(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vectag"] = factory();
	else
		root["vectag"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/index.js ***!
  \********************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: radians, degrees */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "./node_modules/d3-dispatch/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-dispatch/src/index.js ***!
  \***********************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassive"])
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view)
      .on("mousemove.drag", mousemoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"])
      .on("mouseup.drag", mouseupped, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"]);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(event.view, mousemoving);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"]("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-drag/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/index.js ***!
  \*******************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _drag_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });





/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nonpassive, nonpassivecapture, nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassive", function() { return nonpassive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassivecapture", function() { return nonpassivecapture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-(--t)) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-t) * Math.sin((s - t) / p)
        : 2 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


function expIn(t) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - +t);
}

function expOut(t) {
  return 1 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - t) : 2 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t - 1)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/index.js ***!
  \*******************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _linear_js__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _cubic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic.js */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _poly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./poly.js */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _sin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sin.js */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _exp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exp.js */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circle.js */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _bounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bounce.js */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _back_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./back.js */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _elastic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elastic.js */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });






















/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
const linear = t => +t;


/***/ }),

/***/ "./node_modules/d3-ease/src/math.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/math.js ***!
  \******************************************/
/*! exports provided: tpmt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tpmt", function() { return tpmt; });
// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default, genericArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genericArray", function() { return genericArray; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return (Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_1__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/discrete.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/discrete.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hue.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hue.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["hue"])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/index.js ***!
  \**************************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateNumberArray, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _value_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _array_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _date_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "./node_modules/d3-interpolate/src/discrete.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return _discrete_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "./node_modules/d3-interpolate/src/hue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return _hue_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _number_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _object_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _round_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _string_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformSvg"]; });

/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasisClosed"]; });

/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["hslLong"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["hclLong"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["cubehelixLong"]; });

/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _piecewise_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _quantize_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });
























/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/*! exports provided: default, isNumberArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumberArray", function() { return isNumberArray; });
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"] : Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_6__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_8__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__["genericArray"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ __webpack_exports__["default"] = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return array; });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return Object(_select_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/index.js ***!
  \************************************************/
/*! exports provided: create, creator, local, matcher, namespace, namespaces, pointer, pointers, select, selectAll, selection, selector, selectorAll, style, window */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create.js */ "./node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _creator_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local.js */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _local_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _namespace_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _namespaces_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointer", function() { return _pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _pointers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pointers.js */ "./node_modules/d3-selection/src/pointers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointers", function() { return _pointers_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _select_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _selectAll_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _selection_index_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector.js */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _selector_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _selection_style_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _selection_style_js__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./window.js */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _window_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });


















/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default, childMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "childMatcher", function() { return childMatcher; });
/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
});


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(event, node) {
  event = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointers.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/pointers.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(events, node) {
  if (events.target) { // i.e., instanceof Event, not TouchList or iterable
    events = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(events);
    if (node === undefined) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, event => Object(_pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event, node));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ __webpack_exports__["default"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return !this.node();
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function*() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(lower);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Array.from(this);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(raise);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(remove);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = Object(_selectorAll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(update) {
  return new Array(update.length);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),

/***/ "./node_modules/d3-timer/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/index.js ***!
  \********************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timeout.js */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _timeout_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _interval_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });








/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? Object(_timer_js__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"];
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return this.each(function() {
    Object(_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]
      : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");



var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["default"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        string1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["set"])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_3__["tweenValue"])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(_tween_js__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity, ZoomTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["Transform"]; });





/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved(event) {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(event.view, g.moved);
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
});


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/jsts/dist/jsts.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * @license
 */
!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class n extends Error{constructor(t){super(t),this.name=Object.keys({Exception:n})[0]}toString(){return this.message}}class s extends n{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:s})[0]}}class i{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function r(){}function o(){}function l(){}function a(){}function c(){}r.NaN=NaN,r.isNaN=t=>Number.isNaN(t),r.isInfinite=t=>!Number.isFinite(t),r.MAX_VALUE=Number.MAX_VALUE,r.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,r.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,e=new Float64Array(1),n=new Int32Array(e.buffer);r.doubleToLongBits=function(s){e[0]=s;let r=0|n[0],o=0|n[1];return(o&t)===t&&0!=(1048575&o)&&0!==r&&(r=0,o=2146959360),new i(o,r)},r.longBitsToDouble=function(t){return n[0]=t.low,n[1]=t.high,e[0]}}():function(){const t=1023,e=Math.log2,n=Math.floor,s=Math.pow,o=function(){for(let t=53;t>0;t--){const i=s(2,t)-1;if(n(e(i))+1===t)return i}return 0}();r.doubleToLongBits=function(r){let l,a,c,h,u,g,d,_,p;if(r<0||1/r===Number.NEGATIVE_INFINITY?(g=1<<31,r=-r):g=0,0===r)return p=0,_=g,new i(_,p);if(r===1/0)return p=0,_=2146435072|g,new i(_,p);if(r!=r)return p=0,_=2146959360,new i(_,p);if(h=0,p=0,l=n(r),l>1)if(l<=o)h=n(e(l)),h<=20?(p=0,_=l<<20-h&1048575):(c=h-20,a=s(2,c),p=l%a<<32-c,_=l/a&1048575);else for(c=l,p=0;a=c/2,c=n(a),0!==c;)h++,p>>>=1,p|=(1&_)<<31,_>>>=1,a!==c&&(_|=524288);if(d=h+t,u=0===l,l=r-l,h<52&&0!==l)for(c=0;;){if(a=2*l,a>=1?(l=a-1,u?(d--,u=!1):(c<<=1,c|=1,h++)):(l=a,u?0==--d&&(h++,u=!1):(c<<=1,h++)),20===h)_|=c,c=0;else if(52===h){p|=c;break}if(1===a){h<20?_|=c<<20-h:h<52&&(p|=c<<52-h);break}}return _|=d<<20,_|=g,new i(_,p)},r.longBitsToDouble=function(e){let n,i,r,o;const l=e.high,a=e.low,c=l&1<<31?-1:1;for(r=((2146435072&l)>>20)-t,o=0,i=1<<19,n=1;n<=20;n++)l&i&&(o+=s(2,-n)),i>>>=1;for(i=1<<31,n=21;n<=52;n++)a&i&&(o+=s(2,-n)),i>>>=1;if(-1023===r){if(0===o)return 0*c;r=-1022}else{if(1024===r)return 0===o?c/0:NaN;o+=1}return c*o*s(2,r)}}();class h extends n{constructor(t){super(t),this.name=Object.keys({RuntimeException:h})[0]}}class u extends h{constructor(){super(),u.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)h.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}}}class g{static shouldNeverReachHere(){if(0===arguments.length)g.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new u("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];g.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new u:new u(t)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];g.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new u("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}const d=new ArrayBuffer(8),_=new Float64Array(d),p=new Int32Array(d);class m{constructor(){m.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)m.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];m.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return _[0]=t,p[0]^p[1]}getM(){return r.NaN}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.setZ(e);break;default:throw new s("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}setM(t){throw new s("Invalid ordinate index: "+m.M)}getZ(){return this.z}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ()}throw new s("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||r.isNaN(this.getZ())&&r.isNaN(t.getZ()))}equals(t){return t instanceof m&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.getZ(),t.getZ(),n)}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return g.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new m(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+s*s)}getY(){return this.y}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this.x),t=37*t+m.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[o,l,c]}}class f{constructor(){f.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)f.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new s("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0}compare(t,e){const n=f.compare(t.x,e.x);if(0!==n)return n;const s=f.compare(t.y,e.y);if(0!==s)return s;if(this._dimensionsToTest<=2)return 0;return f.compare(t.getZ(),e.getZ())}get interfaces_(){return[a]}}m.DimensionalComparator=f,m.NULL_ORDINATE=r.NaN,m.X=0,m.Y=1,m.Z=2,m.M=3;class y extends m{constructor(){super(),y.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)m.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof y){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case y.X:this.x=e;break;case y.Y:this.y=e;break;default:throw new s("Invalid ordinate index: "+t)}}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case y.X:return this.x;case y.Y:return this.y}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new y(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}}y.X=0,y.Y=1,y.Z=-1,y.M=-1;class x extends m{constructor(){super(),x.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof x){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];m.constructor_.call(this,t,e,m.NULL_ORDINATE),this._m=n}}getM(){return this._m}setOrdinate(t,e){switch(t){case x.X:this.x=e;break;case x.Y:this.y=e;break;case x.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case x.X:return this.x;case x.Y:return this.y;case x.M:return this._m}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new x(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}x.X=0,x.Y=1,x.Z=-1,x.M=2;class E extends m{constructor(){super(),E.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof E){const t=arguments[0];m.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];m.constructor_.call(this,t,e,n),this._m=s}}getM(){return this._m}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.z=e;break;case m.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ();case m.M:return this.getM()}throw new s("Invalid ordinate index: "+t)}copy(){return new E(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}function I(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}class N{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class w extends n{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:w})[0]}}class C extends N{get(){}set(){}isEmpty(){}}class S extends n{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:S})[0]}}class L extends C{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}get interfaces_(){return[C,N]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new T(this)}get(t){if(t<0||t>=this.size())throw new w;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort(((e,n)=>t.compare(e,n))):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}let T=class{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new S;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}};class R extends L{constructor(){super(),R.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&I(arguments[0],N)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){if(0===arguments.length)return this.toArray(R.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(R.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof m&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}}R.coordArrayType=new Array(0).fill(null);class P{filter(t,e){}isDone(){}isGeometryChanged(){}}class O{constructor(){O.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof O))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new O;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new O(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof m){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new O(this)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new m((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this._minx),t=37*t+m.hashCode(this._maxx),t=37*t+m.hashCode(this._miny),t=37*t+m.hashCode(this._maxy),t}get interfaces_(){return[o,c]}}class v{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class b{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new b(t)}}class M{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class D extends n{constructor(t){super(t),this.name=Object.keys({IllegalStateException:D})[0]}}class A{constructor(){A.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof A){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];A.constructor_.call(this,A.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return A.determinant(A.valueOf(t),A.valueOf(e),A.valueOf(n),A.valueOf(s))}if(arguments[3]instanceof A&&arguments[2]instanceof A&&arguments[0]instanceof A&&arguments[1]instanceof A){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return A.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return A.parse(t)}if("number"==typeof arguments[0]){return new A(arguments[0])}}static sqrt(t){return A.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;M.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new A;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,M.isDigit(n)){const t=n-"0";i.selfMultiply(A.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=b.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=i;a||(o=r);const h=r-o-l;if(0===h)c=i;else if(h>0){const t=A.TEN.pow(h);c=i.divide(t)}else if(h<0){const t=A.TEN.pow(-h);c=i.multiply(t)}return s?c.negate():c}static createNaN(){return new A(r.NaN,r.NaN)}static copy(t){return new A(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new v;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=A.magnitude(n._hi);const i=A.TEN.pow(s);n=n.divide(i),n.gt(A.TEN)?(n=n.divide(A.TEN),s+=1):n.lt(A.ONE)&&(n=n.multiply(A.TEN),s-=1);const r=s+1,o=new v,l=A.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(A.valueOf(s)).multiply(A.TEN),i&&n.selfAdd(A.TEN);let c=!0;const h=A.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof A){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof A){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof A){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=A.SPLIT*o,n=l-o,c=A.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof A){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=A.SPLIT*r,e=o-r,a=A.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new A(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?A.createNaN():A.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return A.valueOf(1);let e=new A(this),n=A.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return A.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new A(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof A){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return A.valueOf(0);if(this.isNegative())return A.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=A.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=A.SPLIT*this._hi,n=o-this._hi,l=A.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return A.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new A(t,e)}negate(){return this.isNaN()?this:new A(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof A){const t=arguments[0];return t.isNaN()?A.createNaN():A.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?A.createNaN():A.copy(this).selfMultiply(t,0)}}isNaN(){return r.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=A.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+A.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+A.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=A.SPLIT*i,t=r-i,l=A.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new A(a,i-a+r)}toSciNotation(){if(this.isZero())return A.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=A.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new D("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?A.NaN:this.isNegative()?this.negate():new A(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof A){const t=arguments[0];return A.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return A.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof A){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?A.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[c,o,l]}}A.PI=new A(3.141592653589793,12246467991473532e-32),A.TWO_PI=new A(6.283185307179586,24492935982947064e-32),A.PI_2=new A(1.5707963267948966,6123233995736766e-32),A.E=new A(2.718281828459045,14456468917292502e-32),A.NaN=new A(r.NaN,r.NaN),A.EPS=123259516440783e-46,A.SPLIT=134217729,A.MAX_PRINT_DIGITS=32,A.TEN=A.valueOf(10),A.ONE=A.valueOf(1),A.SCI_NOT_EXPONENT_CHAR="E",A.SCI_NOT_ZERO="0.0E0";class F{static orientationIndex(t,e,n){const s=F.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=A.valueOf(e.x).selfAdd(-t.x),r=A.valueOf(e.y).selfAdd(-t.y),o=A.valueOf(n.x).selfAdd(-e.x),l=A.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof A&&arguments[2]instanceof A&&arguments[0]instanceof A&&arguments[1]instanceof A){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=A.valueOf(t),r=A.valueOf(e),o=A.valueOf(n),l=A.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=new A(t.y).selfSubtract(e.y),o=new A(e.x).selfSubtract(t.x),l=new A(t.x).selfMultiply(e.y).selfSubtract(new A(e.x).selfMultiply(t.y)),a=new A(n.y).selfSubtract(s.y),c=new A(s.x).selfSubtract(n.x),h=new A(n.x).selfMultiply(s.y).selfSubtract(new A(s.x).selfMultiply(n.y)),u=o.multiply(h).selfSubtract(c.multiply(l)),g=a.multiply(l).selfSubtract(i.multiply(h)),d=i.multiply(c).selfSubtract(a.multiply(o)),_=u.selfDivide(d).doubleValue(),p=g.selfDivide(d).doubleValue();return r.isNaN(_)||r.isInfinite(_)||r.isNaN(p)||r.isInfinite(p)?null:new m(_,p)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return F.signum(o);s=i+r}else{if(!(i<0))return F.signum(o);if(r>=0)return F.signum(o);s=-i-r}const l=F.DP_SAFE_EPSILON*s;return o>=l||-o>=l?F.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}F.DP_SAFE_EPSILON=1e-15;class G{getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return r.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):r.NaN}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}get interfaces_(){return[l]}}G.X=0,G.Y=1,G.Z=2,G.M=3;class q{static index(t,e,n){return F.orientationIndex(t,e,n)}static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(n)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(n)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(n)||a.equals2D(n)||l.equals2D(a))return!1;const c=q.index(l,n,a);let h=null;return h=0===c?l.x>a.x:c>0,h}if(I(arguments[0],G)){const t=arguments[0],e=t.size()-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let r=null,o=i;do{o-=1,o<0&&(o=e),r=t.getCoordinate(o)}while(r.equals2D(n)&&o!==i);let l=null,a=i;do{a=(a+1)%e,l=t.getCoordinate(a)}while(l.equals2D(n)&&a!==i);if(r.equals2D(n)||l.equals2D(n)||r.equals2D(l))return!1;const c=q.index(r,n,l);let h=null;return h=0===c?r.x>l.x:c>0,h}}}q.CLOCKWISE=-1,q.RIGHT=q.CLOCKWISE,q.COUNTERCLOCKWISE=1,q.LEFT=q.COUNTERCLOCKWISE,q.COLLINEAR=0,q.STRAIGHT=q.COLLINEAR;class B{static intersection(t,e,n,s){const i=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((i>c?i:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2,p=t.x-d,f=t.y-_,y=e.x-d,x=e.y-_,E=n.x-d,I=n.y-_,N=s.x-d,w=s.y-_,C=f-x,S=y-p,L=p*x-y*f,T=I-w,R=N-E,P=E*w-N*I,O=C*R-T*S,v=(S*P-R*L)/O,b=(T*L-C*P)/O;return r.isNaN(v)||r.isInfinite(v)||r.isNaN(b)||r.isInfinite(b)?null:new m(v+d,b+_)}}class Y{static arraycopy(t,e,n,s,i){let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class V{static log10(t){const e=Math.log(t);return r.isInfinite(e)||r.isNaN(e)?e:e/V.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let s=arguments[0];return t>s&&(s=t),e>s&&(s=e),n>s&&(s=n),s}}static average(t,e){return(t+e)/2}}V.LOG_10=Math.log(10);class z{static segmentToSegment(t,e,n,s){if(t.equals(e))return z.pointToSegment(t,n,s);if(n.equals(s))return z.pointToSegment(s,t,e);let i=!1;if(O.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?V.min(z.pointToSegment(t,n,s),z.pointToSegment(e,n,s),z.pointToSegment(n,t,e),z.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new s("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let s=0;s<e.length-1;s++){const i=z.pointToSegment(t,e[s],e[s+1]);i<n&&(n=i)}return n}}class X{create(){if(1===arguments.length)arguments[0]instanceof Array||I(arguments[0],G);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class k{filter(t){}}class U{constructor(){U.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===U.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(U.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===U.TYPECODE_GEOMETRYCOLLECTION)throw new s("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new O(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[l,o,c]}getClass(){return U}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}U.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},U.TYPECODE_POINT=0,U.TYPECODE_MULTIPOINT=1,U.TYPECODE_LINESTRING=2,U.TYPECODE_LINEARRING=3,U.TYPECODE_MULTILINESTRING=4,U.TYPECODE_POLYGON=5,U.TYPECODE_MULTIPOLYGON=6,U.TYPECODE_GEOMETRYCOLLECTION=7,U.TYPENAME_POINT="Point",U.TYPENAME_MULTIPOINT="MultiPoint",U.TYPENAME_LINESTRING="LineString",U.TYPENAME_LINEARRING="LinearRing",U.TYPENAME_MULTILINESTRING="MultiLineString",U.TYPENAME_POLYGON="Polygon",U.TYPENAME_MULTIPOLYGON="MultiPolygon",U.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",U.geometryChangedFilter={get interfaces_(){return[k]},filter(t){t.geometryChangedAction()}};class H{filter(t){}}class W{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new m;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}}class Z{}class j{static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,G.X)===t.getOrdinate(e-1,G.X)&&t.getOrdinate(0,G.Y)===t.getOrdinate(e-1,G.Y))}static scroll(){if(2===arguments.length){if(I(arguments[0],G)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];j.scroll(t,e,j.isRing(t))}else if(I(arguments[0],G)&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=j.indexOf(e,t);if(n<=0)return null;j.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const s=t.copy(),i=n?t.size()-1:t.size();for(let n=0;n<i;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,s.getOrdinate((e+n)%i,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(i,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let i=0;i<n;i++)for(let n=0;n<s;n++){const s=t.getOrdinate(i,n),o=e.getOrdinate(i,n);if(t.getOrdinate(i,n)!==e.getOrdinate(i,n)&&(!r.isNaN(s)||!r.isNaN(o)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return j.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,s=null;for(let i=arguments[1];i<=e;i++){const e=t.getCoordinate(i);(null===s||s.compareTo(e)>0)&&(s=e,n=i)}return n}}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(j.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)j.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)j.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)j.copyCoord(t,e+r,n,s+r)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return j.createClosedRing(t,e,4);return e.getOrdinate(0,G.X)===e.getOrdinate(n-1,G.X)&&e.getOrdinate(0,G.Y)===e.getOrdinate(n-1,G.Y)?e:j.createClosedRing(t,e,n+1)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,G.X)&&t.y===e.getOrdinate(n,G.Y))return n;return-1}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();j.copy(e,0,s,0,i);for(let t=i;t<n;t++)j.copy(e,0,s,t,1);return s}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const s=t.getCoordinate(n);(null===e||e.compareTo(s)>0)&&(e=s)}return e}}class K extends n{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:K})[0]}}class Q{static toDimensionSymbol(t){switch(t){case Q.FALSE:return Q.SYM_FALSE;case Q.TRUE:return Q.SYM_TRUE;case Q.DONTCARE:return Q.SYM_DONTCARE;case Q.P:return Q.SYM_P;case Q.L:return Q.SYM_L;case Q.A:return Q.SYM_A}throw new s("Unknown dimension value: "+t)}static toDimensionValue(t){switch(M.toUpperCase(t)){case Q.SYM_FALSE:return Q.FALSE;case Q.SYM_TRUE:return Q.TRUE;case Q.SYM_DONTCARE:return Q.DONTCARE;case Q.SYM_P:return Q.P;case Q.SYM_L:return Q.L;case Q.SYM_A:return Q.A}throw new s("Unknown dimension symbol: "+t)}}Q.P=0,Q.L=1,Q.A=2,Q.FALSE=-1,Q.TRUE=-2,Q.DONTCARE=-3,Q.SYM_FALSE="F",Q.SYM_TRUE="T",Q.SYM_DONTCARE="*",Q.SYM_P="0",Q.SYM_L="1",Q.SYM_A="2";class J{filter(t){}}class $ extends U{constructor(){super(),$.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new O:this._points.expandEnvelope(new O)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new $(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();j.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?Q.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return j.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return U.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return W.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(I(arguments[0],H)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){throw new K}isEquivalentClass(t){return t instanceof $}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return U.TYPENAME_LINESTRING}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new s("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}get interfaces_(){return[Z]}}class tt{}class et extends U{constructor(){super(),et.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new O;const t=new O;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new et(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return Q.FALSE}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return U.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new D("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(I(arguments[0],H)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(I(arguments[0],P)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return U.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new D("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),g.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}get interfaces_(){return[tt]}}class nt{static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(nt.ofRingSigned(t))}if(I(arguments[0],G)){const t=arguments[0];return Math.abs(nt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(I(arguments[0],G)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new m,s=new m,i=new m;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}}class st{static sort(){const t=arguments[0];if(1===arguments.length)t.sort(((t,e)=>t.compareTo(e)));else if(2===arguments.length)t.sort(((t,e)=>arguments[1].compare(t,e)));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort(((t,e)=>arguments[3].compare(t,e)));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new L;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class it{}class rt extends U{constructor(){super(),rt.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(U.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),U.hasNullElements(e))throw new s("holes must not contain null elements");if(t.isEmpty()&&U.hasNonEmptyElements(e))throw new s("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=nt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=nt.ofRing(this._holes[e].getCoordinateSequence());return t}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new rt(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);st.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),s=j.minCoordinateIndex(n,0,n.size()-2);j.scroll(n,s,!0),q.isCCW(n)===e&&j.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return U.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,s=e._shell,i=n.compareToSameClass(s,t);if(0!==i)return i;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),s=e.getInteriorRingN(l),i=n.compareToSameClass(s,t);if(0!==i)return i;l++}return l<r?1:l<o?-1:0}}apply(){if(I(arguments[0],H)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return U.TYPENAME_POLYGON}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[it]}}class ot extends N{contains(){}}class lt extends ot{}class at extends lt{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new K}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new ct(this.array)}}let ct=class{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new S;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new K}};class ht extends U{constructor(){super(),ht.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(U.constructor_.call(this,e),null===t&&(t=[]),U.hasNullElements(t))throw new s("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new O;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ht(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();st.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=Q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}reverseInternal(){const t=this._geometries.length,e=new L(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return U.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=Q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new at(st.asList(this._geometries)),n=new at(st.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),s=e.getNumGeometries();let i=0;for(;i<n&&i<s;){const n=this.getGeometryN(i),s=e.getGeometryN(i),r=n.compareToSameClass(s,t);if(0!==r)return r;i++}return i<n?1:i<s?-1:0}}apply(){if(I(arguments[0],H)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return U.checkNotGeometryCollection(this),g.shouldNeverReachHere(),null}getGeometryType(){return U.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}}class ut extends ht{constructor(){super(),ut.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ut(t,this._factory)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return Q.FALSE}getTypeCode(){return U.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return U.TYPENAME_MULTIPOINT}get interfaces_(){return[tt]}}class gt extends ${constructor(){super(),gt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];$.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new gt(this._points.copy(),this._factory)}getBoundaryDimension(){return Q.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return j.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return U.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new s("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<gt.MINIMUM_VALID_SIZE)throw new s("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return U.TYPENAME_LINEARRING}}gt.MINIMUM_VALID_SIZE=4;class dt{static measures(t){return t instanceof y?0:t instanceof x||t instanceof E?1:0}static dimension(t){return t instanceof y?2:t instanceof x?3:t instanceof E?4:3}static create(){if(1===arguments.length){const t=arguments[0];return dt.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new y:3===t&&0===e?new m:3===t&&1===e?new x:4===t&&1===e?new E:new m}}}class _t{static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(_t.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=_t.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);Y.arraycopy(t,n,s,0,t.length-n),Y.arraycopy(t,0,s,t.length-n,n),Y.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new R;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,dt.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!_t.hasRepeatedPoints(t))return t;return new R(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new O;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(_t.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,dt.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=V.clamp(e,0,t.length);let s=(n=V.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}}_t.ForwardComparator=class{compare(t,e){const n=t,s=e;return _t.compare(n,s)}get interfaces_(){return[a]}},_t.BidirectionalComparator=class{compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=_t.compare(n,s);return _t.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=_t.increasingDirection(n),r=_t.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}get interfaces_(){return[a]}},_t.coordArrayType=new Array(0).fill(null);class pt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class mt{constructor(){mt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];mt.constructor_.call(this,t,_t.dimension(t),_t.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new m}else if(I(arguments[0],G)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];mt.constructor_.call(this,t,e,_t.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=dt.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getM(t){return this.hasM()?this._coordinates[t].getM():r.NaN}setOrdinate(t,e,n){switch(e){case G.X:this._coordinates[t].x=n;break;case G.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():r.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case G.X:return this._coordinates[t].x;case G.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return dt.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new mt(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new pt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}get interfaces_(){return[G,c]}}class ft{static instance(){return ft.instanceObject}readResolve(){return ft.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new mt(arguments[0])}if(I(arguments[0],G)){return new mt(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new mt(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new mt(arguments[0],e+t,t)}}}get interfaces_(){return[X,c]}}ft.instanceObject=new ft;class yt extends ht{constructor(){super(),yt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new yt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return U.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new L;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return U.TYPENAME_MULTIPOLYGON}get interfaces_(){return[it]}}let xt=class{get(){}put(){}size(){}values(){}entrySet(){}};class Et extends ot{constructor(t){super(),this.map=new Map,t instanceof N&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new K}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new It(this.map)}[Symbol.iterator](){return this.map}}let It=class{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new S;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new K}};class Nt extends xt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new L,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new Et;return this.map.entries().forEach((e=>t.add(e))),t}size(){return this.map.size()}}class wt{constructor(){wt.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=wt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Ct){const t=arguments[0];this._modelType=t,t===wt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=wt.FIXED,this.setScale(t)}else if(arguments[0]instanceof wt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof wt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return b.compare(n,s)}getScale(){return this._scale}isFloating(){return this._modelType===wt.FLOATING||this._modelType===wt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===wt.FLOATING?t="Floating":this._modelType===wt.FLOATING_SINGLE?t="Floating-Single":this._modelType===wt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(r.isNaN(t))return t;if(this._modelType===wt.FLOATING_SINGLE){return t}return this._modelType===wt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof m){const t=arguments[0];if(this._modelType===wt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===wt.FLOATING?t=16:this._modelType===wt.FLOATING_SINGLE?t=6:this._modelType===wt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}get interfaces_(){return[c,o]}}class Ct{constructor(){Ct.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,Ct.nameToTypeMap.put(t,this)}readResolve(){return Ct.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[c]}}Ct.nameToTypeMap=new Nt,wt.Type=Ct,wt.FIXED=new Ct("FIXED"),wt.FLOATING=new Ct("FLOATING"),wt.FLOATING_SINGLE=new Ct("FLOATING SINGLE"),wt.maximumPreciseValue=9007199254740992;class St extends ht{constructor(){super(),St.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new St(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?Q.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return U.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new K}getGeometryType(){return U.TYPENAME_MULTILINESTRING}get interfaces_(){return[Z]}}class Lt{constructor(){Lt.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Lt.constructor_.call(this,new wt,0);else if(1===arguments.length){if(I(arguments[0],X)){const t=arguments[0];Lt.constructor_.call(this,new wt,0,t)}else if(arguments[0]instanceof wt){const t=arguments[0];Lt.constructor_.call(this,t,0,Lt.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Lt.constructor_.call(this,t,e,Lt.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return ft.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new s("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new m(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new m(t.getMinX(),t.getMinY()),new m(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new m(t.getMinX(),t.getMinY()),new m(t.getMinX(),t.getMaxY()),new m(t.getMaxX(),t.getMaxY()),new m(t.getMaxX(),t.getMinY()),new m(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],G)){return new $(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new St(null,this);if(1===arguments.length){return new St(arguments[0],this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof ht&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Lt.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof rt)return this.createMultiPolygon(Lt.toPolygonArray(t));if(i instanceof $)return this.createMultiLineString(Lt.toLineStringArray(t));if(i instanceof et)return this.createMultiPoint(Lt.toPointArray(t));g.shouldNeverReachHere("Unhandled geometry type: "+i.getGeometryType())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(I(arguments[0],G)){return new et(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(I(arguments[0],G)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof gt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new rt(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new ht(null,this);if(1===arguments.length){return new ht(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],G)){return new gt(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new yt(null,this);if(1===arguments.length){return new yt(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new ut(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new ut(arguments[0],this)}if(I(arguments[0],G)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());j.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}get interfaces_(){return[c]}}const Tt="XY",Rt="XYZ",Pt="XYM",Ot="XYZM",vt={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},bt="EMPTY",Mt=1,Dt=2,At=3,Ft=4,Gt=5,qt=6;for(const t in vt)vt[t].toUpperCase();class Bt{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,s=t;if("("==t)n=Dt;else if(","==t)n=Gt;else if(")"==t)n=At;else if(this.isNumeric_(t)||"-"==t)n=Ft,s=this.readNumber_();else if(this.isAlpha_(t))n=Mt,s=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=qt}return{position:e,value:s,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,s=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(s=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!s&&("e"==t||"E"==t)||s&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class Yt{constructor(t,e){this.lexer_=t,this.token_,this.layout_=Tt,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){this.consume_();return this.parseGeometry_()}parseGeometryLayout_(){let t=Tt;const e=this.token_;if(this.isTokenType(Mt)){const n=e.value;"Z"===n?t=Rt:"M"===n?t=Pt:"ZM"===n&&(t=Ot),t!==Tt&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(Dt)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(Gt));if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(Dt)){const t=this.parsePoint_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(Dt)){const t=this.parsePointList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(Dt)){const t=this.parseLineStringTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(Dt)){let t;if(t=this.token_.type==Dt?this.parsePointTextList_():this.parsePointList_(),this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(Dt)){const t=this.parseLineStringTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(Dt)){const t=this.parsePolygonTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(Ft))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(Gt);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(Gt);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(Gt);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(Gt);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(Mt)&&this.token_.value==bt;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>new m(...t),n=n=>{const s=n.map((n=>t.createLinearRing(n.map(e))));return s.length>1?t.createPolygon(s[0],s.slice(1)):t.createPolygon(s[0])},s=this.token_;if(this.match(Mt)){const i=s.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==i){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(i){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new m(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const s=n.map(e).map((e=>t.createPoint(e)));return t.createMultiPoint(s)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map((n=>t.createLineString(n.map(e))));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const s=e.map(n);return t.createMultiPolygon(s)}default:throw new Error("Invalid geometry type: "+i)}}throw new Error(this.formatErrorMessage_())}}function Vt(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return void 0===e.z||Number.isNaN(e.z)||n.push(e.z),void 0===e.m||Number.isNaN(e.m)||n.push(e.m),n.join(" ")}function zt(t){const e=t.getCoordinates().map((t=>{const e=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||e.push(t.z),void 0===t.m||Number.isNaN(t.m)||e.push(t.m),e})),n=[];for(let t=0,s=e.length;t<s;++t)n.push(e[t].join(" "));return n.join(", ")}function Xt(t){const e=[];e.push("("+zt(t.getExteriorRing())+")");for(let n=0,s=t.getNumInteriorRing();n<s;++n)e.push("("+zt(t.getInteriorRingN(n))+")");return e.join(", ")}const kt={Point:Vt,LineString:zt,LinearRing:zt,Polygon:Xt,MultiPoint:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Vt(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+zt(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Xt(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push(Ut(t.getGeometryN(n)));return e.join(", ")}};function Ut(t){let e=t.getGeometryType();const n=kt[e];e=e.toUpperCase();const s=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return void 0===n.z||Number.isNaN(n.z)||(e+="Z"),void 0===n.m||Number.isNaN(n.m)||(e+="M"),e}(t);if(s.length>0&&(e+=" "+s),t.isEmpty())return e+" "+bt;return e+" ("+n(t)+")"}class Ht{constructor(t){this.geometryFactory=t||new Lt,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new Bt(t);return new Yt(e,this.geometryFactory).parse()}write(t){return Ut(t)}}class Wt{constructor(t){this.parser=new Ht(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class Zt{constructor(){Zt.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map((()=>Array(2))),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new m,this._intPt[1]=new m,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return g.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return g.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new pt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map((()=>Array(2))),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Zt.NO_INTERSECTION}getEdgeDistance(t,e){return Zt.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Zt.COLLINEAR_INTERSECTION}toString(){return Wt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Wt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Zt.DONT_INTERSECT=0,Zt.DO_INTERSECT=1,Zt.COLLINEAR=2,Zt.NO_INTERSECTION=0,Zt.POINT_INTERSECTION=1,Zt.COLLINEAR_INTERSECTION=2;class jt extends Zt{constructor(){super()}static nearestEndpoint(t,e,n,s){let i=t,r=z.pointToSegment(t,n,s),o=z.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=z.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=z.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new O(this._inputLines[0][0],this._inputLines[0][1]),n=new O(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,O.intersects(e,n,t)&&0===q.index(e,n,t)&&0===q.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Zt.POINT_INTERSECTION,null;this._result=Zt.NO_INTERSECTION}}intersection(t,e,n,s){let i=this.intersectionSafe(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new m(jt.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}checkDD(t,e,n,s,i){const r=F.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);Y.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&Y.out.println("Distance = "+i.distance(r))}intersectionSafe(t,e,n,s){let i=B.intersection(t,e,n,s);return null===i&&(i=jt.nearestEndpoint(t,e,n,s)),i}computeCollinearIntersection(t,e,n,s){const i=O.intersects(t,e,n),r=O.intersects(t,e,s),o=O.intersects(n,s,t),l=O.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,Zt.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Zt.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):Zt.NO_INTERSECTION}computeIntersect(t,e,n,s){if(this._isProper=!1,!O.intersects(t,e,n,s))return Zt.NO_INTERSECTION;const i=q.index(t,e,n),r=q.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return Zt.NO_INTERSECTION;const o=q.index(n,s,t),l=q.index(n,s,e);if(o>0&&l>0||o<0&&l<0)return Zt.NO_INTERSECTION;return 0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new m(n):0===r?this._intPt[0]=new m(s):0===o?this._intPt[0]=new m(t):0===l&&(this._intPt[0]=new m(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),Zt.POINT_INTERSECTION)}}class Kt{constructor(){Kt.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)Kt.constructor_.call(this,new m,new m);else if(1===arguments.length){const t=arguments[0];Kt.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,new m(t,e),new m(n,s))}}static midPoint(t,e){return new m((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof Kt){const t=arguments[0],e=q.index(this.p0,this.p1,t.p0),n=q.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof m){const t=arguments[0];return q.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof Kt))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new jt;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof m){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new m(t);const e=this.projectionFactor(t),n=new m;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof Kt){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new Kt(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return z.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return Kt.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;if(s<=0)return r.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=r.MAX_VALUE,i=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);i=l.distance(t.p1),i<s&&(s=i,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);i=a.distance(this.p0),i<s&&(s=i,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return i=c.distance(this.p1),i<s&&(s=i,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return B.intersection(this.p0,this.p1,t.p0,t.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new D("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new m(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||r.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),s=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),i=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new m((-r*o-2*e*n*l-2*e*s)/i,(r*l-2*e*n*o-2*n*s)/i)}distance(){if(arguments[0]instanceof Kt){const t=arguments[0];return z.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof m){const t=arguments[0];return z.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new m;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=r.doubleToLongBits(this.p0.x);t^=31*r.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=r.doubleToLongBits(this.p1.x);n^=31*r.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))}get interfaces_(){return[o,c]}}class Qt{static toLocationSymbol(t){switch(t){case Qt.EXTERIOR:return"e";case Qt.BOUNDARY:return"b";case Qt.INTERIOR:return"i";case Qt.NONE:return"-"}throw new s("Unknown location value: "+t)}}Qt.INTERIOR=0,Qt.BOUNDARY=1,Qt.EXTERIOR=2,Qt.NONE=-1;class Jt{constructor(){Jt.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map((()=>Array(3))),this.setAll(Q.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Jt.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Jt){const t=arguments[0];Jt.constructor_.call(this),this._matrix[Qt.INTERIOR][Qt.INTERIOR]=t._matrix[Qt.INTERIOR][Qt.INTERIOR],this._matrix[Qt.INTERIOR][Qt.BOUNDARY]=t._matrix[Qt.INTERIOR][Qt.BOUNDARY],this._matrix[Qt.INTERIOR][Qt.EXTERIOR]=t._matrix[Qt.INTERIOR][Qt.EXTERIOR],this._matrix[Qt.BOUNDARY][Qt.INTERIOR]=t._matrix[Qt.BOUNDARY][Qt.INTERIOR],this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]=t._matrix[Qt.BOUNDARY][Qt.BOUNDARY],this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]=t._matrix[Qt.BOUNDARY][Qt.EXTERIOR],this._matrix[Qt.EXTERIOR][Qt.INTERIOR]=t._matrix[Qt.EXTERIOR][Qt.INTERIOR],this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]=t._matrix[Qt.EXTERIOR][Qt.BOUNDARY],this._matrix[Qt.EXTERIOR][Qt.EXTERIOR]=t._matrix[Qt.EXTERIOR][Qt.EXTERIOR]}}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===Q.SYM_DONTCARE||(e===Q.SYM_TRUE&&(t>=0||t===Q.TRUE)||(e===Q.SYM_FALSE&&t===Q.FALSE||(e===Q.SYM_P&&t===Q.P||(e===Q.SYM_L&&t===Q.L||e===Q.SYM_A&&t===Q.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Jt(arguments[0]).matches(t)}}static isTrue(t){return t>=0||t===Q.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE}isCoveredBy(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=Q.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,Q.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===Q.A&&e===Q.A||t===Q.L&&e===Q.L||t===Q.L&&e===Q.A||t===Q.P&&e===Q.A||t===Q.P&&e===Q.L)&&(this._matrix[Qt.INTERIOR][Qt.INTERIOR]===Q.FALSE&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY])))}isOverlaps(t,e){return t===Q.P&&e===Q.P||t===Q.A&&e===Q.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===Q.L&&e===Q.L&&(1===this._matrix[Qt.INTERIOR][Qt.INTERIOR]&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]))}isEquals(t,e){return t===e&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE)}toString(){const t=new pt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,Q.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new s("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Jt.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[Qt.INTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.INTERIOR][Qt.BOUNDARY]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]===Q.FALSE}isCrosses(t,e){return t===Q.P&&e===Q.L||t===Q.P&&e===Q.A||t===Q.L&&e===Q.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR]):t===Q.L&&e===Q.P||t===Q.A&&e===Q.P||t===Q.A&&e===Q.L?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===Q.L&&e===Q.L&&0===this._matrix[Qt.INTERIOR][Qt.INTERIOR]}get interfaces_(){return[l]}}class $t{static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=$t.PI_TIMES_2;for(;t<=-Math.PI;)t+=$t.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=$t.PI_TIMES_2;t>=$t.PI_TIMES_2&&(t=0)}else{for(;t>=$t.PI_TIMES_2;)t-=$t.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return $t.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?$t.COUNTERCLOCKWISE:n<0?$t.CLOCKWISE:$t.NONE}static angleBetweenOriented(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n)-s;return i<=-Math.PI?i+$t.PI_TIMES_2:i>Math.PI?i-$t.PI_TIMES_2:i}}$t.PI_TIMES_2=2*Math.PI,$t.PI_OVER_2=Math.PI/2,$t.PI_OVER_4=Math.PI/4,$t.COUNTERCLOCKWISE=q.COUNTERCLOCKWISE,$t.CLOCKWISE=q.CLOCKWISE,$t.NONE=q.COLLINEAR;class te extends n{constructor(){super(),te.constructor_.apply(this,arguments)}static constructor_(){n.constructor_.call(this,"Projective point not representable on the Cartesian plane.")}}class ee{constructor(){ee.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof ee&&arguments[1]instanceof ee){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}}getY(){const t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getX(){const t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getCoordinate(){const t=new m;return t.x=this.getX(),t.y=this.getY(),t}}class ne{constructor(){ne.constructor_.apply(this,arguments)}static constructor_(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static circumcentreDD(t,e,n){const s=A.valueOf(t.x).subtract(n.x),i=A.valueOf(t.y).subtract(n.y),r=A.valueOf(e.x).subtract(n.x),o=A.valueOf(e.y).subtract(n.y),l=A.determinant(s,i,r,o).multiply(2),a=s.sqr().add(i.sqr()),c=r.sqr().add(o.sqr()),h=A.determinant(i,a,o,c),u=A.determinant(s,a,r,c),g=A.valueOf(n.x).subtract(h.divide(l)).doubleValue(),d=A.valueOf(n.y).add(u.divide(l)).doubleValue();return new m(g,d)}static isAcute(t,e,n){return!!$t.isAcute(t,e,n)&&(!!$t.isAcute(e,n,t)&&!!$t.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*ne.det(r,o,l,a),h=ne.det(o,r*r+o*o,a,l*l+a*a),u=ne.det(r,r*r+o*o,l,l*l+a*a);return new m(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new ee(t.x+n/2,t.y+s/2,1),r=new ee(t.x-s+n/2,t.y+n+s/2,1);return new ee(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new m(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.getZ()-t.getZ(),o=n.x-t.x,l=n.y-t.y,a=n.getZ()-t.getZ(),c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new m(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new m(l,a)}area(){return ne.area(this.p0,this.p1,this.p2)}signedArea(){return ne.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new s("Supplied point is null.");return ne.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return ne.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return ne.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return ne.circumcentre(this.p0,this.p1,this.p2)}area3D(){return ne.area3D(this.p0,this.p1,this.p2)}centroid(){return ne.centroid(this.p0,this.p1,this.p2)}inCentre(){return ne.inCentre(this.p0,this.p1,this.p2)}}class se extends n{constructor(){super(),se.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)n.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];n.constructor_.call(this,t)}}}class ie{constructor(){ie.constructor_.apply(this,arguments)}static constructor_(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof ie){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}}static translationInstance(t,e){const n=new ie;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new ie;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return ie.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return ie.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,n,i){if(t===n&&e===i)throw new s("Reflection line points must be distinct");const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new se("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new ie(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof ie))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(ie.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(ie.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(ie.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.rotationInstance(t,e,n,s)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof n))throw t;g.shouldNeverReachHere()}return null}translate(t,e){return this.compose(ie.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const n=Math.sqrt(t*t+e*e),i=e/n,r=t/n;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];if(t===n&&e===i)throw new s("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(ie.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(I(arguments[0],G)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.reflectionInstance(t,e,n,s)),this}}get interfaces_(){return[l,P]}}class re{static solve(t,e){const n=e.length;if(t.length!==n||t[0].length!==n)throw new s("Matrix A is incorrectly sized");for(let s=0;s<n;s++){let i=s;for(let e=s+1;e<n;e++)Math.abs(t[e][s])>Math.abs(t[i][s])&&(i=e);if(0===t[i][s])return null;re.swapRows(t,s,i),re.swapRows(e,s,i);for(let i=s+1;i<n;i++){const r=t[i][s]/t[s][s];for(let e=n-1;e>=s;e--)t[i][e]-=t[s][e]*r;e[i]-=e[s]*r}}const i=new Array(n).fill(null);for(let s=n-1;s>=0;s--){let r=0;for(let e=s+1;e<n;e++)r+=t[s][e]*i[e];i[s]=(e[s]-r)/t[s][s]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}}class oe{constructor(){oe.constructor_.apply(this,arguments)}static constructor_(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return re.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new ie(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}}class le{static createFromBaseLines(t,e,n,s){const i=new m(t.x+s.x-n.x,t.y+s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new ie;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return ie.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new s("Src and Dest arrays are not the same length");if(t.length<=0)throw new s("Too few control points");if(t.length>3)throw new s("Too many control points");return 1===t.length?le.createFromControlVectors(t[0],e[0]):2===t.length?le.createFromControlVectors(t[0],t[1],e[0],e[1]):le.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new m(s.x-n.x,s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){return new oe(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]).getTransformation()}}}}class ae{constructor(){ae.constructor_.apply(this,arguments)}static constructor_(){this._coords=null;const t=arguments[0];this._coords=t}static getCoordinates(t){const e=new L;return t.apply(new ae(e)),e}filter(t){(t instanceof $||t instanceof et)&&this._coords.add(t.getCoordinate())}get interfaces_(){return[k]}}class ce{constructor(){ce.constructor_.apply(this,arguments)}static constructor_(){this._mapOp=null;const t=arguments[0];this._mapOp=t}static map(t,e){return new ce(e).map(t)}map(t){const e=new L;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Lt.toGeometryArray(e))}}class he{constructor(){he.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=he.extractFactory(t),this._inputGeoms=t}static combine(){if(1===arguments.length){return new he(arguments[0]).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new he(he.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new he(he.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new L;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new L;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}}class ue{constructor(){ue.constructor_.apply(this,arguments)}static constructor_(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof ht?this.editGeometryCollection(t,e):t instanceof rt?this.editPolygon(t,e):t instanceof et||t instanceof $?e.edit(t,this._factory):(g.shouldNeverReachHere("Unsupported Geometry type: "+t.getGeometryType()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new L;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getGeometryType()===U.TYPENAME_MULTIPOINT?this._factory.createMultiPoint(s.toArray([])):n.getGeometryType()===U.TYPENAME_MULTILINESTRING?this._factory.createMultiLineString(s.toArray([])):n.getGeometryType()===U.TYPENAME_MULTIPOLYGON?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new L;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}}function ge(){}ue.GeometryEditorOperation=ge;ue.NoOpGeometryOperation=class{edit(t,e){return t}get interfaces_(){return[ge]}},ue.CoordinateOperation=class{edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof gt?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof $?null===n?e.createLineString():e.createLineString(n):t instanceof et?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}get interfaces_(){return[ge]}},ue.CoordinateSequenceOperation=class{edit(t,e){return t instanceof gt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof $?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof et?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}get interfaces_(){return[ge]}};class de{constructor(){de.constructor_.apply(this,arguments)}static constructor_(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e}static isOfType(t,e){return t.getGeometryType()===e||e===U.TYPENAME_LINESTRING&&t.getGeometryType()===U.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return de.extract(t,e,new L)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof ht&&t.apply(new de(e,n)),n}}filter(t){(null===this._geometryType||de.isOfType(t,this._geometryType))&&this._comps.add(t)}get interfaces_(){return[J]}}class _e{static map(){if(arguments[0]instanceof U&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(I(arguments[0],N)&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}}function pe(){}_e.MapOp=pe;class me{constructor(){me.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof gt&&!s.isEmpty()||(n=!1);const i=new L;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof gt||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new L;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Lt.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof et)return this.transformPoint(t,null);if(t instanceof ut)return this.transformMultiPoint(t,null);if(t instanceof gt)return this.transformLinearRing(t,null);if(t instanceof $)return this.transformLineString(t,null);if(t instanceof St)return this.transformMultiLineString(t,null);if(t instanceof rt)return this.transformPolygon(t,null);if(t instanceof yt)return this.transformMultiPolygon(t,null);if(t instanceof ht)return this.transformGeometryCollection(t,null);throw new s("Unknown Geometry subtype: "+t.getGeometryType())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}}class fe{constructor(){fe.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getGeometry(t){return t.getFactory().buildGeometry(fe.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return fe.getLines(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof $?e.add(t):t instanceof ht&&t.apply(new fe(e)),e}}filter(t){t instanceof $&&this._comps.add(t)}get interfaces_(){return[J]}}class ye{constructor(){ye.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(ye.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(ye.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,!1)}if(2===arguments.length){if(I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();ye.getLines(n,t)}return t}if(arguments[0]instanceof U&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new L;return t.apply(new ye(n,e)),n}if(arguments[0]instanceof U&&I(arguments[1],N)){const t=arguments[0],e=arguments[1];return t instanceof $?e.add(t):t.apply(new ye(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const s=n.next();ye.getLines(s,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof U&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new ye(t,e)),t}}}filter(t){if(this._isForcedToLineString&&t instanceof gt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof $&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[k]}}const xe={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return xe.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?st.sort(n,e):st.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new L;return e.add(t),e}};class Ee{constructor(){Ee.constructor_.apply(this,arguments)}static constructor_(){this._pts=null;const t=arguments[0];this._pts=t}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof et?xe.singletonList(t):Ee.getPoints(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof et?e.add(t):t instanceof ht&&t.apply(new Ee(e)),e}}filter(t){t instanceof et&&this._pts.add(t)}get interfaces_(){return[J]}}class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ie.getPolygons(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof rt?e.add(t):t instanceof ht&&t.apply(new Ie(e)),e}}filter(t){t instanceof rt&&this._comps.add(t)}get interfaces_(){return[J]}}class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof ht)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class we{constructor(){we.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._precModel=null,this._dim=new Ce,this._nPts=100,this._rotationAngle=0,0===arguments.length)we.constructor_.call(this,new Lt);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new m(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=ie.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new m(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}}class Ce{constructor(){Ce.constructor_.apply(this,arguments)}static constructor_(){this.base=null,this.centre=null,this.width=null,this.height=null}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new m(t.getMinX(),t.getMinY()),this.centre=new m(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new O(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new O(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new O(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new m(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}}we.Dimensions=Ce;class Se extends we{constructor(){super(),Se.constructor_.apply(this,arguments)}static constructor_(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)we.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];we.constructor_.call(this,t)}}static create(t,e,n,s,i){const r=new Se;r.setCentre(t),r.setSize(e),r.setNumPoints(n),r.setArmLengthRatio(i),r.setNumArms(s);return r.createSineStar()}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new m(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}}var Le=Object.freeze({__proto__:null,AffineTransformation:ie,AffineTransformationBuilder:oe,AffineTransformationFactory:le,ComponentCoordinateExtracter:ae,GeometryCollectionMapper:ce,GeometryCombiner:he,GeometryEditor:ue,GeometryExtracter:de,GeometryMapper:_e,GeometryTransformer:me,LineStringExtracter:fe,LinearComponentExtracter:ye,PointExtracter:Ee,PolygonExtracter:Ie,ShortCircuitedGeometryVisitor:Ne,SineStarFactory:Se}),Te=Object.freeze({__proto__:null,Coordinate:m,CoordinateXY:y,CoordinateXYM:x,CoordinateXYZM:E,CoordinateList:R,CoordinateSequenceFilter:P,Envelope:O,LineSegment:Kt,GeometryFactory:Lt,Geometry:U,Point:et,LineString:$,LinearRing:gt,Polygon:rt,GeometryCollection:ht,MultiPoint:ut,MultiLineString:St,MultiPolygon:yt,Dimension:Q,IntersectionMatrix:Jt,PrecisionModel:wt,Location:Qt,Triangle:ne,util:Le});class Re{constructor(){Re.constructor_.apply(this,arguments)}static constructor_(){this._pt=[new m,new m],this._distance=r.NaN,this._isNull=!0}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Wt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}}class Pe{static computeDistance(){if(arguments[2]instanceof Re&&arguments[0]instanceof $&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Kt,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Re&&arguments[0]instanceof rt&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];Pe.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)Pe.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Re&&arguments[0]instanceof U&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof $)Pe.computeDistance(t,e,n);else if(t instanceof rt)Pe.computeDistance(t,e,n);else if(t instanceof ht){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);Pe.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Re&&arguments[0]instanceof Kt&&arguments[1]instanceof m){const t=arguments[1],e=arguments[2],n=arguments[0].closestPoint(t);e.setMinimum(n,t)}}}class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static constructor_(){this._g0=null,this._g1=null,this._ptDist=new Re,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e}static distance(){if(2===arguments.length){return new Oe(arguments[0],arguments[1]).distance()}if(3===arguments.length){const t=arguments[2],e=new Oe(arguments[0],arguments[1]);return e.setDensifyFraction(t),e.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new s("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new ve(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new be(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}}class ve{constructor(){ve.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._euclideanDist=new Pe,this._geom=null;const t=arguments[0];this._geom=t}filter(t){this._minPtDist.initialize(),Pe.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[H]}}class be{constructor(){be.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new m(e,s);this._minPtDist.initialize(),Pe.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[P]}}Oe.MaxPointDistanceFilter=ve,Oe.MaxDensifiedByFractionDistanceFilter=be;var Me=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:Pe,PointPairDistance:Re});class De{visitItem(t){}}class Ae{locate(t){}}class Fe{constructor(){Fe.constructor_.apply(this,arguments)}static constructor_(){this._min=r.POSITIVE_INFINITY,this._max=r.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Wt.toLineString(new m(this._min,0),new m(this._max,0))}}Fe.NodeComparator=class{compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}get interfaces_(){return[a]}};class Ge extends Fe{constructor(){super(),Ge.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class qe extends Fe{constructor(){super(),qe.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class Be{constructor(){Be.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new L,this._root=null,this._level=0}buildTree(){xe.sort(this._leaves,new Fe.NodeComparator);let t=this._leaves,e=null,n=new L;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new D("Index cannot be added to once it has been queried");this._leaves.add(new Ge(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){Y.out.println(Wt.toLineString(new m(t._min,this._level),new m(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new qe(t.get(n),t.get(n+1));e.add(s)}}}}class Ye{constructor(){Ye.constructor_.apply(this,arguments)}static constructor_(){this._items=new L}visitItem(t){this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class Ve{constructor(){Ve.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof m&&I(arguments[1],G)){const t=arguments[1],e=new Ve(arguments[0]),n=new m,s=new m;for(let i=1;i<t.size();i++)if(t.getCoordinate(i,n),t.getCoordinate(i-1,s),e.countSegment(n,s),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[1],e=new Ve(arguments[0]);for(let n=1;n<t.length;n++){const s=t[n],i=t[n-1];if(e.countSegment(s,i),e.isOnSegment())return e.getLocation()}return e.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=q.index(t,e,this._p);if(n===q.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===q.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==Qt.EXTERIOR}getLocation(){return this._isPointOnSegment?Qt.BOUNDARY:this._crossingCount%2==1?Qt.INTERIOR:Qt.EXTERIOR}isOnSegment(){return this._isPointOnSegment}}class ze{constructor(){ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(I(t,it)||t instanceof gt))throw new s("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new ke(this._geom),this._geom=null);const e=new Ve(t),n=new Xe(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[Ae]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[De]}}class ke{constructor(){ke.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new Be;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new Kt(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new L;const n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}ze.SegmentVisitor=Xe,ze.IntervalIndexedGeometry=ke;class Ue{static isOnLine(){if(arguments[0]instanceof m&&I(arguments[1],G)){const t=arguments[0],e=arguments[1],n=new jt,s=new m,i=new m,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new jt;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ve.locatePointInRing(t,e)}static isInRing(t,e){return Ue.locateInRing(t,e)!==Qt.EXTERIOR}}class He{hasNext(){}next(){}remove(){}}class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof ht)}next(){if(this._atStart)return this._atStart=!1,We.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new S;const t=this._parent.getGeometryN(this._index++);return t instanceof ht?(this._subcollectionIterator=new We(t),this._subcollectionIterator.next()):t}remove(){throw new K(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}get interfaces_(){return[He]}}class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==Qt.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===Qt.BOUNDARY)return Qt.BOUNDARY;if(i===Qt.INTERIOR)return Qt.EXTERIOR}return Qt.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}static containsPointInPolygon(t,e){return Qt.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof rt)return Ze.locatePointInPolygon(t,e);if(e instanceof ht){const n=new We(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==Qt.EXTERIOR)return e}}}return Qt.EXTERIOR}static isContained(t,e){return Qt.EXTERIOR!==Ze.locate(t,e)}static locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e.getEnvelopeInternal().intersects(t)?Ze.locateInGeometry(t,e):Qt.EXTERIOR}locate(t){return Ze.locate(t,this._geom)}get interfaces_(){return[Ae]}}var je=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ze,PointOnGeometryLocator:Ae,SimplePointInAreaLocator:Ze});class Ke{measure(t,e){}}class Qe{static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,Qe.DENSIFY_FRACTION),s=new O(t.getEnvelopeInternal());s.expandToInclude(e.getEnvelopeInternal());return 1-n/Qe.diagonalSize(s)}get interfaces_(){return[Ke]}}Qe.DENSIFY_FRACTION=.25;var Je=Object.freeze({__proto__:null,AreaSimilarityMeasure:class{measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}get interfaces_(){return[Ke]}},HausdorffSimilarityMeasure:Qe,SimilarityMeasure:Ke,SimilarityMeasureCombiner:class{static combine(t,e){return Math.min(t,e)}}});class $e{constructor(){$e.constructor_.apply(this,arguments)}static constructor_(){this._areaBasePt=null,this._triangleCent3=new m,this._areasum2=0,this._cg3=new m,this._lineCentSum=new m,this._totalLength=0,this._ptCount=0,this._ptCentSum=new m;const t=arguments[0];this._areaBasePt=null,this.add(t)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new $e(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=q.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new m;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!q.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;$e.centroid3(t,e,n,this._triangleCent3);const r=$e.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof rt){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof U){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof et)this.addPoint(t.getCoordinate());else if(t instanceof $)this.addLineSegments(t.getCoordinates());else if(t instanceof rt){const e=t;this.add(e)}else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}}class tn extends n{constructor(t){super(t),this.name=Object.keys({EmptyStackException:tn})[0]}}class en extends C{constructor(){super(),this.array=[]}add(t){return this.array.push(t),!0}get(t){if(t<0||t>=this.size())throw new w;return this.array[t]}push(t){return this.array.push(t),t}pop(){if(0===this.array.length)throw new tn;return this.array.pop()}peek(){if(0===this.array.length)throw new tn;return this.array[this.array.length-1]}empty(){return 0===this.array.length}isEmpty(){return this.empty()}search(t){return this.array.indexOf(t)}size(){return this.array.length}toArray(){return this.array.slice()}}class nn{constructor(){nn.constructor_.apply(this,arguments)}static constructor_(){this._coordSet=new Et,this._list=new L}static filterCoordinates(t){const e=new nn;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this._coordSet.add(t)&&this._list.add(t)}getCoordinates(){const t=new Array(this._list.size()).fill(null);return this._list.toArray(t)}get interfaces_(){return[H]}}class sn{constructor(){sn.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];sn.constructor_.call(this,sn.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=nn.filterCoordinates(t),this._geomFactory=e}}static extractCoordinates(t){const e=new nn;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return st.sort(t,1,t.length,new rn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new R;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){g.equals(t[0],t[t.length-1]);const e=new L;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==q.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new at;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)Ue.isInRing(t[s],e)||n.add(t[s]);const s=_t.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new en;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&q.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}}class rn{constructor(){rn.constructor_.apply(this,arguments)}static constructor_(){this._origin=null;const t=arguments[0];this._origin=t}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=q.index(t,e,n);if(l===q.COUNTERCLOCKWISE)return 1;if(l===q.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return rn.polarCompare(this._origin,n,s)}get interfaces_(){return[a]}}sn.RadialComparator=rn;class on{constructor(){on.constructor_.apply(this,arguments)}static constructor_(){this._interiorPoint=null,this._maxWidth=-1;const t=arguments[0];this.process(t)}static getInteriorPoint(t){return new on(t).getInteriorPoint()}static avg(t,e){return(t+e)/2}getInteriorPoint(){return this._interiorPoint}process(t){if(t.isEmpty())return null;if(t instanceof rt)this.processPolygon(t);else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.process(e.getGeometryN(t))}}processPolygon(t){const e=new ln(t);e.process();const n=e.getWidth();n>this._maxWidth&&(this._maxWidth=n,this._interiorPoint=e.getInteriorPoint())}}class ln{constructor(){ln.constructor_.apply(this,arguments)}static constructor_(){this._polygon=null,this._interiorPointY=null,this._interiorSectionWidth=0,this._interiorPoint=null;const t=arguments[0];this._polygon=t,this._interiorPointY=cn.getScanLineY(t)}static isEdgeCrossingCounted(t,e,n){const s=t.getY(),i=e.getY();return s!==i&&(!(s===n&&i<n)&&!(i===n&&s<n))}static intersectsHorizontalLine(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!(e<t.getMinY())&&!(e>t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return!(t.getY()>n&&e.getY()>n)&&!(t.getY()<n&&e.getY()<n)}}static intersection(t,e,n){const s=t.getX(),i=e.getX();if(s===i)return s;const r=i-s,o=(e.getY()-t.getY())/r;return s+(n-t.getY())/o}findBestMidpoint(t){if(0===t.size())return null;g.isTrue(0==t.size()%2,"Interior Point robustness failure: odd number of scanline crossings"),t.sort(new an);for(let e=0;e<t.size();e+=2){const n=t.get(e),s=t.get(e+1),i=s-n;if(i>this._interiorSectionWidth){this._interiorSectionWidth=i;const t=on.avg(n,s);this._interiorPoint=new m(t,this._interiorPointY)}}}process(){if(this._polygon.isEmpty())return null;this._interiorPoint=new m(this._polygon.getCoordinate());const t=new L;this.scanRing(this._polygon.getExteriorRing(),t);for(let e=0;e<this._polygon.getNumInteriorRing();e++)this.scanRing(this._polygon.getInteriorRingN(e),t);this.findBestMidpoint(t)}scanRing(t,e){if(!ln.intersectsHorizontalLine(t.getEnvelopeInternal(),this._interiorPointY))return null;const n=t.getCoordinateSequence();for(let t=1;t<n.size();t++){const s=n.getCoordinate(t-1),i=n.getCoordinate(t);this.addEdgeCrossing(s,i,this._interiorPointY,e)}}getWidth(){return this._interiorSectionWidth}getInteriorPoint(){return this._interiorPoint}addEdgeCrossing(t,e,n,s){if(!ln.intersectsHorizontalLine(t,e,n))return null;if(!ln.isEdgeCrossingCounted(t,e,n))return null;const i=ln.intersection(t,e,n);s.add(i)}}class an{compare(t,e){return t<e?-1:t>e?1:0}get interfaces_(){return[a]}}ln.DoubleComparator=an;class cn{constructor(){cn.constructor_.apply(this,arguments)}static constructor_(){this._poly=null,this._centreY=null,this._hiY=r.MAX_VALUE,this._loY=-r.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=on.avg(this._loY,this._hiY)}static getScanLineY(t){return new cn(t).getScanLineY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getScanLineY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return on.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}}on.InteriorPointPolygon=ln,on.ScanLineYOrdinateFinder=cn;class hn{constructor(){hn.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=null:(this._centroid=$e.getCentroid(t),t.getPrecisionModel().makePrecise(this._centroid)),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)}static getInteriorPoint(t){return new hn(t).getInteriorPoint()}addEndpoints(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof $)this.addEndpoints(t.getCoordinates());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof $)this.addInterior(t.getCoordinates());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}class un{constructor(){un.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=$e.getCentroid(t),this.add(t)}static getInteriorPoint(t){return new un(t).getInteriorPoint()}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof et)this.add(t.getCoordinate());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof m){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}}class gn{isInBoundary(t){}}class dn{isInBoundary(t){return t%2==1}get interfaces_(){return[gn]}}class _n{isInBoundary(t){return t>0}get interfaces_(){return[gn]}}class pn{isInBoundary(t){return t>1}get interfaces_(){return[gn]}}class mn{isInBoundary(t){return 1===t}get interfaces_(){return[gn]}}gn.Mod2BoundaryNodeRule=dn,gn.EndPointBoundaryNodeRule=_n,gn.MultiValentEndPointBoundaryNodeRule=pn,gn.MonoValentEndPointBoundaryNodeRule=mn,gn.MOD2_BOUNDARY_RULE=new dn,gn.ENDPOINT_BOUNDARY_RULE=new _n,gn.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new pn,gn.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new mn,gn.OGC_SFS_BOUNDARY_RULE=gn.MOD2_BOUNDARY_RULE;class fn{constructor(){fn.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=gn.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new s("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}intersects(t,e){return this.locate(t,e)!==Qt.EXTERIOR}updateLocationInfo(t){t===Qt.INTERIOR&&(this._isIn=!0),t===Qt.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof et&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof $)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof rt)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof St){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof yt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof ht){const n=new We(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?Qt.INTERIOR:Qt.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return Qt.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?Ue.isOnLine(t,n)?Qt.INTERIOR:Qt.EXTERIOR:Qt.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===Qt.EXTERIOR)return Qt.EXTERIOR;if(s===Qt.BOUNDARY)return Qt.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===Qt.INTERIOR)return Qt.EXTERIOR;if(i===Qt.BOUNDARY)return Qt.BOUNDARY}return Qt.INTERIOR}locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e instanceof $?this.locateOnLineString(t,e):e instanceof rt?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?Qt.BOUNDARY:this._numBoundaries>0||this._isIn?Qt.INTERIOR:Qt.EXTERIOR)}}class yn{constructor(){yn.constructor_.apply(this,arguments)}static constructor_(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t}static farthestPoints(t){const e=t[0].distance(t[1]),n=t[1].distance(t[2]),s=t[2].distance(t[0]);return e>=n&&e>=s?[t[0],t[1]]:n>=e&&n>=s?[t[1],t[2]]:[t[2],t[0]]}static pointWitMinAngleWithX(t,e){let n=r.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=r.MAX_VALUE,i=null;for(let r=0;r<t.length;r++){const o=t[r];if(o===e)continue;if(o===n)continue;const l=$t.angleBetween(e,o,n);l<s&&(s=l,i=o)}return i}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new m(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),_t.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=_t.copyDeep(e),null;let n=yn.lowestPoint(e),s=yn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=yn.pointWithMinAngleWithSegment(e,n,s);if($t.isObtuse(n,t,s))return this._extremalPts=[new m(n),new m(s)],null;if($t.isObtuse(t,n,s))n=t;else{if(!$t.isObtuse(t,s,n))return this._extremalPts=[new m(n),new m(s),new m(t)],null;s=t}}g.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}getMaximumDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre);case 2:return this._input.getFactory().createLineString([this._extremalPts[0],this._extremalPts[1]]);default:const t=yn.farthestPoints(this._extremalPts);return this._input.getFactory().createLineString(t)}}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new m((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=ne.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}}class xn{constructor(){xn.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new Kt,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];xn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new xn(t).getDiameter()}static getMinimumRectangle(t){return new xn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new m(0,n/e),i=new m(1,n/e-t/e)):(s=new m(n/t,0),i=new m(n/t-e/t,1)),new Kt(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof rt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=r.MAX_VALUE;let e=1;const n=new Kt;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new sn(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=xn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new Kt(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=r.MAX_VALUE,s=-r.MAX_VALUE,i=r.MAX_VALUE,o=-r.MAX_VALUE;for(let r=0;r<this._convexHullPts.length;r++){const l=xn.computeC(t,e,this._convexHullPts[r]);l>s&&(s=l),l<n&&(n=l);const a=xn.computeC(-e,t,this._convexHullPts[r]);a>o&&(o=a),a<i&&(i=a)}const l=xn.computeSegmentForLine(-t,-e,o),a=xn.computeSegmentForLine(-t,-e,i),c=xn.computeSegmentForLine(-e,t,s),h=xn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),p=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(p)}}var En=Object.freeze({__proto__:null,distance:Me,locate:je,match:Je,Angle:$t,Area:nt,Centroid:$e,ConvexHull:sn,Distance:z,InteriorPointArea:on,InteriorPointLine:hn,InteriorPointPoint:un,Length:W,Orientation:q,PointLocation:Ue,PointLocator:fn,RobustLineIntersector:jt,MinimumBoundingCircle:yn,MinimumDiameter:xn});class In{constructor(){In.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t}static densifyPoints(t,e,n){const s=new Kt,i=new R;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new In(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new Nn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new s("Tolerance must be positive");this._distanceTolerance=t}}class Nn extends me{constructor(){super(),Nn.constructor_.apply(this,arguments)}static constructor_(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=In.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof $&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}}In.DensifyTransformer=Nn;var wn=Object.freeze({__proto__:null,Densifier:In});class Cn{static isNorthern(t){return t===Cn.NE||t===Cn.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===Cn.SE?t===Cn.SE||t===Cn.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Cn.NE:Cn.SE:e>=0?Cn.NW:Cn.SW}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new s("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?Cn.NE:Cn.SE:e.y>=t.y?Cn.NW:Cn.SW}}}Cn.NE=0,Cn.NW=1,Cn.SW=2,Cn.SE=3;class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static constructor_(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t}static create(t,e){const n=new Sn(t),s=new Sn(e);return n.link(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}isEdgesSorted(){const t=this.findLowest();let e=t;do{const n=e.oNext();if(n===t)break;if(!(n.compareTo(e)>0))return!1;e=n}while(e!==t);return!0}oNext(){return this._sym._next}directionY(){return this.directionPt().getY()-this._orig.getY()}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;this.insertionEdge(t).insertAfter(t)}insertAfter(t){g.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof m&&arguments[0]instanceof m){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}findLowest(){let t=this,e=this.oNext();do{e.compareTo(t)<0&&(t=e),e=e.oNext()}while(e!==this);return t}directionPt(){return this.dest()}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.directionX(),n=this.directionY(),s=t.directionX(),i=t.directionY();if(e===s&&n===i)return 0;const r=Cn.quadrant(e,n),o=Cn.quadrant(s,i);if(r>o)return 1;if(r<o)return-1;const l=this.directionPt(),a=t.directionPt();return q.index(t._orig,a,l)}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}directionX(){return this.directionPt().getX()-this._orig.getX()}insertionEdge(t){let e=this;do{const n=e.oNext();if(n.compareTo(e)>0&&t.compareTo(e)>=0&&t.compareTo(n)<=0)return e;if(n.compareTo(e)<=0&&(t.compareTo(n)<=0||t.compareTo(e)>=0))return e;e=n}while(e!==this);return g.shouldNeverReachHere(),null}compareTo(t){const e=t;return this.compareAngularDirection(e)}toStringNode(){const t=this.orig();this.dest();const e=new pt;e.append("Node( "+Wt.format(t)+" )\n");let n=this;do{e.append("  -> "+n),e.append("\n"),n=n.oNext()}while(n!==this);return e.toString()}link(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}toStringNodeEdge(){return"  -> ("+Wt.format(this.dest())}setNext(t){this._next=t}}class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1;const t=arguments[0];Sn.constructor_.call(this,t)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}}class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static constructor_(){this._vertexMap=new Nt}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return n.link(s),n}createEdge(t){return new Sn(t)}addEdge(t,e){if(!Tn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}}class Rn extends Ln{constructor(){super(),Rn.constructor_.apply(this,arguments)}static constructor_(){this._isStart=!1;const t=arguments[0];Ln.constructor_.call(this,t)}setStart(){this._isStart=!0}isStart(){return this._isStart}}class Pn extends Tn{constructor(){super()}createEdge(t){return new Rn(t)}}class On{constructor(){On.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._factory=null,this._graph=null,this._lines=new L,this._nodeEdgeStack=new en,this._ringStartEdge=null,this._graph=new Pn}static dissolve(t){const e=new On;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new R;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new R;let n=t;for(this._ringStartEdge=null,Ln.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Ln.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Ln.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Ln.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Ln.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof U){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof $&&this.add(t)}})}else if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof $){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}}var vn=Object.freeze({__proto__:null,LineDissolver:On});class bn{static opposite(t){return t===bn.LEFT?bn.RIGHT:t===bn.RIGHT?bn.LEFT:t}}bn.ON=0,bn.LEFT=1,bn.RIGHT=2;let Mn=class{constructor(){Mn.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}};class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=Dn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=Dn.INSERT,this._label=t,this._xValue=e,this._obj=n}}isDelete(){return this._eventType===Dn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===Dn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}get interfaces_(){return[o]}}Dn.INSERT=1,Dn.DELETE=2;class An{}let Fn=class{constructor(){Fn.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Fn.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}};class Gn extends An{constructor(){super(),Gn.constructor_.apply(this,arguments)}static constructor_(){this.events=new L,this.nOverlaps=null}prepareEvents(){xe.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Fn&&I(arguments[0],C)&&I(arguments[1],C)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&I(arguments[0],C)&&arguments[1]instanceof Fn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new Mn(n,t),i=new Dn(e,n.getMinX(t),s);this.events.add(i),this.events.add(new Dn(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class qn{constructor(){qn.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[bn.ON]=t}else if(arguments[0]instanceof qn){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[bn.ON]=t,this.location[bn.LEFT]=e,this.location[bn.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==Qt.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[bn.ON]=this.location[bn.ON],t[bn.LEFT]=Qt.NONE,t[bn.RIGHT]=Qt.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[bn.LEFT];this.location[bn.LEFT]=this.location[bn.RIGHT],this.location[bn.RIGHT]=t}toString(){const t=new v;return this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[bn.LEFT])),t.append(Qt.toLocationSymbol(this.location[bn.ON])),this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[bn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[bn.ON]=t,this.location[bn.LEFT]=e,this.location[bn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:Qt.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===Qt.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(bn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(Qt.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}}class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new qn(t),this.elt[1]=new qn(t)}else if(arguments[0]instanceof Bn){const t=arguments[0];this.elt[0]=new qn(t.elt[0]),this.elt[1]=new qn(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new qn(Qt.NONE),this.elt[1]=new qn(Qt.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new qn(t,e,n),this.elt[1]=new qn(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new qn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[1]=new qn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[t].setLocations(e,n,s)}}static toLineLabel(t){const e=new Bn(Qt.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new qn(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(bn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new v;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(bn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new qn(this.elt[t].location[0]))}}class Yn{constructor(){Yn.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new m(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[o]}}class Vn extends xt{}function zn(t){return null==t?0:t.color}function Xn(t){return null==t?null:t.parent}function kn(t,e){null!==t&&(t.color=e)}function Un(t){return null==t?null:t.left}function Hn(t){return null==t?null:t.right}class Wn extends Vn{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,s,i=this.root_;do{if(n=i,s=t.compareTo(i.key),s<0)i=i.left;else{if(!(s>0)){const t=i.value;return i.value=e,t}i=i.right}}while(null!==i);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)Xn(t)===Un(Xn(Xn(t)))?(e=Hn(Xn(Xn(t))),1===zn(e)?(kn(Xn(t),0),kn(e,0),kn(Xn(Xn(t)),1),t=Xn(Xn(t))):(t===Hn(Xn(t))&&(t=Xn(t),this.rotateLeft(t)),kn(Xn(t),0),kn(Xn(Xn(t)),1),this.rotateRight(Xn(Xn(t))))):(e=Un(Xn(Xn(t))),1===zn(e)?(kn(Xn(t),0),kn(e,0),kn(Xn(Xn(t)),1),t=Xn(Xn(t))):(t===Un(Xn(t))&&(t=Xn(t),this.rotateRight(t)),kn(Xn(t),0),kn(Xn(Xn(t)),1),this.rotateLeft(Xn(Xn(t)))));this.root_.color=0}values(){const t=new L;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=Wn.successor(e));)t.add(e.value);return t}entrySet(){const t=new Et;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=Wn.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new ts(r,new Bn(this.edge._label))}add(t,e,n){const s=new Yn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}}class jn{constructor(){jn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)jn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),Y.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=st.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return Y.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class Kn{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new jn(Math.trunc(t.length/2));n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return n.toArray()}findChainEnd(t,e){const n=Cn.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(Cn.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}OLDgetChainStartIndices(t){let e=0;const n=new L;n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return Kn.toIntArray(n)}}class Qn{constructor(){Qn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return O.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}}class Jn{constructor(){Jn.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map((()=>Array(3)));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Jn.NULL_VALUE}static depthAtLocation(t){return t===Qt.EXTERIOR?0:t===Qt.INTERIOR?1:Jn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Jn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Jn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Jn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][bn.RIGHT]-this._depth[t][bn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?Qt.EXTERIOR:Qt.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==Qt.EXTERIOR&&s!==Qt.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Jn.depthAtLocation(s):this._depth[e][n]+=Jn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===Qt.INTERIOR&&this._depth[t][e]++}}}Jn.NULL_VALUE=-1;let $n=class{constructor(){$n.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){g.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}},ts=class extends $n{constructor(){super(),ts.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new Zn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Jn,this._depthDelta=0,1===arguments.length){const t=arguments[0];ts.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Jt&&arguments[0]instanceof Bn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,bn.ON),t.getLocation(1,bn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,bn.LEFT),t.getLocation(1,bn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,bn.RIGHT),t.getLocation(1,bn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new ts(t,Bn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof ts))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){ts.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Qn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new O;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new m(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new pt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}},es=class extends $n{constructor(){super(),es.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Bn(0,Qt.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=Qt.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==Qt.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Bn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof es){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Bn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===Qt.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=Qt.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case Qt.BOUNDARY:n=Qt.INTERIOR;break;case Qt.INTERIOR:default:n=Qt.BOUNDARY}this._label.setLocation(t,n)}},ns=class{constructor(){ns.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new Wn,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof m){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof es){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new L;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===Qt.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}};class ss{constructor(){ss.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ss.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ss.constructor_.call(this,t),this.init(e,n),this._label=s}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:q.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Cn.quadrant(this._dx,this._dy),g.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}get interfaces_(){return[o]}}class is extends h{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new m(e):void 0,this.name=Object.keys({TopologyException:is})[0]}getCoordinate(){return this.pt}}let rs=class extends ss{constructor(){super(),rs.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(ss.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===Qt.EXTERIOR&&e===Qt.INTERIOR?1:t===Qt.INTERIOR&&e===Qt.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Bn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new is("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,bn.LEFT)===Qt.INTERIOR&&this._label.getLocation(e,bn.RIGHT)===Qt.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[bn.LEFT]+"/"+this._depth[bn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Qt.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Qt.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===bn.LEFT&&(s=-1);const i=bn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}};class os{createNode(t){return new es(t,null)}}let ls=class{constructor(){ls.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new L,this._nodes=null,this._edgeEndList=new L,0===arguments.length)this._nodes=new ns(new os);else if(1===arguments.length){const t=arguments[0];this._nodes=new ns(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof es){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){Y.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===Qt.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(q.index(t,e,s)===q.COLLINEAR&&Cn.quadrant(t,e)===Cn.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){Y.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new rs(t,!0),s=new rs(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}};class as extends ls{constructor(){super(),as.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new Nt,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new fn,2===arguments.length){const t=arguments[0],e=arguments[1];as.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?Qt.BOUNDARY:Qt.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=Qt.NONE;i=n.getLocation(t,bn.ON),i===Qt.BOUNDARY&&s++;const r=as.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new Fn(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const s=this.createEdgeSetIntersector(),i=this._parentGeom instanceof gt||this._parentGeom instanceof rt||this._parentGeom instanceof yt,r=t||!i;return s.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new Fn(e,n,!0);s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof et){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,Qt.INTERIOR)}else if(arguments[0]instanceof m){const t=arguments[0];this.insertPoint(this._argIndex,t,Qt.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),Qt.EXTERIOR,Qt.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,Qt.INTERIOR,Qt.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],Qt.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],Qt.BOUNDARY)}addLineString(t){const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new ts(e,new Bn(this._argIndex,Qt.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),g.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===Qt.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=_t.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;q.isCCW(s)&&(i=n,r=e);const o=new ts(s,new Bn(this._argIndex,Qt.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],Qt.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new Bn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Gn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof U))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof yt&&(this._useBoundaryDeterminationRule=!1),t instanceof rt)this.addPolygon(t);else if(t instanceof $)this.addLineString(t);else if(t instanceof et)this.addPoint(t);else if(t instanceof ut)this.addCollection(t);else if(t instanceof St)this.addCollection(t);else if(t instanceof yt)this.addCollection(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return I(this._parentGeom,it)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ze(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof $){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}}var cs=Object.freeze({__proto__:null,GeometryGraph:as});class hs{visit(t){}}class us{constructor(){us.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e),this._left=null,this._right=null,this._count=1,this._data=n}}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}}class gs{constructor(){gs.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)gs.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return gs.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new R;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new us(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new L;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof O&&I(arguments[1],C)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[hs]}visit(t){e.add(t)}})}else if(arguments[0]instanceof O&&I(arguments[1],hs)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new ds(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new us(t,e);return r?s.setLeft(o):s.setRight(o),o}}class ds{constructor(){ds.constructor_.apply(this,arguments)}static constructor_(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new O(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}get interfaces_(){return[hs]}}gs.BestMatchVisitor=ds;var _s=Object.freeze({__proto__:null,KdTree:gs});class ps{constructor(){ps.constructor_.apply(this,arguments)}static constructor_(){this._items=new L,this._subnode=new Array(4).fill(null)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}get interfaces_(){return[c]}}function ms(){}ms.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},ms.powerOf2=function(t){return Math.pow(2,t)};class fs{constructor(){fs.constructor_.apply(this,arguments)}static constructor_(){this._pt=new m,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return ms.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=fs.computeQuadLevel(t),this._env=new O,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ms.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new m((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}}let ys=class extends ps{constructor(){super(),ys.constructor_.apply(this,arguments)}static constructor_(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2}static createNode(t){const e=new fs(t);return new ys(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new O(e);null!==t&&n.expandToInclude(t._env);const s=ys.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=ps.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=ps.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new O(e,n,s,i);return new ys(r,this._level-1)}insertNode(t){g.isTrue(null===this._env||this._env.contains(t._env));const e=ps.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}};class xs{static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return ms.exponent(s)<=xs.MIN_BINARY_EXPONENT}}xs.MIN_BINARY_EXPONENT=-50;class Es extends ps{constructor(){super()}insert(t,e){const n=ps.getSubnodeIndex(t,Es.origin.x,Es.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=ys.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){g.isTrue(t.getEnvelope().contains(e));const s=xs.isZeroWidth(e.getMinX(),e.getMaxX()),i=xs.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}}Es.origin=new m(0,0);class Is{insert(t,e){}remove(t,e){}query(){}}class Ns{constructor(){Ns.constructor_.apply(this,arguments)}static constructor_(){this._root=null,this._minExtent=1,this._root=new Es}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s+=e/2),i===r&&(i-=e/2,r+=e/2),new O(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=Ns.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new L;return this._root.addAllItems(t),t}remove(t,e){const n=Ns.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}get interfaces_(){return[Is,c]}}var ws=Object.freeze({__proto__:null,Quadtree:Ns});class Cs{getBounds(){}}class Ss{constructor(){Ss.constructor_.apply(this,arguments)}static constructor_(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e}getItem(){return this._item}getBounds(){return this._bounds}get interfaces_(){return[Cs,c]}}class Ls{constructor(){Ls.constructor_.apply(this,arguments)}static constructor_(){this._size=null,this._items=null,this._size=0,this._items=new L,this._items.add(null)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}}class Ts{constructor(){Ts.constructor_.apply(this,arguments)}static constructor_(){if(this._childBoundables=new L,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){g.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}get interfaces_(){return[Cs,c]}}class Rs{static maxDistance(t,e,n,s,i,r,o,l){let a=Rs.distance(t,e,i,r);return a=Math.max(a,Rs.distance(t,e,o,l)),a=Math.max(a,Rs.distance(n,s,i,r)),a=Math.max(a,Rs.distance(n,s,o,l)),a}static distance(t,e,n,s){const i=n-t,r=s-e;return Math.sqrt(i*i+r*r)}static maximumDistance(t,e){const n=Math.min(t.getMinX(),e.getMinX()),s=Math.min(t.getMinY(),e.getMinY()),i=Math.max(t.getMaxX(),e.getMaxX()),r=Math.max(t.getMaxY(),e.getMaxY());return Rs.distance(n,s,i,r)}static minMaxDistance(t,e){const n=t.getMinX(),s=t.getMinY(),i=t.getMaxX(),r=t.getMaxY(),o=e.getMinX(),l=e.getMinY(),a=e.getMaxX(),c=e.getMaxY();let h=Rs.maxDistance(n,s,n,r,o,l,o,c);return h=Math.min(h,Rs.maxDistance(n,s,n,r,o,l,a,l)),h=Math.min(h,Rs.maxDistance(n,s,n,r,a,c,o,c)),h=Math.min(h,Rs.maxDistance(n,s,n,r,a,c,a,l)),h=Math.min(h,Rs.maxDistance(n,s,i,s,o,l,o,c)),h=Math.min(h,Rs.maxDistance(n,s,i,s,o,l,a,l)),h=Math.min(h,Rs.maxDistance(n,s,i,s,a,c,o,c)),h=Math.min(h,Rs.maxDistance(n,s,i,s,a,c,a,l)),h=Math.min(h,Rs.maxDistance(i,r,n,r,o,l,o,c)),h=Math.min(h,Rs.maxDistance(i,r,n,r,o,l,a,l)),h=Math.min(h,Rs.maxDistance(i,r,n,r,a,c,o,c)),h=Math.min(h,Rs.maxDistance(i,r,n,r,a,c,a,l)),h=Math.min(h,Rs.maxDistance(i,r,i,s,o,l,o,c)),h=Math.min(h,Rs.maxDistance(i,r,i,s,o,l,a,l)),h=Math.min(h,Rs.maxDistance(i,r,i,s,a,c,o,c)),h=Math.min(h,Rs.maxDistance(i,r,i,s,a,c,a,l)),h}}class Ps{constructor(){Ps.constructor_.apply(this,arguments)}static constructor_(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof Ts}maximumDistance(){return Rs.maximumDistance(this._boundable1.getBounds(),this._boundable2.getBounds())}expandToQueue(t,e){const n=Ps.isComposite(this._boundable1),i=Ps.isComposite(this._boundable2);if(n&&i)return Ps.area(this._boundable1)>Ps.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,!1,t,e),null):(this.expand(this._boundable2,this._boundable1,!0,t,e),null);if(n)return this.expand(this._boundable1,this._boundable2,!1,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,!0,t,e),null;throw new s("neither boundable is composite")}isLeaves(){return!(Ps.isComposite(this._boundable1)||Ps.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s,i){for(let r=t.getChildBoundables().iterator();r.hasNext();){const t=r.next();let o=null;o=n?new Ps(e,t,this._itemDistance):new Ps(t,e,this._itemDistance),o.getDistance()<i&&s.add(o)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}get interfaces_(){return[o]}}class Os{constructor(){Os.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._built=!1,this._itemBoundables=new L,this._nodeCapacity=null,0===arguments.length)Os.constructor_.call(this,Os.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];g.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(I(arguments[2],De)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ts?this.queryInternal(t,i,e):i instanceof Ss?e.visitItem(i.getItem()):g.shouldNeverReachHere())}}else if(I(arguments[2],C)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ts?this.queryInternal(t,i,e):i instanceof Ss?e.add(i.getItem()):g.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof Ts?t+=this.size(n):n instanceof Ss&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof Ss&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new L:t}if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof Ts){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof Ss?e.add(t.getItem()):g.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){g.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new Ss(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new L;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(g.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof Ts?this.boundablesAtLevel(t,e,n):(g.isTrue(e instanceof Ss),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new L;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof Ts&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){g.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof Ts){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=new L;n.add(this.createNode(e));const s=new L(t);xe.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}get interfaces_(){return[c]}}Os.IntersectsOp=function(){},Os.DEFAULT_NODE_CAPACITY=10;class vs{distance(t,e){}}class bs extends Os{constructor(){super(),bs.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)bs.constructor_.call(this,bs.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];Os.constructor_.call(this,t)}}static centreX(t){return bs.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return bs.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){g.isTrue(t.length>0);const n=new L;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}nearestNeighbourK(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.nearestNeighbourK(t,r.POSITIVE_INFINITY,e)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=arguments[1];const s=new Ls;s.add(t);const i=new Ls;for(;!s.isEmpty()&&n>=0;){const t=s.poll(),r=t.getDistance();if(r>=n)break;if(t.isLeaves())if(i.size()<e)i.add(t);else{i.peek().getDistance()>r&&(i.poll(),i.add(t));n=i.peek().getDistance()}else t.expandToQueue(s,n)}return bs.getItems(i)}}createNode(t){return new Ms(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return bs.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new L;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return bs.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new L(t);xe.sort(s,bs.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(I(arguments[0],vs)){const t=arguments[0];if(this.isEmpty())return null;const e=new Ps(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof Ps){const t=arguments[0];let e=r.POSITIVE_INFINITY,n=null;const s=new Ls;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return null===n?null:[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}}else{if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isEmpty()||t.isEmpty())return null;const n=new Ps(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(3===arguments.length){const t=arguments[2],e=new Ss(arguments[0],arguments[1]),n=new Ps(this.getRoot(),e,t);return this.nearestNeighbour(n)[0]}if(4===arguments.length){const t=arguments[2],e=arguments[3],n=new Ss(arguments[0],arguments[1]),s=new Ps(this.getRoot(),n,t);return this.nearestNeighbourK(s,e)}}}isWithinDistance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=r.POSITIVE_INFINITY;const s=new Ls;for(s.add(t);!s.isEmpty();){const t=s.poll(),i=t.getDistance();if(i>e)return!1;if(t.maximumDistance()<=e)return!0;if(t.isLeaves()){if(n=i,n<=e)return!0}else t.expandToQueue(s,n)}return!1}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Ps(this.getRoot(),t.getRoot(),e);return this.isWithinDistance(s,n)}}get interfaces_(){return[Is,c]}}class Ms extends Ts{constructor(){super(),Ms.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0];Ts.constructor_.call(this,t)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new O(n.getBounds()):t.expandToInclude(n.getBounds())}return t}}bs.STRtreeNode=Ms,bs.xComparator=new class{get interfaces_(){return[a]}compare(t,e){return Os.compareDoubles(bs.centreX(t.getBounds()),bs.centreX(e.getBounds()))}},bs.yComparator=new class{get interfaces_(){return[a]}compare(t,e){return Os.compareDoubles(bs.centreY(t.getBounds()),bs.centreY(e.getBounds()))}},bs.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},bs.DEFAULT_NODE_CAPACITY=10;var Ds=Object.freeze({__proto__:null,STRtree:bs}),As=Object.freeze({__proto__:null,kdtree:_s,quadtree:ws,strtree:Ds});const Fs=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class Gs{constructor(t){this.geometryFactory=t||new Lt}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!qs[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==Fs.indexOf(n)?qs[n].call(this,e.coordinates):"GeometryCollection"===n?qs[n].call(this,e.geometries):qs[n].call(this,e)}write(t){const e=t.getGeometryType();if(!Bs[e])throw new Error("Geometry is not supported");return Bs[e].call(this,t)}}const qs={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!qs[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=qs.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new m(...s))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new m(t[0],t[1]),new m(t[2],t[1]),new m(t[2],t[3]),new m(t[0],t[3]),new m(t[0],t[1])])},Point:function(t){const e=new m(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(qs.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=qs.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(qs.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=qs.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=qs.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(qs.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},Bs={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:Bs.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(Bs.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=Bs.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=Bs.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(Bs[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Ys(t){return[t.x,t.y]}var Vs=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new Gs(t||new Lt)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new Gs(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Lt,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new m(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Ys);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Ys);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Ys)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Ys));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Ys))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Ht(t||new Lt)}read(t){return this.parser.read(t)}},WKTWriter:Wt});class zs{static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=zs.relativeSign(e.x,n.x),i=zs.relativeSign(e.y,n.y);switch(t){case 0:return zs.compareValue(s,i);case 1:return zs.compareValue(i,s);case 2:return zs.compareValue(i,-s);case 3:return zs.compareValue(-s,i);case 4:return zs.compareValue(-s,-i);case 5:return zs.compareValue(-i,-s);case 6:return zs.compareValue(-i,s);case 7:return zs.compareValue(s,-i)}return g.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}}class Xs{constructor(){Xs.constructor_.apply(this,arguments)}static constructor_(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new m(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:this._isInterior?e._isInterior?zs.compare(this._segmentOctant,this.coord,e.coord):1:-1}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}toString(){return this.segmentIndex+":"+this.coord.toString()}isInterior(){return this._isInterior}get interfaces_(){return[o]}}class ks{constructor(){ks.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn,this._edge=null;const t=arguments[0];this._edge=t}getSplitCoordinates(){const t=new R;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new L;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}createSplitEdgePts(t,e){let n=e.segmentIndex-t.segmentIndex+2;if(2===n)return[new m(t.coord),new m(e.coord)];const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new m(e.coord)),r}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e);this._edge.getCoordinate(e+1);const s=this._edge.getCoordinate(e+2);n.equals2D(s)&&t.add(b.valueOf(e+1))}}addEdgeCoordinates(t,e,n){const s=this.createSplitEdgePts(t,e);n.add(s,!1)}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(b.valueOf(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){const n=this.createSplitEdgePts(t,e);return new Zs(n,this._edge.getData())}add(t,e){const n=new Xs(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(g.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new h("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new h("bad split edge end point at "+i)}}class Us{static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the octant for point ( "+t+", "+e+" )");const n=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?n>=i?0:1:n>=i?7:6:e>=0?n>=i?3:2:n>=i?4:5}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,i=e.y-t.y;if(0===n&&0===i)throw new s("Cannot compute the octant for two identical points "+t);return Us.octant(n,i)}}}class Hs{getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}}class Ws{addIntersection(t,e){}get interfaces_(){return[Hs]}}class Zs{constructor(){Zs.constructor_.apply(this,arguments)}static constructor_(){this._nodeList=new ks(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new L;return Zs.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){e.next().getNodeList().addSplitEdges(t)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Us.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[1],e=arguments[3],n=new m(arguments[0].getIntersection(e));this.addIntersection(n,t)}}toString(){return Wt.toLineString(new mt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}get interfaces_(){return[Ws]}}class js{constructor(){js.constructor_.apply(this,arguments)}static constructor_(){this._overlapSeg1=new Kt,this._overlapSeg2=new Kt}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];arguments[0].getLineSegment(t,this._overlapSeg1),e.getLineSegment(n,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}}class Ks{constructor(){Ks.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new O(t,e)}return this._env}overlaps(t,e,n,s,i){return O.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}}class Qs{static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=Cn.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(Cn.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Qs.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;let s=0;do{const i=Qs.findChainEnd(t,s),r=new Ks(t,s,i,e);n.add(r),s=i}while(s<t.length-1);return n}}}class Js{computeNodes(t){}getNodedSubstrings(){}}class $s{constructor(){$s.constructor_.apply(this,arguments)}static constructor_(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}}setSegmentIntersector(t){this._segInt=t}get interfaces_(){return[Js]}}class ti extends $s{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){if(this._monoChains=new L,this._index=new bs,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];$s.constructor_.call(this,t)}}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Zs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Qs.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new ei(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}}class ei extends js{constructor(){super(),ei.constructor_.apply(this,arguments)}static constructor_(){this._si=null;const t=arguments[0];this._si=t}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[1],e=arguments[2],n=arguments[3],s=arguments[0].getContext(),i=e.getContext();this._si.processIntersections(s,t,i,n)}}}ti.SegmentOverlapAction=ei;class ni{constructor(){ni.constructor_.apply(this,arguments)}static constructor_(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ni.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}}rescale(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&Y.out.println(t)}}scale(){if(I(arguments[0],N)){const t=arguments[0],e=new L(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Zs(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new m(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].getZ());return _t.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}get interfaces_(){return[Js]}}var si=Object.freeze({__proto__:null,MCIndexNoder:ti,ScaledNoder:ni,SegmentString:Hs});class ii{constructor(){ii.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];ii.constructor_.call(this,t,gn.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}}static getBoundary(){if(1===arguments.length){return new ii(arguments[0]).getBoundary()}if(2===arguments.length){return new ii(arguments[0],arguments[1]).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof $?this.boundaryLineString(this._geom):this._geom instanceof St?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new L;this._endpointMap=new Wn;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return _t.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new ri,this._endpointMap.put(t,e)),e.count++}}let ri=class{constructor(){ri.constructor_.apply(this,arguments)}static constructor_(){this.count=null}};class oi{constructor(){oi.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}}static isSimple(){if(1===arguments.length){return new oi(arguments[0]).isSimple()}if(2===arguments.length){return new oi(arguments[0],arguments[1]).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new at;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new Wn;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.isClosed(),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new as(0,t),n=new jt,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new li(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof $||t instanceof St?this.isSimpleLinearGeometry(t):t instanceof ut?this.isSimpleMultiPoint(t):I(t,it)?this.isSimplePolygonal(t):!(t instanceof ht)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}}class li{constructor(){li.constructor_.apply(this,arguments)}static constructor_(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}}oi.EndpointInfo=li;class ai{constructor(){ai.constructor_.apply(this,arguments)}static constructor_(){if(this._quadrantSegments=ai.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=ai.CAP_ROUND,this._joinStyle=ai.JOIN_ROUND,this._mitreLimit=ai.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=ai.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=ai.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=ai.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==ai.JOIN_ROUND&&(this._quadrantSegments=ai.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}}ai.CAP_ROUND=1,ai.CAP_FLAT=2,ai.CAP_SQUARE=3,ai.JOIN_ROUND=1,ai.JOIN_MITRE=2,ai.JOIN_BEVEL=3,ai.DEFAULT_QUADRANT_SEGMENTS=8,ai.DEFAULT_MITRE_LIMIT=5,ai.DEFAULT_SIMPLIFY_FACTOR=.01;class ci{constructor(){ci.constructor_.apply(this,arguments)}static constructor_(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();g.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=q.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===q.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===q.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=bn.LEFT;return n[e].y<n[e+1].y&&(s=bn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}g.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe;this.getRightmostSide(this._minDe,this._minIndex)===bn.LEFT&&(this._orientedDe=this._minDe.getSym())}}class hi{constructor(){this.array=[]}addLast(t){this.array.push(t)}removeFirst(){return this.array.shift()}isEmpty(){return 0===this.array.length}}class ui{constructor(){ui.constructor_.apply(this,arguments)}static constructor_(){this._finder=null,this._dirEdgeList=new L,this._nodes=new L,this._rightMostCoord=null,this._env=null,this._finder=new ci}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new is("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel(),e.setEdgeDepths(bn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(bn.RIGHT)>=1&&e.getDepth(bn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new Et,n=new hi,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new O;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new en;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(bn.LEFT,t.getDepth(bn.RIGHT)),e.setDepth(bn.RIGHT,t.getDepth(bn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}get interfaces_(){return[o]}}let gi=class{constructor(){gi.constructor_.apply(this,arguments)}static constructor_(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new L,this._pts=new L,this._label=new Bn(Qt.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new L,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=q.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new is("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new is("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();g.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!Ue.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[1],e=arguments[0].getLocation(t,bn.RIGHT);if(e===Qt.NONE)return null;if(this._label.getLocation(t)===Qt.NONE)return this._label.setLocation(t,e),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}};class di extends gi{constructor(){super(),di.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];gi.constructor_.call(this,t,e)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}}class _i extends gi{constructor(){super(),_i.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];gi.constructor_.call(this,t,e)}buildMinimalRings(){const t=new L;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new di(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}}class pi{constructor(){pi.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=null,this._shellList=new L;const t=arguments[0];this._geometryFactory=t}static findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getLinearRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=_t.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;Ue.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getLinearRing().getEnvelopeInternal())}return r}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=pi.findEdgeRingContaining(e,t);if(null===n)throw new is("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}buildMaximalEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new _i(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return g.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ls.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new L,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}}class mi{constructor(){mi.constructor_.apply(this,arguments)}static constructor_(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=q.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t}static simplify(t,e){return new mi(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=mi.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){if(!(q.index(t,e,n)===this._angleOrientation))return!1;return z.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/mi.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return q.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=q.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===mi.DELETE;)e++;return e}isShallow(t,e,n,s){return z.pointToSegment(e,t,n)<s}collapseLine(){const t=new R;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==mi.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}}mi.INIT=0,mi.DELETE=1,mi.KEEP=1,mi.NUM_PTS_TO_CHECK=10;class fi{constructor(){fi.constructor_.apply(this,arguments)}static constructor_(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new L}getCoordinates(){return this._ptList.toArray(fi.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new m(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Lt).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new m(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}}fi.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class yi{constructor(){yi.constructor_.apply(this,arguments)}static constructor_(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new Kt,this._seg1=new Kt,this._offset0=new Kt,this._offset1=new Kt,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new jt,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===ai.JOIN_ROUND&&(this._closingSegLengthFactor=yi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=q.index(this._s0,this._s1,this._s2),s=n===q.CLOCKWISE&&this._side===bn.LEFT||n===q.COUNTERCLOCKWISE&&this._side===bn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new Kt(t,e),s=new Kt;this.computeOffsetSegment(n,bn.LEFT,this._distance,s);const i=new Kt;this.computeOffsetSegment(n,bn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case ai.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,q.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case ai.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case ai.CAP_SQUARE:const t=new m;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new m(s.p1.x+t.x,s.p1.y+t.y),r=new m(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){const i=B.intersection(e.p0,e.p1,n.p0,n.p1);if(null!==i){if((s<=0?1:i.distance(t)/Math.abs(s))<=this._bufParams.getMitreLimit())return this._segList.addPt(i),null}this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*yi.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===ai.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===ai.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new m(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new m(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===q.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=$t.angle(i,this._seg0.p0),o=$t.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2,l=$t.normalize(r+o),a=$t.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),g=i.y+c*Math.sin(a),d=new m(u,g),_=new Kt(i,d),p=_.pointAlongOffset(1,h),f=_.pointAlongOffset(1,-h);this._side===bn.LEFT?(this._segList.addPt(p),this._segList.addPt(f)):(this._segList.addPt(f),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===q.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;const a=o/l,c=new m;for(let n=0;n<l;n++){const s=e+r*n*a;c.x=t.x+i*Math.cos(s),c.y=t.y+i*Math.sin(s),this._segList.addPt(c)}}computeOffsetSegment(t,e,n,s){const i=e===bn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*yi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new m((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new m((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new m(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new fi,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*yi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2);this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===ai.JOIN_BEVEL||this._bufParams.getJoinStyle()===ai.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,q.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}}yi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,yi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,yi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,yi.MAX_CLOSING_SEG_LEN_FACTOR=80;class xi{constructor(){xi.constructor_.apply(this,arguments)}static constructor_(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new m(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&_t.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=mi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],bn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=mi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],bn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===bn.RIGHT&&(s=-s);const i=mi.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=mi.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],bn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=mi.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],bn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case ai.CAP_ROUND:e.createCircle(t);break;case ai.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,this.isLineOffsetEmpty(e))return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return xi.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=mi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],bn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=mi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],bn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}isLineOffsetEmpty(t){return 0===t||t<0&&!this._bufParams.isSingleSided()}getSegGen(t){return new yi(this._precisionModel,this._bufParams,t)}}class Ei{constructor(){Ei.constructor_.apply(this,arguments)}static constructor_(){this._subgraphs=null,this._seg=new Kt;const t=arguments[0];this._subgraphs=t}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(I(arguments[2],C)&&arguments[0]instanceof m&&arguments[1]instanceof rs){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse();if(Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(q.index(this._seg.p0,this._seg.p1,t)===q.RIGHT)continue;let r=e.getDepth(bn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(bn.RIGHT));const o=new Ii(this._seg,r);n.add(o)}}else if(I(arguments[2],C)&&arguments[0]instanceof m&&I(arguments[1],C)){const t=arguments[0],e=arguments[2];for(let n=arguments[1].iterator();n.hasNext();){const s=n.next();s.isForward()&&this.findStabbedSegments(t,s,e)}}}getDepth(t){const e=this.findStabbedSegments(t);if(0===e.size())return 0;return xe.min(e)._leftDepth}}class Ii{constructor(){Ii.constructor_.apply(this,arguments)}static constructor_(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new Kt(t),this._leftDepth=e}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}get interfaces_(){return[o]}}Ei.DepthSegment=Ii;class Ni{constructor(){Ni.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n}addRingSide(t,e,n,s,i){if(0===e&&t.length<gt.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=gt.MINIMUM_VALID_SIZE&&q.isCCW(t)&&(r=i,o=s,n=bn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}addRingBothSides(t,e){this.addRingSide(t,e,bn.LEFT,Qt.EXTERIOR,Qt.INTERIOR),this.addRingSide(t,e,bn.RIGHT,Qt.INTERIOR,Qt.EXTERIOR)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,Qt.EXTERIOR,Qt.INTERIOR)}addPolygon(t){let e=this._distance,n=bn.LEFT;this._distance<0&&(e=-this._distance,n=bn.RIGHT);const s=t.getExteriorRing(),i=_t.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addRingSide(i,e,n,Qt.EXTERIOR,Qt.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=_t.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addRingSide(r,e,bn.opposite(n),Qt.INTERIOR,Qt.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new ne(t[0],t[1],t[2]),s=n.inCentre();return z.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._curveBuilder.isLineOffsetEmpty(this._distance))return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(_t.isRing(e)&&!this._curveBuilder.getBufferParameters().isSingleSided())this.addRingBothSides(e,this._distance);else{const t=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(t,Qt.EXTERIOR,Qt.INTERIOR)}}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Zs(t,new Bn(0,Qt.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}add(t){if(t.isEmpty())return null;if(t instanceof rt)this.addPolygon(t);else if(t instanceof $)this.addLineString(t);else if(t instanceof et)this.addPoint(t);else if(t instanceof ut)this.addCollection(t);else if(t instanceof St)this.addCollection(t);else if(t instanceof yt)this.addCollection(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}}class wi{constructor(){wi.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new Wn,this._edgeList=null,this._ptInAreaLocation=[Qt.NONE,Qt.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=Qt.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,bn.LEFT)!==Qt.NONE&&(e=s.getLocation(t,bn.LEFT))}if(e===Qt.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,bn.ON)===Qt.NONE&&i.setLocation(t,bn.ON,n),i.isArea(t)){const e=i.getLocation(t,bn.LEFT),r=i.getLocation(t,bn.RIGHT);if(r!==Qt.NONE){if(r!==n)throw new is("side location conflict",s.getCoordinate());e===Qt.NONE&&g.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else g.isTrue(i.getLocation(t,bn.LEFT)===Qt.NONE,"found single null side"),i.setLocation(t,bn.RIGHT,n),i.setLocation(t,bn.LEFT,n)}}}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}print(t){Y.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,bn.LEFT);g.isTrue(s!==Qt.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();g.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,bn.LEFT),r=n.getLocation(t,bn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new L(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===Qt.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new v;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===Qt.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=Qt.NONE;if(e[n])r=Qt.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}}let Ci=class extends wi{constructor(){super(),Ci.constructor_.apply(this,arguments)}static constructor_(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new is("no outgoing dirEdge found",this.getCoordinate());g.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return Cn.isNorthern(i)&&Cn.isNorthern(r)?n:Cn.isNorthern(i)||Cn.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(g.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){Y.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new L;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(bn.LEFT),s=t.getDepth(bn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new is("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[1];let e=arguments[2];for(let n=arguments[0];n<t;n++){const t=this._edgeList.get(n);t.setEdgeDepths(bn.RIGHT,e),e=t.getDepth(bn.LEFT)}return e}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(g.isTrue(null!==e,"found null for first outgoing dirEdge"),g.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=Qt.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=Qt.INTERIOR;break}if(s.isInResult()){t=Qt.EXTERIOR;break}}}if(t===Qt.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===Qt.INTERIOR):(n.isInResult()&&(e=Qt.EXTERIOR),s.isInResult()&&(e=Qt.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Bn(Qt.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==Qt.INTERIOR&&n!==Qt.BOUNDARY||this._label.setLocation(t,Qt.INTERIOR)}}}};class Si extends os{constructor(){super()}createNode(t){return new es(t,new Ci)}}class Li{constructor(){Li.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=Li.orientation(t)}static orientation(t){return 1===_t.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return Li.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}get interfaces_(){return[o]}}class Ti{constructor(){Ti.constructor_.apply(this,arguments)}static constructor_(){this._edges=new L,this._ocaMap=new Wn}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new Li(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new Li(t.getCoordinates());this._ocaMap.put(e,t)}}class Ri{processIntersections(t,e,n,s){}isDone(){}}class Pi{constructor(){Pi.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Pi.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}get interfaces_(){return[Ri]}}class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static constructor_(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Ti;const t=arguments[0];this._bufParams=t}static depthDelta(t){const e=t.getLocation(0,bn.LEFT),n=t.getLocation(0,bn.RIGHT);return e===Qt.INTERIOR&&n===Qt.EXTERIOR?1:e===Qt.EXTERIOR&&n===Qt.INTERIOR?-1:0}static convertSegStrings(t){const e=new Lt,n=new L;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Bn(t.getLabel()),s.flip()),n.merge(s);const i=Oi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(Oi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new Ei(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new L;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new ui;n.create(t),e.add(n)}}return xe.sort(e,xe.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new ti,n=new jt;return n.setPrecisionModel(t),e.setSegmentIntersector(new Pi(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new xi(n,this._bufParams),i=new Ni(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new ls(new Si),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new pi(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();if(l.size()<=0)return this.createEmptyResultGeometry();return this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new ts(e.getCoordinates(),new Bn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}}class vi{constructor(){vi.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null;const t=arguments[0];this._segStrings=t}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new h("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new h("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new h("found non-noded collapse at "+vi.fact.createLineString([t,e,n]))}}vi.fact=new Lt;class bi{constructor(){bi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new s("Scale factor must be non-zero");1!==e&&(this._pt=new m(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new m,this._p1Scaled=new m),this.initCorners(this._pt)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return g.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){const e=.5;this._minx=t.x-e,this._maxx=t.x+e,this._miny=t.y-e,this._maxy=t.y+e,this._corner[0]=new m(this._maxx,this._maxy),this._corner[1]=new m(this._minx,this._maxy),this._corner[2]=new m(this._minx,this._miny),this._corner[3]=new m(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=bi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new O(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}}bi.SAFE_ENV_EXPANSION_FACTOR=.75;class Mi{constructor(){Mi.constructor_.apply(this,arguments)}static constructor_(){this.selectedSegment=new Kt}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[1];arguments[0].getLineSegment(t,this.selectedSegment),this.select(this.selectedSegment)}}}class Di{constructor(){Di.constructor_.apply(this,arguments)}static constructor_(){this._index=null;const t=arguments[0];this._index=t}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Ai(t,e,n);return this._index.query(s,new class{get interfaces_(){return[De]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}}class Ai extends Mi{constructor(){super(),Ai.constructor_.apply(this,arguments)}static constructor_(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof Ks))return super.select.apply(this,arguments);{const t=arguments[1],e=arguments[0].getContext();if(this._parentEdge===e&&(t===this._hotPixelVertexIndex||t+1===this._hotPixelVertexIndex))return null;this._isNodeAdded|=this._hotPixel.addSnappedNode(e,t)}}}Di.HotPixelSnapAction=Ai;class Fi{constructor(){Fi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new L}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}get interfaces_(){return[Ri]}}class Gi{constructor(){Gi.constructor_.apply(this,arguments)}static constructor_(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new jt,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()}checkCorrectness(t){const e=Zs.getNodedSubstrings(t),s=new vi(e);try{s.checkValid()}catch(t){if(!(t instanceof n))throw t;t.printStackTrace()}}getNodedSubstrings(){return Zs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Fi(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Zs){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new bi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new ti,this._pointSnapper=new Di(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new bi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}get interfaces_(){return[Js]}}class qi{constructor(){qi.constructor_.apply(this,arguments)}static constructor_(){if(this._argGeom=null,this._distance=null,this._bufParams=new ai,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}}static bufferOp(){if(2===arguments.length){const t=arguments[1];return new qi(arguments[0]).getResultGeometry(t)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof U&&"number"==typeof arguments[1]){const t=arguments[1],e=arguments[2],n=new qi(arguments[0]);n.setQuadrantSegments(e);return n.getResultGeometry(t)}if(arguments[2]instanceof ai&&arguments[0]instanceof U&&"number"==typeof arguments[1]){const t=arguments[1];return new qi(arguments[0],arguments[2]).getResultGeometry(t)}}else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3],s=new qi(arguments[0]);s.setQuadrantSegments(e),s.setEndCapStyle(n);return s.getResultGeometry(t)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=V.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ni(new Gi(new wt(1)),t.getScale()),n=new Oi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=qi.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof is))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=qi.precisionScaleFactor(this._argGeom,this._distance,t),n=new wt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===wt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new Oi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof h))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}}qi.CAP_ROUND=ai.CAP_ROUND,qi.CAP_BUTT=ai.CAP_FLAT,qi.CAP_FLAT=ai.CAP_FLAT,qi.CAP_SQUARE=ai.CAP_SQUARE,qi.MAX_PRECISION_DIGITS=12;var Bi=Object.freeze({__proto__:null,BufferOp:qi,BufferParameters:ai});class Yi{constructor(){Yi.constructor_.apply(this,arguments)}static constructor_(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Yi.constructor_.call(this,t,Yi.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}}getSegmentIndex(){return this._segIndex}getCoordinate(){return this._pt}isInsideArea(){return this._segIndex===Yi.INSIDE_AREA}toString(){return this._component.getGeometryType()+"["+this._segIndex+"]-"+Wt.toPoint(this._pt)}getGeometryComponent(){return this._component}}Yi.INSIDE_AREA=-1;class Vi{constructor(){Vi.constructor_.apply(this,arguments)}static constructor_(){this._locations=null;const t=arguments[0];this._locations=t}static getLocations(t){const e=new L;return t.apply(new Vi(e)),e}filter(t){if(t.isEmpty())return null;(t instanceof et||t instanceof $||t instanceof rt)&&this._locations.add(new Yi(t,0,t.getCoordinate()))}get interfaces_(){return[J]}}class zi{constructor(){zi.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new fn,this._minDistanceLocation=null,this._minDistance=r.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];zi.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}}static distance(t,e){return new zi(t,e).distance()}static isWithinDistance(t,e,n){if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)return!1;return new zi(t,e,n).distance()<=n}static nearestPoints(t,e){return new zi(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ie.getPolygons(n);if(i.size()>0){const n=Vi.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&I(arguments[0],C)&&I(arguments[1],C)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Yi&&arguments[1]instanceof rt){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(Qt.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Yi(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=ye.getLines(this._geom[0]),n=ye.getLines(this._geom[1]),s=Ee.getPoints(this._geom[0]),i=Ee.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){this.computeMinDistance();return[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof $&&arguments[1]instanceof et){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=z.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new Kt(s[r],s[r+1]).closestPoint(i);n[0]=new Yi(t,r,l),n[1]=new Yi(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof $&&arguments[1]instanceof $){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++){const o=new O(s[r],s[r+1]);if(!(o.distance(e.getEnvelopeInternal())>this._minDistance))for(let l=0;l<i.length-1;l++){const a=new O(i[l],i[l+1]);if(o.distance(a)>this._minDistance)continue;const c=z.segmentToSegment(s[r],s[r+1],i[l],i[l+1]);if(c<this._minDistance){this._minDistance=c;const o=new Kt(s[r],s[r+1]),a=new Kt(i[l],i[l+1]),h=o.closestPoints(a);n[0]=new Yi(t,r,h[0]),n[1]=new Yi(e,l,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Yi(i,0,i.getCoordinate()),n[1]=new Yi(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new s("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}}var Xi=Object.freeze({__proto__:null,DistanceOp:zi});class ki{constructor(){ki.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._directedEdges=new L,this._coordinates=null;const t=arguments[0];this._factory=t}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new R;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&_t.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}}class Ui{constructor(){Ui.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1,this._isVisited=!1,this._data=null}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}}class Hi extends Ui{constructor(){super(),Hi.constructor_.apply(this,arguments)}static constructor_(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=Cn.quadrant(i,r),this._angle=Math.atan2(r,i)}}static toEdges(t){const e=new L;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:q.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}get interfaces_(){return[o]}}class Wi extends Hi{constructor(){super(),Wi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hi.constructor_.call(this,t,e,n,s)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(g.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}}class Zi extends Ui{constructor(){super(),Zi.constructor_.apply(this,arguments)}static constructor_(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Ki){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}}class ji{constructor(){ji.constructor_.apply(this,arguments)}static constructor_(){this._outEdges=new L,this._sorted=!1}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(xe.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Zi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof Hi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}}class Ki extends Ui{constructor(){super(),Ki.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];Ki.constructor_.call(this,t,new ji)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}}static getEdgesBetween(t,e){const n=Hi.toEdges(t.getOutEdges().getEdges()),s=new Et(n),i=Hi.toEdges(e.getOutEdges().getEdges());return s.retainAll(i),s}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}}class Qi extends Zi{constructor(){super(),Qi.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}}class $i{constructor(){$i.constructor_.apply(this,arguments)}static constructor_(){this._edges=new Et,this._dirEdges=new Et,this._nodeMap=new Ji}findNodesOfDegree(t){const e=new L;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Zi){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof Hi){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Ki){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Zi){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof Hi){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Ki){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Zi){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof Hi){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}}class tr extends $i{constructor(){super()}addEdge(t){if(t.isEmpty())return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Wi(i,r,e[1],!0),l=new Wi(r,i,e[e.length-2],!1),a=new Qi(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new Ki(t),this.add(e)),e}}class er{constructor(){er.constructor_.apply(this,arguments)}static constructor_(){this._graph=new tr,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(g.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Ui.setMarked(this._graph.nodeIterator(),!1),Ui.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new L,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new L;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new ki(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof U){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof $&&this.addLineString(n)}}else if(I(arguments[0],N)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}}class nr{constructor(){nr.constructor_.apply(this,arguments)}static constructor_(){this._parentGraph=null,this._edges=new Et,this._dirEdges=new L,this._nodeMap=new Ji;const t=arguments[0];this._parentGraph=t}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}}class sr{constructor(){sr.constructor_.apply(this,arguments)}static constructor_(){this._graph=null;const t=arguments[0];this._graph=t}addReachable(t,e){const n=new en;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new nr(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new L;Ui.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}}class ir{constructor(){ir.constructor_.apply(this,arguments)}static constructor_(){this._graph=new tr,this._factory=new Lt,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=b.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof St))return!0;const e=t,n=new at;let s=null;const i=new L;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new m(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new ir;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();g.isTrue(this._lineCount===e,"Lines were missing from result"),g.isTrue(this._sequencedGeometry instanceof $||this._sequencedGeometry instanceof St,"Result is not lineal")}findSequences(){const t=new L;for(let e=new sr(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=ir.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&g.isTrue(i===s,"path not contiguous")}findSequence(t){Ui.setVisited(t.edgeIterator(),!1);const e=ir.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new hi,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=ir.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new hi;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new L;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=ir.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof U){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof $&&this.addLine(t)}})}}}var rr=Object.freeze({__proto__:null,LineMerger:er,LineSequencer:ir});class or{constructor(){or.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new Kt,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof $&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];or.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=or.isClosed(t),this._snapTolerance=e}}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new m(i)),0===s&&this._isClosed&&t.set(t.size()-1,new m(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new R(this._srcPts);this.snapVertices(e,t),this.snapSegments(e,t);return e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new m(n),!1)}}findSegmentIndexToSnap(t,e){let n=r.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}}class lr{constructor(){lr.constructor_.apply(this,arguments)}static constructor_(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t}static snap(t,e,n){const s=new Array(2).fill(null),i=new lr(t);s[0]=i.snapTo(e,n);const r=new lr(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=lr.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===wt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(lr.computeOverlaySnapTolerance(t),lr.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*lr.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new lr(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new ar(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new ar(t,n,!0).transform(this._srcGeom);let i=s;return e&&I(i,it)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new at,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=r.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}}lr.SNAP_PRECISION_FACTOR=1e-9;class ar extends me{constructor(){super(),ar.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}}snapLine(t,e){const n=new or(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}}var cr=Object.freeze({__proto__:null,GeometrySnapper:lr,LineStringSnapper:or});class hr{constructor(){hr.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Us.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Wt.toLineString(new mt(this._pts))}get interfaces_(){return[Hs]}}class ur{constructor(){ur.constructor_.apply(this,arguments)}static constructor_(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._keepIntersections=!0,this._isInteriorIntersectionsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new L,this._intersectionCount=0;const t=arguments[0];this._li=t,this._interiorIntersection=null}static createAllIntersectionsFinder(t){const e=new ur(t);return e.setFindAllIntersections(!0),e}static isInteriorVertexIntersection(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3];return(!arguments[2]||!n)&&!!t.equals2D(e)}if(8===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6],l=arguments[7];return!!ur.isInteriorVertexIntersection(t,n,i,o)||(!!ur.isInteriorVertexIntersection(t,s,i,l)||(!!ur.isInteriorVertexIntersection(e,n,r,o)||!!ur.isInteriorVertexIntersection(e,s,r,l)))}}static createInteriorIntersectionCounter(t){const e=new ur(t);return e.setInteriorIntersectionsOnly(!0),e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static createIntersectionCounter(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static isEndSegment(t,e){return 0===e||e>=t.size()-2}static createAnyIntersectionFinder(t){return new ur(t)}static createInteriorIntersectionsFinder(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.setInteriorIntersectionsOnly(!0),e}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}getIntersection(){return this._interiorIntersection}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;const i=t===n;if(i&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(ur.isEndSegment(t,e)||ur.isEndSegment(n,s)))return null}const r=t.getCoordinate(e),o=t.getCoordinate(e+1),l=n.getCoordinate(s),a=n.getCoordinate(s+1),c=0===e,h=e+2===t.size(),u=0===s,g=s+2===n.size();this._li.computeIntersection(r,o,l,a);const d=this._li.hasIntersection()&&this._li.isInteriorIntersection();let _=!1;if(!this._isInteriorIntersectionsOnly){_=!(i&&Math.abs(s-e)<=1)&&ur.isInteriorVertexIntersection(r,o,l,a,c,h,u,g)}(d||_)&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=r,this._intSegments[1]=o,this._intSegments[2]=l,this._intSegments[3]=a,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}setInteriorIntersectionsOnly(t){this._isInteriorIntersectionsOnly=t}get interfaces_(){return[Ri]}}class gr{constructor(){gr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t}static computeIntersections(t){const e=new gr(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new ur(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new ti;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new is(this.getErrorMessage(),this._segInt.getIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Wt.toLineString(t[0],t[1])+" and "+Wt.toLineString(t[2],t[3])}}class dr{constructor(){dr.constructor_.apply(this,arguments)}static constructor_(){this._nv=null;const t=arguments[0];this._nv=new gr(dr.toSegmentStrings(t))}static toSegmentStrings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new hr(t.getCoordinates(),t))}return e}static checkValid(t){new dr(t).checkValid()}checkValid(){this._nv.checkValid()}}class _r{constructor(){_r.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new L,this._resultLineList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!wr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=this._geometryFactory.createLineString(e.getCoordinates());this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(g.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(wr.isResultOfOp(s,e)&&e===wr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}}class pr{constructor(){pr.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._resultPointList=new L;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===wr.INTERSECTION))){const e=n.getLabel();wr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}}class mr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new i,this._commonSignExp=null}getCommon(){return r.longBitsToDouble(this._commonBits)}add(t){const e=r.doubleToLongBits(t);if(this._isFirst)return this._commonBits=e,this._commonSignExp=mr.signExpBits(this._commonBits),this._isFirst=!1,null;if(mr.signExpBits(e)!==this._commonSignExp)return this._commonBits.high=0,this._commonBits.low=0,null;this._commonMantissaBitsCount=mr.numCommonMostSigMantissaBits(this._commonBits,e),this._commonBits=mr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))}toString(){if(1===arguments.length){const t=arguments[0],e=r.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+i.toBinaryString(t),s=n.substring(n.length-64);return s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]"}}getClass(){return mr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(mr.getBit(t,s)!==mr.getBit(e,s))return n;n++}return 52}}class fr{constructor(){fr.constructor_.apply(this,arguments)}static constructor_(){this._commonCoord=null,this._ccFilter=new yr}addCommonBits(t){const e=new xr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new m(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new xr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}}class yr{constructor(){yr.constructor_.apply(this,arguments)}static constructor_(){this._commonBitsX=new mr,this._commonBitsY=new mr}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new m(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}get interfaces_(){return[H]}}class xr{constructor(){xr.constructor_.apply(this,arguments)}static constructor_(){this.trans=null;const t=arguments[0];this.trans=t}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}get interfaces_(){return[P]}}fr.CommonCoordinateFilter=yr,fr.Translater=xr;class Er{constructor(){Er.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()}static overlayOp(t,e,n){return new Er(t,e).getResultGeometry(n)}static union(t,e){return Er.overlayOp(t,e,wr.UNION)}static intersection(t,e){return Er.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){return Er.overlayOp(t,e,wr.SYMDIFFERENCE)}static difference(t,e){return Er.overlayOp(t,e,wr.DIFFERENCE)}selfSnap(t){return new lr(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new fr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=wr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||Y.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=lr.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return lr.snap(e[0],e[1],this._snapTolerance)}}class Ir{constructor(){Ir.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e}static overlayOp(t,e,n){return new Ir(t,e).getResultGeometry(n)}static union(t,e){return Ir.overlayOp(t,e,wr.UNION)}static intersection(t,e){return Ir.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){return Ir.overlayOp(t,e,wr.SYMDIFFERENCE)}static difference(t,e){return Ir.overlayOp(t,e,wr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=wr.overlayOp(this._geom[0],this._geom[1],t); true&&(n=!0)}catch(t){if(!(t instanceof h))throw t;s=t}if(!n)try{e=Er.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof h?s:t}return e}}class Nr{constructor(){Nr.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new jt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new as(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new as(0,t,n),this._arg[1]=new as(1,e,n)}}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}}class wr extends Nr{constructor(){super(),wr.constructor_.apply(this,arguments)}static constructor_(){this._ptLocator=new fn,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new Ti,this._resultPolyList=new L,this._resultLineList=new L,this._resultPointList=new L;const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e),this._graph=new ls(new Si),this._geomFact=t.getFactory()}static overlayOp(t,e,n){return new wr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return wr.createEmptyResult(wr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ce.map(t,new class{get interfaces_(){return[MapOp]}map(t){return wr.intersection(t,n)}})}return Ir.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case wr.INTERSECTION:r=Math.min(s,i);break;case wr.UNION:r=Math.max(s,i);break;case wr.DIFFERENCE:r=s;break;case wr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){const i=wr.resultDimension(t,e,n);return s.createEmpty(i)}static difference(t,e){if(t.isEmpty())return wr.createEmptyResult(wr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return wr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1],n=arguments[2];switch(t===Qt.BOUNDARY&&(t=Qt.INTERIOR),e===Qt.BOUNDARY&&(e=Qt.INTERIOR),n){case wr.INTERSECTION:return t===Qt.INTERIOR&&e===Qt.INTERIOR;case wr.UNION:return t===Qt.INTERIOR||e===Qt.INTERIOR;case wr.DIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR;case wr.SYMDIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR||t!==Qt.INTERIOR&&e===Qt.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Bn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new L;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?wr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==Qt.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new L;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new L;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),dr.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new pi(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new _r(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new pr(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&wr.isResultOfOp(s.getLocation(0,bn.RIGHT),s.getLocation(1,bn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(g.isTrue(!s.isNull(t,bn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,bn.LEFT,s.getLocation(t,bn.LEFT)),g.isTrue(!s.isNull(t,bn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,bn.RIGHT,s.getLocation(t,bn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}}wr.INTERSECTION=1,wr.UNION=2,wr.DIFFERENCE=3,wr.SYMDIFFERENCE=4;var Cr=Object.freeze({__proto__:null,snap:cr,OverlayOp:wr});class Sr extends Hi{constructor(){super(),Sr.constructor_.apply(this,arguments)}static constructor_(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hi.constructor_.call(this,t,e,n,s)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}}class Lr extends Zi{constructor(){super(),Lr.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Tr{constructor(){Tr.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=new Lt,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){if(t.isEmpty())return null;const n=t.getCoordinates(),s=n[0],i=Tr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR&&(l=o.getSym()),g.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof rt){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof yt){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{g.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new _i(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new L;this._geomGraph.computeSplitEdges(t);const e=new ls(new Si);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}}class Rr{createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new ss(t,n.coord,r,new Bn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new Bn(t.getLabel());o.flip();const l=new ss(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}}class Pr extends ss{constructor(){super(),Pr.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new L,1===arguments.length){const t=arguments[0];Pr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];ss.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Bn(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===Qt.BOUNDARY&&n++,i===Qt.INTERIOR&&(s=!0)}let i=Qt.NONE;s&&(i=Qt.INTERIOR),n>0&&(i=as.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===Qt.INTERIOR)return this._label.setLocation(t,e,Qt.INTERIOR),null;n===Qt.EXTERIOR&&this._label.setLocation(t,e,Qt.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,bn.LEFT),this.computeLabelSide(t,bn.RIGHT)}updateIM(t){ts.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Bn(Qt.NONE,Qt.NONE,Qt.NONE):new Bn(Qt.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class Or extends wi{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Pr(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class vr extends es{constructor(){super(),vr.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];es.constructor_.call(this,t,e)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}}class br extends os{constructor(){super()}createNode(t){return new vr(t,new Or)}}class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static constructor_(){this._nodes=new ns(new br)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new Rr).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===Qt.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,Qt.INTERIOR)}}}}class Dr{constructor(){Dr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._geomGraph=null,this._nodeGraph=new Mr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}}class Ar{constructor(){Ar.constructor_.apply(this,arguments)}static constructor_(){this._graph=null,this._rings=new L,this._totalEnv=new O,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t}buildIndex(){this._index=new bs;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Gr.findPtNotNode(n,i,this._graph);if(null===o)continue;if(Ue.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}}class Fr{constructor(){Fr.constructor_.apply(this,arguments)}static constructor_(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Fr.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}}getErrorType(){return this._errorType}getMessage(){return Fr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}}Fr.ERROR=0,Fr.REPEATED_POINT=1,Fr.HOLE_OUTSIDE_SHELL=2,Fr.NESTED_HOLES=3,Fr.DISCONNECTED_INTERIOR=4,Fr.SELF_INTERSECTION=5,Fr.RING_SELF_INTERSECTION=6,Fr.NESTED_SHELLS=7,Fr.DUPLICATE_RINGS=8,Fr.TOO_FEW_POINTS=9,Fr.INVALID_COORDINATE=10,Fr.RING_NOT_CLOSED=11,Fr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Gr{constructor(){Gr.constructor_.apply(this,arguments)}static constructor_(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof U){return new Gr(arguments[0]).isValid()}if(arguments[0]instanceof m){const t=arguments[0];return!r.isNaN(t.x)&&(!r.isInfinite(t.x)&&(!r.isNaN(t.y)&&!r.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Gr.isValid(t[e]))return this._validErr=new Fr(Fr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof rt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){if(t.getNumInteriorRing()<=0)return null;const n=new Ar(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);s.isEmpty()||n.add(s)}n.isNonNested()||(this._validErr=new Fr(Fr.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new Dr(t);if(!e.isNodeConsistentArea())return this._validErr=new Fr(Fr.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Fr(Fr.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Gr.findPtNotNode(s,e,n);if(null!==r){if(!Ue.isInRing(r,i))return r}const o=Gr.findPtNotNode(i,t,n);if(null!==o){return Ue.isInRing(o,s)?o:null}return g.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new Tr(t);e.isInteriorsConnected()||(this._validErr=new Fr(Fr.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new at;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Fr(Fr.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){if(t.getNumInteriorRing()<=0)return null;const n=t.getExteriorRing(),s=n.isEmpty(),i=new ze(n);for(let r=0;r<t.getNumInteriorRing();r++){const o=t.getInteriorRingN(r);let l=null;if(o.isEmpty())continue;if(l=Gr.findPtNotNode(o.getCoordinates(),n,e),null===l)return null;if(s||Qt.EXTERIOR===i.locate(l))return this._validErr=new Fr(Fr.HOLE_OUTSIDE_SHELL,l),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Fr(Fr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof et){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof ut){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof gt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new jt;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof $){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new as(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof rt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof yt){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof ht){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof U){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof et)this.checkValid(t);else if(t instanceof ut)this.checkValid(t);else if(t instanceof gt)this.checkValid(t);else if(t instanceof $)this.checkValid(t);else if(t instanceof rt)this.checkValid(t);else if(t instanceof yt)this.checkValid(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing();if(i.isEmpty())return null;const r=i.getCoordinates(),o=Gr.findPtNotNode(s,i,n);if(null===o)return null;if(!Ue.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Fr(Fr.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Fr(Fr.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(t.isEmpty())return null;if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Fr(Fr.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}}class qr{constructor(){qr.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._deList=new L,this._lowestEdge=null,this._ring=null,this._locator=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t}static findDirEdgesInRing(t){let e=t;const n=new L;do{n.add(e),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing().getEnvelopeInternal();if(l.equals(s))continue;if(!l.contains(s))continue;i=_t.ptNotInList(n.getCoordinates(),e.getCoordinates());e.isInRing(i)&&(null===r||o.contains(l))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new R;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();qr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Gr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isInRing(t){return Qt.EXTERIOR!==this.getLocator().locate(t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof gt){const t=arguments[0];null===this._holes&&(this._holes=new L),this._holes.add(t)}else if(arguments[0]instanceof qr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new L),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=q.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Wt.toLineString(new mt(this.getCoordinates()))}getLocator(){return null===this._locator&&(this._locator=new ze(this.getRing())),this._locator}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&Y.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof n))throw t;Y.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}}qr.EnvelopeComparator=class{compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}get interfaces_(){return[a]}};class Br extends $i{constructor(){super(),Br.constructor_.apply(this,arguments)}static constructor_(){this._factory=null;const t=arguments[0];this._factory=t}static findLabeledEdgeRings(t){const e=new L;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=qr.findDirEdgesInRing(t);Br.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(g.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();Br.getDegree(i,e)>1&&(null===s&&(s=new L),s.add(i)),n=n.getNext(),g.isTrue(null!==n,"found null DE in ring"),g.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new qr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();Br.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Sr(i,r,e[1],!0),l=new Sr(r,i,e[e.length-2],!1),a=new Lr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),Br.findLabeledEdgeRings(this._dirEdges);const t=new L;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Br.label(this._dirEdges,-1);const t=Br.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new L;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new Ki(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=Br.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();Br.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new Et,n=new en;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();Br.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===Br.getDegreeNonDeleted(o)&&n.push(o)}}return e}}class Yr{constructor(){Yr.constructor_.apply(this,arguments)}static constructor_(){this._shells=null,this._shellIndex=null;const t=arguments[0];this._shells=t,this.buildIndex()}static assignHolesToShells(t,e){new Yr(e).assignHolesToShells(t)}assignHolesToShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.assignHoleToShell(t)}}buildIndex(){this._shellIndex=new bs;for(const t of this._shells)this._shellIndex.insert(t.getRing().getEnvelopeInternal(),t)}queryOverlappingShells(t){return this._shellIndex.query(t)}findShellContaining(t){const e=t.getRing().getEnvelopeInternal(),n=this.queryOverlappingShells(e);return qr.findEdgeRingContaining(t,n)}assignHoleToShell(t){const e=this.findShellContaining(t);null!==e&&e.addHole(t)}}class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static constructor_(){if(this._lineStringAdder=new zr(this),this._graph=null,this._dangles=new L,this._cutEdges=new L,this._invalidRingLines=new L,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Vr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}}static extractPolygons(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static findDisjointShells(t){Vr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Lt),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Lt.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new L,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new L;this._invalidRingLines=new L,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Yr.assignHolesToShells(this._holeList,this._shellList),xe.sort(this._shellList,new qr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Vr.findDisjointShells(this._shellList),n=!1),this._polyList=Vr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof $){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Br(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof U){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new L,this._shellList=new L;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}}class zr{constructor(){zr.constructor_.apply(this,arguments)}static constructor_(){this.p=null;const t=arguments[0];this.p=t}filter(t){t instanceof $&&this.p.add(t)}get interfaces_(){return[k]}}Vr.LineStringAdder=zr;var Xr=Object.freeze({__proto__:null,Polygonizer:Vr});class kr{constructor(){kr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._ptLocator=new fn,this._arg=null,this._nodes=new ns(new br),this._im=null,this._isolatedEdges=new L,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,Qt.EXTERIOR)}computeIM(){const t=new Jt;if(t.set(Qt.EXTERIOR,Qt.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new Rr,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===Qt.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,Qt.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===Qt.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,Qt.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();g.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(Qt.INTERIOR,Qt.EXTERIOR,e.getDimension()),t.set(Qt.BOUNDARY,Qt.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(Qt.EXTERIOR,Qt.INTERIOR,n.getDimension()),t.set(Qt.EXTERIOR,Qt.BOUNDARY,n.getBoundaryDimension()))}}class Ur{constructor(){Ur.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new Ur(t).contains(e)}isContainedInBoundary(t){if(t instanceof rt)return!1;if(t instanceof et)return this.isPointContainedInBoundary(t);if(t instanceof $)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new m,s=new m;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof et){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof m){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new m(t.getMinX(),t.getMinY()),this._diagUp1=new m(t.getMaxX(),t.getMaxY()),this._diagDown0=new m(t.getMinX(),t.getMaxY()),this._diagDown1=new m(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new O(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Wr{constructor(){Wr.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Wr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Zr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new jr(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new Kr(this._rectangle);return s.applyTo(t),!!s.intersects()}}class Zr extends Ne{constructor(){super(),Zr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}}class jr extends Ne{constructor(){super(),jr.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof rt))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new m;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}}class Kr extends Ne{constructor(){super(),Kr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new m,this._p1=new m;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Hr(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=ye.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class Qr extends Nr{constructor(){super(),Qr.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e),this._relate=new kr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Nr.constructor_.call(this,t,e,n),this._relate=new kr(this._arg)}}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Qr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Wr.intersects(t,e);if(e.isRectangle())return Wr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Qr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Qr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){return new Qr(arguments[0],arguments[1]).getIntersectionMatrix()}if(3===arguments.length){return new Qr(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Ur.contains(t,e):new Qr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}}var Jr=Object.freeze({__proto__:null,RelateOp:Qr});class $r{constructor(){$r.constructor_.apply(this,arguments)}static constructor_(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()}static union(t,e){return new $r(t,e).union()}union(){const t=new fn,e=new at;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===Qt.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=_t.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),he.combine(n,this._otherGeom)}}class to{constructor(){to.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._polygons=new L,this._lines=new L,this._points=new L,this._dimension=Q.FALSE}static extract(){if(I(arguments[0],N)){const t=arguments[0],e=new to;return e.add(t),e}if(arguments[0]instanceof U){const t=arguments[0],e=new to;return e.add(t),e}}getFactory(){return this._geomFactory}recordDimension(t){t>this._dimension&&(this._dimension=t)}getDimension(){return this._dimension}filter(t){return this.recordDimension(t.getDimension()),t instanceof ht||t.isEmpty()?null:t instanceof rt?(this._polygons.add(t),null):t instanceof $?(this._lines.add(t),null):t instanceof et?(this._points.add(t),null):void g.shouldNeverReachHere("Unhandled geometry type: "+t.getGeometryType())}getExtract(t){switch(t){case 0:return this._points;case 1:return this._lines;case 2:return this._polygons}return g.shouldNeverReachHere("Invalid dimension: "+t),null}isEmpty(){return this._polygons.isEmpty()&&this._lines.isEmpty()&&this._points.isEmpty()}add(){if(I(arguments[0],N)){const t=arguments[0];for(const e of t)this.add(e)}else if(arguments[0]instanceof U){const t=arguments[0];null===this._geomFactory&&(this._geomFactory=t.getFactory()),t.apply(this)}}get interfaces_(){return[J]}}class eo{static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return U.checkNotGeometryCollection(t),U.checkNotGeometryCollection(e),Ir.overlayOp(t,e,wr.UNION)}}class no{constructor(){no.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._g0=null,this._g1=null,this._isUnionSafe=null;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e,this._geomFactory=t.getFactory()}static containsProperly(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!t.isNull()&&(e.getX()>t.getMinX()&&e.getX()<t.getMaxX()&&e.getY()>t.getMinY()&&e.getY()<t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return no.containsProperly(t,e)&&no.containsProperly(t,n)}}static union(t,e){return new no(t,e).union()}static intersects(t,e,n){return t.intersects(e)||t.intersects(n)}static overlapEnvelope(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();return n.intersection(s)}static extractBorderSegments(t,e,n){t.apply(new class{get interfaces_(){return[P]}filter(t,s){if(s<=0)return null;const i=t.getCoordinate(s-1),r=t.getCoordinate(s);if(no.intersects(e,i,r)&&!no.containsProperly(e,i,r)){const t=new Kt(i,r);n.add(t)}}isDone(){return!1}isGeometryChanged(){return!1}})}static unionBuffer(t,e){return t.getFactory().createGeometryCollection([t,e]).buffer(0)}isBorderSegmentsSame(t,e){const n=this.extractBorderSegments(this._g0,this._g1,e),s=new L;return no.extractBorderSegments(t,e,s),this.isEqual(n,s)}extractByEnvelope(t,e,n){const s=new L;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);if(r.getEnvelopeInternal().intersects(t))s.add(r);else{const t=r.copy();n.add(t)}}return this._geomFactory.buildGeometry(s)}isEqual(t,e){if(t.size()!==e.size())return!1;const n=new Et(t);for(const t of e)if(!n.contains(t))return!1;return!0}union(){const t=no.overlapEnvelope(this._g0,this._g1);if(t.isNull()){const t=this._g0.copy(),e=this._g1.copy();return he.combine(t,e)}const e=new L,n=this.extractByEnvelope(t,this._g0,e),s=this.extractByEnvelope(t,this._g1,e),i=this.unionFull(n,s);let r=null;return this._isUnionSafe=this.isBorderSegmentsSame(i,t),r=this._isUnionSafe?this.combine(i,e):this.unionFull(this._g0,this._g1),r}combine(t,e){if(e.size()<=0)return t;e.add(t);return he.combine(e)}unionFull(t,e){try{return eo.union(t,e)}catch(n){if(n instanceof is)return no.unionBuffer(t,e);throw n}}extractBorderSegments(t,e,n){const s=new L;return no.extractBorderSegments(t,n,s),null!==e&&no.extractBorderSegments(e,n,s),s}isUnionOptimized(){return this._isUnionSafe}}class so{constructor(){so.constructor_.apply(this,arguments)}static constructor_(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new L)}static restrictToPolygons(t){if(I(t,it))return t;const e=Ie.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Lt.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new so(t).union()}reduceToGeometries(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;I(t,C)?s=this.unionTree(t):t instanceof U&&(s=t),e.add(s)}return e}union(){if(null===this._inputPolys)throw new D("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new bs(so.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=so.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(so.getGeometry(t,e),so.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionActual(t,e)}unionActual(t,e){const n=no.union(t,e);return so.restrictToPolygons(n)}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}}so.STRTREE_NODE_CAPACITY=4;class io{constructor(){io.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._extracter=null,1===arguments.length){if(I(arguments[0],N)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof U){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}}static union(){if(1===arguments.length){if(I(arguments[0],N)){return new io(arguments[0]).union()}if(arguments[0]instanceof U){return new io(arguments[0]).union()}}else if(2===arguments.length){return new io(arguments[0],arguments[1]).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return Ir.overlayOp(t,e,wr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:wr.union(t,e)}extract(){if(I(arguments[0],N)){const t=arguments[0];this._extracter=to.extract(t)}else if(arguments[0]instanceof U){const t=arguments[0];this._extracter=to.extract(t)}}union(){if(null===this._geomFact&&(this._geomFact=this._extracter.getFactory()),null===this._geomFact)return null;if(this._extracter.isEmpty())return this._geomFact.createEmpty(this._extracter.getDimension());const t=this._extracter.getExtract(0),e=this._extracter.getExtract(1),n=this._extracter.getExtract(2);let s=null;if(t.size()>0){const e=this._geomFact.buildGeometry(t);s=this.unionNoOpt(e)}let i=null;if(e.size()>0){const t=this._geomFact.buildGeometry(e);i=this.unionNoOpt(t)}let r=null;n.size()>0&&(r=so.union(n));const o=this.unionWithNull(i,r);let l=null;return l=null===s?o:null===o?s:$r.union(s,o),null===l?this._geomFact.createGeometryCollection():l}}var ro=Object.freeze({__proto__:null,UnaryUnionOp:io}),oo=Object.freeze({__proto__:null,IsValidOp:Gr,ConsistentAreaTester:Dr}),lo=Object.freeze({__proto__:null,BoundaryOp:ii,IsSimpleOp:oi,buffer:Bi,distance:Xi,linemerge:rr,overlay:Cr,polygonize:Xr,relate:Jr,union:ro,valid:oo});class ao{constructor(){ao.constructor_.apply(this,arguments)}static constructor_(){if(this._returnToOriginalPrecision=!0,this._cbr=null,0===arguments.length)ao.constructor_.call(this,!0);else if(1===arguments.length){const t=arguments[0];this._returnToOriginalPrecision=t}}computeResultPrecision(t){return this._returnToOriginalPrecision&&this._cbr.addCommonBits(t),t}union(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].union(n[1]))}intersection(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].intersection(n[1]))}removeCommonBits(){if(1===arguments.length){const t=arguments[0];this._cbr=new fr,this._cbr.add(t);return this._cbr.removeCommonBits(t.copy())}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._cbr=new fr,this._cbr.add(t),this._cbr.add(e);const n=new Array(2).fill(null);return n[0]=this._cbr.removeCommonBits(t.copy()),n[1]=this._cbr.removeCommonBits(e.copy()),n}}buffer(t,e){const n=this.removeCommonBits(t);return this.computeResultPrecision(n.buffer(e))}symDifference(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].symDifference(n[1]))}difference(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].difference(n[1]))}}class co extends ue.CoordinateOperation{constructor(){super(),co.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e}edit(){if(2===arguments.length&&arguments[1]instanceof U&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new m(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new R(n,!1).toCoordinateArray();let i=0;e instanceof $&&(i=2),e instanceof gt&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}}class ho{constructor(){ho.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t}static reduce(t,e){return new ho(e).reduce(t)}static reducePointwise(t,e){const n=new ho(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));return qi.bufferOp(e,0)}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new ue(n)}else e=new ue;let n=this._removeCollapsed;t.getDimension()>=2&&(n=!0);return e.edit(t,new co(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new ue.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Lt(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:I(e,it)?Gr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new ue;const n=this.createFactory(t,e);return new ue(n)}}class uo{constructor(){uo.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._pts=null,this._start=null,this._end=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._pts=t,this._start=e,this._end=e+1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pts=t,this._start=e,this._end=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._geom=t,this._pts=e,this._start=n,this._end=s}}computeDistanceLineLine(t,e){let n=r.MAX_VALUE;for(let s=this._start;s<this._end-1;s++){const i=this._pts.getCoordinate(s),r=this._pts.getCoordinate(s+1);for(let o=t._start;o<t._end-1;o++){const l=t._pts.getCoordinate(o),a=t._pts.getCoordinate(o+1),c=z.segmentToSegment(i,r,l,a);if(c<n&&(n=c,null!==e&&this.updateNearestLocationsLineLine(s,i,r,t,o,l,a,e),n<=0))return n}}return n}updateNearestLocationsPointLine(t,e,n,s,i,r){r[0]=new Yi(this._geom,this._start,new m(t));const o=new Kt(s,i).closestPoint(t);r[1]=new Yi(e._geom,n,new m(o))}size(){return this._end-this._start}getCoordinate(t){return this._pts.getCoordinate(this._start+t)}nearestLocations(t){const e=this.isPoint(),n=t.isPoint(),s=new Array(2).fill(null);if(e&&n){const e=this._pts.getCoordinate(this._start),n=t._pts.getCoordinate(t._start);s[0]=new Yi(this._geom,this._start,new m(e)),s[1]=new Yi(t._geom,t._start,new m(n))}else if(e){const e=this._pts.getCoordinate(this._start);this.computeDistancePointLine(e,t,s)}else if(n){const e=t._pts.getCoordinate(t._start);this.computeDistancePointLine(e,this,s);const n=s[0];s[0]=s[1],s[1]=n}else this.computeDistanceLineLine(t,s);return s}getEnvelope(){const t=new O;for(let e=this._start;e<this._end;e++)t.expandToInclude(this._pts.getX(e),this._pts.getY(e));return t}updateNearestLocationsLineLine(t,e,n,s,i,r,o,l){const a=new Kt(e,n),c=new Kt(r,o),h=a.closestPoints(c);l[0]=new Yi(this._geom,t,new m(h[0])),l[1]=new Yi(s._geom,i,new m(h[1]))}toString(){const t=new v;t.append("LINESTRING ( ");const e=new m;for(let n=this._start;n<this._end;n++)n>this._start&&t.append(", "),this._pts.getCoordinate(n,e),t.append(e.x+" "+e.y);return t.append(" )"),t.toString()}computeDistancePointLine(t,e,n){let s=r.MAX_VALUE;for(let i=e._start;i<e._end-1;i++){const r=e._pts.getCoordinate(i),o=e._pts.getCoordinate(i+1),l=z.pointToSegment(t,r,o);if(l<s&&(s=l,null!==n&&this.updateNearestLocationsPointLine(t,e,i,r,o,n),s<=0))return s}return s}isPoint(){return this._end-this._start==1}distance(t){const e=this.isPoint(),n=t.isPoint();let s=null;if(e&&n){const e=this._pts.getCoordinate(this._start),n=t._pts.getCoordinate(t._start);s=e.distance(n)}else if(e){const e=this._pts.getCoordinate(this._start);s=this.computeDistancePointLine(e,t,null)}else if(n){const e=t._pts.getCoordinate(t._start);s=this.computeDistancePointLine(e,this,null)}else s=this.computeDistanceLineLine(t,null);return s}}class go{static addFacetSequences(t,e,n){let s=0;const i=e.size();for(;s<=i-1;){let r=s+go.FACET_SEQUENCE_SIZE+1;r>=i-1&&(r=i);const o=new uo(t,e,s,r);n.add(o),s+=go.FACET_SEQUENCE_SIZE}}static computeFacetSequences(t){const e=new L;return t.apply(new class{get interfaces_(){return[k]}filter(t){let n=null;(t instanceof $||t instanceof et)&&(n=t.getCoordinateSequence(),go.addFacetSequences(t,n,e))}}),e}static build(t){const e=new bs(go.STR_TREE_NODE_CAPACITY);for(let n=go.computeFacetSequences(t).iterator();n.hasNext();){const t=n.next();e.insert(t.getEnvelope(),t)}return e.build(),e}}go.FACET_SEQUENCE_SIZE=6,go.STR_TREE_NODE_CAPACITY=4;class _o{constructor(){_o.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._minClearance=null,this._minClearancePts=null;const t=arguments[0];this._inputGeom=t}static getLine(t){return new _o(t).getLine()}static getDistance(t){return new _o(t).getDistance()}getLine(){return this.compute(),null===this._minClearancePts||null===this._minClearancePts[0]?this._inputGeom.getFactory().createLineString():this._inputGeom.getFactory().createLineString(this._minClearancePts)}compute(){if(null!==this._minClearancePts)return null;if(this._minClearancePts=new Array(2).fill(null),this._minClearance=r.MAX_VALUE,this._inputGeom.isEmpty())return null;const t=go.build(this._inputGeom).nearestNeighbour(new po),e=new po;this._minClearance=e.distance(t[0],t[1]),this._minClearancePts=e.getCoordinates()}getDistance(){return this.compute(),this._minClearance}}class po{constructor(){po.constructor_.apply(this,arguments)}static constructor_(){this._minDist=r.MAX_VALUE,this._minPts=new Array(2).fill(null)}vertexDistance(t,e){for(let n=0;n<t.size();n++)for(let s=0;s<e.size();s++){const i=t.getCoordinate(n),r=e.getCoordinate(s);if(!i.equals2D(r)){const t=i.distance(r);if(t<this._minDist&&(this._minDist=t,this._minPts[0]=i,this._minPts[1]=r,0===t))return t}}return this._minDist}getCoordinates(){return this._minPts}segmentDistance(t,e){for(let n=0;n<t.size();n++)for(let s=1;s<e.size();s++){const i=t.getCoordinate(n),r=e.getCoordinate(s-1),o=e.getCoordinate(s);if(!i.equals2D(r)&&!i.equals2D(o)){const t=z.pointToSegment(i,r,o);if(t<this._minDist&&(this._minDist=t,this.updatePts(i,r,o),0===t))return t}}return this._minDist}distance(){if(arguments[0]instanceof Ss&&arguments[1]instanceof Ss){const t=arguments[1],e=arguments[0].getItem(),n=t.getItem();return this._minDist=r.MAX_VALUE,this.distance(e,n)}if(arguments[0]instanceof uo&&arguments[1]instanceof uo){const t=arguments[0],e=arguments[1];return this.vertexDistance(t,e),1===t.size()&&1===e.size()?this._minDist:this._minDist<=0?this._minDist:(this.segmentDistance(t,e),this._minDist<=0||this.segmentDistance(e,t),this._minDist)}}updatePts(t,e,n){this._minPts[0]=t;const s=new Kt(e,n);this._minPts[1]=new m(s.closestPoint(t))}get interfaces_(){return[vs]}}_o.MinClearanceDistance=po;class mo{constructor(){mo.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._minClearance=null,this._minClearancePts=null;const t=arguments[0];this._inputGeom=t}static getLine(t){return new mo(t).getLine()}static getDistance(t){return new mo(t).getDistance()}getLine(){return this.compute(),this._inputGeom.getFactory().createLineString(this._minClearancePts)}updateClearance(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t<this._minClearance&&(this._minClearance=t,this._minClearancePts[0]=new m(e),this._minClearancePts[1]=new m(n))}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t<this._minClearance){this._minClearance=t,this._minClearancePts[0]=new m(e);const i=new Kt(n,s);this._minClearancePts[1]=new m(i.closestPoint(e))}}}compute(){if(null!==this._minClearancePts)return null;this._minClearancePts=new Array(2).fill(null),this._minClearance=r.MAX_VALUE,this._inputGeom.apply(new fo(this))}getDistance(){return this.compute(),this._minClearance}}class fo{constructor(){fo.constructor_.apply(this,arguments)}static constructor_(){this.smc=null;const t=arguments[0];this.smc=t}filter(t){this.smc._inputGeom.apply(new yo(this.smc,t))}get interfaces_(){return[H]}}class yo{constructor(){yo.constructor_.apply(this,arguments)}static constructor_(){this.smc=null,this._queryPt=null;const t=arguments[0],e=arguments[1];this.smc=t,this._queryPt=e}isGeometryChanged(){return!1}checkVertexDistance(t){const e=t.distance(this._queryPt);e>0&&this.smc.updateClearance(e,this._queryPt,t)}filter(t,e){this.checkVertexDistance(t.getCoordinate(e)),e>0&&this.checkSegmentDistance(t.getCoordinate(e-1),t.getCoordinate(e))}checkSegmentDistance(t,e){if(this._queryPt.equals2D(t)||this._queryPt.equals2D(e))return null;const n=z.pointToSegment(this._queryPt,e,t);n>0&&this.smc.updateClearance(n,this._queryPt,e,t)}isDone(){return!1}get interfaces_(){return[P]}}mo.VertexCoordinateFilter=fo,mo.ComputeMCCoordinateSequenceFilter=yo;var xo=Object.freeze({__proto__:null,CommonBits:mr,CommonBitsOp:ao,CommonBitsRemover:fr,EnhancedPrecisionOp:class{static union(t,e){let n=null;try{return t.union(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).union(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static intersection(t,e){let n=null;try{return t.intersection(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).intersection(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static buffer(t,e){let n=null;try{return t.buffer(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).buffer(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static symDifference(t,e){let n=null;try{return t.symDifference(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).symDifference(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static difference(t,e){let n=null;try{return t.difference(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).difference(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}},GeometryPrecisionReducer:ho,MinimumClearance:_o,SimpleMinimumClearance:mo});class Eo{constructor(){Eo.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new Kt;const t=arguments[0];this._pts=t}static simplify(t,e){const n=new Eo(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new R;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new m(this._pts[e]));return t.toCoordinateArray()}}class Io{constructor(){Io.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Io(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new No(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class No extends me{constructor(){super(),No.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):Eo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof rt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof gt?s:null}}Io.DPTransformer=No;class wo extends Kt{constructor(){super(),wo.constructor_.apply(this,arguments)}static constructor_(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];wo.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,t,e),this._parent=n,this._index=s}}getIndex(){return this._index}getParent(){return this._parent}}class Co{constructor(){Co.constructor_.apply(this,arguments)}static constructor_(){if(this._parentLine=null,this._segs=null,this._resultSegs=new L,this._minimumSize=null,1===arguments.length){const t=arguments[0];Co.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(Co.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(Co.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new wo(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return Co.extractCoordinates(this._resultSegs)}}class So{constructor(){So.constructor_.apply(this,arguments)}static constructor_(){this._index=new Ns}remove(t){this._index.remove(new O(t.p0,t.p1),t)}add(){if(arguments[0]instanceof Co){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof Kt){const t=arguments[0];this._index.insert(new O(t.p0,t.p1),t)}}query(t){const e=new O(t.p0,t.p1),n=new Lo(t);this._index.query(e,n);return n.getItems()}}class Lo{constructor(){Lo.constructor_.apply(this,arguments)}static constructor_(){this._querySeg=null,this._items=new L;const t=arguments[0];this._querySeg=t}visitItem(t){const e=t;O.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class To{constructor(){To.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._inputIndex=new So,this._outputIndex=new So,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new Kt(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new Kt;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new Kt;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(To.isInLineSection(t,e,i))continue;return!0}}return!1}}class Ro{constructor(){Ro.constructor_.apply(this,arguments)}static constructor_(){this._inputIndex=new So,this._outputIndex=new So,this._distanceTolerance=0}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new To(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}}class Po{constructor(){Po.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._lineSimplifier=new Ro,this._linestringMap=null;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Po(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();this._linestringMap=new Nt,this._inputGeom.apply(new vo(this)),this._lineSimplifier.simplify(this._linestringMap.values());return new Oo(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}}class Oo extends me{constructor(){super(),Oo.constructor_.apply(this,arguments)}static constructor_(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof $){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}}class vo{constructor(){vo.constructor_.apply(this,arguments)}static constructor_(){this.tps=null;const t=arguments[0];this.tps=t}filter(t){if(t instanceof $){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new Co(e,n);this.tps._linestringMap.put(e,s)}}get interfaces_(){return[k]}}Po.LineStringTransformer=Oo,Po.LineStringMapBuilderFilter=vo;class bo{constructor(){bo.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e}static simplify(t,e){return new bo(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=Mo.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new m(n[0])]:n}}class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static constructor_(){this._pt=null,this._prev=null,this._next=null,this._area=Mo.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new Mo(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new R;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=Mo.MAX_AREA,null;this._area=Math.abs(ne.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}}Mo.MAX_AREA=r.MAX_VALUE,bo.VWVertex=Mo;class Do{constructor(){Do.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Do(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Ao(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class Ao extends me{constructor(){super(),Ao.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):bo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof rt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof gt?s:null}}Do.VWTransformer=Ao;var Fo=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Io,TopologyPreservingSimplifier:Po,VWSimplifier:Do});class Go{constructor(){Go.constructor_.apply(this,arguments)}static constructor_(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()}static pointAlongReverse(t,e){const n=new m;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=Go.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=Go.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}}class qo{findSplitPoint(t,e){}}class Bo{static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new Go(n),r=Bo.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}get interfaces_(){return[qo]}}class Yo{static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=A.valueOf(t.x).selfSubtract(s.x),r=A.valueOf(t.y).selfSubtract(s.y),o=A.valueOf(e.x).selfSubtract(s.x),l=A.valueOf(e.y).selfSubtract(s.y),a=A.valueOf(n.x).selfSubtract(s.x),c=A.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),p=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(p.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=Yo.isInCircleNonRobust(t,e,n,s),r=Yo.isInCircleDDSlow(t,e,n,s),o=Yo.isInCircleCC(t,e,n,s),l=ne.circumcentre(t,e,n);Y.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(Y.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),Y.out.println(Wt.toLineString(new mt([t,e,n,s]))),Y.out.println("Circumcentre = "+Wt.toPoint(l)+" radius = "+t.distance(l)),Y.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),Y.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),Y.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),Y.out.println())}static isInCircleDDFast(t,e,n,s){const i=A.sqr(t.x).selfAdd(A.sqr(t.y)).selfMultiply(Yo.triAreaDDFast(e,n,s)),r=A.sqr(e.x).selfAdd(A.sqr(e.y)).selfMultiply(Yo.triAreaDDFast(t,n,s)),o=A.sqr(n.x).selfAdd(A.sqr(n.y)).selfMultiply(Yo.triAreaDDFast(t,e,s)),l=A.sqr(s.x).selfAdd(A.sqr(s.y)).selfMultiply(Yo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=ne.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=A.valueOf(s.x),r=A.valueOf(s.y),o=A.valueOf(t.x),l=A.valueOf(t.y),a=A.valueOf(e.x),c=A.valueOf(e.y),h=A.valueOf(n.x),u=A.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(Yo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(Yo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(Yo.triAreaDDSlow(o,l,a,c,i,r)),p=i.multiply(i).add(r.multiply(r)).multiply(Yo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(p).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*Yo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*Yo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*Yo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*Yo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return Yo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=A.valueOf(e.x).selfSubtract(t.x).selfMultiply(A.valueOf(n.y).selfSubtract(t.y)),i=A.valueOf(e.y).selfSubtract(t.y).selfMultiply(A.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}}class Vo{constructor(){Vo.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new m(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e,n)}}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.getZ()-e.getZ();return e.getZ()+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}}circleCenter(t,e){const n=new Vo(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new ee(s,i);let o=null;try{o=new Vo(r.getX(),r.getY())}catch(s){if(!(s instanceof te))throw s;Y.err.println("a: "+n+"  b: "+t+"  c: "+e),Y.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.getZ()}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new ee(t.getX()+n/2,t.getY()+s/2,1),r=new ee(t.getX()-s+n/2,t.getY()+n+s/2,1);return new ee(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return Yo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.getZ()+t.getZ())/2;return new Vo(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.setZ(t)}times(t){return new Vo(t*this._p.x,t*this._p.y)}cross(){return new Vo(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new Vo(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=this,s=e.sub(t),i=n.sub(t),r=s.crossProduct(i);return r>0?Vo.LEFT:r<0?Vo.RIGHT:s.getX()*i.getX()<0||s.getY()*i.getY()<0?Vo.BEHIND:s.magn()<i.magn()?Vo.BEYOND:t.equals(n)?Vo.ORIGIN:e.equals(n)?Vo.DESTINATION:Vo.BETWEEN}sum(t){return new Vo(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}}Vo.LEFT=0,Vo.RIGHT=1,Vo.BEYOND=2,Vo.BEHIND=3,Vo.BETWEEN=4,Vo.ORIGIN=5,Vo.DESTINATION=6;class zo extends Vo{constructor(){super(),zo.constructor_.apply(this,arguments)}static constructor_(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];Vo.constructor_.call(this,t)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}}class Xo{constructor(){Xo.constructor_.apply(this,arguments)}static constructor_(){this._rot=null,this._vertex=null,this._next=null,this._data=null}static makeEdge(t,e){const n=new Xo,s=new Xo,i=new Xo,r=new Xo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();Xo.splice(t,e),Xo.splice(t.sym(),n),Xo.splice(t,e.lNext()),Xo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=Xo.makeEdge(t.dest(),e.orig());return Xo.splice(n,t.lNext()),Xo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new Kt(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Wt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}}class ko{constructor(){ko.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);Xo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))Xo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}}class Uo{locate(t){}}class Ho{constructor(){Ho.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}get interfaces_(){return[Uo]}}class Wo extends h{constructor(){super(),Wo.constructor_.apply(this,arguments)}static constructor_(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];h.constructor_.call(this,t)}else if(arguments[0]instanceof Kt){const t=arguments[0];h.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new Kt(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,Wo.msgWithSpatial(t,e)),this._seg=new Kt(e)}}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}}class Zo{visit(t){}}class jo{constructor(){jo.constructor_.apply(this,arguments)}static constructor_(){this._visitedKey=0,this._quadEdges=new L,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new Kt,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/jo.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Ho(this)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new s("Edges do not form a triangle")}getTriangleVertices(t){const e=new Jo;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=Xo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new L,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new R;i.addAll(n,!1),i.closeRing(),i.size()<4&&(Y.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);Xo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return Xo.splice(e.sym(),n),Xo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);jo.getTriangleEdges(t,e);const n=new Array(3).fill(null);jo.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=Xo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new en;n.push(this._startingEdge);const s=new Et;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());return this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new O(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new Vo((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new Vo(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new Vo(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new O(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new $o;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new Et;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new L,n=new Et;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Qo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new L,n=new en;n.push(this._startingEdge);const s=new Et;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){Xo.splice(t,t.oPrev()),Xo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new Wo(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new Ko,!0);const e=new L;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Lt.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);Xo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof Vo){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._locator.locate(new Vo(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new Vo(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}}class Ko{visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=ne.circumcentreDD(e,n,s),r=new Vo(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}get interfaces_(){return[Zo]}}class Qo{constructor(){Qo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}get interfaces_(){return[Zo]}}class Jo{constructor(){Jo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}get interfaces_(){return[Zo]}}class $o{constructor(){$o.constructor_.apply(this,arguments)}static constructor_(){this._coordList=new R,this._triCoords=new L}checkTriangleSize(t){t.length>=2?Wt.toLineString(t[0],t[1]):t.length>=1&&Wt.toPoint(t[0])}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}get interfaces_(){return[Zo]}}jo.TriangleCircumcentreVisitor=Ko,jo.TriangleEdgesListVisitor=Qo,jo.TriangleVertexListVisitor=Jo,jo.TriangleCoordinatesVisitor=$o,jo.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class tl{constructor(){tl.constructor_.apply(this,arguments)}static constructor_(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new Kt(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new Kt(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];tl.constructor_.call(this,new m(t,e,n),new m(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];tl.constructor_.call(this,new m(t,e,n),new m(s,i,r),o)}}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).getZ()}getStartZ(){return this._ls.getCoordinate(0).getZ()}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}}class el extends h{constructor(){super(),el.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,el.msgWithCoord(t,e)),this._pt=new m(e)}}static msgWithCoord(t,e){return null!==e?t+" [ "+Wt.toPoint(e)+" ]":t}getCoordinate(){return this._pt}}class nl{constructor(){nl.constructor_.apply(this,arguments)}static constructor_(){this._initialVertices=null,this._segVertices=null,this._segments=new L,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new Bo,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new L(t),this._tolerance=e,this._kdt=new gs(e)}static computeVertexEnvelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<nl.MAX_SPLIT_ITER);if(t===nl.MAX_SPLIT_ITER)throw new el("Too many splitting iterations while enforcing constraints.  Last split point was at: ",this._splitPt)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Lt,e=this.getPointArray(),n=new sn(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new m((e.x+n.x)/2,(e.y+n.y)/2),i=e.distance(s),o=new O(s);o.expandBy(i);const l=this._kdt.query(o);let a=null,c=r.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const r=t.next().getCoordinate();if(r.equals2D(e)||r.equals2D(n))continue;const o=s.distance(r);if(o<i){const t=o;(null===a||t<c)&&(a=r,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new L;let n=0;const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new tl(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new tl(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new zo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new zo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=nl.computeVertexEnvelope(this._initialVertices),e=nl.computeVertexEnvelope(this._segVertices),n=new O(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new O(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new jo(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Ho(this._subdiv)),this._incDel=new ko(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof zo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof m){const t=arguments[0];this.insertSite(this.createVertex(t))}}}nl.MAX_SPLIT_ITER=99;class sl{constructor(){sl.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null}static extractUniqueCoordinates(t){if(null===t)return new R;const e=t.getCoordinates();return sl.unique(e)}static envelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=_t.copyDeep(t);st.sort(e);return new R(e,!1)}static toVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Vo(t))}return e}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords),e=sl.toVertices(this._siteCoords);this._subdiv=new jo(t,this._tolerance);new ko(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof U){const t=arguments[0];this._siteCoords=sl.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=sl.unique(_t.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}}class il{constructor(){il.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new Wn}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=ye.getLines(t),n=new L;for(let t=e.iterator();t.hasNext();){const e=t.next();il.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[1],e=arguments[0].getCoordinates();for(let n=1;n<e.length;n++)t.add(new tl(e[n-1],e[n]))}}createSiteVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new zo(t))}return e}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords);let e=new L;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=il.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new nl(n,this._tolerance);s.setConstraints(e,new L(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=sl.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new zo(e[t]);this._constraintVertexMap.put(e[t],n)}}}class rl{constructor(){rl.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new L;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=wr.intersection(n,r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Lt.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords);if(this._diagramEnv=this._clipEnv,null===this._diagramEnv){this._diagramEnv=t;const e=this._diagramEnv.getDiameter();this._diagramEnv.expandBy(e)}const e=sl.toVertices(this._siteCoords);this._subdiv=new jo(t,this._tolerance);new ko(this._subdiv).insertSites(e)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return rl.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof U){const t=arguments[0];this._siteCoords=sl.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=sl.unique(_t.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}}var ll=Object.freeze({__proto__:null,Vertex:Vo}),al=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:il,DelaunayTriangulationBuilder:sl,VoronoiDiagramBuilder:rl,quadedge:ll});class cl{constructor(){cl.constructor_.apply(this,arguments)}static constructor_(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];cl.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];cl.constructor_.call(this,t,e.getComponentIndex(),cl.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!I(t,Z))throw new s("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=n,this.loadCurrentLine()}}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}}class hl{constructor(){hl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new hl(t).indexOf(e)}static indexOfAfter(t,e,n){return new hl(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=e,i=0;const o=new Kt,l=new cl(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const r=o.distance(t),a=this.segmentNearestMeasure(o,t,i);r<n&&a>e&&(s=a,n=r),i+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}}class ul{constructor(){ul.constructor_.apply(this,arguments)}static constructor_(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ul.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}}static getEndLocation(t){const e=new ul;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.getZ()-t.getZ())*n+t.getZ();return new m(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}static numSegments(t){const e=t.getNumPoints();return e<=1?0:e-1}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex),n=ul.numSegments(e);return this._segmentIndex>=n||this._segmentIndex===n-1&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex),n=ul.numSegments(e);return this._segmentIndex<n?this:new ul(this._componentIndex,n-1,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=ul.numSegments(e))return n;const s=e.getCoordinateN(this._segmentIndex+1);return ul.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=ul.numSegments(e)){const t=e.getCoordinateN(e.getNumPoints()-2);return new Kt(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new Kt(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=ul.numSegments(e),this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=ul.numSegments(e),this._segmentFraction=0}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new ul(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=ul.numSegments(e)&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}get interfaces_(){return[o]}}class gl{constructor(){gl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new gl(t).indexOf(e)}static indexOfAfter(t,e,n){return new gl(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=0,i=0,o=-1;const l=new Kt;for(let r=new cl(this._linearGeom);r.hasNext();r.next())if(!r.isEndOfLine()){l.p0=r.getSegmentStart(),l.p1=r.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=r.getComponentIndex(),u=r.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,i=u,o=c,n=a)}if(n===r.MAX_VALUE)return new ul(e);return new ul(s,i,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=ul.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}}class dl{constructor(){dl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indicesOf(t,e){return new dl(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new gl(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}}class _l{constructor(){_l.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static getLength(t,e){return new _l(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[1];return new _l(arguments[0]).getLocation(t)}if(3===arguments.length){const t=arguments[1],e=arguments[2];return new _l(arguments[0]).getLocation(t,e)}}getLength(t){let e=0;const n=new cl(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new ul(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new ul;let e=0;const n=new cl(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new ul(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new ul(r,o,s)}e+=i}n.next()}return ul.getEndLocation(this._linearGeom)}}class pl{constructor(){pl.constructor_.apply(this,arguments)}static constructor_(){this._geomFact=null,this._lines=new L,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let n=null;try{n=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof s))throw t;if(!this._ignoreInvalidLines)throw t}null!==n&&this._lines.add(n)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new R),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}}class ml{constructor(){ml.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}static extract(t,e,n){return new ml(t).extract(e,n)}computeLinear(t,e){const n=new pl(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new cl(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new R;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return I(t,Z)?t.reverse():(g.shouldNeverReachHere("non-linear geometry encountered"),null)}}class fl{constructor(){fl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return _l.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return _l.getLocation(this._linearGeom,t,e)}}project(t){return hl.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return _l.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=_l.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return hl.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return ml.extract(this._linearGeom,r,o)}indexOf(t){return hl.indexOf(this._linearGeom,t)}indicesOf(t){const e=dl.indicesOf(this._linearGeom,t);return[_l.getLength(this._linearGeom,e[0]),_l.getLength(this._linearGeom,e[1])]}}class yl{constructor(){yl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return gl.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof $||this._linearGeom instanceof St))throw new s("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[1],e=arguments[0].toLowest(this._linearGeom);return e.getSegment(this._linearGeom).pointAlongOffset(e.getSegmentFraction(),t)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return ul.getEndLocation(this._linearGeom)}getStartIndex(){return new ul}indexOfAfter(t,e){return gl.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return ml.extract(this._linearGeom,t,e)}indexOf(t){return gl.indexOf(this._linearGeom,t)}indicesOf(t){return dl.indicesOf(this._linearGeom,t)}}var xl=Object.freeze({__proto__:null,LengthIndexedLine:fl,LengthLocationMap:_l,LinearGeometryBuilder:pl,LinearIterator:cl,LinearLocation:ul,LocationIndexedLine:yl});class El{static transform(t,e){const n=new L;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}}El.Function=function(){};class Il{constructor(){Il.constructor_.apply(this,arguments)}static constructor_(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}get interfaces_(){return[H]}}class Nl{constructor(){Nl.constructor_.apply(this,arguments)}static constructor_(){this._n=0}filter(t){this._n++}getCount(){return this._n}get interfaces_(){return[H]}}class wl{constructor(){wl.constructor_.apply(this,arguments)}static constructor_(){this._counts=new Nt}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new Cl(1)):e.increment()}}class Cl{constructor(){Cl.constructor_.apply(this,arguments)}static constructor_(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}}count(){return this.count}increment(){this.count++}}function Sl(){}function Ll(){}function Tl(){}wl.Counter=Cl;class Rl extends n{}function Pl(){}class Ol{static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new Tl,n=new Sl;return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";new Ll(Ol.getStackTrace(t));const s=new Pl;for(let t=0;t<e;t++)try{n+=s.readLine()+Ol.NEWLINE}catch(t){if(!(t instanceof Rl))throw t;g.shouldNeverReachHere()}return n}}static spaces(t){return Ol.chars(" ",t)}static split(t,e){const n=e.length,s=new L;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}}Ol.NEWLINE=Y.getProperty("line.separator");var vl=Object.freeze({__proto__:null,CollectionUtil:El,CoordinateArrayFilter:Il,CoordinateCountFilter:Nl,GeometricShapeFactory:we,NumberUtil:e,ObjectCounter:wl,PriorityQueue:Ls,StringUtil:Ol,UniqueCoordinateArrayFilter:nn});$.prototype.getBoundary=function(){return ii.getBoundary(this)},St.prototype.getBoundary=function(){return ii.getBoundary(this)},U.prototype.equalsTopo=function(t){return Qr.equalsTopo(this,t)},U.prototype.equals=function(t){return null!==t&&Qr.equalsTopo(this,t)},U.prototype.union=function(){if(0===arguments.length)return io.union(this);if(1===arguments.length){const t=arguments[0];return eo.union(this,t)}},U.prototype.isValid=function(){return Gr.isValid(this)},U.prototype.intersection=function(t){return wr.intersection(this,t)},U.prototype.covers=function(t){return Qr.covers(this,t)},U.prototype.coveredBy=function(t){return Qr.covers(t,this)},U.prototype.touches=function(t){return Qr.touches(this,t)},U.prototype.intersects=function(t){return Qr.intersects(this,t)},U.prototype.within=function(t){return Qr.contains(t,this)},U.prototype.overlaps=function(t){return Qr.overlaps(this,t)},U.prototype.disjoint=function(t){return Qr.disjoint(this,t)},U.prototype.crosses=function(t){return Qr.crosses(this,t)},U.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return qi.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return qi.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return qi.bufferOp(this,t,e,n)}},U.prototype.convexHull=function(){return new sn(this).getConvexHull()},U.prototype.relate=function(){if(1===arguments.length){const t=arguments[0];return Qr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Qr.relate(this,t).matches(e)}},U.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=$e.getCentroid(this);return this.createPointFromInternalCoord(t,this)},U.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new un(this):1===e?new hn(this):new on(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},U.prototype.symDifference=function(t){return wr.symDifference(this,t)},U.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},U.prototype.toText=function(){return(new Wt).write(this)},U.prototype.toString=function(){return this.toText()},U.prototype.contains=function(t){return Qr.contains(this,t)},U.prototype.difference=function(t){return wr.difference(this,t)},U.prototype.isSimple=function(){return new oi(this).isSimple()},U.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&zi.isWithinDistance(this,t,e)},U.prototype.distance=function(t){return zi.distance(this,t)};t.algorithm=En,t.densify=wn,t.dissolve=vn,t.geom=Te,t.geomgraph=cs,t.index=As,t.io=Vs,t.linearref=xl,t.noding=si,t.operation=lo,t.precision=xo,t.simplify=Fo,t.triangulate=al,t.util=vl,t.version="2.9.3"}));
//# sourceMappingURL=jsts.min.js.map


/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./src/base/AgentPoint.js":
/*!********************************!*\
  !*** ./src/base/AgentPoint.js ***!
  \********************************/
/*! exports provided: AgentPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgentPoint", function() { return AgentPoint; });
//@ts-check

/** */
class AgentPoint {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(x, y, sx=0, sy=0) {

        //position

        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y

        //speed

        /** @type {number} */
        this.sx = sx
        /** @type {number} */
        this.sy = sy
        /** @type {number} */
        this.s = undefined
        /** @type {number} */
        this.sa = undefined
    }


    /**
     * @param {AgentPoint} a
     * @returns {number} The distance to another agent.
     */
    d(a) {
        return this.dP(a.x, a.y);
    }

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @returns {number} The distance to a position.
     */
    dP(x, y) {
        return Math.hypot((x - this.x), (y - this.y));
    }

    /** 
    * Set random speed
    * 
    * @param {number} minSpeed
    * @param {number} maxSpeed
    */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        this.s = minSpeed + Math.random() * (maxSpeed - minSpeed);
        this.sa = 2 * Math.random() * Math.PI;
        this.sx = this.s * Math.cos(this.sa)
        this.sy = this.s * Math.sin(this.sa)
    }

    /** */
    computeSpeed() {
        this.s = Math.hypot(this.sx, this.sy);
        return this.s
    }

    /** */
    computeSpeedAngle() {
        this.sa = Math.atan2(this.sy, this.sx);
        return this.sa
    }

}


/***/ }),

/***/ "./src/base/GeoCanvas.js":
/*!*******************************!*\
  !*** ./src/base/GeoCanvas.js ***!
  \*******************************/
/*! exports provided: GeoCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoCanvas", function() { return GeoCanvas; });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
//@ts-check
/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */




/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 * 
 * @author Julien Gaffuri
 */
class GeoCanvas {

    /**
     * @constructor
     * @param {string} canvasId
     * @param {object} center Geographical coordinates of the center
     * @param {number} zf The zoom factor (pixel size, in ground m)
     */
    constructor(canvasId = "vacanvas", center = undefined, zf = 1) {

        /** @type {object} */
        this.canvas = document.getElementById(canvasId);

        /** @type {number} */
        this.w = this.canvas.offsetWidth;
        /** @type {number} */
        this.h = this.canvas.offsetHeight;

        this.canvas.width = this.w;
        this.canvas.height = this.h;

        /**@type {object} */
        this.ctx = this.canvas.getContext("2d");

        // set geo coordinates of the center
        this.setCenter(center || { x: this.w * 0.5, y: this.h * 0.5 })

        // set zoom factor: pixel size, in m/pix
        this.setZf(zf);

        //extent
        /** @type {Envelope} */
        this.extGeo = undefined;
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoomIdentity"]
        Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(this.canvas).call(
            Object(d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoom"])().on("zoom", (e) => {
                const t = e.transform
                const f = tP.k / t.k
                if (f == 1) {
                    //pan
                    const dx = tP.x - t.x
                    const dy = tP.y - t.y
                    this.pan(dx * this.getZf(), -dy * this.getZf())
                } else {
                    const se = e.sourceEvent;
                    if (se instanceof WheelEvent) {
                        //zoom at the mouse position
                        this.zoom(f, this.pixToGeoX(e.sourceEvent.offsetX), this.pixToGeoY(e.sourceEvent.offsetY))
                    } else if (se instanceof TouchEvent) {
                        //compute average position of the touches
                        let tx = 0, ty = 0
                        for (let tt of se.targetTouches) { tx += tt.clientX; ty += tt.clientY }
                        tx /= se.targetTouches.length; ty /= se.targetTouches.length
                        //zoom at this average position
                        this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                    }
                }
                tP = t
            }));
    }

    /** @param {{x:number,y:number}} v Geographical coordinates of the center */
    setCenter(v) { this.center = v; }
    /** @returns {{x:number,y:number}} Geographical coordinates of the center */
    getCenter() { return this.center; }

    /** @param {number} v The zoom factor (pixel size, in ground m) */
    setZf(v) { this.zf = v; }
    /** @returns {number} The zoom factor (pixel size, in ground m) */
    getZf() { return this.zf; }




    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.getZf();
        const tx = -this.center.x / this.getZf() + this.w * 0.5;
        const ty = this.center.y / this.getZf() + this.h * 0.5;
        this.ctx.setTransform(k, 0, 0, -k, tx, ty);
    }


    /** The function specifying how to draw the map. */
    redraw() {
        throw new Error('Method redraw not implemented.');
    }

    /**
     * Clear the app screen. To be used before a redraw for example.
     * @param {string} color 
     */
    clear(color = "white") {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.w, this.h);
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
    */
    geoToPixX(xGeo) { return (xGeo - this.center.x) / this.getZf() + this.w * 0.5; }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
    */
    geoToPixY(yGeo) { return -(yGeo - this.center.y) / this.getZf() + this.h * 0.5; }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
    */
    pixToGeoX(x) { return (x - this.w * 0.5) * this.getZf() + this.center.x; }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
    */
    pixToGeoY(y) { return -(y - this.h * 0.5) * this.getZf() + this.center.y; }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo, dyGeo) {
        //TODO force extend to remain
        this.center.x += dxGeo;
        this.center.y += dyGeo;
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.center.x, yGeo = this.center.y) {
        //TODO force extend to remain
        this.setZf(f * this.getZf());
        this.center.x += (xGeo - this.center.x) * (1 - f)
        this.center.y += (yGeo - this.center.y) * (1 - f)
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * @param {number} marginPx 
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx)
        }
        return this.extGeo;
    }

    /**
     * Check if the object has to be drawn
     * 
     * @param {{x:number,y:number}} obj 
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false;
        if (obj.x > this.extGeo.xMax) return false;
        if (obj.y < this.extGeo.yMin) return false;
        if (obj.y > this.extGeo.yMax) return false;
        return true
    }

}


/***/ }),

/***/ "./src/base/SpatialIndex.js":
/*!**********************************!*\
  !*** ./src/base/SpatialIndex.js ***!
  \**********************************/
/*! exports provided: SpatialIndex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpatialIndex", function() { return SpatialIndex; });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
//@ts-check

//see https://github.com/mourner/rbush


/**
 * @template T
 */
class SpatialIndex {

    /**
     * @constructor
     */
    constructor() {
        class MyRBush extends rbush__WEBPACK_IMPORTED_MODULE_0___default.a {
            /** @param {{x:number,y:number}} obj  */
            toBBox(obj) { return { minX: obj.x, minY: obj.y, maxX: obj.x, maxY: obj.y }; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinX(a, b) { return a.x - b.x; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinY(a, b) { return a.y - b.y; }
        }

        /** @type {MyRBush} */
        this.tree = new MyRBush();
    }

    //TODO bulk remove ?

    /**
     * @param {number} xmin
     * @param {number} ymin
     * @param {number} xmax
     * @param {number} ymax
     * @return {Array.<T>}
     */
    get(xmin, ymin, xmax, ymax) {
        return this.tree.search({
            minX: xmin,
            minY: ymin,
            maxX: xmax,
            maxY: ymax
        });
    }

    /**
     * @param {T} obj
     */
    insert(obj) {
        this.tree.insert(obj);
    }

    /**
     * Bulk insert
     * 
     * @param {Array.<T>} objs
     */
    load(objs) {
        this.tree.load(objs);
    }

    /**
     * @param {T} obj
     */
    remove(obj) {
        this.tree.remove(obj)
    }

    /**
     */
    clear() {
        this.tree.clear()
    }

}


/***/ }),

/***/ "./src/base/lib.js":
/*!*************************!*\
  !*** ./src/base/lib.js ***!
  \*************************/
/*! exports provided: objToArray, removeFromArray, removeFromArrayS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objToArray", function() { return objToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArray", function() { return removeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArrayS", function() { return removeFromArrayS; });
//@ts-check
/**
 * @template T
 * @param {Object.<?, T>} obj
 * @returns {Array.<T>}
 */
const objToArray = function (obj) {
    var out = [];
    for (var key in obj)
        if (obj.hasOwnProperty(key))
            out.push(obj[key]);
    return out;
};

/**
 * @template T
 * @param {Array.<T>} arr
 * @param {T} obj
 * @param {boolean} msg 
 */
const removeFromArray = function (arr, obj, msg = true) {
    /** @type {number} */
    var index = arr.indexOf(obj);
    if (index > -1)
        arr.splice(index, 1);
    else
        if (msg) console.log("Impossible to remove element not present in array.");
};

/**
 * 
 * @template T
 * @param {Array.<T>} arr
 * @param {Array.<T>} objs 
 * @param {boolean} msg 
 */
const removeFromArrayS = function (arr, objs, msg = true) {
    for (let obj of objs)
        removeFromArray(arr, obj, msg)
};


/***/ }),

/***/ "./src/fish/Sardin.js":
/*!****************************!*\
  !*** ./src/fish/Sardin.js ***!
  \****************************/
/*! exports provided: Sardin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sardin", function() { return Sardin; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check





/** */
class Sardin extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {Sea} sea 
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(sea, x = sea.w * Math.random(), y = sea.h * Math.random(), sx = undefined, sy = undefined) {

        //
        super(x, y, sx, sy)

        /** @type {Sea} */
        this.sea = sea;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > sea.w ? sea.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > sea.h ? sea.h : y

        //speed
        if (!sx && !sy) {
            this.setRandomSpeed(0, this.sea.V_MAX)

            //acceleration
            /** @type {number} */
            this.ax = 0
            /** @type {number} */
            this.ay = 0

            //list of sardins in vision field
            /** @type {Array.<Sardin>} */
            this.obs = []
            //list of sardins in collision field
            /** @type {Array.<Sardin>} */
            this.col = []
        }
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    observe(sindex) {

        /** @type {Sea} */
        const s = this.sea
        /** @type {number} */
        const dO = s.D_OBS

        //initialise lists
        /** @type {Array.<Sardin>} */
        this.obs = [];
        /** @type {Array.<Sardin>} */
        this.col = [];

        //get sardins around using spatial index
        /** @type {Array.<Sardin>} */
        const ss = sindex.get(this.x - dO, this.y - dO, this.x + dO, this.y + dO);

        //get sardins in observation and collision fields
        for (let f of ss) {
            if (f == this) continue;
            if (this.d(f) <= s.D_COL)
                this.col.push(f);
            if (this.d(f) <= dO) {
                //check angle
                let da = Math.atan2(f.y - this.y, f.x - this.x) - this.sa;
                if (da > Math.PI) da -= 2 * Math.PI;
                else if (da <= -Math.PI) da += 2 * Math.PI;
                da = Math.abs(da);
                if (da > s.A_OBS * 0.5) continue;
                this.obs.push(f);
            }
        }

        //initialise acceleration
        this.ax = 0; this.ay = 0;

        //collision: repulsion
        for (let f of this.col) {
            const d = this.d(f);
            const a = 1.0 * (1 / (d * d) - 1 / (s.D_COL * s.D_COL));
            this.ax += a * (this.x - f.x) / d;
            this.ay += a * (this.y - f.y) / d;
        }

        // toward target speed
        const dv = (s.V_TARGET - this.s) * 0.01;
        this.ax += dv * this.sx / this.s;
        this.ay += dv * this.sy / this.s;

        //toward the observed mean position
        /*if(obs.size()>1){
            double xn=0,yn=0;
            for(Sardin s:obs){
                xn+=s.x;
                yn+=s.y;
            }
            xn=xn/obs.size();
            yn=yn/obs.size();
            double d=Math.hypot(xn-x,yn-y);
            ax+=-0.1*(x-xn)/d;
            ay+=-0.1*(y-yn)/d;
        }*/

        //toward the observed speed
        const t = 0.9;
        if (this.obs.length > 1) {
            let dsx = 0, dsy = 0;
            for (let s of this.obs) {
                dsx += s.sx;
                dsy += s.sy;
            }
            dsx = (t - 1) * this.sx + (1 - t) * dsx / this.obs.length;
            dsy = (t - 1) * this.sy + (1 - t) * dsy / this.obs.length;

            const a = 0.1;
            this.ax += a * dsx;
            this.ay += a * dsy;
        }

        //avoid shark
        const sh = s.shark;
        if (sh != null) {
            const d = Math.hypot((sh.x - this.x), (sh.y - this.y));
            if (d <= s.D_OBS) {
                const a = 5.0 * (1 / (d * d) - 1 / (dO * dO));
                this.ax += a * (this.x - sh.x) / d;
                this.ay += a * (this.y - sh.y) / d;
            }
        }

    }


    /**
     * @param {number} timeStepMs 
     */
    move(timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.sy += this.ay * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.s = this.computeSpeed()
        if (this.s > this.sea.V_MAX) {
            this.s = this.sea.V_MAX;
            this.sx = this.sea.V_MAX * Math.cos(this.sa);
            this.sy = this.sea.V_MAX * Math.sin(this.sa);
        }

        //compute new position
        this.x += this.sx * timeStepMs;
        this.y += this.sy * timeStepMs;

        //limit
        if (this.x < 0) this.x = this.sea.w;
        if (this.y < 0) this.y = this.sea.h;
        if (this.x > this.sea.w) this.x = 0;
        if (this.y > this.sea.h) this.y = 0;
    }


    /**
     * Display a sardin body
     * 
     * @param {GeoCanvas} cp 
     * @param {number} length 
     */
    display(cp, length) {
        const c2 = cp.ctx
        const c = Math.floor(255 * Math.abs(this.sa) / Math.PI);
        c2.strokeStyle = "rgb(255, 255, " + c + ")"
        const a = length / this.s;
        const dx = a * this.sx * 0.5;
        const dy = a * this.sy * 0.5;

        c2.beginPath();
        c2.moveTo(this.x - dx, this.y - dy);
        c2.lineTo(this.x + dx, this.y + dy);
        c2.closePath();
        c2.stroke();
    }

    /**
     * Display sardin vision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} lineWidth 
     */
    displayVisionField(cp, fillStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.arc(this.x, this.y, this.sea.D_OBS / cp.getZf(),
            this.sa - this.sea.A_OBS * 0.5,
            this.sa + this.sea.A_OBS * 0.5
        );
        c2.closePath();
        c2.fill();
    }

    /**
     * Display sardin vision links
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayVisionLinks(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        for (let sa2 of this.obs) {
            c2.beginPath();
            c2.moveTo(this.x, this.y);
            c2.lineTo(sa2.x, sa2.y);
            c2.closePath();
            c2.stroke();
        }
    }

    /**
     * Display sardin collision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayCollisionField(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.sea.D_COL * 0.5 / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/fish/Sea.js":
/*!*************************!*\
  !*** ./src/fish/Sea.js ***!
  \*************************/
/*! exports provided: Sea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sea", function() { return Sea; });
/* harmony import */ var _Sardin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sardin */ "./src/fish/Sardin.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
//@ts-check




/** */
class Sea {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */        //get 10 random locations

    constructor(w, h) {

        //TODO should become static attributes of Sardin class

        //observation
        /** @type {number} */
        this.D_OBS = 50
        /** @type {number} */
        this.A_OBS = 200 * Math.PI / 180

        //collision
        /** @type {number} */
        this.D_COL = 10

        //speed
        /** @type {number} */
        this.V_TARGET = 0.3
        /** @type {number} */
        this.V_MAX = 0.6

        //shark
        /** @type {number} */
        this.D_SHARK_EAT = 12
        /** @type {number} */
        this.EATEN_SARDIN_NB = 0


        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Sardin>} */
        this.fish = []

        //TODO
        this.shark = null;

        /** @type {Array.<Sardin>} */
        this.killed = [];
    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //ini
        for (let f of this.fish) {
            f.computeSpeed()
            f.computeSpeedAngle()
        }

        //make spatial index
        /** @type {SpatialIndex.<Sardin>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.fish)

        //observe
        for (let f of this.fish)
            f.observe(sindex);

        //shark eat fish
        this.sharkEat(sindex);

        //dispose spatial index
        //sindex.clear()

        //move
        for (let f of this.fish)
            f.move(timeStepMs);
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    sharkEat(sindex) {
        if (this.shark == null) return;

        /** @type {Array.<Sardin>} */
        this.killed = [];

        const x = this.shark.x, y = this.shark.y;
        const ss = sindex.get(x - this.D_SHARK_EAT, y - this.D_SHARK_EAT, x + this.D_SHARK_EAT, y + this.D_SHARK_EAT);
        for (let s of ss) {
            const d = Math.hypot((x - s.x), (y - s.y));
            if (d > this.D_SHARK_EAT) continue;
            this.killed.push(s);
            Object(_base_lib__WEBPACK_IMPORTED_MODULE_2__["removeFromArray"])(this.fish, s)
            //sindex.remove(s);
        }
        this.EATEN_SARDIN_NB += this.killed.length;
        //eatenFishNb.setText("Eaten fish: " + EATEN_SARDIN_NB);
        return this;
    }

    /**
     * Add fish
     * 
     * @param {number} nb 
     * @returns {this}
     */
    addFish(nb = 1) {
        for (let i = 0; i < nb; i++)
            this.fish.push(new _Sardin__WEBPACK_IMPORTED_MODULE_0__["Sardin"](this));
        return this
    }

    /**
     * Set random speed for all fish
     * @returns {this}
     */
    setRandomSpeed() {
        for (let f of this.fish)
            f.setRandomSpeed()
        return this
    }

}


/***/ }),

/***/ "./src/fish/index.js":
/*!***************************!*\
  !*** ./src/fish/index.js ***!
  \***************************/
/*! exports provided: fish */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return fish; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check



class FishSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        //TODO
        //add eaten fish nb label

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        /** @type {boolean} */
        this.showFishVisionField = false
        /** @type {boolean} */
        this.showFishVisionLinks = false
        /** @type {boolean} */
        this.showFishCollisionField = false

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx
            const s = th.sea

            this.initCanvasTransform()

            //clear
            c2.fillStyle = "rgba(120,120,255,0.6)";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //show vision field
            if (th.showFishVisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionField(this, "rgba(200,200,200,0.15)", 1)
            //show vision links
            if (th.showFishVisionLinks)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionLinks(this, "rgba(255,100,100,0.3)", 1)
            //show collision field
            if (th.showFishCollisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayCollisionField(this, "purple", 1)


            //display sardins
            c2.lineWidth = 2
            const sardinLength = 7
            for (let sa of s.fish)
                if (this.toDraw(sa))
                    sa.display(this, sardinLength)


            //display shark
            if (s.shark != null) {

                c2.lineWidth = 4
                c2.strokeStyle = "black"

                const sharkLength = 12
                const dx = sharkLength * Math.cos(s.shark.angle);
                const dy = sharkLength * Math.sin(s.shark.angle);

                c2.beginPath();
                c2.moveTo(s.shark.x, s.shark.y);
                c2.lineTo(s.shark.x - dx, s.shark.y + dy);
                c2.closePath();
                c2.stroke();
            }

            //display blood spot
            c2.fillStyle = "red";
            c2.lineWidth = 1
            for (let sa of s.killed) {
                c2.beginPath();
                c2.moveTo(sa.x, sa.y);
                c2.arc(sa.x, sa.y, 4, 0, 2 * Math.PI);
                c2.closePath();
                c2.fill();
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        this.cplus.canvas.addEventListener("mouseover", e => {
            th.sea.shark = { x: th.cplus.pixToGeoX(e.offsetX), y: th.cplus.pixToGeoY(e.offsetY), angle: 0 }
        });
        this.cplus.canvas.addEventListener("mousemove", e => {
            const xG = th.cplus.pixToGeoX(e.offsetX);
            const yG = th.cplus.pixToGeoY(e.offsetY);
            const angle = Math.atan2(-yG + th.sea.shark.y, xG - th.sea.shark.x);
            th.sea.shark = { x: xG, y: yG, angle: angle }
        });
        this.cplus.canvas.addEventListener("mouseout", e => {
            th.sea.shark = null;
        });


        /** @type {Sea} */
        this.sea = new _Sea__WEBPACK_IMPORTED_MODULE_0__["Sea"](this.w, this.h)

    }


    /**
     * @param {number} density 
     * @returns {this}
     */
    initRandom(density = 0.001) {
        this.sea.addFish(density * this.sea.w * this.sea.h);
        return this
    }

    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.sea.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this
    }

}

/**
 * @param {Object} opts 
 */
const fish = function (opts) {
    return new FishSimulation(opts)
}


/***/ }),

/***/ "./src/gol/Cell.js":
/*!*************************!*\
  !*** ./src/gol/Cell.js ***!
  \*************************/
/*! exports provided: Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return Cell; });
//@ts-check

/**
 * 
 */
class Cell {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} nb 
     */
    constructor(x, y, nb=0) {
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.nb = nb
    }

}


/***/ }),

/***/ "./src/gol/Universe.js":
/*!*****************************!*\
  !*** ./src/gol/Universe.js ***!
  \*****************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




/**
 * 
 */
class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Cell>} */
        this.population = [];
        /** @type {Object.<string,Cell>} */
        this.populationI = {};
    }

    /**
     * @param {number} x
     * @param {number} y
     * @returns {Cell|null}
     */
    add(x, y) {

        //find cell at location
        /**@type {string}*/
        const id = x + "_" + y;
        if (this.populationI[id]) return null;

        //create new cell
        /**@type {Cell} */
        const cell = new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x, y, 0)
        this.population.push(cell)
        this.populationI[id] = cell
        return cell
    }

    /**
     * @returns {this}
     */
    step() {

        //TODO double indexing? by raw and then column ?
        //populate cell surroundings
        /** @type {Object.<string, Cell>}
         * @dict */
        const surI = {};
        //go through list of cells
        for (let cell of this.population) {
            // +1 surrounding cells
            const srs = Universe.getCellSurrounding(cell, this);
            for (let sur of srs) {
                const key = sur.x + "_" + sur.y;
                const sur_ = surI[key];
                if (sur_) {
                    sur_.nb++;
                } else {
                    sur.nb = 1;
                    surI[key] = sur;
                }
            }
        }

        //B3/S23
        //kill cells
        /** @type {Array.<Cell>} */
        const cellsToKeep = [];
        /** @type {Object.<string, Cell>}
         * @dict */
        const cellsToKeepI = {};
        for (let cell of this.population) {
            const key = cell.x + "_" + cell.y;
            const cell_ = surI[key];
            if (!cell_) continue;
            //if (nb<2 or nb>3) -> kill
            if (cell_.nb < 2 || cell_.nb > 3) continue;
            cellsToKeep.push(cell);
            cellsToKeepI[key] = cell;
        }
        this.population = cellsToKeep;
        this.populationI = cellsToKeepI;

        //create new cells
        /** @type {Array.<Cell>} */
        const surs = Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["objToArray"])(surI);
        for (let sur of surs) {

            if (sur.nb !== 3) continue;

            //check if already alive
            const key = sur.x + "_" + sur.y;
            let cell = this.populationI[key];
            if (cell) continue;

            //create new cell
            this.population.push(sur);
            this.populationI[key] = sur;
        }
        return this;
    }


    /**
     * @param {number} nb
     * @param {number} timeoutMS
     * @param {GeoCanvas} cplus
     * @return {Universe}
     */
    start(nb, timeoutMS, cplus) {
        let i = 0;
        const uni = this;
        const engine = function () {
            //console.log(i);
            uni.step();
            cplus.redraw();
            if (nb > 0 && i++ > nb) return;
            setTimeout(engine, timeoutMS);
        };
        engine();
        return this;
    }

    /**
     * @param {Cell} cell
     * @param {Universe} uni
     * @return {Array.<Cell>}
     */
    static getCellSurrounding(cell, uni) {
        const x1 = cell.x === 0 ? uni.w - 1 : cell.x - 1;
        const x2 = cell.x === uni.w - 1 ? 0 : cell.x + 1;
        const y1 = cell.y === 0 ? uni.h - 1 : cell.y - 1;
        const y2 = cell.y === uni.h - 1 ? 0 : cell.y + 1;
        return [
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y2),
        ];
    }

}


/***/ }),

/***/ "./src/gol/index.js":
/*!**************************!*\
  !*** ./src/gol/index.js ***!
  \**************************/
/*! exports provided: gameOfLife */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return gameOfLife; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Universe */ "./src/gol/Universe.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




//TODO zoom/pan, with canvas transform: better universe limits
//TODO buttons (play, stop, speed, draw, pan)
//TODO check canvas animation


class GoLSimulation {

    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //clear
            this.initCanvasTransform()
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            //draw cells
            this.setCanvasTransform()
            c2.fillStyle = "blue";
            for (let cell of th.uni.population)
                c2.fillRect((cell.x), (cell.y), 1, 1);

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };

        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_1__["Universe"](this.w, this.h);
    }


    //
    initRandom(density = 0.05) {
        let i = 0;
        /** @type {number} */
        const nb = this.uni.w * this.uni.h * density;
        while (i < nb) {
            const x = Math.round(this.uni.w * Math.random());
            const y = Math.round(this.uni.h * Math.random());
            /** @type {Cell} */
            const cell = this.uni.add(x, y);
            if (cell) i++;
        }
        return this;
    }


    //
    start() {
        this.uni.start(-1, 0, this.cplus);
        return this;
    }

}


const gameOfLife = function (opts) {
    return new GoLSimulation(opts)
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: planets, gameOfLife, fish, preyPredator, urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _planets_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planets/index */ "./src/planets/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return _planets_index__WEBPACK_IMPORTED_MODULE_0__["planets"]; });

/* harmony import */ var _gol_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gol/index */ "./src/gol/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return _gol_index__WEBPACK_IMPORTED_MODULE_1__["gameOfLife"]; });

/* harmony import */ var _fish_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fish/index */ "./src/fish/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return _fish_index__WEBPACK_IMPORTED_MODULE_2__["fish"]; });

/* harmony import */ var _pp_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pp/index */ "./src/pp/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return _pp_index__WEBPACK_IMPORTED_MODULE_3__["preyPredator"]; });

/* harmony import */ var _urban_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./urban/index */ "./src/urban/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return _urban_index__WEBPACK_IMPORTED_MODULE_4__["urban"]; });

//@ts-check








/***/ }),

/***/ "./src/planets/Planet.js":
/*!*******************************!*\
  !*** ./src/planets/Planet.js ***!
  \*******************************/
/*! exports provided: Planet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Planet", function() { return Planet; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




class Planet extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @constructor
     * @param {Universe} u The universe the planet belongs to.
     * @param {number} m The mass
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} sx The speed x
     * @param {number} sy The speed y
     */
    constructor(u, m, x, y, sx = 0, sy = 0) {

        //
        super(x, y, sx, sy)

        /** @type {Universe} */
        this.u = u;
        u.ps.push(this)

        /** @type {number} */
        this.m = m;

        //compute radius
        /** @type {number} */
        const r = this.r();

        //set position
        /** @type {number} */
        this.x = x < r ? r : x > u.w - r ? u.w - r : x;
        /** @type {number} */
        this.y = y < r ? r : y > u.h - r ? u.h - r : y;

        //acceleration
        /** @type {number} */
        this.ax = 0;
        /** @type {number} */
        this.ay = 0;
    }

    /**
     * Update the force, based on the gravity of other planets.
     * @param {number} exponent
     */
    observe(exponent) {

        //compute gravity field at planet location
        const g = this.u.getGravityField(this.x, this.y, this, exponent);

        //set acceleration
        /** @type {number} */
        this.ax = g.gx;
        /** @type {number} */
        this.ay = g.gy;
    }


    /**
     * @return {number} The radius of the planet, depending on its mass.
     */
    r() {
        return Math.pow(this.m / Math.PI, 0.5);
    }


    /**
     * 
     * @param {boolean} bounce 
     * @param {number} maxSpeed 
     * @param {number} timeStepMs 
     */
    change(bounce = false, maxSpeed = 0.8, timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs;
        this.sy += this.ay * timeStepMs;

        //check vmax
        if (maxSpeed > 0) {
            /** @type {number} */
            const v = Math.sqrt(this.sx * this.sx + this.sy * this.sy);
            if (v > maxSpeed) {
                this.sx = maxSpeed * this.sx / v;
                this.sy = maxSpeed * this.sy / v;
            }
        }

        //compute new position
        /** @type {number} */
        let nx = this.x + this.sx * timeStepMs;
        /** @type {number} */
        let ny = this.y + this.sy * timeStepMs;

        //handle position limit
        if (bounce) {
            const r = this.r();
            const e = 1;
            if (nx < r) { nx = r; this.sx = -this.sx * e; }
            if (ny < r) { ny = r; this.sy = -this.sy * e; }
            if (nx > this.u.w - r) { nx = this.u.w - r; this.sx = -this.sx * e; }
            if (ny > this.u.h - r) { ny = this.u.h - r; this.sy = -this.sy * e; }
        } else {
            if (nx < 0) { nx = this.u.w; }
            if (ny < 0) { ny = this.u.h; }
            if (nx > this.u.w) { nx = 0; }
            if (ny > this.u.h) { ny = 0; }
        }

        //move
        this.x = nx;
        this.y = ny;
    }


    /**
     * Display planet
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     */
    display(cp, fillStyle) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r() / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
    }

    /**
     * Display planet acceleration
     * 
     * @param {GeoCanvas} cp 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     * @param {number} factor 
     */
    displayAcceleration(cp, strokeStyle = "cyan", lineWidth = 1, factor = 5000) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.lineTo(this.x + factor * this.ax, this.y + factor * this.ay);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/planets/Universe.js":
/*!*********************************!*\
  !*** ./src/planets/Universe.js ***!
  \*********************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
//@ts-check




class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Planet>} */
        this.ps = [];
    }

    /**
     * Compute the mass of the universe, as the sum of the mass of its planets.
     * @returns {number}
     */
    m() {
        let m = 0;
        for (let p of this.ps)
            m += p.m;
        return m;
    }


    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {Planet} pIgnore A planet to ignore
     * @param {number} exponent
     * @returns {{gx:number,gy:number}}
     */
    getGravityField(x, y, pIgnore = undefined, exponent = 2) {

        /** @type {number} */
        let gx = 0
        /** @type {number} */
        let gy = 0

        //gothrough all planets in the universe
        for (let p of this.ps) {

            //ignore planet
            if (pIgnore && p == pIgnore)
                continue;

            //compute distance
            /** @type {number} */
            let d = p.dP(x, y);
            if (d === 0)
                continue;

            //compute and add contribution
            d = d * Math.pow(d, exponent);
            gx += 0.01 * (p.x - x) * p.m / d;
            gy += 0.01 * (p.y - y) * p.m / d;
        }
        return { gx: gx, gy: gy }
    }


    /**
     * Aggregate two planets
     * 
     * @param {Planet} p1
     * @param {Planet} p2
     * @param {SpatialIndex.<Planet>} sindex
     * @returns {Planet}
     */
    aggregate(p1, p2, sindex) {
        const m = p1.m + p2.m;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](
            this,
            m,
            (p1.x * p1.m + p2.x * p2.m) / m,
            (p1.y * p1.m + p2.y * p2.m) / m,
            (p1.sx * p1.m + p2.sx * p2.m) / m,
            (p1.sy * p1.m + p2.sy * p2.m) / m
        );
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p1);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p2);

        if (sindex) {
            sindex.remove(p1)
            sindex.remove(p2)
            sindex.insert(p)
        }

        return p;
    }



    /**
     * @param {SpatialIndex.<Planet>} sindex
     * @param {number} collisionFactor
     * @returns {Array.<Planet>}
     */
    findCollision(sindex, collisionFactor = 1) {
        for (let pi of this.ps) {

            const w = 2 * pi.r();
            const cand = sindex.get(pi.x - w, pi.y - w, pi.x + w, pi.y + w);

            for (let pj of cand) {

                if (pi == pj) continue;

                /** @type {number} */
                const d1 = pi.d(pj);
                /** @type {number} */
                const d2 = (pi.r() + pj.r()) * collisionFactor;
                if (d1 > d2)
                    continue;
                return [pi, pj];

            }
        }
        return null;
    }


    /**
     * Add planets with random speed
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed
     * @param {number} maxSpeed
     * @returns {this}
     */
    addPlanets(nb = 1, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        for (let i = 0; i < nb; i++) {
            const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, mi, this.w * Math.random(), this.h * Math.random());
            p.setRandomSpeed(minSpeed, maxSpeed);
        }
        return this;
    }



    /**
     * 
     * @param {boolean} bounce 
     * @param {number} vmax 
     * @param {number} exponent 
     * @param {number} collisionFactor 
     * @param {number} timeStepMs 
     * @returns {this}
     */
    step(bounce = false, vmax = 0.8, exponent = 2, collisionFactor = 1, timeStepMs = 10) {

        //observation
        for (let p of this.ps)
            p.observe(exponent);

        //action
        for (let p of this.ps)
            p.change(bounce, vmax, timeStepMs);


        //collision detection
        this.detectCollisions(collisionFactor)

        return this;
    }

    /**
     * @param {number} collisionFactor 
     * @returns {this}
     */
    detectCollisions(collisionFactor = 1) {

        /** @type {SpatialIndex.<Planet>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.ps)

        //find first collision
        /** @type {Array.<Planet>} */
        let pair = this.findCollision(sindex, collisionFactor);
        while (pair !== null) {

            //aggregate
            const p = this.aggregate(pair[0], pair[1], sindex)

            //find next collision
            pair = this.findCollision(sindex, collisionFactor);
        }

        return this;
    }


    /**
     * Assign random speed to all planets
     * 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        for (let p of this.ps)
            p.setRandomSpeed(minSpeed, maxSpeed)
        return this
    }

    /**
     * @returns {Planet} The largest planet of the universe, usually the star.
     */
    getLargestPlanet() {
        let pM = null, mM = 0;
        for (let p of this.ps)
            if (p.m > mM) { pM = p; mM = p.m }
        return pM
    }

    /**
     * Get largest planet and explode it.
     */
    explodeLargestPlanet() {
        const p = this.getLargestPlanet()
        this.explode(p)
    }

    /**
     * Explode a planet into pieces
     * 
     * @param {Planet} p 
     * @param {number} nb 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     */
    explode(p, nb = -1, minSpeed = 0.8, maxSpeed = 1.5, rad = -1) {
        if (nb <= 0) nb = Math.floor(p.m);
        if (nb <= 0) return;
        const angleStep = 2 * Math.PI / nb;
        for (let i = 0; i < nb; i++) {
            //create planet

            //position
            if (rad < 0) rad = 2 * p.r()
            const d = rad * Math.random();
            const a = i * angleStep;
            const x = d * Math.cos(a), y = d * Math.sin(a);

            //speed
            const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
            const aS = a + 2 * (Math.random() - 0.5) * 2 * Math.PI / 3;
            const sx = speed * Math.cos(aS), sy = speed * Math.sin(aS);

            new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, p.m / nb, p.x + x, p.y + y, p.sx + sx, p.sy + sy)
        }
        //remove p from universe
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p);
    }

}


/***/ }),

/***/ "./src/planets/index.js":
/*!******************************!*\
  !*** ./src/planets/index.js ***!
  \******************************/
/*! exports provided: planets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return planets; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/**  */
class PlanetSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {number} */
        this.maxSpeed = opts.maxSpeed || 0.8;
        /** @type {boolean} */
        this.bounce = opts.bounce || false
        /** @type {number} */
        this.exponent = opts.exponent || 2;
        /** @type {number} */
        this.collisionFactor = opts.collisionFactor || 1;

        /** @type {boolean} */
        this.showPlanetAcceleration = false

        /** @type {string|undefined} */
        this.showField = undefined
        /** @type {number} */
        this.fieldRes = 20
        /** @type {number} */
        this.fieldFactor = 1000
        /** @type {string} */
        this.fieldStrokeStyle = "#99bbff";

        /** @type {number} */
        this.tailings = opts.tailings || 0.1;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear, with transparency
            c2.fillStyle = "rgba(0,0,0," + th.tailings + ")";
            c2.fillRect(0, 0, th.w, th.h);
            //c2.fillRect(-1e20, -1e20, 2e20, 2e20); //todo

            //display gravity field
            if (th.showField === "f")
                th.displayGravityField(this, true)
            else if (th.showField === "i")
                th.displayGravityField(this, false)


            this.setCanvasTransform()

            //display planets
            for (let p of th.uni.ps) {
                if (!this.toDraw(p)) continue
                const t = p.m / th.uni.m();
                p.display(this, "rgb(255,255," + Math.floor(255 * (1 - t)) + ")")
            }

            //display planets acceleration
            if (th.showPlanetAcceleration) {
                for (let p of th.uni.ps) {
                    if (!this.toDraw(p)) continue
                    p.displayAcceleration(this)
                }
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Universe} */
        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_0__["Universe"](this.w, this.h)
    }


    /**
     * @param {GeoCanvas} cp 
     * @param {boolean} field 
     */
    displayGravityField(cp, field = true) {
        const c2 = cp.ctx
        const res = this.fieldRes
        const f = this.fieldFactor
        const f_ = field ? 0.3 * res : 0.6 * res;
        c2.strokeStyle = this.fieldStrokeStyle
        for (let x = res * 0.5; x < this.w; x += res) {
            const xG = cp.pixToGeoX(x);
            if (xG > this.uni.w || xG < 0) continue
            for (let y = res / 2; y < this.h; y += res) {
                const yG = cp.pixToGeoY(y);
                if (yG > this.uni.h || yG < 0) continue
                //get gravity field
                const g = this.uni.getGravityField(xG, yG, undefined, this.exponent);
                const g_ = Math.hypot(g.gx, g.gy)

                c2.lineWidth = Math.min(f * g_, 0.3 * res);
                const dx = f_ * g.gx / g_, dy = f_ * g.gy / g_

                //draw
                c2.beginPath();
                if (field) {
                    //gravity field
                    c2.moveTo(x - dx, y + dy);
                    c2.lineTo(x + dx, y - dy);
                } else {
                    //isopotential lines
                    c2.moveTo(x + dy, y + dx);
                    c2.lineTo(x - dy, y - dx);
                }
                c2.closePath();
                c2.stroke();
            }
        }
    }


    /**
     * Initialise with random planets
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    initRandom(nb = 1000, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        this.uni.addPlanets(nb, mi, minSpeed, maxSpeed);
        return this;
    }

    /**
     * Initialise with big bang setup
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     * @returns {this}
     */
    initBigBang(nb = 1000, mi = 1, minSpeed = 0.35, maxSpeed = 0.7, rad = 100) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        //create big planet in the middle
        const cx = this.w * 0.5, cy = this.h * 0.5;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_1__["Planet"](this.uni, nb * mi, cx, cy, 0, 0);
        //explode it
        this.uni.explode(p, nb, minSpeed, maxSpeed, rad)
        return this;
    }

    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.uni.step(t.bounce, t.maxSpeed, t.exponent, t.collisionFactor, timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const planets = function (opts) {
    return new PlanetSimulation(opts)
}


/***/ }),

/***/ "./src/pp/Animal.js":
/*!**************************!*\
  !*** ./src/pp/Animal.js ***!
  \**************************/
/*! exports provided: Animal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animal", function() { return Animal; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




/** */
class Animal extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {number} type 
     * @param {Land} l 
     * @param {number} x 
     * @param {number} y 
     */
    constructor(type, l, x = 0, y = 0) {

        super(x, y)

        /** @type {number} */
        this.type = type;
        /** @type {Land} */
        this.l = l;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > l.w ? l.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > l.h ? l.h : y

        //the other animals around
        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        //add to the spatial index
        l.grid.insert(this);
    }


    /**
     * @param {*} timeStepMs 
     */
    move(timeStepMs = 10) {
        const l = this.l
        l.grid.remove(this);

        const angle = Math.random() * 2 * Math.PI;
        const r = 0.01 * Math.random();

        this.sx += r * Math.cos(angle) * timeStepMs;
        this.sx = this.sx > l.V_MAX ? l.V_MAX : this.sx < -l.V_MAX ? -l.V_MAX : this.sx

        this.sy += r * Math.sin(angle) * timeStepMs;
        this.sy = this.sy > l.V_MAX ? l.V_MAX : this.sy < -l.V_MAX ? -l.V_MAX : this.sy

        this.x += this.sx * timeStepMs;
        this.x = this.x < 0 ? l.w : this.x > l.w ? 0 : this.x

        this.y += this.sy * timeStepMs;
        this.y = this.y < 0 ? l.h : this.y > l.h ? 0 : this.y

        l.grid.insert(this);
    }


    /** Observe */
    observe() {
        const l = this.l

        //get animals around
        const as = l.grid.get(this.x - l.d, this.y - l.d, this.x + l.d, this.y + l.d);

        this.preys = [];
        this.predators = [];

        for (let a of as) {
            if (a == this) continue;
            if (this.d(a) > l.d) continue;
            if (a.type == 0)
                this.preys.push(a);
            else
                this.predators.push(a);
        }
    }

    /** @returns {Animal} */
    makeChild() {
        //do better: make child around
        return new Animal(this.type, this.l, this.x, this.y);
    }



    /**
     * Display animal
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} size 
     */
    display(cp, fillStyle = "blue", size = 2) {
        cp.ctx.fillStyle = fillStyle;
        cp.ctx.fillRect(this.x, this.y, size, size);
        /*c2.beginPath();
        c2.arc(a.x, a.y, 0.5, 0, 2*Math.PI);
        c2.closePath();
        c2.fill();*/
    }

}


/***/ }),

/***/ "./src/pp/Land.js":
/*!************************!*\
  !*** ./src/pp/Land.js ***!
  \************************/
/*! exports provided: Land */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Land", function() { return Land; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
//@ts-check




class Land {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */
    constructor(w, h) {

        //the max speed
        /** @type {number} */
        this.V_MAX = 0.1

        /** @type {number} */
        this.p = 0.02 //predator death probability
        /** @type {number} */
        this.q = 0.1 //prey reproduction probability
        /** @type {number} */
        this.r = 0.5 //eaten prey transformation probability
        /** @type {number} */
        this.nb = 3 //neighbors number

        /** @type {number} */
        this.w = w
        /** @type {number} */
        this.h = h

        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        /** @type {number} */
        this.d = 10
        /** @type {SpatialIndex.<Animal>} */
        this.grid = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /*int[][] histo;
        int index=0;
        this.c2Chart=c2Chart;
        this.hChart=hChart;
        this.histo=new int[wChart][];
        for(int i=0;i<wChart;i++)
            histo[i]=new int[]{0,0};*/

    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //observe
        for (let a of this.preys) a.observe();
        for (let a of this.predators) a.observe();

        const preysToBorn = []
        const preysToDie = []
        const predsToBorn = []
        const predsToDie = []

        //prey
        for (let prey of this.preys) {
            //reproduction if no predator around
            if (Math.random() > this.q) continue;
            if (prey.predators.length != 0) continue;
            if (prey.preys.length >= this.nb) continue;
            preysToBorn.push(prey.makeChild());
        }

        //predator
        for (let pred of this.predators) {
            //no prey around: predator dies with probability p
            if (pred.preys.length == 0) {
                if (Math.random() < this.p) predsToDie.push(pred);
            }
            //prey around
            else {
                //eat prey
                //choose randomly
                const preyToEat = pred.preys[Math.floor(pred.preys.length * Math.random())];
                preysToDie.push(preyToEat);

                //predator reproduction
                if (Math.random() > this.r) continue;
                if (pred.predators.length >= this.nb) continue;
                predsToBorn.push(pred.makeChild());
            }
        }

        this.preys.push(...preysToBorn);
        this.predators.push(...predsToBorn);

        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.preys, preysToDie, false)
        for (let a of preysToDie) this.grid.remove(a);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.predators, predsToDie, false)
        for (let a of predsToDie) this.grid.remove(a);

        //move
        for (let a of this.preys)
            a.move(timeStepMs);
        for (let a of this.predators)
            a.move(timeStepMs);

        /*/histo
        histo[index] = new int[]{ preys.size(), predators.size() };
        if (index == histo.length - 1) index = 0;
        else index++;*/

    }
}


/***/ }),

/***/ "./src/pp/index.js":
/*!*************************!*\
  !*** ./src/pp/index.js ***!
  \*************************/
/*! exports provided: preyPredator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return preyPredator; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/** */
class PreyPredatorSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);


        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //transparency
            this.initCanvasTransform()
            c2.fillStyle = "rgba(255,255,255,0.5)";
            c2.fillRect(0, 0, th.w, th.h);

            //display animals
            this.setCanvasTransform()
            for (let a of th.land.preys)
                if (this.toDraw(a))
                    a.display(this, "blue");
            for (let a of th.land.predators)
                if (this.toDraw(a))
                    a.display(this, "red");

            /*/label
            c2.fillStyle = "lightgray";
            c2.fillRect(0, 0, 65, 13);
            c2.fillStyle = "black";
            c2.fillText(preys.length + "/" + predators.length, 2, 10);*/

            //chart
            //c2Chart.setFillStyle(backColor2);
            //c2Chart.fillRect(0, 0, w, h);

            //double max = getMaxHisto();
            /*public int getMaxHisto() {
                int max=0;
                for(int i=0;i<histo.length;i++){
                    if(histo[i][0]>max) max=histo[i][0];
                    if(histo[i][1]>max) max=histo[i][1];
                }
                return max;
            }*/
            /*
                        if (max != 0) {
                            double h1, h2;
                            for (int i = 0; i < histo.length; i++) {
                                h1 = hChart * histo[i][0] / max;
                                h2 = hChart * histo[i][1] / max;
                                c2Chart.setFillStyle(preyColor2);
                                c2Chart.fillRect(i, hChart - h1, 1, h1);
                                c2Chart.setFillStyle(predatorColor2);
                                c2Chart.fillRect(i, hChart - h2, 1, h2);
                            }
                        }
                        c2Chart.setFillStyle(CssColor.make(255, 255, 255));
                        c2Chart.fillRect(index, 0, 1, hChart);
            */

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };


        /** @type {Land} */
        this.land = new _Land__WEBPACK_IMPORTED_MODULE_0__["Land"](this.w, this.h)

    }



    //TODO test init in a bubble ?
    //TODO use density as input parameters instead of nb

    /**
     * 
     * @param {number} preyDensity 
     * @param {number} predatorDensity 
     * @returns {this}
     */
    initRandom(preyDensity = 0.003, predatorDensity = 0.003) {
        const l = this.land
        for (let i = 0; i < preyDensity * l.w * l.h; i++)
            l.preys.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](0, l, l.w * Math.random(), l.h * Math.random())
            );
        for (let i = 0; i < predatorDensity * l.w * l.h; i++)
            l.predators.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](1, l, l.w * Math.random(), l.h * Math.random())
            );
        return this;
    }


    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.land.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

}


/**
 * @param {Object} opts 
 */
const preyPredator = function (opts) {
    return new PreyPredatorSimulation(opts)
}


/***/ }),

/***/ "./src/urban/Building.js":
/*!*******************************!*\
  !*** ./src/urban/Building.js ***!
  \*******************************/
/*! exports provided: Building */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Building", function() { return Building; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check



class Building {

    /**
     * @constructor
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} area The area
     */
    constructor(x, y, area) {

        //set position
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.area = area
    }

    /**
     * @returns { number }
     */
    r() {
        return Math.sqrt(this.area / Math.PI)
    }

    /**
     * @param {Building} b 
     */
    overlap(b) {
        const d1 = b.r() + this.r()
        const d2 = Math.hypot((b.x - this.x), (b.y - this.y));
        return d2 < d1
    }



    /**
     * @param {SpatialIndex.<Building>} sindex 
     * @param {number} sDistance 
     * @returns {boolean}
     */
    checkCollision(sindex, sDistance) {

        //get buildings around using spatial index
        /** @type {Array.<Building>} */
        const ss = sindex.get(this.x - sDistance, this.y - sDistance, this.x + sDistance, this.y + sDistance);

        for (let b of ss) {
            if (b == this) continue;
            if (this.overlap(b)) return true
        }
        return false;
    }




    /**
     * Display
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     * @param {String} strokeStyle 
     */
    display(cp, fillStyle, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
        c2.stroke();
    }


}


/***/ }),

/***/ "./src/urban/Map.js":
/*!**************************!*\
  !*** ./src/urban/Map.js ***!
  \**************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Building__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Building */ "./src/urban/Building.js");
/* harmony import */ var _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RoadNetwork */ "./src/urban/RoadNetwork.js");
//@ts-check




class Map {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Building>} */
        this.bs = [];
        /** @type {SpatialIndex.<Building>} */
        this.buIndex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /** @type {RoadNetwork} */
        this.rn = new _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__["RoadNetwork"]();

        /*
        //test turf
                var ls = turf.lineString([[1000, 0], [1000, 1000]]);
                console.log(ls)
                //var pt = turf.point([1000, 1000]);
                var buff = turf.buffer(ls, 10, 'degrees');
                console.log(buff)
        */

        //test jsts
        //https://bjornharrtell.github.io/jsts/
        /*var reader = new jsts.io.WKTReader()
        var a = reader.read('POINT (-20 0)')
        console.log(reader)
        console.log(a)
        a = a.buffer(40)
        console.log(a)
        var w = new jsts.io.WKTWriter()
        console.log(w.write(a))*/
    }

    /** */
    addBuilding() {

        //compute candidate location, size and type for next building
        //TODO low local congestion AND go to high density (with good access to other stuff)

        //make random building
        const makeRandomBuilding = () => {
            const x = this.w * Math.random();
            const y = this.h * Math.random();
            const area = 40 + 200 * Math.random()
            return new _Building__WEBPACK_IMPORTED_MODULE_1__["Building"](x, y, area)
        }

        //TODO should not overlap with other entities (roads, building)

        /** @type {number} */
        const sDistance = 100;
        /** @type {Building} */
        let bu = makeRandomBuilding();
        while (bu.checkCollision(this.buIndex, sDistance)) {
            bu = makeRandomBuilding();
        }

        //add building
        this.bs.push(bu);
        this.buIndex.load([bu])
    }

    /**
     * @returns {this}
     */
    step() {

        //compute building need
        const buNeed = 10;

        //urbanise
        for (let i = 0; i < buNeed; i++) {
            this.addBuilding();
        }

        //extend road network
        //TODO

        return this;
    }

}


/***/ }),

/***/ "./src/urban/Road.js":
/*!***************************!*\
  !*** ./src/urban/Road.js ***!
  \***************************/
/*! exports provided: Road */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Road", function() { return Road; });
//@ts-check

class Road {

    constructor(geom) {

        this.geom = geom

    }

}


/***/ }),

/***/ "./src/urban/RoadNetwork.js":
/*!**********************************!*\
  !*** ./src/urban/RoadNetwork.js ***!
  \**********************************/
/*! exports provided: RoadNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoadNetwork", function() { return RoadNetwork; });
/* harmony import */ var _Road__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Road */ "./src/urban/Road.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jsts__WEBPACK_IMPORTED_MODULE_1__);
//@ts-check



class RoadNetwork {

    constructor() {

        /** @type {Array.<Road>} */
        this.sections = []


        //add test road
        //https://github.com/bjornharrtell/jsts
        //http://bjornharrtell.github.io/jsts/
        var reader = new jsts__WEBPACK_IMPORTED_MODULE_1___default.a.io.WKTReader()
        var g = reader.read('LINESTRING (30 10, 10 300, 400 40)')
        this.sections.push(new _Road__WEBPACK_IMPORTED_MODULE_0__["Road"](g));
    }

}


/***/ }),

/***/ "./src/urban/index.js":
/*!****************************!*\
  !*** ./src/urban/index.js ***!
  \****************************/
/*! exports provided: urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return urban; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map */ "./src/urban/Map.js");
//@ts-check



/**  */
class UrbanSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //display buildings
            for (let b of th.map.bs) {
                if (!this.toDraw(b)) continue
                b.display(this, "lightgray", "black", 2)
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Map} */
        this.map = new _Map__WEBPACK_IMPORTED_MODULE_1__["Map"](this.w, this.h)
    }


    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.map.step();
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const urban = function (opts) {
    return new UrbanSimulation(opts)
}


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZWN0YWcvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3ZlY3RhZy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY3ViZWhlbGl4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2RyYWcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9iYWNrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9ib3VuY2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2V4cC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcG9seS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvc2luLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kaXNjcmV0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hjbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hzbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2h1ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbGFiLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JvdW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRvci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9sb2NhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tYXRjaGVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlcnMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2xvd2VyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZXMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvd2luZG93LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW50ZXJydXB0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0clR3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2RlbGF5LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZVZhcnlpbmcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2NoZWR1bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3R3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2pzdHMvZGlzdC9qc3RzLm1pbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvcmJ1c2gvcmJ1c2gubWluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL0FnZW50UG9pbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Jhc2UvR2VvQ2FudmFzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL1NwYXRpYWxJbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvYmFzZS9saWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Zpc2gvU2FyZGluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9maXNoL1NlYS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZmlzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL0NlbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2dvbC9Vbml2ZXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcGxhbmV0cy9QbGFuZXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvVW5pdmVyc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BwL0FuaW1hbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvTGFuZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL0J1aWxkaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9NYXAuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWROZXR3b3JrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDOztBQUVwQzs7QUFFQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBTSxXQUFXLHlEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FB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QUFtQixPQUFPO0FBQzFCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7OztBQUdBLG1CQUFtQixVQUFVO0FBQzdCLHlCQUF5Qix5REFBUztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsSUFBSTtBQUN2Qix1QkFBdUIsd0NBQUc7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDTztBQUNQO0FBQ0EiLCJmaWxlIjoidmVjdGFnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmVjdGFnXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZlY3RhZ1wiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJidWlsZC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENvbG9yKCkge31cblxuZXhwb3J0IHZhciBkYXJrZXIgPSAwLjc7XG5leHBvcnQgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weTogZnVuY3Rpb24oY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gcmdiYShtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IHJnYmEoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gXCIjXCIgKyBoZXgodGhpcy5yKSArIGhleCh0aGlzLmcpICsgaGV4KHRoaXMuYik7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICByZXR1cm4gKGEgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIilcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmcpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iKSB8fCAwKSlcbiAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCIpXG4gICAgICAgICsgKHRoaXMuaCB8fCAwKSArIFwiLCBcIlxuICAgICAgICArICh0aGlzLnMgfHwgMCkgKiAxMDAgKyBcIiUsIFwiXG4gICAgICAgICsgKHRoaXMubCB8fCAwKSAqIDEwMCArIFwiJVwiXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2IsIGRhcmtlciwgYnJpZ2h0ZXJ9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxudmFyIEEgPSAtMC4xNDg2MSxcbiAgICBCID0gKzEuNzgyNzcsXG4gICAgQyA9IC0wLjI5MjI3LFxuICAgIEQgPSAtMC45MDY0OSxcbiAgICBFID0gKzEuOTcyOTQsXG4gICAgRUQgPSBFICogRCxcbiAgICBFQiA9IEUgKiBCLFxuICAgIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSByZXR1cm4gbmV3IEN1YmVoZWxpeChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcbiAgICAgIGJsID0gYiAtIGwsXG4gICAgICBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQsXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSwgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiBkZWdyZWVzIC0gMTIwIDogTmFOO1xuICByZXR1cm4gbmV3IEN1YmVoZWxpeChoIDwgMCA/IGggKyAzNjAgOiBoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGN1YmVoZWxpeENvbnZlcnQoaCkgOiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoQ3ViZWhlbGl4LCBjdWJlaGVsaXgsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogcmFkaWFucyxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBjb2xvciwgcmdiLCBoc2x9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbGFiLCBoY2wsIGxjaCwgZ3JheX0gZnJvbSBcIi4vbGFiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3ViZWhlbGl4fSBmcm9tIFwiLi9jdWJlaGVsaXguanNcIjtcbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdifSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWdyZWVzLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbi8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbmNvbnN0IEsgPSAxOCxcbiAgICBYbiA9IDAuOTY0MjIsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMC44MjUyMSxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gaGNsMmxhYihvKTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBuZXcgTGFiKGwsIDAsIDAsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBsYWJDb252ZXJ0KGwpIDogbmV3IExhYihsLCBhLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5hID0gK2E7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKExhYiwgbGFiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBscmdiMnJnYiggMy4xMzM4NTYxICogeCAtIDEuNjE2ODY2NyAqIHkgLSAwLjQ5MDYxNDYgKiB6KSxcbiAgICAgIGxyZ2IycmdiKC0wLjk3ODc2ODQgKiB4ICsgMS45MTYxNDE1ICogeSArIDAuMDMzNDU0MCAqIHopLFxuICAgICAgbHJnYjJyZ2IoIDAuMDcxOTQ1MyAqIHggLSAwLjIyODk5MTQgKiB5ICsgMS40MDUyNDI3ICogeiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24gbHJnYjJyZ2IoeCkge1xuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cblxuZnVuY3Rpb24gcmdiMmxyZ2IoeCkge1xuICByZXR1cm4gKHggLz0gMjU1KSA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gaGNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gbmV3IEhjbChvLmgsIG8uYywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XG4gIGlmIChvLmEgPT09IDAgJiYgby5iID09PSAwKSByZXR1cm4gbmV3IEhjbChOYU4sIDAgPCBvLmwgJiYgby5sIDwgMTAwID8gMCA6IE5hTiwgby5sLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogZGVncmVlcztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxjaChsLCBjLCBoLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChsKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5jID0gK2M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZnVuY3Rpb24gaGNsMmxhYihvKSB7XG4gIGlmIChpc05hTihvLmgpKSByZXR1cm4gbmV3IExhYihvLmwsIDAsIDAsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gby5oICogcmFkaWFucztcbiAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG59XG5cbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGhjbDJsYWIodGhpcykucmdiKCk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBjb25zdCByYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGRpc3BhdGNofSBmcm9tIFwiLi9kaXNwYXRjaC5qc1wiO1xuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3NlbGVjdCwgcG9pbnRlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IG5vZHJhZywge3llc2RyYWd9IGZyb20gXCIuL25vZHJhZy5qc1wiO1xuaW1wb3J0IG5vZXZlbnQsIHtub25wYXNzaXZlLCBub25wYXNzaXZlY2FwdHVyZSwgbm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgRHJhZ0V2ZW50IGZyb20gXCIuL2V2ZW50LmpzXCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcihldmVudCkge1xuICByZXR1cm4gIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRhaW5lcigpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN1YmplY3QoZXZlbnQsIGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBldmVudC54LCB5OiBldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gZGVmYXVsdFN1YmplY3QsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgZ2VzdHVyZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxuICAgICAgYWN0aXZlID0gMCxcbiAgICAgIG1vdXNlZG93bngsXG4gICAgICBtb3VzZWRvd255LFxuICAgICAgbW91c2Vtb3ZpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiBkcmFnKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd25lZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuZHJhZ1wiLCB0b3VjaG1vdmVkLCBub25wYXNzaXZlKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC5kcmFnIHRvdWNoY2FuY2VsLmRyYWdcIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoZXZlbnQsIGQpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5jYWxsKHRoaXMsIGV2ZW50LCBkKSkgcmV0dXJuO1xuICAgIHZhciBnZXN0dXJlID0gYmVmb3Jlc3RhcnQodGhpcywgY29udGFpbmVyLmNhbGwodGhpcywgZXZlbnQsIGQpLCBldmVudCwgZCwgXCJtb3VzZVwiKTtcbiAgICBpZiAoIWdlc3R1cmUpIHJldHVybjtcbiAgICBzZWxlY3QoZXZlbnQudmlldylcbiAgICAgIC5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIG5vbnBhc3NpdmVjYXB0dXJlKVxuICAgICAgLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgICBub2RyYWcoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgbW91c2Vtb3ZpbmcgPSBmYWxzZTtcbiAgICBtb3VzZWRvd254ID0gZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZXZlbnQuY2xpZW50WTtcbiAgICBnZXN0dXJlKFwic3RhcnRcIiwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vtb3ZlZChldmVudCkge1xuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGlmICghbW91c2Vtb3ZpbmcpIHtcbiAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBtb3VzZWRvd254LCBkeSA9IGV2ZW50LmNsaWVudFkgLSBtb3VzZWRvd255O1xuICAgICAgbW91c2Vtb3ZpbmcgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgIH1cbiAgICBnZXN0dXJlcy5tb3VzZShcImRyYWdcIiwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZChldmVudCkge1xuICAgIHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKTtcbiAgICB5ZXNkcmFnKGV2ZW50LnZpZXcsIG1vdXNlbW92aW5nKTtcbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBnZXN0dXJlcy5tb3VzZShcImVuZFwiLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoZXZlbnQsIGQpIHtcbiAgICBpZiAoIWZpbHRlci5jYWxsKHRoaXMsIGV2ZW50LCBkKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIGMgPSBjb250YWluZXIuY2FsbCh0aGlzLCBldmVudCwgZCksXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodGhpcywgYywgZXZlbnQsIGQsIHRvdWNoZXNbaV0uaWRlbnRpZmllciwgdG91Y2hlc1tpXSkpIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiLCBldmVudCwgdG91Y2hlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZChldmVudCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgICAgZ2VzdHVyZShcImRyYWdcIiwgZXZlbnQsIHRvdWNoZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgICAgIGdlc3R1cmUoXCJlbmRcIiwgZXZlbnQsIHRvdWNoZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZXN0YXJ0KHRoYXQsIGNvbnRhaW5lciwgZXZlbnQsIGQsIGlkZW50aWZpZXIsIHRvdWNoKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbGlzdGVuZXJzLmNvcHkoKSxcbiAgICAgICAgcCA9IHBvaW50ZXIodG91Y2ggfHwgZXZlbnQsIGNvbnRhaW5lciksIGR4LCBkeSxcbiAgICAgICAgcztcblxuICAgIGlmICgocyA9IHN1YmplY3QuY2FsbCh0aGF0LCBuZXcgRHJhZ0V2ZW50KFwiYmVmb3Jlc3RhcnRcIiwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICAgIHRhcmdldDogZHJhZyxcbiAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICB4OiBwWzBdLFxuICAgICAgICB5OiBwWzFdLFxuICAgICAgICBkeDogMCxcbiAgICAgICAgZHk6IDAsXG4gICAgICAgIGRpc3BhdGNoXG4gICAgICB9KSwgZCkpID09IG51bGwpIHJldHVybjtcblxuICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgIGR5ID0gcy55IC0gcFsxXSB8fCAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSwgZXZlbnQsIHRvdWNoKSB7XG4gICAgICB2YXIgcDAgPSBwLCBuO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOiBnZXN0dXJlc1tpZGVudGlmaWVyXSA9IGdlc3R1cmUsIG4gPSBhY3RpdmUrKzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbmRcIjogZGVsZXRlIGdlc3R1cmVzW2lkZW50aWZpZXJdLCAtLWFjdGl2ZTsgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnRlcih0b3VjaCB8fCBldmVudCwgY29udGFpbmVyKSwgbiA9IGFjdGl2ZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaC5jYWxsKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGF0LFxuICAgICAgICBuZXcgRHJhZ0V2ZW50KHR5cGUsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICAgICAgc3ViamVjdDogcyxcbiAgICAgICAgICB0YXJnZXQ6IGRyYWcsXG4gICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICBhY3RpdmU6IG4sXG4gICAgICAgICAgeDogcFswXSArIGR4LFxuICAgICAgICAgIHk6IHBbMV0gKyBkeSxcbiAgICAgICAgICBkeDogcFswXSAtIHAwWzBdLFxuICAgICAgICAgIGR5OiBwWzFdIC0gcDBbMV0sXG4gICAgICAgICAgZGlzcGF0Y2hcbiAgICAgICAgfSksXG4gICAgICAgIGRcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIGRyYWcuZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiBmaWx0ZXI7XG4gIH07XG5cbiAgZHJhZy5jb250YWluZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGFpbmVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBjb250YWluZXI7XG4gIH07XG5cbiAgZHJhZy5zdWJqZWN0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN1YmplY3QgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IHN1YmplY3Q7XG4gIH07XG5cbiAgZHJhZy50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICBkcmFnLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGRyYWcgOiB2YWx1ZTtcbiAgfTtcblxuICBkcmFnLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIGRyYWcpIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICByZXR1cm4gZHJhZztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERyYWdFdmVudCh0eXBlLCB7XG4gIHNvdXJjZUV2ZW50LFxuICBzdWJqZWN0LFxuICB0YXJnZXQsXG4gIGlkZW50aWZpZXIsXG4gIGFjdGl2ZSxcbiAgeCwgeSwgZHgsIGR5LFxuICBkaXNwYXRjaFxufSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHlwZToge3ZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHNvdXJjZUV2ZW50OiB7dmFsdWU6IHNvdXJjZUV2ZW50LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHN1YmplY3Q6IHt2YWx1ZTogc3ViamVjdCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0YXJnZXQ6IHt2YWx1ZTogdGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIGlkZW50aWZpZXI6IHt2YWx1ZTogaWRlbnRpZmllciwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBhY3RpdmU6IHt2YWx1ZTogYWN0aXZlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHg6IHt2YWx1ZTogeCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB5OiB7dmFsdWU6IHksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgZHg6IHt2YWx1ZTogZHgsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgZHk6IHt2YWx1ZTogZHksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgXzoge3ZhbHVlOiBkaXNwYXRjaH1cbiAgfSk7XG59XG5cbkRyYWdFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5fLm9uLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHZhbHVlID09PSB0aGlzLl8gPyB0aGlzIDogdmFsdWU7XG59O1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWd9IGZyb20gXCIuL2RyYWcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkcmFnRGlzYWJsZSwgeWVzZHJhZyBhcyBkcmFnRW5hYmxlfSBmcm9tIFwiLi9ub2RyYWcuanNcIjtcbiIsImltcG9ydCB7c2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9ldmVudCwge25vbnBhc3NpdmVjYXB0dXJlfSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHllc2RyYWcodmlldywgbm9jbGljaykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIGlmIChub2NsaWNrKSB7XG4gICAgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG4iLCIvLyBUaGVzZSBhcmUgdHlwaWNhbGx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBub2V2ZW50IHRvIGVuc3VyZSB0aGF0IHdlIGNhblxuLy8gcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50LlxuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmUgPSB7cGFzc2l2ZTogZmFsc2V9O1xuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmVjYXB0dXJlID0ge2NhcHR1cmU6IHRydWUsIHBhc3NpdmU6IGZhbHNlfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwidmFyIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG5cbmV4cG9ydCB2YXIgYmFja0luID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrSW4odCkge1xuICAgIHJldHVybiAodCA9ICt0KSAqIHQgKiAocyAqICh0IC0gMSkgKyB0KTtcbiAgfVxuXG4gIGJhY2tJbi5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tJbjtcbn0pKG92ZXJzaG9vdCk7XG5cbmV4cG9ydCB2YXIgYmFja091dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHQgKyAxKSAqIHMgKyB0KSArIDE7XG4gIH1cblxuICBiYWNrT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja091dDtcbn0pKG92ZXJzaG9vdCk7XG5cbmV4cG9ydCB2YXIgYmFja0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrSW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgKj0gMikgPCAxID8gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSA6ICh0IC09IDIpICogdCAqICgocyArIDEpICogdCArIHMpICsgMikgLyAyO1xuICB9XG5cbiAgYmFja0luT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja0luT3V0O1xufSkob3ZlcnNob290KTtcbiIsInZhciBiMSA9IDQgLyAxMSxcbiAgICBiMiA9IDYgLyAxMSxcbiAgICBiMyA9IDggLyAxMSxcbiAgICBiNCA9IDMgLyA0LFxuICAgIGI1ID0gOSAvIDExLFxuICAgIGI2ID0gMTAgLyAxMSxcbiAgICBiNyA9IDE1IC8gMTYsXG4gICAgYjggPSAyMSAvIDIyLFxuICAgIGI5ID0gNjMgLyA2NCxcbiAgICBiMCA9IDEgLyBiMSAvIGIxO1xuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0gdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VPdXQodCkge1xuICByZXR1cm4gKHQgPSArdCkgPCBiMSA/IGIwICogdCAqIHQgOiB0IDwgYjMgPyBiMCAqICh0IC09IGIyKSAqIHQgKyBiNCA6IHQgPCBiNiA/IGIwICogKHQgLT0gYjUpICogdCArIGI3IDogYjAgKiAodCAtPSBiOCkgKiB0ICsgYjk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBib3VuY2VPdXQoMSAtIHQpIDogYm91bmNlT3V0KHQgLSAxKSArIDEpIC8gMjtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjaXJjbGVJbih0KSB7XG4gIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVPdXQodCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZUluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpIDogTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgLyAyO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG4iLCJpbXBvcnQge3RwbXR9IGZyb20gXCIuL21hdGguanNcIjtcblxudmFyIHRhdSA9IDIgKiBNYXRoLlBJLFxuICAgIGFtcGxpdHVkZSA9IDEsXG4gICAgcGVyaW9kID0gMC4zO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNJbiA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBhICogdHBtdCgtKC0tdCkpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY0luLmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luLnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luO1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBhICogdHBtdCh0ID0gK3QpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgPSB0ICogMiAtIDEpIDwgMFxuICAgICAgICA/IGEgKiB0cG10KC10KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKVxuICAgICAgICA6IDIgLSBhICogdHBtdCh0KSAqIE1hdGguc2luKChzICsgdCkgLyBwKSkgLyAyO1xuICB9XG5cbiAgZWxhc3RpY0luT3V0LmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luT3V0LnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuIiwiaW1wb3J0IHt0cG10fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBJbih0KSB7XG4gIHJldHVybiB0cG10KDEgLSArdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBPdXQodCkge1xuICByZXR1cm4gMSAtIHRwbXQodCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHRwbXQoMSAtIHQpIDogMiAtIHRwbXQodCAtIDEpKSAvIDI7XG59XG4iLCJleHBvcnQge1xuICBsaW5lYXIgYXMgZWFzZUxpbmVhclxufSBmcm9tIFwiLi9saW5lYXIuanNcIjtcblxuZXhwb3J0IHtcbiAgcXVhZEluT3V0IGFzIGVhc2VRdWFkLFxuICBxdWFkSW4gYXMgZWFzZVF1YWRJbixcbiAgcXVhZE91dCBhcyBlYXNlUXVhZE91dCxcbiAgcXVhZEluT3V0IGFzIGVhc2VRdWFkSW5PdXRcbn0gZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQge1xuICBjdWJpY0luT3V0IGFzIGVhc2VDdWJpYyxcbiAgY3ViaWNJbiBhcyBlYXNlQ3ViaWNJbixcbiAgY3ViaWNPdXQgYXMgZWFzZUN1YmljT3V0LFxuICBjdWJpY0luT3V0IGFzIGVhc2VDdWJpY0luT3V0XG59IGZyb20gXCIuL2N1YmljLmpzXCI7XG5cbmV4cG9ydCB7XG4gIHBvbHlJbk91dCBhcyBlYXNlUG9seSxcbiAgcG9seUluIGFzIGVhc2VQb2x5SW4sXG4gIHBvbHlPdXQgYXMgZWFzZVBvbHlPdXQsXG4gIHBvbHlJbk91dCBhcyBlYXNlUG9seUluT3V0XG59IGZyb20gXCIuL3BvbHkuanNcIjtcblxuZXhwb3J0IHtcbiAgc2luSW5PdXQgYXMgZWFzZVNpbixcbiAgc2luSW4gYXMgZWFzZVNpbkluLFxuICBzaW5PdXQgYXMgZWFzZVNpbk91dCxcbiAgc2luSW5PdXQgYXMgZWFzZVNpbkluT3V0XG59IGZyb20gXCIuL3Npbi5qc1wiO1xuXG5leHBvcnQge1xuICBleHBJbk91dCBhcyBlYXNlRXhwLFxuICBleHBJbiBhcyBlYXNlRXhwSW4sXG4gIGV4cE91dCBhcyBlYXNlRXhwT3V0LFxuICBleHBJbk91dCBhcyBlYXNlRXhwSW5PdXRcbn0gZnJvbSBcIi4vZXhwLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGNpcmNsZUluT3V0IGFzIGVhc2VDaXJjbGUsXG4gIGNpcmNsZUluIGFzIGVhc2VDaXJjbGVJbixcbiAgY2lyY2xlT3V0IGFzIGVhc2VDaXJjbGVPdXQsXG4gIGNpcmNsZUluT3V0IGFzIGVhc2VDaXJjbGVJbk91dFxufSBmcm9tIFwiLi9jaXJjbGUuanNcIjtcblxuZXhwb3J0IHtcbiAgYm91bmNlT3V0IGFzIGVhc2VCb3VuY2UsXG4gIGJvdW5jZUluIGFzIGVhc2VCb3VuY2VJbixcbiAgYm91bmNlT3V0IGFzIGVhc2VCb3VuY2VPdXQsXG4gIGJvdW5jZUluT3V0IGFzIGVhc2VCb3VuY2VJbk91dFxufSBmcm9tIFwiLi9ib3VuY2UuanNcIjtcblxuZXhwb3J0IHtcbiAgYmFja0luT3V0IGFzIGVhc2VCYWNrLFxuICBiYWNrSW4gYXMgZWFzZUJhY2tJbixcbiAgYmFja091dCBhcyBlYXNlQmFja091dCxcbiAgYmFja0luT3V0IGFzIGVhc2VCYWNrSW5PdXRcbn0gZnJvbSBcIi4vYmFjay5qc1wiO1xuXG5leHBvcnQge1xuICBlbGFzdGljT3V0IGFzIGVhc2VFbGFzdGljLFxuICBlbGFzdGljSW4gYXMgZWFzZUVsYXN0aWNJbixcbiAgZWxhc3RpY091dCBhcyBlYXNlRWxhc3RpY091dCxcbiAgZWxhc3RpY0luT3V0IGFzIGVhc2VFbGFzdGljSW5PdXRcbn0gZnJvbSBcIi4vZWxhc3RpYy5qc1wiO1xuIiwiZXhwb3J0IGNvbnN0IGxpbmVhciA9IHQgPT4gK3Q7XG4iLCIvLyB0cG10IGlzIHR3byBwb3dlciBtaW51cyB0ZW4gdGltZXMgdCBzY2FsZWQgdG8gWzAsMV1cbmV4cG9ydCBmdW5jdGlvbiB0cG10KHgpIHtcbiAgcmV0dXJuIChNYXRoLnBvdygyLCAtMTAgKiB4KSAtIDAuMDAwOTc2NTYyNSkgKiAxLjAwMDk3NzUxNzEwNjU0OTQ7XG59XG4iLCJ2YXIgZXhwb25lbnQgPSAzO1xuXG5leHBvcnQgdmFyIHBvbHlJbiA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gIH1cblxuICBwb2x5SW4uZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbjtcbn0pKGV4cG9uZW50KTtcblxuZXhwb3J0IHZhciBwb2x5T3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5T3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBlKTtcbiAgfVxuXG4gIHBvbHlPdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlPdXQ7XG59KShleHBvbmVudCk7XG5cbmV4cG9ydCB2YXIgcG9seUluT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5SW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KHQsIGUpIDogMiAtIE1hdGgucG93KDIgLSB0LCBlKSkgLyAyO1xuICB9XG5cbiAgcG9seUluT3V0LmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW5PdXQ7XG59KShleHBvbmVudCk7XG4iLCJleHBvcnQgZnVuY3Rpb24gcXVhZEluKHQpIHtcbiAgcmV0dXJuIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhZE91dCh0KSB7XG4gIHJldHVybiB0ICogKDIgLSB0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcbn1cbiIsInZhciBwaSA9IE1hdGguUEksXG4gICAgaGFsZlBpID0gcGkgLyAyO1xuXG5leHBvcnQgZnVuY3Rpb24gc2luSW4odCkge1xuICByZXR1cm4gKCt0ID09PSAxKSA/IDEgOiAxIC0gTWF0aC5jb3ModCAqIGhhbGZQaSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5PdXQodCkge1xuICByZXR1cm4gTWF0aC5zaW4odCAqIGhhbGZQaSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5Jbk91dCh0KSB7XG4gIHJldHVybiAoMSAtIE1hdGguY29zKHBpICogdCkpIC8gMjtcbn1cbiIsImltcG9ydCB2YWx1ZSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuaW1wb3J0IG51bWJlckFycmF5LCB7aXNOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gKGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheSA6IGdlbmVyaWNBcnJheSkoYSwgYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmljQXJyYXkoYSwgYikge1xuICB2YXIgbmIgPSBiID8gYi5sZW5ndGggOiAwLFxuICAgICAgbmEgPSBhID8gTWF0aC5taW4obmIsIGEubGVuZ3RoKSA6IDAsXG4gICAgICB4ID0gbmV3IEFycmF5KG5hKSxcbiAgICAgIGMgPSBuZXcgQXJyYXkobmIpLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgeFtpXSA9IHZhbHVlKGFbaV0sIGJbaV0pO1xuICBmb3IgKDsgaSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiaW1wb3J0IHtjdWJlaGVsaXggYXMgY29sb3JDdWJlaGVsaXh9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaHVlKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBjb2xvckN1YmVoZWxpeChlbmQpKS5oKSxcbiAgICAgICAgICBzID0gY29sb3Ioc3RhcnQucywgZW5kLnMpLFxuICAgICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4LmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG5cbiAgICByZXR1cm4gY3ViZWhlbGl4O1xuICB9KSgxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3ViZWhlbGl4KGh1ZSk7XG5leHBvcnQgdmFyIGN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXgoY29sb3IpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgZCA9IG5ldyBEYXRlO1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZC5zZXRUaW1lKGEgKiAoMSAtIHQpICsgYiAqIHQpLCBkO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cbiIsImltcG9ydCB7aGNsIGFzIGNvbG9ySGNsfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gaGNsKGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IGNvbG9ySGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGNvbG9ySGNsKGVuZCkpLmgpLFxuICAgICAgICBjID0gY29sb3Ioc3RhcnQuYywgZW5kLmMpLFxuICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBoY2woaHVlKTtcbmV4cG9ydCB2YXIgaGNsTG9uZyA9IGhjbChjb2xvcik7XG4iLCJpbXBvcnQge2hzbCBhcyBjb2xvckhzbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhzbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhzbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhzbChlbmQpKS5oKSxcbiAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaHNsKGh1ZSk7XG5leHBvcnQgdmFyIGhzbExvbmcgPSBoc2woY29sb3IpO1xuIiwiaW1wb3J0IHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSBodWUoK2EsICtiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgeCA9IGkodCk7XG4gICAgcmV0dXJuIHggLSAzNjAgKiBNYXRoLmZsb29yKHggLyAzNjApO1xuICB9O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQXJyYXl9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUJhc2lzQ2xvc2VkfSBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGF0ZX0gZnJvbSBcIi4vZGF0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGlzY3JldGV9IGZyb20gXCIuL2Rpc2NyZXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIdWV9IGZyb20gXCIuL2h1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlTnVtYmVyfSBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlT2JqZWN0fSBmcm9tIFwiLi9vYmplY3QuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiLi9yb3VuZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlU3RyaW5nfSBmcm9tIFwiLi9zdHJpbmcuanNcIjtcbmV4cG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MsIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnfSBmcm9tIFwiLi90cmFuc2Zvcm0vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVpvb219IGZyb20gXCIuL3pvb20uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJnYiwgcmdiQmFzaXMgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpcywgcmdiQmFzaXNDbG9zZWQgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vcmdiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIc2wsIGhzbExvbmcgYXMgaW50ZXJwb2xhdGVIc2xMb25nfSBmcm9tIFwiLi9oc2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUxhYn0gZnJvbSBcIi4vbGFiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIY2wsIGhjbExvbmcgYXMgaW50ZXJwb2xhdGVIY2xMb25nfSBmcm9tIFwiLi9oY2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeCwgY3ViZWhlbGl4TG9uZyBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmd9IGZyb20gXCIuL2N1YmVoZWxpeC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZWNld2lzZX0gZnJvbSBcIi4vcGllY2V3aXNlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG4iLCJpbXBvcnQge2xhYiBhcyBjb2xvckxhYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBjb2xvcigoc3RhcnQgPSBjb2xvckxhYihzdGFydCkpLmwsIChlbmQgPSBjb2xvckxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBjb2xvcihzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFiKSBiID0gW107XG4gIHZhciBuID0gYSA/IE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgYyA9IGIuc2xpY2UoKSxcbiAgICAgIGk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY1tpXSA9IGFbaV0gKiAoMSAtIHQpICsgYltpXSAqIHQ7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlckFycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgaSA9IHt9LFxuICAgICAgYyA9IHt9LFxuICAgICAgaztcblxuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IHZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyB2YWx1ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB2YWx1ZXMgPSBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJwb2xhdG9yLCBuKSB7XG4gIHZhciBzYW1wbGVzID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgc2FtcGxlc1tpXSA9IGludGVycG9sYXRvcihpIC8gKG4gLSAxKSk7XG4gIHJldHVybiBzYW1wbGVzO1xufVxuIiwiaW1wb3J0IHtyZ2IgYXMgY29sb3JSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGJhc2lzIGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5pbXBvcnQgYmFzaXNDbG9zZWQgZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmltcG9ydCBub2dhbW1hLCB7Z2FtbWF9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBjb2xvclJnYihzdGFydCkpLnIsIChlbmQgPSBjb2xvclJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGNvbG9yUmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMpO1xuZXhwb3J0IHZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiAoMSAtIHQpICsgYiAqIHQpO1xuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHJnYiBmcm9tIFwiLi9yZ2IuanNcIjtcbmltcG9ydCB7Z2VuZXJpY0FycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGRhdGUgZnJvbSBcIi4vZGF0ZS5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCBvYmplY3QgZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5pbXBvcnQgc3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG4iLCJ2YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHpvb21SaG8ocmhvLCByaG8yLCByaG80KSB7XG5cbiAgLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuICAvLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG4gIGZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGksXG4gICAgICAgIFM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhbCBjYXNlLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwICogcmhvIC8gTWF0aC5TUVJUMjtcblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgem9vbS5yaG8gPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIF8xID0gTWF0aC5tYXgoMWUtMywgK18pLCBfMiA9IF8xICogXzEsIF80ID0gXzIgKiBfMjtcbiAgICByZXR1cm4gem9vbVJobyhfMSwgXzIsIF80KTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn0pKE1hdGguU1FSVDIsIDIsIDQpO1xuIiwiLy8gR2l2ZW4gc29tZXRoaW5nIGFycmF5IGxpa2UgKG9yIG51bGwpLCByZXR1cm5zIHNvbWV0aGluZyB0aGF0IGlzIHN0cmljdGx5IGFuXG4vLyBhcnJheS4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGFycmF5LWxpa2Ugb2JqZWN0cyBwYXNzZWQgdG8gZDMuc2VsZWN0QWxsXG4vLyBvciBzZWxlY3Rpb24uc2VsZWN0QWxsIGFyZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgYXJyYXlzIHdoZW4gY3JlYXRpbmcgYVxuLy8gc2VsZWN0aW9uOyB3ZSBkb27igJl0IGV2ZXIgd2FudCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gYmFja2VkIGJ5IGEgbGl2ZVxuLy8gSFRNTENvbGxlY3Rpb24gb3IgTm9kZUxpc3QuIEhvd2V2ZXIsIG5vdGUgdGhhdCBzZWxlY3Rpb24uc2VsZWN0QWxsIHdpbGwgdXNlIGFcbi8vIHN0YXRpYyBOb2RlTGlzdCBhcyBhIGdyb3VwLCBzaW5jZSBpdCBzYWZlbHkgZGVyaXZlZCBmcm9tIHF1ZXJ5U2VsZWN0b3JBbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcnJheSh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyBbXSA6IEFycmF5LmlzQXJyYXkoeCkgPyB4IDogQXJyYXkuZnJvbSh4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0KGNyZWF0b3IobmFtZSkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4vbmFtZXNwYWNlLmpzXCI7XG5pbXBvcnQge3hodG1sfSBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgY3JlYXRlfSBmcm9tIFwiLi9jcmVhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdG9yfSBmcm9tIFwiLi9jcmVhdG9yLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbG9jYWx9IGZyb20gXCIuL2xvY2FsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWF0Y2hlcn0gZnJvbSBcIi4vbWF0Y2hlci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5hbWVzcGFjZX0gZnJvbSBcIi4vbmFtZXNwYWNlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmFtZXNwYWNlc30gZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBvaW50ZXJ9IGZyb20gXCIuL3BvaW50ZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwb2ludGVyc30gZnJvbSBcIi4vcG9pbnRlcnMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3R9IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdEFsbH0gZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0aW9ufSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3Rvcn0gZnJvbSBcIi4vc2VsZWN0b3IuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RvckFsbH0gZnJvbSBcIi4vc2VsZWN0b3JBbGwuanNcIjtcbmV4cG9ydCB7c3R5bGVWYWx1ZSBhcyBzdHlsZX0gZnJvbSBcIi4vc2VsZWN0aW9uL3N0eWxlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgd2luZG93fSBmcm9tIFwiLi93aW5kb3cuanNcIjtcbiIsInZhciBuZXh0SWQgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb2NhbCgpIHtcbiAgcmV0dXJuIG5ldyBMb2NhbDtcbn1cblxuZnVuY3Rpb24gTG9jYWwoKSB7XG4gIHRoaXMuXyA9IFwiQFwiICsgKCsrbmV4dElkKS50b1N0cmluZygzNik7XG59XG5cbkxvY2FsLnByb3RvdHlwZSA9IGxvY2FsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExvY2FsLFxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG4gICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIG5vZGVbaWRdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZE1hdGNoZXIoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuIiwiaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xufVxuIiwiZXhwb3J0IHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuIiwiaW1wb3J0IHNvdXJjZUV2ZW50IGZyb20gXCIuL3NvdXJjZUV2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG4gIGV2ZW50ID0gc291cmNlRXZlbnQoZXZlbnQpO1xuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSBub2RlID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcbiAgICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gICAgfVxuICAgIGlmIChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiBbZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZXTtcbn1cbiIsImltcG9ydCBwb2ludGVyIGZyb20gXCIuL3BvaW50ZXIuanNcIjtcbmltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudHMsIG5vZGUpIHtcbiAgaWYgKGV2ZW50cy50YXJnZXQpIHsgLy8gaS5lLiwgaW5zdGFuY2VvZiBFdmVudCwgbm90IFRvdWNoTGlzdCBvciBpdGVyYWJsZVxuICAgIGV2ZW50cyA9IHNvdXJjZUV2ZW50KGV2ZW50cyk7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgbm9kZSA9IGV2ZW50cy5jdXJyZW50VGFyZ2V0O1xuICAgIGV2ZW50cyA9IGV2ZW50cy50b3VjaGVzIHx8IFtldmVudHNdO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cywgZXZlbnQgPT4gcG9pbnRlcihldmVudCwgbm9kZSkpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbYXJyYXkoc2VsZWN0b3IpXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi4vbmFtZXNwYWNlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cbiIsImZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUodHJ1ZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7RW50ZXJOb2RlfSBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IG5ldyBNYXAsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApICsgXCJcIjtcbiAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUpKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKSArIFwiXCI7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUpKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZS5kZWxldGUoa2V5VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdHVtKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX19kYXRhX187XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLCBkYXR1bSk7XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gYXJyYXlsaWtlKHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG4vLyBHaXZlbiBzb21lIGRhdGEsIHRoaXMgcmV0dXJucyBhbiBhcnJheS1saWtlIHZpZXcgb2YgaXQ6IGFuIG9iamVjdCB0aGF0XG4vLyBleHBvc2VzIGEgbGVuZ3RoIHByb3BlcnR5IGFuZCBhbGxvd3MgbnVtZXJpYyBpbmRleGluZy4gTm90ZSB0aGF0IHVubGlrZVxuLy8gc2VsZWN0QWxsLCB0aGlzIGlzbuKAmXQgd29ycmllZCBhYm91dCDigJxsaXZl4oCdIGNvbGxlY3Rpb25zIGJlY2F1c2UgdGhlIHJlc3VsdGluZ1xuLy8gYXJyYXkgd2lsbCBvbmx5IGJlIHVzZWQgYnJpZWZseSB3aGlsZSBkYXRhIGlzIGJlaW5nIGJvdW5kLiAoSXQgaXMgcG9zc2libGUgdG9cbi8vIGNhdXNlIHRoZSBkYXRhIHRvIGNoYW5nZSB3aGlsZSBpdGVyYXRpbmcgYnkgdXNpbmcgYSBrZXkgZnVuY3Rpb24sIGJ1dCBwbGVhc2Vcbi8vIGRvbuKAmXQ7IHdl4oCZZCByYXRoZXIgYXZvaWQgYSBncmF0dWl0b3VzIGNvcHkuKVxuZnVuY3Rpb24gYXJyYXlsaWtlKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4gZGF0YVxuICAgID8gZGF0YSAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oZGF0YSk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQgZnJvbSBcIi4vc2VsZWN0Q2hpbGQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4gZnJvbSBcIi4vc2VsZWN0Q2hpbGRyZW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pdGVyYXRvciBmcm9tIFwiLi9pdGVyYXRvci5qc1wiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBqb2luOiBzZWxlY3Rpb25fam9pbixcbiAgbWVyZ2U6IHNlbGVjdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiBzZWxlY3Rpb25fc2VsZWN0aW9uLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX2l0ZXJhdG9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qKCkge1xuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9uZW50ZXIsIG9udXBkYXRlLCBvbmV4aXQpIHtcbiAgdmFyIGVudGVyID0gdGhpcy5lbnRlcigpLCB1cGRhdGUgPSB0aGlzLCBleGl0ID0gdGhpcy5leGl0KCk7XG4gIGlmICh0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZW50ZXIgPSBvbmVudGVyKGVudGVyKTtcbiAgICBpZiAoZW50ZXIpIGVudGVyID0gZW50ZXIuc2VsZWN0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgZW50ZXIgPSBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICB9XG4gIGlmIChvbnVwZGF0ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgICBpZiAodXBkYXRlKSB1cGRhdGUgPSB1cGRhdGUuc2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dDtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gc2VsZWN0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbiIsImZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCB0aGlzLl9fZGF0YV9fKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcih2YWx1ZSk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5vcHRpb25zID0gb3B0aW9ucyk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIG9wdGlvbnM6IG9wdGlvbnN9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5leHQpIF4gNCkgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn1cbiIsImZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IGFycmF5IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yQWxsIGZyb20gXCIuLi9zZWxlY3RvckFsbC5qc1wiO1xuXG5mdW5jdGlvbiBhcnJheUFsbChzZWxlY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcnJheShzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBhcnJheUFsbChzZWxlY3QpO1xuICBlbHNlIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbmQgPSBBcnJheS5wcm90b3R5cGUuZmluZDtcblxuZnVuY3Rpb24gY2hpbGRGaW5kKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmluZC5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRGaXJzdCgpIHtcbiAgcmV0dXJuIHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChtYXRjaCA9PSBudWxsID8gY2hpbGRGaXJzdFxuICAgICAgOiBjaGlsZEZpbmQodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcblxuZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjaGlsZHJlbkZpbHRlcihtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKG1hdGNoID09IG51bGwgPyBjaGlsZHJlblxuICAgICAgOiBjaGlsZHJlbkZpbHRlcih0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpICsrc2l6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGxldCBzb3VyY2VFdmVudDtcbiAgd2hpbGUgKHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQpIGV2ZW50ID0gc291cmNlRXZlbnQ7XG4gIHJldHVybiBldmVudDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJleHBvcnQge1xuICBub3csXG4gIHRpbWVyLFxuICB0aW1lckZsdXNoXG59IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZW91dFxufSBmcm9tIFwiLi90aW1lb3V0LmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgaW50ZXJ2YWxcbn0gZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbiIsImltcG9ydCB7VGltZXIsIG5vd30gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyLCB0b3RhbCA9IGRlbGF5O1xuICBpZiAoZGVsYXkgPT0gbnVsbCkgcmV0dXJuIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpLCB0O1xuICB0Ll9yZXN0YXJ0ID0gdC5yZXN0YXJ0O1xuICB0LnJlc3RhcnQgPSBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBkZWxheSA9ICtkZWxheSwgdGltZSA9IHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWU7XG4gICAgdC5fcmVzdGFydChmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICAgIGVsYXBzZWQgKz0gdG90YWw7XG4gICAgICB0Ll9yZXN0YXJ0KHRpY2ssIHRvdGFsICs9IGRlbGF5LCB0aW1lKTtcbiAgICAgIGNhbGxiYWNrKGVsYXBzZWQpO1xuICAgIH0sIGRlbGF5LCB0aW1lKTtcbiAgfVxuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iLCJpbXBvcnQge1RpbWVyfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XG4gIHQucmVzdGFydChlbGFwc2VkID0+IHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwidmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbCh1bmRlZmluZWQsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtTQ0hFRFVMRUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBpO1xuXG4gIGlmIChzY2hlZHVsZXMpIHtcbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLnN0YXRlID4gU0NIRURVTEVEICYmIHNjaGVkdWxlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKFtbbm9kZV1dLCByb290LCBuYW1lLCAraSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhY3RpdmV9IGZyb20gXCIuL2FjdGl2ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycnVwdH0gZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG4iLCJpbXBvcnQge1NUQVJUSU5HLCBFTkRJTkcsIEVOREVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbXB0eSA9IHRydWUsXG4gICAgICBpO1xuXG4gIGlmICghc2NoZWR1bGVzKSByZXR1cm47XG5cbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcgJiYgc2NoZWR1bGUuc3RhdGUgPCBFTkRJTkc7XG4gICAgc2NoZWR1bGUuc3RhdGUgPSBFTkRFRDtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgc2NoZWR1bGUub24uY2FsbChhY3RpdmUgPyBcImludGVycnVwdFwiIDogXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2NoZWR1bGUuaW5kZXgsIHNjaGVkdWxlLmdyb3VwKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICB9XG5cbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnRlcnJ1cHQgZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuXG5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XG5zZWxlY3Rpb24ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBzZWxlY3Rpb25fdHJhbnNpdGlvbjtcbiIsImltcG9ydCBpbnRlcnJ1cHQgZnJvbSBcIi4uL2ludGVycnVwdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJydXB0KHRoaXMsIG5hbWUpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUgZnJvbSBcIi4uL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7ZWFzZUN1YmljSW5PdXR9IGZyb20gXCJkMy1lYXNlXCI7XG5pbXBvcnQge25vd30gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBkZWZhdWx0VGltaW5nID0ge1xuICB0aW1lOiBudWxsLCAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogZWFzZUN1YmljSW5PdXRcbn07XG5cbmZ1bmN0aW9uIGluaGVyaXQobm9kZSwgaWQpIHtcbiAgdmFyIHRpbWluZztcbiAgd2hpbGUgKCEodGltaW5nID0gbm9kZS5fX3RyYW5zaXRpb24pIHx8ICEodGltaW5nID0gdGltaW5nW2lkXSkpIHtcbiAgICBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2l0aW9uICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGltaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBpZCxcbiAgICAgIHRpbWluZztcblxuICBpZiAobmFtZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICBpZCA9IG5hbWUuX2lkLCBuYW1lID0gbmFtZS5fbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IG5ld0lkKCksICh0aW1pbmcgPSBkZWZhdWx0VGltaW5nKS50aW1lID0gbm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSksIGkgPSBmdWxsbmFtZSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KShmdWxsbmFtZSwgaSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge2dldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZGVsYXlGdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGF5Q29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZGVsYXk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkdXJhdGlvbkZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZHVyYXRpb25GdW5jdGlvblxuICAgICAgICAgIDogZHVyYXRpb25Db25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZHVyYXRpb247XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaChlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlVmFyeWluZyhpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy5lYWNoKGVhc2VWYXJ5aW5nKHRoaXMuX2lkLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgb24wLCBvbjEsIHRoYXQgPSB0aGlzLCBpZCA9IHRoYXQuX2lkLCBzaXplID0gdGhhdC5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgY2FuY2VsID0ge3ZhbHVlOiByZWplY3R9LFxuICAgICAgICBlbmQgPSB7dmFsdWU6IGZ1bmN0aW9uKCkgeyBpZiAoLS1zaXplID09PSAwKSByZXNvbHZlKCk7IH19O1xuXG4gICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgICAgaWYgKG9uICE9PSBvbjApIHtcbiAgICAgICAgb24xID0gKG9uMCA9IG9uKS5jb3B5KCk7XG4gICAgICAgIG9uMS5fLmNhbmNlbC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmludGVycnVwdC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmVuZC5wdXNoKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHNlbGVjdGlvbiB3YXMgZW1wdHksIHJlc29sdmUgZW5kIGltbWVkaWF0ZWx5XG4gICAgaWYgKHNpemUgPT09IDApIHJlc29sdmUoKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge21hdGNoZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHJUd2VlbiBmcm9tIFwiLi9hdHRyVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2RlbGF5IGZyb20gXCIuL2RlbGF5LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZSBmcm9tIFwiLi9lYXNlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlVmFyeWluZyBmcm9tIFwiLi9lYXNlVmFyeWluZy5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3Rpb24gZnJvbSBcIi4vc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGVUd2VlbiBmcm9tIFwiLi9zdHlsZVR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHRUd2VlbiBmcm9tIFwiLi90ZXh0VHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHdlZW4gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2VuZCBmcm9tIFwiLi9lbmQuanNcIjtcblxudmFyIGlkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zaXRpb24oZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCkge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3Rpb24oKS50cmFuc2l0aW9uKG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3SWQoKSB7XG4gIHJldHVybiArK2lkO1xufVxuXG52YXIgc2VsZWN0aW9uX3Byb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGU7XG5cblRyYW5zaXRpb24ucHJvdG90eXBlID0gdHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICBzZWxlY3Q6IHRyYW5zaXRpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHRyYW5zaXRpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogdHJhbnNpdGlvbl9maWx0ZXIsXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHRyYW5zaXRpb25fc2VsZWN0aW9uLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uX3RyYW5zaXRpb24sXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX3Byb3RvdHlwZS5lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX3Byb3RvdHlwZS5lYWNoLFxuICBvbjogdHJhbnNpdGlvbl9vbixcbiAgYXR0cjogdHJhbnNpdGlvbl9hdHRyLFxuICBhdHRyVHdlZW46IHRyYW5zaXRpb25fYXR0clR3ZWVuLFxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcbiAgc3R5bGVUd2VlbjogdHJhbnNpdGlvbl9zdHlsZVR3ZWVuLFxuICB0ZXh0OiB0cmFuc2l0aW9uX3RleHQsXG4gIHRleHRUd2VlbjogdHJhbnNpdGlvbl90ZXh0VHdlZW4sXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXG4gIHR3ZWVuOiB0cmFuc2l0aW9uX3R3ZWVuLFxuICBkZWxheTogdHJhbnNpdGlvbl9kZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXG4gIGVhc2U6IHRyYW5zaXRpb25fZWFzZSxcbiAgZWFzZVZhcnlpbmc6IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcsXG4gIGVuZDogdHJhbnNpdGlvbl9lbmQsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25fcHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl1cbn07XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUmdiLCBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGM7XG4gIHJldHVybiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIgPyBpbnRlcnBvbGF0ZU51bWJlclxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyBpbnRlcnBvbGF0ZVJnYlxuICAgICAgOiAoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gc3RhcnQobmFtZSkge1xuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsIG9uMSwgc2l0ID0gc3RhcnQobmFtZSkgPyBpbml0IDogc2V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2l0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCkgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihuYW1lLCBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyXG4gICAgICA/IGdldCh0aGlzLm5vZGUoKSwgaWQpLm9uLm9uKG5hbWUpXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyLCB0aW1lb3V0fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGVtcHR5T24gPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2FuY2VsXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxuZXhwb3J0IHZhciBDUkVBVEVEID0gMDtcbmV4cG9ydCB2YXIgU0NIRURVTEVEID0gMTtcbmV4cG9ydCB2YXIgU1RBUlRJTkcgPSAyO1xuZXhwb3J0IHZhciBTVEFSVEVEID0gMztcbmV4cG9ydCB2YXIgUlVOTklORyA9IDQ7XG5leHBvcnQgdmFyIEVORElORyA9IDU7XG5leHBvcnQgdmFyIEVOREVEID0gNjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSwgaWQsIGluZGV4LCBncm91cCwgdGltaW5nKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZXMpIG5vZGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKGlkIGluIHNjaGVkdWxlcykgcmV0dXJuO1xuICBjcmVhdGUobm9kZSwgaWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBlbXB0eU9uLFxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxuICAgIHRpbWU6IHRpbWluZy50aW1lLFxuICAgIGRlbGF5OiB0aW1pbmcuZGVsYXksXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcbiAgICBlYXNlOiB0aW1pbmcuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogQ1JFQVRFRFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gQ1JFQVRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgc2NoZWR1bGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gU1RBUlRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgcnVubmluZ1wiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgaWQsIHNlbGYpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgdHdlZW47XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuICBzY2hlZHVsZXNbaWRdID0gc2VsZjtcbiAgc2VsZi50aW1lciA9IHRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcblxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChzZWxmLmRlbGF5IDw9IGVsYXBzZWQpIHN0YXJ0KGVsYXBzZWQgLSBzZWxmLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICB2YXIgaSwgaiwgbiwgbztcblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgbyA9IHNjaGVkdWxlc1tpXTtcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XG5cbiAgICAgIC8vIFdoaWxlIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHN0YXJ0aW5nIHRyYW5zaXRpb24gZHVyaW5nIHRoaXMgZnJhbWUsXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcbiAgICAgIC8vIGNoYW5jZSB0byB0aWNrIChhbmQgcG9zc2libHkgZW5kKTsgc2VlIGQzL2QzLXRyYW5zaXRpb24jNTQhXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIHRpbWVvdXQoc3RhcnQpO1xuXG4gICAgICAvLyBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBhbnkgcHJlLWVtcHRlZCB0cmFuc2l0aW9ucy5cbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXG4gICAgLy8gTm90ZSB0aGUgdHJhbnNpdGlvbiBtYXkgYmUgY2FuY2VsZWQgYWZ0ZXIgc3RhcnQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdGljayFcbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBzY2hlZHVsZWQgYmVmb3JlIHRoZSBzdGFydCBldmVudDsgc2VlIGQzL2QzLXRyYW5zaXRpb24jMTYhXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxuICAgIHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gUlVOTklORztcbiAgICAgICAgc2VsZi50aW1lci5yZXN0YXJ0KHRpY2ssIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG4gICAgICAgIHRpY2soZWxhcHNlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgc3RhcnQgZXZlbnQuXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIHR3ZWVuIGFyZSBpbml0aWFsaXplZC5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0d2VlbiwgZGVsZXRpbmcgbnVsbCB0d2Vlbi5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGogPSAtMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG8gPSBzZWxmLnR3ZWVuW2ldLnZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCkpIHtcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgdmFyIHQgPSBlbGFwc2VkIDwgc2VsZi5kdXJhdGlvbiA/IHNlbGYuZWFzZS5jYWxsKG51bGwsIGVsYXBzZWQgLyBzZWxmLmR1cmF0aW9uKSA6IChzZWxmLnRpbWVyLnJlc3RhcnQoc3RvcCksIHNlbGYuc3RhdGUgPSBFTkRJTkcsIDEpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgdHdlZW5baV0uY2FsbChub2RlLCB0KTtcbiAgICB9XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuICAgIGlmIChzZWxmLnN0YXRlID09PSBFTkRJTkcpIHtcbiAgICAgIHNlbGYub24uY2FsbChcImVuZFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHNlbGYuc3RhdGUgPSBFTkRFRDtcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgICBzY2hlZHVsZShzdWJncm91cFtpXSwgbmFtZSwgaWQsIGksIHN1Ymdyb3VwLCBnZXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yQWxsfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCksIGNoaWxkLCBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkKSwgayA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGsgPCBsOyArK2spIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPSBjaGlsZHJlbltrXSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoY2hpbGQsIG5hbWUsIGlkLCBrLCBjaGlsZHJlbiwgaW5oZXJpdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbnZhciBTZWxlY3Rpb24gPSBzZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzdHlsZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVOdWxsKG5hbWUsIGludGVycG9sYXRlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgc3RyaW5nMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHN0cmluZzEwID0gc3RyaW5nMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgdmFsdWUxID0gdmFsdWUodGhpcyksXG4gICAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgc3RyaW5nMSA9IHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZU1heWJlUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciBvbjAsIG9uMSwgbGlzdGVuZXIwLCBrZXkgPSBcInN0eWxlLlwiICsgbmFtZSwgZXZlbnQgPSBcImVuZC5cIiArIGtleSwgcmVtb3ZlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbixcbiAgICAgICAgbGlzdGVuZXIgPSBzY2hlZHVsZS52YWx1ZVtrZXldID09IG51bGwgPyByZW1vdmUgfHwgKHJlbW92ZSA9IHN0eWxlUmVtb3ZlKG5hbWUpKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCB8fCBsaXN0ZW5lcjAgIT09IGxpc3RlbmVyKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKGV2ZW50LCBsaXN0ZW5lcjAgPSBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBpID0gKG5hbWUgKz0gXCJcIikgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlTnVsbChuYW1lLCBpKSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIHN0eWxlUmVtb3ZlKG5hbWUpKVxuICAgIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUZ1bmN0aW9uKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSkpXG4gICAgICAuZWFjaChzdHlsZU1heWJlUmVtb3ZlKHRoaXMuX2lkLCBuYW1lKSlcbiAgICA6IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUpLCBwcmlvcml0eSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIG51bGwpO1xufVxuIiwiZnVuY3Rpb24gc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaS5jYWxsKHRoaXMsIHQpLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciB0LCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdCA9IChpMCA9IGkpICYmIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIga2V5ID0gXCJzdHlsZS5cIiArIChuYW1lICs9IFwiXCIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpO1xufVxuIiwiaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlMSA9PSBudWxsID8gXCJcIiA6IHZhbHVlMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IHRleHRGdW5jdGlvbih0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufVxuIiwiZnVuY3Rpb24gdGV4dEludGVycG9sYXRlKGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gaS5jYWxsKHRoaXMsIHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0VHdlZW4odmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiB0ZXh0SW50ZXJwb2xhdGUoaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcInRleHRcIjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHRleHRUd2Vlbih2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxuICAgICAgaWQxID0gbmV3SWQoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldChub2RlLCBpZDApO1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZDEsIGksIGdyb3VwLCB7XG4gICAgICAgICAgdGltZTogaW5oZXJpdC50aW1lICsgaW5oZXJpdC5kZWxheSArIGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiB0d2VlblJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gdHdlZW4wID0gdHdlZW47XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xID0gdHdlZW4xLnNsaWNlKCk7XG4gICAgICAgICAgdHdlZW4xLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0d2VlbkZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9ICh0d2VlbjAgPSB0d2Vlbikuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIHQgPSB7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSwgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMVtpXSA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBuKSB0d2VlbjEucHVzaCh0KTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgbmFtZSArPSBcIlwiO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciB0d2VlbiA9IGdldCh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4ubGVuZ3RoLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHQgPSB0d2VlbltpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gdHdlZW5SZW1vdmUgOiB0d2VlbkZ1bmN0aW9uKShpZCwgbmFtZSwgdmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG5cbiAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlLnZhbHVlIHx8IChzY2hlZHVsZS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBnZXQobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9vbUV2ZW50KHR5cGUsIHtcbiAgc291cmNlRXZlbnQsXG4gIHRhcmdldCxcbiAgdHJhbnNmb3JtLFxuICBkaXNwYXRjaFxufSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHlwZToge3ZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHNvdXJjZUV2ZW50OiB7dmFsdWU6IHNvdXJjZUV2ZW50LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRhcmdldDoge3ZhbHVlOiB0YXJnZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdHJhbnNmb3JtOiB7dmFsdWU6IHRyYW5zZm9ybSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBfOiB7dmFsdWU6IGRpc3BhdGNofVxuICB9KTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgem9vbVRyYW5zZm9ybSwgaWRlbnRpdHkgYXMgem9vbUlkZW50aXR5LCBUcmFuc2Zvcm0gYXMgWm9vbVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKGssIHgsIHkpIHtcbiAgdGhpcy5rID0gaztcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuayAqIGssIHRoaXMueCwgdGhpcy55KTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IDAgJiB5ID09PSAwID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB4LCB0aGlzLnkgKyB0aGlzLmsgKiB5KTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludFswXSAqIHRoaXMuayArIHRoaXMueCwgcG9pbnRbMV0gKiB0aGlzLmsgKyB0aGlzLnldO1xuICB9LFxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCAqIHRoaXMuayArIHRoaXMueDtcbiAgfSxcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLmsgKyB0aGlzLnk7XG4gIH0sXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gWyhsb2NhdGlvblswXSAtIHRoaXMueCkgLyB0aGlzLmssIChsb2NhdGlvblsxXSAtIHRoaXMueSkgLyB0aGlzLmtdO1xuICB9LFxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4IC0gdGhpcy54KSAvIHRoaXMuaztcbiAgfSxcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoeSAtIHRoaXMueSkgLyB0aGlzLms7XG4gIH0sXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguY29weSgpLmRvbWFpbih4LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCwgdGhpcykubWFwKHguaW52ZXJ0LCB4KSk7XG4gIH0sXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkuY29weSgpLmRvbWFpbih5LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WSwgdGhpcykubWFwKHkuaW52ZXJ0LCB5KSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtkcmFnRGlzYWJsZSwgZHJhZ0VuYWJsZX0gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVab29tfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c2VsZWN0LCBwb2ludGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2ludGVycnVwdH0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IFpvb21FdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuaW1wb3J0IHtUcmFuc2Zvcm0sIGlkZW50aXR5fSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbi8vIGV4Y2VwdCBmb3IgcGluY2gtdG8tem9vbSwgd2hpY2ggaXMgc2VudCBhcyBhIHdoZWVsK2N0cmxLZXkgZXZlbnRcbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoZXZlbnQpIHtcbiAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBldmVudC50eXBlID09PSAnd2hlZWwnKSAmJiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXh0ZW50KCkge1xuICB2YXIgZSA9IHRoaXM7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIGlmIChlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICAgIGUgPSBlLnZpZXdCb3guYmFzZVZhbDtcbiAgICAgIHJldHVybiBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV07XG4gICAgfVxuICAgIHJldHVybiBbWzAsIDBdLCBbZS53aWR0aC5iYXNlVmFsLnZhbHVlLCBlLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtlLmNsaWVudFdpZHRoLCBlLmNsaWVudEhlaWdodF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKGV2ZW50KSB7XG4gIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogKGV2ZW50LmN0cmxLZXkgPyAxMCA6IDEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29uc3RyYWluKHRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpIHtcbiAgdmFyIGR4MCA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFswXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMF0sXG4gICAgICBkeDEgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMV1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzBdLFxuICAgICAgZHkwID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzBdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVsxXSxcbiAgICAgIGR5MSA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFsxXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMV07XG4gIHJldHVybiB0cmFuc2Zvcm0udHJhbnNsYXRlKFxuICAgIGR4MSA+IGR4MCA/IChkeDAgKyBkeDEpIC8gMiA6IE1hdGgubWluKDAsIGR4MCkgfHwgTWF0aC5tYXgoMCwgZHgxKSxcbiAgICBkeTEgPiBkeTAgPyAoZHkwICsgZHkxKSAvIDIgOiBNYXRoLm1pbigwLCBkeTApIHx8IE1hdGgubWF4KDAsIGR5MSlcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGNvbnN0cmFpbiA9IGRlZmF1bHRDb25zdHJhaW4sXG4gICAgICB3aGVlbERlbHRhID0gZGVmYXVsdFdoZWVsRGVsdGEsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgc2NhbGVFeHRlbnQgPSBbMCwgSW5maW5pdHldLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVpvb20sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSxcbiAgICAgIHRvdWNoc3RhcnRpbmcsXG4gICAgICB0b3VjaGZpcnN0LFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMCxcbiAgICAgIHRhcERpc3RhbmNlID0gMTA7XG5cbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZCwge3Bhc3NpdmU6IGZhbHNlfSlcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vkb3duZWQpXG4gICAgICAgIC5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuem9vbVwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcbiAgICBzZWxlY3Rpb24ucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSk7XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW50ZXJydXB0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgLmV2ZW50KGV2ZW50KVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLnpvb20obnVsbCwgdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0cmFuc2Zvcm0pXG4gICAgICAgICAgLmVuZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHpvb20uc2NhbGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHAsXG4gICAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBudWxsLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbihpZGVudGl0eS50cmFuc2xhdGUocDBbMF0sIHAwWzFdKS5zY2FsZSh0LmspLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IC15LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteVxuICAgICAgKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCBrKSB7XG4gICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgaykpO1xuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xuICAgIHZhciB4ID0gcDBbMF0gLSBwMVswXSAqIHRyYW5zZm9ybS5rLCB5ID0gcDBbMV0gLSBwMVsxXSAqIHRyYW5zZm9ybS5rO1xuICAgIHJldHVybiB4ID09PSB0cmFuc2Zvcm0ueCAmJiB5ID09PSB0cmFuc2Zvcm0ueSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtLmssIHgsIHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB0cmFuc2l0aW9uXG4gICAgICAgIC5vbihcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuZW5kKCk7IH0pXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgICAgICAgIGUgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyksXG4gICAgICAgICAgICAgIHAgPSBwb2ludCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcG9pbnQgPT09IFwiZnVuY3Rpb25cIiA/IHBvaW50LmFwcGx5KHRoYXQsIGFyZ3MpIDogcG9pbnQsXG4gICAgICAgICAgICAgIHcgPSBNYXRoLm1heChlWzFdWzBdIC0gZVswXVswXSwgZVsxXVsxXSAtIGVbMF1bMV0pLFxuICAgICAgICAgICAgICBhID0gdGhhdC5fX3pvb20sXG4gICAgICAgICAgICAgIGIgPSB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhhdCwgYXJncykgOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGkgPSBpbnRlcnBvbGF0ZShhLmludmVydChwKS5jb25jYXQodyAvIGEuayksIGIuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYi5rKSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0ID0gYjsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3Igb24gZW5kLlxuICAgICAgICAgICAgZWxzZSB7IHZhciBsID0gaSh0KSwgayA9IHcgLyBsWzJdOyB0ID0gbmV3IFRyYW5zZm9ybShrLCBwWzBdIC0gbFswXSAqIGssIHBbMV0gLSBsWzFdICogayk7IH1cbiAgICAgICAgICAgIGcuem9vbShudWxsLCB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlc3R1cmUodGhhdCwgYXJncywgY2xlYW4pIHtcbiAgICByZXR1cm4gKCFjbGVhbiAmJiB0aGF0Ll9fem9vbWluZykgfHwgbmV3IEdlc3R1cmUodGhhdCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBHZXN0dXJlKHRoYXQsIGFyZ3MpIHtcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIHRoaXMuc291cmNlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIHRoaXMudGFwcyA9IDA7XG4gIH1cblxuICBHZXN0dXJlLnByb3RvdHlwZSA9IHtcbiAgICBldmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkgdGhpcy5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkge1xuICAgICAgICB0aGlzLnRoYXQuX196b29taW5nID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhcnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uKGtleSwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodGhpcy5tb3VzZSAmJiBrZXkgIT09IFwibW91c2VcIikgdGhpcy5tb3VzZVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy5tb3VzZVswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDAgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gwWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMFswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDEgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gxWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMVswXSk7XG4gICAgICB0aGlzLnRoYXQuX196b29tID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5lbWl0KFwiem9vbVwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRoYXQuX196b29taW5nO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBkID0gc2VsZWN0KHRoaXMudGhhdCkuZGF0dW0oKTtcbiAgICAgIGxpc3RlbmVycy5jYWxsKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLnRoYXQsXG4gICAgICAgIG5ldyBab29tRXZlbnQodHlwZSwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiB0aGlzLnNvdXJjZUV2ZW50LFxuICAgICAgICAgIHRhcmdldDogem9vbSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy50aGF0Ll9fem9vbSxcbiAgICAgICAgICBkaXNwYXRjaDogbGlzdGVuZXJzXG4gICAgICAgIH0pLFxuICAgICAgICBkXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgdC5rICogTWF0aC5wb3coMiwgd2hlZWxEZWx0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCk7XG5cbiAgICAvLyBJZiB0aGUgbW91c2UgaXMgaW4gdGhlIHNhbWUgbG9jYXRpb24gYXMgYmVmb3JlLCByZXVzZSBpdC5cbiAgICAvLyBJZiB0aGVyZSB3ZXJlIHJlY2VudCB3aGVlbCBldmVudHMsIHJlc2V0IHRoZSB3aGVlbCBpZGxlIHRpbWVvdXQuXG4gICAgaWYgKGcud2hlZWwpIHtcbiAgICAgIGlmIChnLm1vdXNlWzBdWzBdICE9PSBwWzBdIHx8IGcubW91c2VbMF1bMV0gIT09IHBbMV0pIHtcbiAgICAgICAgZy5tb3VzZVsxXSA9IHQuaW52ZXJ0KGcubW91c2VbMF0gPSBwKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChnLndoZWVsKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHdoZWVsIGV2ZW50IHdvbuKAmXQgdHJpZ2dlciBhIHRyYW5zZm9ybSBjaGFuZ2UsIGlnbm9yZSBpdC5cbiAgICBlbHNlIGlmICh0LmsgPT09IGspIHJldHVybjtcblxuICAgIC8vIE90aGVyd2lzZSwgY2FwdHVyZSB0aGUgbW91c2UgcG9pbnQgYW5kIGxvY2F0aW9uIGF0IHRoZSBzdGFydC5cbiAgICBlbHNlIHtcbiAgICAgIGcubW91c2UgPSBbcCwgdC5pbnZlcnQocCldO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgdHJ1ZSkuZXZlbnQoZXZlbnQpLFxuICAgICAgICB2ID0gc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLnpvb21cIiwgbW91c2V1cHBlZCwgdHJ1ZSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgeDAgPSBldmVudC5jbGllbnRYLFxuICAgICAgICB5MCA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICBkcmFnRGlzYWJsZShldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBnLm1vdXNlID0gW3AsIHRoaXMuX196b29tLmludmVydChwKV07XG4gICAgaW50ZXJydXB0KHRoaXMpO1xuICAgIGcuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZWQoZXZlbnQpIHtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKCFnLm1vdmVkKSB7XG4gICAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSB4MCwgZHkgPSBldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy5ldmVudChldmVudClcbiAgICAgICAuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXBwZWQoZXZlbnQpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkcmFnRW5hYmxlKGV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBnLmV2ZW50KGV2ZW50KS5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICBwMCA9IHBvaW50ZXIoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50LCB0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmdzKSwgdHJhbnNsYXRlRXh0ZW50KTtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCwgZXZlbnQpO1xuICAgIGVsc2Ugc2VsZWN0KHRoaXMpLmNhbGwoem9vbS50cmFuc2Zvcm0sIHQxLCBwMCwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgc3RhcnRlZCwgaSwgdCwgcDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaGZpcnN0ID0gcFswXSwgdG91Y2hzdGFydGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoc3RhcnRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0LCBwLCBsO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gwWzBdID0gcDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gxWzBdID0gcDtcbiAgICB9XG4gICAgdCA9IGcudGhhdC5fX3pvb207XG4gICAgaWYgKGcudG91Y2gxKSB7XG4gICAgICB2YXIgcDAgPSBnLnRvdWNoMFswXSwgbDAgPSBnLnRvdWNoMFsxXSxcbiAgICAgICAgICBwMSA9IGcudG91Y2gxWzBdLCBsMSA9IGcudG91Y2gxWzFdLFxuICAgICAgICAgIGRwID0gKGRwID0gcDFbMF0gLSBwMFswXSkgKiBkcCArIChkcCA9IHAxWzFdIC0gcDBbMV0pICogZHAsXG4gICAgICAgICAgZGwgPSAoZGwgPSBsMVswXSAtIGwwWzBdKSAqIGRsICsgKGRsID0gbDFbMV0gLSBsMFsxXSkgKiBkbDtcbiAgICAgIHQgPSBzY2FsZSh0LCBNYXRoLnNxcnQoZHAgLyBkbCkpO1xuICAgICAgcCA9IFsocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyXTtcbiAgICAgIGwgPSBbKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGcudG91Y2gwKSBwID0gZy50b3VjaDBbMF0sIGwgPSBnLnRvdWNoMFsxXTtcbiAgICBlbHNlIHJldHVybjtcblxuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQ7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICB9XG4gICAgaWYgKGcudG91Y2gxICYmICFnLnRvdWNoMCkgZy50b3VjaDAgPSBnLnRvdWNoMSwgZGVsZXRlIGcudG91Y2gxO1xuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgZy5lbmQoKTtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgZGJsdGFwLCByZXJvdXRlIHRvIHRoZSAob3B0aW9uYWwpIGRibGNsaWNrLnpvb20gaGFuZGxlci5cbiAgICAgIGlmIChnLnRhcHMgPT09IDIpIHtcbiAgICAgICAgdCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICAgIGlmIChNYXRoLmh5cG90KHRvdWNoZmlyc3RbMF0gLSB0WzBdLCB0b3VjaGZpcnN0WzFdIC0gdFsxXSkgPCB0YXBEaXN0YW5jZSkge1xuICAgICAgICAgIHZhciBwID0gc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgICBpZiAocCkgcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdoZWVsRGVsdGEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgem9vbSkgOiB3aGVlbERlbHRhO1xuICB9O1xuXG4gIHpvb20uZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgem9vbS50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgem9vbSkgOiBleHRlbnQ7XG4gIH07XG5cbiAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZUV4dGVudFswXSA9ICtfWzBdLCBzY2FsZUV4dGVudFsxXSA9ICtfWzFdLCB6b29tKSA6IFtzY2FsZUV4dGVudFswXSwgc2NhbGVFeHRlbnRbMV1dO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25zdHJhaW4gPSBfLCB6b29tKSA6IGNvbnN0cmFpbjtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgem9vbS50YXBEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXBEaXN0YW5jZSA9ICtfLCB6b29tKSA6IHRhcERpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufVxuIiwiLyoqXG4gKiBKU1RTLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0c1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VETHYxLnR4dFxuICogaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VQTHYxLnR4dFxuICogQGxpY2Vuc2VcbiAqL1xuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZSk6ZSgodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmpzdHM9e30pfSh0aGlzLChmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtjbGFzcyBle3N0YXRpYyBlcXVhbHNXaXRoVG9sZXJhbmNlKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnModC1lKTw9bn19Y2xhc3MgbiBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7RXhjZXB0aW9uOm59KVswXX10b1N0cmluZygpe3JldHVybiB0aGlzLm1lc3NhZ2V9fWNsYXNzIHMgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7SWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uOnN9KVswXX19Y2xhc3MgaXtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMubG93PWV8fDAsdGhpcy5oaWdoPXR8fDB9c3RhdGljIHRvQmluYXJ5U3RyaW5nKHQpe2xldCBlLG49XCJcIjtmb3IoZT0yMTQ3NDgzNjQ4O2U+MDtlPj4+PTEpbis9KHQuaGlnaCZlKT09PWU/XCIxXCI6XCIwXCI7Zm9yKGU9MjE0NzQ4MzY0ODtlPjA7ZT4+Pj0xKW4rPSh0LmxvdyZlKT09PWU/XCIxXCI6XCIwXCI7cmV0dXJuIG59fWZ1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gYygpe31yLk5hTj1OYU4sci5pc05hTj10PT5OdW1iZXIuaXNOYU4odCksci5pc0luZmluaXRlPXQ9PiFOdW1iZXIuaXNGaW5pdGUodCksci5NQVhfVkFMVUU9TnVtYmVyLk1BWF9WQUxVRSxyLlBPU0lUSVZFX0lORklOSVRZPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSxyLk5FR0FUSVZFX0lORklOSVRZPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBGbG9hdDY0QXJyYXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEludDMyQXJyYXk/ZnVuY3Rpb24oKXtjb25zdCB0PTIxNDY0MzUwNzIsZT1uZXcgRmxvYXQ2NEFycmF5KDEpLG49bmV3IEludDMyQXJyYXkoZS5idWZmZXIpO3IuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbihzKXtlWzBdPXM7bGV0IHI9MHxuWzBdLG89MHxuWzFdO3JldHVybihvJnQpPT09dCYmMCE9KDEwNDg1NzUmbykmJjAhPT1yJiYocj0wLG89MjE0Njk1OTM2MCksbmV3IGkobyxyKX0sci5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKHQpe3JldHVybiBuWzBdPXQubG93LG5bMV09dC5oaWdoLGVbMF19fSgpOmZ1bmN0aW9uKCl7Y29uc3QgdD0xMDIzLGU9TWF0aC5sb2cyLG49TWF0aC5mbG9vcixzPU1hdGgucG93LG89ZnVuY3Rpb24oKXtmb3IobGV0IHQ9NTM7dD4wO3QtLSl7Y29uc3QgaT1zKDIsdCktMTtpZihuKGUoaSkpKzE9PT10KXJldHVybiBpfXJldHVybiAwfSgpO3IuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbihyKXtsZXQgbCxhLGMsaCx1LGcsZCxfLHA7aWYocjwwfHwxL3I9PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk/KGc9MTw8MzEscj0tcik6Zz0wLDA9PT1yKXJldHVybiBwPTAsXz1nLG5ldyBpKF8scCk7aWYocj09PTEvMClyZXR1cm4gcD0wLF89MjE0NjQzNTA3MnxnLG5ldyBpKF8scCk7aWYociE9cilyZXR1cm4gcD0wLF89MjE0Njk1OTM2MCxuZXcgaShfLHApO2lmKGg9MCxwPTAsbD1uKHIpLGw+MSlpZihsPD1vKWg9bihlKGwpKSxoPD0yMD8ocD0wLF89bDw8MjAtaCYxMDQ4NTc1KTooYz1oLTIwLGE9cygyLGMpLHA9bCVhPDwzMi1jLF89bC9hJjEwNDg1NzUpO2Vsc2UgZm9yKGM9bCxwPTA7YT1jLzIsYz1uKGEpLDAhPT1jOyloKysscD4+Pj0xLHB8PSgxJl8pPDwzMSxfPj4+PTEsYSE9PWMmJihffD01MjQyODgpO2lmKGQ9aCt0LHU9MD09PWwsbD1yLWwsaDw1MiYmMCE9PWwpZm9yKGM9MDs7KXtpZihhPTIqbCxhPj0xPyhsPWEtMSx1PyhkLS0sdT0hMSk6KGM8PD0xLGN8PTEsaCsrKSk6KGw9YSx1PzA9PS0tZCYmKGgrKyx1PSExKTooYzw8PTEsaCsrKSksMjA9PT1oKV98PWMsYz0wO2Vsc2UgaWYoNTI9PT1oKXtwfD1jO2JyZWFrfWlmKDE9PT1hKXtoPDIwP198PWM8PDIwLWg6aDw1MiYmKHB8PWM8PDUyLWgpO2JyZWFrfX1yZXR1cm4gX3w9ZDw8MjAsX3w9ZyxuZXcgaShfLHApfSxyLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24oZSl7bGV0IG4saSxyLG87Y29uc3QgbD1lLmhpZ2gsYT1lLmxvdyxjPWwmMTw8MzE/LTE6MTtmb3Iocj0oKDIxNDY0MzUwNzImbCk+PjIwKS10LG89MCxpPTE8PDE5LG49MTtuPD0yMDtuKyspbCZpJiYobys9cygyLC1uKSksaT4+Pj0xO2ZvcihpPTE8PDMxLG49MjE7bjw9NTI7bisrKWEmaSYmKG8rPXMoMiwtbikpLGk+Pj49MTtpZigtMTAyMz09PXIpe2lmKDA9PT1vKXJldHVybiAwKmM7cj0tMTAyMn1lbHNle2lmKDEwMjQ9PT1yKXJldHVybiAwPT09bz9jLzA6TmFOO28rPTF9cmV0dXJuIGMqbypzKDIscil9fSgpO2NsYXNzIGggZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7UnVudGltZUV4Y2VwdGlvbjpofSlbMF19fWNsYXNzIHUgZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx1LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWguY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX19Y2xhc3MgZ3tzdGF0aWMgc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClnLnNob3VsZE5ldmVyUmVhY2hIZXJlKG51bGwpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3Rocm93IG5ldyB1KFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIisobnVsbCE9PXQ/XCI6IFwiK3Q6XCJcIikpfX1zdGF0aWMgaXNUcnVlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2cuaXNUcnVlKHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07aWYoIWFyZ3VtZW50c1swXSl0aHJvdyBudWxsPT09dD9uZXcgdTpuZXcgdSh0KX19c3RhdGljIGVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtnLmVxdWFscyh0LGUsbnVsbCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoIWUuZXF1YWxzKHQpKXRocm93IG5ldyB1KFwiRXhwZWN0ZWQgXCIrdCtcIiBidXQgZW5jb3VudGVyZWQgXCIrZSsobnVsbCE9PW4/XCI6IFwiK246XCJcIikpfX19Y29uc3QgZD1uZXcgQXJyYXlCdWZmZXIoOCksXz1uZXcgRmxvYXQ2NEFycmF5KGQpLHA9bmV3IEludDMyQXJyYXkoZCk7Y2xhc3MgbXtjb25zdHJ1Y3Rvcigpe20uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy56PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpbS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDAsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnksdC5nZXRaKCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbS5OVUxMX09SRElOQVRFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9bn19c3RhdGljIGhhc2hDb2RlKHQpe3JldHVybiBfWzBdPXQscFswXV5wWzFdfWdldE0oKXtyZXR1cm4gci5OYU59c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSBtLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBtLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBtLlo6dGhpcy5zZXRaKGUpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19ZXF1YWxzMkQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4hIWUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLngsdC54LG4pJiYhIWUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnksdC55LG4pfX1zZXRNKHQpe3Rocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrbS5NKX1nZXRaKCl7cmV0dXJuIHRoaXMuen1nZXRPcmRpbmF0ZSh0KXtzd2l0Y2godCl7Y2FzZSBtLlg6cmV0dXJuIHRoaXMueDtjYXNlIG0uWTpyZXR1cm4gdGhpcy55O2Nhc2UgbS5aOnJldHVybiB0aGlzLmdldFooKX10aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfWVxdWFsczNEKHQpe3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueSYmKHRoaXMuZ2V0WigpPT09dC5nZXRaKCl8fHIuaXNOYU4odGhpcy5nZXRaKCkpJiZyLmlzTmFOKHQuZ2V0WigpKSl9ZXF1YWxzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgbSYmdGhpcy5lcXVhbHMyRCh0KX1lcXVhbEluWih0LG4pe3JldHVybiBlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy5nZXRaKCksdC5nZXRaKCksbil9c2V0WCh0KXt0aGlzLng9dH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLng8ZS54Py0xOnRoaXMueD5lLng/MTp0aGlzLnk8ZS55Py0xOnRoaXMueT5lLnk/MTowfWdldFgoKXtyZXR1cm4gdGhpcy54fXNldFoodCl7dGhpcy56PXR9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhpcyBjbGFzcyBpcyBDbG9uZWFibGVcIiksbnVsbDt0aHJvdyB0fX1jb3B5KCl7cmV0dXJuIG5ldyBtKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIsIFwiK3RoaXMuZ2V0WigpK1wiKVwifWRpc3RhbmNlM0QodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueSxzPXRoaXMuZ2V0WigpLXQuZ2V0WigpO3JldHVybiBNYXRoLnNxcnQoZSplK24qbitzKnMpfWdldFkoKXtyZXR1cm4gdGhpcy55fXNldFkodCl7dGhpcy55PXR9ZGlzdGFuY2UodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfWhhc2hDb2RlKCl7bGV0IHQ9MTc7cmV0dXJuIHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMueCksdD0zNyp0K20uaGFzaENvZGUodGhpcy55KSx0fXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxsLGNdfX1jbGFzcyBme2NvbnN0cnVjdG9yKCl7Zi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9kaW1lbnNpb25zVG9UZXN0PTIsMD09PWFyZ3VtZW50cy5sZW5ndGgpZi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDIpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDIhPT10JiYzIT09dCl0aHJvdyBuZXcgcyhcIm9ubHkgMiBvciAzIGRpbWVuc2lvbnMgbWF5IGJlIHNwZWNpZmllZFwiKTt0aGlzLl9kaW1lbnNpb25zVG9UZXN0PXR9fXN0YXRpYyBjb21wYXJlKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTpyLmlzTmFOKHQpP3IuaXNOYU4oZSk/MDotMTpyLmlzTmFOKGUpPzE6MH1jb21wYXJlKHQsZSl7Y29uc3Qgbj1mLmNvbXBhcmUodC54LGUueCk7aWYoMCE9PW4pcmV0dXJuIG47Y29uc3Qgcz1mLmNvbXBhcmUodC55LGUueSk7aWYoMCE9PXMpcmV0dXJuIHM7aWYodGhpcy5fZGltZW5zaW9uc1RvVGVzdDw9MilyZXR1cm4gMDtyZXR1cm4gZi5jb21wYXJlKHQuZ2V0WigpLGUuZ2V0WigpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fW0uRGltZW5zaW9uYWxDb21wYXJhdG9yPWYsbS5OVUxMX09SRElOQVRFPXIuTmFOLG0uWD0wLG0uWT0xLG0uWj0yLG0uTT0zO2NsYXNzIHkgZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx5LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW0uY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB5KXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxtLk5VTExfT1JESU5BVEUpfX1zZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaCh0KXtjYXNlIHkuWDp0aGlzLng9ZTticmVhaztjYXNlIHkuWTp0aGlzLnk9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fWdldFooKXtyZXR1cm4gbS5OVUxMX09SRElOQVRFfWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIHkuWDpyZXR1cm4gdGhpcy54O2Nhc2UgeS5ZOnJldHVybiB0aGlzLnl9dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1zZXRaKHQpe3Rocm93IG5ldyBzKFwiQ29vcmRpbmF0ZVhZIGRpbWVuc2lvbiAyIGRvZXMgbm90IHN1cHBvcnQgei1vcmRpbmF0ZVwiKX1jb3B5KCl7cmV0dXJuIG5ldyB5KHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIpXCJ9c2V0Q29vcmRpbmF0ZSh0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuZ2V0WigpfX15Llg9MCx5Llk9MSx5Llo9LTEseS5NPS0xO2NsYXNzIHggZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx4LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX209bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCltLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuX209MDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55KSx0aGlzLl9tPXQuX219ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55KSx0aGlzLl9tPXRoaXMuZ2V0TSgpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG0uTlVMTF9PUkRJTkFURSksdGhpcy5fbT1ufX1nZXRNKCl7cmV0dXJuIHRoaXMuX219c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSB4Llg6dGhpcy54PWU7YnJlYWs7Y2FzZSB4Llk6dGhpcy55PWU7YnJlYWs7Y2FzZSB4Lk06dGhpcy5fbT1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19c2V0TSh0KXt0aGlzLl9tPXR9Z2V0Wigpe3JldHVybiBtLk5VTExfT1JESU5BVEV9Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgeC5YOnJldHVybiB0aGlzLng7Y2FzZSB4Llk6cmV0dXJuIHRoaXMueTtjYXNlIHguTTpyZXR1cm4gdGhpcy5fbX10aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfXNldFoodCl7dGhyb3cgbmV3IHMoXCJDb29yZGluYXRlWFkgZGltZW5zaW9uIDIgZG9lcyBub3Qgc3VwcG9ydCB6LW9yZGluYXRlXCIpfWNvcHkoKXtyZXR1cm4gbmV3IHgodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiBtPVwiK3RoaXMuZ2V0TSgpK1wiKVwifXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKSx0aGlzLl9tPXQuZ2V0TSgpfX14Llg9MCx4Llk9MSx4Llo9LTEseC5NPTI7Y2xhc3MgRSBleHRlbmRzIG17Y29uc3RydWN0b3IoKXtzdXBlcigpLEUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKW0uY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5fbT0wO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuX209dC5fbX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuX209dGhpcy5nZXRNKCl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbiksdGhpcy5fbT1zfX1nZXRNKCl7cmV0dXJuIHRoaXMuX219c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSBtLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBtLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBtLlo6dGhpcy56PWU7YnJlYWs7Y2FzZSBtLk06dGhpcy5fbT1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19c2V0TSh0KXt0aGlzLl9tPXR9Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgbS5YOnJldHVybiB0aGlzLng7Y2FzZSBtLlk6cmV0dXJuIHRoaXMueTtjYXNlIG0uWjpyZXR1cm4gdGhpcy5nZXRaKCk7Y2FzZSBtLk06cmV0dXJuIHRoaXMuZ2V0TSgpfXRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9Y29weSgpe3JldHVybiBuZXcgRSh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLmdldFooKStcIiBtPVwiK3RoaXMuZ2V0TSgpK1wiKVwifXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKSx0aGlzLl9tPXQuZ2V0TSgpfX1mdW5jdGlvbiBJKHQsZSl7cmV0dXJuIHQuaW50ZXJmYWNlc18mJnQuaW50ZXJmYWNlc18uaW5kZXhPZihlKT4tMX1jbGFzcyBOe2FkZCgpe31hZGRBbGwoKXt9aXNFbXB0eSgpe31pdGVyYXRvcigpe31zaXplKCl7fXRvQXJyYXkoKXt9cmVtb3ZlKCl7fX1jbGFzcyB3IGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb246d30pWzBdfX1jbGFzcyBDIGV4dGVuZHMgTntnZXQoKXt9c2V0KCl7fWlzRW1wdHkoKXt9fWNsYXNzIFMgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7Tm9TdWNoRWxlbWVudEV4Y2VwdGlvbjpTfSlbMF19fWNsYXNzIEwgZXh0ZW5kcyBDe2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5hcnJheT1bXSx0IGluc3RhbmNlb2YgTiYmdGhpcy5hZGRBbGwodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0MsTl19ZW5zdXJlQ2FwYWNpdHkoKXt9YWRkKHQpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLmFycmF5LnB1c2godCk6dGhpcy5hcnJheS5zcGxpY2UoYXJndW1lbnRzWzBdLDAsYXJndW1lbnRzWzFdKSwhMH1jbGVhcigpe3RoaXMuYXJyYXk9W119YWRkQWxsKHQpe2Zvcihjb25zdCBlIG9mIHQpdGhpcy5hcnJheS5wdXNoKGUpfXNldCh0LGUpe2NvbnN0IG49dGhpcy5hcnJheVt0XTtyZXR1cm4gdGhpcy5hcnJheVt0XT1lLG59aXRlcmF0b3IoKXtyZXR1cm4gbmV3IFQodGhpcyl9Z2V0KHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IHc7cmV0dXJuIHRoaXMuYXJyYXlbdF19aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9c29ydCh0KXt0P3RoaXMuYXJyYXkuc29ydCgoKGUsbik9PnQuY29tcGFyZShlLG4pKSk6dGhpcy5hcnJheS5zb3J0KCl9c2l6ZSgpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aH10b0FycmF5KCl7cmV0dXJuIHRoaXMuYXJyYXkuc2xpY2UoKX1yZW1vdmUodCl7Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Lmxlbmd0aDtlPG47ZSsrKWlmKHRoaXMuYXJyYXlbZV09PT10KXJldHVybiEhdGhpcy5hcnJheS5zcGxpY2UoZSwxKTtyZXR1cm4hMX1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLmFycmF5LnZhbHVlcygpfX1sZXQgVD1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmFycmF5TGlzdD10LHRoaXMucG9zaXRpb249MH1uZXh0KCl7aWYodGhpcy5wb3NpdGlvbj09PXRoaXMuYXJyYXlMaXN0LnNpemUoKSl0aHJvdyBuZXcgUztyZXR1cm4gdGhpcy5hcnJheUxpc3QuZ2V0KHRoaXMucG9zaXRpb24rKyl9aGFzTmV4dCgpe3JldHVybiB0aGlzLnBvc2l0aW9uPHRoaXMuYXJyYXlMaXN0LnNpemUoKX1zZXQodCl7cmV0dXJuIHRoaXMuYXJyYXlMaXN0LnNldCh0aGlzLnBvc2l0aW9uLTEsdCl9cmVtb3ZlKCl7dGhpcy5hcnJheUxpc3QucmVtb3ZlKHRoaXMuYXJyYXlMaXN0LmdldCh0aGlzLnBvc2l0aW9uKSl9fTtjbGFzcyBSIGV4dGVuZHMgTHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCxlKX19Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5nZXQodCl9YWRkQWxsKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMV07bGV0IGU9ITE7Zm9yKGxldCBuPWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl0aGlzLmFkZChuLm5leHQoKSx0KSxlPSEwO3JldHVybiBlfXJldHVybiBzdXBlci5hZGRBbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfWNsb25lKCl7Y29uc3QgdD1zdXBlci5jbG9uZS5jYWxsKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5zaXplKCk7ZSsrKXQuYWRkKGUsdGhpcy5nZXQoZSkuY2xvbmUoKSk7cmV0dXJuIHR9dG9Db29yZGluYXRlQXJyYXkoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy50b0FycmF5KFIuY29vcmRBcnJheVR5cGUpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF0pcmV0dXJuIHRoaXMudG9BcnJheShSLmNvb3JkQXJyYXlUeXBlKTtjb25zdCB0PXRoaXMuc2l6ZSgpLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0O24rKyllW25dPXRoaXMuZ2V0KHQtbi0xKTtyZXR1cm4gZX19YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBzdXBlci5hZGQuY2FsbCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKHQsZSwhMCksITB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoIWFyZ3VtZW50c1sxXSYmdGhpcy5zaXplKCk+PTEpe2lmKHRoaXMuZ2V0KHRoaXMuc2l6ZSgpLTEpLmVxdWFsczJEKHQpKXJldHVybiBudWxsfXN1cGVyLmFkZC5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZCh0LGUpLCEwfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50c1syXSlmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl0aGlzLmFkZCh0W25dLGUpO2Vsc2UgZm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pdGhpcy5hZGQodFtuXSxlKTtyZXR1cm4hMH1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCFhcmd1bWVudHNbMl0pe2NvbnN0IG49dGhpcy5zaXplKCk7aWYobj4wKXtpZih0PjApe2lmKHRoaXMuZ2V0KHQtMSkuZXF1YWxzMkQoZSkpcmV0dXJuIG51bGx9aWYodDxuKXtpZih0aGlzLmdldCh0KS5lcXVhbHMyRChlKSlyZXR1cm4gbnVsbH19fXN1cGVyLmFkZC5jYWxsKHRoaXMsdCxlKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9MTtuPnMmJihpPS0xKTtmb3IobGV0IHI9bjtyIT09cztyKz1pKXRoaXMuYWRkKHRbcl0sZSk7cmV0dXJuITB9fWNsb3NlUmluZygpe2lmKHRoaXMuc2l6ZSgpPjApe2NvbnN0IHQ9dGhpcy5nZXQoMCkuY29weSgpO3RoaXMuYWRkKHQsITEpfX19Ui5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKTtjbGFzcyBQe2ZpbHRlcih0LGUpe31pc0RvbmUoKXt9aXNHZW9tZXRyeUNoYW5nZWQoKXt9fWNsYXNzIE97Y29uc3RydWN0b3IoKXtPLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX21pbng9bnVsbCx0aGlzLl9tYXh4PW51bGwsdGhpcy5fbWlueT1udWxsLHRoaXMuX21heHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LngsZS54LHQueSxlLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuaW5pdCh0LGUsbixzKX19c3RhdGljIGludGVyc2VjdHMoKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG4ueD49KHQueDxlLng/dC54OmUueCkmJm4ueDw9KHQueD5lLng/dC54OmUueCkmJm4ueT49KHQueTxlLnk/dC55OmUueSkmJm4ueTw9KHQueT5lLnk/dC55OmUueSl9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2xldCBpPU1hdGgubWluKG4ueCxzLngpLHI9TWF0aC5tYXgobi54LHMueCksbz1NYXRoLm1pbih0LngsZS54KSxsPU1hdGgubWF4KHQueCxlLngpO3JldHVybiEobz5yKSYmKCEobDxpKSYmKGk9TWF0aC5taW4obi55LHMueSkscj1NYXRoLm1heChuLnkscy55KSxvPU1hdGgubWluKHQueSxlLnkpLGw9TWF0aC5tYXgodC55LGUueSksIShvPnIpJiYhKGw8aSkpKX19Z2V0QXJlYSgpe3JldHVybiB0aGlzLmdldFdpZHRoKCkqdGhpcy5nZXRIZWlnaHQoKX1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgTykpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk6dGhpcy5fbWF4eD09PWUuZ2V0TWF4WCgpJiZ0aGlzLl9tYXh5PT09ZS5nZXRNYXhZKCkmJnRoaXMuX21pbng9PT1lLmdldE1pblgoKSYmdGhpcy5fbWlueT09PWUuZ2V0TWluWSgpfWludGVyc2VjdGlvbih0KXtpZih0aGlzLmlzTnVsbCgpfHx0LmlzTnVsbCgpfHwhdGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiBuZXcgTztjb25zdCBlPXRoaXMuX21pbng+dC5fbWlueD90aGlzLl9taW54OnQuX21pbngsbj10aGlzLl9taW55PnQuX21pbnk/dGhpcy5fbWlueTp0Ll9taW55LHM9dGhpcy5fbWF4eDx0Ll9tYXh4P3RoaXMuX21heHg6dC5fbWF4eCxpPXRoaXMuX21heHk8dC5fbWF4eT90aGlzLl9tYXh5OnQuX21heHk7cmV0dXJuIG5ldyBPKGUscyxuLGkpfWlzTnVsbCgpe3JldHVybiB0aGlzLl9tYXh4PHRoaXMuX21pbnh9Z2V0TWF4WCgpe3JldHVybiB0aGlzLl9tYXh4fWNvdmVycygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0LngsdC55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhdC5pc051bGwoKSYmKHQuZ2V0TWluWCgpPj10aGlzLl9taW54JiZ0LmdldE1heFgoKTw9dGhpcy5fbWF4eCYmdC5nZXRNaW5ZKCk+PXRoaXMuX21pbnkmJnQuZ2V0TWF4WSgpPD10aGlzLl9tYXh5KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJih0Pj10aGlzLl9taW54JiZ0PD10aGlzLl9tYXh4JiZlPj10aGlzLl9taW55JiZlPD10aGlzLl9tYXh5KX19aW50ZXJzZWN0cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhdC5pc051bGwoKSYmISh0Ll9taW54PnRoaXMuX21heHh8fHQuX21heHg8dGhpcy5fbWlueHx8dC5fbWlueT50aGlzLl9tYXh5fHx0Ll9tYXh5PHRoaXMuX21pbnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyh0LngsdC55KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuITE7aWYoKHQueDxlLng/dC54OmUueCk+dGhpcy5fbWF4eClyZXR1cm4hMTtpZigodC54PmUueD90Lng6ZS54KTx0aGlzLl9taW54KXJldHVybiExO2lmKCh0Lnk8ZS55P3QueTplLnkpPnRoaXMuX21heHkpcmV0dXJuITE7cmV0dXJuISgodC55PmUueT90Lnk6ZS55KTx0aGlzLl9taW55KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmISh0PnRoaXMuX21heHh8fHQ8dGhpcy5fbWlueHx8ZT50aGlzLl9tYXh5fHxlPHRoaXMuX21pbnkpfX19Z2V0TWluWSgpe3JldHVybiB0aGlzLl9taW55fWdldERpYW1ldGVyKCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIE1hdGguc3FydCh0KnQrZSplKX1nZXRNaW5YKCl7cmV0dXJuIHRoaXMuX21pbnh9ZXhwYW5kVG9JbmNsdWRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRUb0luY2x1ZGUodC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5pc051bGwoKT8odGhpcy5fbWlueD10LmdldE1pblgoKSx0aGlzLl9tYXh4PXQuZ2V0TWF4WCgpLHRoaXMuX21pbnk9dC5nZXRNaW5ZKCksdGhpcy5fbWF4eT10LmdldE1heFkoKSk6KHQuX21pbng8dGhpcy5fbWlueCYmKHRoaXMuX21pbng9dC5fbWlueCksdC5fbWF4eD50aGlzLl9tYXh4JiYodGhpcy5fbWF4eD10Ll9tYXh4KSx0Ll9taW55PHRoaXMuX21pbnkmJih0aGlzLl9taW55PXQuX21pbnkpLHQuX21heHk+dGhpcy5fbWF4eSYmKHRoaXMuX21heHk9dC5fbWF4eSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmlzTnVsbCgpPyh0aGlzLl9taW54PXQsdGhpcy5fbWF4eD10LHRoaXMuX21pbnk9ZSx0aGlzLl9tYXh5PWUpOih0PHRoaXMuX21pbngmJih0aGlzLl9taW54PXQpLHQ+dGhpcy5fbWF4eCYmKHRoaXMuX21heHg9dCksZTx0aGlzLl9taW55JiYodGhpcy5fbWlueT1lKSxlPnRoaXMuX21heHkmJih0aGlzLl9tYXh5PWUpKX19bWluRXh0ZW50KCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ8ZT90OmV9Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMuX21heHgtdGhpcy5fbWlueH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk/MDotMTplLmlzTnVsbCgpPzE6dGhpcy5fbWlueDxlLl9taW54Py0xOnRoaXMuX21pbng+ZS5fbWlueD8xOnRoaXMuX21pbnk8ZS5fbWlueT8tMTp0aGlzLl9taW55PmUuX21pbnk/MTp0aGlzLl9tYXh4PGUuX21heHg/LTE6dGhpcy5fbWF4eD5lLl9tYXh4PzE6dGhpcy5fbWF4eTxlLl9tYXh5Py0xOnRoaXMuX21heHk+ZS5fbWF4eT8xOjB9dHJhbnNsYXRlKHQsZSl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmluaXQodGhpcy5nZXRNaW5YKCkrdCx0aGlzLmdldE1heFgoKSt0LHRoaXMuZ2V0TWluWSgpK2UsdGhpcy5nZXRNYXhZKCkrZSl9Y29weSgpe3JldHVybiBuZXcgTyh0aGlzKX10b1N0cmluZygpe3JldHVyblwiRW52W1wiK3RoaXMuX21pbngrXCIgOiBcIit0aGlzLl9tYXh4K1wiLCBcIit0aGlzLl9taW55K1wiIDogXCIrdGhpcy5fbWF4eStcIl1cIn1zZXRUb051bGwoKXt0aGlzLl9taW54PTAsdGhpcy5fbWF4eD0tMSx0aGlzLl9taW55PTAsdGhpcy5fbWF4eT0tMX1kaXNqb2ludCh0KXtyZXR1cm4hKCF0aGlzLmlzTnVsbCgpJiYhdC5pc051bGwoKSl8fCh0Ll9taW54PnRoaXMuX21heHh8fHQuX21heHg8dGhpcy5fbWlueHx8dC5fbWlueT50aGlzLl9tYXh5fHx0Ll9tYXh5PHRoaXMuX21pbnkpfWdldEhlaWdodCgpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5fbWF4eS10aGlzLl9taW55fW1heEV4dGVudCgpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiB0PmU/dDplfWV4cGFuZEJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kQnkodCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuX21pbngtPXQsdGhpcy5fbWF4eCs9dCx0aGlzLl9taW55LT1lLHRoaXMuX21heHkrPWUsKHRoaXMuX21pbng+dGhpcy5fbWF4eHx8dGhpcy5fbWlueT50aGlzLl9tYXh5KSYmdGhpcy5zZXRUb051bGwoKX19Y29udGFpbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvdmVycyh0LGUpfX1jZW50cmUoKXtyZXR1cm4gdGhpcy5pc051bGwoKT9udWxsOm5ldyBtKCh0aGlzLmdldE1pblgoKSt0aGlzLmdldE1heFgoKSkvMiwodGhpcy5nZXRNaW5ZKCkrdGhpcy5nZXRNYXhZKCkpLzIpfWluaXQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvTnVsbCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21pbng9dC5fbWlueCx0aGlzLl9tYXh4PXQuX21heHgsdGhpcy5fbWlueT10Ll9taW55LHRoaXMuX21heHk9dC5fbWF4eX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQueCxlLngsdC55LGUueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dDxlPyh0aGlzLl9taW54PXQsdGhpcy5fbWF4eD1lKToodGhpcy5fbWlueD1lLHRoaXMuX21heHg9dCksbjxzPyh0aGlzLl9taW55PW4sdGhpcy5fbWF4eT1zKToodGhpcy5fbWlueT1zLHRoaXMuX21heHk9bil9fWdldE1heFkoKXtyZXR1cm4gdGhpcy5fbWF4eX1kaXN0YW5jZSh0KXtpZih0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIDA7bGV0IGU9MDt0aGlzLl9tYXh4PHQuX21pbng/ZT10Ll9taW54LXRoaXMuX21heHg6dGhpcy5fbWlueD50Ll9tYXh4JiYoZT10aGlzLl9taW54LXQuX21heHgpO2xldCBuPTA7cmV0dXJuIHRoaXMuX21heHk8dC5fbWlueT9uPXQuX21pbnktdGhpcy5fbWF4eTp0aGlzLl9taW55PnQuX21heHkmJihuPXRoaXMuX21pbnktdC5fbWF4eSksMD09PWU/bjowPT09bj9lOk1hdGguc3FydChlKmUrbipuKX1oYXNoQ29kZSgpe2xldCB0PTE3O3JldHVybiB0PTM3KnQrbS5oYXNoQ29kZSh0aGlzLl9taW54KSx0PTM3KnQrbS5oYXNoQ29kZSh0aGlzLl9tYXh4KSx0PTM3KnQrbS5oYXNoQ29kZSh0aGlzLl9taW55KSx0PTM3KnQrbS5oYXNoQ29kZSh0aGlzLl9tYXh5KSx0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvLGNdfX1jbGFzcyB2e2NvbnN0cnVjdG9yKHQpe3RoaXMuc3RyPXR9YXBwZW5kKHQpe3RoaXMuc3RyKz10fXNldENoYXJBdCh0LGUpe3RoaXMuc3RyPXRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5zdHJ9fWNsYXNzIGJ7Y29uc3RydWN0b3IodCl7dGhpcy52YWx1ZT10fWludFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9Y29tcGFyZVRvKHQpe3JldHVybiB0aGlzLnZhbHVlPHQ/LTE6dGhpcy52YWx1ZT50PzE6MH1zdGF0aWMgY29tcGFyZSh0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6MH1zdGF0aWMgaXNOYW4odCl7cmV0dXJuIE51bWJlci5pc05hTih0KX1zdGF0aWMgdmFsdWVPZih0KXtyZXR1cm4gbmV3IGIodCl9fWNsYXNzIE17c3RhdGljIGlzV2hpdGVzcGFjZSh0KXtyZXR1cm4gdDw9MzImJnQ+PTB8fDEyNz09PXR9c3RhdGljIHRvVXBwZXJDYXNlKHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9fWNsYXNzIEQgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7SWxsZWdhbFN0YXRlRXhjZXB0aW9uOkR9KVswXX19Y2xhc3MgQXtjb25zdHJ1Y3Rvcigpe0EuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5faGk9MCx0aGlzLl9sbz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0EuY29uc3RydWN0b3JfLmNhbGwodGhpcyxBLnBhcnNlKHQpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQsZSl9fXN0YXRpYyBkZXRlcm1pbmFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbM10mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiBBLmRldGVybWluYW50KEEudmFsdWVPZih0KSxBLnZhbHVlT2YoZSksQS52YWx1ZU9mKG4pLEEudmFsdWVPZihzKSl9aWYoYXJndW1lbnRzWzNdaW5zdGFuY2VvZiBBJiZhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEEmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXTtyZXR1cm4gYXJndW1lbnRzWzBdLm11bHRpcGx5KG4pLnNlbGZTdWJ0cmFjdCh0Lm11bHRpcGx5KGUpKX19c3RhdGljIHNxcih0KXtyZXR1cm4gQS52YWx1ZU9mKHQpLnNlbGZNdWx0aXBseSh0KX1zdGF0aWMgdmFsdWVPZigpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBBLnBhcnNlKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3JldHVybiBuZXcgQShhcmd1bWVudHNbMF0pfX1zdGF0aWMgc3FydCh0KXtyZXR1cm4gQS52YWx1ZU9mKHQpLnNxcnQoKX1zdGF0aWMgcGFyc2UodCl7bGV0IGU9MDtjb25zdCBuPXQubGVuZ3RoO2Zvcig7TS5pc1doaXRlc3BhY2UodC5jaGFyQXQoZSkpOyllKys7bGV0IHM9ITE7aWYoZTxuKXtjb25zdCBuPXQuY2hhckF0KGUpO1wiLVwiIT09biYmXCIrXCIhPT1ufHwoZSsrLFwiLVwiPT09biYmKHM9ITApKX1jb25zdCBpPW5ldyBBO2xldCByPTAsbz0wLGw9MCxhPSExO2Zvcig7IShlPj1uKTspe2NvbnN0IG49dC5jaGFyQXQoZSk7aWYoZSsrLE0uaXNEaWdpdChuKSl7Y29uc3QgdD1uLVwiMFwiO2kuc2VsZk11bHRpcGx5KEEuVEVOKSxpLnNlbGZBZGQodCkscisrfWVsc2V7aWYoXCIuXCIhPT1uKXtpZihcImVcIj09PW58fFwiRVwiPT09bil7Y29uc3Qgbj10LnN1YnN0cmluZyhlKTt0cnl7bD1iLnBhcnNlSW50KG4pfWNhdGNoKGUpe3Rocm93IGUgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb24/bmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIkludmFsaWQgZXhwb25lbnQgXCIrbitcIiBpbiBzdHJpbmcgXCIrdCk6ZX1icmVha310aHJvdyBuZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK24rXCInIGF0IHBvc2l0aW9uIFwiK2UrXCIgaW4gc3RyaW5nIFwiK3QpfW89cixhPSEwfX1sZXQgYz1pO2F8fChvPXIpO2NvbnN0IGg9ci1vLWw7aWYoMD09PWgpYz1pO2Vsc2UgaWYoaD4wKXtjb25zdCB0PUEuVEVOLnBvdyhoKTtjPWkuZGl2aWRlKHQpfWVsc2UgaWYoaDwwKXtjb25zdCB0PUEuVEVOLnBvdygtaCk7Yz1pLm11bHRpcGx5KHQpfXJldHVybiBzP2MubmVnYXRlKCk6Y31zdGF0aWMgY3JlYXRlTmFOKCl7cmV0dXJuIG5ldyBBKHIuTmFOLHIuTmFOKX1zdGF0aWMgY29weSh0KXtyZXR1cm4gbmV3IEEodCl9c3RhdGljIG1hZ25pdHVkZSh0KXtjb25zdCBlPU1hdGguYWJzKHQpLG49TWF0aC5sb2coZSkvTWF0aC5sb2coMTApO2xldCBzPU1hdGgudHJ1bmMoTWF0aC5mbG9vcihuKSk7cmV0dXJuIDEwKk1hdGgucG93KDEwLHMpPD1lJiYocys9MSksc31zdGF0aWMgc3RyaW5nT2ZDaGFyKHQsZSl7Y29uc3Qgbj1uZXcgdjtmb3IobGV0IHM9MDtzPGU7cysrKW4uYXBwZW5kKHQpO3JldHVybiBuLnRvU3RyaW5nKCl9bGUodCl7cmV0dXJuIHRoaXMuX2hpPHQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbzw9dC5fbG99ZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHQsZSl7bGV0IG49dGhpcy5hYnMoKSxzPUEubWFnbml0dWRlKG4uX2hpKTtjb25zdCBpPUEuVEVOLnBvdyhzKTtuPW4uZGl2aWRlKGkpLG4uZ3QoQS5URU4pPyhuPW4uZGl2aWRlKEEuVEVOKSxzKz0xKTpuLmx0KEEuT05FKSYmKG49bi5tdWx0aXBseShBLlRFTikscy09MSk7Y29uc3Qgcj1zKzEsbz1uZXcgdixsPUEuTUFYX1BSSU5UX0RJR0lUUy0xO2ZvcihsZXQgZT0wO2U8PWw7ZSsrKXt0JiZlPT09ciYmby5hcHBlbmQoXCIuXCIpO2NvbnN0IHM9TWF0aC50cnVuYyhuLl9oaSk7aWYoczwwKWJyZWFrO2xldCBpPSExLGE9MDtzPjk/KGk9ITAsYT1cIjlcIik6YT1cIjBcIitzLG8uYXBwZW5kKGEpLG49bi5zdWJ0cmFjdChBLnZhbHVlT2YocykpLm11bHRpcGx5KEEuVEVOKSxpJiZuLnNlbGZBZGQoQS5URU4pO2xldCBjPSEwO2NvbnN0IGg9QS5tYWduaXR1ZGUobi5faGkpO2lmKGg8MCYmTWF0aC5hYnMoaCk+PWwtZSYmKGM9ITEpLCFjKWJyZWFrfXJldHVybiBlWzBdPXMsby50b1N0cmluZygpfXNxcigpe3JldHVybiB0aGlzLm11bHRpcGx5KHRoaXMpfWRvdWJsZVZhbHVlKCl7cmV0dXJuIHRoaXMuX2hpK3RoaXMuX2xvfXN1YnRyYWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQodC5uZWdhdGUoKSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKC10KX19ZXF1YWxzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPT09dC5fbG99fWlzWmVybygpe3JldHVybiAwPT09dGhpcy5faGkmJjA9PT10aGlzLl9sb31zZWxmU3VidHJhY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQuX2hpLC10Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtdCwwKX19Z2V0U3BlY2lhbE51bWJlclN0cmluZygpe3JldHVybiB0aGlzLmlzWmVybygpP1wiMC4wXCI6dGhpcy5pc05hTigpP1wiTmFOIFwiOm51bGx9bWluKHQpe3JldHVybiB0aGlzLmxlKHQpP3RoaXM6dH1zZWxmRGl2aWRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0LDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsLGM9bnVsbDtyZXR1cm4gbz10aGlzLl9oaS90LGw9QS5TUExJVCpvLG49bC1vLGM9QS5TUExJVCp0LG49bC1uLHM9by1uLGk9Yy10LGE9byp0LGk9Yy1pLHI9dC1pLGM9bippLWErbipyK3MqaStzKnIsbD0odGhpcy5faGktYS1jK3RoaXMuX2xvLW8qZSkvdCxjPW8rbCx0aGlzLl9oaT1jLHRoaXMuX2xvPW8tYytsLHRoaXN9fWR1bXAoKXtyZXR1cm5cIkREPFwiK3RoaXMuX2hpK1wiLCBcIit0aGlzLl9sbytcIj5cIn1kaXZpZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsO3I9dGhpcy5faGkvdC5faGksbz1BLlNQTElUKnIsZT1vLXIsYT1BLlNQTElUKnQuX2hpLGU9by1lLG49ci1lLHM9YS10Ll9oaSxsPXIqdC5faGkscz1hLXMsaT10Ll9oaS1zLGE9ZSpzLWwrZSppK24qcytuKmksbz0odGhpcy5faGktbC1hK3RoaXMuX2xvLXIqdC5fbG8pL3QuX2hpLGE9citvO3JldHVybiBuZXcgQShhLHItYStvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTih0KT9BLmNyZWF0ZU5hTigpOkEuY29weSh0aGlzKS5zZWxmRGl2aWRlKHQsMCl9fWdlKHQpe3JldHVybiB0aGlzLl9oaT50Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG8+PXQuX2xvfXBvdyh0KXtpZigwPT09dClyZXR1cm4gQS52YWx1ZU9mKDEpO2xldCBlPW5ldyBBKHRoaXMpLG49QS52YWx1ZU9mKDEpLHM9TWF0aC5hYnModCk7aWYocz4xKWZvcig7cz4wOylzJTI9PTEmJm4uc2VsZk11bHRpcGx5KGUpLHMvPTIscz4wJiYoZT1lLnNxcigpKTtlbHNlIG49ZTtyZXR1cm4gdDwwP24ucmVjaXByb2NhbCgpOm59Y2VpbCgpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gQS5OYU47Y29uc3QgdD1NYXRoLmNlaWwodGhpcy5faGkpO2xldCBlPTA7cmV0dXJuIHQ9PT10aGlzLl9oaSYmKGU9TWF0aC5jZWlsKHRoaXMuX2xvKSksbmV3IEEodCxlKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9oaTxlLl9oaT8tMTp0aGlzLl9oaT5lLl9oaT8xOnRoaXMuX2xvPGUuX2xvPy0xOnRoaXMuX2xvPmUuX2xvPzE6MH1yaW50KCl7aWYodGhpcy5pc05hTigpKXJldHVybiB0aGlzO3JldHVybiB0aGlzLmFkZCguNSkuZmxvb3IoKX1zZXRWYWx1ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc319bWF4KHQpe3JldHVybiB0aGlzLmdlKHQpP3RoaXM6dH1zcXJ0KCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gQS52YWx1ZU9mKDApO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBBLk5hTjtjb25zdCB0PTEvTWF0aC5zcXJ0KHRoaXMuX2hpKSxlPXRoaXMuX2hpKnQsbj1BLnZhbHVlT2YoZSkscz10aGlzLnN1YnRyYWN0KG4uc3FyKCkpLl9oaSooLjUqdCk7cmV0dXJuIG4uYWRkKHMpfXNlbGZBZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmQWRkKHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGw7cmV0dXJuIHM9dGhpcy5faGkrdCxyPXMtdGhpcy5faGksaT1zLXIsaT10LXIrKHRoaXMuX2hpLWkpLG89aSt0aGlzLl9sbyxlPXMrbyxuPW8rKHMtZSksdGhpcy5faGk9ZStuLHRoaXMuX2xvPW4rKGUtdGhpcy5faGkpLHRoaXN9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGwsYz1udWxsO289dGhpcy5faGkrdCxpPXRoaXMuX2xvK2UsYT1vLXRoaXMuX2hpLGM9aS10aGlzLl9sbyxsPW8tYSxyPWktYyxsPXQtYSsodGhpcy5faGktbCkscj1lLWMrKHRoaXMuX2xvLXIpLGE9bCtpLG49bythLHM9YSsoby1uKSxhPXIrcztjb25zdCBoPW4rYSx1PWErKG4taCk7cmV0dXJuIHRoaXMuX2hpPWgsdGhpcy5fbG89dSx0aGlzfX1zZWxmTXVsdGlwbHkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0LDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGw7bz1BLlNQTElUKnRoaXMuX2hpLG49by10aGlzLl9oaSxsPUEuU1BMSVQqdCxuPW8tbixzPXRoaXMuX2hpLW4saT1sLXQsbz10aGlzLl9oaSp0LGk9bC1pLHI9dC1pLGw9bippLW8rbipyK3MqaStzKnIrKHRoaXMuX2hpKmUrdGhpcy5fbG8qdCk7Y29uc3QgYT1vK2w7bj1vLWE7Y29uc3QgYz1sK247cmV0dXJuIHRoaXMuX2hpPWEsdGhpcy5fbG89Yyx0aGlzfX1zZWxmU3FyKCl7cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHRoaXMpfWZsb29yKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBBLk5hTjtjb25zdCB0PU1hdGguZmxvb3IodGhpcy5faGkpO2xldCBlPTA7cmV0dXJuIHQ9PT10aGlzLl9oaSYmKGU9TWF0aC5mbG9vcih0aGlzLl9sbykpLG5ldyBBKHQsZSl9bmVnYXRlKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOm5ldyBBKC10aGlzLl9oaSwtdGhpcy5fbG8pfWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gbnVsbDt0aHJvdyB0fX1tdWx0aXBseSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuaXNOYU4oKT9BLmNyZWF0ZU5hTigpOkEuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4odCk/QS5jcmVhdGVOYU4oKTpBLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHQsMCl9fWlzTmFOKCl7cmV0dXJuIHIuaXNOYU4odGhpcy5faGkpfWludFZhbHVlKCl7cmV0dXJuIE1hdGgudHJ1bmModGhpcy5faGkpfXRvU3RyaW5nKCl7Y29uc3QgdD1BLm1hZ25pdHVkZSh0aGlzLl9oaSk7cmV0dXJuIHQ+PS0zJiZ0PD0yMD90aGlzLnRvU3RhbmRhcmROb3RhdGlvbigpOnRoaXMudG9TY2lOb3RhdGlvbigpfXRvU3RhbmRhcmROb3RhdGlvbigpe2NvbnN0IHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCEwLGUpLHM9ZVswXSsxO2xldCBpPW47aWYoXCIuXCI9PT1uLmNoYXJBdCgwKSlpPVwiMFwiK247ZWxzZSBpZihzPDApaT1cIjAuXCIrQS5zdHJpbmdPZkNoYXIoXCIwXCIsLXMpK247ZWxzZSBpZigtMT09PW4uaW5kZXhPZihcIi5cIikpe2NvbnN0IHQ9cy1uLmxlbmd0aDtpPW4rQS5zdHJpbmdPZkNoYXIoXCIwXCIsdCkrXCIuMFwifXJldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIitpOml9cmVjaXByb2NhbCgpe2xldCB0PW51bGwsZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsO2k9MS90aGlzLl9oaSxyPUEuU1BMSVQqaSx0PXItaSxsPUEuU1BMSVQqdGhpcy5faGksdD1yLXQsZT1pLXQsbj1sLXRoaXMuX2hpLG89aSp0aGlzLl9oaSxuPWwtbixzPXRoaXMuX2hpLW4sbD10Km4tbyt0KnMrZSpuK2UqcyxyPSgxLW8tbC1pKnRoaXMuX2xvKS90aGlzLl9oaTtjb25zdCBhPWkrcjtyZXR1cm4gbmV3IEEoYSxpLWErcil9dG9TY2lOb3RhdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIEEuU0NJX05PVF9aRVJPO2NvbnN0IHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCExLGUpLHM9QS5TQ0lfTk9UX0VYUE9ORU5UX0NIQVIrZVswXTtpZihcIjBcIj09PW4uY2hhckF0KDApKXRocm93IG5ldyBEKFwiRm91bmQgbGVhZGluZyB6ZXJvOiBcIituKTtsZXQgaT1cIlwiO24ubGVuZ3RoPjEmJihpPW4uc3Vic3RyaW5nKDEpKTtjb25zdCByPW4uY2hhckF0KDApK1wiLlwiK2k7cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK3IrczpyK3N9YWJzKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9BLk5hTjp0aGlzLmlzTmVnYXRpdmUoKT90aGlzLm5lZ2F0ZSgpOm5ldyBBKHRoaXMpfWlzUG9zaXRpdmUoKXtyZXR1cm4gdGhpcy5faGk+MHx8MD09PXRoaXMuX2hpJiZ0aGlzLl9sbz4wfWx0KHQpe3JldHVybiB0aGlzLl9oaTx0Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG88dC5fbG99YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gQS5jb3B5KHRoaXMpLnNlbGZBZGQodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEEuY29weSh0aGlzKS5zZWxmQWRkKHQpfX1pbml0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2hpPXQsdGhpcy5fbG89MH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faGk9dC5faGksdGhpcy5fbG89dC5fbG99fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2hpPXQsdGhpcy5fbG89ZX19Z3QodCl7cmV0dXJuIHRoaXMuX2hpPnQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz50Ll9sb31pc05lZ2F0aXZlKCl7cmV0dXJuIHRoaXMuX2hpPDB8fDA9PT10aGlzLl9oaSYmdGhpcy5fbG88MH10cnVuYygpe3JldHVybiB0aGlzLmlzTmFOKCk/QS5OYU46dGhpcy5pc1Bvc2l0aXZlKCk/dGhpcy5mbG9vcigpOnRoaXMuY2VpbCgpfXNpZ251bSgpe3JldHVybiB0aGlzLl9oaT4wPzE6dGhpcy5faGk8MD8tMTp0aGlzLl9sbz4wPzE6dGhpcy5fbG88MD8tMTowfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjLG8sbF19fUEuUEk9bmV3IEEoMy4xNDE1OTI2NTM1ODk3OTMsMTIyNDY0Njc5OTE0NzM1MzJlLTMyKSxBLlRXT19QST1uZXcgQSg2LjI4MzE4NTMwNzE3OTU4NiwyNDQ5MjkzNTk4Mjk0NzA2NGUtMzIpLEEuUElfMj1uZXcgQSgxLjU3MDc5NjMyNjc5NDg5NjYsNjEyMzIzMzk5NTczNjc2NmUtMzIpLEEuRT1uZXcgQSgyLjcxODI4MTgyODQ1OTA0NSwxNDQ1NjQ2ODkxNzI5MjUwMmUtMzIpLEEuTmFOPW5ldyBBKHIuTmFOLHIuTmFOKSxBLkVQUz0xMjMyNTk1MTY0NDA3ODNlLTQ2LEEuU1BMSVQ9MTM0MjE3NzI5LEEuTUFYX1BSSU5UX0RJR0lUUz0zMixBLlRFTj1BLnZhbHVlT2YoMTApLEEuT05FPUEudmFsdWVPZigxKSxBLlNDSV9OT1RfRVhQT05FTlRfQ0hBUj1cIkVcIixBLlNDSV9OT1RfWkVSTz1cIjAuMEUwXCI7Y2xhc3MgRntzdGF0aWMgb3JpZW50YXRpb25JbmRleCh0LGUsbil7Y29uc3Qgcz1GLm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pO2lmKHM8PTEpcmV0dXJuIHM7Y29uc3QgaT1BLnZhbHVlT2YoZS54KS5zZWxmQWRkKC10LngpLHI9QS52YWx1ZU9mKGUueSkuc2VsZkFkZCgtdC55KSxvPUEudmFsdWVPZihuLngpLnNlbGZBZGQoLWUueCksbD1BLnZhbHVlT2Yobi55KS5zZWxmQWRkKC1lLnkpO3JldHVybiBpLnNlbGZNdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoci5zZWxmTXVsdGlwbHkobykpLnNpZ251bSgpfXN0YXRpYyBzaWduT2ZEZXQyeDIoKXtpZihhcmd1bWVudHNbM11pbnN0YW5jZW9mIEEmJmFyZ3VtZW50c1syXWluc3RhbmNlb2YgQSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdO3JldHVybiBhcmd1bWVudHNbMF0ubXVsdGlwbHkobikuc2VsZlN1YnRyYWN0KHQubXVsdGlwbHkoZSkpLnNpZ251bSgpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbM10mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9QS52YWx1ZU9mKHQpLHI9QS52YWx1ZU9mKGUpLG89QS52YWx1ZU9mKG4pLGw9QS52YWx1ZU9mKHMpO3JldHVybiBpLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChyLm11bHRpcGx5KG8pKS5zaWdudW0oKX19c3RhdGljIGludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPW5ldyBBKHQueSkuc2VsZlN1YnRyYWN0KGUueSksbz1uZXcgQShlLngpLnNlbGZTdWJ0cmFjdCh0LngpLGw9bmV3IEEodC54KS5zZWxmTXVsdGlwbHkoZS55KS5zZWxmU3VidHJhY3QobmV3IEEoZS54KS5zZWxmTXVsdGlwbHkodC55KSksYT1uZXcgQShuLnkpLnNlbGZTdWJ0cmFjdChzLnkpLGM9bmV3IEEocy54KS5zZWxmU3VidHJhY3Qobi54KSxoPW5ldyBBKG4ueCkuc2VsZk11bHRpcGx5KHMueSkuc2VsZlN1YnRyYWN0KG5ldyBBKHMueCkuc2VsZk11bHRpcGx5KG4ueSkpLHU9by5tdWx0aXBseShoKS5zZWxmU3VidHJhY3QoYy5tdWx0aXBseShsKSksZz1hLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChpLm11bHRpcGx5KGgpKSxkPWkubXVsdGlwbHkoYykuc2VsZlN1YnRyYWN0KGEubXVsdGlwbHkobykpLF89dS5zZWxmRGl2aWRlKGQpLmRvdWJsZVZhbHVlKCkscD1nLnNlbGZEaXZpZGUoZCkuZG91YmxlVmFsdWUoKTtyZXR1cm4gci5pc05hTihfKXx8ci5pc0luZmluaXRlKF8pfHxyLmlzTmFOKHApfHxyLmlzSW5maW5pdGUocCk/bnVsbDpuZXcgbShfLHApfXN0YXRpYyBvcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKXtsZXQgcz1udWxsO2NvbnN0IGk9KHQueC1uLngpKihlLnktbi55KSxyPSh0Lnktbi55KSooZS54LW4ueCksbz1pLXI7aWYoaT4wKXtpZihyPD0wKXJldHVybiBGLnNpZ251bShvKTtzPWkrcn1lbHNle2lmKCEoaTwwKSlyZXR1cm4gRi5zaWdudW0obyk7aWYocj49MClyZXR1cm4gRi5zaWdudW0obyk7cz0taS1yfWNvbnN0IGw9Ri5EUF9TQUZFX0VQU0lMT04qcztyZXR1cm4gbz49bHx8LW8+PWw/Ri5zaWdudW0obyk6Mn1zdGF0aWMgc2lnbnVtKHQpe3JldHVybiB0PjA/MTp0PDA/LTE6MH19Ri5EUF9TQUZFX0VQU0lMT049MWUtMTU7Y2xhc3MgR3tnZXRNKHQpe2lmKHRoaXMuaGFzTSgpKXtjb25zdCBlPXRoaXMuZ2V0RGltZW5zaW9uKCktdGhpcy5nZXRNZWFzdXJlcygpO3JldHVybiB0aGlzLmdldE9yZGluYXRlKHQsZSl9cmV0dXJuIHIuTmFOfXNldE9yZGluYXRlKHQsZSxuKXt9Z2V0Wih0KXtyZXR1cm4gdGhpcy5oYXNaKCk/dGhpcy5nZXRPcmRpbmF0ZSh0LDIpOnIuTmFOfXNpemUoKXt9Z2V0T3JkaW5hdGUodCxlKXt9Z2V0Q29vcmRpbmF0ZSgpe31nZXRDb29yZGluYXRlQ29weSh0KXt9Y3JlYXRlQ29vcmRpbmF0ZSgpe31nZXREaW1lbnNpb24oKXt9aGFzTSgpe3JldHVybiB0aGlzLmdldE1lYXN1cmVzKCk+MH1nZXRYKHQpe31oYXNaKCl7cmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9uKCktdGhpcy5nZXRNZWFzdXJlcygpPjJ9Z2V0TWVhc3VyZXMoKXtyZXR1cm4gMH1leHBhbmRFbnZlbG9wZSh0KXt9Y29weSgpe31nZXRZKHQpe310b0Nvb3JkaW5hdGVBcnJheSgpe31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fUcuWD0wLEcuWT0xLEcuWj0yLEcuTT0zO2NsYXNzIHF7c3RhdGljIGluZGV4KHQsZSxuKXtyZXR1cm4gRi5vcmllbnRhdGlvbkluZGV4KHQsZSxuKX1zdGF0aWMgaXNDQ1coKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQubGVuZ3RoLTE7aWYoZTwzKXRocm93IG5ldyBzKFwiUmluZyBoYXMgZmV3ZXIgdGhhbiA0IHBvaW50cywgc28gb3JpZW50YXRpb24gY2Fubm90IGJlIGRldGVybWluZWRcIik7bGV0IG49dFswXSxpPTA7Zm9yKGxldCBzPTE7czw9ZTtzKyspe2NvbnN0IGU9dFtzXTtlLnk+bi55JiYobj1lLGk9cyl9bGV0IHI9aTtkb3tyLT0xLHI8MCYmKHI9ZSl9d2hpbGUodFtyXS5lcXVhbHMyRChuKSYmciE9PWkpO2xldCBvPWk7ZG97bz0obysxKSVlfXdoaWxlKHRbb10uZXF1YWxzMkQobikmJm8hPT1pKTtjb25zdCBsPXRbcl0sYT10W29dO2lmKGwuZXF1YWxzMkQobil8fGEuZXF1YWxzMkQobil8fGwuZXF1YWxzMkQoYSkpcmV0dXJuITE7Y29uc3QgYz1xLmluZGV4KGwsbixhKTtsZXQgaD1udWxsO3JldHVybiBoPTA9PT1jP2wueD5hLng6Yz4wLGh9aWYoSShhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCktMTtpZihlPDMpdGhyb3cgbmV3IHMoXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtsZXQgbj10LmdldENvb3JkaW5hdGUoMCksaT0wO2ZvcihsZXQgcz0xO3M8PWU7cysrKXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZShzKTtlLnk+bi55JiYobj1lLGk9cyl9bGV0IHI9bnVsbCxvPWk7ZG97by09MSxvPDAmJihvPWUpLHI9dC5nZXRDb29yZGluYXRlKG8pfXdoaWxlKHIuZXF1YWxzMkQobikmJm8hPT1pKTtsZXQgbD1udWxsLGE9aTtkb3thPShhKzEpJWUsbD10LmdldENvb3JkaW5hdGUoYSl9d2hpbGUobC5lcXVhbHMyRChuKSYmYSE9PWkpO2lmKHIuZXF1YWxzMkQobil8fGwuZXF1YWxzMkQobil8fHIuZXF1YWxzMkQobCkpcmV0dXJuITE7Y29uc3QgYz1xLmluZGV4KHIsbixsKTtsZXQgaD1udWxsO3JldHVybiBoPTA9PT1jP3IueD5sLng6Yz4wLGh9fX1xLkNMT0NLV0lTRT0tMSxxLlJJR0hUPXEuQ0xPQ0tXSVNFLHEuQ09VTlRFUkNMT0NLV0lTRT0xLHEuTEVGVD1xLkNPVU5URVJDTE9DS1dJU0UscS5DT0xMSU5FQVI9MCxxLlNUUkFJR0hUPXEuQ09MTElORUFSO2NsYXNzIEJ7c3RhdGljIGludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPXQueDxlLng/dC54OmUueCxvPXQueTxlLnk/dC55OmUueSxsPXQueD5lLng/dC54OmUueCxhPXQueT5lLnk/dC55OmUueSxjPW4ueDxzLng/bi54OnMueCxoPW4ueTxzLnk/bi55OnMueSx1PW4ueD5zLng/bi54OnMueCxnPW4ueT5zLnk/bi55OnMueSxkPSgoaT5jP2k6YykrKGw8dT9sOnUpKS8yLF89KChvPmg/bzpoKSsoYTxnP2E6ZykpLzIscD10LngtZCxmPXQueS1fLHk9ZS54LWQseD1lLnktXyxFPW4ueC1kLEk9bi55LV8sTj1zLngtZCx3PXMueS1fLEM9Zi14LFM9eS1wLEw9cCp4LXkqZixUPUktdyxSPU4tRSxQPUUqdy1OKkksTz1DKlItVCpTLHY9KFMqUC1SKkwpL08sYj0oVCpMLUMqUCkvTztyZXR1cm4gci5pc05hTih2KXx8ci5pc0luZmluaXRlKHYpfHxyLmlzTmFOKGIpfHxyLmlzSW5maW5pdGUoYik/bnVsbDpuZXcgbSh2K2QsYitfKX19Y2xhc3MgWXtzdGF0aWMgYXJyYXljb3B5KHQsZSxuLHMsaSl7bGV0IHI9MDtmb3IobGV0IG89ZTtvPGUraTtvKyspbltzK3JdPXRbb10scisrfXN0YXRpYyBnZXRQcm9wZXJ0eSh0KXtyZXR1cm57XCJsaW5lLnNlcGFyYXRvclwiOlwiXFxuXCJ9W3RdfX1jbGFzcyBWe3N0YXRpYyBsb2cxMCh0KXtjb25zdCBlPU1hdGgubG9nKHQpO3JldHVybiByLmlzSW5maW5pdGUoZSl8fHIuaXNOYU4oZSk/ZTplL1YuTE9HXzEwfXN0YXRpYyBtaW4odCxlLG4scyl7bGV0IGk9dDtyZXR1cm4gZTxpJiYoaT1lKSxuPGkmJihpPW4pLHM8aSYmKGk9cyksaX1zdGF0aWMgY2xhbXAoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdDxlP2U6dD5uP246dH1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdDxlP2U6dD5uP246dH19c3RhdGljIHdyYXAodCxlKXtyZXR1cm4gdDwwP2UtIC10JWU6dCVlfXN0YXRpYyBtYXgoKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl07bGV0IG49YXJndW1lbnRzWzBdO3JldHVybiB0Pm4mJihuPXQpLGU+biYmKG49ZSksbn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM107bGV0IHM9YXJndW1lbnRzWzBdO3JldHVybiB0PnMmJihzPXQpLGU+cyYmKHM9ZSksbj5zJiYocz1uKSxzfX1zdGF0aWMgYXZlcmFnZSh0LGUpe3JldHVybih0K2UpLzJ9fVYuTE9HXzEwPU1hdGgubG9nKDEwKTtjbGFzcyB6e3N0YXRpYyBzZWdtZW50VG9TZWdtZW50KHQsZSxuLHMpe2lmKHQuZXF1YWxzKGUpKXJldHVybiB6LnBvaW50VG9TZWdtZW50KHQsbixzKTtpZihuLmVxdWFscyhzKSlyZXR1cm4gei5wb2ludFRvU2VnbWVudChzLHQsZSk7bGV0IGk9ITE7aWYoTy5pbnRlcnNlY3RzKHQsZSxuLHMpKXtjb25zdCByPShlLngtdC54KSoocy55LW4ueSktKGUueS10LnkpKihzLngtbi54KTtpZigwPT09cilpPSEwO2Vsc2V7Y29uc3Qgbz0odC55LW4ueSkqKHMueC1uLngpLSh0Lngtbi54KSoocy55LW4ueSksbD0oKHQueS1uLnkpKihlLngtdC54KS0odC54LW4ueCkqKGUueS10LnkpKS9yLGE9by9yOyhhPDB8fGE+MXx8bDwwfHxsPjEpJiYoaT0hMCl9fWVsc2UgaT0hMDtyZXR1cm4gaT9WLm1pbih6LnBvaW50VG9TZWdtZW50KHQsbixzKSx6LnBvaW50VG9TZWdtZW50KGUsbixzKSx6LnBvaW50VG9TZWdtZW50KG4sdCxlKSx6LnBvaW50VG9TZWdtZW50KHMsdCxlKSk6MH1zdGF0aWMgcG9pbnRUb1NlZ21lbnQodCxlLG4pe2lmKGUueD09PW4ueCYmZS55PT09bi55KXJldHVybiB0LmRpc3RhbmNlKGUpO2NvbnN0IHM9KG4ueC1lLngpKihuLngtZS54KSsobi55LWUueSkqKG4ueS1lLnkpLGk9KCh0LngtZS54KSoobi54LWUueCkrKHQueS1lLnkpKihuLnktZS55KSkvcztpZihpPD0wKXJldHVybiB0LmRpc3RhbmNlKGUpO2lmKGk+PTEpcmV0dXJuIHQuZGlzdGFuY2Uobik7Y29uc3Qgcj0oKGUueS10LnkpKihuLngtZS54KS0oZS54LXQueCkqKG4ueS1lLnkpKS9zO3JldHVybiBNYXRoLmFicyhyKSpNYXRoLnNxcnQocyl9c3RhdGljIHBvaW50VG9MaW5lUGVycGVuZGljdWxhcih0LGUsbil7Y29uc3Qgcz0obi54LWUueCkqKG4ueC1lLngpKyhuLnktZS55KSoobi55LWUueSksaT0oKGUueS10LnkpKihuLngtZS54KS0oZS54LXQueCkqKG4ueS1lLnkpKS9zO3JldHVybiBNYXRoLmFicyhpKSpNYXRoLnNxcnQocyl9c3RhdGljIHBvaW50VG9TZWdtZW50U3RyaW5nKHQsZSl7aWYoMD09PWUubGVuZ3RoKXRocm93IG5ldyBzKFwiTGluZSBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHZlcnRleFwiKTtsZXQgbj10LmRpc3RhbmNlKGVbMF0pO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGgtMTtzKyspe2NvbnN0IGk9ei5wb2ludFRvU2VnbWVudCh0LGVbc10sZVtzKzFdKTtpPG4mJihuPWkpfXJldHVybiBufX1jbGFzcyBYe2NyZWF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXl8fEkoYXJndW1lbnRzWzBdLEcpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNyZWF0ZSh0LGUpfX19Y2xhc3Mga3tmaWx0ZXIodCl7fX1jbGFzcyBVe2NvbnN0cnVjdG9yKCl7VS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzR2VvbWV0cnlDb2xsZWN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VHlwZUNvZGUoKT09PVUuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OfWdldEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeX1nZXRHZW9tZXRyeU4odCl7cmV0dXJuIHRoaXN9Z2V0QXJlYSgpe3JldHVybiAwfWlzUmVjdGFuZ2xlKCl7cmV0dXJuITF9ZXF1YWxzRXhhY3QodCl7cmV0dXJuIHRoaXM9PT10fHx0aGlzLmVxdWFsc0V4YWN0KHQsMCl9Z2VvbWV0cnlDaGFuZ2VkKCl7dGhpcy5hcHBseShVLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcil9Z2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl7dGhpcy5fZW52ZWxvcGU9bnVsbH1lcXVhbHNOb3JtKHQpe3JldHVybiBudWxsIT09dCYmdGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QodC5ub3JtKCkpfWdldExlbmd0aCgpe3JldHVybiAwfWdldE51bUdlb21ldHJpZXMoKXtyZXR1cm4gMX1jb21wYXJlVG8oKXtsZXQgdDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT1hcmd1bWVudHNbMF07cmV0dXJuIHQ9ZSx0aGlzLmdldFR5cGVDb2RlKCkhPT10LmdldFR5cGVDb2RlKCk/dGhpcy5nZXRUeXBlQ29kZSgpLXQuZ2V0VHlwZUNvZGUoKTp0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTp0LmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKGUpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdD1lLHRoaXMuZ2V0VHlwZUNvZGUoKSE9PXQuZ2V0VHlwZUNvZGUoKT90aGlzLmdldFR5cGVDb2RlKCktdC5nZXRUeXBlQ29kZSgpOnRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOnQuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MoZSxuKX19Z2V0VXNlckRhdGEoKXtyZXR1cm4gdGhpcy5fdXNlckRhdGF9Z2V0U1JJRCgpe3JldHVybiB0aGlzLl9TUklEfWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkpfXN0YXRpYyBjaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KXtpZih0LmdldFR5cGVDb2RlKCk9PT1VLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTil0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKX1lcXVhbCh0LGUsbil7cmV0dXJuIDA9PT1uP3QuZXF1YWxzKGUpOnQuZGlzdGFuY2UoZSk8PW59bm9ybSgpe2NvbnN0IHQ9dGhpcy5jb3B5KCk7cmV0dXJuIHQubm9ybWFsaXplKCksdH1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLnJldmVyc2VJbnRlcm5hbCgpO3JldHVybiBudWxsIT10aGlzLmVudmVsb3BlJiYodC5lbnZlbG9wZT10aGlzLmVudmVsb3BlLmNvcHkoKSksdC5zZXRTUklEKHRoaXMuZ2V0U1JJRCgpKSx0fWNvcHkoKXtjb25zdCB0PXRoaXMuY29weUludGVybmFsKCk7cmV0dXJuIHQuZW52ZWxvcGU9bnVsbD09dGhpcy5fZW52ZWxvcGU/bnVsbDp0aGlzLl9lbnZlbG9wZS5jb3B5KCksdC5fU1JJRD10aGlzLl9TUklELHQuX3VzZXJEYXRhPXRoaXMuX3VzZXJEYXRhLHR9Z2V0UHJlY2lzaW9uTW9kZWwoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfWdldEVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2VudmVsb3BlJiYodGhpcy5fZW52ZWxvcGU9dGhpcy5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpKSxuZXcgTyh0aGlzLl9lbnZlbG9wZSl9c2V0U1JJRCh0KXt0aGlzLl9TUklEPXR9c2V0VXNlckRhdGEodCl7dGhpcy5fdXNlckRhdGE9dH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10Lml0ZXJhdG9yKCkscz1lLml0ZXJhdG9yKCk7Zm9yKDtuLmhhc05leHQoKSYmcy5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLGU9cy5uZXh0KCksaT10LmNvbXBhcmVUbyhlKTtpZigwIT09aSlyZXR1cm4gaX1yZXR1cm4gbi5oYXNOZXh0KCk/MTpzLmhhc05leHQoKT8tMTowfWhhc2hDb2RlKCl7cmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmhhc2hDb2RlKCl9aXNFcXVpdmFsZW50Q2xhc3ModCl7cmV0dXJuIHRoaXMuZ2V0VHlwZUNvZGUoKT09dC5nZXRUeXBlQ29kZSgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsLG8sY119Z2V0Q2xhc3MoKXtyZXR1cm4gVX1zdGF0aWMgaGFzTm9uRW1wdHlFbGVtZW50cyh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZighdFtlXS5pc0VtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIGhhc051bGxFbGVtZW50cyh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZihudWxsPT09dFtlXSlyZXR1cm4hMDtyZXR1cm4hMX19VS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24odCl7dCYmKHRoaXMuX2VudmVsb3BlPW51bGwsdGhpcy5fdXNlckRhdGE9bnVsbCx0aGlzLl9mYWN0b3J5PXQsdGhpcy5fU1JJRD10LmdldFNSSUQoKSl9LFUuVFlQRUNPREVfUE9JTlQ9MCxVLlRZUEVDT0RFX01VTFRJUE9JTlQ9MSxVLlRZUEVDT0RFX0xJTkVTVFJJTkc9MixVLlRZUEVDT0RFX0xJTkVBUlJJTkc9MyxVLlRZUEVDT0RFX01VTFRJTElORVNUUklORz00LFUuVFlQRUNPREVfUE9MWUdPTj01LFUuVFlQRUNPREVfTVVMVElQT0xZR09OPTYsVS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT049NyxVLlRZUEVOQU1FX1BPSU5UPVwiUG9pbnRcIixVLlRZUEVOQU1FX01VTFRJUE9JTlQ9XCJNdWx0aVBvaW50XCIsVS5UWVBFTkFNRV9MSU5FU1RSSU5HPVwiTGluZVN0cmluZ1wiLFUuVFlQRU5BTUVfTElORUFSUklORz1cIkxpbmVhclJpbmdcIixVLlRZUEVOQU1FX01VTFRJTElORVNUUklORz1cIk11bHRpTGluZVN0cmluZ1wiLFUuVFlQRU5BTUVfUE9MWUdPTj1cIlBvbHlnb25cIixVLlRZUEVOQU1FX01VTFRJUE9MWUdPTj1cIk11bHRpUG9seWdvblwiLFUuVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OPVwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsVS5nZW9tZXRyeUNoYW5nZWRGaWx0ZXI9e2dldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX0sZmlsdGVyKHQpe3QuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl9fTtjbGFzcyBIe2ZpbHRlcih0KXt9fWNsYXNzIFd7c3RhdGljIG9mTGluZSh0KXtjb25zdCBlPXQuc2l6ZSgpO2lmKGU8PTEpcmV0dXJuIDA7bGV0IG49MDtjb25zdCBzPW5ldyBtO3QuZ2V0Q29vcmRpbmF0ZSgwLHMpO2xldCBpPXMueCxyPXMueTtmb3IobGV0IG89MTtvPGU7bysrKXt0LmdldENvb3JkaW5hdGUobyxzKTtjb25zdCBlPXMueCxsPXMueSxhPWUtaSxjPWwtcjtuKz1NYXRoLnNxcnQoYSphK2MqYyksaT1lLHI9bH1yZXR1cm4gbn19Y2xhc3MgWnt9Y2xhc3MgantzdGF0aWMgY29weUNvb3JkKHQsZSxuLHMpe2NvbnN0IGk9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxuLmdldERpbWVuc2lvbigpKTtmb3IobGV0IHI9MDtyPGk7cisrKW4uc2V0T3JkaW5hdGUocyxyLHQuZ2V0T3JkaW5hdGUoZSxyKSl9c3RhdGljIGlzUmluZyh0KXtjb25zdCBlPXQuc2l6ZSgpO3JldHVybiAwPT09ZXx8IShlPD0zKSYmKHQuZ2V0T3JkaW5hdGUoMCxHLlgpPT09dC5nZXRPcmRpbmF0ZShlLTEsRy5YKSYmdC5nZXRPcmRpbmF0ZSgwLEcuWSk9PT10LmdldE9yZGluYXRlKGUtMSxHLlkpKX1zdGF0aWMgc2Nyb2xsKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLEcpJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2ouc2Nyb2xsKHQsZSxqLmlzUmluZyh0KSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxHKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWouaW5kZXhPZihlLHQpO2lmKG48PTApcmV0dXJuIG51bGw7ai5zY3JvbGwodCxuKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZTw9MClyZXR1cm4gbnVsbDtjb25zdCBzPXQuY29weSgpLGk9bj90LnNpemUoKS0xOnQuc2l6ZSgpO2ZvcihsZXQgbj0wO248aTtuKyspZm9yKGxldCByPTA7cjx0LmdldERpbWVuc2lvbigpO3IrKyl0LnNldE9yZGluYXRlKG4scixzLmdldE9yZGluYXRlKChlK24pJWkscikpO2lmKG4pZm9yKGxldCBlPTA7ZTx0LmdldERpbWVuc2lvbigpO2UrKyl0LnNldE9yZGluYXRlKGksZSx0LmdldE9yZGluYXRlKDAsZSkpfX1zdGF0aWMgaXNFcXVhbCh0LGUpe2NvbnN0IG49dC5zaXplKCk7aWYobiE9PWUuc2l6ZSgpKXJldHVybiExO2NvbnN0IHM9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgbj0wO248cztuKyspe2NvbnN0IHM9dC5nZXRPcmRpbmF0ZShpLG4pLG89ZS5nZXRPcmRpbmF0ZShpLG4pO2lmKHQuZ2V0T3JkaW5hdGUoaSxuKSE9PWUuZ2V0T3JkaW5hdGUoaSxuKSYmKCFyLmlzTmFOKHMpfHwhci5pc05hTihvKSkpcmV0dXJuITF9cmV0dXJuITB9c3RhdGljIG1pbkNvb3JkaW5hdGVJbmRleCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gai5taW5Db29yZGluYXRlSW5kZXgodCwwLHQuc2l6ZSgpLTEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXTtsZXQgbj0tMSxzPW51bGw7Zm9yKGxldCBpPWFyZ3VtZW50c1sxXTtpPD1lO2krKyl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoaSk7KG51bGw9PT1zfHxzLmNvbXBhcmVUbyhlKT4wKSYmKHM9ZSxuPWkpfXJldHVybiBufX1zdGF0aWMgZXh0ZW5kKHQsZSxuKXtjb25zdCBzPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSksaT1lLnNpemUoKTtpZihqLmNvcHkoZSwwLHMsMCxpKSxpPjApZm9yKGxldCB0PWk7dDxuO3QrKylqLmNvcHkoZSxpLTEscyx0LDEpO3JldHVybiBzfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5zaXplKCktMSxuPU1hdGgudHJ1bmMoZS8yKTtmb3IobGV0IHM9MDtzPD1uO3MrKylqLnN3YXAodCxzLGUtcyl9c3RhdGljIHN3YXAodCxlLG4pe2lmKGU9PT1uKXJldHVybiBudWxsO2ZvcihsZXQgcz0wO3M8dC5nZXREaW1lbnNpb24oKTtzKyspe2NvbnN0IGk9dC5nZXRPcmRpbmF0ZShlLHMpO3Quc2V0T3JkaW5hdGUoZSxzLHQuZ2V0T3JkaW5hdGUobixzKSksdC5zZXRPcmRpbmF0ZShuLHMsaSl9fXN0YXRpYyBjb3B5KHQsZSxuLHMsaSl7Zm9yKGxldCByPTA7cjxpO3IrKylqLmNvcHlDb29yZCh0LGUrcixuLHMrcil9c3RhdGljIGVuc3VyZVZhbGlkUmluZyh0LGUpe2NvbnN0IG49ZS5zaXplKCk7aWYoMD09PW4pcmV0dXJuIGU7aWYobjw9MylyZXR1cm4gai5jcmVhdGVDbG9zZWRSaW5nKHQsZSw0KTtyZXR1cm4gZS5nZXRPcmRpbmF0ZSgwLEcuWCk9PT1lLmdldE9yZGluYXRlKG4tMSxHLlgpJiZlLmdldE9yZGluYXRlKDAsRy5ZKT09PWUuZ2V0T3JkaW5hdGUobi0xLEcuWSk/ZTpqLmNyZWF0ZUNsb3NlZFJpbmcodCxlLG4rMSl9c3RhdGljIGluZGV4T2YodCxlKXtmb3IobGV0IG49MDtuPGUuc2l6ZSgpO24rKylpZih0Lng9PT1lLmdldE9yZGluYXRlKG4sRy5YKSYmdC55PT09ZS5nZXRPcmRpbmF0ZShuLEcuWSkpcmV0dXJuIG47cmV0dXJuLTF9c3RhdGljIGNyZWF0ZUNsb3NlZFJpbmcodCxlLG4pe2NvbnN0IHM9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxpPWUuc2l6ZSgpO2ouY29weShlLDAscywwLGkpO2ZvcihsZXQgdD1pO3Q8bjt0Kyspai5jb3B5KGUsMCxzLHQsMSk7cmV0dXJuIHN9c3RhdGljIG1pbkNvb3JkaW5hdGUodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10LmdldENvb3JkaW5hdGUobik7KG51bGw9PT1lfHxlLmNvbXBhcmVUbyhzKT4wKSYmKGU9cyl9cmV0dXJuIGV9fWNsYXNzIEsgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7VW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb246S30pWzBdfX1jbGFzcyBRe3N0YXRpYyB0b0RpbWVuc2lvblN5bWJvbCh0KXtzd2l0Y2godCl7Y2FzZSBRLkZBTFNFOnJldHVybiBRLlNZTV9GQUxTRTtjYXNlIFEuVFJVRTpyZXR1cm4gUS5TWU1fVFJVRTtjYXNlIFEuRE9OVENBUkU6cmV0dXJuIFEuU1lNX0RPTlRDQVJFO2Nhc2UgUS5QOnJldHVybiBRLlNZTV9QO2Nhc2UgUS5MOnJldHVybiBRLlNZTV9MO2Nhc2UgUS5BOnJldHVybiBRLlNZTV9BfXRocm93IG5ldyBzKFwiVW5rbm93biBkaW1lbnNpb24gdmFsdWU6IFwiK3QpfXN0YXRpYyB0b0RpbWVuc2lvblZhbHVlKHQpe3N3aXRjaChNLnRvVXBwZXJDYXNlKHQpKXtjYXNlIFEuU1lNX0ZBTFNFOnJldHVybiBRLkZBTFNFO2Nhc2UgUS5TWU1fVFJVRTpyZXR1cm4gUS5UUlVFO2Nhc2UgUS5TWU1fRE9OVENBUkU6cmV0dXJuIFEuRE9OVENBUkU7Y2FzZSBRLlNZTV9QOnJldHVybiBRLlA7Y2FzZSBRLlNZTV9MOnJldHVybiBRLkw7Y2FzZSBRLlNZTV9BOnJldHVybiBRLkF9dGhyb3cgbmV3IHMoXCJVbmtub3duIGRpbWVuc2lvbiBzeW1ib2w6IFwiK3QpfX1RLlA9MCxRLkw9MSxRLkE9MixRLkZBTFNFPS0xLFEuVFJVRT0tMixRLkRPTlRDQVJFPS0zLFEuU1lNX0ZBTFNFPVwiRlwiLFEuU1lNX1RSVUU9XCJUXCIsUS5TWU1fRE9OVENBUkU9XCIqXCIsUS5TWU1fUD1cIjBcIixRLlNZTV9MPVwiMVwiLFEuU1lNX0E9XCIyXCI7Y2xhc3MgSntmaWx0ZXIodCl7fX1jbGFzcyAkIGV4dGVuZHMgVXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksJC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wb2ludHM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07VS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX19Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bmV3IE86dGhpcy5fcG9pbnRzLmV4cGFuZEVudmVsb3BlKG5ldyBPKX1pc1JpbmcoKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpJiZ0aGlzLmlzU2ltcGxlKCl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KCl9Y29weUludGVybmFsKCl7cmV0dXJuIG5ldyAkKHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQ7aWYodGhpcy5fcG9pbnRzLnNpemUoKSE9PW4uX3BvaW50cy5zaXplKCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9wb2ludHMuc2l6ZSgpO3QrKylpZighdGhpcy5lcXVhbCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxuLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8TWF0aC50cnVuYyh0aGlzLl9wb2ludHMuc2l6ZSgpLzIpO3QrKyl7Y29uc3QgZT10aGlzLl9wb2ludHMuc2l6ZSgpLTEtdDtpZighdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuZXF1YWxzKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKSl7aWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuY29tcGFyZVRvKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKT4wKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7ai5yZXZlcnNlKHQpLHRoaXMuX3BvaW50cz10fXJldHVybiBudWxsfX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKDApfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9RLkZBTFNFOjB9aXNDbG9zZWQoKXtyZXR1cm4hdGhpcy5pc0VtcHR5KCkmJnRoaXMuZ2V0Q29vcmRpbmF0ZU4oMCkuZXF1YWxzMkQodGhpcy5nZXRDb29yZGluYXRlTih0aGlzLmdldE51bVBvaW50cygpLTEpKX1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7cmV0dXJuIGoucmV2ZXJzZSh0KSx0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQpfWdldEVuZFBvaW50KCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4odGhpcy5nZXROdW1Qb2ludHMoKS0xKX1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX0xJTkVTVFJJTkd9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0TGVuZ3RoKCl7cmV0dXJuIFcub2ZMaW5lKHRoaXMuX3BvaW50cyl9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMuX3BvaW50cy5zaXplKCl9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPTAsbj0wO2Zvcig7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpJiZuPHQuX3BvaW50cy5zaXplKCk7KXtjb25zdCBzPXRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpLmNvbXBhcmVUbyh0Ll9wb2ludHMuZ2V0Q29vcmRpbmF0ZShuKSk7aWYoMCE9PXMpcmV0dXJuIHM7ZSsrLG4rK31yZXR1cm4gZTx0aGlzLl9wb2ludHMuc2l6ZSgpPzE6bjx0Ll9wb2ludHMuc2l6ZSgpPy0xOjB9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBhcmd1bWVudHNbMV0uY29tcGFyZSh0aGlzLl9wb2ludHMsdC5fcG9pbnRzKX19YXBwbHkoKXtpZihJKGFyZ3VtZW50c1swXSxIKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpO2UrKyl0LmZpbHRlcih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxQKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuX3BvaW50cy5zaXplKCkpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpJiYodC5maWx0ZXIodGhpcy5fcG9pbnRzLGUpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEopKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9fWdldEJvdW5kYXJ5KCl7dGhyb3cgbmV3IEt9aXNFcXVpdmFsZW50Q2xhc3ModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiAkfWdldENvb3JkaW5hdGVOKHQpe3JldHVybiB0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9MSU5FU1RSSU5HfWdldENvb3JkaW5hdGVTZXF1ZW5jZSgpe3JldHVybiB0aGlzLl9wb2ludHN9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fcG9pbnRzLnNpemUoKX1pbml0KHQpe2lmKG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksMT09PXQuc2l6ZSgpKXRocm93IG5ldyBzKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVTdHJpbmcgKGZvdW5kIFwiK3Quc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDIpXCIpO3RoaXMuX3BvaW50cz10fWlzQ29vcmRpbmF0ZSh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCk7ZSsrKWlmKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpLmVxdWFscyh0KSlyZXR1cm4hMDtyZXR1cm4hMX1nZXRTdGFydFBvaW50KCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4oMCl9Z2V0UG9pbnROKHQpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1pdfX1jbGFzcyB0dHt9Y2xhc3MgZXQgZXh0ZW5kcyBVe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxldC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZGluYXRlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1UuY29uc3RydWN0b3JfLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbmV3IE87Y29uc3QgdD1uZXcgTztyZXR1cm4gdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29vcmRpbmF0ZXMuZ2V0WCgwKSx0aGlzLl9jb29yZGluYXRlcy5nZXRZKDApKSx0fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP1tdOlt0aGlzLmdldENvb3JkaW5hdGUoKV19Y29weUludGVybmFsKCl7cmV0dXJuIG5ldyBldCh0aGlzLl9jb29yZGluYXRlcy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJighKCF0aGlzLmlzRW1wdHkoKXx8IXQuaXNFbXB0eSgpKXx8dGhpcy5pc0VtcHR5KCk9PT10LmlzRW1wdHkoKSYmdGhpcy5lcXVhbCh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmdldENvb3JkaW5hdGUoKSxlKSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXt9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiAwIT09dGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpP3RoaXMuX2Nvb3JkaW5hdGVzLmdldENvb3JkaW5hdGUoMCk6bnVsbH1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiBRLkZBTFNFfXJldmVyc2VJbnRlcm5hbCgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jb29yZGluYXRlcy5jb3B5KCkpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfUE9JTlR9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDB9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6MX1nZXRYKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBEKFwiZ2V0WCBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnh9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odC5nZXRDb29yZGluYXRlKCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzFdLmNvbXBhcmUodGhpcy5fY29vcmRpbmF0ZXMsdC5fY29vcmRpbmF0ZXMpfX1hcHBseSgpe2lmKEkoYXJndW1lbnRzWzBdLEgpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0LmZpbHRlcih0aGlzLmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxQKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5fY29vcmRpbmF0ZXMsMCksdC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sSikpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxrKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX19Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfUE9JTlR9Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfWdldFkoKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IEQoXCJnZXRZIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9jb29yZGluYXRlcy5zaXplKCl9aW5pdCh0KXtudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLGcuaXNUcnVlKHQuc2l6ZSgpPD0xKSx0aGlzLl9jb29yZGluYXRlcz10fWlzU2ltcGxlKCl7cmV0dXJuITB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3R0XX19Y2xhc3MgbnR7c3RhdGljIG9mUmluZygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmFicyhudC5vZlJpbmdTaWduZWQodCkpfWlmKEkoYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hYnMobnQub2ZSaW5nU2lnbmVkKHQpKX19c3RhdGljIG9mUmluZ1NpZ25lZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQubGVuZ3RoPDMpcmV0dXJuIDA7bGV0IGU9MDtjb25zdCBuPXRbMF0ueDtmb3IobGV0IHM9MTtzPHQubGVuZ3RoLTE7cysrKXtjb25zdCBpPXRbc10ueC1uLHI9dFtzKzFdLnk7ZSs9aSoodFtzLTFdLnktcil9cmV0dXJuIGUvMn1pZihJKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKTtpZihlPDMpcmV0dXJuIDA7Y29uc3Qgbj1uZXcgbSxzPW5ldyBtLGk9bmV3IG07dC5nZXRDb29yZGluYXRlKDAscyksdC5nZXRDb29yZGluYXRlKDEsaSk7Y29uc3Qgcj1zLng7aS54LT1yO2xldCBvPTA7Zm9yKGxldCBsPTE7bDxlLTE7bCsrKW4ueT1zLnkscy54PWkueCxzLnk9aS55LHQuZ2V0Q29vcmRpbmF0ZShsKzEsaSksaS54LT1yLG8rPXMueCoobi55LWkueSk7cmV0dXJuIG8vMn19fWNsYXNzIHN0e3N0YXRpYyBzb3J0KCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpdC5zb3J0KCgodCxlKT0+dC5jb21wYXJlVG8oZSkpKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXQuc29ydCgoKHQsZSk9PmFyZ3VtZW50c1sxXS5jb21wYXJlKHQsZSkpKTtlbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPXQuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSk7ZS5zb3J0KCk7Y29uc3Qgbj10LnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSx0LnNsaWNlKGFyZ3VtZW50c1syXSx0Lmxlbmd0aCkpO3Quc3BsaWNlKDAsdC5sZW5ndGgpO2Zvcihjb25zdCBlIG9mIG4pdC5wdXNoKGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9dC5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKTtlLnNvcnQoKCh0LGUpPT5hcmd1bWVudHNbM10uY29tcGFyZSh0LGUpKSk7Y29uc3Qgbj10LnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSx0LnNsaWNlKGFyZ3VtZW50c1syXSx0Lmxlbmd0aCkpO3Quc3BsaWNlKDAsdC5sZW5ndGgpO2Zvcihjb25zdCBlIG9mIG4pdC5wdXNoKGUpfX1zdGF0aWMgYXNMaXN0KHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGNvbnN0IG4gb2YgdCllLmFkZChuKTtyZXR1cm4gZX1zdGF0aWMgY29weU9mKHQsZSl7cmV0dXJuIHQuc2xpY2UoMCxlKX19Y2xhc3MgaXR7fWNsYXNzIHJ0IGV4dGVuZHMgVXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkscnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9ob2xlcz1udWxsO2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihVLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbiksbnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoKSksbnVsbD09PWUmJihlPVtdKSxVLmhhc051bGxFbGVtZW50cyhlKSl0aHJvdyBuZXcgcyhcImhvbGVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTtpZih0LmlzRW1wdHkoKSYmVS5oYXNOb25FbXB0eUVsZW1lbnRzKGUpKXRocm93IG5ldyBzKFwic2hlbGwgaXMgZW1wdHkgYnV0IGhvbGVzIGFyZSBub3RcIik7dGhpcy5fc2hlbGw9dCx0aGlzLl9ob2xlcz1lfWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIHRoaXMuX3NoZWxsLmdldEVudmVsb3BlSW50ZXJuYWwoKX1nZXRDb29yZGluYXRlcygpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybltdO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7bGV0IGU9LTE7Y29uc3Qgbj10aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgcz0wO3M8bi5sZW5ndGg7cysrKWUrKyx0W2VdPW5bc107Zm9yKGxldCBuPTA7bjx0aGlzLl9ob2xlcy5sZW5ndGg7bisrKXtjb25zdCBzPXRoaXMuX2hvbGVzW25dLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxzLmxlbmd0aDtuKyspZSsrLHRbZV09c1tuXX1yZXR1cm4gdH1nZXRBcmVhKCl7bGV0IHQ9MDt0Kz1udC5vZlJpbmcodGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0LT1udC5vZlJpbmcodGhpcy5faG9sZXNbZV0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0fWNvcHlJbnRlcm5hbCgpe2NvbnN0IHQ9dGhpcy5fc2hlbGwuY29weSgpLGU9bmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspZVt0XT10aGlzLl9ob2xlc1t0XS5jb3B5KCk7cmV0dXJuIG5ldyBydCh0LGUsdGhpcy5fZmFjdG9yeSl9aXNSZWN0YW5nbGUoKXtpZigwIT09dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSlyZXR1cm4hMTtpZihudWxsPT09dGhpcy5fc2hlbGwpcmV0dXJuITE7aWYoNSE9PXRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpKXJldHVybiExO2NvbnN0IHQ9dGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksZT10aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKTtmb3IobGV0IG49MDtuPDU7bisrKXtjb25zdCBzPXQuZ2V0WChuKTtpZihzIT09ZS5nZXRNaW5YKCkmJnMhPT1lLmdldE1heFgoKSlyZXR1cm4hMTtjb25zdCBpPXQuZ2V0WShuKTtpZihpIT09ZS5nZXRNaW5ZKCkmJmkhPT1lLmdldE1heFkoKSlyZXR1cm4hMX1sZXQgbj10LmdldFgoMCkscz10LmdldFkoMCk7Zm9yKGxldCBlPTE7ZTw9NDtlKyspe2NvbnN0IGk9dC5nZXRYKGUpLHI9dC5nZXRZKGUpO2lmKGkhPT1uPT09KHIhPT1zKSlyZXR1cm4hMTtuPWkscz1yfXJldHVybiEwfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10LHM9dGhpcy5fc2hlbGwsaT1uLl9zaGVsbDtpZighcy5lcXVhbHNFeGFjdChpLGUpKXJldHVybiExO2lmKHRoaXMuX2hvbGVzLmxlbmd0aCE9PW4uX2hvbGVzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2hvbGVzW3RdLmVxdWFsc0V4YWN0KG4uX2hvbGVzW3RdLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMuX3NoZWxsPXRoaXMubm9ybWFsaXplZCh0aGlzLl9zaGVsbCwhMCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKXRoaXMuX2hvbGVzW3RdPXRoaXMubm9ybWFsaXplZCh0aGlzLl9ob2xlc1t0XSwhMSk7c3Quc29ydCh0aGlzLl9ob2xlcyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHM9ai5taW5Db29yZGluYXRlSW5kZXgobiwwLG4uc2l6ZSgpLTIpO2ouc2Nyb2xsKG4scywhMCkscS5pc0NDVyhuKT09PWUmJmoucmV2ZXJzZShuKX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlKCl9Z2V0TnVtSW50ZXJpb3JSaW5nKCl7cmV0dXJuIHRoaXMuX2hvbGVzLmxlbmd0aH1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiAxfXJldmVyc2VJbnRlcm5hbCgpe2NvbnN0IHQ9dGhpcy5nZXRFeHRlcmlvclJpbmcoKS5yZXZlcnNlKCksZT1uZXcgQXJyYXkodGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdPXRoaXMuZ2V0SW50ZXJpb3JSaW5nTih0KS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24odCxlKX1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX1BPTFlHT059Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDJ9Z2V0TGVuZ3RoKCl7bGV0IHQ9MDt0Kz10aGlzLl9zaGVsbC5nZXRMZW5ndGgoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5faG9sZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9Z2V0TnVtUG9pbnRzKCl7bGV0IHQ9dGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2hvbGVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fWNvbnZleEh1bGwoKXtyZXR1cm4gdGhpcy5nZXRFeHRlcmlvclJpbmcoKS5jb252ZXhIdWxsKCl9bm9ybWFsaXplZCh0LGUpe2NvbnN0IG49dC5jb3B5KCk7cmV0dXJuIHRoaXMubm9ybWFsaXplKG4sZSksbn1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9zaGVsbCxuPXQuX3NoZWxsO3JldHVybiBlLmNvbXBhcmVUb1NhbWVDbGFzcyhuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0sbj10aGlzLl9zaGVsbCxzPWUuX3NoZWxsLGk9bi5jb21wYXJlVG9TYW1lQ2xhc3Mocyx0KTtpZigwIT09aSlyZXR1cm4gaTtjb25zdCByPXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCksbz1lLmdldE51bUludGVyaW9yUmluZygpO2xldCBsPTA7Zm9yKDtsPHImJmw8bzspe2NvbnN0IG49dGhpcy5nZXRJbnRlcmlvclJpbmdOKGwpLHM9ZS5nZXRJbnRlcmlvclJpbmdOKGwpLGk9bi5jb21wYXJlVG9TYW1lQ2xhc3Mocyx0KTtpZigwIT09aSlyZXR1cm4gaTtsKyt9cmV0dXJuIGw8cj8xOmw8bz8tMTowfX1hcHBseSgpe2lmKEkoYXJndW1lbnRzWzBdLEgpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaGVsbC5hcHBseSh0KTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdGhpcy5faG9sZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxQKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fc2hlbGwuYXBwbHkodCksIXQuaXNEb25lKCkpZm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGgmJih0aGlzLl9ob2xlc1tlXS5hcHBseSh0KSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxKKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLGspKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKSx0aGlzLl9zaGVsbC5hcHBseSh0KTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdGhpcy5faG9sZXNbZV0uYXBwbHkodCl9fWdldEJvdW5kYXJ5KCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCsxKS5maWxsKG51bGwpO3RbMF09dGhpcy5fc2hlbGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRbZSsxXT10aGlzLl9ob2xlc1tlXTtyZXR1cm4gdC5sZW5ndGg8PTE/dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0WzBdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTp0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfUE9MWUdPTn1nZXRFeHRlcmlvclJpbmcoKXtyZXR1cm4gdGhpcy5fc2hlbGx9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9zaGVsbC5pc0VtcHR5KCl9Z2V0SW50ZXJpb3JSaW5nTih0KXtyZXR1cm4gdGhpcy5faG9sZXNbdF19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2l0XX19Y2xhc3Mgb3QgZXh0ZW5kcyBOe2NvbnRhaW5zKCl7fX1jbGFzcyBsdCBleHRlbmRzIG90e31jbGFzcyBhdCBleHRlbmRzIGx0e2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5hcnJheT1bXSx0IGluc3RhbmNlb2YgTiYmdGhpcy5hZGRBbGwodCl9Y29udGFpbnModCl7Zm9yKGNvbnN0IGUgb2YgdGhpcy5hcnJheSlpZigwPT09ZS5jb21wYXJlVG8odCkpcmV0dXJuITA7cmV0dXJuITF9YWRkKHQpe2lmKHRoaXMuY29udGFpbnModCkpcmV0dXJuITE7Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Lmxlbmd0aDtlPG47ZSsrKXtpZigxPT09dGhpcy5hcnJheVtlXS5jb21wYXJlVG8odCkpcmV0dXJuISF0aGlzLmFycmF5LnNwbGljZShlLDAsdCl9cmV0dXJuIHRoaXMuYXJyYXkucHVzaCh0KSwhMH1hZGRBbGwodCl7Zm9yKGNvbnN0IGUgb2YgdCl0aGlzLmFkZChlKTtyZXR1cm4hMH1yZW1vdmUoKXt0aHJvdyBuZXcgS31zaXplKCl7cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RofWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuYXJyYXkubGVuZ3RofXRvQXJyYXkoKXtyZXR1cm4gdGhpcy5hcnJheS5zbGljZSgpfWl0ZXJhdG9yKCl7cmV0dXJuIG5ldyBjdCh0aGlzLmFycmF5KX19bGV0IGN0PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYXJyYXk9dCx0aGlzLnBvc2l0aW9uPTB9bmV4dCgpe2lmKHRoaXMucG9zaXRpb249PT10aGlzLmFycmF5Lmxlbmd0aCl0aHJvdyBuZXcgUztyZXR1cm4gdGhpcy5hcnJheVt0aGlzLnBvc2l0aW9uKytdfWhhc05leHQoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbjx0aGlzLmFycmF5Lmxlbmd0aH1yZW1vdmUoKXt0aHJvdyBuZXcgS319O2NsYXNzIGh0IGV4dGVuZHMgVXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksaHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbWV0cmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoVS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLG51bGw9PT10JiYodD1bXSksVS5oYXNOdWxsRWxlbWVudHModCkpdGhyb3cgbmV3IHMoXCJnZW9tZXRyaWVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTt0aGlzLl9nZW9tZXRyaWVzPXR9fWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7Y29uc3QgdD1uZXcgTztmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9nZW9tZXRyaWVzW2VdLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIHR9Z2V0R2VvbWV0cnlOKHQpe3JldHVybiB0aGlzLl9nZW9tZXRyaWVzW3RdfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtsZXQgZT0tMTtmb3IobGV0IG49MDtuPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10aGlzLl9nZW9tZXRyaWVzW25dLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxzLmxlbmd0aDtuKyspZSsrLHRbZV09c1tuXX1yZXR1cm4gdH1nZXRBcmVhKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldEFyZWEoKTtyZXR1cm4gdH1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgaHQodCx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dDtpZih0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCE9PW4uX2dlb21ldHJpZXMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9nZW9tZXRyaWVzW3RdLmVxdWFsc0V4YWN0KG4uX2dlb21ldHJpZXNbdF0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKyl0aGlzLl9nZW9tZXRyaWVzW3RdLm5vcm1hbGl6ZSgpO3N0LnNvcnQodGhpcy5fZ2VvbWV0cmllcyl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuX2dlb21ldHJpZXNbMF0uZ2V0Q29vcmRpbmF0ZSgpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7bGV0IHQ9US5GQUxTRTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKTtyZXR1cm4gdH1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEwodCk7Zm9yKGxldCBuPTA7bjx0O24rKyllLmFkZCh0aGlzLl9nZW9tZXRyaWVzW25dLnJldmVyc2UoKSk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoZSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT059Z2V0RGltZW5zaW9uKCl7bGV0IHQ9US5GQUxTRTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5fZ2VvbWV0cmllc1tlXS5nZXREaW1lbnNpb24oKSk7cmV0dXJuIHR9Z2V0TGVuZ3RoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fWdldE51bVBvaW50cygpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH1nZXROdW1HZW9tZXRyaWVzKCl7cmV0dXJuIHRoaXMuX2dlb21ldHJpZXMubGVuZ3RofWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBhdChzdC5hc0xpc3QodGhpcy5fZ2VvbWV0cmllcykpLG49bmV3IGF0KHN0LmFzTGlzdCh0Ll9nZW9tZXRyaWVzKSk7cmV0dXJuIHRoaXMuY29tcGFyZShlLG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXSxuPXRoaXMuZ2V0TnVtR2VvbWV0cmllcygpLHM9ZS5nZXROdW1HZW9tZXRyaWVzKCk7bGV0IGk9MDtmb3IoO2k8biYmaTxzOyl7Y29uc3Qgbj10aGlzLmdldEdlb21ldHJ5TihpKSxzPWUuZ2V0R2VvbWV0cnlOKGkpLHI9bi5jb21wYXJlVG9TYW1lQ2xhc3Mocyx0KTtpZigwIT09cilyZXR1cm4gcjtpKyt9cmV0dXJuIGk8bj8xOmk8cz8tMTowfX1hcHBseSgpe2lmKEkoYXJndW1lbnRzWzBdLEgpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoJiYodGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxKKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLGspKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfX1nZXRCb3VuZGFyeSgpe3JldHVybiBVLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSxudWxsfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX0dFT01FVFJZQ09MTEVDVElPTn1pc0VtcHR5KCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNFbXB0eSgpKXJldHVybiExO3JldHVybiEwfX1jbGFzcyB1dCBleHRlbmRzIGh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx1dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtodC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9Y29weUludGVybmFsKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IHV0KHQsdGhpcy5fZmFjdG9yeSl9aXNWYWxpZCgpe3JldHVybiEwfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1t0XS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHN1cGVyLmdldENvb3JkaW5hdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIFEuRkFMU0V9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9NVUxUSVBPSU5UfWdldERpbWVuc2lvbigpe3JldHVybiAwfWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX01VTFRJUE9JTlR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3R0XX19Y2xhc3MgZ3QgZXh0ZW5kcyAke2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxndC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTskLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLnZhbGlkYXRlQ29uc3RydWN0aW9uKCl9Y29weUludGVybmFsKCl7cmV0dXJuIG5ldyBndCh0aGlzLl9wb2ludHMuY29weSgpLHRoaXMuX2ZhY3RvcnkpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIFEuRkFMU0V9aXNDbG9zZWQoKXtyZXR1cm4hIXRoaXMuaXNFbXB0eSgpfHxzdXBlci5pc0Nsb3NlZC5jYWxsKHRoaXMpfXJldmVyc2VJbnRlcm5hbCgpe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtyZXR1cm4gai5yZXZlcnNlKHQpLHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodCl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9MSU5FQVJSSU5HfXZhbGlkYXRlQ29uc3RydWN0aW9uKCl7aWYoIXRoaXMuaXNFbXB0eSgpJiYhc3VwZXIuaXNDbG9zZWQuY2FsbCh0aGlzKSl0aHJvdyBuZXcgcyhcIlBvaW50cyBvZiBMaW5lYXJSaW5nIGRvIG5vdCBmb3JtIGEgY2xvc2VkIGxpbmVzdHJpbmdcIik7aWYodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk+PTEmJnRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPGd0Lk1JTklNVU1fVkFMSURfU0laRSl0aHJvdyBuZXcgcyhcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lYXJSaW5nIChmb3VuZCBcIit0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSA0KVwiKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9MSU5FQVJSSU5HfX1ndC5NSU5JTVVNX1ZBTElEX1NJWkU9NDtjbGFzcyBkdHtzdGF0aWMgbWVhc3VyZXModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB5PzA6dCBpbnN0YW5jZW9mIHh8fHQgaW5zdGFuY2VvZiBFPzE6MH1zdGF0aWMgZGltZW5zaW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgeT8yOnQgaW5zdGFuY2VvZiB4PzM6dCBpbnN0YW5jZW9mIEU/NDozfXN0YXRpYyBjcmVhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGR0LmNyZWF0ZSh0LDApfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gMj09PXQ/bmV3IHk6Mz09PXQmJjA9PT1lP25ldyBtOjM9PT10JiYxPT09ZT9uZXcgeDo0PT09dCYmMT09PWU/bmV3IEU6bmV3IG19fX1jbGFzcyBfdHtzdGF0aWMgaXNSaW5nKHQpe3JldHVybiEodC5sZW5ndGg8NCkmJiEhdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX1zdGF0aWMgcHROb3RJbkxpc3QodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dO2lmKF90LmluZGV4T2YocyxlKTwwKXJldHVybiBzfXJldHVybiBudWxsfXN0YXRpYyBzY3JvbGwodCxlKXtjb25zdCBuPV90LmluZGV4T2YoZSx0KTtpZihuPDApcmV0dXJuIG51bGw7Y29uc3Qgcz1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7WS5hcnJheWNvcHkodCxuLHMsMCx0Lmxlbmd0aC1uKSxZLmFycmF5Y29weSh0LDAscyx0Lmxlbmd0aC1uLG4pLFkuYXJyYXljb3B5KHMsMCx0LDAsdC5sZW5ndGgpfXN0YXRpYyBlcXVhbHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09PXR8fG51bGw9PT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGVbbl0pKXJldHVybiExO3JldHVybiEwfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT09dHx8bnVsbD09PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKylpZigwIT09bi5jb21wYXJlKHRbc10sZVtzXSkpcmV0dXJuITE7cmV0dXJuITB9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtjb25zdCBuPW5ldyBSO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKWUuaW50ZXJzZWN0cyh0W3NdKSYmbi5hZGQodFtzXSwhMCk7cmV0dXJuIG4udG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgbWVhc3VyZXModCl7aWYobnVsbD09PXR8fDA9PT10Lmxlbmd0aClyZXR1cm4gMDtsZXQgZT0wO2Zvcihjb25zdCBuIG9mIHQpZT1NYXRoLm1heChlLGR0Lm1lYXN1cmVzKG4pKTtyZXR1cm4gZX1zdGF0aWMgaGFzUmVwZWF0ZWRQb2ludHModCl7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspaWYodFtlLTFdLmVxdWFscyh0W2VdKSlyZXR1cm4hMDtyZXR1cm4hMX1zdGF0aWMgcmVtb3ZlUmVwZWF0ZWRQb2ludHModCl7aWYoIV90Lmhhc1JlcGVhdGVkUG9pbnRzKHQpKXJldHVybiB0O3JldHVybiBuZXcgUih0LCExKS50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5sZW5ndGgtMSxuPU1hdGgudHJ1bmMoZS8yKTtmb3IobGV0IHM9MDtzPD1uO3MrKyl7Y29uc3Qgbj10W3NdO3Rbc109dFtlLXNdLHRbZS1zXT1ufX1zdGF0aWMgcmVtb3ZlTnVsbCh0KXtsZXQgZT0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKW51bGwhPT10W25dJiZlKys7Y29uc3Qgbj1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtpZigwPT09ZSlyZXR1cm4gbjtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKW51bGwhPT10W2VdJiYobltzKytdPXRbZV0pO3JldHVybiBufXN0YXRpYyBjb3B5RGVlcCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllW25dPXRbbl0uY29weSgpO3JldHVybiBlfWlmKDU9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XTtmb3IobGV0IHI9MDtyPGk7cisrKW5bcytyXT10W2Urcl0uY29weSgpfX1zdGF0aWMgaXNFcXVhbFJldmVyc2VkKHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHM9dFtuXSxpPWVbdC5sZW5ndGgtbi0xXTtpZigwIT09cy5jb21wYXJlVG8oaSkpcmV0dXJuITF9cmV0dXJuITB9c3RhdGljIGVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE87Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5leHBhbmRUb0luY2x1ZGUodFtuXSk7cmV0dXJuIGV9c3RhdGljIHRvQ29vcmRpbmF0ZUFycmF5KHQpe3JldHVybiB0LnRvQXJyYXkoX3QuY29vcmRBcnJheVR5cGUpfXN0YXRpYyBkaW1lbnNpb24odCl7aWYobnVsbD09PXR8fDA9PT10Lmxlbmd0aClyZXR1cm4gMztsZXQgZT0wO2Zvcihjb25zdCBuIG9mIHQpZT1NYXRoLm1heChlLGR0LmRpbWVuc2lvbihuKSk7cmV0dXJuIGV9c3RhdGljIGF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmcodCxlKXtyZXR1cm4gZS5sZW5ndGg+PXQ/ZTpbXX1zdGF0aWMgaW5kZXhPZih0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKHQuZXF1YWxzKGVbbl0pKXJldHVybiBuO3JldHVybi0xfXN0YXRpYyBpbmNyZWFzaW5nRGlyZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8TWF0aC50cnVuYyh0Lmxlbmd0aC8yKTtlKyspe2NvbnN0IG49dC5sZW5ndGgtMS1lLHM9dFtlXS5jb21wYXJlVG8odFtuXSk7aWYoMCE9PXMpcmV0dXJuIHN9cmV0dXJuIDF9c3RhdGljIGNvbXBhcmUodCxlKXtsZXQgbj0wO2Zvcig7bjx0Lmxlbmd0aCYmbjxlLmxlbmd0aDspe2NvbnN0IHM9dFtuXS5jb21wYXJlVG8oZVtuXSk7aWYoMCE9PXMpcmV0dXJuIHM7bisrfXJldHVybiBuPGUubGVuZ3RoPy0xOm48dC5sZW5ndGg/MTowfXN0YXRpYyBtaW5Db29yZGluYXRlKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspKG51bGw9PT1lfHxlLmNvbXBhcmVUbyh0W25dKT4wKSYmKGU9dFtuXSk7cmV0dXJuIGV9c3RhdGljIGV4dHJhY3QodCxlLG4pe2U9Vi5jbGFtcChlLDAsdC5sZW5ndGgpO2xldCBzPShuPVYuY2xhbXAobiwtMSx0Lmxlbmd0aCkpLWUrMTtuPDAmJihzPTApLGU+PXQubGVuZ3RoJiYocz0wKSxuPGUmJihzPTApO2NvbnN0IGk9bmV3IEFycmF5KHMpLmZpbGwobnVsbCk7aWYoMD09PXMpcmV0dXJuIGk7bGV0IHI9MDtmb3IobGV0IHM9ZTtzPD1uO3MrKylpW3IrK109dFtzXTtyZXR1cm4gaX19X3QuRm9yd2FyZENvbXBhcmF0b3I9Y2xhc3N7Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7cmV0dXJuIF90LmNvbXBhcmUobixzKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fSxfdC5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvcj1jbGFzc3tjb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtpZihuLmxlbmd0aDxzLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5zLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7Y29uc3QgaT1fdC5jb21wYXJlKG4scyk7cmV0dXJuIF90LmlzRXF1YWxSZXZlcnNlZChuLHMpPzA6aX1PTERjb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtpZihuLmxlbmd0aDxzLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5zLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7Y29uc3QgaT1fdC5pbmNyZWFzaW5nRGlyZWN0aW9uKG4pLHI9X3QuaW5jcmVhc2luZ0RpcmVjdGlvbihzKTtsZXQgbz1pPjA/MDpuLmxlbmd0aC0xLGw9cj4wPzA6bi5sZW5ndGgtMTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgdD1uW29dLmNvbXBhcmVUbyhzW2xdKTtpZigwIT09dClyZXR1cm4gdDtvKz1pLGwrPXJ9cmV0dXJuIDB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX0sX3QuY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCk7Y2xhc3MgcHR7Y29uc3RydWN0b3IodCl7dGhpcy5zdHI9dH1hcHBlbmQodCl7dGhpcy5zdHIrPXR9c2V0Q2hhckF0KHQsZSl7dGhpcy5zdHI9dGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX10b1N0cmluZygpe3JldHVybiB0aGlzLnN0cn19Y2xhc3MgbXR7Y29uc3RydWN0b3IoKXttdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9kaW1lbnNpb249Myx0aGlzLl9tZWFzdXJlcz0wLHRoaXMuX2Nvb3JkaW5hdGVzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO210LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxfdC5kaW1lbnNpb24odCksX3QubWVhc3VyZXModCkpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPW5ldyBtfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXJldHVybiB0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO3RoaXMuX2RpbWVuc2lvbj10LmdldERpbWVuc2lvbigpLHRoaXMuX21lYXN1cmVzPXQuZ2V0TWVhc3VyZXMoKSx0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPXQuZ2V0Q29vcmRpbmF0ZUNvcHkoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bXQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsX3QubWVhc3VyZXModCkpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuX2RpbWVuc2lvbj1lO2ZvcihsZXQgbj0wO248dDtuKyspdGhpcy5fY29vcmRpbmF0ZXNbbl09ZHQuY3JlYXRlKGUpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9kaW1lbnNpb249ZSx0aGlzLl9tZWFzdXJlcz1uLHRoaXMuX2Nvb3JkaW5hdGVzPW51bGw9PT10P25ldyBBcnJheSgwKS5maWxsKG51bGwpOnR9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLl9kaW1lbnNpb249ZSx0aGlzLl9tZWFzdXJlcz1uO2ZvcihsZXQgZT0wO2U8dDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09dGhpcy5jcmVhdGVDb29yZGluYXRlKCl9fWdldE0odCl7cmV0dXJuIHRoaXMuaGFzTSgpP3RoaXMuX2Nvb3JkaW5hdGVzW3RdLmdldE0oKTpyLk5hTn1zZXRPcmRpbmF0ZSh0LGUsbil7c3dpdGNoKGUpe2Nhc2UgRy5YOnRoaXMuX2Nvb3JkaW5hdGVzW3RdLng9bjticmVhaztjYXNlIEcuWTp0aGlzLl9jb29yZGluYXRlc1t0XS55PW47YnJlYWs7ZGVmYXVsdDp0aGlzLl9jb29yZGluYXRlc1t0XS5zZXRPcmRpbmF0ZShlLG4pfX1nZXRaKHQpe3JldHVybiB0aGlzLmhhc1ooKT90aGlzLl9jb29yZGluYXRlc1t0XS5nZXRaKCk6ci5OYU59c2l6ZSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGh9Z2V0T3JkaW5hdGUodCxlKXtzd2l0Y2goZSl7Y2FzZSBHLlg6cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLng7Y2FzZSBHLlk6cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0uZ2V0T3JkaW5hdGUoZSl9fWdldENvb3JkaW5hdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTthcmd1bWVudHNbMV0uc2V0Q29vcmRpbmF0ZSh0aGlzLl9jb29yZGluYXRlc1t0XSl9fWdldENvb3JkaW5hdGVDb3B5KHQpe2NvbnN0IGU9dGhpcy5jcmVhdGVDb29yZGluYXRlKCk7cmV0dXJuIGUuc2V0Q29vcmRpbmF0ZSh0aGlzLl9jb29yZGluYXRlc1t0XSksZX1jcmVhdGVDb29yZGluYXRlKCl7cmV0dXJuIGR0LmNyZWF0ZSh0aGlzLmdldERpbWVuc2lvbigpLHRoaXMuZ2V0TWVhc3VyZXMoKSl9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuX2RpbWVuc2lvbn1nZXRYKHQpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS54fWdldE1lYXN1cmVzKCl7cmV0dXJuIHRoaXMuX21lYXN1cmVzfWV4cGFuZEVudmVsb3BlKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlc1tlXSk7cmV0dXJuIHR9Y29weSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl7Y29uc3Qgbj10aGlzLmNyZWF0ZUNvb3JkaW5hdGUoKTtuLnNldENvb3JkaW5hdGUodGhpcy5fY29vcmRpbmF0ZXNbZV0pLHRbZV09bn1yZXR1cm4gbmV3IG10KHQsdGhpcy5fZGltZW5zaW9uLHRoaXMuX21lYXN1cmVzKX10b1N0cmluZygpe2lmKHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aD4wKXtjb25zdCB0PW5ldyBwdCgxNyp0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgpO3QuYXBwZW5kKFwiKFwiKSx0LmFwcGVuZCh0aGlzLl9jb29yZGluYXRlc1swXSk7Zm9yKGxldCBlPTE7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuYXBwZW5kKFwiLCBcIiksdC5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0LmFwcGVuZChcIilcIiksdC50b1N0cmluZygpfXJldHVyblwiKClcIn1nZXRZKHQpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS55fXRvQ29vcmRpbmF0ZUFycmF5KCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHLGNdfX1jbGFzcyBmdHtzdGF0aWMgaW5zdGFuY2UoKXtyZXR1cm4gZnQuaW5zdGFuY2VPYmplY3R9cmVhZFJlc29sdmUoKXtyZXR1cm4gZnQuaW5zdGFuY2UoKX1jcmVhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7cmV0dXJuIG5ldyBtdChhcmd1bWVudHNbMF0pfWlmKEkoYXJndW1lbnRzWzBdLEcpKXtyZXR1cm4gbmV3IG10KGFyZ3VtZW50c1swXSl9fWVsc2V7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gdD4zJiYodD0zKSx0PDImJih0PTIpLG5ldyBtdChhcmd1bWVudHNbMF0sdCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1syXSxlPWFyZ3VtZW50c1sxXS10O3JldHVybiB0PjEmJih0PTEpLGU+MyYmKGU9MyksZTwyJiYoZT0yKSxuZXcgbXQoYXJndW1lbnRzWzBdLGUrdCx0KX19fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltYLGNdfX1mdC5pbnN0YW5jZU9iamVjdD1uZXcgZnQ7Y2xhc3MgeXQgZXh0ZW5kcyBodHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfWNvcHlJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyB5dCh0LHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9NVUxUSVBPTFlHT059Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDJ9Z2V0Qm91bmRhcnkoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl7Y29uc3Qgbj10aGlzLl9nZW9tZXRyaWVzW2VdLmdldEJvdW5kYXJ5KCk7Zm9yKGxldCBlPTA7ZTxuLmdldE51bUdlb21ldHJpZXMoKTtlKyspdC5hZGQobi5nZXRHZW9tZXRyeU4oZSkpfWNvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodC50b0FycmF5KGUpKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9NVUxUSVBPTFlHT059Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2l0XX19bGV0IHh0PWNsYXNze2dldCgpe31wdXQoKXt9c2l6ZSgpe312YWx1ZXMoKXt9ZW50cnlTZXQoKXt9fTtjbGFzcyBFdCBleHRlbmRzIG90e2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5tYXA9bmV3IE1hcCx0IGluc3RhbmNlb2YgTiYmdGhpcy5hZGRBbGwodCl9Y29udGFpbnModCl7Y29uc3QgZT10Lmhhc2hDb2RlP3QuaGFzaENvZGUoKTp0O3JldHVybiEhdGhpcy5tYXAuaGFzKGUpfWFkZCh0KXtjb25zdCBlPXQuaGFzaENvZGU/dC5oYXNoQ29kZSgpOnQ7cmV0dXJuIXRoaXMubWFwLmhhcyhlKSYmISF0aGlzLm1hcC5zZXQoZSx0KX1hZGRBbGwodCl7Zm9yKGNvbnN0IGUgb2YgdCl0aGlzLmFkZChlKTtyZXR1cm4hMH1yZW1vdmUoKXt0aHJvdyBuZXcgS31zaXplKCl7cmV0dXJuIHRoaXMubWFwLnNpemV9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5tYXAuc2l6ZX10b0FycmF5KCl7cmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAudmFsdWVzKCkpfWl0ZXJhdG9yKCl7cmV0dXJuIG5ldyBJdCh0aGlzLm1hcCl9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5tYXB9fWxldCBJdD1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLml0ZXJhdG9yPXQudmFsdWVzKCk7Y29uc3R7ZG9uZTplLHZhbHVlOm59PXRoaXMuaXRlcmF0b3IubmV4dCgpO3RoaXMuZG9uZT1lLHRoaXMudmFsdWU9bn1uZXh0KCl7aWYodGhpcy5kb25lKXRocm93IG5ldyBTO2NvbnN0IHQ9dGhpcy52YWx1ZSx7ZG9uZTplLHZhbHVlOm59PXRoaXMuaXRlcmF0b3IubmV4dCgpO3JldHVybiB0aGlzLmRvbmU9ZSx0aGlzLnZhbHVlPW4sdH1oYXNOZXh0KCl7cmV0dXJuIXRoaXMuZG9uZX1yZW1vdmUoKXt0aHJvdyBuZXcgS319O2NsYXNzIE50IGV4dGVuZHMgeHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMubWFwPW5ldyBNYXB9Z2V0KHQpe3JldHVybiB0aGlzLm1hcC5nZXQodCl8fG51bGx9cHV0KHQsZSl7cmV0dXJuIHRoaXMubWFwLnNldCh0LGUpLGV9dmFsdWVzKCl7Y29uc3QgdD1uZXcgTCxlPXRoaXMubWFwLnZhbHVlcygpO2xldCBuPWUubmV4dCgpO2Zvcig7IW4uZG9uZTspdC5hZGQobi52YWx1ZSksbj1lLm5leHQoKTtyZXR1cm4gdH1lbnRyeVNldCgpe2NvbnN0IHQ9bmV3IEV0O3JldHVybiB0aGlzLm1hcC5lbnRyaWVzKCkuZm9yRWFjaCgoZT0+dC5hZGQoZSkpKSx0fXNpemUoKXtyZXR1cm4gdGhpcy5tYXAuc2l6ZSgpfX1jbGFzcyB3dHtjb25zdHJ1Y3Rvcigpe3d0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX21vZGVsVHlwZT1udWxsLHRoaXMuX3NjYWxlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbW9kZWxUeXBlPXd0LkZMT0FUSU5HO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXQsdD09PXd0LkZJWEVEJiZ0aGlzLnNldFNjYWxlKDEpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXd0LkZJWEVELHRoaXMuc2V0U2NhbGUodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHd0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9dC5fbW9kZWxUeXBlLHRoaXMuX3NjYWxlPXQuX3NjYWxlfX1zdGF0aWMgbW9zdFByZWNpc2UodCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSk+PTA/dDplfWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiB3dCkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1lLl9tb2RlbFR5cGUmJnRoaXMuX3NjYWxlPT09ZS5fc2NhbGV9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dCxuPXRoaXMuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCkscz1lLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO3JldHVybiBiLmNvbXBhcmUobixzKX1nZXRTY2FsZSgpe3JldHVybiB0aGlzLl9zY2FsZX1pc0Zsb2F0aW5nKCl7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HfHx0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElOR19TSU5HTEV9Z2V0VHlwZSgpe3JldHVybiB0aGlzLl9tb2RlbFR5cGV9dG9TdHJpbmcoKXtsZXQgdD1cIlVOS05PV05cIjtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkc/dD1cIkZsb2F0aW5nXCI6dGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkdfU0lOR0xFP3Q9XCJGbG9hdGluZy1TaW5nbGVcIjp0aGlzLl9tb2RlbFR5cGU9PT13dC5GSVhFRCYmKHQ9XCJGaXhlZCAoU2NhbGU9XCIrdGhpcy5nZXRTY2FsZSgpK1wiKVwiKSx0fW1ha2VQcmVjaXNlKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoci5pc05hTih0KSlyZXR1cm4gdDtpZih0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElOR19TSU5HTEUpe3JldHVybiB0fXJldHVybiB0aGlzLl9tb2RlbFR5cGU9PT13dC5GSVhFRD9NYXRoLnJvdW5kKHQqdGhpcy5fc2NhbGUpL3RoaXMuX3NjYWxlOnR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElORylyZXR1cm4gbnVsbDt0Lng9dGhpcy5tYWtlUHJlY2lzZSh0LngpLHQueT10aGlzLm1ha2VQcmVjaXNlKHQueSl9fWdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpe2xldCB0PTE2O3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElORz90PTE2OnRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HX1NJTkdMRT90PTY6dGhpcy5fbW9kZWxUeXBlPT09d3QuRklYRUQmJih0PTErTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5sb2codGhpcy5nZXRTY2FsZSgpKS9NYXRoLmxvZygxMCkpKSksdH1zZXRTY2FsZSh0KXt0aGlzLl9zY2FsZT1NYXRoLmFicyh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYyxvXX19Y2xhc3MgQ3R7Y29uc3RydWN0b3IoKXtDdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9uYW1lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbmFtZT10LEN0Lm5hbWVUb1R5cGVNYXAucHV0KHQsdGhpcyl9cmVhZFJlc29sdmUoKXtyZXR1cm4gQ3QubmFtZVRvVHlwZU1hcC5nZXQodGhpcy5fbmFtZSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fbmFtZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bY119fUN0Lm5hbWVUb1R5cGVNYXA9bmV3IE50LHd0LlR5cGU9Q3Qsd3QuRklYRUQ9bmV3IEN0KFwiRklYRURcIiksd3QuRkxPQVRJTkc9bmV3IEN0KFwiRkxPQVRJTkdcIiksd3QuRkxPQVRJTkdfU0lOR0xFPW5ldyBDdChcIkZMT0FUSU5HIFNJTkdMRVwiKSx3dC5tYXhpbXVtUHJlY2lzZVZhbHVlPTkwMDcxOTkyNTQ3NDA5OTI7Y2xhc3MgU3QgZXh0ZW5kcyBodHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksU3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfWNvcHlJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBTdCh0LHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9RLkZBTFNFOjB9aXNDbG9zZWQoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5pc0Nsb3NlZCgpKXJldHVybiExO3JldHVybiEwfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HfWdldERpbWVuc2lvbigpe3JldHVybiAxfWdldEJvdW5kYXJ5KCl7dGhyb3cgbmV3IEt9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltaXX19Y2xhc3MgTHR7Y29uc3RydWN0b3IoKXtMdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bnVsbCx0aGlzLl9TUklEPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpTHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgd3QsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sWCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0x0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IHd0LDAsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHd0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtMdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMCxMdC5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07THQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsTHQuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW4sdGhpcy5fU1JJRD1lfX1zdGF0aWMgdG9NdWx0aVBvbHlnb25BcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0dlb21ldHJ5QXJyYXkodCl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKXtyZXR1cm4gZnQuaW5zdGFuY2UoKX1zdGF0aWMgdG9NdWx0aUxpbmVTdHJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0xpbmVTdHJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b011bHRpUG9pbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0xpbmVhclJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b1BvaW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9Qb2x5Z29uQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9Y3JlYXRlRW1wdHkodCl7c3dpdGNoKHQpe2Nhc2UtMTpyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtjYXNlIDA6cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQoKTtjYXNlIDE6cmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMjpyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKCk7ZGVmYXVsdDp0aHJvdyBuZXcgcyhcIkludmFsaWQgZGltZW5zaW9uOiBcIit0KX19dG9HZW9tZXRyeSh0KXtyZXR1cm4gdC5pc051bGwoKT90aGlzLmNyZWF0ZVBvaW50KCk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKSYmdC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZVBvaW50KG5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKXx8dC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgbSh0LmdldE1heFgoKSx0LmdldE1heFkoKSldKTp0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IG0odC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLG5ldyBtKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSxuZXcgbSh0LmdldE1heFgoKSx0LmdldE1pblkoKSksbmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpXSksbnVsbCl9Y3JlYXRlTGluZVN0cmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKEkoYXJndW1lbnRzWzBdLEcpKXtyZXR1cm4gbmV3ICQoYXJndW1lbnRzWzBdLHRoaXMpfX19Y3JlYXRlTXVsdGlMaW5lU3RyaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBTdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IFN0KGFyZ3VtZW50c1swXSx0aGlzKX19YnVpbGRHZW9tZXRyeSh0KXtsZXQgZT1udWxsLG49ITEscz0hMTtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPXQuZ2V0VHlwZUNvZGUoKTtudWxsPT09ZSYmKGU9ciksciE9PWUmJihuPSEwKSx0IGluc3RhbmNlb2YgaHQmJihzPSEwKX1pZihudWxsPT09ZSlyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtpZihufHxzKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihMdC50b0dlb21ldHJ5QXJyYXkodCkpO2NvbnN0IGk9dC5pdGVyYXRvcigpLm5leHQoKTtpZih0LnNpemUoKT4xKXtpZihpIGluc3RhbmNlb2YgcnQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2x5Z29uKEx0LnRvUG9seWdvbkFycmF5KHQpKTtpZihpIGluc3RhbmNlb2YgJClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoTHQudG9MaW5lU3RyaW5nQXJyYXkodCkpO2lmKGkgaW5zdGFuY2VvZiBldClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KEx0LnRvUG9pbnRBcnJheSh0KSk7Zy5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuaGFuZGxlZCBnZW9tZXRyeSB0eXBlOiBcIitpLmdldEdlb21ldHJ5VHlwZSgpKX1yZXR1cm4gaX1jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3Jkcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1jcmVhdGVQb2ludCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvaW50KHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbdF0pOm51bGwpfWlmKEkoYXJndW1lbnRzWzBdLEcpKXtyZXR1cm4gbmV3IGV0KGFyZ3VtZW50c1swXSx0aGlzKX19fWdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeX1jcmVhdGVQb2x5Z29uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbihudWxsLG51bGwpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGd0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHQsbnVsbCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgcnQoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSx0aGlzKX19Z2V0U1JJRCgpe3JldHVybiB0aGlzLl9TUklEfWNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgaHQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBodChhcmd1bWVudHNbMF0sdGhpcyl9fWdldFByZWNpc2lvbk1vZGVsKCl7cmV0dXJuIHRoaXMuX3ByZWNpc2lvbk1vZGVsfWNyZWF0ZUxpbmVhclJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihJKGFyZ3VtZW50c1swXSxHKSl7cmV0dXJuIG5ldyBndChhcmd1bWVudHNbMF0sdGhpcyl9fX1jcmVhdGVNdWx0aVBvbHlnb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IHl0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgeXQoYXJndW1lbnRzWzBdLHRoaXMpfX1jcmVhdGVNdWx0aVBvaW50KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyB1dChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtyZXR1cm4gbmV3IHV0KGFyZ3VtZW50c1swXSx0aGlzKX1pZihJKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKDEsdC5nZXREaW1lbnNpb24oKSx0LmdldE1lYXN1cmVzKCkpO2ouY29weSh0LG4scywwLDEpLGVbbl09dGhpcy5jcmVhdGVQb2ludChzKX1yZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGUpfX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NdfX1jb25zdCBUdD1cIlhZXCIsUnQ9XCJYWVpcIixQdD1cIlhZTVwiLE90PVwiWFlaTVwiLHZ0PXtQT0lOVDpcIlBvaW50XCIsTElORV9TVFJJTkc6XCJMaW5lU3RyaW5nXCIsTElORUFSX1JJTkc6XCJMaW5lYXJSaW5nXCIsUE9MWUdPTjpcIlBvbHlnb25cIixNVUxUSV9QT0lOVDpcIk11bHRpUG9pbnRcIixNVUxUSV9MSU5FX1NUUklORzpcIk11bHRpTGluZVN0cmluZ1wiLE1VTFRJX1BPTFlHT046XCJNdWx0aVBvbHlnb25cIixHRU9NRVRSWV9DT0xMRUNUSU9OOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsQ0lSQ0xFOlwiQ2lyY2xlXCJ9LGJ0PVwiRU1QVFlcIixNdD0xLER0PTIsQXQ9MyxGdD00LEd0PTUscXQ9Njtmb3IoY29uc3QgdCBpbiB2dCl2dFt0XS50b1VwcGVyQ2FzZSgpO2NsYXNzIEJ0e2NvbnN0cnVjdG9yKHQpe3RoaXMud2t0PXQsdGhpcy5pbmRleF89LTF9aXNBbHBoYV8odCl7cmV0dXJuIHQ+PVwiYVwiJiZ0PD1cInpcInx8dD49XCJBXCImJnQ8PVwiWlwifWlzTnVtZXJpY18odCxlKXtyZXR1cm4gdD49XCIwXCImJnQ8PVwiOVwifHxcIi5cIj09dCYmISh2b2lkIDAhPT1lJiZlKX1pc1doaXRlU3BhY2VfKHQpe3JldHVyblwiIFwiPT10fHxcIlxcdFwiPT10fHxcIlxcclwiPT10fHxcIlxcblwiPT10fW5leHRDaGFyXygpe3JldHVybiB0aGlzLndrdC5jaGFyQXQoKyt0aGlzLmluZGV4Xyl9bmV4dFRva2VuKCl7Y29uc3QgdD10aGlzLm5leHRDaGFyXygpLGU9dGhpcy5pbmRleF87bGV0IG4scz10O2lmKFwiKFwiPT10KW49RHQ7ZWxzZSBpZihcIixcIj09dCluPUd0O2Vsc2UgaWYoXCIpXCI9PXQpbj1BdDtlbHNlIGlmKHRoaXMuaXNOdW1lcmljXyh0KXx8XCItXCI9PXQpbj1GdCxzPXRoaXMucmVhZE51bWJlcl8oKTtlbHNlIGlmKHRoaXMuaXNBbHBoYV8odCkpbj1NdCxzPXRoaXMucmVhZFRleHRfKCk7ZWxzZXtpZih0aGlzLmlzV2hpdGVTcGFjZV8odCkpcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7aWYoXCJcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiK3QpO249cXR9cmV0dXJue3Bvc2l0aW9uOmUsdmFsdWU6cyx0eXBlOm59fXJlYWROdW1iZXJfKCl7bGV0IHQ7Y29uc3QgZT10aGlzLmluZGV4XztsZXQgbj0hMSxzPSExO2Rve1wiLlwiPT10P249ITA6XCJlXCIhPXQmJlwiRVwiIT10fHwocz0hMCksdD10aGlzLm5leHRDaGFyXygpfXdoaWxlKHRoaXMuaXNOdW1lcmljXyh0LG4pfHwhcyYmKFwiZVwiPT10fHxcIkVcIj09dCl8fHMmJihcIi1cIj09dHx8XCIrXCI9PXQpKTtyZXR1cm4gcGFyc2VGbG9hdCh0aGlzLndrdC5zdWJzdHJpbmcoZSx0aGlzLmluZGV4Xy0tKSl9cmVhZFRleHRfKCl7bGV0IHQ7Y29uc3QgZT10aGlzLmluZGV4Xztkb3t0PXRoaXMubmV4dENoYXJfKCl9d2hpbGUodGhpcy5pc0FscGhhXyh0KSk7cmV0dXJuIHRoaXMud2t0LnN1YnN0cmluZyhlLHRoaXMuaW5kZXhfLS0pLnRvVXBwZXJDYXNlKCl9fWNsYXNzIFl0e2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5sZXhlcl89dCx0aGlzLnRva2VuXyx0aGlzLmxheW91dF89VHQsdGhpcy5mYWN0b3J5PWV9Y29uc3VtZV8oKXt0aGlzLnRva2VuXz10aGlzLmxleGVyXy5uZXh0VG9rZW4oKX1pc1Rva2VuVHlwZSh0KXtyZXR1cm4gdGhpcy50b2tlbl8udHlwZT09dH1tYXRjaCh0KXtjb25zdCBlPXRoaXMuaXNUb2tlblR5cGUodCk7cmV0dXJuIGUmJnRoaXMuY29uc3VtZV8oKSxlfXBhcnNlKCl7dGhpcy5jb25zdW1lXygpO3JldHVybiB0aGlzLnBhcnNlR2VvbWV0cnlfKCl9cGFyc2VHZW9tZXRyeUxheW91dF8oKXtsZXQgdD1UdDtjb25zdCBlPXRoaXMudG9rZW5fO2lmKHRoaXMuaXNUb2tlblR5cGUoTXQpKXtjb25zdCBuPWUudmFsdWU7XCJaXCI9PT1uP3Q9UnQ6XCJNXCI9PT1uP3Q9UHQ6XCJaTVwiPT09biYmKHQ9T3QpLHQhPT1UdCYmdGhpcy5jb25zdW1lXygpfXJldHVybiB0fXBhcnNlR2VvbWV0cnlDb2xsZWN0aW9uVGV4dF8oKXtpZih0aGlzLm1hdGNoKER0KSl7Y29uc3QgdD1bXTtkb3t0LnB1c2godGhpcy5wYXJzZUdlb21ldHJ5XygpKX13aGlsZSh0aGlzLm1hdGNoKEd0KSk7aWYodGhpcy5tYXRjaChBdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlUG9pbnRUZXh0Xygpe2lmKHRoaXMubWF0Y2goRHQpKXtjb25zdCB0PXRoaXMucGFyc2VQb2ludF8oKTtpZih0aGlzLm1hdGNoKEF0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybiBudWxsO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VMaW5lU3RyaW5nVGV4dF8oKXtpZih0aGlzLm1hdGNoKER0KSl7Y29uc3QgdD10aGlzLnBhcnNlUG9pbnRMaXN0XygpO2lmKHRoaXMubWF0Y2goQXQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvbHlnb25UZXh0Xygpe2lmKHRoaXMubWF0Y2goRHQpKXtjb25zdCB0PXRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dExpc3RfKCk7aWYodGhpcy5tYXRjaChBdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTXVsdGlQb2ludFRleHRfKCl7aWYodGhpcy5tYXRjaChEdCkpe2xldCB0O2lmKHQ9dGhpcy50b2tlbl8udHlwZT09RHQ/dGhpcy5wYXJzZVBvaW50VGV4dExpc3RfKCk6dGhpcy5wYXJzZVBvaW50TGlzdF8oKSx0aGlzLm1hdGNoKEF0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VNdWx0aUxpbmVTdHJpbmdUZXh0Xygpe2lmKHRoaXMubWF0Y2goRHQpKXtjb25zdCB0PXRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dExpc3RfKCk7aWYodGhpcy5tYXRjaChBdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTXVsdGlQb2x5Z29uVGV4dF8oKXtpZih0aGlzLm1hdGNoKER0KSl7Y29uc3QgdD10aGlzLnBhcnNlUG9seWdvblRleHRMaXN0XygpO2lmKHRoaXMubWF0Y2goQXQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvaW50Xygpe2NvbnN0IHQ9W10sZT10aGlzLmxheW91dF8ubGVuZ3RoO2ZvcihsZXQgbj0wO248ZTsrK24pe2NvbnN0IGU9dGhpcy50b2tlbl87aWYoIXRoaXMubWF0Y2goRnQpKWJyZWFrO3QucHVzaChlLnZhbHVlKX1pZih0Lmxlbmd0aD09ZSlyZXR1cm4gdDt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlUG9pbnRMaXN0Xygpe2NvbnN0IHQ9W3RoaXMucGFyc2VQb2ludF8oKV07Zm9yKDt0aGlzLm1hdGNoKEd0KTspdC5wdXNoKHRoaXMucGFyc2VQb2ludF8oKSk7cmV0dXJuIHR9cGFyc2VQb2ludFRleHRMaXN0Xygpe2NvbnN0IHQ9W3RoaXMucGFyc2VQb2ludFRleHRfKCldO2Zvcig7dGhpcy5tYXRjaChHdCk7KXQucHVzaCh0aGlzLnBhcnNlUG9pbnRUZXh0XygpKTtyZXR1cm4gdH1wYXJzZUxpbmVTdHJpbmdUZXh0TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCldO2Zvcig7dGhpcy5tYXRjaChHdCk7KXQucHVzaCh0aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCkpO3JldHVybiB0fXBhcnNlUG9seWdvblRleHRMaXN0Xygpe2NvbnN0IHQ9W3RoaXMucGFyc2VQb2x5Z29uVGV4dF8oKV07Zm9yKDt0aGlzLm1hdGNoKEd0KTspdC5wdXNoKHRoaXMucGFyc2VQb2x5Z29uVGV4dF8oKSk7cmV0dXJuIHR9aXNFbXB0eUdlb21ldHJ5Xygpe2NvbnN0IHQ9dGhpcy5pc1Rva2VuVHlwZShNdCkmJnRoaXMudG9rZW5fLnZhbHVlPT1idDtyZXR1cm4gdCYmdGhpcy5jb25zdW1lXygpLHR9Zm9ybWF0RXJyb3JNZXNzYWdlXygpe3JldHVyblwiVW5leHBlY3RlZCBgXCIrdGhpcy50b2tlbl8udmFsdWUrXCJgIGF0IHBvc2l0aW9uIFwiK3RoaXMudG9rZW5fLnBvc2l0aW9uK1wiIGluIGBcIit0aGlzLmxleGVyXy53a3QrXCJgXCJ9cGFyc2VHZW9tZXRyeV8oKXtjb25zdCB0PXRoaXMuZmFjdG9yeSxlPXQ9Pm5ldyBtKC4uLnQpLG49bj0+e2NvbnN0IHM9bi5tYXAoKG49PnQuY3JlYXRlTGluZWFyUmluZyhuLm1hcChlKSkpKTtyZXR1cm4gcy5sZW5ndGg+MT90LmNyZWF0ZVBvbHlnb24oc1swXSxzLnNsaWNlKDEpKTp0LmNyZWF0ZVBvbHlnb24oc1swXSl9LHM9dGhpcy50b2tlbl87aWYodGhpcy5tYXRjaChNdCkpe2NvbnN0IGk9cy52YWx1ZTtpZih0aGlzLmxheW91dF89dGhpcy5wYXJzZUdlb21ldHJ5TGF5b3V0XygpLFwiR0VPTUVUUllDT0xMRUNUSU9OXCI9PWkpe2NvbnN0IGU9dGhpcy5wYXJzZUdlb21ldHJ5Q29sbGVjdGlvblRleHRfKCk7cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfXN3aXRjaChpKXtjYXNlXCJQT0lOVFwiOntjb25zdCBlPXRoaXMucGFyc2VQb2ludFRleHRfKCk7cmV0dXJuIGU/dC5jcmVhdGVQb2ludChuZXcgbSguLi5lKSk6dC5jcmVhdGVQb2ludCgpfWNhc2VcIkxJTkVTVFJJTkdcIjp7Y29uc3Qgbj10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCkubWFwKGUpO3JldHVybiB0LmNyZWF0ZUxpbmVTdHJpbmcobil9Y2FzZVwiTElORUFSUklOR1wiOntjb25zdCBuPXRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dF8oKS5tYXAoZSk7cmV0dXJuIHQuY3JlYXRlTGluZWFyUmluZyhuKX1jYXNlXCJQT0xZR09OXCI6e2NvbnN0IGU9dGhpcy5wYXJzZVBvbHlnb25UZXh0XygpO3JldHVybiBlJiYwIT09ZS5sZW5ndGg/bihlKTp0LmNyZWF0ZVBvbHlnb24oKX1jYXNlXCJNVUxUSVBPSU5UXCI6e2NvbnN0IG49dGhpcy5wYXJzZU11bHRpUG9pbnRUZXh0XygpO2lmKCFufHwwPT09bi5sZW5ndGgpcmV0dXJuIHQuY3JlYXRlTXVsdGlQb2ludCgpO2NvbnN0IHM9bi5tYXAoZSkubWFwKChlPT50LmNyZWF0ZVBvaW50KGUpKSk7cmV0dXJuIHQuY3JlYXRlTXVsdGlQb2ludChzKX1jYXNlXCJNVUxUSUxJTkVTVFJJTkdcIjp7Y29uc3Qgbj10aGlzLnBhcnNlTXVsdGlMaW5lU3RyaW5nVGV4dF8oKS5tYXAoKG49PnQuY3JlYXRlTGluZVN0cmluZyhuLm1hcChlKSkpKTtyZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9Y2FzZVwiTVVMVElQT0xZR09OXCI6e2NvbnN0IGU9dGhpcy5wYXJzZU11bHRpUG9seWdvblRleHRfKCk7aWYoIWV8fDA9PT1lLmxlbmd0aClyZXR1cm4gdC5jcmVhdGVNdWx0aVBvbHlnb24oKTtjb25zdCBzPWUubWFwKG4pO3JldHVybiB0LmNyZWF0ZU11bHRpUG9seWdvbihzKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ2VvbWV0cnkgdHlwZTogXCIraSl9fXRocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9fWZ1bmN0aW9uIFZ0KHQpe2lmKHQuaXNFbXB0eSgpKXJldHVyblwiXCI7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoKSxuPVtlLngsZS55XTtyZXR1cm4gdm9pZCAwPT09ZS56fHxOdW1iZXIuaXNOYU4oZS56KXx8bi5wdXNoKGUueiksdm9pZCAwPT09ZS5tfHxOdW1iZXIuaXNOYU4oZS5tKXx8bi5wdXNoKGUubSksbi5qb2luKFwiIFwiKX1mdW5jdGlvbiB6dCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoKHQ9Pntjb25zdCBlPVt0LngsdC55XTtyZXR1cm4gdm9pZCAwPT09dC56fHxOdW1iZXIuaXNOYU4odC56KXx8ZS5wdXNoKHQueiksdm9pZCAwPT09dC5tfHxOdW1iZXIuaXNOYU4odC5tKXx8ZS5wdXNoKHQubSksZX0pKSxuPVtdO2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzOysrdCluLnB1c2goZVt0XS5qb2luKFwiIFwiKSk7cmV0dXJuIG4uam9pbihcIiwgXCIpfWZ1bmN0aW9uIFh0KHQpe2NvbnN0IGU9W107ZS5wdXNoKFwiKFwiK3p0KHQuZ2V0RXh0ZXJpb3JSaW5nKCkpK1wiKVwiKTtmb3IobGV0IG49MCxzPXQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bjxzOysrbillLnB1c2goXCIoXCIrenQodC5nZXRJbnRlcmlvclJpbmdOKG4pKStcIilcIik7cmV0dXJuIGUuam9pbihcIiwgXCIpfWNvbnN0IGt0PXtQb2ludDpWdCxMaW5lU3RyaW5nOnp0LExpbmVhclJpbmc6enQsUG9seWdvbjpYdCxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChcIihcIitWdCh0LmdldEdlb21ldHJ5TihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChcIihcIit6dCh0LmdldEdlb21ldHJ5TihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChcIihcIitYdCh0LmdldEdlb21ldHJ5TihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChVdCh0LmdldEdlb21ldHJ5TihuKSkpO3JldHVybiBlLmpvaW4oXCIsIFwiKX19O2Z1bmN0aW9uIFV0KHQpe2xldCBlPXQuZ2V0R2VvbWV0cnlUeXBlKCk7Y29uc3Qgbj1rdFtlXTtlPWUudG9VcHBlckNhc2UoKTtjb25zdCBzPWZ1bmN0aW9uKHQpe2xldCBlPVwiXCI7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGU7Y29uc3Qgbj10LmdldENvb3JkaW5hdGUoKTtyZXR1cm4gdm9pZCAwPT09bi56fHxOdW1iZXIuaXNOYU4obi56KXx8KGUrPVwiWlwiKSx2b2lkIDA9PT1uLm18fE51bWJlci5pc05hTihuLm0pfHwoZSs9XCJNXCIpLGV9KHQpO2lmKHMubGVuZ3RoPjAmJihlKz1cIiBcIitzKSx0LmlzRW1wdHkoKSlyZXR1cm4gZStcIiBcIitidDtyZXR1cm4gZStcIiAoXCIrbih0KStcIilcIn1jbGFzcyBIdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgTHQsdGhpcy5wcmVjaXNpb25Nb2RlbD10aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfXJlYWQodCl7Y29uc3QgZT1uZXcgQnQodCk7cmV0dXJuIG5ldyBZdChlLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KS5wYXJzZSgpfXdyaXRlKHQpe3JldHVybiBVdCh0KX19Y2xhc3MgV3R7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEh0KHQpfXdyaXRlKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX1zdGF0aWMgdG9MaW5lU3RyaW5nKHQsZSl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO3JldHVyblwiTElORVNUUklORyAoIFwiK3QueCtcIiBcIit0LnkrXCIsIFwiK2UueCtcIiBcIitlLnkrXCIgKVwifX1jbGFzcyBadHtjb25zdHJ1Y3Rvcigpe1p0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Jlc3VsdD1udWxsLHRoaXMuX2lucHV0TGluZXM9QXJyYXkoMikuZmlsbCgpLm1hcCgoKCk9PkFycmF5KDIpKSksdGhpcy5faW50UHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5faW50TGluZUluZGV4PW51bGwsdGhpcy5faXNQcm9wZXI9bnVsbCx0aGlzLl9wYT1udWxsLHRoaXMuX3BiPW51bGwsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9pbnRQdFswXT1uZXcgbSx0aGlzLl9pbnRQdFsxXT1uZXcgbSx0aGlzLl9wYT10aGlzLl9pbnRQdFswXSx0aGlzLl9wYj10aGlzLl9pbnRQdFsxXSx0aGlzLl9yZXN1bHQ9MH1zdGF0aWMgY29tcHV0ZUVkZ2VEaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz1NYXRoLmFicyhuLngtZS54KSxpPU1hdGguYWJzKG4ueS1lLnkpO2xldCByPS0xO2lmKHQuZXF1YWxzKGUpKXI9MDtlbHNlIGlmKHQuZXF1YWxzKG4pKXI9cz5pP3M6aTtlbHNle2NvbnN0IG49TWF0aC5hYnModC54LWUueCksbz1NYXRoLmFicyh0LnktZS55KTtyPXM+aT9uOm8sMCE9PXJ8fHQuZXF1YWxzKGUpfHwocj1NYXRoLm1heChuLG8pKX1yZXR1cm4gZy5pc1RydWUoISgwPT09ciYmIXQuZXF1YWxzKGUpKSxcIkJhZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxyfXN0YXRpYyBub25Sb2J1c3RDb21wdXRlRWRnZURpc3RhbmNlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55LHI9TWF0aC5zcXJ0KHMqcytpKmkpO3JldHVybiBnLmlzVHJ1ZSghKDA9PT1yJiYhdC5lcXVhbHMoZSkpLFwiSW52YWxpZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxyfWdldEluZGV4QWxvbmdTZWdtZW50KHQsZSl7cmV0dXJuIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpLHRoaXMuX2ludExpbmVJbmRleFt0XVtlXX1nZXRUb3BvbG9neVN1bW1hcnkoKXtjb25zdCB0PW5ldyBwdDtyZXR1cm4gdGhpcy5pc0VuZFBvaW50KCkmJnQuYXBwZW5kKFwiIGVuZHBvaW50XCIpLHRoaXMuX2lzUHJvcGVyJiZ0LmFwcGVuZChcIiBwcm9wZXJcIiksdGhpcy5pc0NvbGxpbmVhcigpJiZ0LmFwcGVuZChcIiBjb2xsaW5lYXJcIiksdC50b1N0cmluZygpfWNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLG4scyl7dGhpcy5faW5wdXRMaW5lc1swXVswXT10LHRoaXMuX2lucHV0TGluZXNbMF1bMV09ZSx0aGlzLl9pbnB1dExpbmVzWzFdWzBdPW4sdGhpcy5faW5wdXRMaW5lc1sxXVsxXT1zLHRoaXMuX3Jlc3VsdD10aGlzLmNvbXB1dGVJbnRlcnNlY3QodCxlLG4scyl9Z2V0SW50ZXJzZWN0aW9uTnVtKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdH1jb21wdXRlSW50TGluZUluZGV4KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbnVsbD09PXRoaXMuX2ludExpbmVJbmRleCYmKHRoaXMuX2ludExpbmVJbmRleD1BcnJheSgyKS5maWxsKCkubWFwKCgoKT0+QXJyYXkoMikpKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMCksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDEpKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDApPnRoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMSk/KHRoaXMuX2ludExpbmVJbmRleFt0XVswXT0wLHRoaXMuX2ludExpbmVJbmRleFt0XVsxXT0xKToodGhpcy5faW50TGluZUluZGV4W3RdWzBdPTEsdGhpcy5faW50TGluZUluZGV4W3RdWzFdPTApfX1pc1Byb3Blcigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9pc1Byb3Blcn1zZXRQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9wcmVjaXNpb25Nb2RlbD10fWlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4hIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigwKXx8ISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dGhpcy5fcmVzdWx0O2UrKylpZighdGhpcy5faW50UHRbZV0uZXF1YWxzMkQodGhpcy5faW5wdXRMaW5lc1t0XVswXSkmJiF0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLl9pbnB1dExpbmVzW3RdWzFdKSlyZXR1cm4hMDtyZXR1cm4hMX19Z2V0SW50ZXJzZWN0aW9uKHQpe3JldHVybiB0aGlzLl9pbnRQdFt0XX1pc0VuZFBvaW50KCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJiF0aGlzLl9pc1Byb3Blcn1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVzdWx0IT09WnQuTk9fSU5URVJTRUNUSU9OfWdldEVkZ2VEaXN0YW5jZSh0LGUpe3JldHVybiBadC5jb21wdXRlRWRnZURpc3RhbmNlKHRoaXMuX2ludFB0W2VdLHRoaXMuX2lucHV0TGluZXNbdF1bMF0sdGhpcy5faW5wdXRMaW5lc1t0XVsxXSl9aXNDb2xsaW5lYXIoKXtyZXR1cm4gdGhpcy5fcmVzdWx0PT09WnQuQ09MTElORUFSX0lOVEVSU0VDVElPTn10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcodGhpcy5faW5wdXRMaW5lc1swXVswXSx0aGlzLl9pbnB1dExpbmVzWzBdWzFdKStcIiAtIFwiK1d0LnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzFdWzBdLHRoaXMuX2lucHV0TGluZXNbMV1bMV0pK3RoaXMuZ2V0VG9wb2xvZ3lTdW1tYXJ5KCl9Z2V0RW5kcG9pbnQodCxlKXtyZXR1cm4gdGhpcy5faW5wdXRMaW5lc1t0XVtlXX1pc0ludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9MDtlPHRoaXMuX3Jlc3VsdDtlKyspaWYodGhpcy5faW50UHRbZV0uZXF1YWxzMkQodCkpcmV0dXJuITA7cmV0dXJuITF9Z2V0SW50ZXJzZWN0aW9uQWxvbmdTZWdtZW50KHQsZSl7cmV0dXJuIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpLHRoaXMuX2ludFB0W3RoaXMuX2ludExpbmVJbmRleFt0XVtlXV19fVp0LkRPTlRfSU5URVJTRUNUPTAsWnQuRE9fSU5URVJTRUNUPTEsWnQuQ09MTElORUFSPTIsWnQuTk9fSU5URVJTRUNUSU9OPTAsWnQuUE9JTlRfSU5URVJTRUNUSU9OPTEsWnQuQ09MTElORUFSX0lOVEVSU0VDVElPTj0yO2NsYXNzIGp0IGV4dGVuZHMgWnR7Y29uc3RydWN0b3IoKXtzdXBlcigpfXN0YXRpYyBuZWFyZXN0RW5kcG9pbnQodCxlLG4scyl7bGV0IGk9dCxyPXoucG9pbnRUb1NlZ21lbnQodCxuLHMpLG89ei5wb2ludFRvU2VnbWVudChlLG4scyk7cmV0dXJuIG88ciYmKHI9byxpPWUpLG89ei5wb2ludFRvU2VnbWVudChuLHQsZSksbzxyJiYocj1vLGk9biksbz16LnBvaW50VG9TZWdtZW50KHMsdCxlKSxvPHImJihyPW8saT1zKSxpfWlzSW5TZWdtZW50RW52ZWxvcGVzKHQpe2NvbnN0IGU9bmV3IE8odGhpcy5faW5wdXRMaW5lc1swXVswXSx0aGlzLl9pbnB1dExpbmVzWzBdWzFdKSxuPW5ldyBPKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sdGhpcy5faW5wdXRMaW5lc1sxXVsxXSk7cmV0dXJuIGUuY29udGFpbnModCkmJm4uY29udGFpbnModCl9Y29tcHV0ZUludGVyc2VjdGlvbigpe2lmKDMhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBzdXBlci5jb21wdXRlSW50ZXJzZWN0aW9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodGhpcy5faXNQcm9wZXI9ITEsTy5pbnRlcnNlY3RzKGUsbix0KSYmMD09PXEuaW5kZXgoZSxuLHQpJiYwPT09cS5pbmRleChuLGUsdCkpcmV0dXJuIHRoaXMuX2lzUHJvcGVyPSEwLCh0LmVxdWFscyhlKXx8dC5lcXVhbHMobikpJiYodGhpcy5faXNQcm9wZXI9ITEpLHRoaXMuX3Jlc3VsdD1adC5QT0lOVF9JTlRFUlNFQ1RJT04sbnVsbDt0aGlzLl9yZXN1bHQ9WnQuTk9fSU5URVJTRUNUSU9OfX1pbnRlcnNlY3Rpb24odCxlLG4scyl7bGV0IGk9dGhpcy5pbnRlcnNlY3Rpb25TYWZlKHQsZSxuLHMpO3JldHVybiB0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKGkpfHwoaT1uZXcgbShqdC5uZWFyZXN0RW5kcG9pbnQodCxlLG4scykpKSxudWxsIT09dGhpcy5fcHJlY2lzaW9uTW9kZWwmJnRoaXMuX3ByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGkpLGl9Y2hlY2tERCh0LGUsbixzLGkpe2NvbnN0IHI9Ri5pbnRlcnNlY3Rpb24odCxlLG4scyksbz10aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKHIpO1kub3V0LnByaW50bG4oXCJERCBpbiBlbnYgPSBcIitvK1wiICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gXCIrciksaS5kaXN0YW5jZShyKT4xZS00JiZZLm91dC5wcmludGxuKFwiRGlzdGFuY2UgPSBcIitpLmRpc3RhbmNlKHIpKX1pbnRlcnNlY3Rpb25TYWZlKHQsZSxuLHMpe2xldCBpPUIuaW50ZXJzZWN0aW9uKHQsZSxuLHMpO3JldHVybiBudWxsPT09aSYmKGk9anQubmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpKSxpfWNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1PLmludGVyc2VjdHModCxlLG4pLHI9Ty5pbnRlcnNlY3RzKHQsZSxzKSxvPU8uaW50ZXJzZWN0cyhuLHMsdCksbD1PLmludGVyc2VjdHMobixzLGUpO3JldHVybiBpJiZyPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPXMsWnQuQ09MTElORUFSX0lOVEVSU0VDVElPTik6byYmbD8odGhpcy5faW50UHRbMF09dCx0aGlzLl9pbnRQdFsxXT1lLFp0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOmkmJm8/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09dCwhbi5lcXVhbHModCl8fHJ8fGw/WnQuQ09MTElORUFSX0lOVEVSU0VDVElPTjpadC5QT0lOVF9JTlRFUlNFQ1RJT04pOmkmJmw/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09ZSwhbi5lcXVhbHMoZSl8fHJ8fG8/WnQuQ09MTElORUFSX0lOVEVSU0VDVElPTjpadC5QT0lOVF9JTlRFUlNFQ1RJT04pOnImJm8/KHRoaXMuX2ludFB0WzBdPXMsdGhpcy5faW50UHRbMV09dCwhcy5lcXVhbHModCl8fGl8fGw/WnQuQ09MTElORUFSX0lOVEVSU0VDVElPTjpadC5QT0lOVF9JTlRFUlNFQ1RJT04pOnImJmw/KHRoaXMuX2ludFB0WzBdPXMsdGhpcy5faW50UHRbMV09ZSwhcy5lcXVhbHMoZSl8fGl8fG8/WnQuQ09MTElORUFSX0lOVEVSU0VDVElPTjpadC5QT0lOVF9JTlRFUlNFQ1RJT04pOlp0Lk5PX0lOVEVSU0VDVElPTn1jb21wdXRlSW50ZXJzZWN0KHQsZSxuLHMpe2lmKHRoaXMuX2lzUHJvcGVyPSExLCFPLmludGVyc2VjdHModCxlLG4scykpcmV0dXJuIFp0Lk5PX0lOVEVSU0VDVElPTjtjb25zdCBpPXEuaW5kZXgodCxlLG4pLHI9cS5pbmRleCh0LGUscyk7aWYoaT4wJiZyPjB8fGk8MCYmcjwwKXJldHVybiBadC5OT19JTlRFUlNFQ1RJT047Y29uc3Qgbz1xLmluZGV4KG4scyx0KSxsPXEuaW5kZXgobixzLGUpO2lmKG8+MCYmbD4wfHxvPDAmJmw8MClyZXR1cm4gWnQuTk9fSU5URVJTRUNUSU9OO3JldHVybiAwPT09aSYmMD09PXImJjA9PT1vJiYwPT09bD90aGlzLmNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24odCxlLG4scyk6KDA9PT1pfHwwPT09cnx8MD09PW98fDA9PT1sPyh0aGlzLl9pc1Byb3Blcj0hMSx0LmVxdWFsczJEKG4pfHx0LmVxdWFsczJEKHMpP3RoaXMuX2ludFB0WzBdPXQ6ZS5lcXVhbHMyRChuKXx8ZS5lcXVhbHMyRChzKT90aGlzLl9pbnRQdFswXT1lOjA9PT1pP3RoaXMuX2ludFB0WzBdPW5ldyBtKG4pOjA9PT1yP3RoaXMuX2ludFB0WzBdPW5ldyBtKHMpOjA9PT1vP3RoaXMuX2ludFB0WzBdPW5ldyBtKHQpOjA9PT1sJiYodGhpcy5faW50UHRbMF09bmV3IG0oZSkpKToodGhpcy5faXNQcm9wZXI9ITAsdGhpcy5faW50UHRbMF09dGhpcy5pbnRlcnNlY3Rpb24odCxlLG4scykpLFp0LlBPSU5UX0lOVEVSU0VDVElPTil9fWNsYXNzIEt0e2NvbnN0cnVjdG9yKCl7S3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClLdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBtLG5ldyBtKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtLdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wMD10LHRoaXMucDE9ZX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtLdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBtKHQsZSksbmV3IG0obixzKSl9fXN0YXRpYyBtaWRQb2ludCh0LGUpe3JldHVybiBuZXcgbSgodC54K2UueCkvMiwodC55K2UueSkvMil9bWluWCgpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLngsdGhpcy5wMS54KX1vcmllbnRhdGlvbkluZGV4KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1xLmluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAwKSxuPXEuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDEpO3JldHVybiBlPj0wJiZuPj0wfHxlPD0wJiZuPD0wP01hdGgubWF4KGUsbik6MH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBxLmluZGV4KHRoaXMucDAsdGhpcy5wMSx0KX19dG9HZW9tZXRyeSh0KXtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLnAwLHRoaXMucDFdKX1pc1ZlcnRpY2FsKCl7cmV0dXJuIHRoaXMucDAueD09PXRoaXMucDEueH1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgS3QpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5wMC5lcXVhbHMoZS5wMCkmJnRoaXMucDEuZXF1YWxzKGUucDEpfWludGVyc2VjdGlvbih0KXtjb25zdCBlPW5ldyBqdDtyZXR1cm4gZS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpLGUuaGFzSW50ZXJzZWN0aW9uKCk/ZS5nZXRJbnRlcnNlY3Rpb24oMCk6bnVsbH1wcm9qZWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmVxdWFscyh0aGlzLnAwKXx8dC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIG5ldyBtKHQpO2NvbnN0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpLG49bmV3IG07cmV0dXJuIG4ueD10aGlzLnAwLngrZSoodGhpcy5wMS54LXRoaXMucDAueCksbi55PXRoaXMucDAueStlKih0aGlzLnAxLnktdGhpcy5wMC55KSxufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQucDApLG49dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQucDEpO2lmKGU+PTEmJm4+PTEpcmV0dXJuIG51bGw7aWYoZTw9MCYmbjw9MClyZXR1cm4gbnVsbDtsZXQgcz10aGlzLnByb2plY3QodC5wMCk7ZTwwJiYocz10aGlzLnAwKSxlPjEmJihzPXRoaXMucDEpO2xldCBpPXRoaXMucHJvamVjdCh0LnAxKTtyZXR1cm4gbjwwJiYoaT10aGlzLnAwKSxuPjEmJihpPXRoaXMucDEpLG5ldyBLdChzLGkpfX1ub3JtYWxpemUoKXt0aGlzLnAxLmNvbXBhcmVUbyh0aGlzLnAwKTwwJiZ0aGlzLnJldmVyc2UoKX1hbmdsZSgpe3JldHVybiBNYXRoLmF0YW4yKHRoaXMucDEueS10aGlzLnAwLnksdGhpcy5wMS54LXRoaXMucDAueCl9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gMD09PXQ/dGhpcy5wMDp0aGlzLnAxfWRpc3RhbmNlUGVycGVuZGljdWxhcih0KXtyZXR1cm4gei5wb2ludFRvTGluZVBlcnBlbmRpY3VsYXIodCx0aGlzLnAwLHRoaXMucDEpfW1pblkoKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LHRoaXMucDEueSl9bWlkUG9pbnQoKXtyZXR1cm4gS3QubWlkUG9pbnQodGhpcy5wMCx0aGlzLnAxKX1wcm9qZWN0aW9uRmFjdG9yKHQpe2lmKHQuZXF1YWxzKHRoaXMucDApKXJldHVybiAwO2lmKHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiAxO2NvbnN0IGU9dGhpcy5wMS54LXRoaXMucDAueCxuPXRoaXMucDEueS10aGlzLnAwLnkscz1lKmUrbipuO2lmKHM8PTApcmV0dXJuIHIuTmFOO3JldHVybigodC54LXRoaXMucDAueCkqZSsodC55LXRoaXMucDAueSkqbikvc31jbG9zZXN0UG9pbnRzKHQpe2NvbnN0IGU9dGhpcy5pbnRlcnNlY3Rpb24odCk7aWYobnVsbCE9PWUpcmV0dXJuW2UsZV07Y29uc3Qgbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtsZXQgcz1yLk1BWF9WQUxVRSxpPW51bGw7Y29uc3Qgbz10aGlzLmNsb3Nlc3RQb2ludCh0LnAwKTtzPW8uZGlzdGFuY2UodC5wMCksblswXT1vLG5bMV09dC5wMDtjb25zdCBsPXRoaXMuY2xvc2VzdFBvaW50KHQucDEpO2k9bC5kaXN0YW5jZSh0LnAxKSxpPHMmJihzPWksblswXT1sLG5bMV09dC5wMSk7Y29uc3QgYT10LmNsb3Nlc3RQb2ludCh0aGlzLnAwKTtpPWEuZGlzdGFuY2UodGhpcy5wMCksaTxzJiYocz1pLG5bMF09dGhpcy5wMCxuWzFdPWEpO2NvbnN0IGM9dC5jbG9zZXN0UG9pbnQodGhpcy5wMSk7cmV0dXJuIGk9Yy5kaXN0YW5jZSh0aGlzLnAxKSxpPHMmJihzPWksblswXT10aGlzLnAxLG5bMV09Yyksbn1jbG9zZXN0UG9pbnQodCl7Y29uc3QgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7aWYoZT4wJiZlPDEpcmV0dXJuIHRoaXMucHJvamVjdCh0KTtyZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0KTx0aGlzLnAxLmRpc3RhbmNlKHQpP3RoaXMucDA6dGhpcy5wMX1tYXhYKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMucDAueCx0aGlzLnAxLngpfWdldExlbmd0aCgpe3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHRoaXMucDEpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQsbj10aGlzLnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0aGlzLnAxLmNvbXBhcmVUbyhlLnAxKX1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLnAwO3RoaXMucDA9dGhpcy5wMSx0aGlzLnAxPXR9ZXF1YWxzVG9wbyh0KXtyZXR1cm4gdGhpcy5wMC5lcXVhbHModC5wMCkmJnRoaXMucDEuZXF1YWxzKHQucDEpfHx0aGlzLnAwLmVxdWFscyh0LnAxKSYmdGhpcy5wMS5lcXVhbHModC5wMCl9bGluZUludGVyc2VjdGlvbih0KXtyZXR1cm4gQi5pbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSl9bWF4WSgpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLnksdGhpcy5wMS55KX1wb2ludEFsb25nT2Zmc2V0KHQsZSl7Y29uc3Qgbj10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCkscz10aGlzLnAwLnkrdCoodGhpcy5wMS55LXRoaXMucDAueSksaT10aGlzLnAxLngtdGhpcy5wMC54LHI9dGhpcy5wMS55LXRoaXMucDAueSxvPU1hdGguc3FydChpKmkrcipyKTtsZXQgbD0wLGE9MDtpZigwIT09ZSl7aWYobzw9MCl0aHJvdyBuZXcgRChcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTtsPWUqaS9vLGE9ZSpyL299cmV0dXJuIG5ldyBtKG4tYSxzK2wpfXNldENvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnAwLng9dC54LHRoaXMucDAueT10LnksdGhpcy5wMS54PWUueCx0aGlzLnAxLnk9ZS55fX1zZWdtZW50RnJhY3Rpb24odCl7bGV0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO3JldHVybiBlPDA/ZT0wOihlPjF8fHIuaXNOYU4oZSkpJiYoZT0xKSxlfXRvU3RyaW5nKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifWlzSG9yaXpvbnRhbCgpe3JldHVybiB0aGlzLnAwLnk9PT10aGlzLnAxLnl9cmVmbGVjdCh0KXtjb25zdCBlPXRoaXMucDEuZ2V0WSgpLXRoaXMucDAuZ2V0WSgpLG49dGhpcy5wMC5nZXRYKCktdGhpcy5wMS5nZXRYKCkscz10aGlzLnAwLmdldFkoKSoodGhpcy5wMS5nZXRYKCktdGhpcy5wMC5nZXRYKCkpLXRoaXMucDAuZ2V0WCgpKih0aGlzLnAxLmdldFkoKS10aGlzLnAwLmdldFkoKSksaT1lKmUrbipuLHI9ZSplLW4qbixvPXQuZ2V0WCgpLGw9dC5nZXRZKCk7cmV0dXJuIG5ldyBtKCgtcipvLTIqZSpuKmwtMiplKnMpL2ksKHIqbC0yKmUqbipvLTIqbipzKS9pKX1kaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB6LnNlZ21lbnRUb1NlZ21lbnQodGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gei5wb2ludFRvU2VnbWVudCh0LHRoaXMucDAsdGhpcy5wMSl9fXBvaW50QWxvbmcodCl7Y29uc3QgZT1uZXcgbTtyZXR1cm4gZS54PXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxlLnk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGV9aGFzaENvZGUoKXtsZXQgdD1yLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC54KTt0Xj0zMSpyLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC55KTtjb25zdCBlPU1hdGgudHJ1bmModCleTWF0aC50cnVuYyh0Pj4zMik7bGV0IG49ci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueCk7bl49MzEqci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueSk7cmV0dXJuIGVeKE1hdGgudHJ1bmMobileTWF0aC50cnVuYyhuPj4zMikpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvLGNdfX1jbGFzcyBRdHtzdGF0aWMgdG9Mb2NhdGlvblN5bWJvbCh0KXtzd2l0Y2godCl7Y2FzZSBRdC5FWFRFUklPUjpyZXR1cm5cImVcIjtjYXNlIFF0LkJPVU5EQVJZOnJldHVyblwiYlwiO2Nhc2UgUXQuSU5URVJJT1I6cmV0dXJuXCJpXCI7Y2FzZSBRdC5OT05FOnJldHVyblwiLVwifXRocm93IG5ldyBzKFwiVW5rbm93biBsb2NhdGlvbiB2YWx1ZTogXCIrdCl9fVF0LklOVEVSSU9SPTAsUXQuQk9VTkRBUlk9MSxRdC5FWFRFUklPUj0yLFF0Lk5PTkU9LTE7Y2xhc3MgSnR7Y29uc3RydWN0b3IoKXtKdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tYXRyaXg9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9tYXRyaXg9QXJyYXkoMykuZmlsbCgpLm1hcCgoKCk9PkFycmF5KDMpKSksdGhpcy5zZXRBbGwoUS5GQUxTRSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtKdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLnNldCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0p0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdPXQuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldPXQuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdPXQuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdLHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdPXQuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldPXQuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdPXQuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdLHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPXQuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldPXQuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuRVhURVJJT1JdPXQuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuRVhURVJJT1JdfX1zdGF0aWMgbWF0Y2hlcygpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGU9PT1RLlNZTV9ET05UQ0FSRXx8KGU9PT1RLlNZTV9UUlVFJiYodD49MHx8dD09PVEuVFJVRSl8fChlPT09US5TWU1fRkFMU0UmJnQ9PT1RLkZBTFNFfHwoZT09PVEuU1lNX1AmJnQ9PT1RLlB8fChlPT09US5TWU1fTCYmdD09PVEuTHx8ZT09PVEuU1lNX0EmJnQ9PT1RLkEpKSkpfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgSnQoYXJndW1lbnRzWzBdKS5tYXRjaGVzKHQpfX1zdGF0aWMgaXNUcnVlKHQpe3JldHVybiB0Pj0wfHx0PT09US5UUlVFfWlzSW50ZXJzZWN0cygpe3JldHVybiF0aGlzLmlzRGlzam9pbnQoKX1pc0NvdmVycygpe3JldHVybihKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5CT1VOREFSWV0pKSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXT09PVEuRkFMU0V9aXNDb3ZlcmVkQnkoKXtyZXR1cm4oSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldKSkmJnRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5FWFRFUklPUl09PT1RLkZBTFNFfXNldCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj1NYXRoLnRydW5jKGUvMykscz1lJTM7dGhpcy5fbWF0cml4W25dW3NdPVEudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21hdHJpeFt0XVtlXT1ufX1pc0NvbnRhaW5zKCl7cmV0dXJuIEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV09PT1RLkZBTFNFfXNldEF0TGVhc3QoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49TWF0aC50cnVuYyhlLzMpLHM9ZSUzO3RoaXMuc2V0QXRMZWFzdChuLHMsUS50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21hdHJpeFt0XVtlXTxuJiYodGhpcy5fbWF0cml4W3RdW2VdPW4pfX1zZXRBdExlYXN0SWZWYWxpZCh0LGUsbil7dD49MCYmZT49MCYmdGhpcy5zZXRBdExlYXN0KHQsZSxuKX1pc1dpdGhpbigpe3JldHVybiBKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdPT09US5GQUxTRX1pc1RvdWNoZXModCxlKXtyZXR1cm4gdD5lP3RoaXMuaXNUb3VjaGVzKGUsdCk6KHQ9PT1RLkEmJmU9PT1RLkF8fHQ9PT1RLkwmJmU9PT1RLkx8fHQ9PT1RLkwmJmU9PT1RLkF8fHQ9PT1RLlAmJmU9PT1RLkF8fHQ9PT1RLlAmJmU9PT1RLkwpJiYodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl09PT1RLkZBTFNFJiYoSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldKSkpfWlzT3ZlcmxhcHModCxlKXtyZXR1cm4gdD09PVEuUCYmZT09PVEuUHx8dD09PVEuQSYmZT09PVEuQT9KdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl0pOnQ9PT1RLkwmJmU9PT1RLkwmJigxPT09dGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0mJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXSkmJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXSkpfWlzRXF1YWxzKHQsZSl7cmV0dXJuIHQ9PT1lJiYoSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV09PT1RLkZBTFNFKX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHB0KFwiMTIzNDU2Nzg5XCIpO2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0LnNldENoYXJBdCgzKmUrbixRLnRvRGltZW5zaW9uU3ltYm9sKHRoaXMuX21hdHJpeFtlXVtuXSkpO3JldHVybiB0LnRvU3RyaW5nKCl9c2V0QWxsKHQpe2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0aGlzLl9tYXRyaXhbZV1bbl09dH1nZXQodCxlKXtyZXR1cm4gdGhpcy5fbWF0cml4W3RdW2VdfXRyYW5zcG9zZSgpe2xldCB0PXRoaXMuX21hdHJpeFsxXVswXTtyZXR1cm4gdGhpcy5fbWF0cml4WzFdWzBdPXRoaXMuX21hdHJpeFswXVsxXSx0aGlzLl9tYXRyaXhbMF1bMV09dCx0PXRoaXMuX21hdHJpeFsyXVswXSx0aGlzLl9tYXRyaXhbMl1bMF09dGhpcy5fbWF0cml4WzBdWzJdLHRoaXMuX21hdHJpeFswXVsyXT10LHQ9dGhpcy5fbWF0cml4WzJdWzFdLHRoaXMuX21hdHJpeFsyXVsxXT10aGlzLl9tYXRyaXhbMV1bMl0sdGhpcy5fbWF0cml4WzFdWzJdPXQsdGhpc31tYXRjaGVzKHQpe2lmKDkhPT10Lmxlbmd0aCl0aHJvdyBuZXcgcyhcIlNob3VsZCBiZSBsZW5ndGggOTogXCIrdCk7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKWlmKCFKdC5tYXRjaGVzKHRoaXMuX21hdHJpeFtlXVtuXSx0LmNoYXJBdCgzKmUrbikpKXJldHVybiExO3JldHVybiEwfWFkZCh0KXtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdGhpcy5zZXRBdExlYXN0KGUsbix0LmdldChlLG4pKX1pc0Rpc2pvaW50KCl7cmV0dXJuIHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldPT09US5GQUxTRX1pc0Nyb3NzZXModCxlKXtyZXR1cm4gdD09PVEuUCYmZT09PVEuTHx8dD09PVEuUCYmZT09PVEuQXx8dD09PVEuTCYmZT09PVEuQT9KdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl0pOnQ9PT1RLkwmJmU9PT1RLlB8fHQ9PT1RLkEmJmU9PT1RLlB8fHQ9PT1RLkEmJmU9PT1RLkw/SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdKTp0PT09US5MJiZlPT09US5MJiYwPT09dGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1jbGFzcyAkdHtzdGF0aWMgdG9EZWdyZWVzKHQpe3JldHVybiAxODAqdC9NYXRoLlBJfXN0YXRpYyBub3JtYWxpemUodCl7Zm9yKDt0Pk1hdGguUEk7KXQtPSR0LlBJX1RJTUVTXzI7Zm9yKDt0PD0tTWF0aC5QSTspdCs9JHQuUElfVElNRVNfMjtyZXR1cm4gdH1zdGF0aWMgYW5nbGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYXRhbjIodC55LHQueCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxzPWUueS10Lnk7cmV0dXJuIE1hdGguYXRhbjIocyxuKX19c3RhdGljIGlzQWN1dGUodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnk7cmV0dXJuIHMqKG4ueC1lLngpK2kqKG4ueS1lLnkpPjB9c3RhdGljIGlzT2J0dXNlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55O3JldHVybiBzKihuLngtZS54KStpKihuLnktZS55KTwwfXN0YXRpYyBpbnRlcmlvckFuZ2xlKHQsZSxuKXtjb25zdCBzPSR0LmFuZ2xlKGUsdCksaT0kdC5hbmdsZShlLG4pO3JldHVybiBNYXRoLmFicyhpLXMpfXN0YXRpYyBub3JtYWxpemVQb3NpdGl2ZSh0KXtpZih0PDApe2Zvcig7dDwwOyl0Kz0kdC5QSV9USU1FU18yO3Q+PSR0LlBJX1RJTUVTXzImJih0PTApfWVsc2V7Zm9yKDt0Pj0kdC5QSV9USU1FU18yOyl0LT0kdC5QSV9USU1FU18yO3Q8MCYmKHQ9MCl9cmV0dXJuIHR9c3RhdGljIGFuZ2xlQmV0d2Vlbih0LGUsbil7Y29uc3Qgcz0kdC5hbmdsZShlLHQpLGk9JHQuYW5nbGUoZSxuKTtyZXR1cm4gJHQuZGlmZihzLGkpfXN0YXRpYyBkaWZmKHQsZSl7bGV0IG49bnVsbDtyZXR1cm4gbj10PGU/ZS10OnQtZSxuPk1hdGguUEkmJihuPTIqTWF0aC5QSS1uKSxufXN0YXRpYyB0b1JhZGlhbnModCl7cmV0dXJuIHQqTWF0aC5QSS8xODB9c3RhdGljIGdldFR1cm4odCxlKXtjb25zdCBuPU1hdGguc2luKGUtdCk7cmV0dXJuIG4+MD8kdC5DT1VOVEVSQ0xPQ0tXSVNFOm48MD8kdC5DTE9DS1dJU0U6JHQuTk9ORX1zdGF0aWMgYW5nbGVCZXR3ZWVuT3JpZW50ZWQodCxlLG4pe2NvbnN0IHM9JHQuYW5nbGUoZSx0KSxpPSR0LmFuZ2xlKGUsbiktcztyZXR1cm4gaTw9LU1hdGguUEk/aSskdC5QSV9USU1FU18yOmk+TWF0aC5QST9pLSR0LlBJX1RJTUVTXzI6aX19JHQuUElfVElNRVNfMj0yKk1hdGguUEksJHQuUElfT1ZFUl8yPU1hdGguUEkvMiwkdC5QSV9PVkVSXzQ9TWF0aC5QSS80LCR0LkNPVU5URVJDTE9DS1dJU0U9cS5DT1VOVEVSQ0xPQ0tXSVNFLCR0LkNMT0NLV0lTRT1xLkNMT0NLV0lTRSwkdC5OT05FPXEuQ09MTElORUFSO2NsYXNzIHRlIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7bi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFwiUHJvamVjdGl2ZSBwb2ludCBub3QgcmVwcmVzZW50YWJsZSBvbiB0aGUgQ2FydGVzaWFuIHBsYW5lLlwiKX19Y2xhc3MgZWV7Y29uc3RydWN0b3IoKXtlZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLnc9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLng9MCx0aGlzLnk9MCx0aGlzLnc9MTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy53PTF9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQsdGhpcy55PWUsdGhpcy53PTF9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55KmUudy1lLnkqdC53LHRoaXMueT1lLngqdC53LXQueCplLncsdGhpcy53PXQueCplLnktZS54KnQueX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55LWUueSx0aGlzLnk9ZS54LXQueCx0aGlzLnc9dC54KmUueS1lLngqdC55fX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLnc9bn1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPXQueS1lLnkscj1lLngtdC54LG89dC54KmUueS1lLngqdC55LGw9bi55LXMueSxhPXMueC1uLngsYz1uLngqcy55LXMueCpuLnk7dGhpcy54PXIqYy1hKm8sdGhpcy55PWwqby1pKmMsdGhpcy53PWkqYS1sKnJ9fWdldFkoKXtjb25zdCB0PXRoaXMueS90aGlzLnc7aWYoci5pc05hTih0KXx8ci5pc0luZmluaXRlKHQpKXRocm93IG5ldyB0ZTtyZXR1cm4gdH1nZXRYKCl7Y29uc3QgdD10aGlzLngvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdGU7cmV0dXJuIHR9Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9bmV3IG07cmV0dXJuIHQueD10aGlzLmdldFgoKSx0Lnk9dGhpcy5nZXRZKCksdH19Y2xhc3MgbmV7Y29uc3RydWN0b3IoKXtuZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMucDI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLnAwPXQsdGhpcy5wMT1lLHRoaXMucDI9bn1zdGF0aWMgYXJlYSh0LGUsbil7cmV0dXJuIE1hdGguYWJzKCgobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzIpfXN0YXRpYyBzaWduZWRBcmVhKHQsZSxuKXtyZXR1cm4oKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yfXN0YXRpYyBkZXQodCxlLG4scyl7cmV0dXJuIHQqcy1lKm59c3RhdGljIGludGVycG9sYXRlWih0LGUsbixzKXtjb25zdCBpPWUueCxyPWUueSxvPW4ueC1pLGw9cy54LWksYT1uLnktcixjPXMueS1yLGg9bypjLWwqYSx1PXQueC1pLGc9dC55LXIsZD0oYyp1LWwqZykvaCxfPSgtYSp1K28qZykvaDtyZXR1cm4gZS5nZXRaKCkrZCoobi5nZXRaKCktZS5nZXRaKCkpK18qKHMuZ2V0WigpLWUuZ2V0WigpKX1zdGF0aWMgbG9uZ2VzdFNpZGVMZW5ndGgodCxlLG4pe2NvbnN0IHM9dC5kaXN0YW5jZShlKSxpPWUuZGlzdGFuY2Uobikscj1uLmRpc3RhbmNlKHQpO2xldCBvPXM7cmV0dXJuIGk+byYmKG89aSkscj5vJiYobz1yKSxvfXN0YXRpYyBjaXJjdW1jZW50cmVERCh0LGUsbil7Y29uc3Qgcz1BLnZhbHVlT2YodC54KS5zdWJ0cmFjdChuLngpLGk9QS52YWx1ZU9mKHQueSkuc3VidHJhY3Qobi55KSxyPUEudmFsdWVPZihlLngpLnN1YnRyYWN0KG4ueCksbz1BLnZhbHVlT2YoZS55KS5zdWJ0cmFjdChuLnkpLGw9QS5kZXRlcm1pbmFudChzLGkscixvKS5tdWx0aXBseSgyKSxhPXMuc3FyKCkuYWRkKGkuc3FyKCkpLGM9ci5zcXIoKS5hZGQoby5zcXIoKSksaD1BLmRldGVybWluYW50KGksYSxvLGMpLHU9QS5kZXRlcm1pbmFudChzLGEscixjKSxnPUEudmFsdWVPZihuLngpLnN1YnRyYWN0KGguZGl2aWRlKGwpKS5kb3VibGVWYWx1ZSgpLGQ9QS52YWx1ZU9mKG4ueSkuYWRkKHUuZGl2aWRlKGwpKS5kb3VibGVWYWx1ZSgpO3JldHVybiBuZXcgbShnLGQpfXN0YXRpYyBpc0FjdXRlKHQsZSxuKXtyZXR1cm4hISR0LmlzQWN1dGUodCxlLG4pJiYoISEkdC5pc0FjdXRlKGUsbix0KSYmISEkdC5pc0FjdXRlKG4sdCxlKSl9c3RhdGljIGNpcmN1bWNlbnRyZSh0LGUsbil7Y29uc3Qgcz1uLngsaT1uLnkscj10LngtcyxvPXQueS1pLGw9ZS54LXMsYT1lLnktaSxjPTIqbmUuZGV0KHIsbyxsLGEpLGg9bmUuZGV0KG8scipyK28qbyxhLGwqbCthKmEpLHU9bmUuZGV0KHIscipyK28qbyxsLGwqbCthKmEpO3JldHVybiBuZXcgbShzLWgvYyxpK3UvYyl9c3RhdGljIHBlcnBlbmRpY3VsYXJCaXNlY3Rvcih0LGUpe2NvbnN0IG49ZS54LXQueCxzPWUueS10LnksaT1uZXcgZWUodC54K24vMix0Lnkrcy8yLDEpLHI9bmV3IGVlKHQueC1zK24vMix0LnkrbitzLzIsMSk7cmV0dXJuIG5ldyBlZShpLHIpfXN0YXRpYyBhbmdsZUJpc2VjdG9yKHQsZSxuKXtjb25zdCBzPWUuZGlzdGFuY2UodCksaT1zLyhzK2UuZGlzdGFuY2UobikpLHI9bi54LXQueCxvPW4ueS10Lnk7cmV0dXJuIG5ldyBtKHQueCtpKnIsdC55K2kqbyl9c3RhdGljIGFyZWEzRCh0LGUsbil7Y29uc3Qgcz1lLngtdC54LGk9ZS55LXQueSxyPWUuZ2V0WigpLXQuZ2V0WigpLG89bi54LXQueCxsPW4ueS10LnksYT1uLmdldFooKS10LmdldFooKSxjPWkqYS1yKmwsaD1yKm8tcyphLHU9cypsLWkqbyxnPWMqYytoKmgrdSp1O3JldHVybiBNYXRoLnNxcnQoZykvMn1zdGF0aWMgY2VudHJvaWQodCxlLG4pe2NvbnN0IHM9KHQueCtlLngrbi54KS8zLGk9KHQueStlLnkrbi55KS8zO3JldHVybiBuZXcgbShzLGkpfXN0YXRpYyBpbkNlbnRyZSh0LGUsbil7Y29uc3Qgcz1lLmRpc3RhbmNlKG4pLGk9dC5kaXN0YW5jZShuKSxyPXQuZGlzdGFuY2UoZSksbz1zK2krcixsPShzKnQueCtpKmUueCtyKm4ueCkvbyxhPShzKnQueStpKmUueStyKm4ueSkvbztyZXR1cm4gbmV3IG0obCxhKX1hcmVhKCl7cmV0dXJuIG5lLmFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfXNpZ25lZEFyZWEoKXtyZXR1cm4gbmUuc2lnbmVkQXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aW50ZXJwb2xhdGVaKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBzKFwiU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC5cIik7cmV0dXJuIG5lLmludGVycG9sYXRlWih0LHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1sb25nZXN0U2lkZUxlbmd0aCgpe3JldHVybiBuZS5sb25nZXN0U2lkZUxlbmd0aCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aXNBY3V0ZSgpe3JldHVybiBuZS5pc0FjdXRlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1jaXJjdW1jZW50cmUoKXtyZXR1cm4gbmUuY2lyY3VtY2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1hcmVhM0QoKXtyZXR1cm4gbmUuYXJlYTNEKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1jZW50cm9pZCgpe3JldHVybiBuZS5jZW50cm9pZCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aW5DZW50cmUoKXtyZXR1cm4gbmUuaW5DZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfX1jbGFzcyBzZSBleHRlbmRzIG57Y29uc3RydWN0b3IoKXtzdXBlcigpLHNlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW4uY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX19Y2xhc3MgaWV7Y29uc3RydWN0b3IoKXtpZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tMDA9bnVsbCx0aGlzLl9tMDE9bnVsbCx0aGlzLl9tMDI9bnVsbCx0aGlzLl9tMTA9bnVsbCx0aGlzLl9tMTE9bnVsbCx0aGlzLl9tMTI9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvSWRlbnRpdHkoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tMDA9dFswXSx0aGlzLl9tMDE9dFsxXSx0aGlzLl9tMDI9dFsyXSx0aGlzLl9tMTA9dFszXSx0aGlzLl9tMTE9dFs0XSx0aGlzLl9tMTI9dFs1XX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgaWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0VHJhbnNmb3JtYXRpb24odCl9fWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbNV0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbNF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbM10mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3RoaXMuc2V0VHJhbnNmb3JtYXRpb24odCxlLG4scyxpLHIpfX1zdGF0aWMgdHJhbnNsYXRpb25JbnN0YW5jZSh0LGUpe2NvbnN0IG49bmV3IGllO3JldHVybiBuLnNldFRvVHJhbnNsYXRpb24odCxlKSxufXN0YXRpYyBzaGVhckluc3RhbmNlKHQsZSl7Y29uc3Qgbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9TaGVhcih0LGUpLG59c3RhdGljIHJlZmxlY3Rpb25JbnN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1JlZmxlY3Rpb24odCxlKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBpZTtyZXR1cm4gaS5zZXRUb1JlZmxlY3Rpb24odCxlLG4scyksaX19c3RhdGljIHJvdGF0aW9uSW5zdGFuY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGllLnJvdGF0aW9uSW5zdGFuY2UoTWF0aC5zaW4odCksTWF0aC5jb3ModCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1JvdGF0aW9uKHQsZSksbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIGllLnJvdGF0aW9uSW5zdGFuY2UoTWF0aC5zaW4odCksTWF0aC5jb3ModCksZSxuKX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgaWU7cmV0dXJuIGkuc2V0VG9Sb3RhdGlvbih0LGUsbixzKSxpfX1zdGF0aWMgc2NhbGVJbnN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1NjYWxlKHQsZSksbn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgaWU7cmV0dXJuIGkudHJhbnNsYXRlKC1uLC1zKSxpLnNjYWxlKHQsZSksaS50cmFuc2xhdGUobixzKSxpfX1zZXRUb1JlZmxlY3Rpb25CYXNpYyh0LGUsbixpKXtpZih0PT09biYmZT09PWkpdGhyb3cgbmV3IHMoXCJSZWZsZWN0aW9uIGxpbmUgcG9pbnRzIG11c3QgYmUgZGlzdGluY3RcIik7Y29uc3Qgcj1uLXQsbz1pLWUsbD1NYXRoLnNxcnQocipyK28qbyksYT1vL2wsYz1yL2wsaD0yKmEqYyx1PWMqYy1hKmE7cmV0dXJuIHRoaXMuX20wMD11LHRoaXMuX20wMT1oLHRoaXMuX20wMj0wLHRoaXMuX20xMD1oLHRoaXMuX20xMT0tdSx0aGlzLl9tMTI9MCx0aGlzfWdldEludmVyc2UoKXtjb25zdCB0PXRoaXMuZ2V0RGV0ZXJtaW5hbnQoKTtpZigwPT09dCl0aHJvdyBuZXcgc2UoXCJUcmFuc2Zvcm1hdGlvbiBpcyBub24taW52ZXJ0aWJsZVwiKTtjb25zdCBlPXRoaXMuX20xMS90LG49LXRoaXMuX20xMC90LHM9LXRoaXMuX20wMS90LGk9dGhpcy5fbTAwL3Qscj0odGhpcy5fbTAxKnRoaXMuX20xMi10aGlzLl9tMDIqdGhpcy5fbTExKS90LG89KC10aGlzLl9tMDAqdGhpcy5fbTEyK3RoaXMuX20xMCp0aGlzLl9tMDIpL3Q7cmV0dXJuIG5ldyBpZShlLHMscixuLGksbyl9Y29tcG9zZSh0KXtjb25zdCBlPXQuX20wMCp0aGlzLl9tMDArdC5fbTAxKnRoaXMuX20xMCxuPXQuX20wMCp0aGlzLl9tMDErdC5fbTAxKnRoaXMuX20xMSxzPXQuX20wMCp0aGlzLl9tMDIrdC5fbTAxKnRoaXMuX20xMit0Ll9tMDIsaT10Ll9tMTAqdGhpcy5fbTAwK3QuX20xMSp0aGlzLl9tMTAscj10Ll9tMTAqdGhpcy5fbTAxK3QuX20xMSp0aGlzLl9tMTEsbz10Ll9tMTAqdGhpcy5fbTAyK3QuX20xMSp0aGlzLl9tMTIrdC5fbTEyO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9bix0aGlzLl9tMDI9cyx0aGlzLl9tMTA9aSx0aGlzLl9tMTE9cix0aGlzLl9tMTI9byx0aGlzfWVxdWFscyh0KXtpZihudWxsPT09dClyZXR1cm4hMTtpZighKHQgaW5zdGFuY2VvZiBpZSkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLl9tMDA9PT1lLl9tMDAmJnRoaXMuX20wMT09PWUuX20wMSYmdGhpcy5fbTAyPT09ZS5fbTAyJiZ0aGlzLl9tMTA9PT1lLl9tMTAmJnRoaXMuX20xMT09PWUuX20xMSYmdGhpcy5fbTEyPT09ZS5fbTEyfXNldFRvU2NhbGUodCxlKXtyZXR1cm4gdGhpcy5fbTAwPXQsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTAsdGhpcy5fbTExPWUsdGhpcy5fbTEyPTAsdGhpc31pc0lkZW50aXR5KCl7cmV0dXJuIDE9PT10aGlzLl9tMDAmJjA9PT10aGlzLl9tMDEmJjA9PT10aGlzLl9tMDImJjA9PT10aGlzLl9tMTAmJjE9PT10aGlzLl9tMTEmJjA9PT10aGlzLl9tMTJ9c2NhbGUodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnNjYWxlSW5zdGFuY2UodCxlKSksdGhpc31zZXRUb0lkZW50aXR5KCl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT0wLHRoaXMuX20wMj0wLHRoaXMuX20xMD0wLHRoaXMuX20xMT0xLHRoaXMuX20xMj0wLHRoaXN9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMH1zZXRUcmFuc2Zvcm1hdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbTAwPXQuX20wMCx0aGlzLl9tMDE9dC5fbTAxLHRoaXMuX20wMj10Ll9tMDIsdGhpcy5fbTEwPXQuX20xMCx0aGlzLl9tMTE9dC5fbTExLHRoaXMuX20xMj10Ll9tMTIsdGhpc31pZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07cmV0dXJuIHRoaXMuX20wMD10LHRoaXMuX20wMT1lLHRoaXMuX20wMj1uLHRoaXMuX20xMD1zLHRoaXMuX20xMT1pLHRoaXMuX20xMj1yLHRoaXN9fXNldFRvUm90YXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2V0VG9Sb3RhdGlvbihNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSksdGhpc31pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT0tdCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9dCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9MCx0aGlzfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdGhpcy5zZXRUb1JvdGF0aW9uKE1hdGguc2luKHQpLE1hdGguY29zKHQpLGUsbiksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT0tdCx0aGlzLl9tMDI9bi1uKmUrcyp0LHRoaXMuX20xMD10LHRoaXMuX20xMT1lLHRoaXMuX20xMj1zLW4qdC1zKmUsdGhpc319Z2V0TWF0cml4RW50cmllcygpe3JldHVyblt0aGlzLl9tMDAsdGhpcy5fbTAxLHRoaXMuX20wMix0aGlzLl9tMTAsdGhpcy5fbTExLHRoaXMuX20xMl19ZmlsdGVyKHQsZSl7dGhpcy50cmFuc2Zvcm0odCxlKX1yb3RhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQpKSx0aGlzfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJvdGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc31pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQsZSxuKSksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQsZSxuLHMpKSx0aGlzfX1nZXREZXRlcm1pbmFudCgpe3JldHVybiB0aGlzLl9tMDAqdGhpcy5fbTExLXRoaXMuX20wMSp0aGlzLl9tMTB9Y29tcG9zZUJlZm9yZSh0KXtjb25zdCBlPXRoaXMuX20wMCp0Ll9tMDArdGhpcy5fbTAxKnQuX20xMCxuPXRoaXMuX20wMCp0Ll9tMDErdGhpcy5fbTAxKnQuX20xMSxzPXRoaXMuX20wMCp0Ll9tMDIrdGhpcy5fbTAxKnQuX20xMit0aGlzLl9tMDIsaT10aGlzLl9tMTAqdC5fbTAwK3RoaXMuX20xMSp0Ll9tMTAscj10aGlzLl9tMTAqdC5fbTAxK3RoaXMuX20xMSp0Ll9tMTEsbz10aGlzLl9tMTAqdC5fbTAyK3RoaXMuX20xMSp0Ll9tMTIrdGhpcy5fbTEyO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9bix0aGlzLl9tMDI9cyx0aGlzLl9tMTA9aSx0aGlzLl9tMTE9cix0aGlzLl9tMTI9byx0aGlzfXNldFRvU2hlYXIodCxlKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPXQsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPWUsdGhpcy5fbTExPTEsdGhpcy5fbTEyPTAsdGhpc31pc0RvbmUoKXtyZXR1cm4hMX1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBuKSl0aHJvdyB0O2cuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbnVsbH10cmFuc2xhdGUodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnRyYW5zbGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc31zZXRUb1JlZmxlY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBzKFwiUmVmbGVjdGlvbiB2ZWN0b3IgbXVzdCBiZSBub24temVyb1wiKTtpZih0PT09ZSlyZXR1cm4gdGhpcy5fbTAwPTAsdGhpcy5fbTAxPTEsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTEsdGhpcy5fbTExPTAsdGhpcy5fbTEyPTAsdGhpcztjb25zdCBuPU1hdGguc3FydCh0KnQrZSplKSxpPWUvbixyPXQvbjtyZXR1cm4gdGhpcy5yb3RhdGUoLWksciksdGhpcy5zY2FsZSgxLC0xKSx0aGlzLnJvdGF0ZShpLHIpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO2lmKHQ9PT1uJiZlPT09aSl0aHJvdyBuZXcgcyhcIlJlZmxlY3Rpb24gbGluZSBwb2ludHMgbXVzdCBiZSBkaXN0aW5jdFwiKTt0aGlzLnNldFRvVHJhbnNsYXRpb24oLXQsLWUpO2NvbnN0IHI9bi10LG89aS1lLGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9by9sLGM9ci9sO3JldHVybiB0aGlzLnJvdGF0ZSgtYSxjKSx0aGlzLnNjYWxlKDEsLTEpLHRoaXMucm90YXRlKGEsYyksdGhpcy50cmFuc2xhdGUodCxlKSx0aGlzfX10b1N0cmluZygpe3JldHVyblwiQWZmaW5lVHJhbnNmb3JtYXRpb25bW1wiK3RoaXMuX20wMCtcIiwgXCIrdGhpcy5fbTAxK1wiLCBcIit0aGlzLl9tMDIrXCJdLCBbXCIrdGhpcy5fbTEwK1wiLCBcIit0aGlzLl9tMTErXCIsIFwiK3RoaXMuX20xMitcIl1dXCJ9c2V0VG9UcmFuc2xhdGlvbih0LGUpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9dCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9ZSx0aGlzfXNoZWFyKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShpZS5zaGVhckluc3RhbmNlKHQsZSkpLHRoaXN9dHJhbnNmb3JtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmNvcHkoKTtyZXR1cm4gdC5hcHBseSh0aGlzKSx0fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9tMDAqdC54K3RoaXMuX20wMSp0LnkrdGhpcy5fbTAyLHM9dGhpcy5fbTEwKnQueCt0aGlzLl9tMTEqdC55K3RoaXMuX20xMjtyZXR1cm4gZS54PW4sZS55PXMsZX1pZihJKGFyZ3VtZW50c1swXSxHKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX20wMCp0LmdldE9yZGluYXRlKGUsMCkrdGhpcy5fbTAxKnQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLl9tMDIscz10aGlzLl9tMTAqdC5nZXRPcmRpbmF0ZShlLDApK3RoaXMuX20xMSp0LmdldE9yZGluYXRlKGUsMSkrdGhpcy5fbTEyO3Quc2V0T3JkaW5hdGUoZSwwLG4pLHQuc2V0T3JkaW5hdGUoZSwxLHMpfX19cmVmbGVjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJlZmxlY3Rpb25JbnN0YW5jZSh0LGUpKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJlZmxlY3Rpb25JbnN0YW5jZSh0LGUsbixzKSksdGhpc319Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2wsUF19fWNsYXNzIHJle3N0YXRpYyBzb2x2ZSh0LGUpe2NvbnN0IG49ZS5sZW5ndGg7aWYodC5sZW5ndGghPT1ufHx0WzBdLmxlbmd0aCE9PW4pdGhyb3cgbmV3IHMoXCJNYXRyaXggQSBpcyBpbmNvcnJlY3RseSBzaXplZFwiKTtmb3IobGV0IHM9MDtzPG47cysrKXtsZXQgaT1zO2ZvcihsZXQgZT1zKzE7ZTxuO2UrKylNYXRoLmFicyh0W2VdW3NdKT5NYXRoLmFicyh0W2ldW3NdKSYmKGk9ZSk7aWYoMD09PXRbaV1bc10pcmV0dXJuIG51bGw7cmUuc3dhcFJvd3ModCxzLGkpLHJlLnN3YXBSb3dzKGUscyxpKTtmb3IobGV0IGk9cysxO2k8bjtpKyspe2NvbnN0IHI9dFtpXVtzXS90W3NdW3NdO2ZvcihsZXQgZT1uLTE7ZT49cztlLS0pdFtpXVtlXS09dFtzXVtlXSpyO2VbaV0tPWVbc10qcn19Y29uc3QgaT1uZXcgQXJyYXkobikuZmlsbChudWxsKTtmb3IobGV0IHM9bi0xO3M+PTA7cy0tKXtsZXQgcj0wO2ZvcihsZXQgZT1zKzE7ZTxuO2UrKylyKz10W3NdW2VdKmlbZV07aVtzXT0oZVtzXS1yKS90W3NdW3NdfXJldHVybiBpfXN0YXRpYyBzd2FwUm93cygpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IobGV0IHM9MDtzPHRbMF0ubGVuZ3RoO3MrKyl7Y29uc3QgaT10W2VdW3NdO3RbZV1bc109dFtuXVtzXSx0W25dW3NdPWl9fWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGU9PT1uKXJldHVybiBudWxsO2NvbnN0IHM9dFtlXTt0W2VdPXRbbl0sdFtuXT1zfX19Y2xhc3Mgb2V7Y29uc3RydWN0b3IoKXtvZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zcmMwPW51bGwsdGhpcy5fc3JjMT1udWxsLHRoaXMuX3NyYzI9bnVsbCx0aGlzLl9kZXN0MD1udWxsLHRoaXMuX2Rlc3QxPW51bGwsdGhpcy5fZGVzdDI9bnVsbCx0aGlzLl9tMDA9bnVsbCx0aGlzLl9tMDE9bnVsbCx0aGlzLl9tMDI9bnVsbCx0aGlzLl9tMTA9bnVsbCx0aGlzLl9tMTE9bnVsbCx0aGlzLl9tMTI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0aGlzLl9zcmMwPXQsdGhpcy5fc3JjMT1lLHRoaXMuX3NyYzI9bix0aGlzLl9kZXN0MD1zLHRoaXMuX2Rlc3QxPWksdGhpcy5fZGVzdDI9cn1zb2x2ZSh0KXtjb25zdCBlPVtbdGhpcy5fc3JjMC54LHRoaXMuX3NyYzAueSwxXSxbdGhpcy5fc3JjMS54LHRoaXMuX3NyYzEueSwxXSxbdGhpcy5fc3JjMi54LHRoaXMuX3NyYzIueSwxXV07cmV0dXJuIHJlLnNvbHZlKGUsdCl9Y29tcHV0ZSgpe2NvbnN0IHQ9W3RoaXMuX2Rlc3QwLngsdGhpcy5fZGVzdDEueCx0aGlzLl9kZXN0Mi54XSxlPXRoaXMuc29sdmUodCk7aWYobnVsbD09PWUpcmV0dXJuITE7dGhpcy5fbTAwPWVbMF0sdGhpcy5fbTAxPWVbMV0sdGhpcy5fbTAyPWVbMl07Y29uc3Qgbj1bdGhpcy5fZGVzdDAueSx0aGlzLl9kZXN0MS55LHRoaXMuX2Rlc3QyLnldLHM9dGhpcy5zb2x2ZShuKTtyZXR1cm4gbnVsbCE9PXMmJih0aGlzLl9tMTA9c1swXSx0aGlzLl9tMTE9c1sxXSx0aGlzLl9tMTI9c1syXSwhMCl9Z2V0VHJhbnNmb3JtYXRpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCk/bmV3IGllKHRoaXMuX20wMCx0aGlzLl9tMDEsdGhpcy5fbTAyLHRoaXMuX20xMCx0aGlzLl9tMTEsdGhpcy5fbTEyKTpudWxsfX1jbGFzcyBsZXtzdGF0aWMgY3JlYXRlRnJvbUJhc2VMaW5lcyh0LGUsbixzKXtjb25zdCBpPW5ldyBtKHQueCtzLngtbi54LHQueStzLnktbi55KSxyPSR0LmFuZ2xlQmV0d2Vlbk9yaWVudGVkKGUsdCxpKSxvPWUuZGlzdGFuY2UodCksbD1zLmRpc3RhbmNlKG4pO2lmKDA9PT1vKXJldHVybiBuZXcgaWU7Y29uc3QgYT1sL28sYz1pZS50cmFuc2xhdGlvbkluc3RhbmNlKC10LngsLXQueSk7cmV0dXJuIGMucm90YXRlKHIpLGMuc2NhbGUoYSxhKSxjLnRyYW5zbGF0ZShuLngsbi55KSxjfXN0YXRpYyBjcmVhdGVGcm9tQ29udHJvbFZlY3RvcnMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxzPWUueS10Lnk7cmV0dXJuIGllLnRyYW5zbGF0aW9uSW5zdGFuY2UobixzKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBzKFwiU3JjIGFuZCBEZXN0IGFycmF5cyBhcmUgbm90IHRoZSBzYW1lIGxlbmd0aFwiKTtpZih0Lmxlbmd0aDw9MCl0aHJvdyBuZXcgcyhcIlRvbyBmZXcgY29udHJvbCBwb2ludHNcIik7aWYodC5sZW5ndGg+Myl0aHJvdyBuZXcgcyhcIlRvbyBtYW55IGNvbnRyb2wgcG9pbnRzXCIpO3JldHVybiAxPT09dC5sZW5ndGg/bGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sZVswXSk6Mj09PXQubGVuZ3RoP2xlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLHRbMV0sZVswXSxlWzFdKTpsZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSx0WzFdLHRbMl0sZVswXSxlWzFdLGVbMl0pfX1lbHNle2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBtKHMueC1uLngscy55LW4ueSkscj0kdC5hbmdsZUJldHdlZW5PcmllbnRlZChlLHQsaSksbz1lLmRpc3RhbmNlKHQpLGw9cy5kaXN0YW5jZShuKTtpZigwPT09bylyZXR1cm4gbnVsbDtjb25zdCBhPWwvbyxjPWllLnRyYW5zbGF0aW9uSW5zdGFuY2UoLXQueCwtdC55KTtyZXR1cm4gYy5yb3RhdGUociksYy5zY2FsZShhLGEpLGMudHJhbnNsYXRlKG4ueCxuLnkpLGN9aWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgb2UoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0pLmdldFRyYW5zZm9ybWF0aW9uKCl9fX19Y2xhc3MgYWV7Y29uc3RydWN0b3IoKXthZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb29yZHM9dH1zdGF0aWMgZ2V0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgTDtyZXR1cm4gdC5hcHBseShuZXcgYWUoZSkpLGV9ZmlsdGVyKHQpeyh0IGluc3RhbmNlb2YgJHx8dCBpbnN0YW5jZW9mIGV0KSYmdGhpcy5fY29vcmRzLmFkZCh0LmdldENvb3JkaW5hdGUoKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfX1jbGFzcyBjZXtjb25zdHJ1Y3Rvcigpe2NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21hcE9wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWFwT3A9dH1zdGF0aWMgbWFwKHQsZSl7cmV0dXJuIG5ldyBjZShlKS5tYXAodCl9bWFwKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dGhpcy5fbWFwT3AubWFwKHQuZ2V0R2VvbWV0cnlOKG4pKTtzLmlzRW1wdHkoKXx8ZS5hZGQocyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihMdC50b0dlb21ldHJ5QXJyYXkoZSkpfX1jbGFzcyBoZXtjb25zdHJ1Y3Rvcigpe2hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5fc2tpcEVtcHR5PSExLHRoaXMuX2lucHV0R2VvbXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdG9yeT1oZS5leHRyYWN0RmFjdG9yeSh0KSx0aGlzLl9pbnB1dEdlb21zPXR9c3RhdGljIGNvbWJpbmUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBoZShhcmd1bWVudHNbMF0pLmNvbWJpbmUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBoZShoZS5jcmVhdGVMaXN0KHQsZSkpLmNvbWJpbmUoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBoZShoZS5jcmVhdGVMaXN0KHQsZSxuKSkuY29tYmluZSgpfX1zdGF0aWMgZXh0cmFjdEZhY3RvcnkodCl7cmV0dXJuIHQuaXNFbXB0eSgpP251bGw6dC5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCl9c3RhdGljIGNyZWF0ZUxpc3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtyZXR1cm4gbi5hZGQodCksbi5hZGQoZSksbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgTDtyZXR1cm4gcy5hZGQodCkscy5hZGQoZSkscy5hZGQobiksc319ZXh0cmFjdEVsZW1lbnRzKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7dGhpcy5fc2tpcEVtcHR5JiZzLmlzRW1wdHkoKXx8ZS5hZGQocyl9fWNvbWJpbmUoKXtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT10aGlzLl9pbnB1dEdlb21zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuZXh0cmFjdEVsZW1lbnRzKG4sdCl9cmV0dXJuIDA9PT10LnNpemUoKT9udWxsIT09dGhpcy5fZ2VvbUZhY3Rvcnk/dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6bnVsbDp0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHQpfX1jbGFzcyB1ZXtjb25zdHJ1Y3Rvcigpe3VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9pc1VzZXJEYXRhQ29waWVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9fXNldENvcHlVc2VyRGF0YSh0KXt0aGlzLl9pc1VzZXJEYXRhQ29waWVkPXR9ZWRpdCh0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5lZGl0SW50ZXJuYWwodCxlKTtyZXR1cm4gdGhpcy5faXNVc2VyRGF0YUNvcGllZCYmbi5zZXRVc2VyRGF0YSh0LmdldFVzZXJEYXRhKCkpLG59ZWRpdEludGVybmFsKHQsZSl7cmV0dXJuIG51bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdCBpbnN0YW5jZW9mIGh0P3RoaXMuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpOnQgaW5zdGFuY2VvZiBydD90aGlzLmVkaXRQb2x5Z29uKHQsZSk6dCBpbnN0YW5jZW9mIGV0fHx0IGluc3RhbmNlb2YgJD9lLmVkaXQodCx0aGlzLl9mYWN0b3J5KTooZy5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuc3VwcG9ydGVkIEdlb21ldHJ5IHR5cGU6IFwiK3QuZ2V0R2VvbWV0cnlUeXBlKCkpLG51bGwpfWVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPWUuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpLHM9bmV3IEw7Zm9yKGxldCB0PTA7dDxuLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IGk9dGhpcy5lZGl0KG4uZ2V0R2VvbWV0cnlOKHQpLGUpO251bGw9PT1pfHxpLmlzRW1wdHkoKXx8cy5hZGQoaSl9cmV0dXJuIG4uZ2V0R2VvbWV0cnlUeXBlKCk9PT1VLlRZUEVOQU1FX01VTFRJUE9JTlQ/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KHMudG9BcnJheShbXSkpOm4uZ2V0R2VvbWV0cnlUeXBlKCk9PT1VLlRZUEVOQU1FX01VTFRJTElORVNUUklORz90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhzLnRvQXJyYXkoW10pKTpuLmdldEdlb21ldHJ5VHlwZSgpPT09VS5UWVBFTkFNRV9NVUxUSVBPTFlHT04/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24ocy50b0FycmF5KFtdKSk6dGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24ocy50b0FycmF5KFtdKSl9ZWRpdFBvbHlnb24odCxlKXtsZXQgbj1lLmVkaXQodCx0aGlzLl9mYWN0b3J5KTtpZihudWxsPT09biYmKG49dGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCkpLG4uaXNFbXB0eSgpKXJldHVybiBuO2NvbnN0IHM9dGhpcy5lZGl0KG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSk7aWYobnVsbD09PXN8fHMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTtjb25zdCBpPW5ldyBMO2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1JbnRlcmlvclJpbmcoKTt0Kyspe2NvbnN0IHM9dGhpcy5lZGl0KG4uZ2V0SW50ZXJpb3JSaW5nTih0KSxlKTtudWxsPT09c3x8cy5pc0VtcHR5KCl8fGkuYWRkKHMpfXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24ocyxpLnRvQXJyYXkoW10pKX19ZnVuY3Rpb24gZ2UoKXt9dWUuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb249Z2U7dWUuTm9PcEdlb21ldHJ5T3BlcmF0aW9uPWNsYXNze2VkaXQodCxlKXtyZXR1cm4gdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ2VdfX0sdWUuQ29vcmRpbmF0ZU9wZXJhdGlvbj1jbGFzc3tlZGl0KHQsZSl7Y29uc3Qgbj10aGlzLmVkaXQodC5nZXRDb29yZGluYXRlcygpLHQpO3JldHVybiB0IGluc3RhbmNlb2YgZ3Q/bnVsbD09PW4/ZS5jcmVhdGVMaW5lYXJSaW5nKCk6ZS5jcmVhdGVMaW5lYXJSaW5nKG4pOnQgaW5zdGFuY2VvZiAkP251bGw9PT1uP2UuY3JlYXRlTGluZVN0cmluZygpOmUuY3JlYXRlTGluZVN0cmluZyhuKTp0IGluc3RhbmNlb2YgZXQ/bnVsbD09PW58fDA9PT1uLmxlbmd0aD9lLmNyZWF0ZVBvaW50KCk6ZS5jcmVhdGVQb2ludChuWzBdKTp0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnZV19fSx1ZS5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb249Y2xhc3N7ZWRpdCh0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgZ3Q/ZS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgJD9lLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnQgaW5zdGFuY2VvZiBldD9lLmNyZWF0ZVBvaW50KHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnZV19fTtjbGFzcyBkZXtjb25zdHJ1Y3Rvcigpe2RlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21ldHJ5VHlwZT1udWxsLHRoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbWV0cnlUeXBlPXQsdGhpcy5fY29tcHM9ZX1zdGF0aWMgaXNPZlR5cGUodCxlKXtyZXR1cm4gdC5nZXRHZW9tZXRyeVR5cGUoKT09PWV8fGU9PT1VLlRZUEVOQU1FX0xJTkVTVFJJTkcmJnQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1VLlRZUEVOQU1FX0xJTkVBUlJJTkd9c3RhdGljIGV4dHJhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGRlLmV4dHJhY3QodCxlLG5ldyBMKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1lP24uYWRkKHQpOnQgaW5zdGFuY2VvZiBodCYmdC5hcHBseShuZXcgZGUoZSxuKSksbn19ZmlsdGVyKHQpeyhudWxsPT09dGhpcy5fZ2VvbWV0cnlUeXBlfHxkZS5pc09mVHlwZSh0LHRoaXMuX2dlb21ldHJ5VHlwZSkpJiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pdfX1jbGFzcyBfZXtzdGF0aWMgbWFwKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVJiZJKGFyZ3VtZW50c1sxXSxwZSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7Zm9yKGxldCBzPTA7czx0LmdldE51bUdlb21ldHJpZXMoKTtzKyspe2NvbnN0IGk9ZS5tYXAodC5nZXRHZW9tZXRyeU4ocykpO251bGwhPT1pJiZuLmFkZChpKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShuKX1pZihJKGFyZ3VtZW50c1swXSxOKSYmSShhcmd1bWVudHNbMV0scGUpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9ZS5tYXAodCk7bnVsbCE9PWkmJm4uYWRkKGkpfXJldHVybiBufX19ZnVuY3Rpb24gcGUoKXt9X2UuTWFwT3A9cGU7Y2xhc3MgbWV7Y29uc3RydWN0b3IoKXttZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5PSEwLHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT0hMCx0aGlzLl9wcmVzZXJ2ZUNvbGxlY3Rpb25zPSExLHRoaXMuX3ByZXNlcnZlVHlwZT0hMX10cmFuc2Zvcm1Qb2ludCh0LGUpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9dHJhbnNmb3JtUG9seWdvbih0LGUpe2xldCBuPSEwO2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksdCk7bnVsbCE9PXMmJnMgaW5zdGFuY2VvZiBndCYmIXMuaXNFbXB0eSgpfHwobj0hMSk7Y29uc3QgaT1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEludGVyaW9yUmluZ04oZSksdCk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHwocyBpbnN0YW5jZW9mIGd0fHwobj0hMSksaS5hZGQocykpfWlmKG4pcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzLGkudG9BcnJheShbXSkpO3tjb25zdCB0PW5ldyBMO3JldHVybiBudWxsIT09cyYmdC5hZGQocyksdC5hZGRBbGwoaSksdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHQpfX1jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UodCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KX1nZXRJbnB1dEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbX10cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcodCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe3JldHVybiB0aGlzLmNvcHkodCl9dHJhbnNmb3JtTGluZVN0cmluZyh0LGUpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX10cmFuc2Zvcm1NdWx0aVBvaW50KHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybVBvaW50KHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfWNvcHkodCl7cmV0dXJuIHQuY29weSgpfXRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm0odC5nZXRHZW9tZXRyeU4oZSkpO251bGwhPT1zJiYodGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5JiZzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU/dGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oTHQudG9HZW9tZXRyeUFycmF5KG4pKTp0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtKHQpe2lmKHRoaXMuX2lucHV0R2VvbT10LHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksdCBpbnN0YW5jZW9mIGV0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIHV0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgZ3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiAkKXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgU3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIHJ0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgeXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGh0KXJldHVybiB0aGlzLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LG51bGwpO3Rocm93IG5ldyBzKFwiVW5rbm93biBHZW9tZXRyeSBzdWJ0eXBlOiBcIit0LmdldEdlb21ldHJ5VHlwZSgpKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj10aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCk7aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhudWxsKTtjb25zdCBzPW4uc2l6ZSgpO3JldHVybiBzPjAmJnM8NCYmIXRoaXMuX3ByZXNlcnZlVHlwZT90aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobik6dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4pfX1jbGFzcyBmZXtjb25zdHJ1Y3Rvcigpe2ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcHM9dH1zdGF0aWMgZ2V0R2VvbWV0cnkodCl7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoZmUuZ2V0TGluZXModCkpfXN0YXRpYyBnZXRMaW5lcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gZmUuZ2V0TGluZXModCxuZXcgTCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgJD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgaHQmJnQuYXBwbHkobmV3IGZlKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mICQmJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSl19fWNsYXNzIHlle2NvbnN0cnVjdG9yKCl7eWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGluZXM9bnVsbCx0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz0hMSwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZXM9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9saW5lcz10LHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPWV9fXN0YXRpYyBnZXRHZW9tZXRyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh5ZS5nZXRMaW5lcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHllLmdldExpbmVzKHQsZSkpfX1zdGF0aWMgZ2V0TGluZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHllLmdldExpbmVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxOKSYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7eWUuZ2V0TGluZXMobix0KX1yZXR1cm4gdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO3JldHVybiB0LmFwcGx5KG5ldyB5ZShuLGUpKSxufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgJD9lLmFkZCh0KTp0LmFwcGx5KG5ldyB5ZShlKSksZX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJkkoYXJndW1lbnRzWzBdLE4pJiZJKGFyZ3VtZW50c1sxXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl07Zm9yKGxldCBuPWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTt5ZS5nZXRMaW5lcyhzLHQsZSl9cmV0dXJuIHR9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO3JldHVybiBhcmd1bWVudHNbMF0uYXBwbHkobmV3IHllKHQsZSkpLHR9fX1maWx0ZXIodCl7aWYodGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcmJnQgaW5zdGFuY2VvZiBndCl7Y29uc3QgZT10LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0aGlzLl9saW5lcy5hZGQoZSksbnVsbH10IGluc3RhbmNlb2YgJCYmdGhpcy5fbGluZXMuYWRkKHQpfXNldEZvcmNlVG9MaW5lU3RyaW5nKHQpe3RoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfX1jb25zdCB4ZT17cmV2ZXJzZU9yZGVyOmZ1bmN0aW9uKCl7cmV0dXJue2NvbXBhcmU6KHQsZSk9PmUuY29tcGFyZVRvKHQpfX0sbWluOmZ1bmN0aW9uKHQpe3JldHVybiB4ZS5zb3J0KHQpLHQuZ2V0KDApfSxzb3J0OmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10LnRvQXJyYXkoKTtlP3N0LnNvcnQobixlKTpzdC5zb3J0KG4pO2NvbnN0IHM9dC5pdGVyYXRvcigpO2ZvcihsZXQgdD0wLGU9bi5sZW5ndGg7dDxlO3QrKylzLm5leHQoKSxzLnNldChuW3RdKX0sc2luZ2xldG9uTGlzdDpmdW5jdGlvbih0KXtjb25zdCBlPW5ldyBMO3JldHVybiBlLmFkZCh0KSxlfX07Y2xhc3MgRWV7Y29uc3RydWN0b3IoKXtFZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dH1zdGF0aWMgZ2V0UG9pbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0IGluc3RhbmNlb2YgZXQ/eGUuc2luZ2xldG9uTGlzdCh0KTpFZS5nZXRQb2ludHModCxuZXcgTCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgZXQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIGh0JiZ0LmFwcGx5KG5ldyBFZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBldCYmdGhpcy5fcHRzLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSl19fWNsYXNzIElle2NvbnN0cnVjdG9yKCl7SWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wcz10fXN0YXRpYyBnZXRQb2x5Z29ucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gSWUuZ2V0UG9seWdvbnModCxuZXcgTCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgcnQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIGh0JiZ0LmFwcGx5KG5ldyBJZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBydCYmdGhpcy5fY29tcHMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKXX19Y2xhc3MgTmV7Y29uc3RydWN0b3IoKXtOZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0RvbmU9ITF9YXBwbHlUbyh0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpJiYhdGhpcy5faXNEb25lO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZihuIGluc3RhbmNlb2YgaHQpdGhpcy5hcHBseVRvKG4pO2Vsc2UgaWYodGhpcy52aXNpdChuKSx0aGlzLmlzRG9uZSgpKXJldHVybiB0aGlzLl9pc0RvbmU9ITAsbnVsbH19fWNsYXNzIHdle2NvbnN0cnVjdG9yKCl7d2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9wcmVjTW9kZWw9bnVsbCx0aGlzLl9kaW09bmV3IENlLHRoaXMuX25QdHM9MTAwLHRoaXMuX3JvdGF0aW9uQW5nbGU9MCwwPT09YXJndW1lbnRzLmxlbmd0aCl3ZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBMdCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Q9dCx0aGlzLl9wcmVjTW9kZWw9dC5nZXRQcmVjaXNpb25Nb2RlbCgpfX1jcmVhdGVTdXBlcmNpcmNsZSh0KXtjb25zdCBlPTEvdCxuPXRoaXMuX2RpbS5nZXRNaW5TaXplKCkvMixzPXRoaXMuX2RpbS5nZXRDZW50cmUoKSxpPU1hdGgucG93KG4sdCkscj1uLG89TWF0aC5wb3coaS8yLGUpLGw9TWF0aC50cnVuYyh0aGlzLl9uUHRzLzgpLGE9bmV3IEFycmF5KDgqbCsxKS5maWxsKG51bGwpLGM9by9sO2ZvcihsZXQgbj0wO248PWw7bisrKXtsZXQgbz0wLGg9cjtpZigwIT09bil7bz1jKm47Y29uc3Qgcz1NYXRoLnBvdyhvLHQpO2g9TWF0aC5wb3coaS1zLGUpfWFbbl09dGhpcy5jb29yZFRyYW5zKG8saCxzKSxhWzIqbC1uXT10aGlzLmNvb3JkVHJhbnMoaCxvLHMpLGFbMipsK25dPXRoaXMuY29vcmRUcmFucyhoLC1vLHMpLGFbNCpsLW5dPXRoaXMuY29vcmRUcmFucyhvLC1oLHMpLGFbNCpsK25dPXRoaXMuY29vcmRUcmFucygtbywtaCxzKSxhWzYqbC1uXT10aGlzLmNvb3JkVHJhbnMoLWgsLW8scyksYVs2Kmwrbl09dGhpcy5jb29yZFRyYW5zKC1oLG8scyksYVs4Kmwtbl09dGhpcy5jb29yZFRyYW5zKC1vLGgscyl9YVthLmxlbmd0aC0xXT1uZXcgbShhWzBdKTtjb25zdCBoPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcoYSksdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGgpO3JldHVybiB0aGlzLnJvdGF0ZSh1KX1zZXROdW1Qb2ludHModCl7dGhpcy5fblB0cz10fXNldEJhc2UodCl7dGhpcy5fZGltLnNldEJhc2UodCl9c2V0Um90YXRpb24odCl7dGhpcy5fcm90YXRpb25BbmdsZT10fXNldFdpZHRoKHQpe3RoaXMuX2RpbS5zZXRXaWR0aCh0KX1jcmVhdGVFbGxpcHNlKCl7Y29uc3QgdD10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxlPXQuZ2V0V2lkdGgoKS8yLG49dC5nZXRIZWlnaHQoKS8yLHM9dC5nZXRNaW5YKCkrZSxpPXQuZ2V0TWluWSgpK24scj1uZXcgQXJyYXkodGhpcy5fblB0cysxKS5maWxsKG51bGwpO2xldCBvPTA7Zm9yKGxldCB0PTA7dDx0aGlzLl9uUHRzO3QrKyl7Y29uc3QgbD10KigyKk1hdGguUEkvdGhpcy5fblB0cyksYT1lKk1hdGguY29zKGwpK3MsYz1uKk1hdGguc2luKGwpK2k7cltvKytdPXRoaXMuY29vcmQoYSxjKX1yW29dPW5ldyBtKHJbMF0pO2NvbnN0IGw9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhyKSxhPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24obCk7cmV0dXJuIHRoaXMucm90YXRlKGEpfWNvb3JkVHJhbnModCxlLG4pe3JldHVybiB0aGlzLmNvb3JkKHQrbi54LGUrbi55KX1jcmVhdGVTcXVpcmNsZSgpe3JldHVybiB0aGlzLmNyZWF0ZVN1cGVyY2lyY2xlKDQpfXNldEVudmVsb3BlKHQpe3RoaXMuX2RpbS5zZXRFbnZlbG9wZSh0KX1zZXRDZW50cmUodCl7dGhpcy5fZGltLnNldENlbnRyZSh0KX1jcmVhdGVBcmModCxlKXtjb25zdCBuPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLHM9bi5nZXRXaWR0aCgpLzIsaT1uLmdldEhlaWdodCgpLzIscj1uLmdldE1pblgoKStzLG89bi5nZXRNaW5ZKCkraTtsZXQgbD1lOyhsPD0wfHxsPjIqTWF0aC5QSSkmJihsPTIqTWF0aC5QSSk7Y29uc3QgYT1sLyh0aGlzLl9uUHRzLTEpLGM9bmV3IEFycmF5KHRoaXMuX25QdHMpLmZpbGwobnVsbCk7bGV0IGg9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25QdHM7ZSsrKXtjb25zdCBuPXQrZSphLGw9cypNYXRoLmNvcyhuKStyLHU9aSpNYXRoLnNpbihuKStvO2NbaCsrXT10aGlzLmNvb3JkKGwsdSl9Y29uc3QgdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lU3RyaW5nKGMpO3JldHVybiB0aGlzLnJvdGF0ZSh1KX1yb3RhdGUodCl7aWYoMCE9PXRoaXMuX3JvdGF0aW9uQW5nbGUpe2NvbnN0IGU9aWUucm90YXRpb25JbnN0YW5jZSh0aGlzLl9yb3RhdGlvbkFuZ2xlLHRoaXMuX2RpbS5nZXRDZW50cmUoKS54LHRoaXMuX2RpbS5nZXRDZW50cmUoKS55KTt0LmFwcGx5KGUpfXJldHVybiB0fWNvb3JkKHQsZSl7Y29uc3Qgbj1uZXcgbSh0LGUpO3JldHVybiB0aGlzLl9wcmVjTW9kZWwubWFrZVByZWNpc2Uobiksbn1jcmVhdGVBcmNQb2x5Z29uKHQsZSl7Y29uc3Qgbj10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxzPW4uZ2V0V2lkdGgoKS8yLGk9bi5nZXRIZWlnaHQoKS8yLHI9bi5nZXRNaW5YKCkrcyxvPW4uZ2V0TWluWSgpK2k7bGV0IGw9ZTsobDw9MHx8bD4yKk1hdGguUEkpJiYobD0yKk1hdGguUEkpO2NvbnN0IGE9bC8odGhpcy5fblB0cy0xKSxjPW5ldyBBcnJheSh0aGlzLl9uUHRzKzIpLmZpbGwobnVsbCk7bGV0IGg9MDtjW2grK109dGhpcy5jb29yZChyLG8pO2ZvcihsZXQgZT0wO2U8dGhpcy5fblB0cztlKyspe2NvbnN0IG49dCthKmUsbD1zKk1hdGguY29zKG4pK3IsdT1pKk1hdGguc2luKG4pK287Y1toKytdPXRoaXMuY29vcmQobCx1KX1jW2grK109dGhpcy5jb29yZChyLG8pO2NvbnN0IHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhjKSxnPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24odSk7cmV0dXJuIHRoaXMucm90YXRlKGcpfWNyZWF0ZVJlY3RhbmdsZSgpe2xldCB0PW51bGwsZT0wLG49TWF0aC50cnVuYyh0aGlzLl9uUHRzLzQpO248MSYmKG49MSk7Y29uc3Qgcz10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKS5nZXRXaWR0aCgpL24saT10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKS5nZXRIZWlnaHQoKS9uLHI9bmV3IEFycmF5KDQqbisxKS5maWxsKG51bGwpLG89dGhpcy5fZGltLmdldEVudmVsb3BlKCk7Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWluWCgpK3QqcyxpPW8uZ2V0TWluWSgpO3JbZSsrXT10aGlzLmNvb3JkKG4saSl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWF4WCgpLHM9by5nZXRNaW5ZKCkrdCppO3JbZSsrXT10aGlzLmNvb3JkKG4scyl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWF4WCgpLXQqcyxpPW8uZ2V0TWF4WSgpO3JbZSsrXT10aGlzLmNvb3JkKG4saSl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWluWCgpLHM9by5nZXRNYXhZKCktdCppO3JbZSsrXT10aGlzLmNvb3JkKG4scyl9cltlKytdPW5ldyBtKHJbMF0pO2NvbnN0IGw9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhyKSxhPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24obCk7cmV0dXJuIHRoaXMucm90YXRlKGEpfWNyZWF0ZUNpcmNsZSgpe3JldHVybiB0aGlzLmNyZWF0ZUVsbGlwc2UoKX1zZXRIZWlnaHQodCl7dGhpcy5fZGltLnNldEhlaWdodCh0KX1zZXRTaXplKHQpe3RoaXMuX2RpbS5zZXRTaXplKHQpfX1jbGFzcyBDZXtjb25zdHJ1Y3Rvcigpe0NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuYmFzZT1udWxsLHRoaXMuY2VudHJlPW51bGwsdGhpcy53aWR0aD1udWxsLHRoaXMuaGVpZ2h0PW51bGx9c2V0QmFzZSh0KXt0aGlzLmJhc2U9dH1zZXRXaWR0aCh0KXt0aGlzLndpZHRoPXR9Z2V0QmFzZSgpe3JldHVybiB0aGlzLmJhc2V9Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy53aWR0aH1zZXRFbnZlbG9wZSh0KXt0aGlzLndpZHRoPXQuZ2V0V2lkdGgoKSx0aGlzLmhlaWdodD10LmdldEhlaWdodCgpLHRoaXMuYmFzZT1uZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksdGhpcy5jZW50cmU9bmV3IG0odC5jZW50cmUoKSl9c2V0Q2VudHJlKHQpe3RoaXMuY2VudHJlPXR9Z2V0TWluU2l6ZSgpe3JldHVybiBNYXRoLm1pbih0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KX1nZXRFbnZlbG9wZSgpe3JldHVybiBudWxsIT09dGhpcy5iYXNlP25ldyBPKHRoaXMuYmFzZS54LHRoaXMuYmFzZS54K3RoaXMud2lkdGgsdGhpcy5iYXNlLnksdGhpcy5iYXNlLnkrdGhpcy5oZWlnaHQpOm51bGwhPT10aGlzLmNlbnRyZT9uZXcgTyh0aGlzLmNlbnRyZS54LXRoaXMud2lkdGgvMix0aGlzLmNlbnRyZS54K3RoaXMud2lkdGgvMix0aGlzLmNlbnRyZS55LXRoaXMuaGVpZ2h0LzIsdGhpcy5jZW50cmUueSt0aGlzLmhlaWdodC8yKTpuZXcgTygwLHRoaXMud2lkdGgsMCx0aGlzLmhlaWdodCl9Z2V0Q2VudHJlKCl7cmV0dXJuIG51bGw9PT10aGlzLmNlbnRyZSYmKHRoaXMuY2VudHJlPW5ldyBtKHRoaXMuYmFzZS54K3RoaXMud2lkdGgvMix0aGlzLmJhc2UueSt0aGlzLmhlaWdodC8yKSksdGhpcy5jZW50cmV9Z2V0SGVpZ2h0KCl7cmV0dXJuIHRoaXMuaGVpZ2h0fXNldEhlaWdodCh0KXt0aGlzLmhlaWdodD10fXNldFNpemUodCl7dGhpcy5oZWlnaHQ9dCx0aGlzLndpZHRoPXR9fXdlLkRpbWVuc2lvbnM9Q2U7Y2xhc3MgU2UgZXh0ZW5kcyB3ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksU2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbnVtQXJtcz04LHRoaXMuX2FybUxlbmd0aFJhdGlvPS41LDA9PT1hcmd1bWVudHMubGVuZ3RoKXdlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3dlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fXN0YXRpYyBjcmVhdGUodCxlLG4scyxpKXtjb25zdCByPW5ldyBTZTtyLnNldENlbnRyZSh0KSxyLnNldFNpemUoZSksci5zZXROdW1Qb2ludHMobiksci5zZXRBcm1MZW5ndGhSYXRpbyhpKSxyLnNldE51bUFybXMocyk7cmV0dXJuIHIuY3JlYXRlU2luZVN0YXIoKX1zZXROdW1Bcm1zKHQpe3RoaXMuX251bUFybXM9dH1zZXRBcm1MZW5ndGhSYXRpbyh0KXt0aGlzLl9hcm1MZW5ndGhSYXRpbz10fWNyZWF0ZVNpbmVTdGFyKCl7Y29uc3QgdD10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxlPXQuZ2V0V2lkdGgoKS8yO2xldCBuPXRoaXMuX2FybUxlbmd0aFJhdGlvO248MCYmKG49MCksbj4xJiYobj0xKTtjb25zdCBzPW4qZSxpPSgxLW4pKmUscj10LmdldE1pblgoKStlLG89dC5nZXRNaW5ZKCkrZSxsPW5ldyBBcnJheSh0aGlzLl9uUHRzKzEpLmZpbGwobnVsbCk7bGV0IGE9MDtmb3IobGV0IHQ9MDt0PHRoaXMuX25QdHM7dCsrKXtjb25zdCBlPXQvdGhpcy5fblB0cyp0aGlzLl9udW1Bcm1zLG49ZS1NYXRoLmZsb29yKGUpLGM9MipNYXRoLlBJKm4saD1pK3MqKChNYXRoLmNvcyhjKSsxKS8yKSx1PXQqKDIqTWF0aC5QSS90aGlzLl9uUHRzKSxnPWgqTWF0aC5jb3ModSkrcixkPWgqTWF0aC5zaW4odSkrbztsW2ErK109dGhpcy5jb29yZChnLGQpfWxbYV09bmV3IG0obFswXSk7Y29uc3QgYz10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGwpO3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGMpfX12YXIgTGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQWZmaW5lVHJhbnNmb3JtYXRpb246aWUsQWZmaW5lVHJhbnNmb3JtYXRpb25CdWlsZGVyOm9lLEFmZmluZVRyYW5zZm9ybWF0aW9uRmFjdG9yeTpsZSxDb21wb25lbnRDb29yZGluYXRlRXh0cmFjdGVyOmFlLEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlcjpjZSxHZW9tZXRyeUNvbWJpbmVyOmhlLEdlb21ldHJ5RWRpdG9yOnVlLEdlb21ldHJ5RXh0cmFjdGVyOmRlLEdlb21ldHJ5TWFwcGVyOl9lLEdlb21ldHJ5VHJhbnNmb3JtZXI6bWUsTGluZVN0cmluZ0V4dHJhY3RlcjpmZSxMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXI6eWUsUG9pbnRFeHRyYWN0ZXI6RWUsUG9seWdvbkV4dHJhY3RlcjpJZSxTaG9ydENpcmN1aXRlZEdlb21ldHJ5VmlzaXRvcjpOZSxTaW5lU3RhckZhY3Rvcnk6U2V9KSxUZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb29yZGluYXRlOm0sQ29vcmRpbmF0ZVhZOnksQ29vcmRpbmF0ZVhZTTp4LENvb3JkaW5hdGVYWVpNOkUsQ29vcmRpbmF0ZUxpc3Q6UixDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXI6UCxFbnZlbG9wZTpPLExpbmVTZWdtZW50Okt0LEdlb21ldHJ5RmFjdG9yeTpMdCxHZW9tZXRyeTpVLFBvaW50OmV0LExpbmVTdHJpbmc6JCxMaW5lYXJSaW5nOmd0LFBvbHlnb246cnQsR2VvbWV0cnlDb2xsZWN0aW9uOmh0LE11bHRpUG9pbnQ6dXQsTXVsdGlMaW5lU3RyaW5nOlN0LE11bHRpUG9seWdvbjp5dCxEaW1lbnNpb246USxJbnRlcnNlY3Rpb25NYXRyaXg6SnQsUHJlY2lzaW9uTW9kZWw6d3QsTG9jYXRpb246UXQsVHJpYW5nbGU6bmUsdXRpbDpMZX0pO2NsYXNzIFJle2NvbnN0cnVjdG9yKCl7UmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHQ9W25ldyBtLG5ldyBtXSx0aGlzLl9kaXN0YW5jZT1yLk5hTix0aGlzLl9pc051bGw9ITB9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRbdF19c2V0TWluaW11bSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldE1pbmltdW0odC5fcHRbMF0sdC5fcHRbMV0pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzTnVsbClyZXR1cm4gdGhpcy5pbml0aWFsaXplKHQsZSksbnVsbDtjb25zdCBuPXQuZGlzdGFuY2UoZSk7bjx0aGlzLl9kaXN0YW5jZSYmdGhpcy5pbml0aWFsaXplKHQsZSxuKX19aW5pdGlhbGl6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX2lzTnVsbD0hMDtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHQpLHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUoZSksdGhpcy5fZGlzdGFuY2U9dC5kaXN0YW5jZShlKSx0aGlzLl9pc051bGw9ITF9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZSh0KSx0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKGUpLHRoaXMuX2Rpc3RhbmNlPW4sdGhpcy5faXNOdWxsPSExfX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcodGhpcy5fcHRbMF0sdGhpcy5fcHRbMV0pfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfXNldE1heGltdW0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRNYXhpbXVtKHQuX3B0WzBdLHQuX3B0WzFdKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLl9pc051bGwpcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZSh0LGUpLG51bGw7Y29uc3Qgbj10LmRpc3RhbmNlKGUpO24+dGhpcy5fZGlzdGFuY2UmJnRoaXMuaW5pdGlhbGl6ZSh0LGUsbil9fX1jbGFzcyBQZXtzdGF0aWMgY29tcHV0ZURpc3RhbmNlKCl7aWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IEt0LGk9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGgtMTt0Kyspe3Muc2V0Q29vcmRpbmF0ZXMoaVt0XSxpW3QrMV0pO2NvbnN0IHI9cy5jbG9zZXN0UG9pbnQoZSk7bi5zZXRNaW5pbXVtKHIsZSl9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBydCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtQZS5jb21wdXRlRGlzdGFuY2UodC5nZXRFeHRlcmlvclJpbmcoKSxlLG4pO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspUGUuY29tcHV0ZURpc3RhbmNlKHQuZ2V0SW50ZXJpb3JSaW5nTihzKSxlLG4pfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQgaW5zdGFuY2VvZiAkKVBlLmNvbXB1dGVEaXN0YW5jZSh0LGUsbik7ZWxzZSBpZih0IGluc3RhbmNlb2YgcnQpUGUuY29tcHV0ZURpc3RhbmNlKHQsZSxuKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBodCl7Y29uc3Qgcz10O2ZvcihsZXQgdD0wO3Q8cy5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBpPXMuZ2V0R2VvbWV0cnlOKHQpO1BlLmNvbXB1dGVEaXN0YW5jZShpLGUsbil9fWVsc2Ugbi5zZXRNaW5pbXVtKHQuZ2V0Q29vcmRpbmF0ZSgpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1swXS5jbG9zZXN0UG9pbnQodCk7ZS5zZXRNaW5pbXVtKG4sdCl9fX1jbGFzcyBPZXtjb25zdHJ1Y3Rvcigpe09lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2cwPW51bGwsdGhpcy5fZzE9bnVsbCx0aGlzLl9wdERpc3Q9bmV3IFJlLHRoaXMuX2RlbnNpZnlGcmFjPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZzA9dCx0aGlzLl9nMT1lfXN0YXRpYyBkaXN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IE9lKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLmRpc3RhbmNlKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzJdLGU9bmV3IE9lKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pO3JldHVybiBlLnNldERlbnNpZnlGcmFjdGlvbih0KSxlLmRpc3RhbmNlKCl9fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0RGlzdC5nZXRDb29yZGluYXRlcygpfXNldERlbnNpZnlGcmFjdGlvbih0KXtpZih0PjF8fHQ8PTApdGhyb3cgbmV3IHMoXCJGcmFjdGlvbiBpcyBub3QgaW4gcmFuZ2UgKDAuMCAtIDEuMF1cIik7dGhpcy5fZGVuc2lmeUZyYWM9dH1jb21wdXRlKHQsZSl7dGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0LGUsdGhpcy5fcHREaXN0KSx0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKGUsdCx0aGlzLl9wdERpc3QpfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSh0aGlzLl9nMCx0aGlzLl9nMSksdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKCl9Y29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9bmV3IHZlKGUpO2lmKHQuYXBwbHkocyksbi5zZXRNYXhpbXVtKHMuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKSx0aGlzLl9kZW5zaWZ5RnJhYz4wKXtjb25zdCBzPW5ldyBiZShlLHRoaXMuX2RlbnNpZnlGcmFjKTt0LmFwcGx5KHMpLG4uc2V0TWF4aW11bShzLmdldE1heFBvaW50RGlzdGFuY2UoKSl9fW9yaWVudGVkRGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0aGlzLl9nMCx0aGlzLl9nMSx0aGlzLl9wdERpc3QpLHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpfX1jbGFzcyB2ZXtjb25zdHJ1Y3Rvcigpe3ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21heFB0RGlzdD1uZXcgUmUsdGhpcy5fbWluUHREaXN0PW5ldyBSZSx0aGlzLl9ldWNsaWRlYW5EaXN0PW5ldyBQZSx0aGlzLl9nZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbT10fWZpbHRlcih0KXt0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpLFBlLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLHQsdGhpcy5fbWluUHREaXN0KSx0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpfWdldE1heFBvaW50RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fbWF4UHREaXN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIXX19Y2xhc3MgYmV7Y29uc3RydWN0b3IoKXtiZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9tYXhQdERpc3Q9bmV3IFJlLHRoaXMuX21pblB0RGlzdD1uZXcgUmUsdGhpcy5fZ2VvbT1udWxsLHRoaXMuX251bVN1YlNlZ3M9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tPXQsdGhpcy5fbnVtU3ViU2Vncz1NYXRoLnRydW5jKE1hdGgucm91bmQoMS9lKSl9ZmlsdGVyKHQsZSl7aWYoMD09PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGUoZS0xKSxzPXQuZ2V0Q29vcmRpbmF0ZShlKSxpPShzLngtbi54KS90aGlzLl9udW1TdWJTZWdzLHI9KHMueS1uLnkpL3RoaXMuX251bVN1YlNlZ3M7Zm9yKGxldCB0PTA7dDx0aGlzLl9udW1TdWJTZWdzO3QrKyl7Y29uc3QgZT1uLngrdCppLHM9bi55K3QqcixvPW5ldyBtKGUscyk7dGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKSxQZS5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSxvLHRoaXMuX21pblB0RGlzdCksdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KX19aXNEb25lKCl7cmV0dXJuITF9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMX1nZXRNYXhQb2ludERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21heFB0RGlzdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUF19fU9lLk1heFBvaW50RGlzdGFuY2VGaWx0ZXI9dmUsT2UuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyPWJlO3ZhciBNZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlOk9lLERpc3RhbmNlVG9Qb2ludDpQZSxQb2ludFBhaXJEaXN0YW5jZTpSZX0pO2NsYXNzIERle3Zpc2l0SXRlbSh0KXt9fWNsYXNzIEFle2xvY2F0ZSh0KXt9fWNsYXNzIEZle2NvbnN0cnVjdG9yKCl7RmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWluPXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5fbWF4PXIuTkVHQVRJVkVfSU5GSU5JVFl9Z2V0TWluKCl7cmV0dXJuIHRoaXMuX21pbn1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuISh0aGlzLl9taW4+ZXx8dGhpcy5fbWF4PHQpfWdldE1heCgpe3JldHVybiB0aGlzLl9tYXh9dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKG5ldyBtKHRoaXMuX21pbiwwKSxuZXcgbSh0aGlzLl9tYXgsMCkpfX1GZS5Ob2RlQ29tcGFyYXRvcj1jbGFzc3tjb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZSxpPShuLl9taW4rbi5fbWF4KS8yLHI9KHMuX21pbitzLl9tYXgpLzI7cmV0dXJuIGk8cj8tMTppPnI/MTowfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19O2NsYXNzIEdlIGV4dGVuZHMgRmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLEdlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2l0ZW09bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9taW49dCx0aGlzLl9tYXg9ZSx0aGlzLl9pdGVtPW59cXVlcnkodCxlLG4pe2lmKCF0aGlzLmludGVyc2VjdHModCxlKSlyZXR1cm4gbnVsbDtuLnZpc2l0SXRlbSh0aGlzLl9pdGVtKX19Y2xhc3MgcWUgZXh0ZW5kcyBGZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkscWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZTE9bnVsbCx0aGlzLl9ub2RlMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX25vZGUxPXQsdGhpcy5fbm9kZTI9ZSx0aGlzLmJ1aWxkRXh0ZW50KHRoaXMuX25vZGUxLHRoaXMuX25vZGUyKX1idWlsZEV4dGVudCh0LGUpe3RoaXMuX21pbj1NYXRoLm1pbih0Ll9taW4sZS5fbWluKSx0aGlzLl9tYXg9TWF0aC5tYXgodC5fbWF4LGUuX21heCl9cXVlcnkodCxlLG4pe2lmKCF0aGlzLmludGVyc2VjdHModCxlKSlyZXR1cm4gbnVsbDtudWxsIT09dGhpcy5fbm9kZTEmJnRoaXMuX25vZGUxLnF1ZXJ5KHQsZSxuKSxudWxsIT09dGhpcy5fbm9kZTImJnRoaXMuX25vZGUyLnF1ZXJ5KHQsZSxuKX19Y2xhc3MgQmV7Y29uc3RydWN0b3IoKXtCZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9sZWF2ZXM9bmV3IEwsdGhpcy5fcm9vdD1udWxsLHRoaXMuX2xldmVsPTB9YnVpbGRUcmVlKCl7eGUuc29ydCh0aGlzLl9sZWF2ZXMsbmV3IEZlLk5vZGVDb21wYXJhdG9yKTtsZXQgdD10aGlzLl9sZWF2ZXMsZT1udWxsLG49bmV3IEw7Zm9yKDs7KXtpZih0aGlzLmJ1aWxkTGV2ZWwodCxuKSwxPT09bi5zaXplKCkpcmV0dXJuIG4uZ2V0KDApO2U9dCx0PW4sbj1lfX1pbnNlcnQodCxlLG4pe2lmKG51bGwhPT10aGlzLl9yb290KXRocm93IG5ldyBEKFwiSW5kZXggY2Fubm90IGJlIGFkZGVkIHRvIG9uY2UgaXQgaGFzIGJlZW4gcXVlcmllZFwiKTt0aGlzLl9sZWF2ZXMuYWRkKG5ldyBHZSh0LGUsbikpfXF1ZXJ5KHQsZSxuKXtpZih0aGlzLmluaXQoKSxudWxsPT09dGhpcy5fcm9vdClyZXR1cm4gbnVsbDt0aGlzLl9yb290LnF1ZXJ5KHQsZSxuKX1idWlsZFJvb3QoKXtpZihudWxsIT09dGhpcy5fcm9vdClyZXR1cm4gbnVsbDt0aGlzLl9yb290PXRoaXMuYnVpbGRUcmVlKCl9cHJpbnROb2RlKHQpe1kub3V0LnByaW50bG4oV3QudG9MaW5lU3RyaW5nKG5ldyBtKHQuX21pbix0aGlzLl9sZXZlbCksbmV3IG0odC5fbWF4LHRoaXMuX2xldmVsKSkpfWluaXQoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3Jvb3R8fDA9PT10aGlzLl9sZWF2ZXMuc2l6ZSgpP251bGw6dm9pZCB0aGlzLmJ1aWxkUm9vdCgpfWJ1aWxkTGV2ZWwodCxlKXt0aGlzLl9sZXZlbCsrLGUuY2xlYXIoKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rPTIpe2NvbnN0IHM9dC5nZXQobik7aWYobnVsbD09PShuKzE8dC5zaXplKCk/dC5nZXQobik6bnVsbCkpZS5hZGQocyk7ZWxzZXtjb25zdCBzPW5ldyBxZSh0LmdldChuKSx0LmdldChuKzEpKTtlLmFkZChzKX19fX1jbGFzcyBZZXtjb25zdHJ1Y3Rvcigpe1llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2l0ZW1zPW5ldyBMfXZpc2l0SXRlbSh0KXt0aGlzLl9pdGVtcy5hZGQodCl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RlXX19Y2xhc3MgVmV7Y29uc3RydWN0b3IoKXtWZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wPW51bGwsdGhpcy5fY3Jvc3NpbmdDb3VudD0wLHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcD10fXN0YXRpYyBsb2NhdGVQb2ludEluUmluZygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmSShhcmd1bWVudHNbMV0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9bmV3IFZlKGFyZ3VtZW50c1swXSksbj1uZXcgbSxzPW5ldyBtO2ZvcihsZXQgaT0xO2k8dC5zaXplKCk7aSsrKWlmKHQuZ2V0Q29vcmRpbmF0ZShpLG4pLHQuZ2V0Q29vcmRpbmF0ZShpLTEscyksZS5jb3VudFNlZ21lbnQobixzKSxlLmlzT25TZWdtZW50KCkpcmV0dXJuIGUuZ2V0TG9jYXRpb24oKTtyZXR1cm4gZS5nZXRMb2NhdGlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1uZXcgVmUoYXJndW1lbnRzWzBdKTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dLGk9dFtuLTFdO2lmKGUuY291bnRTZWdtZW50KHMsaSksZS5pc09uU2VnbWVudCgpKXJldHVybiBlLmdldExvY2F0aW9uKCl9cmV0dXJuIGUuZ2V0TG9jYXRpb24oKX19Y291bnRTZWdtZW50KHQsZSl7aWYodC54PHRoaXMuX3AueCYmZS54PHRoaXMuX3AueClyZXR1cm4gbnVsbDtpZih0aGlzLl9wLng9PT1lLngmJnRoaXMuX3AueT09PWUueSlyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2lmKHQueT09PXRoaXMuX3AueSYmZS55PT09dGhpcy5fcC55KXtsZXQgbj10Lngscz1lLng7cmV0dXJuIG4+cyYmKG49ZS54LHM9dC54KSx0aGlzLl9wLng+PW4mJnRoaXMuX3AueDw9cyYmKHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITApLG51bGx9aWYodC55PnRoaXMuX3AueSYmZS55PD10aGlzLl9wLnl8fGUueT50aGlzLl9wLnkmJnQueTw9dGhpcy5fcC55KXtsZXQgbj1xLmluZGV4KHQsZSx0aGlzLl9wKTtpZihuPT09cS5DT0xMSU5FQVIpcmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITAsbnVsbDtlLnk8dC55JiYobj0tbiksbj09PXEuTEVGVCYmdGhpcy5fY3Jvc3NpbmdDb3VudCsrfX1pc1BvaW50SW5Qb2x5Z29uKCl7cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSE9PVF0LkVYVEVSSU9SfWdldExvY2F0aW9uKCl7cmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ/UXQuQk9VTkRBUlk6dGhpcy5fY3Jvc3NpbmdDb3VudCUyPT0xP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SfWlzT25TZWdtZW50KCl7cmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnR9fWNsYXNzIHple2NvbnN0cnVjdG9yKCl7emUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbT1udWxsLHRoaXMuX2luZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoIShJKHQsaXQpfHx0IGluc3RhbmNlb2YgZ3QpKXRocm93IG5ldyBzKFwiQXJndW1lbnQgbXVzdCBiZSBQb2x5Z29uYWwgb3IgTGluZWFyUmluZ1wiKTt0aGlzLl9nZW9tPXR9bG9jYXRlKHQpe251bGw9PT10aGlzLl9pbmRleCYmKHRoaXMuX2luZGV4PW5ldyBrZSh0aGlzLl9nZW9tKSx0aGlzLl9nZW9tPW51bGwpO2NvbnN0IGU9bmV3IFZlKHQpLG49bmV3IFhlKGUpO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeSh0LnksdC55LG4pLGUuZ2V0TG9jYXRpb24oKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfX1jbGFzcyBYZXtjb25zdHJ1Y3Rvcigpe1hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvdW50ZXI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb3VudGVyPXR9dmlzaXRJdGVtKHQpe2NvbnN0IGU9dDt0aGlzLl9jb3VudGVyLmNvdW50U2VnbWVudChlLmdldENvb3JkaW5hdGUoMCksZS5nZXRDb29yZGluYXRlKDEpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRGVdfX1jbGFzcyBrZXtjb25zdHJ1Y3Rvcigpe2tlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRW1wdHk9ITEsdGhpcy5faW5kZXg9bmV3IEJlO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuaXNFbXB0eSgpP3RoaXMuX2lzRW1wdHk9ITA6dGhpcy5pbml0KHQpfWluaXQodCl7Zm9yKGxldCBlPXllLmdldExpbmVzKHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7dGhpcy5hZGRMaW5lKHQpfX1hZGRMaW5lKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPW5ldyBLdCh0W2UtMV0sdFtlXSkscz1NYXRoLm1pbihuLnAwLnksbi5wMS55KSxpPU1hdGgubWF4KG4ucDAueSxuLnAxLnkpO3RoaXMuX2luZGV4Lmluc2VydChzLGksbil9fXF1ZXJ5KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzRW1wdHkpcmV0dXJuIG5ldyBMO2NvbnN0IG49bmV3IFllO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeSh0LGUsbiksbi5nZXRJdGVtcygpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLl9pc0VtcHR5KXJldHVybiBudWxsO3RoaXMuX2luZGV4LnF1ZXJ5KHQsZSxuKX19fXplLlNlZ21lbnRWaXNpdG9yPVhlLHplLkludGVydmFsSW5kZXhlZEdlb21ldHJ5PWtlO2NsYXNzIFVle3N0YXRpYyBpc09uTGluZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmSShhcmd1bWVudHNbMV0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGp0LHM9bmV3IG0saT1uZXcgbSxyPWUuc2l6ZSgpO2ZvcihsZXQgbz0xO288cjtvKyspaWYoZS5nZXRDb29yZGluYXRlKG8tMSxzKSxlLmdldENvb3JkaW5hdGUobyxpKSxuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxzLGkpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITA7cmV0dXJuITF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBqdDtmb3IobGV0IHM9MTtzPGUubGVuZ3RoO3MrKyl7Y29uc3QgaT1lW3MtMV0scj1lW3NdO2lmKG4uY29tcHV0ZUludGVyc2VjdGlvbih0LGksciksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMH1yZXR1cm4hMX19c3RhdGljIGxvY2F0ZUluUmluZyh0LGUpe3JldHVybiBWZS5sb2NhdGVQb2ludEluUmluZyh0LGUpfXN0YXRpYyBpc0luUmluZyh0LGUpe3JldHVybiBVZS5sb2NhdGVJblJpbmcodCxlKSE9PVF0LkVYVEVSSU9SfX1jbGFzcyBIZXtoYXNOZXh0KCl7fW5leHQoKXt9cmVtb3ZlKCl7fX1jbGFzcyBXZXtjb25zdHJ1Y3Rvcigpe1dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BhcmVudD1udWxsLHRoaXMuX2F0U3RhcnQ9bnVsbCx0aGlzLl9tYXg9bnVsbCx0aGlzLl9pbmRleD1udWxsLHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudD10LHRoaXMuX2F0U3RhcnQ9ITAsdGhpcy5faW5kZXg9MCx0aGlzLl9tYXg9dC5nZXROdW1HZW9tZXRyaWVzKCl9c3RhdGljIGlzQXRvbWljKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIGh0KX1uZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4gdGhpcy5fYXRTdGFydD0hMSxXZS5pc0F0b21pYyh0aGlzLl9wYXJlbnQpJiZ0aGlzLl9pbmRleCsrLHRoaXMuX3BhcmVudDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfWlmKHRoaXMuX2luZGV4Pj10aGlzLl9tYXgpdGhyb3cgbmV3IFM7Y29uc3QgdD10aGlzLl9wYXJlbnQuZ2V0R2VvbWV0cnlOKHRoaXMuX2luZGV4KyspO3JldHVybiB0IGluc3RhbmNlb2YgaHQ/KHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1uZXcgV2UodCksdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKSk6dH1yZW1vdmUoKXt0aHJvdyBuZXcgSyh0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKX1oYXNOZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4hMDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiEwO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfXJldHVybiEodGhpcy5faW5kZXg+PXRoaXMuX21heCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hlXX19Y2xhc3MgWmV7Y29uc3RydWN0b3IoKXtaZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbT10fXN0YXRpYyBsb2NhdGVQb2ludEluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBRdC5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz1aZS5sb2NhdGVQb2ludEluUmluZyh0LG4pO2lmKHMhPT1RdC5JTlRFUklPUilyZXR1cm4gcztmb3IobGV0IG49MDtuPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bisrKXtjb25zdCBzPWUuZ2V0SW50ZXJpb3JSaW5nTihuKSxpPVplLmxvY2F0ZVBvaW50SW5SaW5nKHQscyk7aWYoaT09PVF0LkJPVU5EQVJZKXJldHVybiBRdC5CT1VOREFSWTtpZihpPT09UXQuSU5URVJJT1IpcmV0dXJuIFF0LkVYVEVSSU9SfXJldHVybiBRdC5JTlRFUklPUn1zdGF0aWMgbG9jYXRlUG9pbnRJblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9VZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOlF0LkVYVEVSSU9SfXN0YXRpYyBjb250YWluc1BvaW50SW5Qb2x5Z29uKHQsZSl7cmV0dXJuIFF0LkVYVEVSSU9SIT09WmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKX1zdGF0aWMgbG9jYXRlSW5HZW9tZXRyeSh0LGUpe2lmKGUgaW5zdGFuY2VvZiBydClyZXR1cm4gWmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKTtpZihlIGluc3RhbmNlb2YgaHQpe2NvbnN0IG49bmV3IFdlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHMhPT1lKXtjb25zdCBlPVplLmxvY2F0ZUluR2VvbWV0cnkodCxzKTtpZihlIT09UXQuRVhURVJJT1IpcmV0dXJuIGV9fX1yZXR1cm4gUXQuRVhURVJJT1J9c3RhdGljIGlzQ29udGFpbmVkKHQsZSl7cmV0dXJuIFF0LkVYVEVSSU9SIT09WmUubG9jYXRlKHQsZSl9c3RhdGljIGxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9RdC5FWFRFUklPUjplLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP1plLmxvY2F0ZUluR2VvbWV0cnkodCxlKTpRdC5FWFRFUklPUn1sb2NhdGUodCl7cmV0dXJuIFplLmxvY2F0ZSh0LHRoaXMuX2dlb20pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fXZhciBqZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yOnplLFBvaW50T25HZW9tZXRyeUxvY2F0b3I6QWUsU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yOlplfSk7Y2xhc3MgS2V7bWVhc3VyZSh0LGUpe319Y2xhc3MgUWV7c3RhdGljIGRpYWdvbmFsU2l6ZSh0KXtpZih0LmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfW1lYXN1cmUodCxlKXtjb25zdCBuPU9lLmRpc3RhbmNlKHQsZSxRZS5ERU5TSUZZX0ZSQUNUSU9OKSxzPW5ldyBPKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtzLmV4cGFuZFRvSW5jbHVkZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIDEtbi9RZS5kaWFnb25hbFNpemUocyl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0tlXX19UWUuREVOU0lGWV9GUkFDVElPTj0uMjU7dmFyIEplPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFyZWFTaW1pbGFyaXR5TWVhc3VyZTpjbGFzc3ttZWFzdXJlKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKGUpLmdldEFyZWEoKS90LnVuaW9uKGUpLmdldEFyZWEoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bS2VdfX0sSGF1c2RvcmZmU2ltaWxhcml0eU1lYXN1cmU6UWUsU2ltaWxhcml0eU1lYXN1cmU6S2UsU2ltaWxhcml0eU1lYXN1cmVDb21iaW5lcjpjbGFzc3tzdGF0aWMgY29tYmluZSh0LGUpe3JldHVybiBNYXRoLm1pbih0LGUpfX19KTtjbGFzcyAkZXtjb25zdHJ1Y3RvcigpeyRlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2FyZWFCYXNlUHQ9bnVsbCx0aGlzLl90cmlhbmdsZUNlbnQzPW5ldyBtLHRoaXMuX2FyZWFzdW0yPTAsdGhpcy5fY2czPW5ldyBtLHRoaXMuX2xpbmVDZW50U3VtPW5ldyBtLHRoaXMuX3RvdGFsTGVuZ3RoPTAsdGhpcy5fcHRDb3VudD0wLHRoaXMuX3B0Q2VudFN1bT1uZXcgbTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmVhQmFzZVB0PW51bGwsdGhpcy5hZGQodCl9c3RhdGljIGFyZWEyKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShuLngtdC54KSooZS55LXQueSl9c3RhdGljIGNlbnRyb2lkMyh0LGUsbixzKXtyZXR1cm4gcy54PXQueCtlLngrbi54LHMueT10LnkrZS55K24ueSxudWxsfXN0YXRpYyBnZXRDZW50cm9pZCh0KXtyZXR1cm4gbmV3ICRlKHQpLmdldENlbnRyb2lkKCl9c2V0QXJlYUJhc2VQb2ludCh0KXt0aGlzLl9hcmVhQmFzZVB0PXR9YWRkUG9pbnQodCl7dGhpcy5fcHRDb3VudCs9MSx0aGlzLl9wdENlbnRTdW0ueCs9dC54LHRoaXMuX3B0Q2VudFN1bS55Kz10Lnl9YWRkTGluZVNlZ21lbnRzKHQpe2xldCBlPTA7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl7Y29uc3Qgcz10W25dLmRpc3RhbmNlKHRbbisxXSk7aWYoMD09PXMpY29udGludWU7ZSs9cztjb25zdCBpPSh0W25dLngrdFtuKzFdLngpLzI7dGhpcy5fbGluZUNlbnRTdW0ueCs9cyppO2NvbnN0IHI9KHRbbl0ueSt0W24rMV0ueSkvMjt0aGlzLl9saW5lQ2VudFN1bS55Kz1zKnJ9dGhpcy5fdG90YWxMZW5ndGgrPWUsMD09PWUmJnQubGVuZ3RoPjAmJnRoaXMuYWRkUG9pbnQodFswXSl9YWRkSG9sZSh0KXtjb25zdCBlPXEuaXNDQ1codCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuX2FyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9Z2V0Q2VudHJvaWQoKXtjb25zdCB0PW5ldyBtO2lmKE1hdGguYWJzKHRoaXMuX2FyZWFzdW0yKT4wKXQueD10aGlzLl9jZzMueC8zL3RoaXMuX2FyZWFzdW0yLHQueT10aGlzLl9jZzMueS8zL3RoaXMuX2FyZWFzdW0yO2Vsc2UgaWYodGhpcy5fdG90YWxMZW5ndGg+MCl0Lng9dGhpcy5fbGluZUNlbnRTdW0ueC90aGlzLl90b3RhbExlbmd0aCx0Lnk9dGhpcy5fbGluZUNlbnRTdW0ueS90aGlzLl90b3RhbExlbmd0aDtlbHNle2lmKCEodGhpcy5fcHRDb3VudD4wKSlyZXR1cm4gbnVsbDt0Lng9dGhpcy5fcHRDZW50U3VtLngvdGhpcy5fcHRDb3VudCx0Lnk9dGhpcy5fcHRDZW50U3VtLnkvdGhpcy5fcHRDb3VudH1yZXR1cm4gdH1hZGRTaGVsbCh0KXt0Lmxlbmd0aD4wJiZ0aGlzLnNldEFyZWFCYXNlUG9pbnQodFswXSk7Y29uc3QgZT0hcS5pc0NDVyh0KTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5fYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX1hZGRUcmlhbmdsZSh0LGUsbixzKXtjb25zdCBpPXM/MTotMTskZS5jZW50cm9pZDModCxlLG4sdGhpcy5fdHJpYW5nbGVDZW50Myk7Y29uc3Qgcj0kZS5hcmVhMih0LGUsbik7dGhpcy5fY2czLngrPWkqcip0aGlzLl90cmlhbmdsZUNlbnQzLngsdGhpcy5fY2czLnkrPWkqcip0aGlzLl90cmlhbmdsZUNlbnQzLnksdGhpcy5fYXJlYXN1bTIrPWkqcn1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZFNoZWxsKHQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl0aGlzLmFkZEhvbGUodC5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgZXQpdGhpcy5hZGRQb2ludCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgJCl0aGlzLmFkZExpbmVTZWdtZW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHJ0KXtjb25zdCBlPXQ7dGhpcy5hZGQoZSl9ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fX19Y2xhc3MgdG4gZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7RW1wdHlTdGFja0V4Y2VwdGlvbjp0bn0pWzBdfX1jbGFzcyBlbiBleHRlbmRzIEN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuYXJyYXk9W119YWRkKHQpe3JldHVybiB0aGlzLmFycmF5LnB1c2godCksITB9Z2V0KHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IHc7cmV0dXJuIHRoaXMuYXJyYXlbdF19cHVzaCh0KXtyZXR1cm4gdGhpcy5hcnJheS5wdXNoKHQpLHR9cG9wKCl7aWYoMD09PXRoaXMuYXJyYXkubGVuZ3RoKXRocm93IG5ldyB0bjtyZXR1cm4gdGhpcy5hcnJheS5wb3AoKX1wZWVrKCl7aWYoMD09PXRoaXMuYXJyYXkubGVuZ3RoKXRocm93IG5ldyB0bjtyZXR1cm4gdGhpcy5hcnJheVt0aGlzLmFycmF5Lmxlbmd0aC0xXX1lbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9aXNFbXB0eSgpe3JldHVybiB0aGlzLmVtcHR5KCl9c2VhcmNoKHQpe3JldHVybiB0aGlzLmFycmF5LmluZGV4T2YodCl9c2l6ZSgpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aH10b0FycmF5KCl7cmV0dXJuIHRoaXMuYXJyYXkuc2xpY2UoKX19Y2xhc3Mgbm57Y29uc3RydWN0b3IoKXtubi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZFNldD1uZXcgRXQsdGhpcy5fbGlzdD1uZXcgTH1zdGF0aWMgZmlsdGVyQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbm47Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5maWx0ZXIodFtuXSk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZXMoKX1maWx0ZXIodCl7dGhpcy5fY29vcmRTZXQuYWRkKHQpJiZ0aGlzLl9saXN0LmFkZCh0KX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2xpc3Quc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLl9saXN0LnRvQXJyYXkodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hdfX1jbGFzcyBzbntjb25zdHJ1Y3Rvcigpe3NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5faW5wdXRQdHM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07c24uY29uc3RydWN0b3JfLmNhbGwodGhpcyxzbi5leHRyYWN0Q29vcmRpbmF0ZXModCksdC5nZXRGYWN0b3J5KCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0UHRzPW5uLmZpbHRlckNvb3JkaW5hdGVzKHQpLHRoaXMuX2dlb21GYWN0b3J5PWV9fXN0YXRpYyBleHRyYWN0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbm47cmV0dXJuIHQuYXBwbHkoZSksZS5nZXRDb29yZGluYXRlcygpfXByZVNvcnQodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKykodFtuXS55PHRbMF0ueXx8dFtuXS55PT09dFswXS55JiZ0W25dLng8dFswXS54KSYmKGU9dFswXSx0WzBdPXRbbl0sdFtuXT1lKTtyZXR1cm4gc3Quc29ydCh0LDEsdC5sZW5ndGgsbmV3IHJuKHRbMF0pKSx0fWNvbXB1dGVPY3RSaW5nKHQpe2NvbnN0IGU9dGhpcy5jb21wdXRlT2N0UHRzKHQpLG49bmV3IFI7cmV0dXJuIG4uYWRkKGUsITEpLG4uc2l6ZSgpPDM/bnVsbDoobi5jbG9zZVJpbmcoKSxuLnRvQ29vcmRpbmF0ZUFycmF5KCkpfWxpbmVPclBvbHlnb24odCl7aWYoMz09PSh0PXRoaXMuY2xlYW5SaW5nKHQpKS5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW3RbMF0sdFsxXV0pO2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KTtyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlUG9seWdvbihlKX1jbGVhblJpbmcodCl7Zy5lcXVhbHModFswXSx0W3QubGVuZ3RoLTFdKTtjb25zdCBlPW5ldyBMO2xldCBuPW51bGw7Zm9yKGxldCBzPTA7czw9dC5sZW5ndGgtMjtzKyspe2NvbnN0IGk9dFtzXSxyPXRbcysxXTtpLmVxdWFscyhyKXx8KG51bGwhPT1uJiZ0aGlzLmlzQmV0d2VlbihuLGkscil8fChlLmFkZChpKSxuPWkpKX1lLmFkZCh0W3QubGVuZ3RoLTFdKTtjb25zdCBzPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gZS50b0FycmF5KHMpfWlzQmV0d2Vlbih0LGUsbil7aWYoMCE9PXEuaW5kZXgodCxlLG4pKXJldHVybiExO2lmKHQueCE9PW4ueCl7aWYodC54PD1lLngmJmUueDw9bi54KXJldHVybiEwO2lmKG4ueDw9ZS54JiZlLng8PXQueClyZXR1cm4hMH1pZih0LnkhPT1uLnkpe2lmKHQueTw9ZS55JiZlLnk8PW4ueSlyZXR1cm4hMDtpZihuLnk8PWUueSYmZS55PD10LnkpcmV0dXJuITB9cmV0dXJuITF9cmVkdWNlKHQpe2NvbnN0IGU9dGhpcy5jb21wdXRlT2N0UmluZyh0KTtpZihudWxsPT09ZSlyZXR1cm4gdDtjb25zdCBuPW5ldyBhdDtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyluLmFkZChlW3RdKTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKylVZS5pc0luUmluZyh0W3NdLGUpfHxuLmFkZCh0W3NdKTtjb25zdCBzPV90LnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiBzLmxlbmd0aDwzP3RoaXMucGFkQXJyYXkzKHMpOnN9Z2V0Q29udmV4SHVsbCgpe2lmKDA9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKDE9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuX2lucHV0UHRzWzBdKTtpZigyPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX2lucHV0UHRzKTtsZXQgdD10aGlzLl9pbnB1dFB0czt0aGlzLl9pbnB1dFB0cy5sZW5ndGg+NTAmJih0PXRoaXMucmVkdWNlKHRoaXMuX2lucHV0UHRzKSk7Y29uc3QgZT10aGlzLnByZVNvcnQodCksbj10aGlzLmdyYWhhbVNjYW4oZSkscz10aGlzLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiB0aGlzLmxpbmVPclBvbHlnb24ocyl9cGFkQXJyYXkzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspbjx0Lmxlbmd0aD9lW25dPXRbbl06ZVtuXT10WzBdO3JldHVybiBlfWNvbXB1dGVPY3RQdHModCl7Y29uc3QgZT1uZXcgQXJyYXkoOCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXS54PGVbMF0ueCYmKGVbMF09dFtuXSksdFtuXS54LXRbbl0ueTxlWzFdLngtZVsxXS55JiYoZVsxXT10W25dKSx0W25dLnk+ZVsyXS55JiYoZVsyXT10W25dKSx0W25dLngrdFtuXS55PmVbM10ueCtlWzNdLnkmJihlWzNdPXRbbl0pLHRbbl0ueD5lWzRdLngmJihlWzRdPXRbbl0pLHRbbl0ueC10W25dLnk+ZVs1XS54LWVbNV0ueSYmKGVbNV09dFtuXSksdFtuXS55PGVbNl0ueSYmKGVbNl09dFtuXSksdFtuXS54K3Rbbl0ueTxlWzddLngrZVs3XS55JiYoZVs3XT10W25dKTtyZXR1cm4gZX10b0Nvb3JkaW5hdGVBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10LmdldChuKTtlW25dPXN9cmV0dXJuIGV9Z3JhaGFtU2Nhbih0KXtsZXQgZT1udWxsO2NvbnN0IG49bmV3IGVuO24ucHVzaCh0WzBdKSxuLnB1c2godFsxXSksbi5wdXNoKHRbMl0pO2ZvcihsZXQgcz0zO3M8dC5sZW5ndGg7cysrKXtmb3IoZT1uLnBvcCgpOyFuLmVtcHR5KCkmJnEuaW5kZXgobi5wZWVrKCksZSx0W3NdKT4wOyllPW4ucG9wKCk7bi5wdXNoKGUpLG4ucHVzaCh0W3NdKX1yZXR1cm4gbi5wdXNoKHRbMF0pLG59fWNsYXNzIHJue2NvbnN0cnVjdG9yKCl7cm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3JpZ2luPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZ2luPXR9c3RhdGljIHBvbGFyQ29tcGFyZSh0LGUsbil7Y29uc3Qgcz1lLngtdC54LGk9ZS55LXQueSxyPW4ueC10Lngsbz1uLnktdC55LGw9cS5pbmRleCh0LGUsbik7aWYobD09PXEuQ09VTlRFUkNMT0NLV0lTRSlyZXR1cm4gMTtpZihsPT09cS5DTE9DS1dJU0UpcmV0dXJuLTE7Y29uc3QgYT1zKnMraSppLGM9cipyK28qbztyZXR1cm4gYTxjPy0xOmE+Yz8xOjB9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7cmV0dXJuIHJuLnBvbGFyQ29tcGFyZSh0aGlzLl9vcmlnaW4sbixzKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fXNuLlJhZGlhbENvbXBhcmF0b3I9cm47Y2xhc3Mgb257Y29uc3RydWN0b3IoKXtvbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnRlcmlvclBvaW50PW51bGwsdGhpcy5fbWF4V2lkdGg9LTE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wcm9jZXNzKHQpfXN0YXRpYyBnZXRJbnRlcmlvclBvaW50KHQpe3JldHVybiBuZXcgb24odCkuZ2V0SW50ZXJpb3JQb2ludCgpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1wcm9jZXNzKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBydCl0aGlzLnByb2Nlc3NQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5wcm9jZXNzKGUuZ2V0R2VvbWV0cnlOKHQpKX19cHJvY2Vzc1BvbHlnb24odCl7Y29uc3QgZT1uZXcgbG4odCk7ZS5wcm9jZXNzKCk7Y29uc3Qgbj1lLmdldFdpZHRoKCk7bj50aGlzLl9tYXhXaWR0aCYmKHRoaXMuX21heFdpZHRoPW4sdGhpcy5faW50ZXJpb3JQb2ludD1lLmdldEludGVyaW9yUG9pbnQoKSl9fWNsYXNzIGxue2NvbnN0cnVjdG9yKCl7bG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcG9seWdvbj1udWxsLHRoaXMuX2ludGVyaW9yUG9pbnRZPW51bGwsdGhpcy5faW50ZXJpb3JTZWN0aW9uV2lkdGg9MCx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG9seWdvbj10LHRoaXMuX2ludGVyaW9yUG9pbnRZPWNuLmdldFNjYW5MaW5lWSh0KX1zdGF0aWMgaXNFZGdlQ3Jvc3NpbmdDb3VudGVkKHQsZSxuKXtjb25zdCBzPXQuZ2V0WSgpLGk9ZS5nZXRZKCk7cmV0dXJuIHMhPT1pJiYoIShzPT09biYmaTxuKSYmIShpPT09biYmczxuKSl9c3RhdGljIGludGVyc2VjdHNIb3Jpem9udGFsTGluZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hKGU8dC5nZXRNaW5ZKCkpJiYhKGU+dC5nZXRNYXhZKCkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4hKHQuZ2V0WSgpPm4mJmUuZ2V0WSgpPm4pJiYhKHQuZ2V0WSgpPG4mJmUuZ2V0WSgpPG4pfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuKXtjb25zdCBzPXQuZ2V0WCgpLGk9ZS5nZXRYKCk7aWYocz09PWkpcmV0dXJuIHM7Y29uc3Qgcj1pLXMsbz0oZS5nZXRZKCktdC5nZXRZKCkpL3I7cmV0dXJuIHMrKG4tdC5nZXRZKCkpL299ZmluZEJlc3RNaWRwb2ludCh0KXtpZigwPT09dC5zaXplKCkpcmV0dXJuIG51bGw7Zy5pc1RydWUoMD09dC5zaXplKCklMixcIkludGVyaW9yIFBvaW50IHJvYnVzdG5lc3MgZmFpbHVyZTogb2RkIG51bWJlciBvZiBzY2FubGluZSBjcm9zc2luZ3NcIiksdC5zb3J0KG5ldyBhbik7Zm9yKGxldCBlPTA7ZTx0LnNpemUoKTtlKz0yKXtjb25zdCBuPXQuZ2V0KGUpLHM9dC5nZXQoZSsxKSxpPXMtbjtpZihpPnRoaXMuX2ludGVyaW9yU2VjdGlvbldpZHRoKXt0aGlzLl9pbnRlcmlvclNlY3Rpb25XaWR0aD1pO2NvbnN0IHQ9b24uYXZnKG4scyk7dGhpcy5faW50ZXJpb3JQb2ludD1uZXcgbSh0LHRoaXMuX2ludGVyaW9yUG9pbnRZKX19fXByb2Nlc3MoKXtpZih0aGlzLl9wb2x5Z29uLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHRoaXMuX3BvbHlnb24uZ2V0Q29vcmRpbmF0ZSgpKTtjb25zdCB0PW5ldyBMO3RoaXMuc2NhblJpbmcodGhpcy5fcG9seWdvbi5nZXRFeHRlcmlvclJpbmcoKSx0KTtmb3IobGV0IGU9MDtlPHRoaXMuX3BvbHlnb24uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuc2NhblJpbmcodGhpcy5fcG9seWdvbi5nZXRJbnRlcmlvclJpbmdOKGUpLHQpO3RoaXMuZmluZEJlc3RNaWRwb2ludCh0KX1zY2FuUmluZyh0LGUpe2lmKCFsbi5pbnRlcnNlY3RzSG9yaXpvbnRhbExpbmUodC5nZXRFbnZlbG9wZUludGVybmFsKCksdGhpcy5faW50ZXJpb3JQb2ludFkpKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MTt0PG4uc2l6ZSgpO3QrKyl7Y29uc3Qgcz1uLmdldENvb3JkaW5hdGUodC0xKSxpPW4uZ2V0Q29vcmRpbmF0ZSh0KTt0aGlzLmFkZEVkZ2VDcm9zc2luZyhzLGksdGhpcy5faW50ZXJpb3JQb2ludFksZSl9fWdldFdpZHRoKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yU2VjdGlvbldpZHRofWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGRFZGdlQ3Jvc3NpbmcodCxlLG4scyl7aWYoIWxuLmludGVyc2VjdHNIb3Jpem9udGFsTGluZSh0LGUsbikpcmV0dXJuIG51bGw7aWYoIWxuLmlzRWRnZUNyb3NzaW5nQ291bnRlZCh0LGUsbikpcmV0dXJuIG51bGw7Y29uc3QgaT1sbi5pbnRlcnNlY3Rpb24odCxlLG4pO3MuYWRkKGkpfX1jbGFzcyBhbntjb21wYXJlKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTowfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19bG4uRG91YmxlQ29tcGFyYXRvcj1hbjtjbGFzcyBjbntjb25zdHJ1Y3Rvcigpe2NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BvbHk9bnVsbCx0aGlzLl9jZW50cmVZPW51bGwsdGhpcy5faGlZPXIuTUFYX1ZBTFVFLHRoaXMuX2xvWT0tci5NQVhfVkFMVUU7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG9seT10LHRoaXMuX2hpWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNYXhZKCksdGhpcy5fbG9ZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1pblkoKSx0aGlzLl9jZW50cmVZPW9uLmF2Zyh0aGlzLl9sb1ksdGhpcy5faGlZKX1zdGF0aWMgZ2V0U2NhbkxpbmVZKHQpe3JldHVybiBuZXcgY24odCkuZ2V0U2NhbkxpbmVZKCl9dXBkYXRlSW50ZXJ2YWwodCl7dDw9dGhpcy5fY2VudHJlWT90PnRoaXMuX2xvWSYmKHRoaXMuX2xvWT10KTp0PnRoaXMuX2NlbnRyZVkmJnQ8dGhpcy5faGlZJiYodGhpcy5faGlZPXQpfWdldFNjYW5MaW5lWSgpe3RoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEV4dGVyaW9yUmluZygpKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3BvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXRoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEludGVyaW9yUmluZ04odCkpO3JldHVybiBvbi5hdmcodGhpcy5faGlZLHRoaXMuX2xvWSl9cHJvY2Vzcyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IG49ZS5nZXRZKHQpO3RoaXMudXBkYXRlSW50ZXJ2YWwobil9fX1vbi5JbnRlcmlvclBvaW50UG9seWdvbj1sbixvbi5TY2FuTGluZVlPcmRpbmF0ZUZpbmRlcj1jbjtjbGFzcyBobntjb25zdHJ1Y3Rvcigpe2huLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NlbnRyb2lkPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuaXNFbXB0eSgpP3RoaXMuX2NlbnRyb2lkPW51bGw6KHRoaXMuX2NlbnRyb2lkPSRlLmdldENlbnRyb2lkKHQpLHQuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0aGlzLl9jZW50cm9pZCkpLHRoaXMuYWRkSW50ZXJpb3IodCksbnVsbD09PXRoaXMuX2ludGVyaW9yUG9pbnQmJnRoaXMuYWRkRW5kcG9pbnRzKHQpfXN0YXRpYyBnZXRJbnRlcmlvclBvaW50KHQpe3JldHVybiBuZXcgaG4odCkuZ2V0SW50ZXJpb3JQb2ludCgpfWFkZEVuZHBvaW50cygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mICQpdGhpcy5hZGRFbmRwb2ludHModC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBodCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkRW5kcG9pbnRzKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0WzBdKSx0aGlzLmFkZCh0W3QubGVuZ3RoLTFdKX19Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fWFkZEludGVyaW9yKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgJCl0aGlzLmFkZEludGVyaW9yKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZEludGVyaW9yKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoLTE7ZSsrKXRoaXMuYWRkKHRbZV0pfX1hZGQodCl7Y29uc3QgZT10LmRpc3RhbmNlKHRoaXMuX2NlbnRyb2lkKTtlPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5faW50ZXJpb3JQb2ludD1uZXcgbSh0KSx0aGlzLl9taW5EaXN0YW5jZT1lKX19Y2xhc3MgdW57Y29uc3RydWN0b3IoKXt1bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jZW50cm9pZD1udWxsLHRoaXMuX21pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jZW50cm9pZD0kZS5nZXRDZW50cm9pZCh0KSx0aGlzLmFkZCh0KX1zdGF0aWMgZ2V0SW50ZXJpb3JQb2ludCh0KXtyZXR1cm4gbmV3IHVuKHQpLmdldEludGVyaW9yUG9pbnQoKX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgZXQpdGhpcy5hZGQodC5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmRpc3RhbmNlKHRoaXMuX2NlbnRyb2lkKTtlPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5faW50ZXJpb3JQb2ludD1uZXcgbSh0KSx0aGlzLl9taW5EaXN0YW5jZT1lKX19fWNsYXNzIGdue2lzSW5Cb3VuZGFyeSh0KXt9fWNsYXNzIGRue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdCUyPT0xfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnbl19fWNsYXNzIF9ue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdD4wfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnbl19fWNsYXNzIHBue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdD4xfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnbl19fWNsYXNzIG1ue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gMT09PXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Z24uTW9kMkJvdW5kYXJ5Tm9kZVJ1bGU9ZG4sZ24uRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPV9uLGduLk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPXBuLGduLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9bW4sZ24uTU9EMl9CT1VOREFSWV9SVUxFPW5ldyBkbixnbi5FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBfbixnbi5NVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBwbixnbi5NT05PVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IG1uLGduLk9HQ19TRlNfQk9VTkRBUllfUlVMRT1nbi5NT0QyX0JPVU5EQVJZX1JVTEU7Y2xhc3MgZm57Y29uc3RydWN0b3IoKXtmbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9ib3VuZGFyeVJ1bGU9Z24uT0dDX1NGU19CT1VOREFSWV9SVUxFLHRoaXMuX2lzSW49bnVsbCx0aGlzLl9udW1Cb3VuZGFyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXRocm93IG5ldyBzKFwiUnVsZSBtdXN0IGJlIG5vbi1udWxsXCIpO3RoaXMuX2JvdW5kYXJ5UnVsZT10fX1sb2NhdGVJblBvbHlnb25SaW5nKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/VWUubG9jYXRlSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpRdC5FWFRFUklPUn1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRlKHQsZSkhPT1RdC5FWFRFUklPUn11cGRhdGVMb2NhdGlvbkluZm8odCl7dD09PVF0LklOVEVSSU9SJiYodGhpcy5faXNJbj0hMCksdD09PVF0LkJPVU5EQVJZJiZ0aGlzLl9udW1Cb3VuZGFyaWVzKyt9Y29tcHV0ZUxvY2F0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIGV0JiZ0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uUG9pbnQodCxlKSksZSBpbnN0YW5jZW9mICQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgcnQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJblBvbHlnb24odCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgU3Qpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgeXQpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUluUG9seWdvbih0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgaHQpe2NvbnN0IG49bmV3IFdlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MhPT1lJiZ0aGlzLmNvbXB1dGVMb2NhdGlvbih0LHMpfX19bG9jYXRlT25Qb2ludCh0LGUpe3JldHVybiBlLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0KT9RdC5JTlRFUklPUjpRdC5FWFRFUklPUn1sb2NhdGVPbkxpbmVTdHJpbmcodCxlKXtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KSlyZXR1cm4gUXQuRVhURVJJT1I7Y29uc3Qgbj1lLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO3JldHVybiBlLmlzQ2xvc2VkKCl8fCF0LmVxdWFscyhuLmdldENvb3JkaW5hdGUoMCkpJiYhdC5lcXVhbHMobi5nZXRDb29yZGluYXRlKG4uc2l6ZSgpLTEpKT9VZS5pc09uTGluZSh0LG4pP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SOlF0LkJPVU5EQVJZfWxvY2F0ZUluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBRdC5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxuKTtpZihzPT09UXQuRVhURVJJT1IpcmV0dXJuIFF0LkVYVEVSSU9SO2lmKHM9PT1RdC5CT1VOREFSWSlyZXR1cm4gUXQuQk9VTkRBUlk7Zm9yKGxldCBuPTA7bjxlLmdldE51bUludGVyaW9yUmluZygpO24rKyl7Y29uc3Qgcz1lLmdldEludGVyaW9yUmluZ04obiksaT10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxzKTtpZihpPT09UXQuSU5URVJJT1IpcmV0dXJuIFF0LkVYVEVSSU9SO2lmKGk9PT1RdC5CT1VOREFSWSlyZXR1cm4gUXQuQk9VTkRBUll9cmV0dXJuIFF0LklOVEVSSU9SfWxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9RdC5FWFRFUklPUjplIGluc3RhbmNlb2YgJD90aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LGUpOmUgaW5zdGFuY2VvZiBydD90aGlzLmxvY2F0ZUluUG9seWdvbih0LGUpOih0aGlzLl9pc0luPSExLHRoaXMuX251bUJvdW5kYXJpZXM9MCx0aGlzLmNvbXB1dGVMb2NhdGlvbih0LGUpLHRoaXMuX2JvdW5kYXJ5UnVsZS5pc0luQm91bmRhcnkodGhpcy5fbnVtQm91bmRhcmllcyk/UXQuQk9VTkRBUlk6dGhpcy5fbnVtQm91bmRhcmllcz4wfHx0aGlzLl9pc0luP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SKX19Y2xhc3MgeW57Y29uc3RydWN0b3IoKXt5bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dD1udWxsLHRoaXMuX2V4dHJlbWFsUHRzPW51bGwsdGhpcy5fY2VudHJlPW51bGwsdGhpcy5fcmFkaXVzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXQ9dH1zdGF0aWMgZmFydGhlc3RQb2ludHModCl7Y29uc3QgZT10WzBdLmRpc3RhbmNlKHRbMV0pLG49dFsxXS5kaXN0YW5jZSh0WzJdKSxzPXRbMl0uZGlzdGFuY2UodFswXSk7cmV0dXJuIGU+PW4mJmU+PXM/W3RbMF0sdFsxXV06bj49ZSYmbj49cz9bdFsxXSx0WzJdXTpbdFsyXSx0WzBdXX1zdGF0aWMgcG9pbnRXaXRNaW5BbmdsZVdpdGhYKHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz1udWxsO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCByPXRbaV07aWYocj09PWUpY29udGludWU7Y29uc3Qgbz1yLngtZS54O2xldCBsPXIueS1lLnk7bDwwJiYobD0tbCk7Y29uc3QgYT1sL01hdGguc3FydChvKm8rbCpsKTthPG4mJihuPWEscz1yKX1yZXR1cm4gc31zdGF0aWMgbG93ZXN0UG9pbnQodCl7bGV0IGU9dFswXTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl0W25dLnk8ZS55JiYoZT10W25dKTtyZXR1cm4gZX1zdGF0aWMgcG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudCh0LGUsbil7bGV0IHM9ci5NQVhfVkFMVUUsaT1udWxsO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBvPXRbcl07aWYobz09PWUpY29udGludWU7aWYobz09PW4pY29udGludWU7Y29uc3QgbD0kdC5hbmdsZUJldHdlZW4oZSxvLG4pO2w8cyYmKHM9bCxpPW8pfXJldHVybiBpfWdldFJhZGl1cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9yYWRpdXN9Z2V0RGlhbWV0ZXIoKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKX1jb25zdCB0PXRoaXMuX2V4dHJlbWFsUHRzWzBdLGU9dGhpcy5fZXh0cmVtYWxQdHNbMV07cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX1nZXRFeHRyZW1hbFBvaW50cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0c31jb21wdXRlQ2lyY2xlUG9pbnRzKCl7aWYodGhpcy5faW5wdXQuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO2lmKDE9PT10aGlzLl9pbnB1dC5nZXROdW1Qb2ludHMoKSl7Y29uc3QgdD10aGlzLl9pbnB1dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IG0odFswXSldLG51bGx9Y29uc3QgdD10aGlzLl9pbnB1dC5jb252ZXhIdWxsKCkuZ2V0Q29vcmRpbmF0ZXMoKTtsZXQgZT10O2lmKHRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSkmJihlPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpLF90LmNvcHlEZWVwKHQsMCxlLDAsdC5sZW5ndGgtMSkpLGUubGVuZ3RoPD0yKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1fdC5jb3B5RGVlcChlKSxudWxsO2xldCBuPXluLmxvd2VzdFBvaW50KGUpLHM9eW4ucG9pbnRXaXRNaW5BbmdsZVdpdGhYKGUsbik7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHQ9eW4ucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudChlLG4scyk7aWYoJHQuaXNPYnR1c2Uobix0LHMpKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IG0obiksbmV3IG0ocyldLG51bGw7aWYoJHQuaXNPYnR1c2UodCxuLHMpKW49dDtlbHNle2lmKCEkdC5pc09idHVzZSh0LHMsbikpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgbShuKSxuZXcgbShzKSxuZXcgbSh0KV0sbnVsbDtzPXR9fWcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJMb2dpYyBmYWlsdXJlIGluIE1pbmltdW0gQm91bmRpbmcgQ2lyY2xlIGFsZ29yaXRobSFcIil9Y29tcHV0ZSgpe2lmKG51bGwhPT10aGlzLl9leHRyZW1hbFB0cylyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDaXJjbGVQb2ludHMoKSx0aGlzLmNvbXB1dGVDZW50cmUoKSxudWxsIT09dGhpcy5fY2VudHJlJiYodGhpcy5fcmFkaXVzPXRoaXMuX2NlbnRyZS5kaXN0YW5jZSh0aGlzLl9leHRyZW1hbFB0c1swXSkpfWdldENpcmNsZSgpe2lmKHRoaXMuY29tcHV0ZSgpLG51bGw9PT10aGlzLl9jZW50cmUpcmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKCk7Y29uc3QgdD10aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKTtyZXR1cm4gMD09PXRoaXMuX3JhZGl1cz90OnQuYnVmZmVyKHRoaXMuX3JhZGl1cyl9Z2V0Q2VudHJlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX2NlbnRyZX1nZXRNYXhpbXVtRGlhbWV0ZXIoKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKTtjYXNlIDI6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLl9leHRyZW1hbFB0c1swXSx0aGlzLl9leHRyZW1hbFB0c1sxXV0pO2RlZmF1bHQ6Y29uc3QgdD15bi5mYXJ0aGVzdFBvaW50cyh0aGlzLl9leHRyZW1hbFB0cyk7cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQpfX1jb21wdXRlQ2VudHJlKCl7c3dpdGNoKHRoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnRoaXMuX2NlbnRyZT1udWxsO2JyZWFrO2Nhc2UgMTp0aGlzLl9jZW50cmU9dGhpcy5fZXh0cmVtYWxQdHNbMF07YnJlYWs7Y2FzZSAyOnRoaXMuX2NlbnRyZT1uZXcgbSgodGhpcy5fZXh0cmVtYWxQdHNbMF0ueCt0aGlzLl9leHRyZW1hbFB0c1sxXS54KS8yLCh0aGlzLl9leHRyZW1hbFB0c1swXS55K3RoaXMuX2V4dHJlbWFsUHRzWzFdLnkpLzIpO2JyZWFrO2Nhc2UgMzp0aGlzLl9jZW50cmU9bmUuY2lyY3VtY2VudHJlKHRoaXMuX2V4dHJlbWFsUHRzWzBdLHRoaXMuX2V4dHJlbWFsUHRzWzFdLHRoaXMuX2V4dHJlbWFsUHRzWzJdKX19fWNsYXNzIHhue2NvbnN0cnVjdG9yKCl7eG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5faXNDb252ZXg9bnVsbCx0aGlzLl9jb252ZXhIdWxsUHRzPW51bGwsdGhpcy5fbWluQmFzZVNlZz1uZXcgS3QsdGhpcy5fbWluV2lkdGhQdD1udWxsLHRoaXMuX21pblB0SW5kZXg9bnVsbCx0aGlzLl9taW5XaWR0aD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt4bi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsITEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2lzQ29udmV4PWV9fXN0YXRpYyBuZXh0SW5kZXgodCxlKXtyZXR1cm4rK2U+PXQubGVuZ3RoJiYoZT0wKSxlfXN0YXRpYyBjb21wdXRlQyh0LGUsbil7cmV0dXJuIHQqbi55LWUqbi54fXN0YXRpYyBnZXRNaW5pbXVtRGlhbWV0ZXIodCl7cmV0dXJuIG5ldyB4bih0KS5nZXREaWFtZXRlcigpfXN0YXRpYyBnZXRNaW5pbXVtUmVjdGFuZ2xlKHQpe3JldHVybiBuZXcgeG4odCkuZ2V0TWluaW11bVJlY3RhbmdsZSgpfXN0YXRpYyBjb21wdXRlU2VnbWVudEZvckxpbmUodCxlLG4pe2xldCBzPW51bGwsaT1udWxsO3JldHVybiBNYXRoLmFicyhlKT5NYXRoLmFicyh0KT8ocz1uZXcgbSgwLG4vZSksaT1uZXcgbSgxLG4vZS10L2UpKToocz1uZXcgbShuL3QsMCksaT1uZXcgbShuL3QtZS90LDEpKSxuZXcgS3QocyxpKX1nZXRXaWR0aENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGhQdH1nZXRTdXBwb3J0aW5nU2VnbWVudCgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMuX21pbkJhc2VTZWcucDAsdGhpcy5fbWluQmFzZVNlZy5wMV0pfWdldERpYW1ldGVyKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksbnVsbD09PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wcm9qZWN0KHRoaXMuX21pbldpZHRoUHQpO3JldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsdGhpcy5fbWluV2lkdGhQdF0pfWNvbXB1dGVXaWR0aENvbnZleCh0KXt0aGlzLl9jb252ZXhIdWxsUHRzPXQgaW5zdGFuY2VvZiBydD90LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCk6dC5nZXRDb29yZGluYXRlcygpLDA9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluQmFzZVNlZz1udWxsKToxPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDA9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAxPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0pOjI9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aHx8Mz09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAwPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMT10aGlzLl9jb252ZXhIdWxsUHRzWzFdKTp0aGlzLmNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodGhpcy5fY29udmV4SHVsbFB0cyl9Y29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0KXt0aGlzLl9taW5XaWR0aD1yLk1BWF9WQUxVRTtsZXQgZT0xO2NvbnN0IG49bmV3IEt0O2ZvcihsZXQgcz0wO3M8dC5sZW5ndGgtMTtzKyspbi5wMD10W3NdLG4ucDE9dFtzKzFdLGU9dGhpcy5maW5kTWF4UGVycERpc3RhbmNlKHQsbixlKX1jb21wdXRlTWluaW11bURpYW1ldGVyKCl7aWYobnVsbCE9PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIG51bGw7aWYodGhpcy5faXNDb252ZXgpdGhpcy5jb21wdXRlV2lkdGhDb252ZXgodGhpcy5faW5wdXRHZW9tKTtlbHNle2NvbnN0IHQ9bmV3IHNuKHRoaXMuX2lucHV0R2VvbSkuZ2V0Q29udmV4SHVsbCgpO3RoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHQpfX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGh9ZmluZE1heFBlcnBEaXN0YW5jZSh0LGUsbil7bGV0IHM9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtuXSksaT1zLHI9bixvPXI7Zm9yKDtpPj1zOylzPWkscj1vLG89eG4ubmV4dEluZGV4KHQsciksaT1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W29dKTtyZXR1cm4gczx0aGlzLl9taW5XaWR0aCYmKHRoaXMuX21pblB0SW5kZXg9cix0aGlzLl9taW5XaWR0aD1zLHRoaXMuX21pbldpZHRoUHQ9dFt0aGlzLl9taW5QdEluZGV4XSx0aGlzLl9taW5CYXNlU2VnPW5ldyBLdChlKSkscn1nZXRNaW5pbXVtUmVjdGFuZ2xlKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksMD09PXRoaXMuX21pbldpZHRoKXJldHVybiB0aGlzLl9taW5CYXNlU2VnLnAwLmVxdWFsczJEKHRoaXMuX21pbkJhc2VTZWcucDEpP3RoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fbWluQmFzZVNlZy5wMCk6dGhpcy5fbWluQmFzZVNlZy50b0dlb21ldHJ5KHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wMS54LXRoaXMuX21pbkJhc2VTZWcucDAueCxlPXRoaXMuX21pbkJhc2VTZWcucDEueS10aGlzLl9taW5CYXNlU2VnLnAwLnk7bGV0IG49ci5NQVhfVkFMVUUscz0tci5NQVhfVkFMVUUsaT1yLk1BWF9WQUxVRSxvPS1yLk1BWF9WQUxVRTtmb3IobGV0IHI9MDtyPHRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoO3IrKyl7Y29uc3QgbD14bi5jb21wdXRlQyh0LGUsdGhpcy5fY29udmV4SHVsbFB0c1tyXSk7bD5zJiYocz1sKSxsPG4mJihuPWwpO2NvbnN0IGE9eG4uY29tcHV0ZUMoLWUsdCx0aGlzLl9jb252ZXhIdWxsUHRzW3JdKTthPm8mJihvPWEpLGE8aSYmKGk9YSl9Y29uc3QgbD14bi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsbyksYT14bi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsaSksYz14bi5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxzKSxoPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LG4pLHU9Yy5saW5lSW50ZXJzZWN0aW9uKGwpLGc9aC5saW5lSW50ZXJzZWN0aW9uKGwpLGQ9aC5saW5lSW50ZXJzZWN0aW9uKGEpLF89Yy5saW5lSW50ZXJzZWN0aW9uKGEpLHA9dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKFt1LGcsZCxfLHVdKTtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKHApfX12YXIgRW49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGlzdGFuY2U6TWUsbG9jYXRlOmplLG1hdGNoOkplLEFuZ2xlOiR0LEFyZWE6bnQsQ2VudHJvaWQ6JGUsQ29udmV4SHVsbDpzbixEaXN0YW5jZTp6LEludGVyaW9yUG9pbnRBcmVhOm9uLEludGVyaW9yUG9pbnRMaW5lOmhuLEludGVyaW9yUG9pbnRQb2ludDp1bixMZW5ndGg6VyxPcmllbnRhdGlvbjpxLFBvaW50TG9jYXRpb246VWUsUG9pbnRMb2NhdG9yOmZuLFJvYnVzdExpbmVJbnRlcnNlY3RvcjpqdCxNaW5pbXVtQm91bmRpbmdDaXJjbGU6eW4sTWluaW11bURpYW1ldGVyOnhufSk7Y2xhc3MgSW57Y29uc3RydWN0b3IoKXtJbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBkZW5zaWZ5UG9pbnRzKHQsZSxuKXtjb25zdCBzPW5ldyBLdCxpPW5ldyBSO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGgtMTtyKyspe3MucDA9dFtyXSxzLnAxPXRbcisxXSxpLmFkZChzLnAwLCExKTtjb25zdCBvPXMuZ2V0TGVuZ3RoKCksbD1NYXRoLnRydW5jKG8vZSkrMTtpZihsPjEpe2NvbnN0IHQ9by9sO2ZvcihsZXQgZT0xO2U8bDtlKyspe2NvbnN0IHI9ZSp0L28sbD1zLnBvaW50QWxvbmcocik7bi5tYWtlUHJlY2lzZShsKSxpLmFkZChsLCExKX19fXJldHVybiBpLmFkZCh0W3QubGVuZ3RoLTFdLCExKSxpLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIGRlbnNpZnkodCxlKXtjb25zdCBuPW5ldyBJbih0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gbmV3IE5uKHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PD0wKXRocm93IG5ldyBzKFwiVG9sZXJhbmNlIG11c3QgYmUgcG9zaXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH19Y2xhc3MgTm4gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIHl0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1Jbi5kZW5zaWZ5UG9pbnRzKG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSxlLmdldFByZWNpc2lvbk1vZGVsKCkpO3JldHVybiBlIGluc3RhbmNlb2YgJCYmMT09PXMubGVuZ3RoJiYocz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdC5idWZmZXIoMCl9fUluLkRlbnNpZnlUcmFuc2Zvcm1lcj1Objt2YXIgd249T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGVuc2lmaWVyOklufSk7Y2xhc3MgQ257c3RhdGljIGlzTm9ydGhlcm4odCl7cmV0dXJuIHQ9PT1Dbi5ORXx8dD09PUNuLk5XfXN0YXRpYyBpc09wcG9zaXRlKHQsZSl7aWYodD09PWUpcmV0dXJuITE7cmV0dXJuIDI9PT0odC1lKzQpJTR9c3RhdGljIGNvbW1vbkhhbGZQbGFuZSh0LGUpe2lmKHQ9PT1lKXJldHVybiB0O2lmKDI9PT0odC1lKzQpJTQpcmV0dXJuLTE7Y29uc3Qgbj10PGU/dDplO3JldHVybiAwPT09biYmMz09PSh0PmU/dDplKT8zOm59c3RhdGljIGlzSW5IYWxmUGxhbmUodCxlKXtyZXR1cm4gZT09PUNuLlNFP3Q9PT1Dbi5TRXx8dD09PUNuLlNXOnQ9PT1lfHx0PT09ZSsxfXN0YXRpYyBxdWFkcmFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgcyhcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7cmV0dXJuIHQ+PTA/ZT49MD9Dbi5ORTpDbi5TRTplPj0wP0NuLk5XOkNuLlNXfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihlLng9PT10LngmJmUueT09PXQueSl0aHJvdyBuZXcgcyhcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrdCk7cmV0dXJuIGUueD49dC54P2UueT49dC55P0NuLk5FOkNuLlNFOmUueT49dC55P0NuLk5XOkNuLlNXfX19Q24uTkU9MCxDbi5OVz0xLENuLlNXPTIsQ24uU0U9MztjbGFzcyBTbntjb25zdHJ1Y3Rvcigpe1NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX29yaWc9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZz10fXN0YXRpYyBjcmVhdGUodCxlKXtjb25zdCBuPW5ldyBTbih0KSxzPW5ldyBTbihlKTtyZXR1cm4gbi5saW5rKHMpLG59ZmluZCh0KXtsZXQgZT10aGlzO2Rve2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKGUuZGVzdCgpLmVxdWFsczJEKHQpKXJldHVybiBlO2U9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gbnVsbH1kZXN0KCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZ31pc0VkZ2VzU29ydGVkKCl7Y29uc3QgdD10aGlzLmZpbmRMb3dlc3QoKTtsZXQgZT10O2Rve2NvbnN0IG49ZS5vTmV4dCgpO2lmKG49PT10KWJyZWFrO2lmKCEobi5jb21wYXJlVG8oZSk+MCkpcmV0dXJuITE7ZT1ufXdoaWxlKGUhPT10KTtyZXR1cm4hMH1vTmV4dCgpe3JldHVybiB0aGlzLl9zeW0uX25leHR9ZGlyZWN0aW9uWSgpe3JldHVybiB0aGlzLmRpcmVjdGlvblB0KCkuZ2V0WSgpLXRoaXMuX29yaWcuZ2V0WSgpfWluc2VydCh0KXtpZih0aGlzLm9OZXh0KCk9PT10aGlzKXJldHVybiB0aGlzLmluc2VydEFmdGVyKHQpLG51bGw7dGhpcy5pbnNlcnRpb25FZGdlKHQpLmluc2VydEFmdGVyKHQpfWluc2VydEFmdGVyKHQpe2cuZXF1YWxzKHRoaXMuX29yaWcsdC5vcmlnKCkpO2NvbnN0IGU9dGhpcy5vTmV4dCgpO3RoaXMuX3N5bS5zZXROZXh0KHQpLHQuc3ltKCkuc2V0TmV4dChlKX1kZWdyZWUoKXtsZXQgdD0wLGU9dGhpcztkb3t0KyssZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiB0fWVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX29yaWcuZXF1YWxzMkQodCkmJnRoaXMuX3N5bS5fb3JpZy5lcXVhbHMoZSl9fWZpbmRMb3dlc3QoKXtsZXQgdD10aGlzLGU9dGhpcy5vTmV4dCgpO2Rve2UuY29tcGFyZVRvKHQpPDAmJih0PWUpLGU9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gdH1kaXJlY3Rpb25QdCgpe3JldHVybiB0aGlzLmRlc3QoKX1zeW0oKXtyZXR1cm4gdGhpcy5fc3ltfXByZXYoKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfWNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKHQpe2NvbnN0IGU9dGhpcy5kaXJlY3Rpb25YKCksbj10aGlzLmRpcmVjdGlvblkoKSxzPXQuZGlyZWN0aW9uWCgpLGk9dC5kaXJlY3Rpb25ZKCk7aWYoZT09PXMmJm49PT1pKXJldHVybiAwO2NvbnN0IHI9Q24ucXVhZHJhbnQoZSxuKSxvPUNuLnF1YWRyYW50KHMsaSk7aWYocj5vKXJldHVybiAxO2lmKHI8bylyZXR1cm4tMTtjb25zdCBsPXRoaXMuZGlyZWN0aW9uUHQoKSxhPXQuZGlyZWN0aW9uUHQoKTtyZXR1cm4gcS5pbmRleCh0Ll9vcmlnLGEsbCl9cHJldk5vZGUoKXtsZXQgdD10aGlzO2Zvcig7Mj09PXQuZGVncmVlKCk7KWlmKHQ9dC5wcmV2KCksdD09PXRoaXMpcmV0dXJuIG51bGw7cmV0dXJuIHR9ZGlyZWN0aW9uWCgpe3JldHVybiB0aGlzLmRpcmVjdGlvblB0KCkuZ2V0WCgpLXRoaXMuX29yaWcuZ2V0WCgpfWluc2VydGlvbkVkZ2UodCl7bGV0IGU9dGhpcztkb3tjb25zdCBuPWUub05leHQoKTtpZihuLmNvbXBhcmVUbyhlKT4wJiZ0LmNvbXBhcmVUbyhlKT49MCYmdC5jb21wYXJlVG8obik8PTApcmV0dXJuIGU7aWYobi5jb21wYXJlVG8oZSk8PTAmJih0LmNvbXBhcmVUbyhuKTw9MHx8dC5jb21wYXJlVG8oZSk+PTApKXJldHVybiBlO2U9bn13aGlsZShlIT09dGhpcyk7cmV0dXJuIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSxudWxsfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZUFuZ3VsYXJEaXJlY3Rpb24oZSl9dG9TdHJpbmdOb2RlKCl7Y29uc3QgdD10aGlzLm9yaWcoKTt0aGlzLmRlc3QoKTtjb25zdCBlPW5ldyBwdDtlLmFwcGVuZChcIk5vZGUoIFwiK1d0LmZvcm1hdCh0KStcIiApXFxuXCIpO2xldCBuPXRoaXM7ZG97ZS5hcHBlbmQoXCIgIC0+IFwiK24pLGUuYXBwZW5kKFwiXFxuXCIpLG49bi5vTmV4dCgpfXdoaWxlKG4hPT10aGlzKTtyZXR1cm4gZS50b1N0cmluZygpfWxpbmsodCl7dGhpcy5zZXRTeW0odCksdC5zZXRTeW0odGhpcyksdGhpcy5zZXROZXh0KHQpLHQuc2V0TmV4dCh0aGlzKX1uZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9c2V0U3ltKHQpe3RoaXMuX3N5bT10fW9yaWcoKXtyZXR1cm4gdGhpcy5fb3JpZ310b1N0cmluZygpe3JldHVyblwiSEUoXCIrdGhpcy5fb3JpZy54K1wiIFwiK3RoaXMuX29yaWcueStcIiwgXCIrdGhpcy5fc3ltLl9vcmlnLngrXCIgXCIrdGhpcy5fc3ltLl9vcmlnLnkrXCIpXCJ9dG9TdHJpbmdOb2RlRWRnZSgpe3JldHVyblwiICAtPiAoXCIrV3QuZm9ybWF0KHRoaXMuZGVzdCgpKX1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH19Y2xhc3MgTG4gZXh0ZW5kcyBTbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNNYXJrZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07U24uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1zdGF0aWMgc2V0TWFya0JvdGgodCxlKXt0LnNldE1hcmsoZSksdC5zeW0oKS5zZXRNYXJrKGUpfXN0YXRpYyBpc01hcmtlZCh0KXtyZXR1cm4gdC5pc01hcmtlZCgpfXN0YXRpYyBzZXRNYXJrKHQsZSl7dC5zZXRNYXJrKGUpfXN0YXRpYyBtYXJrQm90aCh0KXt0Lm1hcmsoKSx0LnN5bSgpLm1hcmsoKX1zdGF0aWMgbWFyayh0KXt0Lm1hcmsoKX1tYXJrKCl7dGhpcy5faXNNYXJrZWQ9ITB9c2V0TWFyayh0KXt0aGlzLl9pc01hcmtlZD10fWlzTWFya2VkKCl7cmV0dXJuIHRoaXMuX2lzTWFya2VkfX1jbGFzcyBUbntjb25zdHJ1Y3Rvcigpe1RuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3ZlcnRleE1hcD1uZXcgTnR9c3RhdGljIGlzVmFsaWRFZGdlKHQsZSl7cmV0dXJuIDAhPT1lLmNvbXBhcmVUbyh0KX1pbnNlcnQodCxlLG4pe2NvbnN0IHM9dGhpcy5jcmVhdGUodCxlKTtudWxsIT09bj9uLmluc2VydChzKTp0aGlzLl92ZXJ0ZXhNYXAucHV0KHQscyk7Y29uc3QgaT10aGlzLl92ZXJ0ZXhNYXAuZ2V0KGUpO3JldHVybiBudWxsIT09aT9pLmluc2VydChzLnN5bSgpKTp0aGlzLl92ZXJ0ZXhNYXAucHV0KGUscy5zeW0oKSksc31jcmVhdGUodCxlKXtjb25zdCBuPXRoaXMuY3JlYXRlRWRnZSh0KSxzPXRoaXMuY3JlYXRlRWRnZShlKTtyZXR1cm4gbi5saW5rKHMpLG59Y3JlYXRlRWRnZSh0KXtyZXR1cm4gbmV3IFNuKHQpfWFkZEVkZ2UodCxlKXtpZighVG4uaXNWYWxpZEVkZ2UodCxlKSlyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuX3ZlcnRleE1hcC5nZXQodCk7bGV0IHM9bnVsbDtpZihudWxsIT09biYmKHM9bi5maW5kKGUpKSxudWxsIT09cylyZXR1cm4gcztyZXR1cm4gdGhpcy5pbnNlcnQodCxlLG4pfWdldFZlcnRleEVkZ2VzKCl7cmV0dXJuIHRoaXMuX3ZlcnRleE1hcC52YWx1ZXMoKX1maW5kRWRnZSh0LGUpe2NvbnN0IG49dGhpcy5fdmVydGV4TWFwLmdldCh0KTtyZXR1cm4gbnVsbD09PW4/bnVsbDpuLmZpbmQoZSl9fWNsYXNzIFJuIGV4dGVuZHMgTG57Y29uc3RydWN0b3IoKXtzdXBlcigpLFJuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzU3RhcnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07TG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1zZXRTdGFydCgpe3RoaXMuX2lzU3RhcnQ9ITB9aXNTdGFydCgpe3JldHVybiB0aGlzLl9pc1N0YXJ0fX1jbGFzcyBQbiBleHRlbmRzIFRue2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1jcmVhdGVFZGdlKHQpe3JldHVybiBuZXcgUm4odCl9fWNsYXNzIE9ue2NvbnN0cnVjdG9yKCl7T24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVzdWx0PW51bGwsdGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fbGluZXM9bmV3IEwsdGhpcy5fbm9kZUVkZ2VTdGFjaz1uZXcgZW4sdGhpcy5fcmluZ1N0YXJ0RWRnZT1udWxsLHRoaXMuX2dyYXBoPW5ldyBQbn1zdGF0aWMgZGlzc29sdmUodCl7Y29uc3QgZT1uZXcgT247cmV0dXJuIGUuYWRkKHQpLGUuZ2V0UmVzdWx0KCl9YWRkTGluZSh0KXt0aGlzLl9saW5lcy5hZGQodGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQudG9Db29yZGluYXRlQXJyYXkoKSkpfXVwZGF0ZVJpbmdTdGFydEVkZ2UodCl7cmV0dXJuIHQuaXNTdGFydCgpfHwodD10LnN5bSgpKS5pc1N0YXJ0KCk/bnVsbD09PXRoaXMuX3JpbmdTdGFydEVkZ2U/KHRoaXMuX3JpbmdTdGFydEVkZ2U9dCxudWxsKTp2b2lkKHQub3JpZygpLmNvbXBhcmVUbyh0aGlzLl9yaW5nU3RhcnRFZGdlLm9yaWcoKSk8MCYmKHRoaXMuX3JpbmdTdGFydEVkZ2U9dCkpOm51bGx9Z2V0UmVzdWx0KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yZXN1bHQmJnRoaXMuY29tcHV0ZVJlc3VsdCgpLHRoaXMuX3Jlc3VsdH1wcm9jZXNzKHQpe2xldCBlPXQucHJldk5vZGUoKTtudWxsPT09ZSYmKGU9dCksdGhpcy5zdGFja0VkZ2VzKGUpLHRoaXMuYnVpbGRMaW5lcygpfWJ1aWxkUmluZyh0KXtjb25zdCBlPW5ldyBSO2xldCBuPXQ7Zm9yKGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHM9PT10KWJyZWFrO2UuYWRkKHMub3JpZygpLmNvcHkoKSwhMSksbj1zfWUuYWRkKG4uZGVzdCgpLmNvcHkoKSwhMSksdGhpcy5hZGRMaW5lKGUpfWJ1aWxkTGluZSh0KXtjb25zdCBlPW5ldyBSO2xldCBuPXQ7Zm9yKHRoaXMuX3JpbmdTdGFydEVkZ2U9bnVsbCxMbi5tYXJrQm90aChuKSxlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7dGhpcy51cGRhdGVSaW5nU3RhcnRFZGdlKG4pO2NvbnN0IHM9bi5uZXh0KCk7aWYocz09PXQpcmV0dXJuIHRoaXMuYnVpbGRSaW5nKHRoaXMuX3JpbmdTdGFydEVkZ2UpLG51bGw7ZS5hZGQocy5vcmlnKCkuY29weSgpLCExKSxuPXMsTG4ubWFya0JvdGgobil9ZS5hZGQobi5kZXN0KCkuY2xvbmUoKSwhMSksdGhpcy5zdGFja0VkZ2VzKG4uc3ltKCkpLHRoaXMuYWRkTGluZShlKX1zdGFja0VkZ2VzKHQpe2xldCBlPXQ7ZG97TG4uaXNNYXJrZWQoZSl8fHRoaXMuX25vZGVFZGdlU3RhY2suYWRkKGUpLGU9ZS5vTmV4dCgpfXdoaWxlKGUhPT10KX1jb21wdXRlUmVzdWx0KCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldFZlcnRleEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7TG4uaXNNYXJrZWQoZSl8fHRoaXMucHJvY2VzcyhlKX10aGlzLl9yZXN1bHQ9dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMuX2xpbmVzKX1idWlsZExpbmVzKCl7Zm9yKDshdGhpcy5fbm9kZUVkZ2VTdGFjay5lbXB0eSgpOyl7Y29uc3QgdD10aGlzLl9ub2RlRWRnZVN0YWNrLnBvcCgpO0xuLmlzTWFya2VkKHQpfHx0aGlzLmJ1aWxkTGluZSh0KX19YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXthcmd1bWVudHNbMF0uYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mICQmJnRoaXMuYWRkKHQpfX0pfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGQoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkKXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtsZXQgbj0hMTtmb3IobGV0IHQ9MTt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz10aGlzLl9ncmFwaC5hZGRFZGdlKGUuZ2V0Q29vcmRpbmF0ZSh0LTEpLGUuZ2V0Q29vcmRpbmF0ZSh0KSk7bnVsbCE9PXMmJihufHwocy5zZXRTdGFydCgpLG49ITApKX19fX12YXIgdm49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGluZURpc3NvbHZlcjpPbn0pO2NsYXNzIGJue3N0YXRpYyBvcHBvc2l0ZSh0KXtyZXR1cm4gdD09PWJuLkxFRlQ/Ym4uUklHSFQ6dD09PWJuLlJJR0hUP2JuLkxFRlQ6dH19Ym4uT049MCxibi5MRUZUPTEsYm4uUklHSFQ9MjtsZXQgTW49Y2xhc3N7Y29uc3RydWN0b3IoKXtNbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLm1jZT1udWxsLHRoaXMuY2hhaW5JbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubWNlPXQsdGhpcy5jaGFpbkluZGV4PWV9Y29tcHV0ZUludGVyc2VjdGlvbnModCxlKXt0aGlzLm1jZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuY2hhaW5JbmRleCx0Lm1jZSx0LmNoYWluSW5kZXgsZSl9fTtjbGFzcyBEbntjb25zdHJ1Y3Rvcigpe0RuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xhYmVsPW51bGwsdGhpcy5feFZhbHVlPW51bGwsdGhpcy5fZXZlbnRUeXBlPW51bGwsdGhpcy5faW5zZXJ0RXZlbnQ9bnVsbCx0aGlzLl9kZWxldGVFdmVudEluZGV4PW51bGwsdGhpcy5fb2JqPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2V2ZW50VHlwZT1Ebi5ERUxFVEUsdGhpcy5feFZhbHVlPXQsdGhpcy5faW5zZXJ0RXZlbnQ9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ldmVudFR5cGU9RG4uSU5TRVJULHRoaXMuX2xhYmVsPXQsdGhpcy5feFZhbHVlPWUsdGhpcy5fb2JqPW59fWlzRGVsZXRlKCl7cmV0dXJuIHRoaXMuX2V2ZW50VHlwZT09PURuLkRFTEVURX1zZXREZWxldGVFdmVudEluZGV4KHQpe3RoaXMuX2RlbGV0ZUV2ZW50SW5kZXg9dH1nZXRPYmplY3QoKXtyZXR1cm4gdGhpcy5fb2JqfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX3hWYWx1ZTxlLl94VmFsdWU/LTE6dGhpcy5feFZhbHVlPmUuX3hWYWx1ZT8xOnRoaXMuX2V2ZW50VHlwZTxlLl9ldmVudFR5cGU/LTE6dGhpcy5fZXZlbnRUeXBlPmUuX2V2ZW50VHlwZT8xOjB9Z2V0SW5zZXJ0RXZlbnQoKXtyZXR1cm4gdGhpcy5faW5zZXJ0RXZlbnR9aXNJbnNlcnQoKXtyZXR1cm4gdGhpcy5fZXZlbnRUeXBlPT09RG4uSU5TRVJUfWlzU2FtZUxhYmVsKHQpe3JldHVybiBudWxsIT09dGhpcy5fbGFiZWwmJnRoaXMuX2xhYmVsPT09dC5fbGFiZWx9Z2V0RGVsZXRlRXZlbnRJbmRleCgpe3JldHVybiB0aGlzLl9kZWxldGVFdmVudEluZGV4fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19RG4uSU5TRVJUPTEsRG4uREVMRVRFPTI7Y2xhc3MgQW57fWxldCBGbj1jbGFzc3tjb25zdHJ1Y3Rvcigpe0ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9oYXNQcm9wZXI9ITEsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX2luY2x1ZGVQcm9wZXI9bnVsbCx0aGlzLl9yZWNvcmRJc29sYXRlZD1udWxsLHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMuX251bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTAsdGhpcy5fYmR5Tm9kZXM9bnVsbCx0aGlzLl9pc0RvbmU9ITEsdGhpcy5faXNEb25lV2hlblByb3BlckludD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9saT10LHRoaXMuX2luY2x1ZGVQcm9wZXI9ZSx0aGlzLl9yZWNvcmRJc29sYXRlZD1ufXN0YXRpYyBpc0FkamFjZW50U2VnbWVudHModCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9aXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2lmKHQ9PT1uJiYxPT09dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKEZuLmlzQWRqYWNlbnRTZWdtZW50cyhlLHMpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7Y29uc3Qgbj10LmdldE51bVBvaW50cygpLTE7aWYoMD09PWUmJnM9PT1ufHwwPT09cyYmZT09PW4pcmV0dXJuITB9fXJldHVybiExfWdldFByb3BlckludGVyc2VjdGlvblBvaW50KCl7cmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50fXNldElzRG9uZUlmUHJvcGVySW50KHQpe3RoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQ9dH1oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcn1pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpLmdldENvb3JkaW5hdGUoKTtpZih0LmlzSW50ZXJzZWN0aW9uKGUpKXJldHVybiEwfXJldHVybiExfWhhc1Byb3BlckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJ9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4gdGhpcy5faXNEb25lfWlzQm91bmRhcnlQb2ludCh0LGUpe3JldHVybiBudWxsIT09ZSYmKCEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMF0pfHwhIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzFdKSl9c2V0Qm91bmRhcnlOb2Rlcyh0LGUpe3RoaXMuX2JkeU5vZGVzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2JkeU5vZGVzWzBdPXQsdGhpcy5fYmR5Tm9kZXNbMV09ZX1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLl9yZWNvcmRJc29sYXRlZCYmKHQuc2V0SXNvbGF0ZWQoITEpLG4uc2V0SXNvbGF0ZWQoITEpKSx0aGlzLl9udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsIXRoaXMuX2luY2x1ZGVQcm9wZXImJnRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKSksdGhpcy5fbGkuaXNQcm9wZXIoKSYmKHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCksdGhpcy5faGFzUHJvcGVyPSEwLHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQmJih0aGlzLl9pc0RvbmU9ITApLHRoaXMuaXNCb3VuZGFyeVBvaW50KHRoaXMuX2xpLHRoaXMuX2JkeU5vZGVzKXx8KHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSEwKSkpKX19O2NsYXNzIEduIGV4dGVuZHMgQW57Y29uc3RydWN0b3IoKXtzdXBlcigpLEduLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuZXZlbnRzPW5ldyBMLHRoaXMubk92ZXJsYXBzPW51bGx9cHJlcGFyZUV2ZW50cygpe3hlLnNvcnQodGhpcy5ldmVudHMpO2ZvcihsZXQgdD0wO3Q8dGhpcy5ldmVudHMuc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLmV2ZW50cy5nZXQodCk7ZS5pc0RlbGV0ZSgpJiZlLmdldEluc2VydEV2ZW50KCkuc2V0RGVsZXRlRXZlbnRJbmRleCh0KX19Y29tcHV0ZUludGVyc2VjdGlvbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5uT3ZlcmxhcHM9MCx0aGlzLnByZXBhcmVFdmVudHMoKTtmb3IobGV0IGU9MDtlPHRoaXMuZXZlbnRzLnNpemUoKTtlKyspe2NvbnN0IG49dGhpcy5ldmVudHMuZ2V0KGUpO2lmKG4uaXNJbnNlcnQoKSYmdGhpcy5wcm9jZXNzT3ZlcmxhcHMoZSxuLmdldERlbGV0ZUV2ZW50SW5kZXgoKSxuLHQpLHQuaXNEb25lKCkpYnJlYWt9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBGbiYmSShhcmd1bWVudHNbMF0sQykmJkkoYXJndW1lbnRzWzFdLEMpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmFkZEVkZ2VzKHQsdCksdGhpcy5hZGRFZGdlcyhlLGUpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMobil9ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmSShhcmd1bWVudHNbMF0sQykmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgRm4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXT90aGlzLmFkZEVkZ2VzKHQsbnVsbCk6dGhpcy5hZGRFZGdlcyh0KSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKGUpfX1hZGRFZGdlKHQsZSl7Y29uc3Qgbj10LmdldE1vbm90b25lQ2hhaW5FZGdlKCkscz1uLmdldFN0YXJ0SW5kZXhlcygpO2ZvcihsZXQgdD0wO3Q8cy5sZW5ndGgtMTt0Kyspe2NvbnN0IHM9bmV3IE1uKG4sdCksaT1uZXcgRG4oZSxuLmdldE1pblgodCkscyk7dGhpcy5ldmVudHMuYWRkKGkpLHRoaXMuZXZlbnRzLmFkZChuZXcgRG4obi5nZXRNYXhYKHQpLGkpKX19cHJvY2Vzc092ZXJsYXBzKHQsZSxuLHMpe2NvbnN0IGk9bi5nZXRPYmplY3QoKTtmb3IobGV0IHI9dDtyPGU7cisrKXtjb25zdCB0PXRoaXMuZXZlbnRzLmdldChyKTtpZih0LmlzSW5zZXJ0KCkpe2NvbnN0IGU9dC5nZXRPYmplY3QoKTtuLmlzU2FtZUxhYmVsKHQpfHwoaS5jb21wdXRlSW50ZXJzZWN0aW9ucyhlLHMpLHRoaXMubk92ZXJsYXBzKyspfX19YWRkRWRnZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZEVkZ2UoZSxlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmFkZEVkZ2Uobix0KX19fX1jbGFzcyBxbntjb25zdHJ1Y3Rvcigpe3FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMubG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQubGVuZ3RoKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KDEpLHRoaXMubG9jYXRpb25bYm4uT05dPXR9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFuKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmluaXQodC5sb2NhdGlvbi5sZW5ndGgpLG51bGwhPT10KWZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09dC5sb2NhdGlvbltlXX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5pbml0KDMpLHRoaXMubG9jYXRpb25bYm4uT05dPXQsdGhpcy5sb2NhdGlvbltibi5MRUZUXT1lLHRoaXMubG9jYXRpb25bYm4uUklHSFRdPW59fXNldEFsbExvY2F0aW9ucyh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPXR9aXNOdWxsKCl7Zm9yKGxldCB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XSE9PVF0Lk5PTkUpcmV0dXJuITE7cmV0dXJuITB9c2V0QWxsTG9jYXRpb25zSWZOdWxsKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09PT1RdC5OT05FJiYodGhpcy5sb2NhdGlvbltlXT10KX1pc0xpbmUoKXtyZXR1cm4gMT09PXRoaXMubG9jYXRpb24ubGVuZ3RofW1lcmdlKHQpe2lmKHQubG9jYXRpb24ubGVuZ3RoPnRoaXMubG9jYXRpb24ubGVuZ3RoKXtjb25zdCB0PW5ldyBBcnJheSgzKS5maWxsKG51bGwpO3RbYm4uT05dPXRoaXMubG9jYXRpb25bYm4uT05dLHRbYm4uTEVGVF09UXQuTk9ORSx0W2JuLlJJR0hUXT1RdC5OT05FLHRoaXMubG9jYXRpb249dH1mb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPT09UXQuTk9ORSYmZTx0LmxvY2F0aW9uLmxlbmd0aCYmKHRoaXMubG9jYXRpb25bZV09dC5sb2NhdGlvbltlXSl9Z2V0TG9jYXRpb25zKCl7cmV0dXJuIHRoaXMubG9jYXRpb259ZmxpcCgpe2lmKHRoaXMubG9jYXRpb24ubGVuZ3RoPD0xKXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5sb2NhdGlvbltibi5MRUZUXTt0aGlzLmxvY2F0aW9uW2JuLkxFRlRdPXRoaXMubG9jYXRpb25bYm4uUklHSFRdLHRoaXMubG9jYXRpb25bYm4uUklHSFRdPXR9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB2O3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChRdC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bYm4uTEVGVF0pKSx0LmFwcGVuZChRdC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bYm4uT05dKSksdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQoUXQudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2JuLlJJR0hUXSkpLHQudG9TdHJpbmcoKX1zZXRMb2NhdGlvbnModCxlLG4pe3RoaXMubG9jYXRpb25bYm4uT05dPXQsdGhpcy5sb2NhdGlvbltibi5MRUZUXT1lLHRoaXMubG9jYXRpb25bYm4uUklHSFRdPW59Z2V0KHQpe3JldHVybiB0PHRoaXMubG9jYXRpb24ubGVuZ3RoP3RoaXMubG9jYXRpb25bdF06UXQuTk9ORX1pc0FyZWEoKXtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MX1pc0FueU51bGwoKXtmb3IobGV0IHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdPT09UXQuTk9ORSlyZXR1cm4hMDtyZXR1cm4hMX1zZXRMb2NhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldExvY2F0aW9uKGJuLk9OLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubG9jYXRpb25bdF09ZX19aW5pdCh0KXt0aGlzLmxvY2F0aW9uPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuc2V0QWxsTG9jYXRpb25zKFF0Lk5PTkUpfWlzRXF1YWxPblNpZGUodCxlKXtyZXR1cm4gdGhpcy5sb2NhdGlvbltlXT09PXQubG9jYXRpb25bZV19YWxsUG9zaXRpb25zRXF1YWwodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspaWYodGhpcy5sb2NhdGlvbltlXSE9PXQpcmV0dXJuITE7cmV0dXJuITB9fWNsYXNzIEJue2NvbnN0cnVjdG9yKCl7Qm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5lbHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IHFuKHQpLHRoaXMuZWx0WzFdPW5ldyBxbih0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQm4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBxbih0LmVsdFswXSksdGhpcy5lbHRbMV09bmV3IHFuKHQuZWx0WzFdKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbMF09bmV3IHFuKFF0Lk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBxbihRdC5OT05FKSx0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmVsdFswXT1uZXcgcW4odCxlLG4pLHRoaXMuZWx0WzFdPW5ldyBxbih0LGUsbil9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5lbHRbMF09bmV3IHFuKFF0Lk5PTkUsUXQuTk9ORSxRdC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgcW4oUXQuTk9ORSxRdC5OT05FLFF0Lk5PTkUpLHRoaXMuZWx0W3RdLnNldExvY2F0aW9ucyhlLG4scyl9fXN0YXRpYyB0b0xpbmVMYWJlbCh0KXtjb25zdCBlPW5ldyBCbihRdC5OT05FKTtmb3IobGV0IG49MDtuPDI7bisrKWUuc2V0TG9jYXRpb24obix0LmdldExvY2F0aW9uKG4pKTtyZXR1cm4gZX1nZXRHZW9tZXRyeUNvdW50KCl7bGV0IHQ9MDtyZXR1cm4gdGhpcy5lbHRbMF0uaXNOdWxsKCl8fHQrKyx0aGlzLmVsdFsxXS5pc051bGwoKXx8dCsrLHR9c2V0QWxsTG9jYXRpb25zKHQsZSl7dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zKGUpfWlzTnVsbCh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNOdWxsKCl9c2V0QWxsTG9jYXRpb25zSWZOdWxsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdCksdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoZSl9fWlzTGluZSh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNMaW5lKCl9bWVyZ2UodCl7Zm9yKGxldCBlPTA7ZTwyO2UrKyludWxsPT09dGhpcy5lbHRbZV0mJm51bGwhPT10LmVsdFtlXT90aGlzLmVsdFtlXT1uZXcgcW4odC5lbHRbZV0pOnRoaXMuZWx0W2VdLm1lcmdlKHQuZWx0W2VdKX1mbGlwKCl7dGhpcy5lbHRbMF0uZmxpcCgpLHRoaXMuZWx0WzFdLmZsaXAoKX1nZXRMb2NhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KGJuLk9OKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZWx0W3RdLmdldChlKX19dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB2O3JldHVybiBudWxsIT09dGhpcy5lbHRbMF0mJih0LmFwcGVuZChcIkE6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzBdLnRvU3RyaW5nKCkpKSxudWxsIT09dGhpcy5lbHRbMV0mJih0LmFwcGVuZChcIiBCOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFsxXS50b1N0cmluZygpKSksdC50b1N0cmluZygpfWlzQXJlYSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmVsdFswXS5pc0FyZWEoKXx8dGhpcy5lbHRbMV0uaXNBcmVhKCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5pc0FyZWEoKX19aXNBbnlOdWxsKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0FueU51bGwoKX1zZXRMb2NhdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihibi5PTixlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihlLG4pfX1pc0VxdWFsT25TaWRlKHQsZSl7cmV0dXJuIHRoaXMuZWx0WzBdLmlzRXF1YWxPblNpZGUodC5lbHRbMF0sZSkmJnRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUodC5lbHRbMV0sZSl9YWxsUG9zaXRpb25zRXF1YWwodCxlKXtyZXR1cm4gdGhpcy5lbHRbdF0uYWxsUG9zaXRpb25zRXF1YWwoZSl9dG9MaW5lKHQpe3RoaXMuZWx0W3RdLmlzQXJlYSgpJiYodGhpcy5lbHRbdF09bmV3IHFuKHRoaXMuZWx0W3RdLmxvY2F0aW9uWzBdKSl9fWNsYXNzIFlue2NvbnN0cnVjdG9yKCl7WW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5kaXN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5jb29yZD1uZXcgbSh0KSx0aGlzLnNlZ21lbnRJbmRleD1lLHRoaXMuZGlzdD1ufWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29vcmR9cHJpbnQodCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpLHQucHJpbnRsbihcIiBkaXN0ID0gXCIrdGhpcy5kaXN0KX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmUoZS5zZWdtZW50SW5kZXgsZS5kaXN0KX1pc0VuZFBvaW50KHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJjA9PT10aGlzLmRpc3R8fHRoaXMuc2VnbWVudEluZGV4PT09dH10b1N0cmluZygpe3JldHVybiB0aGlzLmNvb3JkK1wiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgrXCIgZGlzdCA9IFwiK3RoaXMuZGlzdH1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLmRpc3R9Y29tcGFyZSh0LGUpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDx0Py0xOnRoaXMuc2VnbWVudEluZGV4PnQ/MTp0aGlzLmRpc3Q8ZT8tMTp0aGlzLmRpc3Q+ZT8xOjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBWbiBleHRlbmRzIHh0e31mdW5jdGlvbiB6bih0KXtyZXR1cm4gbnVsbD09dD8wOnQuY29sb3J9ZnVuY3Rpb24gWG4odCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnBhcmVudH1mdW5jdGlvbiBrbih0LGUpe251bGwhPT10JiYodC5jb2xvcj1lKX1mdW5jdGlvbiBVbih0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQubGVmdH1mdW5jdGlvbiBIbih0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucmlnaHR9Y2xhc3MgV24gZXh0ZW5kcyBWbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5yb290Xz1udWxsLHRoaXMuc2l6ZV89MH1nZXQodCl7bGV0IGU9dGhpcy5yb290Xztmb3IoO251bGwhPT1lOyl7Y29uc3Qgbj10LmNvbXBhcmVUbyhlLmtleSk7aWYobjwwKWU9ZS5sZWZ0O2Vsc2V7aWYoIShuPjApKXJldHVybiBlLnZhbHVlO2U9ZS5yaWdodH19cmV0dXJuIG51bGx9cHV0KHQsZSl7aWYobnVsbD09PXRoaXMucm9vdF8pcmV0dXJuIHRoaXMucm9vdF89e2tleTp0LHZhbHVlOmUsbGVmdDpudWxsLHJpZ2h0Om51bGwscGFyZW50Om51bGwsY29sb3I6MCxnZXRWYWx1ZSgpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXkoKXtyZXR1cm4gdGhpcy5rZXl9fSx0aGlzLnNpemVfPTEsbnVsbDtsZXQgbixzLGk9dGhpcy5yb290Xztkb3tpZihuPWkscz10LmNvbXBhcmVUbyhpLmtleSksczwwKWk9aS5sZWZ0O2Vsc2V7aWYoIShzPjApKXtjb25zdCB0PWkudmFsdWU7cmV0dXJuIGkudmFsdWU9ZSx0fWk9aS5yaWdodH19d2hpbGUobnVsbCE9PWkpO2NvbnN0IHI9e2tleTp0LGxlZnQ6bnVsbCxyaWdodDpudWxsLHZhbHVlOmUscGFyZW50Om4sY29sb3I6MCxnZXRWYWx1ZSgpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXkoKXtyZXR1cm4gdGhpcy5rZXl9fTtyZXR1cm4gczwwP24ubGVmdD1yOm4ucmlnaHQ9cix0aGlzLmZpeEFmdGVySW5zZXJ0aW9uKHIpLHRoaXMuc2l6ZV8rKyxudWxsfWZpeEFmdGVySW5zZXJ0aW9uKHQpe2xldCBlO2Zvcih0LmNvbG9yPTE7bnVsbCE9dCYmdCE9PXRoaXMucm9vdF8mJjE9PT10LnBhcmVudC5jb2xvcjspWG4odCk9PT1VbihYbihYbih0KSkpPyhlPUhuKFhuKFhuKHQpKSksMT09PXpuKGUpPyhrbihYbih0KSwwKSxrbihlLDApLGtuKFhuKFhuKHQpKSwxKSx0PVhuKFhuKHQpKSk6KHQ9PT1IbihYbih0KSkmJih0PVhuKHQpLHRoaXMucm90YXRlTGVmdCh0KSksa24oWG4odCksMCksa24oWG4oWG4odCkpLDEpLHRoaXMucm90YXRlUmlnaHQoWG4oWG4odCkpKSkpOihlPVVuKFhuKFhuKHQpKSksMT09PXpuKGUpPyhrbihYbih0KSwwKSxrbihlLDApLGtuKFhuKFhuKHQpKSwxKSx0PVhuKFhuKHQpKSk6KHQ9PT1VbihYbih0KSkmJih0PVhuKHQpLHRoaXMucm90YXRlUmlnaHQodCkpLGtuKFhuKHQpLDApLGtuKFhuKFhuKHQpKSwxKSx0aGlzLnJvdGF0ZUxlZnQoWG4oWG4odCkpKSkpO3RoaXMucm9vdF8uY29sb3I9MH12YWx1ZXMoKXtjb25zdCB0PW5ldyBMO2xldCBlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlLnZhbHVlKTtudWxsIT09KGU9V24uc3VjY2Vzc29yKGUpKTspdC5hZGQoZS52YWx1ZSk7cmV0dXJuIHR9ZW50cnlTZXQoKXtjb25zdCB0PW5ldyBFdDtsZXQgZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZSk7bnVsbCE9PShlPVduLnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUpO3JldHVybiB0fXJvdGF0ZUxlZnQodCl7aWYobnVsbCE9dCl7Y29uc3QgZT10LnJpZ2h0O3QucmlnaHQ9ZS5sZWZ0LG51bGwhPWUubGVmdCYmKGUubGVmdC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LmxlZnQ9PT10P3QucGFyZW50LmxlZnQ9ZTp0LnBhcmVudC5yaWdodD1lLGUubGVmdD10LHQucGFyZW50PWV9fXJvdGF0ZVJpZ2h0KHQpe2lmKG51bGwhPXQpe2NvbnN0IGU9dC5sZWZ0O3QubGVmdD1lLnJpZ2h0LG51bGwhPWUucmlnaHQmJihlLnJpZ2h0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQucmlnaHQ9PT10P3QucGFyZW50LnJpZ2h0PWU6dC5wYXJlbnQubGVmdD1lLGUucmlnaHQ9dCx0LnBhcmVudD1lfX1nZXRGaXJzdEVudHJ5KCl7bGV0IHQ9dGhpcy5yb290XztpZihudWxsIT10KWZvcig7bnVsbCE9dC5sZWZ0Oyl0PXQubGVmdDtyZXR1cm4gdH1zdGF0aWMgc3VjY2Vzc29yKHQpe2xldCBlO2lmKG51bGw9PT10KXJldHVybiBudWxsO2lmKG51bGwhPT10LnJpZ2h0KXtmb3IoZT10LnJpZ2h0O251bGwhPT1lLmxlZnQ7KWU9ZS5sZWZ0O3JldHVybiBlfXtlPXQucGFyZW50O2xldCBuPXQ7Zm9yKDtudWxsIT09ZSYmbj09PWUucmlnaHQ7KW49ZSxlPWUucGFyZW50O3JldHVybiBlfX1zaXplKCl7cmV0dXJuIHRoaXMuc2l6ZV99Y29udGFpbnNLZXkodCl7bGV0IGU9dGhpcy5yb290Xztmb3IoO251bGwhPT1lOyl7Y29uc3Qgbj10LmNvbXBhcmVUbyhlLmtleSk7aWYobjwwKWU9ZS5sZWZ0O2Vsc2V7aWYoIShuPjApKXJldHVybiEwO2U9ZS5yaWdodH19cmV0dXJuITF9fWNsYXNzIFpue2NvbnN0cnVjdG9yKCl7Wm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZU1hcD1uZXcgV24sdGhpcy5lZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9cHJpbnQodCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9YWRkU3BsaXRFZGdlcyh0KXt0aGlzLmFkZEVuZHBvaW50cygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpLGk9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixzKTt0LmFkZChpKSxuPXN9fWFkZEVuZHBvaW50cygpe2NvbnN0IHQ9dGhpcy5lZGdlLnB0cy5sZW5ndGgtMTt0aGlzLmFkZCh0aGlzLmVkZ2UucHRzWzBdLDAsMCksdGhpcy5hZGQodGhpcy5lZGdlLnB0c1t0XSx0LDApfWNyZWF0ZVNwbGl0RWRnZSh0LGUpe2xldCBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzI7Y29uc3Qgcz10aGlzLmVkZ2UucHRzW2Uuc2VnbWVudEluZGV4XSxpPWUuZGlzdD4wfHwhZS5jb29yZC5lcXVhbHMyRChzKTtpfHxuLS07Y29uc3Qgcj1uZXcgQXJyYXkobikuZmlsbChudWxsKTtsZXQgbz0wO3JbbysrXT1uZXcgbSh0LmNvb3JkKTtmb3IobGV0IG49dC5zZWdtZW50SW5kZXgrMTtuPD1lLnNlZ21lbnRJbmRleDtuKyspcltvKytdPXRoaXMuZWRnZS5wdHNbbl07cmV0dXJuIGkmJihyW29dPWUuY29vcmQpLG5ldyB0cyhyLG5ldyBCbih0aGlzLmVkZ2UuX2xhYmVsKSl9YWRkKHQsZSxuKXtjb25zdCBzPW5ldyBZbih0LGUsbiksaT10aGlzLl9ub2RlTWFwLmdldChzKTtyZXR1cm4gbnVsbCE9PWk/aToodGhpcy5fbm9kZU1hcC5wdXQocyxzKSxzKX1pc0ludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7aWYoZS5uZXh0KCkuY29vcmQuZXF1YWxzKHQpKXJldHVybiEwfXJldHVybiExfX1jbGFzcyBqbntjb25zdHJ1Y3Rvcigpe2puLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2RhdGE9bnVsbCx0aGlzLl9zaXplPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpam4uY29uc3RydWN0b3JfLmNhbGwodGhpcywxMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZGF0YT1uZXcgQXJyYXkodCkuZmlsbChudWxsKX19c2l6ZSgpe3JldHVybiB0aGlzLl9zaXplfWFkZEFsbCh0KXtyZXR1cm4gbnVsbD09PXR8fDA9PT10Lmxlbmd0aD9udWxsOih0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuX3NpemUrdC5sZW5ndGgpLFkuYXJyYXljb3B5KHQsMCx0aGlzLl9kYXRhLHRoaXMuX3NpemUsdC5sZW5ndGgpLHZvaWQodGhpcy5fc2l6ZSs9dC5sZW5ndGgpKX1lbnN1cmVDYXBhY2l0eSh0KXtpZih0PD10aGlzLl9kYXRhLmxlbmd0aClyZXR1cm4gbnVsbDtjb25zdCBlPU1hdGgubWF4KHQsMip0aGlzLl9kYXRhLmxlbmd0aCk7dGhpcy5fZGF0YT1zdC5jb3B5T2YodGhpcy5fZGF0YSxlKX10b0FycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fc2l6ZSkuZmlsbChudWxsKTtyZXR1cm4gWS5hcnJheWNvcHkodGhpcy5fZGF0YSwwLHQsMCx0aGlzLl9zaXplKSx0fWFkZCh0KXt0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuX3NpemUrMSksdGhpcy5fZGF0YVt0aGlzLl9zaXplXT10LCsrdGhpcy5fc2l6ZX19Y2xhc3MgS257c3RhdGljIHRvSW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfWdldENoYWluU3RhcnRJbmRpY2VzKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgam4oTWF0aC50cnVuYyh0Lmxlbmd0aC8yKSk7bi5hZGQoZSk7ZG97Y29uc3Qgcz10aGlzLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKHMpLGU9c313aGlsZShlPHQubGVuZ3RoLTEpO3JldHVybiBuLnRvQXJyYXkoKX1maW5kQ2hhaW5FbmQodCxlKXtjb25zdCBuPUNuLnF1YWRyYW50KHRbZV0sdFtlKzFdKTtsZXQgcz1lKzE7Zm9yKDtzPHQubGVuZ3RoOyl7aWYoQ24ucXVhZHJhbnQodFtzLTFdLHRbc10pIT09bilicmVhaztzKyt9cmV0dXJuIHMtMX1PTERnZXRDaGFpblN0YXJ0SW5kaWNlcyh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IEw7bi5hZGQoZSk7ZG97Y29uc3Qgcz10aGlzLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKHMpLGU9c313aGlsZShlPHQubGVuZ3RoLTEpO3JldHVybiBLbi50b0ludEFycmF5KG4pfX1jbGFzcyBRbntjb25zdHJ1Y3Rvcigpe1FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuZT1udWxsLHRoaXMucHRzPW51bGwsdGhpcy5zdGFydEluZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lPXQsdGhpcy5wdHM9dC5nZXRDb29yZGluYXRlcygpO2NvbnN0IGU9bmV3IEtuO3RoaXMuc3RhcnRJbmRleD1lLmdldENoYWluU3RhcnRJbmRpY2VzKHRoaXMucHRzKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31nZXRNYXhYKHQpe2NvbnN0IGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU+bj9lOm59Z2V0TWluWCh0KXtjb25zdCBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPG4/ZTpufWNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oKXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuc3RhcnRJbmRleFt0XSx0aGlzLnN0YXJ0SW5kZXhbdCsxXSxlLGUuc3RhcnRJbmRleFtuXSxlLnN0YXJ0SW5kZXhbbisxXSxzKX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtpZihlLXQ9PTEmJmktcz09MSlyZXR1cm4gci5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuZSx0LG4uZSxzKSxudWxsO2lmKCF0aGlzLm92ZXJsYXBzKHQsZSxuLHMsaSkpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKCh0K2UpLzIpLGw9TWF0aC50cnVuYygocytpKS8yKTt0PG8mJihzPGwmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0LG8sbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odCxvLG4sbCxpLHIpKSxvPGUmJihzPGwmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihvLGUsbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obyxlLG4sbCxpLHIpKX19b3ZlcmxhcHModCxlLG4scyxpKXtyZXR1cm4gTy5pbnRlcnNlY3RzKHRoaXMucHRzW3RdLHRoaXMucHRzW2VdLG4ucHRzW3NdLG4ucHRzW2ldKX1nZXRTdGFydEluZGV4ZXMoKXtyZXR1cm4gdGhpcy5zdGFydEluZGV4fWNvbXB1dGVJbnRlcnNlY3RzKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLnN0YXJ0SW5kZXgubGVuZ3RoLTE7bisrKWZvcihsZXQgcz0wO3M8dC5zdGFydEluZGV4Lmxlbmd0aC0xO3MrKyl0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obix0LHMsZSl9fWNsYXNzIEpue2NvbnN0cnVjdG9yKCl7Sm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZGVwdGg9QXJyYXkoMikuZmlsbCgpLm1hcCgoKCk9PkFycmF5KDMpKSk7Zm9yKGxldCB0PTA7dDwyO3QrKylmb3IobGV0IGU9MDtlPDM7ZSsrKXRoaXMuX2RlcHRoW3RdW2VdPUpuLk5VTExfVkFMVUV9c3RhdGljIGRlcHRoQXRMb2NhdGlvbih0KXtyZXR1cm4gdD09PVF0LkVYVEVSSU9SPzA6dD09PVF0LklOVEVSSU9SPzE6Sm4uTlVMTF9WQUxVRX1nZXREZXB0aCh0LGUpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXX1zZXREZXB0aCh0LGUsbil7dGhpcy5fZGVwdGhbdF1bZV09bn1pc051bGwoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PTA7dDwyO3QrKylmb3IobGV0IGU9MDtlPDM7ZSsrKWlmKHRoaXMuX2RlcHRoW3RdW2VdIT09Sm4uTlVMTF9WQUxVRSlyZXR1cm4hMTtyZXR1cm4hMH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RlcHRoW3RdWzFdPT09Sm4uTlVMTF9WQUxVRX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdPT09Sm4uTlVMTF9WQUxVRX19bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDwyO3QrKylpZighdGhpcy5pc051bGwodCkpe2xldCBlPXRoaXMuX2RlcHRoW3RdWzFdO3RoaXMuX2RlcHRoW3RdWzJdPGUmJihlPXRoaXMuX2RlcHRoW3RdWzJdKSxlPDAmJihlPTApO2ZvcihsZXQgbj0xO248MztuKyspe2xldCBzPTA7dGhpcy5fZGVwdGhbdF1bbl0+ZSYmKHM9MSksdGhpcy5fZGVwdGhbdF1bbl09c319fWdldERlbHRhKHQpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtibi5SSUdIVF0tdGhpcy5fZGVwdGhbdF1bYm4uTEVGVF19Z2V0TG9jYXRpb24odCxlKXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV08PTA/UXQuRVhURVJJT1I6UXQuSU5URVJJT1J9dG9TdHJpbmcoKXtyZXR1cm5cIkE6IFwiK3RoaXMuX2RlcHRoWzBdWzFdK1wiLFwiK3RoaXMuX2RlcHRoWzBdWzJdK1wiIEI6IFwiK3RoaXMuX2RlcHRoWzFdWzFdK1wiLFwiK3RoaXMuX2RlcHRoWzFdWzJdfWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPDI7ZSsrKWZvcihsZXQgbj0xO248MztuKyspe2NvbnN0IHM9dC5nZXRMb2NhdGlvbihlLG4pO3MhPT1RdC5FWFRFUklPUiYmcyE9PVF0LklOVEVSSU9SfHwodGhpcy5pc051bGwoZSxuKT90aGlzLl9kZXB0aFtlXVtuXT1Kbi5kZXB0aEF0TG9jYXRpb24ocyk6dGhpcy5fZGVwdGhbZV1bbl0rPUpuLmRlcHRoQXRMb2NhdGlvbihzKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXT09PVF0LklOVEVSSU9SJiZ0aGlzLl9kZXB0aFt0XVtlXSsrfX19Sm4uTlVMTF9WQUxVRT0tMTtsZXQgJG49Y2xhc3N7Y29uc3RydWN0b3IoKXskbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9sYWJlbD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNDb3ZlcmVkPSExLHRoaXMuX2lzQ292ZXJlZFNldD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xhYmVsPXR9fXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWlzQ292ZXJlZCgpe3JldHVybiB0aGlzLl9pc0NvdmVyZWR9aXNDb3ZlcmVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZFNldH1zZXRMYWJlbCh0KXt0aGlzLl9sYWJlbD10fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfXNldENvdmVyZWQodCl7dGhpcy5faXNDb3ZlcmVkPXQsdGhpcy5faXNDb3ZlcmVkU2V0PSEwfXVwZGF0ZUlNKHQpe2cuaXNUcnVlKHRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKT49MixcImZvdW5kIHBhcnRpYWwgbGFiZWxcIiksdGhpcy5jb21wdXRlSU0odCl9aXNJblJlc3VsdCgpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9fSx0cz1jbGFzcyBleHRlbmRzICRue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLnB0cz1udWxsLHRoaXMuX2Vudj1udWxsLHRoaXMuZWlMaXN0PW5ldyBabih0aGlzKSx0aGlzLl9uYW1lPW51bGwsdGhpcy5fbWNlPW51bGwsdGhpcy5faXNJc29sYXRlZD0hMCx0aGlzLl9kZXB0aD1uZXcgSm4sdGhpcy5fZGVwdGhEZWx0YT0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0cy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wdHM9dCx0aGlzLl9sYWJlbD1lfX1zdGF0aWMgdXBkYXRlSU0oKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEp0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEJuKSlyZXR1cm4gc3VwZXIudXBkYXRlSU0uYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxibi5PTiksdC5nZXRMb2NhdGlvbigxLGJuLk9OKSwxKSx0LmlzQXJlYSgpJiYoZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsYm4uTEVGVCksdC5nZXRMb2NhdGlvbigxLGJuLkxFRlQpLDIpLGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGJuLlJJR0hUKSx0LmdldExvY2F0aW9uKDEsYm4uUklHSFQpLDIpKX19Z2V0RGVwdGgoKXtyZXR1cm4gdGhpcy5fZGVwdGh9Z2V0Q29sbGFwc2VkRWRnZSgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7dFswXT10aGlzLnB0c1swXSx0WzFdPXRoaXMucHRzWzFdO3JldHVybiBuZXcgdHModCxCbi50b0xpbmVMYWJlbCh0aGlzLl9sYWJlbCkpfWlzSXNvbGF0ZWQoKXtyZXR1cm4gdGhpcy5faXNJc29sYXRlZH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31zZXRJc29sYXRlZCh0KXt0aGlzLl9pc0lzb2xhdGVkPXR9c2V0TmFtZSh0KXt0aGlzLl9uYW1lPXR9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIHRzKSlyZXR1cm4hMTtjb25zdCBlPXQ7aWYodGhpcy5wdHMubGVuZ3RoIT09ZS5wdHMubGVuZ3RoKXJldHVybiExO2xldCBuPSEwLHM9ITAsaT10aGlzLnB0cy5sZW5ndGg7Zm9yKGxldCB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKWlmKHRoaXMucHRzW3RdLmVxdWFsczJEKGUucHRzW3RdKXx8KG49ITEpLHRoaXMucHRzW3RdLmVxdWFsczJEKGUucHRzWy0taV0pfHwocz0hMSksIW4mJiFzKXJldHVybiExO3JldHVybiEwfWdldENvb3JkaW5hdGUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5wdHMubGVuZ3RoPjA/dGhpcy5wdHNbMF06bnVsbDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucHRzW3RdfX1wcmludCh0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIiksdC5wcmludChcIkxJTkVTVFJJTkcgKFwiKTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7dC5wcmludChcIikgIFwiK3RoaXMuX2xhYmVsK1wiIFwiK3RoaXMuX2RlcHRoRGVsdGEpfWNvbXB1dGVJTSh0KXt0cy51cGRhdGVJTSh0aGlzLl9sYWJlbCx0KX1pc0NvbGxhcHNlZCgpe3JldHVybiEhdGhpcy5fbGFiZWwuaXNBcmVhKCkmJigzPT09dGhpcy5wdHMubGVuZ3RoJiYhIXRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSkpfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfWdldE1heGltdW1TZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RoLTF9Z2V0RGVwdGhEZWx0YSgpe3JldHVybiB0aGlzLl9kZXB0aERlbHRhfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9cHJpbnRSZXZlcnNlKHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKTtmb3IobGV0IGU9dGhpcy5wdHMubGVuZ3RoLTE7ZT49MDtlLS0pdC5wcmludCh0aGlzLnB0c1tlXStcIiBcIik7dC5wcmludGxuKFwiXCIpfWdldE1vbm90b25lQ2hhaW5FZGdlKCl7cmV0dXJuIG51bGw9PT10aGlzLl9tY2UmJih0aGlzLl9tY2U9bmV3IFFuKHRoaXMpKSx0aGlzLl9tY2V9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXt0aGlzLl9lbnY9bmV3IE87Zm9yKGxldCB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMuX2Vudi5leHBhbmRUb0luY2x1ZGUodGhpcy5wdHNbdF0pfXJldHVybiB0aGlzLl9lbnZ9YWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9bmV3IG0odC5nZXRJbnRlcnNlY3Rpb24ocykpO2xldCByPWUsbz10LmdldEVkZ2VEaXN0YW5jZShuLHMpO2NvbnN0IGw9cisxO2lmKGw8dGhpcy5wdHMubGVuZ3RoKXtjb25zdCB0PXRoaXMucHRzW2xdO2kuZXF1YWxzMkQodCkmJihyPWwsbz0wKX10aGlzLmVpTGlzdC5hZGQoaSxyLG8pfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgcHQ7dC5hcHBlbmQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKSx0LmFwcGVuZChcIkxJTkVTVFJJTkcgKFwiKTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LmFwcGVuZChcIixcIiksdC5hcHBlbmQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTtyZXR1cm4gdC5hcHBlbmQoXCIpICBcIit0aGlzLl9sYWJlbCtcIiBcIit0aGlzLl9kZXB0aERlbHRhKSx0LnRvU3RyaW5nKCl9aXNQb2ludHdpc2VFcXVhbCh0KXtpZih0aGlzLnB0cy5sZW5ndGghPT10LnB0cy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWlmKCF0aGlzLnB0c1tlXS5lcXVhbHMyRCh0LnB0c1tlXSkpcmV0dXJuITE7cmV0dXJuITB9c2V0RGVwdGhEZWx0YSh0KXt0aGlzLl9kZXB0aERlbHRhPXR9Z2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKXtyZXR1cm4gdGhpcy5laUxpc3R9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixzKX19LGVzPWNsYXNzIGV4dGVuZHMgJG57Y29uc3RydWN0b3IoKXtzdXBlcigpLGVzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3JkPW51bGwsdGhpcy5fZWRnZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZD10LHRoaXMuX2VkZ2VzPWUsdGhpcy5fbGFiZWw9bmV3IEJuKDAsUXQuTk9ORSl9aXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpe2ZvcihsZXQgdD10aGlzLmdldEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7aWYodC5uZXh0KCkuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSlyZXR1cm4hMH1yZXR1cm4hMX1pc0lzb2xhdGVkKCl7cmV0dXJuIDE9PT10aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9jb29yZH1wcmludCh0KXt0LnByaW50bG4oXCJub2RlIFwiK3RoaXMuX2Nvb3JkK1wiIGxibDogXCIrdGhpcy5fbGFiZWwpfWNvbXB1dGVJTSh0KXt9Y29tcHV0ZU1lcmdlZExvY2F0aW9uKHQsZSl7bGV0IG49UXQuTk9ORTtpZihuPXRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUpLCF0LmlzTnVsbChlKSl7Y29uc3Qgcz10LmdldExvY2F0aW9uKGUpO24hPT1RdC5CT1VOREFSWSYmKG49cyl9cmV0dXJuIG59c2V0TGFiZWwoKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKXx8IU51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSlyZXR1cm4gc3VwZXIuc2V0TGFiZWwuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtudWxsPT09dGhpcy5fbGFiZWw/dGhpcy5fbGFiZWw9bmV3IEJuKHQsZSk6dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlKX19Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9bWVyZ2VMYWJlbCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZXMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VMYWJlbCh0Ll9sYWJlbCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEJuKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPDI7ZSsrKXtjb25zdCBuPXRoaXMuY29tcHV0ZU1lcmdlZExvY2F0aW9uKHQsZSk7dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSk9PT1RdC5OT05FJiZ0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbihlLG4pfX19YWRkKHQpe3RoaXMuX2VkZ2VzLmluc2VydCh0KSx0LnNldE5vZGUodGhpcyl9c2V0TGFiZWxCb3VuZGFyeSh0KXtpZihudWxsPT09dGhpcy5fbGFiZWwpcmV0dXJuIG51bGw7bGV0IGU9UXQuTk9ORTtudWxsIT09dGhpcy5fbGFiZWwmJihlPXRoaXMuX2xhYmVsLmdldExvY2F0aW9uKHQpKTtsZXQgbj1udWxsO3N3aXRjaChlKXtjYXNlIFF0LkJPVU5EQVJZOm49UXQuSU5URVJJT1I7YnJlYWs7Y2FzZSBRdC5JTlRFUklPUjpkZWZhdWx0Om49UXQuQk9VTkRBUll9dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxuKX19LG5zPWNsYXNze2NvbnN0cnVjdG9yKCl7bnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5ub2RlTWFwPW5ldyBXbix0aGlzLm5vZGVGYWN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlRmFjdD10fWZpbmQodCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9YWRkTm9kZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9dGhpcy5ub2RlTWFwLmdldCh0KTtyZXR1cm4gbnVsbD09PWUmJihlPXRoaXMubm9kZUZhY3QuY3JlYXRlTm9kZSh0KSx0aGlzLm5vZGVNYXAucHV0KHQsZSkpLGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLm5vZGVNYXAuZ2V0KHQuZ2V0Q29vcmRpbmF0ZSgpKTtyZXR1cm4gbnVsbD09PWU/KHRoaXMubm9kZU1hcC5wdXQodC5nZXRDb29yZGluYXRlKCksdCksdCk6KGUubWVyZ2VMYWJlbCh0KSxlKX19cHJpbnQodCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX12YWx1ZXMoKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfWdldEJvdW5kYXJ5Tm9kZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk9PT1RdC5CT1VOREFSWSYmZS5hZGQocyl9cmV0dXJuIGV9YWRkKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKCk7dGhpcy5hZGROb2RlKGUpLmFkZCh0KX19O2NsYXNzIHNze2NvbnN0cnVjdG9yKCl7c3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZWRnZT1udWxsLHRoaXMuX2xhYmVsPW51bGwsdGhpcy5fbm9kZT1udWxsLHRoaXMuX3AwPW51bGwsdGhpcy5fcDE9bnVsbCx0aGlzLl9keD1udWxsLHRoaXMuX2R5PW51bGwsdGhpcy5fcXVhZHJhbnQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZT10fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3NzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4sbnVsbCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107c3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLmluaXQoZSxuKSx0aGlzLl9sYWJlbD1zfX1jb21wYXJlRGlyZWN0aW9uKHQpe3JldHVybiB0aGlzLl9keD09PXQuX2R4JiZ0aGlzLl9keT09PXQuX2R5PzA6dGhpcy5fcXVhZHJhbnQ+dC5fcXVhZHJhbnQ/MTp0aGlzLl9xdWFkcmFudDx0Ll9xdWFkcmFudD8tMTpxLmluZGV4KHQuX3AwLHQuX3AxLHRoaXMuX3AxKX1nZXREeSgpe3JldHVybiB0aGlzLl9keX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3AwfXNldE5vZGUodCl7dGhpcy5fbm9kZT10fXByaW50KHQpe2NvbnN0IGU9TWF0aC5hdGFuMih0aGlzLl9keSx0aGlzLl9keCksbj10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLHM9bi5sYXN0SW5kZXhPZihcIi5cIiksaT1uLnN1YnN0cmluZyhzKzEpO3QucHJpbnQoXCIgIFwiK2krXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrZStcIiAgIFwiK3RoaXMuX2xhYmVsKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9Z2V0RGlyZWN0ZWRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3AxfWdldER4KCl7cmV0dXJuIHRoaXMuX2R4fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1nZXRRdWFkcmFudCgpe3JldHVybiB0aGlzLl9xdWFkcmFudH1nZXROb2RlKCl7cmV0dXJuIHRoaXMuX25vZGV9dG9TdHJpbmcoKXtjb25zdCB0PU1hdGguYXRhbjIodGhpcy5fZHksdGhpcy5fZHgpLGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpO3JldHVyblwiICBcIitlLnN1YnN0cmluZyhuKzEpK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK3QrXCIgICBcIit0aGlzLl9sYWJlbH1jb21wdXRlTGFiZWwodCl7fWluaXQodCxlKXt0aGlzLl9wMD10LHRoaXMuX3AxPWUsdGhpcy5fZHg9ZS54LXQueCx0aGlzLl9keT1lLnktdC55LHRoaXMuX3F1YWRyYW50PUNuLnF1YWRyYW50KHRoaXMuX2R4LHRoaXMuX2R5KSxnLmlzVHJ1ZSghKDA9PT10aGlzLl9keCYmMD09PXRoaXMuX2R5KSxcIkVkZ2VFbmQgd2l0aCBpZGVudGljYWwgZW5kcG9pbnRzIGZvdW5kXCIpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgaXMgZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIoZT90K1wiIFsgXCIrZStcIiBdXCI6dCksdGhpcy5wdD1lP25ldyBtKGUpOnZvaWQgMCx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe1RvcG9sb2d5RXhjZXB0aW9uOmlzfSlbMF19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLnB0fX1sZXQgcnM9Y2xhc3MgZXh0ZW5kcyBzc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCkscnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNGb3J3YXJkPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5fc3ltPW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX25leHRNaW49bnVsbCx0aGlzLl9lZGdlUmluZz1udWxsLHRoaXMuX21pbkVkZ2VSaW5nPW51bGwsdGhpcy5fZGVwdGg9WzAsLTk5OSwtOTk5XTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihzcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuX2lzRm9yd2FyZD1lLGUpdGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZSgwKSx0LmdldENvb3JkaW5hdGUoMSkpO2Vsc2V7Y29uc3QgZT10LmdldE51bVBvaW50cygpLTE7dGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZShlKSx0LmdldENvb3JkaW5hdGUoZS0xKSl9dGhpcy5jb21wdXRlRGlyZWN0ZWRMYWJlbCgpfXN0YXRpYyBkZXB0aEZhY3Rvcih0LGUpe3JldHVybiB0PT09UXQuRVhURVJJT1ImJmU9PT1RdC5JTlRFUklPUj8xOnQ9PT1RdC5JTlRFUklPUiYmZT09PVF0LkVYVEVSSU9SPy0xOjB9Z2V0TmV4dE1pbigpe3JldHVybiB0aGlzLl9uZXh0TWlufWdldERlcHRoKHQpe3JldHVybiB0aGlzLl9kZXB0aFt0XX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fWNvbXB1dGVEaXJlY3RlZExhYmVsKCl7dGhpcy5fbGFiZWw9bmV3IEJuKHRoaXMuX2VkZ2UuZ2V0TGFiZWwoKSksdGhpcy5faXNGb3J3YXJkfHx0aGlzLl9sYWJlbC5mbGlwKCl9Z2V0TmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fXNldERlcHRoKHQsZSl7aWYoLTk5OSE9PXRoaXMuX2RlcHRoW3RdJiZ0aGlzLl9kZXB0aFt0XSE9PWUpdGhyb3cgbmV3IGlzKFwiYXNzaWduZWQgZGVwdGhzIGRvIG5vdCBtYXRjaFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTt0aGlzLl9kZXB0aFt0XT1lfWlzSW50ZXJpb3JBcmVhRWRnZSgpe2xldCB0PSEwO2ZvcihsZXQgZT0wO2U8MjtlKyspdGhpcy5fbGFiZWwuaXNBcmVhKGUpJiZ0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlLGJuLkxFRlQpPT09UXQuSU5URVJJT1ImJnRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUsYm4uUklHSFQpPT09UXQuSU5URVJJT1J8fCh0PSExKTtyZXR1cm4gdH1zZXROZXh0TWluKHQpe3RoaXMuX25leHRNaW49dH1wcmludCh0KXtzdXBlci5wcmludC5jYWxsKHRoaXMsdCksdC5wcmludChcIiBcIit0aGlzLl9kZXB0aFtibi5MRUZUXStcIi9cIit0aGlzLl9kZXB0aFtibi5SSUdIVF0pLHQucHJpbnQoXCIgKFwiK3RoaXMuZ2V0RGVwdGhEZWx0YSgpK1wiKVwiKSx0aGlzLl9pc0luUmVzdWx0JiZ0LnByaW50KFwiIGluUmVzdWx0XCIpfXNldE1pbkVkZ2VSaW5nKHQpe3RoaXMuX21pbkVkZ2VSaW5nPXR9aXNMaW5lRWRnZSgpe2NvbnN0IHQ9dGhpcy5fbGFiZWwuaXNMaW5lKDApfHx0aGlzLl9sYWJlbC5pc0xpbmUoMSksZT0hdGhpcy5fbGFiZWwuaXNBcmVhKDApfHx0aGlzLl9sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgwLFF0LkVYVEVSSU9SKSxuPSF0aGlzLl9sYWJlbC5pc0FyZWEoMSl8fHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDEsUXQuRVhURVJJT1IpO3JldHVybiB0JiZlJiZufXNldEVkZ2VSaW5nKHQpe3RoaXMuX2VkZ2VSaW5nPXR9Z2V0TWluRWRnZVJpbmcoKXtyZXR1cm4gdGhpcy5fbWluRWRnZVJpbmd9Z2V0RGVwdGhEZWx0YSgpe2xldCB0PXRoaXMuX2VkZ2UuZ2V0RGVwdGhEZWx0YSgpO3JldHVybiB0aGlzLl9pc0ZvcndhcmR8fCh0PS10KSx0fXNldEluUmVzdWx0KHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH1nZXRTeW0oKXtyZXR1cm4gdGhpcy5fc3ltfWlzRm9yd2FyZCgpe3JldHVybiB0aGlzLl9pc0ZvcndhcmR9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfXByaW50RWRnZSh0KXt0aGlzLnByaW50KHQpLHQucHJpbnQoXCIgXCIpLHRoaXMuX2lzRm9yd2FyZD90aGlzLl9lZGdlLnByaW50KHQpOnRoaXMuX2VkZ2UucHJpbnRSZXZlcnNlKHQpfXNldFN5bSh0KXt0aGlzLl9zeW09dH1zZXRWaXNpdGVkRWRnZSh0KXt0aGlzLnNldFZpc2l0ZWQodCksdGhpcy5fc3ltLnNldFZpc2l0ZWQodCl9c2V0RWRnZURlcHRocyh0LGUpe2xldCBuPXRoaXMuZ2V0RWRnZSgpLmdldERlcHRoRGVsdGEoKTt0aGlzLl9pc0ZvcndhcmR8fChuPS1uKTtsZXQgcz0xO3Q9PT1ibi5MRUZUJiYocz0tMSk7Y29uc3QgaT1ibi5vcHBvc2l0ZSh0KSxyPWUrbipzO3RoaXMuc2V0RGVwdGgodCxlKSx0aGlzLnNldERlcHRoKGkscil9Z2V0RWRnZVJpbmcoKXtyZXR1cm4gdGhpcy5fZWRnZVJpbmd9aXNJblJlc3VsdCgpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fXNldE5leHQodCl7dGhpcy5fbmV4dD10fWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9fTtjbGFzcyBvc3tjcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgZXModCxudWxsKX19bGV0IGxzPWNsYXNze2NvbnN0cnVjdG9yKCl7bHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZWRnZXM9bmV3IEwsdGhpcy5fbm9kZXM9bnVsbCx0aGlzLl9lZGdlRW5kTGlzdD1uZXcgTCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9ub2Rlcz1uZXcgbnMobmV3IG9zKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ub2Rlcz1uZXcgbnModCl9fXN0YXRpYyBsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX1wcmludEVkZ2VzKHQpe3QucHJpbnRsbihcIkVkZ2VzOlwiKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspe3QucHJpbnRsbihcImVkZ2UgXCIrZStcIjpcIik7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7bi5wcmludCh0KSxuLmVpTGlzdC5wcmludCh0KX19ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZXMuZmluZCh0KX1hZGROb2RlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlcyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZSh0KX19Z2V0Tm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKCl9bGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19ZGVidWdQcmludGxuKHQpe1kub3V0LnByaW50bG4odCl9aXNCb3VuZGFyeU5vZGUodCxlKXtjb25zdCBuPXRoaXMuX25vZGVzLmZpbmQoZSk7aWYobnVsbD09PW4pcmV0dXJuITE7Y29uc3Qgcz1uLmdldExhYmVsKCk7cmV0dXJuIG51bGwhPT1zJiZzLmdldExvY2F0aW9uKHQpPT09UXQuQk9VTkRBUll9bGlua0FsbERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua0FsbERpcmVjdGVkRWRnZXMoKX19bWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLG4scyl7cmV0dXJuISF0LmVxdWFscyhuKSYmKHEuaW5kZXgodCxlLHMpPT09cS5DT0xMSU5FQVImJkNuLnF1YWRyYW50KHQsZSk9PT1Dbi5xdWFkcmFudChuLHMpKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kTGlzdH1kZWJ1Z1ByaW50KHQpe1kub3V0LnByaW50KHQpfWdldEVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLl9lZGdlcy5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuX2VkZ2VzLmdldChuKSxpPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxpWzBdLGlbMV0pKXJldHVybiBzO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLGlbaS5sZW5ndGgtMV0saVtpLmxlbmd0aC0yXSkpcmV0dXJuIHN9cmV0dXJuIG51bGx9aW5zZXJ0RWRnZSh0KXt0aGlzLl9lZGdlcy5hZGQodCl9ZmluZEVkZ2VFbmQodCl7Zm9yKGxldCBlPXRoaXMuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuLmdldEVkZ2UoKT09PXQpcmV0dXJuIG59cmV0dXJuIG51bGx9YWRkRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IG49bmV3IHJzKHQsITApLHM9bmV3IHJzKHQsITEpO24uc2V0U3ltKHMpLHMuc2V0U3ltKG4pLHRoaXMuYWRkKG4pLHRoaXMuYWRkKHMpfX1hZGQodCl7dGhpcy5fbm9kZXMuYWRkKHQpLHRoaXMuX2VkZ2VFbmRMaXN0LmFkZCh0KX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2Rlcy52YWx1ZXMoKX1maW5kRWRnZSh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5fZWRnZXMuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLl9lZGdlcy5nZXQobiksaT1zLmdldENvb3JkaW5hdGVzKCk7aWYodC5lcXVhbHMoaVswXSkmJmUuZXF1YWxzKGlbMV0pKXJldHVybiBzfXJldHVybiBudWxsfX07Y2xhc3MgYXMgZXh0ZW5kcyBsc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksYXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcGFyZW50R2VvbT1udWxsLHRoaXMuX2xpbmVFZGdlTWFwPW5ldyBOdCx0aGlzLl9ib3VuZGFyeU5vZGVSdWxlPW51bGwsdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMCx0aGlzLl9hcmdJbmRleD1udWxsLHRoaXMuX2JvdW5kYXJ5Tm9kZXM9bnVsbCx0aGlzLl9oYXNUb29GZXdQb2ludHM9ITEsdGhpcy5faW52YWxpZFBvaW50PW51bGwsdGhpcy5fYXJlYVB0TG9jYXRvcj1udWxsLHRoaXMuX3B0TG9jYXRvcj1uZXcgZm4sMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLGduLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fYXJnSW5kZXg9dCx0aGlzLl9wYXJlbnRHZW9tPWUsdGhpcy5fYm91bmRhcnlOb2RlUnVsZT1uLG51bGwhPT1lJiZ0aGlzLmFkZChlKX19c3RhdGljIGRldGVybWluZUJvdW5kYXJ5KHQsZSl7cmV0dXJuIHQuaXNJbkJvdW5kYXJ5KGUpP1F0LkJPVU5EQVJZOlF0LklOVEVSSU9SfWluc2VydEJvdW5kYXJ5UG9pbnQodCxlKXtjb25zdCBuPXRoaXMuX25vZGVzLmFkZE5vZGUoZSkuZ2V0TGFiZWwoKTtsZXQgcz0xLGk9UXQuTk9ORTtpPW4uZ2V0TG9jYXRpb24odCxibi5PTiksaT09PVF0LkJPVU5EQVJZJiZzKys7Y29uc3Qgcj1hcy5kZXRlcm1pbmVCb3VuZGFyeSh0aGlzLl9ib3VuZGFyeU5vZGVSdWxlLHMpO24uc2V0TG9jYXRpb24odCxyKX1jb21wdXRlU2VsZk5vZGVzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXB1dGVTZWxmTm9kZXModCxlLCExKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1uZXcgRm4oYXJndW1lbnRzWzBdLCEwLCExKTtuLnNldElzRG9uZUlmUHJvcGVySW50KGUpO2NvbnN0IHM9dGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKSxpPXRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBndHx8dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIHJ0fHx0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgeXQscj10fHwhaTtyZXR1cm4gcy5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcyxuLHIpLHRoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHRoaXMuX2FyZ0luZGV4KSxufX1jb21wdXRlU3BsaXRFZGdlcyh0KXtmb3IobGV0IGU9dGhpcy5fZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmVpTGlzdC5hZGRTcGxpdEVkZ2VzKHQpfX1jb21wdXRlRWRnZUludGVyc2VjdGlvbnModCxlLG4pe2NvbnN0IHM9bmV3IEZuKGUsbiwhMCk7cy5zZXRCb3VuZGFyeU5vZGVzKHRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLHQuZ2V0Qm91bmRhcnlOb2RlcygpKTtyZXR1cm4gdGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKS5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcyx0Ll9lZGdlcyxzKSxzfWdldEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX3BhcmVudEdlb219Z2V0Qm91bmRhcnlOb2RlUnVsZSgpe3JldHVybiB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlfWhhc1Rvb0Zld1BvaW50cygpe3JldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHN9YWRkUG9pbnQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGV0KXtjb25zdCB0PWFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCx0LFF0LklOVEVSSU9SKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCx0LFF0LklOVEVSSU9SKX19YWRkUG9seWdvbih0KXt0aGlzLmFkZFBvbHlnb25SaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IG49dC5nZXRJbnRlcmlvclJpbmdOKGUpO3RoaXMuYWRkUG9seWdvblJpbmcobixRdC5JTlRFUklPUixRdC5FWFRFUklPUil9fWFkZEVkZ2UodCl7dGhpcy5pbnNlcnRFZGdlKHQpO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsZVswXSxRdC5CT1VOREFSWSksdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxlW2UubGVuZ3RoLTFdLFF0LkJPVU5EQVJZKX1hZGRMaW5lU3RyaW5nKHQpe2NvbnN0IGU9X3QucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5faW52YWxpZFBvaW50PWVbMF0sbnVsbDtjb25zdCBuPW5ldyB0cyhlLG5ldyBCbih0aGlzLl9hcmdJbmRleCxRdC5JTlRFUklPUikpO3RoaXMuX2xpbmVFZGdlTWFwLnB1dCh0LG4pLHRoaXMuaW5zZXJ0RWRnZShuKSxnLmlzVHJ1ZShlLmxlbmd0aD49MixcImZvdW5kIExpbmVTdHJpbmcgd2l0aCBzaW5nbGUgcG9pbnRcIiksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LGVbMF0pLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCxlW2UubGVuZ3RoLTFdKX1nZXRJbnZhbGlkUG9pbnQoKXtyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50fWdldEJvdW5kYXJ5UG9pbnRzKCl7Y29uc3QgdD10aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSxlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtsZXQgbj0wO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2VbbisrXT10LmdldENvb3JkaW5hdGUoKS5jb3B5KCl9cmV0dXJuIGV9Z2V0Qm91bmRhcnlOb2Rlcygpe3JldHVybiBudWxsPT09dGhpcy5fYm91bmRhcnlOb2RlcyYmKHRoaXMuX2JvdW5kYXJ5Tm9kZXM9dGhpcy5fbm9kZXMuZ2V0Qm91bmRhcnlOb2Rlcyh0aGlzLl9hcmdJbmRleCkpLHRoaXMuX2JvdW5kYXJ5Tm9kZXN9YWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxlLG4pe2lmKHRoaXMuaXNCb3VuZGFyeU5vZGUodCxlKSlyZXR1cm4gbnVsbDtuPT09UXQuQk9VTkRBUlkmJnRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU/dGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSk6dGhpcy5pbnNlcnRQb2ludCh0LGUsbil9YWRkUG9seWdvblJpbmcodCxlLG4pe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHM9X3QucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihzLmxlbmd0aDw0KXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5faW52YWxpZFBvaW50PXNbMF0sbnVsbDtsZXQgaT1lLHI9bjtxLmlzQ0NXKHMpJiYoaT1uLHI9ZSk7Y29uc3Qgbz1uZXcgdHMocyxuZXcgQm4odGhpcy5fYXJnSW5kZXgsUXQuQk9VTkRBUlksaSxyKSk7dGhpcy5fbGluZUVkZ2VNYXAucHV0KHQsbyksdGhpcy5pbnNlcnRFZGdlKG8pLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsc1swXSxRdC5CT1VOREFSWSl9aW5zZXJ0UG9pbnQodCxlLG4pe2NvbnN0IHM9dGhpcy5fbm9kZXMuYWRkTm9kZShlKSxpPXMuZ2V0TGFiZWwoKTtudWxsPT09aT9zLl9sYWJlbD1uZXcgQm4odCxuKTppLnNldExvY2F0aW9uKHQsbil9Y3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCl7cmV0dXJuIG5ldyBHbn1hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2ZvcihsZXQgZT1uLmVpTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQsbi5jb29yZCxzKX19fWFkZCgpe2lmKCEoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSkpcmV0dXJuIHN1cGVyLmFkZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiB5dCYmKHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITEpLHQgaW5zdGFuY2VvZiBydCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgJCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZXQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB1dCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHl0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIGh0KSl0aHJvdyBuZXcgSyh0LmdldEdlb21ldHJ5VHlwZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fX1hZGRDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX1sb2NhdGUodCl7cmV0dXJuIEkodGhpcy5fcGFyZW50R2VvbSxpdCkmJnRoaXMuX3BhcmVudEdlb20uZ2V0TnVtR2VvbWV0cmllcygpPjUwPyhudWxsPT09dGhpcy5fYXJlYVB0TG9jYXRvciYmKHRoaXMuX2FyZWFQdExvY2F0b3I9bmV3IHplKHRoaXMuX3BhcmVudEdlb20pKSx0aGlzLl9hcmVhUHRMb2NhdG9yLmxvY2F0ZSh0KSk6dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LHRoaXMuX3BhcmVudEdlb20pfWZpbmRFZGdlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xpbmVFZGdlTWFwLmdldCh0KX1yZXR1cm4gc3VwZXIuZmluZEVkZ2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfX12YXIgY3M9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlHcmFwaDphc30pO2NsYXNzIGhze3Zpc2l0KHQpe319Y2xhc3MgdXN7Y29uc3RydWN0b3IoKXt1cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wPW51bGwsdGhpcy5fZGF0YT1udWxsLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9bmV3IG0odCksdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9MSx0aGlzLl9kYXRhPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcD1uZXcgbSh0LGUpLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PTEsdGhpcy5fZGF0YT1ufX1pc1JlcGVhdGVkKCl7cmV0dXJuIHRoaXMuX2NvdW50PjF9Z2V0UmlnaHQoKXtyZXR1cm4gdGhpcy5fcmlnaHR9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wfXNldExlZnQodCl7dGhpcy5fbGVmdD10fWdldFgoKXtyZXR1cm4gdGhpcy5fcC54fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1nZXRDb3VudCgpe3JldHVybiB0aGlzLl9jb3VudH1nZXRMZWZ0KCl7cmV0dXJuIHRoaXMuX2xlZnR9Z2V0WSgpe3JldHVybiB0aGlzLl9wLnl9aW5jcmVtZW50KCl7dGhpcy5fY291bnQ9dGhpcy5fY291bnQrMX1zZXRSaWdodCh0KXt0aGlzLl9yaWdodD10fX1jbGFzcyBnc3tjb25zdHJ1Y3Rvcigpe2dzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9udW1iZXJPZk5vZGVzPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpZ3MuY29uc3RydWN0b3JfLmNhbGwodGhpcywwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl90b2xlcmFuY2U9dH19c3RhdGljIHRvQ29vcmRpbmF0ZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGdzLnRvQ29vcmRpbmF0ZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFI7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCksaT1lP3QuZ2V0Q291bnQoKToxO2ZvcihsZXQgZT0wO2U8aTtlKyspbi5hZGQodC5nZXRDb29yZGluYXRlKCksITApfXJldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9fWluc2VydCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnNlcnQodCxudWxsKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYobnVsbD09PXRoaXMuX3Jvb3QpcmV0dXJuIHRoaXMuX3Jvb3Q9bmV3IHVzKHQsZSksdGhpcy5fcm9vdDtpZih0aGlzLl90b2xlcmFuY2U+MCl7Y29uc3QgZT10aGlzLmZpbmRCZXN0TWF0Y2hOb2RlKHQpO2lmKG51bGwhPT1lKXJldHVybiBlLmluY3JlbWVudCgpLGV9cmV0dXJuIHRoaXMuaW5zZXJ0RXhhY3QodCxlKX19cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtyZXR1cm4gdGhpcy5xdWVyeSh0LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPJiZJKGFyZ3VtZW50c1sxXSxDKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5xdWVyeU5vZGUodGhpcy5fcm9vdCx0LCEwLG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5baHNdfXZpc2l0KHQpe2UuYWRkKHQpfX0pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPJiZJKGFyZ3VtZW50c1sxXSxocykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMuX3Jvb3QsdCwhMCxlKX19cXVlcnlOb2RlKHQsZSxuLHMpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2xldCBpPW51bGwscj1udWxsLG89bnVsbDtuPyhpPWUuZ2V0TWluWCgpLHI9ZS5nZXRNYXhYKCksbz10LmdldFgoKSk6KGk9ZS5nZXRNaW5ZKCkscj1lLmdldE1heFkoKSxvPXQuZ2V0WSgpKTtjb25zdCBsPW88PXI7aTxvJiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldExlZnQoKSxlLCFuLHMpLGUuY29udGFpbnModC5nZXRDb29yZGluYXRlKCkpJiZzLnZpc2l0KHQpLGwmJnRoaXMucXVlcnlOb2RlKHQuZ2V0UmlnaHQoKSxlLCFuLHMpfWZpbmRCZXN0TWF0Y2hOb2RlKHQpe2NvbnN0IGU9bmV3IGRzKHQsdGhpcy5fdG9sZXJhbmNlKTtyZXR1cm4gdGhpcy5xdWVyeShlLnF1ZXJ5RW52ZWxvcGUoKSxlKSxlLmdldE5vZGUoKX1pc0VtcHR5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yb290fWluc2VydEV4YWN0KHQsZSl7bGV0IG49dGhpcy5fcm9vdCxzPXRoaXMuX3Jvb3QsaT0hMCxyPSEwO2Zvcig7bnVsbCE9PW47KXtpZihudWxsIT09bil7aWYodC5kaXN0YW5jZShuLmdldENvb3JkaW5hdGUoKSk8PXRoaXMuX3RvbGVyYW5jZSlyZXR1cm4gbi5pbmNyZW1lbnQoKSxufXI9aT90Lng8bi5nZXRYKCk6dC55PG4uZ2V0WSgpLHM9bixuPXI/bi5nZXRMZWZ0KCk6bi5nZXRSaWdodCgpLGk9IWl9dGhpcy5fbnVtYmVyT2ZOb2Rlcz10aGlzLl9udW1iZXJPZk5vZGVzKzE7Y29uc3Qgbz1uZXcgdXModCxlKTtyZXR1cm4gcj9zLnNldExlZnQobyk6cy5zZXRSaWdodChvKSxvfX1jbGFzcyBkc3tjb25zdHJ1Y3Rvcigpe2RzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3RvbGVyYW5jZT1udWxsLHRoaXMuX21hdGNoTm9kZT1udWxsLHRoaXMuX21hdGNoRGlzdD0wLHRoaXMuX3A9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPXQsdGhpcy5fdG9sZXJhbmNlPWV9dmlzaXQodCl7Y29uc3QgZT10aGlzLl9wLmRpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZSgpKTtpZighKGU8PXRoaXMuX3RvbGVyYW5jZSkpcmV0dXJuIG51bGw7bGV0IG49ITE7KG51bGw9PT10aGlzLl9tYXRjaE5vZGV8fGU8dGhpcy5fbWF0Y2hEaXN0fHxudWxsIT09dGhpcy5fbWF0Y2hOb2RlJiZlPT09dGhpcy5fbWF0Y2hEaXN0JiZ0LmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5fbWF0Y2hOb2RlLmdldENvb3JkaW5hdGUoKSk8MSkmJihuPSEwKSxuJiYodGhpcy5fbWF0Y2hOb2RlPXQsdGhpcy5fbWF0Y2hEaXN0PWUpfXF1ZXJ5RW52ZWxvcGUoKXtjb25zdCB0PW5ldyBPKHRoaXMuX3ApO3JldHVybiB0LmV4cGFuZEJ5KHRoaXMuX3RvbGVyYW5jZSksdH1nZXROb2RlKCl7cmV0dXJuIHRoaXMuX21hdGNoTm9kZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5baHNdfX1ncy5CZXN0TWF0Y2hWaXNpdG9yPWRzO3ZhciBfcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxLZFRyZWU6Z3N9KTtjbGFzcyBwc3tjb25zdHJ1Y3Rvcigpe3BzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2l0ZW1zPW5ldyBMLHRoaXMuX3N1Ym5vZGU9bmV3IEFycmF5KDQpLmZpbGwobnVsbCl9c3RhdGljIGdldFN1Ym5vZGVJbmRleCh0LGUsbil7bGV0IHM9LTE7cmV0dXJuIHQuZ2V0TWluWCgpPj1lJiYodC5nZXRNaW5ZKCk+PW4mJihzPTMpLHQuZ2V0TWF4WSgpPD1uJiYocz0xKSksdC5nZXRNYXhYKCk8PWUmJih0LmdldE1pblkoKT49biYmKHM9MiksdC5nZXRNYXhZKCk8PW4mJihzPTApKSxzfWhhc0NoaWxkcmVuKCl7Zm9yKGxldCB0PTA7dDw0O3QrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVt0XSlyZXR1cm4hMDtyZXR1cm4hMX1pc1BydW5hYmxlKCl7cmV0dXJuISh0aGlzLmhhc0NoaWxkcmVuKCl8fHRoaXMuaGFzSXRlbXMoKSl9YWRkQWxsSXRlbXModCl7dC5hZGRBbGwodGhpcy5faXRlbXMpO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJnRoaXMuX3N1Ym5vZGVbZV0uYWRkQWxsSXRlbXModCk7cmV0dXJuIHR9Z2V0Tm9kZUNvdW50KCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYodCs9dGhpcy5fc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0KzF9c2l6ZSgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmKHQrPXRoaXMuX3N1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCt0aGlzLl9pdGVtcy5zaXplKCl9YWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO2UuYWRkQWxsKHRoaXMuX2l0ZW1zKTtmb3IobGV0IG49MDtuPDQ7bisrKW51bGwhPT10aGlzLl9zdWJub2RlW25dJiZ0aGlzLl9zdWJub2RlW25dLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl9dmlzaXRJdGVtcyh0LGUpe2ZvcihsZXQgdD10aGlzLl9pdGVtcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyllLnZpc2l0SXRlbSh0Lm5leHQoKSl9aGFzSXRlbXMoKXtyZXR1cm4hdGhpcy5faXRlbXMuaXNFbXB0eSgpfXJlbW92ZSh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuITE7bGV0IG49ITE7Zm9yKGxldCBzPTA7czw0O3MrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVtzXSYmKG49dGhpcy5fc3Vibm9kZVtzXS5yZW1vdmUodCxlKSxuKSl7dGhpcy5fc3Vibm9kZVtzXS5pc1BydW5hYmxlKCkmJih0aGlzLl9zdWJub2RlW3NdPW51bGwpO2JyZWFrfXJldHVybiBufHwobj10aGlzLl9pdGVtcy5yZW1vdmUoZSksbil9dmlzaXQodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO3RoaXMudmlzaXRJdGVtcyh0LGUpO2ZvcihsZXQgbj0wO248NDtuKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbbl0mJnRoaXMuX3N1Ym5vZGVbbl0udmlzaXQodCxlKX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31kZXB0aCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSl7Y29uc3Qgbj10aGlzLl9zdWJub2RlW2VdLmRlcHRoKCk7bj50JiYodD1uKX1yZXR1cm4gdCsxfWlzRW1wdHkoKXtsZXQgdD0hMDtpZih0aGlzLl9pdGVtcy5pc0VtcHR5KCkpe2ZvcihsZXQgZT0wO2U8NDtlKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJiF0aGlzLl9zdWJub2RlW2VdLmlzRW1wdHkoKSl7dD0hMTticmVha319ZWxzZSB0PSExO3JldHVybiB0fWFkZCh0KXt0aGlzLl9pdGVtcy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NdfX1mdW5jdGlvbiBtcygpe31tcy5leHBvbmVudD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlKXtsZXQgbixzLGkscjtjb25zdCBvPXszMjp7ZDoxMjcsYzoxMjgsYjowLGE6MH0sNjQ6e2Q6MzI3NTIsYzowLGI6MCxhOjB9fSxsPXszMjo4LDY0OjExfVt0XTtyfHwobj1lPDB8fDEvZTwwLGlzRmluaXRlKGUpfHwocj1vW3RdLG4mJihyLmQrPTE8PHQvNC0xKSxzPU1hdGgucG93KDIsbCktMSxpPTApKTtpZighcil7Zm9yKHM9ezMyOjEyNyw2NDoxMDIzfVt0XSxpPU1hdGguYWJzKGUpO2k+PTI7KXMrKyxpLz0yO2Zvcig7aTwxJiZzPjA7KXMtLSxpKj0yO3M8PTAmJihpLz0yKSwzMj09PXQmJnM+MjU0JiYocj17ZDpuPzI1NToxMjcsYzoxMjgsYjowLGE6MH0scz1NYXRoLnBvdygyLGwpLTEsaT0wKX1yZXR1cm4gc30oNjQsdCktMTAyM30sbXMucG93ZXJPZjI9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDIsdCl9O2NsYXNzIGZze2NvbnN0cnVjdG9yKCl7ZnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHQ9bmV3IG0sdGhpcy5fbGV2ZWw9MCx0aGlzLl9lbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXB1dGVLZXkodCl9c3RhdGljIGNvbXB1dGVRdWFkTGV2ZWwodCl7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLHM9ZT5uP2U6bjtyZXR1cm4gbXMuZXhwb25lbnQocykrMX1nZXRMZXZlbCgpe3JldHVybiB0aGlzLl9sZXZlbH1jb21wdXRlS2V5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2Zvcih0aGlzLl9sZXZlbD1mcy5jb21wdXRlUXVhZExldmVsKHQpLHRoaXMuX2Vudj1uZXcgTyx0aGlzLmNvbXB1dGVLZXkodGhpcy5fbGV2ZWwsdCk7IXRoaXMuX2Vudi5jb250YWlucyh0KTspdGhpcy5fbGV2ZWwrPTEsdGhpcy5jb21wdXRlS2V5KHRoaXMuX2xldmVsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bXMucG93ZXJPZjIodCk7dGhpcy5fcHQueD1NYXRoLmZsb29yKGUuZ2V0TWluWCgpL24pKm4sdGhpcy5fcHQueT1NYXRoLmZsb29yKGUuZ2V0TWluWSgpL24pKm4sdGhpcy5fZW52LmluaXQodGhpcy5fcHQueCx0aGlzLl9wdC54K24sdGhpcy5fcHQueSx0aGlzLl9wdC55K24pfX1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLl9lbnZ9Z2V0Q2VudHJlKCl7cmV0dXJuIG5ldyBtKCh0aGlzLl9lbnYuZ2V0TWluWCgpK3RoaXMuX2Vudi5nZXRNYXhYKCkpLzIsKHRoaXMuX2Vudi5nZXRNaW5ZKCkrdGhpcy5fZW52LmdldE1heFkoKSkvMil9Z2V0UG9pbnQoKXtyZXR1cm4gdGhpcy5fcHR9fWxldCB5cz1jbGFzcyBleHRlbmRzIHBze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx5cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lbnY9bnVsbCx0aGlzLl9jZW50cmV4PW51bGwsdGhpcy5fY2VudHJleT1udWxsLHRoaXMuX2xldmVsPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZW52PXQsdGhpcy5fbGV2ZWw9ZSx0aGlzLl9jZW50cmV4PSh0LmdldE1pblgoKSt0LmdldE1heFgoKSkvMix0aGlzLl9jZW50cmV5PSh0LmdldE1pblkoKSt0LmdldE1heFkoKSkvMn1zdGF0aWMgY3JlYXRlTm9kZSh0KXtjb25zdCBlPW5ldyBmcyh0KTtyZXR1cm4gbmV3IHlzKGUuZ2V0RW52ZWxvcGUoKSxlLmdldExldmVsKCkpfXN0YXRpYyBjcmVhdGVFeHBhbmRlZCh0LGUpe2NvbnN0IG49bmV3IE8oZSk7bnVsbCE9PXQmJm4uZXhwYW5kVG9JbmNsdWRlKHQuX2Vudik7Y29uc3Qgcz15cy5jcmVhdGVOb2RlKG4pO3JldHVybiBudWxsIT09dCYmcy5pbnNlcnROb2RlKHQpLHN9ZmluZCh0KXtjb25zdCBlPXBzLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdKXtyZXR1cm4gdGhpcy5fc3Vibm9kZVtlXS5maW5kKHQpfXJldHVybiB0aGlzfWlzU2VhcmNoTWF0Y2godCl7cmV0dXJuIG51bGwhPT10JiZ0aGlzLl9lbnYuaW50ZXJzZWN0cyh0KX1nZXRTdWJub2RlKHQpe3JldHVybiBudWxsPT09dGhpcy5fc3Vibm9kZVt0XSYmKHRoaXMuX3N1Ym5vZGVbdF09dGhpcy5jcmVhdGVTdWJub2RlKHQpKSx0aGlzLl9zdWJub2RlW3RdfWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuX2Vudn1nZXROb2RlKHQpe2NvbnN0IGU9cHMuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZigtMSE9PWUpe3JldHVybiB0aGlzLmdldFN1Ym5vZGUoZSkuZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc31jcmVhdGVTdWJub2RlKHQpe2xldCBlPTAsbj0wLHM9MCxpPTA7c3dpdGNoKHQpe2Nhc2UgMDplPXRoaXMuX2Vudi5nZXRNaW5YKCksbj10aGlzLl9jZW50cmV4LHM9dGhpcy5fZW52LmdldE1pblkoKSxpPXRoaXMuX2NlbnRyZXk7YnJlYWs7Y2FzZSAxOmU9dGhpcy5fY2VudHJleCxuPXRoaXMuX2Vudi5nZXRNYXhYKCkscz10aGlzLl9lbnYuZ2V0TWluWSgpLGk9dGhpcy5fY2VudHJleTticmVhaztjYXNlIDI6ZT10aGlzLl9lbnYuZ2V0TWluWCgpLG49dGhpcy5fY2VudHJleCxzPXRoaXMuX2NlbnRyZXksaT10aGlzLl9lbnYuZ2V0TWF4WSgpO2JyZWFrO2Nhc2UgMzplPXRoaXMuX2NlbnRyZXgsbj10aGlzLl9lbnYuZ2V0TWF4WCgpLHM9dGhpcy5fY2VudHJleSxpPXRoaXMuX2Vudi5nZXRNYXhZKCl9Y29uc3Qgcj1uZXcgTyhlLG4scyxpKTtyZXR1cm4gbmV3IHlzKHIsdGhpcy5fbGV2ZWwtMSl9aW5zZXJ0Tm9kZSh0KXtnLmlzVHJ1ZShudWxsPT09dGhpcy5fZW52fHx0aGlzLl9lbnYuY29udGFpbnModC5fZW52KSk7Y29uc3QgZT1wcy5nZXRTdWJub2RlSW5kZXgodC5fZW52LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYodC5fbGV2ZWw9PT10aGlzLl9sZXZlbC0xKXRoaXMuX3N1Ym5vZGVbZV09dDtlbHNle2NvbnN0IG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0Tm9kZSh0KSx0aGlzLl9zdWJub2RlW2VdPW59fX07Y2xhc3MgeHN7c3RhdGljIGlzWmVyb1dpZHRoKHQsZSl7Y29uc3Qgbj1lLXQ7aWYoMD09PW4pcmV0dXJuITA7Y29uc3Qgcz1uL01hdGgubWF4KE1hdGguYWJzKHQpLE1hdGguYWJzKGUpKTtyZXR1cm4gbXMuZXhwb25lbnQocyk8PXhzLk1JTl9CSU5BUllfRVhQT05FTlR9fXhzLk1JTl9CSU5BUllfRVhQT05FTlQ9LTUwO2NsYXNzIEVzIGV4dGVuZHMgcHN7Y29uc3RydWN0b3IoKXtzdXBlcigpfWluc2VydCh0LGUpe2NvbnN0IG49cHMuZ2V0U3Vibm9kZUluZGV4KHQsRXMub3JpZ2luLngsRXMub3JpZ2luLnkpO2lmKC0xPT09bilyZXR1cm4gdGhpcy5hZGQoZSksbnVsbDtjb25zdCBzPXRoaXMuX3N1Ym5vZGVbbl07aWYobnVsbD09PXN8fCFzLmdldEVudmVsb3BlKCkuY29udGFpbnModCkpe2NvbnN0IGU9eXMuY3JlYXRlRXhwYW5kZWQocyx0KTt0aGlzLl9zdWJub2RlW25dPWV9dGhpcy5pbnNlcnRDb250YWluZWQodGhpcy5fc3Vibm9kZVtuXSx0LGUpfWlzU2VhcmNoTWF0Y2godCl7cmV0dXJuITB9aW5zZXJ0Q29udGFpbmVkKHQsZSxuKXtnLmlzVHJ1ZSh0LmdldEVudmVsb3BlKCkuY29udGFpbnMoZSkpO2NvbnN0IHM9eHMuaXNaZXJvV2lkdGgoZS5nZXRNaW5YKCksZS5nZXRNYXhYKCkpLGk9eHMuaXNaZXJvV2lkdGgoZS5nZXRNaW5ZKCksZS5nZXRNYXhZKCkpO2xldCByPW51bGw7cj1zfHxpP3QuZmluZChlKTp0LmdldE5vZGUoZSksci5hZGQobil9fUVzLm9yaWdpbj1uZXcgbSgwLDApO2NsYXNzIElze2luc2VydCh0LGUpe31yZW1vdmUodCxlKXt9cXVlcnkoKXt9fWNsYXNzIE5ze2NvbnN0cnVjdG9yKCl7TnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcm9vdD1udWxsLHRoaXMuX21pbkV4dGVudD0xLHRoaXMuX3Jvb3Q9bmV3IEVzfXN0YXRpYyBlbnN1cmVFeHRlbnQodCxlKXtsZXQgbj10LmdldE1pblgoKSxzPXQuZ2V0TWF4WCgpLGk9dC5nZXRNaW5ZKCkscj10LmdldE1heFkoKTtyZXR1cm4gbiE9PXMmJmkhPT1yP3Q6KG49PT1zJiYobi09ZS8yLHMrPWUvMiksaT09PXImJihpLT1lLzIscis9ZS8yKSxuZXcgTyhuLHMsaSxyKSl9c2l6ZSgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LnNpemUoKTowfWluc2VydCh0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO2NvbnN0IG49TnMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTt0aGlzLl9yb290Lmluc2VydChuLGUpfXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IFllO3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZS5nZXRJdGVtcygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9yb290LnZpc2l0KHQsZSl9fXF1ZXJ5QWxsKCl7Y29uc3QgdD1uZXcgTDtyZXR1cm4gdGhpcy5fcm9vdC5hZGRBbGxJdGVtcyh0KSx0fXJlbW92ZSh0LGUpe2NvbnN0IG49TnMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTtyZXR1cm4gdGhpcy5fcm9vdC5yZW1vdmUobixlKX1jb2xsZWN0U3RhdHModCl7Y29uc3QgZT10LmdldFdpZHRoKCk7ZTx0aGlzLl9taW5FeHRlbnQmJmU+MCYmKHRoaXMuX21pbkV4dGVudD1lKTtjb25zdCBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLl9taW5FeHRlbnQmJm4+MCYmKHRoaXMuX21pbkV4dGVudD1uKX1kZXB0aCgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LmRlcHRoKCk6MH1pc0VtcHR5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yb290fHx0aGlzLl9yb290LmlzRW1wdHkoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSXMsY119fXZhciB3cz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxRdWFkdHJlZTpOc30pO2NsYXNzIENze2dldEJvdW5kcygpe319Y2xhc3MgU3N7Y29uc3RydWN0b3IoKXtTcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ib3VuZHM9bnVsbCx0aGlzLl9pdGVtPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fYm91bmRzPXQsdGhpcy5faXRlbT1lfWdldEl0ZW0oKXtyZXR1cm4gdGhpcy5faXRlbX1nZXRCb3VuZHMoKXtyZXR1cm4gdGhpcy5fYm91bmRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDcyxjXX19Y2xhc3MgTHN7Y29uc3RydWN0b3IoKXtMcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXplPW51bGwsdGhpcy5faXRlbXM9bnVsbCx0aGlzLl9zaXplPTAsdGhpcy5faXRlbXM9bmV3IEwsdGhpcy5faXRlbXMuYWRkKG51bGwpfXBvbGwoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMuX2l0ZW1zLmdldCgxKTtyZXR1cm4gdGhpcy5faXRlbXMuc2V0KDEsdGhpcy5faXRlbXMuZ2V0KHRoaXMuX3NpemUpKSx0aGlzLl9zaXplLT0xLHRoaXMucmVvcmRlcigxKSx0fXNpemUoKXtyZXR1cm4gdGhpcy5fc2l6ZX1yZW9yZGVyKHQpe2xldCBlPW51bGw7Y29uc3Qgbj10aGlzLl9pdGVtcy5nZXQodCk7Zm9yKDsyKnQ8PXRoaXMuX3NpemUmJihlPTIqdCxlIT09dGhpcy5fc2l6ZSYmdGhpcy5faXRlbXMuZ2V0KGUrMSkuY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChlKSk8MCYmZSsrLHRoaXMuX2l0ZW1zLmdldChlKS5jb21wYXJlVG8obik8MCk7dD1lKXRoaXMuX2l0ZW1zLnNldCh0LHRoaXMuX2l0ZW1zLmdldChlKSk7dGhpcy5faXRlbXMuc2V0KHQsbil9Y2xlYXIoKXt0aGlzLl9zaXplPTAsdGhpcy5faXRlbXMuY2xlYXIoKX1wZWVrKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7cmV0dXJuIHRoaXMuX2l0ZW1zLmdldCgxKX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9zaXplfWFkZCh0KXt0aGlzLl9pdGVtcy5hZGQobnVsbCksdGhpcy5fc2l6ZSs9MTtsZXQgZT10aGlzLl9zaXplO2Zvcih0aGlzLl9pdGVtcy5zZXQoMCx0KTt0LmNvbXBhcmVUbyh0aGlzLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk8MDtlLz0yKXRoaXMuX2l0ZW1zLnNldChlLHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTt0aGlzLl9pdGVtcy5zZXQoZSx0KX19Y2xhc3MgVHN7Y29uc3RydWN0b3IoKXtUcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9jaGlsZEJvdW5kYWJsZXM9bmV3IEwsdGhpcy5fYm91bmRzPW51bGwsdGhpcy5fbGV2ZWw9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGV2ZWw9dH19Z2V0TGV2ZWwoKXtyZXR1cm4gdGhpcy5fbGV2ZWx9c2l6ZSgpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuc2l6ZSgpfWdldENoaWxkQm91bmRhYmxlcygpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXN9YWRkQ2hpbGRCb3VuZGFibGUodCl7Zy5pc1RydWUobnVsbD09PXRoaXMuX2JvdW5kcyksdGhpcy5fY2hpbGRCb3VuZGFibGVzLmFkZCh0KX1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCl9Z2V0Qm91bmRzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9ib3VuZHMmJih0aGlzLl9ib3VuZHM9dGhpcy5jb21wdXRlQm91bmRzKCkpLHRoaXMuX2JvdW5kc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQ3MsY119fWNsYXNzIFJze3N0YXRpYyBtYXhEaXN0YW5jZSh0LGUsbixzLGkscixvLGwpe2xldCBhPVJzLmRpc3RhbmNlKHQsZSxpLHIpO3JldHVybiBhPU1hdGgubWF4KGEsUnMuZGlzdGFuY2UodCxlLG8sbCkpLGE9TWF0aC5tYXgoYSxScy5kaXN0YW5jZShuLHMsaSxyKSksYT1NYXRoLm1heChhLFJzLmRpc3RhbmNlKG4scyxvLGwpKSxhfXN0YXRpYyBkaXN0YW5jZSh0LGUsbixzKXtjb25zdCBpPW4tdCxyPXMtZTtyZXR1cm4gTWF0aC5zcXJ0KGkqaStyKnIpfXN0YXRpYyBtYXhpbXVtRGlzdGFuY2UodCxlKXtjb25zdCBuPU1hdGgubWluKHQuZ2V0TWluWCgpLGUuZ2V0TWluWCgpKSxzPU1hdGgubWluKHQuZ2V0TWluWSgpLGUuZ2V0TWluWSgpKSxpPU1hdGgubWF4KHQuZ2V0TWF4WCgpLGUuZ2V0TWF4WCgpKSxyPU1hdGgubWF4KHQuZ2V0TWF4WSgpLGUuZ2V0TWF4WSgpKTtyZXR1cm4gUnMuZGlzdGFuY2UobixzLGkscil9c3RhdGljIG1pbk1heERpc3RhbmNlKHQsZSl7Y29uc3Qgbj10LmdldE1pblgoKSxzPXQuZ2V0TWluWSgpLGk9dC5nZXRNYXhYKCkscj10LmdldE1heFkoKSxvPWUuZ2V0TWluWCgpLGw9ZS5nZXRNaW5ZKCksYT1lLmdldE1heFgoKSxjPWUuZ2V0TWF4WSgpO2xldCBoPVJzLm1heERpc3RhbmNlKG4scyxuLHIsbyxsLG8sYyk7cmV0dXJuIGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShuLHMsbixyLG8sbCxhLGwpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UobixzLG4scixhLGMsbyxjKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKG4scyxuLHIsYSxjLGEsbCkpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShuLHMsaSxzLG8sbCxvLGMpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UobixzLGkscyxvLGwsYSxsKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKG4scyxpLHMsYSxjLG8sYykpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShuLHMsaSxzLGEsYyxhLGwpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLG4scixvLGwsbyxjKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixuLHIsbyxsLGEsbCkpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsbixyLGEsYyxvLGMpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLG4scixhLGMsYSxsKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixpLHMsbyxsLG8sYykpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsaSxzLG8sbCxhLGwpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLGkscyxhLGMsbyxjKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixpLHMsYSxjLGEsbCkpLGh9fWNsYXNzIFBze2NvbnN0cnVjdG9yKCl7UHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fYm91bmRhYmxlMT1udWxsLHRoaXMuX2JvdW5kYWJsZTI9bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2l0ZW1EaXN0YW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2JvdW5kYWJsZTE9dCx0aGlzLl9ib3VuZGFibGUyPWUsdGhpcy5faXRlbURpc3RhbmNlPW4sdGhpcy5fZGlzdGFuY2U9dGhpcy5kaXN0YW5jZSgpfXN0YXRpYyBhcmVhKHQpe3JldHVybiB0LmdldEJvdW5kcygpLmdldEFyZWEoKX1zdGF0aWMgaXNDb21wb3NpdGUodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBUc31tYXhpbXVtRGlzdGFuY2UoKXtyZXR1cm4gUnMubWF4aW11bURpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTEuZ2V0Qm91bmRzKCksdGhpcy5fYm91bmRhYmxlMi5nZXRCb3VuZHMoKSl9ZXhwYW5kVG9RdWV1ZSh0LGUpe2NvbnN0IG49UHMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSksaT1Qcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKTtpZihuJiZpKXJldHVybiBQcy5hcmVhKHRoaXMuX2JvdW5kYWJsZTEpPlBzLmFyZWEodGhpcy5fYm91bmRhYmxlMik/KHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMiwhMSx0LGUpLG51bGwpOih0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLHRoaXMuX2JvdW5kYWJsZTEsITAsdCxlKSxudWxsKTtpZihuKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIsITEsdCxlKSxudWxsO2lmKGkpcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsdGhpcy5fYm91bmRhYmxlMSwhMCx0LGUpLG51bGw7dGhyb3cgbmV3IHMoXCJuZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGVcIil9aXNMZWF2ZXMoKXtyZXR1cm4hKFBzLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpfHxQcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fZGlzdGFuY2U8ZS5fZGlzdGFuY2U/LTE6dGhpcy5fZGlzdGFuY2U+ZS5fZGlzdGFuY2U/MTowfWV4cGFuZCh0LGUsbixzLGkpe2ZvcihsZXQgcj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXtjb25zdCB0PXIubmV4dCgpO2xldCBvPW51bGw7bz1uP25ldyBQcyhlLHQsdGhpcy5faXRlbURpc3RhbmNlKTpuZXcgUHModCxlLHRoaXMuX2l0ZW1EaXN0YW5jZSksby5nZXREaXN0YW5jZSgpPGkmJnMuYWRkKG8pfX1nZXRCb3VuZGFibGUodCl7cmV0dXJuIDA9PT10P3RoaXMuX2JvdW5kYWJsZTE6dGhpcy5fYm91bmRhYmxlMn1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9kaXN0YW5jZX1kaXN0YW5jZSgpe3JldHVybiB0aGlzLmlzTGVhdmVzKCk/dGhpcy5faXRlbURpc3RhbmNlLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMik6dGhpcy5fYm91bmRhYmxlMS5nZXRCb3VuZHMoKS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUyLmdldEJvdW5kcygpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIE9ze2NvbnN0cnVjdG9yKCl7T3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcm9vdD1udWxsLHRoaXMuX2J1aWx0PSExLHRoaXMuX2l0ZW1Cb3VuZGFibGVzPW5ldyBMLHRoaXMuX25vZGVDYXBhY2l0eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKU9zLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsT3MuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtnLmlzVHJ1ZSh0PjEsXCJOb2RlIGNhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5fbm9kZUNhcGFjaXR5PXR9fXN0YXRpYyBjb21wYXJlRG91Ymxlcyh0LGUpe3JldHVybiB0PmU/MTp0PGU/LTE6MH1xdWVyeUludGVybmFsKCl7aWYoSShhcmd1bWVudHNbMl0sRGUpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBUcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbMV0uZ2V0Q2hpbGRCb3VuZGFibGVzKCk7Zm9yKGxldCBzPTA7czxuLnNpemUoKTtzKyspe2NvbnN0IGk9bi5nZXQocyk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGkuZ2V0Qm91bmRzKCksdCkmJihpIGluc3RhbmNlb2YgVHM/dGhpcy5xdWVyeUludGVybmFsKHQsaSxlKTppIGluc3RhbmNlb2YgU3M/ZS52aXNpdEl0ZW0oaS5nZXRJdGVtKCkpOmcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fWVsc2UgaWYoSShhcmd1bWVudHNbMl0sQykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFRzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1sxXS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtmb3IobGV0IHM9MDtzPG4uc2l6ZSgpO3MrKyl7Y29uc3QgaT1uLmdldChzKTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoaS5nZXRCb3VuZHMoKSx0KSYmKGkgaW5zdGFuY2VvZiBUcz90aGlzLnF1ZXJ5SW50ZXJuYWwodCxpLGUpOmkgaW5zdGFuY2VvZiBTcz9lLmFkZChpLmdldEl0ZW0oKSk6Zy5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19fWdldE5vZGVDYXBhY2l0eSgpe3JldHVybiB0aGlzLl9ub2RlQ2FwYWNpdHl9bGFzdE5vZGUodCl7cmV0dXJuIHQuZ2V0KHQuc2l6ZSgpLTEpfXNpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuc2l6ZSh0aGlzLl9yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuIGluc3RhbmNlb2YgVHM/dCs9dGhpcy5zaXplKG4pOm4gaW5zdGFuY2VvZiBTcyYmKHQrPTEpfXJldHVybiB0fX1yZW1vdmVJdGVtKHQsZSl7bGV0IG49bnVsbDtmb3IobGV0IHM9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0IGluc3RhbmNlb2YgU3MmJnQuZ2V0SXRlbSgpPT09ZSYmKG49dCl9cmV0dXJuIG51bGwhPT1uJiYodC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUobiksITApfWl0ZW1zVHJlZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLmJ1aWxkKCk7Y29uc3QgdD10aGlzLml0ZW1zVHJlZSh0aGlzLl9yb290KTtyZXR1cm4gbnVsbD09PXQ/bmV3IEw6dH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtmb3IobGV0IG49dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0IGluc3RhbmNlb2YgVHMpe2NvbnN0IG49dGhpcy5pdGVtc1RyZWUodCk7bnVsbCE9PW4mJmUuYWRkKG4pfWVsc2UgdCBpbnN0YW5jZW9mIFNzP2UuYWRkKHQuZ2V0SXRlbSgpKTpnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIGUuc2l6ZSgpPD0wP251bGw6ZX19aW5zZXJ0KHQsZSl7Zy5pc1RydWUoIXRoaXMuX2J1aWx0LFwiQ2Fubm90IGluc2VydCBpdGVtcyBpbnRvIGFuIFNUUiBwYWNrZWQgUi10cmVlIGFmdGVyIGl0IGhhcyBiZWVuIGJ1aWx0LlwiKSx0aGlzLl9pdGVtQm91bmRhYmxlcy5hZGQobmV3IFNzKHQsZSkpfWJvdW5kYWJsZXNBdExldmVsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7cmV0dXJuIHRoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCx0aGlzLl9yb290LGUpLGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGcuaXNUcnVlKHQ+LTIpLGUuZ2V0TGV2ZWwoKT09PXQpcmV0dXJuIG4uYWRkKGUpLG51bGw7Zm9yKGxldCBzPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGU9cy5uZXh0KCk7ZSBpbnN0YW5jZW9mIFRzP3RoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCxlLG4pOihnLmlzVHJ1ZShlIGluc3RhbmNlb2YgU3MpLC0xPT09dCYmbi5hZGQoZSkpfXJldHVybiBudWxsfX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1aWxkKCk7Y29uc3QgZT1uZXcgTDtyZXR1cm4gdGhpcy5pc0VtcHR5KCl8fHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnF1ZXJ5SW50ZXJuYWwodCx0aGlzLl9yb290LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuYnVpbGQoKSx0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeUludGVybmFsKHQsdGhpcy5fcm9vdCxlKX19YnVpbGQoKXtpZih0aGlzLl9idWlsdClyZXR1cm4gbnVsbDt0aGlzLl9yb290PXRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKT90aGlzLmNyZWF0ZU5vZGUoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5faXRlbUJvdW5kYWJsZXMsLTEpLHRoaXMuX2l0ZW1Cb3VuZGFibGVzPW51bGwsdGhpcy5fYnVpbHQ9ITB9Z2V0Um9vdCgpe3JldHVybiB0aGlzLmJ1aWxkKCksdGhpcy5fcm9vdH1yZW1vdmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYnVpbGQoKSwhIXRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnJlbW92ZSh0LHRoaXMuX3Jvb3QsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2xldCBzPXRoaXMucmVtb3ZlSXRlbShlLG4pO2lmKHMpcmV0dXJuITA7bGV0IGk9bnVsbDtmb3IobGV0IHI9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7Y29uc3QgZT1yLm5leHQoKTtpZih0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoZS5nZXRCb3VuZHMoKSx0KSYmKGUgaW5zdGFuY2VvZiBUcyYmKHM9dGhpcy5yZW1vdmUodCxlLG4pLHMpKSl7aT1lO2JyZWFrfX1yZXR1cm4gbnVsbCE9PWkmJmkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpJiZlLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShpKSxzfX1jcmVhdGVIaWdoZXJMZXZlbHModCxlKXtnLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49dGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSsxKTtyZXR1cm4gMT09PW4uc2l6ZSgpP24uZ2V0KDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKG4sZSsxKX1kZXB0aCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5kZXB0aCh0aGlzLl9yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuIGluc3RhbmNlb2YgVHMpe2NvbnN0IGU9dGhpcy5kZXB0aChuKTtlPnQmJih0PWUpfX1yZXR1cm4gdCsxfX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSl7Zy5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPW5ldyBMO24uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSk7Y29uc3Qgcz1uZXcgTCh0KTt4ZS5zb3J0KHMsdGhpcy5nZXRDb21wYXJhdG9yKCkpO2ZvcihsZXQgdD1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBzPXQubmV4dCgpO3RoaXMubGFzdE5vZGUobikuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuc2l6ZSgpPT09dGhpcy5nZXROb2RlQ2FwYWNpdHkoKSYmbi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKSx0aGlzLmxhc3ROb2RlKG4pLmFkZENoaWxkQm91bmRhYmxlKHMpfXJldHVybiBufWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fYnVpbHQ/dGhpcy5fcm9vdC5pc0VtcHR5KCk6dGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjXX19T3MuSW50ZXJzZWN0c09wPWZ1bmN0aW9uKCl7fSxPcy5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTA7Y2xhc3MgdnN7ZGlzdGFuY2UodCxlKXt9fWNsYXNzIGJzIGV4dGVuZHMgT3N7Y29uc3RydWN0b3IoKXtzdXBlcigpLGJzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWJzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsYnMuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtPcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX1zdGF0aWMgY2VudHJlWCh0KXtyZXR1cm4gYnMuYXZnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WCgpKX1zdGF0aWMgYXZnKHQsZSl7cmV0dXJuKHQrZSkvMn1zdGF0aWMgZ2V0SXRlbXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7bGV0IG49MDtmb3IoOyF0LmlzRW1wdHkoKTspe2NvbnN0IHM9dC5wb2xsKCk7ZVtuXT1zLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbisrfXJldHVybiBlfXN0YXRpYyBjZW50cmVZKHQpe3JldHVybiBicy5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXModCxlKXtnLmlzVHJ1ZSh0Lmxlbmd0aD4wKTtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKW4uYWRkQWxsKHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHRbc10sZSkpO3JldHVybiBufW5lYXJlc3ROZWlnaGJvdXJLKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXJLKHQsci5QT1NJVElWRV9JTkZJTklUWSxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl07bGV0IG49YXJndW1lbnRzWzFdO2NvbnN0IHM9bmV3IExzO3MuYWRkKHQpO2NvbnN0IGk9bmV3IExzO2Zvcig7IXMuaXNFbXB0eSgpJiZuPj0wOyl7Y29uc3QgdD1zLnBvbGwoKSxyPXQuZ2V0RGlzdGFuY2UoKTtpZihyPj1uKWJyZWFrO2lmKHQuaXNMZWF2ZXMoKSlpZihpLnNpemUoKTxlKWkuYWRkKHQpO2Vsc2V7aS5wZWVrKCkuZ2V0RGlzdGFuY2UoKT5yJiYoaS5wb2xsKCksaS5hZGQodCkpO249aS5wZWVrKCkuZ2V0RGlzdGFuY2UoKX1lbHNlIHQuZXhwYW5kVG9RdWV1ZShzLG4pfXJldHVybiBicy5nZXRJdGVtcyhpKX19Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IE1zKHQpfXNpemUoKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/c3VwZXIuc2l6ZS5jYWxsKHRoaXMpOnN1cGVyLnNpemUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydCgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pKXJldHVybiBzdXBlci5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0LmlzTnVsbCgpKXJldHVybiBudWxsO3N1cGVyLmluc2VydC5jYWxsKHRoaXMsdCxlKX19Z2V0SW50ZXJzZWN0c09wKCl7cmV0dXJuIGJzLmludGVyc2VjdHNPcH12ZXJ0aWNhbFNsaWNlcyh0LGUpe2NvbnN0IG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvZSkpLHM9bmV3IEFycmF5KGUpLmZpbGwobnVsbCksaT10Lml0ZXJhdG9yKCk7Zm9yKGxldCB0PTA7dDxlO3QrKyl7c1t0XT1uZXcgTDtsZXQgZT0wO2Zvcig7aS5oYXNOZXh0KCkmJmU8bjspe2NvbnN0IG49aS5uZXh0KCk7c1t0XS5hZGQobiksZSsrfX1yZXR1cm4gc31xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3VwZXIucXVlcnkuY2FsbCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtzdXBlci5xdWVyeS5jYWxsKHRoaXMsdCxlKX19Z2V0Q29tcGFyYXRvcigpe3JldHVybiBicy55Q29tcGFyYXRvcn1jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodCxlKXtyZXR1cm4gc3VwZXIuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsdCxlKX1yZW1vdmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHN1cGVyLnJlbW92ZS5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIucmVtb3ZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1kZXB0aCgpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9zdXBlci5kZXB0aC5jYWxsKHRoaXMpOnN1cGVyLmRlcHRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSl7Zy5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL3RoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKSxzPW5ldyBMKHQpO3hlLnNvcnQocyxicy54Q29tcGFyYXRvcik7Y29uc3QgaT10aGlzLnZlcnRpY2FsU2xpY2VzKHMsTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5zcXJ0KG4pKSkpO3JldHVybiB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMoaSxlKX1uZWFyZXN0TmVpZ2hib3VyKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLHZzKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgUHModGhpcy5nZXRSb290KCksdGhpcy5nZXRSb290KCksdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFBzKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1yLlBPU0lUSVZFX0lORklOSVRZLG49bnVsbDtjb25zdCBzPW5ldyBMcztmb3Iocy5hZGQodCk7IXMuaXNFbXB0eSgpJiZlPjA7KXtjb25zdCB0PXMucG9sbCgpLGk9dC5nZXREaXN0YW5jZSgpO2lmKGk+PWUpYnJlYWs7dC5pc0xlYXZlcygpPyhlPWksbj10KTp0LmV4cGFuZFRvUXVldWUocyxlKX1yZXR1cm4gbnVsbD09PW4/bnVsbDpbbi5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLG4uZ2V0Qm91bmRhYmxlKDEpLmdldEl0ZW0oKV19fWVsc2V7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNFbXB0eSgpfHx0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBQcyh0aGlzLmdldFJvb3QoKSx0LmdldFJvb3QoKSxlKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKG4pfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1syXSxlPW5ldyBTcyhhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKSxuPW5ldyBQcyh0aGlzLmdldFJvb3QoKSxlLHQpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIobilbMF19aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzJdLGU9YXJndW1lbnRzWzNdLG49bmV3IFNzKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLHM9bmV3IFBzKHRoaXMuZ2V0Um9vdCgpLG4sdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cksocyxlKX19fWlzV2l0aGluRGlzdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49ci5QT1NJVElWRV9JTkZJTklUWTtjb25zdCBzPW5ldyBMcztmb3Iocy5hZGQodCk7IXMuaXNFbXB0eSgpOyl7Y29uc3QgdD1zLnBvbGwoKSxpPXQuZ2V0RGlzdGFuY2UoKTtpZihpPmUpcmV0dXJuITE7aWYodC5tYXhpbXVtRGlzdGFuY2UoKTw9ZSlyZXR1cm4hMDtpZih0LmlzTGVhdmVzKCkpe2lmKG49aSxuPD1lKXJldHVybiEwfWVsc2UgdC5leHBhbmRUb1F1ZXVlKHMsbil9cmV0dXJuITF9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IFBzKHRoaXMuZ2V0Um9vdCgpLHQuZ2V0Um9vdCgpLGUpO3JldHVybiB0aGlzLmlzV2l0aGluRGlzdGFuY2UocyxuKX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0lzLGNdfX1jbGFzcyBNcyBleHRlbmRzIFRze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxNcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXTtUcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWNvbXB1dGVCb3VuZHMoKXtsZXQgdD1udWxsO2ZvcihsZXQgZT10aGlzLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO251bGw9PT10P3Q9bmV3IE8obi5nZXRCb3VuZHMoKSk6dC5leHBhbmRUb0luY2x1ZGUobi5nZXRCb3VuZHMoKSl9cmV0dXJuIHR9fWJzLlNUUnRyZWVOb2RlPU1zLGJzLnhDb21wYXJhdG9yPW5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19Y29tcGFyZSh0LGUpe3JldHVybiBPcy5jb21wYXJlRG91Ymxlcyhicy5jZW50cmVYKHQuZ2V0Qm91bmRzKCkpLGJzLmNlbnRyZVgoZS5nZXRCb3VuZHMoKSkpfX0sYnMueUNvbXBhcmF0b3I9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX1jb21wYXJlKHQsZSl7cmV0dXJuIE9zLmNvbXBhcmVEb3VibGVzKGJzLmNlbnRyZVkodC5nZXRCb3VuZHMoKSksYnMuY2VudHJlWShlLmdldEJvdW5kcygpKSl9fSxicy5pbnRlcnNlY3RzT3A9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltJbnRlcnNlY3RzT3BdfWludGVyc2VjdHModCxlKXtyZXR1cm4gdC5pbnRlcnNlY3RzKGUpfX0sYnMuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwO3ZhciBEcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxTVFJ0cmVlOmJzfSksQXM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsa2R0cmVlOl9zLHF1YWR0cmVlOndzLHN0cnRyZWU6RHN9KTtjb25zdCBGcz1bXCJQb2ludFwiLFwiTXVsdGlQb2ludFwiLFwiTGluZVN0cmluZ1wiLFwiTXVsdGlMaW5lU3RyaW5nXCIsXCJQb2x5Z29uXCIsXCJNdWx0aVBvbHlnb25cIl07Y2xhc3MgR3N7Y29uc3RydWN0b3IodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEx0fXJlYWQodCl7bGV0IGU7ZT1cInN0cmluZ1wiPT10eXBlb2YgdD9KU09OLnBhcnNlKHQpOnQ7Y29uc3Qgbj1lLnR5cGU7aWYoIXFzW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIitlLnR5cGUpO3JldHVybi0xIT09RnMuaW5kZXhPZihuKT9xc1tuXS5jYWxsKHRoaXMsZS5jb29yZGluYXRlcyk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PW4/cXNbbl0uY2FsbCh0aGlzLGUuZ2VvbWV0cmllcyk6cXNbbl0uY2FsbCh0aGlzLGUpfXdyaXRlKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeVR5cGUoKTtpZighQnNbZV0pdGhyb3cgbmV3IEVycm9yKFwiR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gQnNbZV0uY2FsbCh0aGlzLHQpfX1jb25zdCBxcz17RmVhdHVyZTpmdW5jdGlvbih0KXtjb25zdCBlPXt9O2Zvcihjb25zdCBuIGluIHQpZVtuXT10W25dO2lmKHQuZ2VvbWV0cnkpe2NvbnN0IG49dC5nZW9tZXRyeS50eXBlO2lmKCFxc1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrdC50eXBlKTtlLmdlb21ldHJ5PXRoaXMucmVhZCh0Lmdlb21ldHJ5KX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PXFzLmJib3guY2FsbCh0aGlzLHQuYmJveCkpLGV9LEZlYXR1cmVDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9e307aWYodC5mZWF0dXJlcyl7ZS5mZWF0dXJlcz1bXTtmb3IobGV0IG49MDtuPHQuZmVhdHVyZXMubGVuZ3RoOysrbillLmZlYXR1cmVzLnB1c2godGhpcy5yZWFkKHQuZmVhdHVyZXNbbl0pKX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PXRoaXMucGFyc2UuYmJveC5jYWxsKHRoaXMsdC5iYm94KSksZX0sY29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaChuZXcgbSguLi5zKSl9cmV0dXJuIGV9LGJib3g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoW25ldyBtKHRbMF0sdFsxXSksbmV3IG0odFsyXSx0WzFdKSxuZXcgbSh0WzJdLHRbM10pLG5ldyBtKHRbMF0sdFszXSksbmV3IG0odFswXSx0WzFdKV0pfSxQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPW5ldyBtKC4uLnQpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChxcy5Qb2ludC5jYWxsKHRoaXMsdFtuXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9cXMuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUpfSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbillLnB1c2gocXMuTGluZVN0cmluZy5jYWxsKHRoaXMsdFtuXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LFBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1xcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsdFswXSksbj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGUpLHM9W107Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDsrK2Upe2NvbnN0IG49dFtlXSxpPXFzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyxuKSxyPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoaSk7cy5wdXNoKHIpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4scyl9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKHFzLlBvbHlnb24uY2FsbCh0aGlzLHMpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaCh0aGlzLnJlYWQocykpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSxCcz17Y29vcmRpbmF0ZTpmdW5jdGlvbih0KXtjb25zdCBlPVt0LngsdC55XTtyZXR1cm4gdC56JiZlLnB1c2godC56KSx0Lm0mJmUucHVzaCh0Lm0pLGV9LFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczpCcy5jb29yZGluYXRlLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGUoKSl9fSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPUJzLlBvaW50LmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvaW50XCIsY29vcmRpbmF0ZXM6ZX19LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoOysrdCl7Y29uc3Qgcz1uW3RdO2UucHVzaChCcy5jb29yZGluYXRlLmNhbGwodGhpcyxzKSl9cmV0dXJue3R5cGU6XCJMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ccy5MaW5lU3RyaW5nLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aUxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdLG49QnMuTGluZVN0cmluZy5jYWxsKHRoaXMsdC5fc2hlbGwpO2UucHVzaChuLmNvb3JkaW5hdGVzKTtmb3IobGV0IG49MDtuPHQuX2hvbGVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5faG9sZXNbbl0saT1Ccy5MaW5lU3RyaW5nLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ccy5Qb2x5Z29uLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvbHlnb25cIixjb29yZGluYXRlczplfX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPXMuZ2V0R2VvbWV0cnlUeXBlKCk7ZS5wdXNoKEJzW2ldLmNhbGwodGhpcyxzKSl9cmV0dXJue3R5cGU6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixnZW9tZXRyaWVzOmV9fX07ZnVuY3Rpb24gWXModCl7cmV0dXJuW3QueCx0LnldfXZhciBWcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9KU09OUmVhZGVyOmNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyBHcyh0fHxuZXcgTHQpfXJlYWQodCl7cmV0dXJuIHRoaXMucGFyc2VyLnJlYWQodCl9fSxHZW9KU09OV3JpdGVyOmNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5wYXJzZXI9bmV3IEdzKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX13cml0ZSh0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9fSxPTDNQYXJzZXI6Y2xhc3N7Y29uc3RydWN0b3IodCxlKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgTHQsdGhpcy5vbD1lfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygb2wmJm9sfWluamVjdCh0LGUsbixzLGkscixvLGwpe3RoaXMub2w9e2dlb206e1BvaW50OnQsTGluZVN0cmluZzplLExpbmVhclJpbmc6bixQb2x5Z29uOnMsTXVsdGlQb2ludDppLE11bHRpTGluZVN0cmluZzpyLE11bHRpUG9seWdvbjpvLEdlb21ldHJ5Q29sbGVjdGlvbjpsfX19cmVhZCh0KXtjb25zdCBlPXRoaXMub2w7cmV0dXJuIHQgaW5zdGFuY2VvZiBlLmdlb20uUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkxpbmVhclJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5Qb2x5Z29uP3RoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlQb2ludD90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlQb2x5Z29uP3RoaXMuY29udmVydEZyb21NdWx0aVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24/dGhpcy5jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCk6dm9pZCAwfWNvbnZlcnRGcm9tUG9pbnQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBtKGVbMF0sZVsxXSkpfWNvbnZlcnRGcm9tTGluZVN0cmluZyh0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IG0odFswXSx0WzFdKX0pKSl9Y29udmVydEZyb21MaW5lYXJSaW5nKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbSh0WzBdLHRbMV0pfSkpKX1jb252ZXJ0RnJvbVBvbHlnb24odCl7Y29uc3QgZT10LmdldExpbmVhclJpbmdzKCk7bGV0IG49bnVsbDtjb25zdCBzPVtdO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBpPXRoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKGVbdF0pOzA9PT10P249aTpzLnB1c2goaSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixzKX1jb252ZXJ0RnJvbU11bHRpUG9pbnQodCl7Y29uc3QgZT10LmdldFBvaW50cygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2ludCh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfWNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nKHQpe2NvbnN0IGU9dC5nZXRMaW5lU3RyaW5ncygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX1jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KXtjb25zdCBlPXQuZ2V0UG9seWdvbnMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9Y29udmVydEZyb21Db2xsZWN0aW9uKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyaWVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX13cml0ZSh0KXtyZXR1cm5cIlBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9pbnQodC5nZXRDb29yZGluYXRlKCkpOlwiTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodCk6XCJMaW5lYXJSaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZWFyUmluZyh0KTpcIlBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQpOlwiTXVsdGlQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9pbnQodCk6XCJNdWx0aUxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCk6XCJNdWx0aVBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvbHlnb24odCk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Db2xsZWN0aW9uKHQpOnZvaWQgMH1jb252ZXJ0VG9Qb2ludCh0KXtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5Qb2ludChbdC54LHQueV0pfWNvbnZlcnRUb0xpbmVTdHJpbmcodCl7Y29uc3QgZT10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChZcyk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTGluZVN0cmluZyhlKX1jb252ZXJ0VG9MaW5lYXJSaW5nKHQpe2NvbnN0IGU9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoWXMpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLkxpbmVhclJpbmcoZSl9Y29udmVydFRvUG9seWdvbih0KXtjb25zdCBlPVt0Ll9zaGVsbC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoWXMpXTtmb3IobGV0IG49MDtuPHQuX2hvbGVzLmxlbmd0aDtuKyspZS5wdXNoKHQuX2hvbGVzW25dLl9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChZcykpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLlBvbHlnb24oZSl9Y29udmVydFRvTXVsdGlQb2ludCh0KXtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aVBvaW50KHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoWXMpKX1jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQuX2dlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpTGluZVN0cmluZyhlKX1jb252ZXJ0VG9NdWx0aVBvbHlnb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQuX2dlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9seWdvbihlKX1jb252ZXJ0VG9Db2xsZWN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXTtlLnB1c2godGhpcy53cml0ZShzKSl9cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0sV0tUUmVhZGVyOmNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyBIdCh0fHxuZXcgTHQpfXJlYWQodCl7cmV0dXJuIHRoaXMucGFyc2VyLnJlYWQodCl9fSxXS1RXcml0ZXI6V3R9KTtjbGFzcyB6c3tzdGF0aWMgcmVsYXRpdmVTaWduKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTowfXN0YXRpYyBjb21wYXJlKHQsZSxuKXtpZihlLmVxdWFsczJEKG4pKXJldHVybiAwO2NvbnN0IHM9enMucmVsYXRpdmVTaWduKGUueCxuLngpLGk9enMucmVsYXRpdmVTaWduKGUueSxuLnkpO3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZShzLGkpO2Nhc2UgMTpyZXR1cm4genMuY29tcGFyZVZhbHVlKGkscyk7Y2FzZSAyOnJldHVybiB6cy5jb21wYXJlVmFsdWUoaSwtcyk7Y2FzZSAzOnJldHVybiB6cy5jb21wYXJlVmFsdWUoLXMsaSk7Y2FzZSA0OnJldHVybiB6cy5jb21wYXJlVmFsdWUoLXMsLWkpO2Nhc2UgNTpyZXR1cm4genMuY29tcGFyZVZhbHVlKC1pLC1zKTtjYXNlIDY6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZSgtaSxzKTtjYXNlIDc6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZShzLC1pKX1yZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZShcImludmFsaWQgb2N0YW50IHZhbHVlXCIpLDB9c3RhdGljIGNvbXBhcmVWYWx1ZSh0LGUpe3JldHVybiB0PDA/LTE6dD4wPzE6ZTwwPy0xOmU+MD8xOjB9fWNsYXNzIFhze2NvbnN0cnVjdG9yKCl7WHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2VnU3RyaW5nPW51bGwsdGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5fc2VnbWVudE9jdGFudD1udWxsLHRoaXMuX2lzSW50ZXJpb3I9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9zZWdTdHJpbmc9dCx0aGlzLmNvb3JkPW5ldyBtKGUpLHRoaXMuc2VnbWVudEluZGV4PW4sdGhpcy5fc2VnbWVudE9jdGFudD1zLHRoaXMuX2lzSW50ZXJpb3I9IWUuZXF1YWxzMkQodC5nZXRDb29yZGluYXRlKG4pKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29vcmR9cHJpbnQodCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PGUuc2VnbWVudEluZGV4Py0xOnRoaXMuc2VnbWVudEluZGV4PmUuc2VnbWVudEluZGV4PzE6dGhpcy5jb29yZC5lcXVhbHMyRChlLmNvb3JkKT8wOnRoaXMuX2lzSW50ZXJpb3I/ZS5faXNJbnRlcmlvcj96cy5jb21wYXJlKHRoaXMuX3NlZ21lbnRPY3RhbnQsdGhpcy5jb29yZCxlLmNvb3JkKToxOi0xfWlzRW5kUG9pbnQodCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmIXRoaXMuX2lzSW50ZXJpb3J8fHRoaXMuc2VnbWVudEluZGV4PT09dH10b1N0cmluZygpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleCtcIjpcIit0aGlzLmNvb3JkLnRvU3RyaW5nKCl9aXNJbnRlcmlvcigpe3JldHVybiB0aGlzLl9pc0ludGVyaW9yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3Mga3N7Y29uc3RydWN0b3IoKXtrcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2RlTWFwPW5ldyBXbix0aGlzLl9lZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZT10fWdldFNwbGl0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBSO3RoaXMuYWRkRW5kcG9pbnRzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCk7dGhpcy5hZGRFZGdlQ29vcmRpbmF0ZXMobixzLHQpLG49c31yZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWFkZENvbGxhcHNlZE5vZGVzKCl7Y29uc3QgdD1uZXcgTDt0aGlzLmZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyh0KSx0aGlzLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KTtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKS5pbnRWYWx1ZSgpO3RoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSh0KSx0KX19Y3JlYXRlU3BsaXRFZGdlUHRzKHQsZSl7bGV0IG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMjtpZigyPT09bilyZXR1cm5bbmV3IG0odC5jb29yZCksbmV3IG0oZS5jb29yZCldO2NvbnN0IHM9dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUuc2VnbWVudEluZGV4KSxpPWUuaXNJbnRlcmlvcigpfHwhZS5jb29yZC5lcXVhbHMyRChzKTtpfHxuLS07Y29uc3Qgcj1uZXcgQXJyYXkobikuZmlsbChudWxsKTtsZXQgbz0wO3JbbysrXT1uZXcgbSh0LmNvb3JkKTtmb3IobGV0IG49dC5zZWdtZW50SW5kZXgrMTtuPD1lLnNlZ21lbnRJbmRleDtuKyspcltvKytdPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShuKTtyZXR1cm4gaSYmKHJbb109bmV3IG0oZS5jb29yZCkpLHJ9cHJpbnQodCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXModCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlLnNpemUoKS0yO2UrKyl7Y29uc3Qgbj10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSk7dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUrMSk7Y29uc3Qgcz10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsyKTtuLmVxdWFsczJEKHMpJiZ0LmFkZChiLnZhbHVlT2YoZSsxKSl9fWFkZEVkZ2VDb29yZGluYXRlcyh0LGUsbil7Y29uc3Qgcz10aGlzLmNyZWF0ZVNwbGl0RWRnZVB0cyh0LGUpO24uYWRkKHMsITEpfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1hZGRTcGxpdEVkZ2VzKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCksdGhpcy5hZGRDb2xsYXBzZWROb2RlcygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpLGk9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixzKTt0LmFkZChpKSxuPXN9fWZpbmRDb2xsYXBzZUluZGV4KHQsZSxuKXtpZighdC5jb29yZC5lcXVhbHMyRChlLmNvb3JkKSlyZXR1cm4hMTtsZXQgcz1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleDtyZXR1cm4gZS5pc0ludGVyaW9yKCl8fHMtLSwxPT09cyYmKG5bMF09dC5zZWdtZW50SW5kZXgrMSwhMCl9ZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLml0ZXJhdG9yKCk7bGV0IHM9bi5uZXh0KCk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IGk9bi5uZXh0KCk7dGhpcy5maW5kQ29sbGFwc2VJbmRleChzLGksZSkmJnQuYWRkKGIudmFsdWVPZihlWzBdKSkscz1pfX1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9YWRkRW5kcG9pbnRzKCl7Y29uc3QgdD10aGlzLl9lZGdlLnNpemUoKS0xO3RoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwwKSx0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUodCksdCl9Y3JlYXRlU3BsaXRFZGdlKHQsZSl7Y29uc3Qgbj10aGlzLmNyZWF0ZVNwbGl0RWRnZVB0cyh0LGUpO3JldHVybiBuZXcgWnMobix0aGlzLl9lZGdlLmdldERhdGEoKSl9YWRkKHQsZSl7Y29uc3Qgbj1uZXcgWHModGhpcy5fZWRnZSx0LGUsdGhpcy5fZWRnZS5nZXRTZWdtZW50T2N0YW50KGUpKSxzPXRoaXMuX25vZGVNYXAuZ2V0KG4pO3JldHVybiBudWxsIT09cz8oZy5pc1RydWUocy5jb29yZC5lcXVhbHMyRCh0KSxcIkZvdW5kIGVxdWFsIG5vZGVzIHdpdGggZGlmZmVyZW50IGNvb3JkaW5hdGVzXCIpLHMpOih0aGlzLl9ub2RlTWFwLnB1dChuLG4pLG4pfWNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzKHQpe2NvbnN0IGU9dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlcygpLG49dC5nZXQoMCkuZ2V0Q29vcmRpbmF0ZSgwKTtpZighbi5lcXVhbHMyRChlWzBdKSl0aHJvdyBuZXcgaChcImJhZCBzcGxpdCBlZGdlIHN0YXJ0IHBvaW50IGF0IFwiK24pO2NvbnN0IHM9dC5nZXQodC5zaXplKCktMSkuZ2V0Q29vcmRpbmF0ZXMoKSxpPXNbcy5sZW5ndGgtMV07aWYoIWkuZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkpdGhyb3cgbmV3IGgoXCJiYWQgc3BsaXQgZWRnZSBlbmQgcG9pbnQgYXQgXCIraSl9fWNsYXNzIFVze3N0YXRpYyBvY3RhbnQoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IHMoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtjb25zdCBuPU1hdGguYWJzKHQpLGk9TWF0aC5hYnMoZSk7cmV0dXJuIHQ+PTA/ZT49MD9uPj1pPzA6MTpuPj1pPzc6NjplPj0wP24+PWk/MzoyOm4+PWk/NDo1fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10LngsaT1lLnktdC55O2lmKDA9PT1uJiYwPT09aSl0aHJvdyBuZXcgcyhcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK3QpO3JldHVybiBVcy5vY3RhbnQobixpKX19fWNsYXNzIEhze2dldENvb3JkaW5hdGVzKCl7fXNpemUoKXt9Z2V0Q29vcmRpbmF0ZSh0KXt9aXNDbG9zZWQoKXt9c2V0RGF0YSh0KXt9Z2V0RGF0YSgpe319Y2xhc3MgV3N7YWRkSW50ZXJzZWN0aW9uKHQsZSl7fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIc119fWNsYXNzIFpze2NvbnN0cnVjdG9yKCl7WnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZUxpc3Q9bmV3IGtzKHRoaXMpLHRoaXMuX3B0cz1udWxsLHRoaXMuX2RhdGE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl9kYXRhPWV9c3RhdGljIGdldE5vZGVkU3Vic3RyaW5ncygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO3JldHVybiBacy5nZXROb2RlZFN1YnN0cmluZ3ModCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtmb3IobGV0IGU9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5nZXROb2RlTGlzdCgpLmFkZFNwbGl0RWRnZXModCl9fX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdHN9c2l6ZSgpe3JldHVybiB0aGlzLl9wdHMubGVuZ3RofWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0c1t0XX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoLTFdKX1nZXRTZWdtZW50T2N0YW50KHQpe3JldHVybiB0PT09dGhpcy5fcHRzLmxlbmd0aC0xPy0xOnRoaXMuc2FmZU9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fXNhZmVPY3RhbnQodCxlKXtyZXR1cm4gdC5lcXVhbHMyRChlKT8wOlVzLm9jdGFudCh0LGUpfWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1hZGRJbnRlcnNlY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbM10sbj1uZXcgbShhcmd1bWVudHNbMF0uZ2V0SW50ZXJzZWN0aW9uKGUpKTt0aGlzLmFkZEludGVyc2VjdGlvbihuLHQpfX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcobmV3IG10KHRoaXMuX3B0cykpfWdldE5vZGVMaXN0KCl7cmV0dXJuIHRoaXMuX25vZGVMaXN0fWFkZEludGVyc2VjdGlvbk5vZGUodCxlKXtsZXQgbj1lO2NvbnN0IHM9bisxO2lmKHM8dGhpcy5fcHRzLmxlbmd0aCl7Y29uc3QgZT10aGlzLl9wdHNbc107dC5lcXVhbHMyRChlKSYmKG49cyl9cmV0dXJuIHRoaXMuX25vZGVMaXN0LmFkZCh0LG4pfWFkZEludGVyc2VjdGlvbnModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1dzXX19Y2xhc3MganN7Y29uc3RydWN0b3IoKXtqcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vdmVybGFwU2VnMT1uZXcgS3QsdGhpcy5fb3ZlcmxhcFNlZzI9bmV3IEt0fW92ZXJsYXAoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM107YXJndW1lbnRzWzBdLmdldExpbmVTZWdtZW50KHQsdGhpcy5fb3ZlcmxhcFNlZzEpLGUuZ2V0TGluZVNlZ21lbnQobix0aGlzLl9vdmVybGFwU2VnMiksdGhpcy5vdmVybGFwKHRoaXMuX292ZXJsYXBTZWcxLHRoaXMuX292ZXJsYXBTZWcyKX19fWNsYXNzIEtze2NvbnN0cnVjdG9yKCl7S3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fc3RhcnQ9bnVsbCx0aGlzLl9lbmQ9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLl9jb250ZXh0PW51bGwsdGhpcy5faWQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9wdHM9dCx0aGlzLl9zdGFydD1lLHRoaXMuX2VuZD1uLHRoaXMuX2NvbnRleHQ9c31nZXRMaW5lU2VnbWVudCh0LGUpe2UucDA9dGhpcy5fcHRzW3RdLGUucDE9dGhpcy5fcHRzW3QrMV19Y29tcHV0ZVNlbGVjdCh0LGUsbixzKXtjb25zdCBpPXRoaXMuX3B0c1tlXSxyPXRoaXMuX3B0c1tuXTtpZihuLWU9PTEpcmV0dXJuIHMuc2VsZWN0KHRoaXMsZSksbnVsbDtpZighdC5pbnRlcnNlY3RzKGkscikpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKChlK24pLzIpO2U8byYmdGhpcy5jb21wdXRlU2VsZWN0KHQsZSxvLHMpLG88biYmdGhpcy5jb21wdXRlU2VsZWN0KHQsbyxuLHMpfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZW5kLXRoaXMuX3N0YXJ0KzEpLmZpbGwobnVsbCk7bGV0IGU9MDtmb3IobGV0IG49dGhpcy5fc3RhcnQ7bjw9dGhpcy5fZW5kO24rKyl0W2UrK109dGhpcy5fcHRzW25dO3JldHVybiB0fWNvbXB1dGVPdmVybGFwcygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmNvbXB1dGVPdmVybGFwcyh0aGlzLl9zdGFydCx0aGlzLl9lbmQsdCx0Ll9zdGFydCx0Ll9lbmQsZSl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07aWYoZS10PT0xJiZpLXM9PTEpcmV0dXJuIHIub3ZlcmxhcCh0aGlzLHQsbixzKSxudWxsO2lmKCF0aGlzLm92ZXJsYXBzKHQsZSxuLHMsaSkpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKCh0K2UpLzIpLGw9TWF0aC50cnVuYygocytpKS8yKTt0PG8mJihzPGwmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKHQsbyxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKHQsbyxuLGwsaSxyKSksbzxlJiYoczxsJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyhvLGUsbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyhvLGUsbixsLGkscikpfX1zZXRJZCh0KXt0aGlzLl9pZD10fXNlbGVjdCh0LGUpe3RoaXMuY29tcHV0ZVNlbGVjdCh0LHRoaXMuX3N0YXJ0LHRoaXMuX2VuZCxlKX1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe2NvbnN0IHQ9dGhpcy5fcHRzW3RoaXMuX3N0YXJ0XSxlPXRoaXMuX3B0c1t0aGlzLl9lbmRdO3RoaXMuX2Vudj1uZXcgTyh0LGUpfXJldHVybiB0aGlzLl9lbnZ9b3ZlcmxhcHModCxlLG4scyxpKXtyZXR1cm4gTy5pbnRlcnNlY3RzKHRoaXMuX3B0c1t0XSx0aGlzLl9wdHNbZV0sbi5fcHRzW3NdLG4uX3B0c1tpXSl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gdGhpcy5fZW5kfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gdGhpcy5fc3RhcnR9Z2V0Q29udGV4dCgpe3JldHVybiB0aGlzLl9jb250ZXh0fWdldElkKCl7cmV0dXJuIHRoaXMuX2lkfX1jbGFzcyBRc3tzdGF0aWMgZmluZENoYWluRW5kKHQsZSl7bGV0IG49ZTtmb3IoO248dC5sZW5ndGgtMSYmdFtuXS5lcXVhbHMyRCh0W24rMV0pOyluKys7aWYobj49dC5sZW5ndGgtMSlyZXR1cm4gdC5sZW5ndGgtMTtjb25zdCBzPUNuLnF1YWRyYW50KHRbbl0sdFtuKzFdKTtsZXQgaT1lKzE7Zm9yKDtpPHQubGVuZ3RoOyl7aWYoIXRbaS0xXS5lcXVhbHMyRCh0W2ldKSl7aWYoQ24ucXVhZHJhbnQodFtpLTFdLHRbaV0pIT09cylicmVha31pKyt9cmV0dXJuIGktMX1zdGF0aWMgZ2V0Q2hhaW5zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBRcy5nZXRDaGFpbnModCxudWxsKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtsZXQgcz0wO2Rve2NvbnN0IGk9UXMuZmluZENoYWluRW5kKHQscykscj1uZXcgS3ModCxzLGksZSk7bi5hZGQocikscz1pfXdoaWxlKHM8dC5sZW5ndGgtMSk7cmV0dXJuIG59fX1jbGFzcyBKc3tjb21wdXRlTm9kZXModCl7fWdldE5vZGVkU3Vic3RyaW5ncygpe319Y2xhc3MgJHN7Y29uc3RydWN0b3IoKXskcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zZWdJbnQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl9fXNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KXt0aGlzLl9zZWdJbnQ9dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSnNdfX1jbGFzcyB0aSBleHRlbmRzICRze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tb25vQ2hhaW5zPW5ldyBMLHRoaXMuX2luZGV4PW5ldyBicyx0aGlzLl9pZENvdW50ZXI9MCx0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9bnVsbCx0aGlzLl9uT3ZlcmxhcHM9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07JHMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19Z2V0TW9ub3RvbmVDaGFpbnMoKXtyZXR1cm4gdGhpcy5fbW9ub0NoYWluc31nZXROb2RlZFN1YnN0cmluZ3MoKXtyZXR1cm4gWnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncyl9Z2V0SW5kZXgoKXtyZXR1cm4gdGhpcy5faW5kZXh9YWRkKHQpe2ZvcihsZXQgZT1Rcy5nZXRDaGFpbnModC5nZXRDb29yZGluYXRlcygpLHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0SWQodGhpcy5faWRDb3VudGVyKyspLHRoaXMuX2luZGV4Lmluc2VydCh0LmdldEVudmVsb3BlKCksdCksdGhpcy5fbW9ub0NoYWlucy5hZGQodCl9fWNvbXB1dGVOb2Rlcyh0KXt0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9dDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7dGhpcy5pbnRlcnNlY3RDaGFpbnMoKX1pbnRlcnNlY3RDaGFpbnMoKXtjb25zdCB0PW5ldyBlaSh0aGlzLl9zZWdJbnQpO2ZvcihsZXQgZT10aGlzLl9tb25vQ2hhaW5zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2ZvcihsZXQgZT10aGlzLl9pbmRleC5xdWVyeShuLmdldEVudmVsb3BlKCkpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpO2lmKHMuZ2V0SWQoKT5uLmdldElkKCkmJihuLmNvbXB1dGVPdmVybGFwcyhzLHQpLHRoaXMuX25PdmVybGFwcysrKSx0aGlzLl9zZWdJbnQuaXNEb25lKCkpcmV0dXJuIG51bGx9fX19Y2xhc3MgZWkgZXh0ZW5kcyBqc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2k9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaT10fW92ZXJsYXAoKXtpZig0IT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gc3VwZXIub3ZlcmxhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdLHM9YXJndW1lbnRzWzBdLmdldENvbnRleHQoKSxpPWUuZ2V0Q29udGV4dCgpO3RoaXMuX3NpLnByb2Nlc3NJbnRlcnNlY3Rpb25zKHMsdCxpLG4pfX19dGkuU2VnbWVudE92ZXJsYXBBY3Rpb249ZWk7Y2xhc3Mgbml7Y29uc3RydWN0b3IoKXtuaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fb2Zmc2V0WD1udWxsLHRoaXMuX29mZnNldFk9bnVsbCx0aGlzLl9pc1NjYWxlZD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCwwKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2Rlcj10LHRoaXMuX3NjYWxlRmFjdG9yPWUsdGhpcy5faXNTY2FsZWQ9IXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCl9fXJlc2NhbGUoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLnJlc2NhbGUoZS5nZXRDb29yZGluYXRlcygpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdLng9dFtlXS54L3RoaXMuX3NjYWxlRmFjdG9yK3RoaXMuX29mZnNldFgsdFtlXS55PXRbZV0ueS90aGlzLl9zY2FsZUZhY3Rvcit0aGlzLl9vZmZzZXRZOzI9PT10Lmxlbmd0aCYmdFswXS5lcXVhbHMyRCh0WzFdKSYmWS5vdXQucHJpbnRsbih0KX19c2NhbGUoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTCh0LnNpemUoKSk7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IFpzKHRoaXMuc2NhbGUodC5nZXRDb29yZGluYXRlcygpKSx0LmdldERhdGEoKSkpfXJldHVybiBlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWVbbl09bmV3IG0oTWF0aC5yb3VuZCgodFtuXS54LXRoaXMuX29mZnNldFgpKnRoaXMuX3NjYWxlRmFjdG9yKSxNYXRoLnJvdW5kKCh0W25dLnktdGhpcy5fb2Zmc2V0WSkqdGhpcy5fc2NhbGVGYWN0b3IpLHRbbl0uZ2V0WigpKTtyZXR1cm4gX3QucmVtb3ZlUmVwZWF0ZWRQb2ludHMoZSl9fWlzSW50ZWdlclByZWNpc2lvbigpe3JldHVybiAxPT09dGhpcy5fc2NhbGVGYWN0b3J9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7Y29uc3QgdD10aGlzLl9ub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtyZXR1cm4gdGhpcy5faXNTY2FsZWQmJnRoaXMucmVzY2FsZSh0KSx0fWNvbXB1dGVOb2Rlcyh0KXtsZXQgZT10O3RoaXMuX2lzU2NhbGVkJiYoZT10aGlzLnNjYWxlKHQpKSx0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXMoZSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pzXX19dmFyIHNpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLE1DSW5kZXhOb2Rlcjp0aSxTY2FsZWROb2RlcjpuaSxTZWdtZW50U3RyaW5nOkhzfSk7Y2xhc3MgaWl7Y29uc3RydWN0b3IoKXtpaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9iblJ1bGU9bnVsbCx0aGlzLl9lbmRwb2ludE1hcD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZ24uTU9EMl9CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tPXQsdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCksdGhpcy5fYm5SdWxlPWV9fXN0YXRpYyBnZXRCb3VuZGFyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IGlpKGFyZ3VtZW50c1swXSkuZ2V0Qm91bmRhcnkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBpaShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5nZXRCb3VuZGFyeSgpfX1ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0KXtpZih0aGlzLl9nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTtjb25zdCBlPXRoaXMuY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXModCk7cmV0dXJuIDE9PT1lLmxlbmd0aD90aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludChlWzBdKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhlKX1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLl9nZW9tIGluc3RhbmNlb2YgJD90aGlzLmJvdW5kYXJ5TGluZVN0cmluZyh0aGlzLl9nZW9tKTp0aGlzLl9nZW9tIGluc3RhbmNlb2YgU3Q/dGhpcy5ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0aGlzLl9nZW9tKTp0aGlzLl9nZW9tLmdldEJvdW5kYXJ5KCl9Ym91bmRhcnlMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2dlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO2lmKHQuaXNDbG9zZWQoKSl7cmV0dXJuIHRoaXMuX2JuUnVsZS5pc0luQm91bmRhcnkoMik/dC5nZXRTdGFydFBvaW50KCk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfXJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KFt0LmdldFN0YXJ0UG9pbnQoKSx0LmdldEVuZFBvaW50KCldKX1nZXRFbXB0eU11bHRpUG9pbnQoKXtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfWNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEw7dGhpcy5fZW5kcG9pbnRNYXA9bmV3IFduO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpOzAhPT1uLmdldE51bVBvaW50cygpJiYodGhpcy5hZGRFbmRwb2ludChuLmdldENvb3JkaW5hdGVOKDApKSx0aGlzLmFkZEVuZHBvaW50KG4uZ2V0Q29vcmRpbmF0ZU4obi5nZXROdW1Qb2ludHMoKS0xKSkpfWZvcihsZXQgdD10aGlzLl9lbmRwb2ludE1hcC5lbnRyeVNldCgpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRWYWx1ZSgpLmNvdW50O3RoaXMuX2JuUnVsZS5pc0luQm91bmRhcnkocykmJmUuYWRkKG4uZ2V0S2V5KCkpfXJldHVybiBfdC50b0Nvb3JkaW5hdGVBcnJheShlKX1hZGRFbmRwb2ludCh0KXtsZXQgZT10aGlzLl9lbmRwb2ludE1hcC5nZXQodCk7bnVsbD09PWUmJihlPW5ldyByaSx0aGlzLl9lbmRwb2ludE1hcC5wdXQodCxlKSksZS5jb3VudCsrfX1sZXQgcmk9Y2xhc3N7Y29uc3RydWN0b3IoKXtyaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmNvdW50PW51bGx9fTtjbGFzcyBvaXtjb25zdHJ1Y3Rvcigpe29pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hMCx0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9IWUuaXNJbkJvdW5kYXJ5KDIpfX1zdGF0aWMgaXNTaW1wbGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBvaShhcmd1bWVudHNbMF0pLmlzU2ltcGxlKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgb2koYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkuaXNTaW1wbGUoKX19aXNTaW1wbGVNdWx0aVBvaW50KHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO2NvbnN0IGU9bmV3IGF0O2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pLmdldENvb3JkaW5hdGUoKTtpZihlLmNvbnRhaW5zKHMpKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1zLCExO2UuYWRkKHMpfXJldHVybiEwfWlzU2ltcGxlUG9seWdvbmFsKHQpe2ZvcihsZXQgZT15ZS5nZXRMaW5lcyh0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZighdGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpKXJldHVybiExfXJldHVybiEwfWhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uKHQpe2NvbnN0IGU9bmV3IFduO2ZvcihsZXQgbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxzPXQuaXNDbG9zZWQoKSxpPXQuZ2V0Q29vcmRpbmF0ZSgwKTt0aGlzLmFkZEVuZHBvaW50KGUsaSxzKTtjb25zdCByPXQuZ2V0Q29vcmRpbmF0ZSh0LmdldE51bVBvaW50cygpLTEpO3RoaXMuYWRkRW5kcG9pbnQoZSxyLHMpfWZvcihsZXQgdD1lLnZhbHVlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2lmKGUuaXNDbG9zZWQmJjIhPT1lLmRlZ3JlZSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249ZS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9Z2V0Tm9uU2ltcGxlTG9jYXRpb24oKXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb259aXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtjb25zdCBlPW5ldyBhcygwLHQpLG49bmV3IGp0LHM9ZS5jb21wdXRlU2VsZk5vZGVzKG4sITApO3JldHVybiFzLmhhc0ludGVyc2VjdGlvbigpfHwocy5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5fbm9uU2ltcGxlTG9jYXRpb249cy5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKTohdGhpcy5oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbihlKSYmKCF0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3J8fCF0aGlzLmhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uKGUpKSl9aGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCk7Zm9yKGxldCBlPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZighdC5pc0VuZFBvaW50KG4pKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj10LmdldENvb3JkaW5hdGUoKSwhMH19cmV0dXJuITF9YWRkRW5kcG9pbnQodCxlLG4pe2xldCBzPXQuZ2V0KGUpO251bGw9PT1zJiYocz1uZXcgbGkoZSksdC5wdXQoZSxzKSkscy5hZGRFbmRwb2ludChuKX1jb21wdXRlU2ltcGxlKHQpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLCEhdC5pc0VtcHR5KCl8fCh0IGluc3RhbmNlb2YgJHx8dCBpbnN0YW5jZW9mIFN0P3RoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KTp0IGluc3RhbmNlb2YgdXQ/dGhpcy5pc1NpbXBsZU11bHRpUG9pbnQodCk6SSh0LGl0KT90aGlzLmlzU2ltcGxlUG9seWdvbmFsKHQpOiEodCBpbnN0YW5jZW9mIGh0KXx8dGhpcy5pc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbih0KSl9aXNTaW1wbGUoKXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCx0aGlzLmNvbXB1dGVTaW1wbGUodGhpcy5faW5wdXRHZW9tKX1pc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5jb21wdXRlU2ltcGxlKG4pKXJldHVybiExfXJldHVybiEwfX1jbGFzcyBsaXtjb25zdHJ1Y3Rvcigpe2xpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMucHQ9bnVsbCx0aGlzLmlzQ2xvc2VkPW51bGwsdGhpcy5kZWdyZWU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnB0PXQsdGhpcy5pc0Nsb3NlZD0hMSx0aGlzLmRlZ3JlZT0wfWFkZEVuZHBvaW50KHQpe3RoaXMuZGVncmVlKyssdGhpcy5pc0Nsb3NlZHw9dH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMucHR9fW9pLkVuZHBvaW50SW5mbz1saTtjbGFzcyBhaXtjb25zdHJ1Y3Rvcigpe2FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3F1YWRyYW50U2VnbWVudHM9YWkuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyx0aGlzLl9lbmRDYXBTdHlsZT1haS5DQVBfUk9VTkQsdGhpcy5fam9pblN0eWxlPWFpLkpPSU5fUk9VTkQsdGhpcy5fbWl0cmVMaW1pdD1haS5ERUZBVUxUX01JVFJFX0xJTUlULHRoaXMuX2lzU2luZ2xlU2lkZWQ9ITEsdGhpcy5fc2ltcGxpZnlGYWN0b3I9YWkuREVGQVVMVF9TSU1QTElGWV9GQUNUT1IsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCksdGhpcy5zZXRFbmRDYXBTdHlsZShlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCksdGhpcy5zZXRFbmRDYXBTdHlsZShlKSx0aGlzLnNldEpvaW5TdHlsZShuKSx0aGlzLnNldE1pdHJlTGltaXQocyl9fXN0YXRpYyBidWZmZXJEaXN0YW5jZUVycm9yKHQpe2NvbnN0IGU9TWF0aC5QSS8yL3Q7cmV0dXJuIDEtTWF0aC5jb3MoZS8yKX1nZXRFbmRDYXBTdHlsZSgpe3JldHVybiB0aGlzLl9lbmRDYXBTdHlsZX1pc1NpbmdsZVNpZGVkKCl7cmV0dXJuIHRoaXMuX2lzU2luZ2xlU2lkZWR9c2V0UXVhZHJhbnRTZWdtZW50cyh0KXt0aGlzLl9xdWFkcmFudFNlZ21lbnRzPXQsMD09PXRoaXMuX3F1YWRyYW50U2VnbWVudHMmJih0aGlzLl9qb2luU3R5bGU9YWkuSk9JTl9CRVZFTCksdGhpcy5fcXVhZHJhbnRTZWdtZW50czwwJiYodGhpcy5fam9pblN0eWxlPWFpLkpPSU5fTUlUUkUsdGhpcy5fbWl0cmVMaW1pdD1NYXRoLmFicyh0aGlzLl9xdWFkcmFudFNlZ21lbnRzKSksdDw9MCYmKHRoaXMuX3F1YWRyYW50U2VnbWVudHM9MSksdGhpcy5fam9pblN0eWxlIT09YWkuSk9JTl9ST1VORCYmKHRoaXMuX3F1YWRyYW50U2VnbWVudHM9YWkuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyl9Z2V0Sm9pblN0eWxlKCl7cmV0dXJuIHRoaXMuX2pvaW5TdHlsZX1zZXRKb2luU3R5bGUodCl7dGhpcy5fam9pblN0eWxlPXR9c2V0U2ltcGxpZnlGYWN0b3IodCl7dGhpcy5fc2ltcGxpZnlGYWN0b3I9dDwwPzA6dH1nZXRTaW1wbGlmeUZhY3Rvcigpe3JldHVybiB0aGlzLl9zaW1wbGlmeUZhY3Rvcn1nZXRRdWFkcmFudFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50U2VnbWVudHN9c2V0RW5kQ2FwU3R5bGUodCl7dGhpcy5fZW5kQ2FwU3R5bGU9dH1nZXRNaXRyZUxpbWl0KCl7cmV0dXJuIHRoaXMuX21pdHJlTGltaXR9c2V0TWl0cmVMaW1pdCh0KXt0aGlzLl9taXRyZUxpbWl0PXR9c2V0U2luZ2xlU2lkZWQodCl7dGhpcy5faXNTaW5nbGVTaWRlZD10fX1haS5DQVBfUk9VTkQ9MSxhaS5DQVBfRkxBVD0yLGFpLkNBUF9TUVVBUkU9MyxhaS5KT0lOX1JPVU5EPTEsYWkuSk9JTl9NSVRSRT0yLGFpLkpPSU5fQkVWRUw9MyxhaS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTPTgsYWkuREVGQVVMVF9NSVRSRV9MSU1JVD01LGFpLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SPS4wMTtjbGFzcyBjaXtjb25zdHJ1Y3Rvcigpe2NpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21pbkluZGV4PS0xLHRoaXMuX21pbkNvb3JkPW51bGwsdGhpcy5fbWluRGU9bnVsbCx0aGlzLl9vcmllbnRlZERlPW51bGx9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9taW5Db29yZH1nZXRSaWdodG1vc3RTaWRlKHQsZSl7bGV0IG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSk7cmV0dXJuIG48MCYmKG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZS0xKSksbjwwJiYodGhpcy5fbWluQ29vcmQ9bnVsbCx0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KSksbn1maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCl7Y29uc3QgdD10aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtnLmlzVHJ1ZSh0aGlzLl9taW5JbmRleD4wJiZ0aGlzLl9taW5JbmRleDx0Lmxlbmd0aCxcInJpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZVwiKTtjb25zdCBlPXRbdGhpcy5fbWluSW5kZXgtMV0sbj10W3RoaXMuX21pbkluZGV4KzFdLHM9cS5pbmRleCh0aGlzLl9taW5Db29yZCxuLGUpO2xldCBpPSExOyhlLnk8dGhpcy5fbWluQ29vcmQueSYmbi55PHRoaXMuX21pbkNvb3JkLnkmJnM9PT1xLkNPVU5URVJDTE9DS1dJU0V8fGUueT50aGlzLl9taW5Db29yZC55JiZuLnk+dGhpcy5fbWluQ29vcmQueSYmcz09PXEuQ0xPQ0tXSVNFKSYmKGk9ITApLGkmJih0aGlzLl9taW5JbmRleD10aGlzLl9taW5JbmRleC0xKX1nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSl7Y29uc3Qgbj10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2lmKGU8MHx8ZSsxPj1uLmxlbmd0aClyZXR1cm4tMTtpZihuW2VdLnk9PT1uW2UrMV0ueSlyZXR1cm4tMTtsZXQgcz1ibi5MRUZUO3JldHVybiBuW2VdLnk8bltlKzFdLnkmJihzPWJuLlJJR0hUKSxzfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fb3JpZW50ZWREZX1jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCl7Y29uc3QgZT10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGgtMTtuKyspKG51bGw9PT10aGlzLl9taW5Db29yZHx8ZVtuXS54PnRoaXMuX21pbkNvb3JkLngpJiYodGhpcy5fbWluRGU9dCx0aGlzLl9taW5JbmRleD1uLHRoaXMuX21pbkNvb3JkPWVbbl0pfWZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCl7Y29uc3QgdD10aGlzLl9taW5EZS5nZXROb2RlKCkuZ2V0RWRnZXMoKTt0aGlzLl9taW5EZT10LmdldFJpZ2h0bW9zdEVkZ2UoKSx0aGlzLl9taW5EZS5pc0ZvcndhcmQoKXx8KHRoaXMuX21pbkRlPXRoaXMuX21pbkRlLmdldFN5bSgpLHRoaXMuX21pbkluZGV4PXRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLmxlbmd0aC0xKX1maW5kRWRnZSh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmlzRm9yd2FyZCgpJiZ0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KX1nLmlzVHJ1ZSgwIT09dGhpcy5fbWluSW5kZXh8fHRoaXMuX21pbkNvb3JkLmVxdWFscyh0aGlzLl9taW5EZS5nZXRDb29yZGluYXRlKCkpLFwiaW5jb25zaXN0ZW5jeSBpbiByaWdodG1vc3QgcHJvY2Vzc2luZ1wiKSwwPT09dGhpcy5fbWluSW5kZXg/dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpOnRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpLHRoaXMuX29yaWVudGVkRGU9dGhpcy5fbWluRGU7dGhpcy5nZXRSaWdodG1vc3RTaWRlKHRoaXMuX21pbkRlLHRoaXMuX21pbkluZGV4KT09PWJuLkxFRlQmJih0aGlzLl9vcmllbnRlZERlPXRoaXMuX21pbkRlLmdldFN5bSgpKX19Y2xhc3MgaGl7Y29uc3RydWN0b3IoKXt0aGlzLmFycmF5PVtdfWFkZExhc3QodCl7dGhpcy5hcnJheS5wdXNoKHQpfXJlbW92ZUZpcnN0KCl7cmV0dXJuIHRoaXMuYXJyYXkuc2hpZnQoKX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Lmxlbmd0aH19Y2xhc3MgdWl7Y29uc3RydWN0b3IoKXt1aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9maW5kZXI9bnVsbCx0aGlzLl9kaXJFZGdlTGlzdD1uZXcgTCx0aGlzLl9ub2Rlcz1uZXcgTCx0aGlzLl9yaWdodE1vc3RDb29yZD1udWxsLHRoaXMuX2Vudj1udWxsLHRoaXMuX2ZpbmRlcj1uZXcgY2l9Y2xlYXJWaXNpdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLnNldFZpc2l0ZWQoITEpfX1nZXRSaWdodG1vc3RDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3JpZ2h0TW9zdENvb3JkfWNvbXB1dGVOb2RlRGVwdGgodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQuaXNWaXNpdGVkKCl8fHQuZ2V0U3ltKCkuaXNWaXNpdGVkKCkpe2U9dDticmVha319aWYobnVsbD09PWUpdGhyb3cgbmV3IGlzKFwidW5hYmxlIHRvIGZpbmQgZWRnZSB0byBjb21wdXRlIGRlcHRocyBhdCBcIit0LmdldENvb3JkaW5hdGUoKSk7dC5nZXRFZGdlcygpLmNvbXB1dGVEZXB0aHMoZSk7Zm9yKGxldCBlPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldFZpc2l0ZWQoITApLHRoaXMuY29weVN5bURlcHRocyh0KX19Y29tcHV0ZURlcHRoKHQpe3RoaXMuY2xlYXJWaXNpdGVkRWRnZXMoKTtjb25zdCBlPXRoaXMuX2ZpbmRlci5nZXRFZGdlKCk7ZS5nZXROb2RlKCksZS5nZXRMYWJlbCgpLGUuc2V0RWRnZURlcHRocyhibi5SSUdIVCx0KSx0aGlzLmNvcHlTeW1EZXB0aHMoZSksdGhpcy5jb21wdXRlRGVwdGhzKGUpfWNyZWF0ZSh0KXt0aGlzLmFkZFJlYWNoYWJsZSh0KSx0aGlzLl9maW5kZXIuZmluZEVkZ2UodGhpcy5fZGlyRWRnZUxpc3QpLHRoaXMuX3JpZ2h0TW9zdENvb3JkPXRoaXMuX2ZpbmRlci5nZXRDb29yZGluYXRlKCl9ZmluZFJlc3VsdEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuZ2V0RGVwdGgoYm4uUklHSFQpPj0xJiZlLmdldERlcHRoKGJuLkxFRlQpPD0wJiYhZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmZS5zZXRJblJlc3VsdCghMCl9fWNvbXB1dGVEZXB0aHModCl7Y29uc3QgZT1uZXcgRXQsbj1uZXcgaGkscz10LmdldE5vZGUoKTtmb3Iobi5hZGRMYXN0KHMpLGUuYWRkKHMpLHQuc2V0VmlzaXRlZCghMCk7IW4uaXNFbXB0eSgpOyl7Y29uc3QgdD1uLnJlbW92ZUZpcnN0KCk7ZS5hZGQodCksdGhpcy5jb21wdXRlTm9kZURlcHRoKHQpO2ZvcihsZXQgcz10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCkuZ2V0U3ltKCk7aWYodC5pc1Zpc2l0ZWQoKSljb250aW51ZTtjb25zdCBpPXQuZ2V0Tm9kZSgpO2UuY29udGFpbnMoaSl8fChuLmFkZExhc3QoaSksZS5hZGQoaSkpfX19Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fcmlnaHRNb3N0Q29vcmQueDxlLl9yaWdodE1vc3RDb29yZC54Py0xOnRoaXMuX3JpZ2h0TW9zdENvb3JkLng+ZS5fcmlnaHRNb3N0Q29vcmQueD8xOjB9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXtjb25zdCB0PW5ldyBPO2ZvcihsZXQgZT10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoLTE7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKG5bZV0pfXRoaXMuX2Vudj10fXJldHVybiB0aGlzLl9lbnZ9YWRkUmVhY2hhYmxlKHQpe2NvbnN0IGU9bmV3IGVuO2ZvcihlLmFkZCh0KTshZS5lbXB0eSgpOyl7Y29uc3QgdD1lLnBvcCgpO3RoaXMuYWRkKHQsZSl9fWNvcHlTeW1EZXB0aHModCl7Y29uc3QgZT10LmdldFN5bSgpO2Uuc2V0RGVwdGgoYm4uTEVGVCx0LmdldERlcHRoKGJuLlJJR0hUKSksZS5zZXREZXB0aChibi5SSUdIVCx0LmdldERlcHRoKGJuLkxFRlQpKX1hZGQodCxlKXt0LnNldFZpc2l0ZWQoITApLHRoaXMuX25vZGVzLmFkZCh0KTtmb3IobGV0IG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX2RpckVkZ2VMaXN0LmFkZCh0KTtjb25zdCBzPXQuZ2V0U3ltKCkuZ2V0Tm9kZSgpO3MuaXNWaXNpdGVkKCl8fGUucHVzaChzKX19Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZXN9Z2V0RGlyZWN0ZWRFZGdlcygpe3JldHVybiB0aGlzLl9kaXJFZGdlTGlzdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWxldCBnaT1jbGFzc3tjb25zdHJ1Y3Rvcigpe2dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3N0YXJ0RGU9bnVsbCx0aGlzLl9tYXhOb2RlRGVncmVlPS0xLHRoaXMuX2VkZ2VzPW5ldyBMLHRoaXMuX3B0cz1uZXcgTCx0aGlzLl9sYWJlbD1uZXcgQm4oUXQuTk9ORSksdGhpcy5fcmluZz1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuX3NoZWxsPW51bGwsdGhpcy5faG9sZXM9bmV3IEwsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1lLHRoaXMuY29tcHV0ZVBvaW50cyh0KSx0aGlzLmNvbXB1dGVSaW5nKCl9fWNvbXB1dGVSaW5nKCl7aWYobnVsbCE9PXRoaXMuX3JpbmcpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fcHRzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX3B0cy5zaXplKCk7ZSsrKXRbZV09dGhpcy5fcHRzLmdldChlKTt0aGlzLl9yaW5nPXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpLHRoaXMuX2lzSG9sZT1xLmlzQ0NXKHRoaXMuX3JpbmcuZ2V0Q29vcmRpbmF0ZXMoKSl9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWNvbXB1dGVQb2ludHModCl7dGhpcy5fc3RhcnREZT10O2xldCBlPXQsbj0hMDtkb3tpZihudWxsPT09ZSl0aHJvdyBuZXcgaXMoXCJGb3VuZCBudWxsIERpcmVjdGVkRWRnZVwiKTtpZihlLmdldEVkZ2VSaW5nKCk9PT10aGlzKXRocm93IG5ldyBpcyhcIkRpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCBcIitlLmdldENvb3JkaW5hdGUoKSk7dGhpcy5fZWRnZXMuYWRkKGUpO2NvbnN0IHQ9ZS5nZXRMYWJlbCgpO2cuaXNUcnVlKHQuaXNBcmVhKCkpLHRoaXMubWVyZ2VMYWJlbCh0KSx0aGlzLmFkZFBvaW50cyhlLmdldEVkZ2UoKSxlLmlzRm9yd2FyZCgpLG4pLG49ITEsdGhpcy5zZXRFZGdlUmluZyhlLHRoaXMpLGU9dGhpcy5nZXROZXh0KGUpfXdoaWxlKGUhPT10aGlzLl9zdGFydERlKX1nZXRMaW5lYXJSaW5nKCl7cmV0dXJuIHRoaXMuX3Jpbmd9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzLmdldCh0KX1jb21wdXRlTWF4Tm9kZURlZ3JlZSgpe3RoaXMuX21heE5vZGVEZWdyZWU9MDtsZXQgdD10aGlzLl9zdGFydERlO2Rve2NvbnN0IGU9dC5nZXROb2RlKCkuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzKTtlPnRoaXMuX21heE5vZGVEZWdyZWUmJih0aGlzLl9tYXhOb2RlRGVncmVlPWUpLHQ9dGhpcy5nZXROZXh0KHQpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKTt0aGlzLl9tYXhOb2RlRGVncmVlKj0yfWFkZFBvaW50cyh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCk7aWYoZSl7bGV0IHQ9MTtuJiYodD0wKTtmb3IobGV0IGU9dDtlPHMubGVuZ3RoO2UrKyl0aGlzLl9wdHMuYWRkKHNbZV0pfWVsc2V7bGV0IHQ9cy5sZW5ndGgtMjtuJiYodD1zLmxlbmd0aC0xKTtmb3IobGV0IGU9dDtlPj0wO2UtLSl0aGlzLl9wdHMuYWRkKHNbZV0pfX1pc0hvbGUoKXtyZXR1cm4gdGhpcy5faXNIb2xlfXNldEluUmVzdWx0KCl7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3t0LmdldEVkZ2UoKS5zZXRJblJlc3VsdCghMCksdD10LmdldE5leHQoKX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSl9Y29udGFpbnNQb2ludCh0KXtjb25zdCBlPXRoaXMuZ2V0TGluZWFyUmluZygpO2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyh0KSlyZXR1cm4hMTtpZighVWUuaXNJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpKXJldHVybiExO2ZvcihsZXQgZT10aGlzLl9ob2xlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7aWYoZS5uZXh0KCkuY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMX1yZXR1cm4hMH1hZGRIb2xlKHQpe3RoaXMuX2hvbGVzLmFkZCh0KX1pc1NoZWxsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9zaGVsbH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31nZXRNYXhOb2RlRGVncmVlKCl7cmV0dXJuIHRoaXMuX21heE5vZGVEZWdyZWU8MCYmdGhpcy5jb21wdXRlTWF4Tm9kZURlZ3JlZSgpLHRoaXMuX21heE5vZGVEZWdyZWV9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5fc2hlbGx9bWVyZ2VMYWJlbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodCwwKSx0aGlzLm1lcmdlTGFiZWwodCwxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXS5nZXRMb2NhdGlvbih0LGJuLlJJR0hUKTtpZihlPT09UXQuTk9ORSlyZXR1cm4gbnVsbDtpZih0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbih0KT09PVF0Lk5PTkUpcmV0dXJuIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSksbnVsbH19c2V0U2hlbGwodCl7dGhpcy5fc2hlbGw9dCxudWxsIT09dCYmdC5hZGRIb2xlKHRoaXMpfXRvUG9seWdvbih0KXtjb25zdCBlPW5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5zaXplKCk7dCsrKWVbdF09dGhpcy5faG9sZXMuZ2V0KHQpLmdldExpbmVhclJpbmcoKTtyZXR1cm4gdC5jcmVhdGVQb2x5Z29uKHRoaXMuZ2V0TGluZWFyUmluZygpLGUpfX07Y2xhc3MgZGkgZXh0ZW5kcyBnaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Z2kuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfXNldEVkZ2VSaW5nKHQsZSl7dC5zZXRNaW5FZGdlUmluZyhlKX1nZXROZXh0KHQpe3JldHVybiB0LmdldE5leHRNaW4oKX19Y2xhc3MgX2kgZXh0ZW5kcyBnaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksX2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Z2kuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfWJ1aWxkTWluaW1hbFJpbmdzKCl7Y29uc3QgdD1uZXcgTDtsZXQgZT10aGlzLl9zdGFydERlO2Rve2lmKG51bGw9PT1lLmdldE1pbkVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IGRpKGUsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTt0LmFkZChuKX1lPWUuZ2V0TmV4dCgpfXdoaWxlKGUhPT10aGlzLl9zdGFydERlKTtyZXR1cm4gdH1zZXRFZGdlUmluZyh0LGUpe3Quc2V0RWRnZVJpbmcoZSl9bGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCl7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3t0LmdldE5vZGUoKS5nZXRFZGdlcygpLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0aGlzKSx0PXQuZ2V0TmV4dCgpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKX1nZXROZXh0KHQpe3JldHVybiB0LmdldE5leHQoKX19Y2xhc3MgcGl7Y29uc3RydWN0b3IoKXtwaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9zaGVsbExpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PXR9c3RhdGljIGZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0TGluZWFyUmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCk7bGV0IGk9bi5nZXRDb29yZGluYXRlTigwKSxyPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLGw9ZS5nZXRMaW5lYXJSaW5nKCksYT1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZihhLmVxdWFscyhzKSljb250aW51ZTtpZighYS5jb250YWlucyhzKSljb250aW51ZTtpPV90LnB0Tm90SW5MaXN0KG4uZ2V0Q29vcmRpbmF0ZXMoKSxsLmdldENvb3JkaW5hdGVzKCkpO2xldCBjPSExO1VlLmlzSW5SaW5nKGksbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09cnx8by5jb250YWlucyhhKSkmJihyPWUsbz1yLmdldExpbmVhclJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfXJldHVybiByfXNvcnRTaGVsbHNBbmRIb2xlcyh0LGUsbil7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc0hvbGUoKT9uLmFkZCh0KTplLmFkZCh0KX19Y29tcHV0ZVBvbHlnb25zKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkudG9Qb2x5Z29uKHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7ZS5hZGQodCl9cmV0dXJuIGV9cGxhY2VGcmVlSG9sZXModCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtpZihudWxsPT09ZS5nZXRTaGVsbCgpKXtjb25zdCBuPXBpLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoZSx0KTtpZihudWxsPT09bil0aHJvdyBuZXcgaXMoXCJ1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbFwiLGUuZ2V0Q29vcmRpbmF0ZSgwKSk7ZS5zZXRTaGVsbChuKX19fWJ1aWxkTWluaW1hbEVkZ2VSaW5ncyh0LGUsbil7Y29uc3Qgcz1uZXcgTDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKTtpZih0LmdldE1heE5vZGVEZWdyZWUoKT4yKXt0LmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9dC5idWlsZE1pbmltYWxSaW5ncygpLGk9dGhpcy5maW5kU2hlbGwocyk7bnVsbCE9PWk/KHRoaXMucGxhY2VQb2x5Z29uSG9sZXMoaSxzKSxlLmFkZChpKSk6bi5hZGRBbGwocyl9ZWxzZSBzLmFkZCh0KX1yZXR1cm4gc31idWlsZE1heGltYWxFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzSW5SZXN1bHQoKSYmdC5nZXRMYWJlbCgpLmlzQXJlYSgpJiZudWxsPT09dC5nZXRFZGdlUmluZygpKXtjb25zdCBuPW5ldyBfaSh0LHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7ZS5hZGQobiksbi5zZXRJblJlc3VsdCgpfX1yZXR1cm4gZX1wbGFjZVBvbHlnb25Ib2xlcyh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2UuaXNIb2xlKCkmJmUuc2V0U2hlbGwodCl9fWdldFBvbHlnb25zKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVBvbHlnb25zKHRoaXMuX3NoZWxsTGlzdCl9ZmluZFNoZWxsKHQpe2xldCBlPTAsbj1udWxsO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNIb2xlKCl8fChuPXQsZSsrKX1yZXR1cm4gZy5pc1RydWUoZTw9MSxcImZvdW5kIHR3byBzaGVsbHMgaW4gTWluaW1hbEVkZ2VSaW5nIGxpc3RcIiksbn1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodC5nZXRFZGdlRW5kcygpLHQuZ2V0Tm9kZXMoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bHMubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoZSk7Y29uc3Qgbj10aGlzLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyh0KSxzPW5ldyBMLGk9dGhpcy5idWlsZE1pbmltYWxFZGdlUmluZ3Mobix0aGlzLl9zaGVsbExpc3Qscyk7dGhpcy5zb3J0U2hlbGxzQW5kSG9sZXMoaSx0aGlzLl9zaGVsbExpc3QscyksdGhpcy5wbGFjZUZyZWVIb2xlcyh0aGlzLl9zaGVsbExpc3Qscyl9fX1jbGFzcyBtaXtjb25zdHJ1Y3Rvcigpe21pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0TGluZT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sPW51bGwsdGhpcy5faXNEZWxldGVkPW51bGwsdGhpcy5fYW5nbGVPcmllbnRhdGlvbj1xLkNPVU5URVJDTE9DS1dJU0U7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRMaW5lPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7cmV0dXJuIG5ldyBtaSh0KS5zaW1wbGlmeShlKX1pc0RlbGV0YWJsZSh0LGUsbixzKXtjb25zdCBpPXRoaXMuX2lucHV0TGluZVt0XSxyPXRoaXMuX2lucHV0TGluZVtlXSxvPXRoaXMuX2lucHV0TGluZVtuXTtyZXR1cm4hIXRoaXMuaXNDb25jYXZlKGkscixvKSYmKCEhdGhpcy5pc1NoYWxsb3coaSxyLG8scykmJnRoaXMuaXNTaGFsbG93U2FtcGxlZChpLHIsdCxuLHMpKX1kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMoKXtsZXQgdD0xLGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSkscz0hMTtmb3IoO248dGhpcy5faW5wdXRMaW5lLmxlbmd0aDspe2xldCBpPSExO3RoaXMuaXNEZWxldGFibGUodCxlLG4sdGhpcy5fZGlzdGFuY2VUb2wpJiYodGhpcy5faXNEZWxldGVkW2VdPW1pLkRFTEVURSxpPSEwLHM9ITApLHQ9aT9uOmUsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKX1yZXR1cm4gc31pc1NoYWxsb3dDb25jYXZpdHkodCxlLG4scyl7aWYoIShxLmluZGV4KHQsZSxuKT09PXRoaXMuX2FuZ2xlT3JpZW50YXRpb24pKXJldHVybiExO3JldHVybiB6LnBvaW50VG9TZWdtZW50KGUsdCxuKTxzfWlzU2hhbGxvd1NhbXBsZWQodCxlLG4scyxpKXtsZXQgcj1NYXRoLnRydW5jKChzLW4pL21pLk5VTV9QVFNfVE9fQ0hFQ0spO3I8PTAmJihyPTEpO2ZvcihsZXQgbz1uO288cztvKz1yKWlmKCF0aGlzLmlzU2hhbGxvdyh0LGUsdGhpcy5faW5wdXRMaW5lW29dLGkpKXJldHVybiExO3JldHVybiEwfWlzQ29uY2F2ZSh0LGUsbil7cmV0dXJuIHEuaW5kZXgodCxlLG4pPT09dGhpcy5fYW5nbGVPcmllbnRhdGlvbn1zaW1wbGlmeSh0KXt0aGlzLl9kaXN0YW5jZVRvbD1NYXRoLmFicyh0KSx0PDAmJih0aGlzLl9hbmdsZU9yaWVudGF0aW9uPXEuQ0xPQ0tXSVNFKSx0aGlzLl9pc0RlbGV0ZWQ9bmV3IEFycmF5KHRoaXMuX2lucHV0TGluZS5sZW5ndGgpLmZpbGwobnVsbCk7bGV0IGU9ITE7ZG97ZT10aGlzLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpfXdoaWxlKGUpO3JldHVybiB0aGlzLmNvbGxhcHNlTGluZSgpfWZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpe2xldCBlPXQrMTtmb3IoO2U8dGhpcy5faW5wdXRMaW5lLmxlbmd0aCYmdGhpcy5faXNEZWxldGVkW2VdPT09bWkuREVMRVRFOyllKys7cmV0dXJuIGV9aXNTaGFsbG93KHQsZSxuLHMpe3JldHVybiB6LnBvaW50VG9TZWdtZW50KGUsdCxuKTxzfWNvbGxhcHNlTGluZSgpe2NvbnN0IHQ9bmV3IFI7Zm9yKGxldCBlPTA7ZTx0aGlzLl9pbnB1dExpbmUubGVuZ3RoO2UrKyl0aGlzLl9pc0RlbGV0ZWRbZV0hPT1taS5ERUxFVEUmJnQuYWRkKHRoaXMuX2lucHV0TGluZVtlXSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX19bWkuSU5JVD0wLG1pLkRFTEVURT0xLG1pLktFRVA9MSxtaS5OVU1fUFRTX1RPX0NIRUNLPTEwO2NsYXNzIGZpe2NvbnN0cnVjdG9yKCl7ZmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRMaXN0PW51bGwsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2U9MCx0aGlzLl9wdExpc3Q9bmV3IEx9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRMaXN0LnRvQXJyYXkoZmkuQ09PUkRJTkFURV9BUlJBWV9UWVBFKX1zZXRQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9wcmVjaXNpb25Nb2RlbD10fWFkZFB0KHQpe2NvbnN0IGU9bmV3IG0odCk7aWYodGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoZSksdGhpcy5pc1JlZHVuZGFudChlKSlyZXR1cm4gbnVsbDt0aGlzLl9wdExpc3QuYWRkKGUpfXJldmVyc2UoKXt9YWRkUHRzKHQsZSl7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmFkZFB0KHRbZV0pO2Vsc2UgZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pdGhpcy5hZGRQdCh0W2VdKX1pc1JlZHVuZGFudCh0KXtpZih0aGlzLl9wdExpc3Quc2l6ZSgpPDEpcmV0dXJuITE7Y29uc3QgZT10aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCktMSk7cmV0dXJuIHQuZGlzdGFuY2UoZSk8dGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlfXRvU3RyaW5nKCl7cmV0dXJuKG5ldyBMdCkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpLnRvU3RyaW5nKCl9Y2xvc2VSaW5nKCl7aWYodGhpcy5fcHRMaXN0LnNpemUoKTwxKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IG0odGhpcy5fcHRMaXN0LmdldCgwKSksZT10aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCktMSk7aWYodC5lcXVhbHMoZSkpcmV0dXJuIG51bGw7dGhpcy5fcHRMaXN0LmFkZCh0KX1zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UodCl7dGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlPXR9fWZpLkNPT1JESU5BVEVfQVJSQVlfVFlQRT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKTtjbGFzcyB5aXtjb25zdHJ1Y3Rvcigpe3lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21heEN1cnZlU2VnbWVudEVycm9yPTAsdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtPW51bGwsdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj0xLHRoaXMuX3NlZ0xpc3Q9bnVsbCx0aGlzLl9kaXN0YW5jZT0wLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYnVmUGFyYW1zPW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9zMD1udWxsLHRoaXMuX3MxPW51bGwsdGhpcy5fczI9bnVsbCx0aGlzLl9zZWcwPW5ldyBLdCx0aGlzLl9zZWcxPW5ldyBLdCx0aGlzLl9vZmZzZXQwPW5ldyBLdCx0aGlzLl9vZmZzZXQxPW5ldyBLdCx0aGlzLl9zaWRlPTAsdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fYnVmUGFyYW1zPWUsdGhpcy5fbGk9bmV3IGp0LHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bT1NYXRoLlBJLzIvZS5nZXRRdWFkcmFudFNlZ21lbnRzKCksZS5nZXRRdWFkcmFudFNlZ21lbnRzKCk+PTgmJmUuZ2V0Sm9pblN0eWxlKCk9PT1haS5KT0lOX1JPVU5EJiYodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj15aS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUiksdGhpcy5pbml0KG4pfWFkZE5leHRTZWdtZW50KHQsZSl7aWYodGhpcy5fczA9dGhpcy5fczEsdGhpcy5fczE9dGhpcy5fczIsdGhpcy5fczI9dCx0aGlzLl9zZWcwLnNldENvb3JkaW5hdGVzKHRoaXMuX3MwLHRoaXMuX3MxKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzAsdGhpcy5fc2lkZSx0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQwKSx0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHRoaXMuX3MxLHRoaXMuX3MyKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsdGhpcy5fc2lkZSx0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQxKSx0aGlzLl9zMS5lcXVhbHModGhpcy5fczIpKXJldHVybiBudWxsO2NvbnN0IG49cS5pbmRleCh0aGlzLl9zMCx0aGlzLl9zMSx0aGlzLl9zMikscz1uPT09cS5DTE9DS1dJU0UmJnRoaXMuX3NpZGU9PT1ibi5MRUZUfHxuPT09cS5DT1VOVEVSQ0xPQ0tXSVNFJiZ0aGlzLl9zaWRlPT09Ym4uUklHSFQ7MD09PW4/dGhpcy5hZGRDb2xsaW5lYXIoZSk6cz90aGlzLmFkZE91dHNpZGVUdXJuKG4sZSk6dGhpcy5hZGRJbnNpZGVUdXJuKG4sZSl9YWRkTGluZUVuZENhcCh0LGUpe2NvbnN0IG49bmV3IEt0KHQsZSkscz1uZXcgS3Q7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGJuLkxFRlQsdGhpcy5fZGlzdGFuY2Uscyk7Y29uc3QgaT1uZXcgS3Q7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGJuLlJJR0hULHRoaXMuX2Rpc3RhbmNlLGkpO2NvbnN0IHI9ZS54LXQueCxvPWUueS10LnksbD1NYXRoLmF0YW4yKG8scik7c3dpdGNoKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIGFpLkNBUF9ST1VORDp0aGlzLl9zZWdMaXN0LmFkZFB0KHMucDEpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQoZSxsK01hdGguUEkvMixsLU1hdGguUEkvMixxLkNMT0NLV0lTRSx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5hZGRQdChpLnAxKTticmVhaztjYXNlIGFpLkNBUF9GTEFUOnRoaXMuX3NlZ0xpc3QuYWRkUHQocy5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdChpLnAxKTticmVhaztjYXNlIGFpLkNBUF9TUVVBUkU6Y29uc3QgdD1uZXcgbTt0Lng9TWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKk1hdGguY29zKGwpLHQueT1NYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkqTWF0aC5zaW4obCk7Y29uc3Qgbj1uZXcgbShzLnAxLngrdC54LHMucDEueSt0LnkpLHI9bmV3IG0oaS5wMS54K3QueCxpLnAxLnkrdC55KTt0aGlzLl9zZWdMaXN0LmFkZFB0KG4pLHRoaXMuX3NlZ0xpc3QuYWRkUHQocil9fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3NlZ0xpc3QuZ2V0Q29vcmRpbmF0ZXMoKX1hZGRNaXRyZUpvaW4odCxlLG4scyl7Y29uc3QgaT1CLmludGVyc2VjdGlvbihlLnAwLGUucDEsbi5wMCxuLnAxKTtpZihudWxsIT09aSl7aWYoKHM8PTA/MTppLmRpc3RhbmNlKHQpL01hdGguYWJzKHMpKTw9dGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSlyZXR1cm4gdGhpcy5fc2VnTGlzdC5hZGRQdChpKSxudWxsfXRoaXMuYWRkTGltaXRlZE1pdHJlSm9pbihlLG4scyx0aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKX1hZGRPdXRzaWRlVHVybih0LGUpe2lmKHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCk8dGhpcy5fZGlzdGFuY2UqeWkuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1IpcmV0dXJuIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksbnVsbDt0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1haS5KT0lOX01JVFJFP3RoaXMuYWRkTWl0cmVKb2luKHRoaXMuX3MxLHRoaXMuX29mZnNldDAsdGhpcy5fb2Zmc2V0MSx0aGlzLl9kaXN0YW5jZSk6dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09YWkuSk9JTl9CRVZFTD90aGlzLmFkZEJldmVsSm9pbih0aGlzLl9vZmZzZXQwLHRoaXMuX29mZnNldDEpOihlJiZ0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuYWRkQ29ybmVyRmlsbGV0KHRoaXMuX3MxLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx0LHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApKX1jcmVhdGVTcXVhcmUodCl7dGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngrdGhpcy5fZGlzdGFuY2UsdC55K3RoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngrdGhpcy5fZGlzdGFuY2UsdC55LXRoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngtdGhpcy5fZGlzdGFuY2UsdC55LXRoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngtdGhpcy5fZGlzdGFuY2UsdC55K3RoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1hZGRTZWdtZW50cyh0LGUpe3RoaXMuX3NlZ0xpc3QuYWRkUHRzKHQsZSl9YWRkRmlyc3RTZWdtZW50KCl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKX1hZGRDb3JuZXJGaWxsZXQodCxlLG4scyxpKXtjb25zdCByPWUueC10Lngsbz1lLnktdC55O2xldCBsPU1hdGguYXRhbjIobyxyKTtjb25zdCBhPW4ueC10LngsYz1uLnktdC55LGg9TWF0aC5hdGFuMihjLGEpO3M9PT1xLkNMT0NLV0lTRT9sPD1oJiYobCs9MipNYXRoLlBJKTpsPj1oJiYobC09MipNYXRoLlBJKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQodCxsLGgscyxpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG4pfWFkZExhc3RTZWdtZW50KCl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAxKX1pbml0U2lkZVNlZ21lbnRzKHQsZSxuKXt0aGlzLl9zMT10LHRoaXMuX3MyPWUsdGhpcy5fc2lkZT1uLHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModCxlKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsbix0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQxKX1hZGRMaW1pdGVkTWl0cmVKb2luKHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5fc2VnMC5wMSxyPSR0LmFuZ2xlKGksdGhpcy5fc2VnMC5wMCksbz0kdC5hbmdsZUJldHdlZW5PcmllbnRlZCh0aGlzLl9zZWcwLnAwLGksdGhpcy5fc2VnMS5wMSkvMixsPSR0Lm5vcm1hbGl6ZShyK28pLGE9JHQubm9ybWFsaXplKGwrTWF0aC5QSSksYz1zKm4saD1uLWMqTWF0aC5hYnMoTWF0aC5zaW4obykpLHU9aS54K2MqTWF0aC5jb3MoYSksZz1pLnkrYypNYXRoLnNpbihhKSxkPW5ldyBtKHUsZyksXz1uZXcgS3QoaSxkKSxwPV8ucG9pbnRBbG9uZ09mZnNldCgxLGgpLGY9Xy5wb2ludEFsb25nT2Zmc2V0KDEsLWgpO3RoaXMuX3NpZGU9PT1ibi5MRUZUPyh0aGlzLl9zZWdMaXN0LmFkZFB0KHApLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZikpOih0aGlzLl9zZWdMaXN0LmFkZFB0KGYpLHRoaXMuX3NlZ0xpc3QuYWRkUHQocCkpfWFkZERpcmVjdGVkRmlsbGV0KHQsZSxuLHMsaSl7Y29uc3Qgcj1zPT09cS5DTE9DS1dJU0U/LTE6MSxvPU1hdGguYWJzKGUtbiksbD1NYXRoLnRydW5jKG8vdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtKy41KTtpZihsPDEpcmV0dXJuIG51bGw7Y29uc3QgYT1vL2wsYz1uZXcgbTtmb3IobGV0IG49MDtuPGw7bisrKXtjb25zdCBzPWUrcipuKmE7Yy54PXQueCtpKk1hdGguY29zKHMpLGMueT10LnkraSpNYXRoLnNpbihzKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGMpfX1jb21wdXRlT2Zmc2V0U2VnbWVudCh0LGUsbixzKXtjb25zdCBpPWU9PT1ibi5MRUZUPzE6LTEscj10LnAxLngtdC5wMC54LG89dC5wMS55LXQucDAueSxsPU1hdGguc3FydChyKnIrbypvKSxhPWkqbipyL2wsYz1pKm4qby9sO3MucDAueD10LnAwLngtYyxzLnAwLnk9dC5wMC55K2Escy5wMS54PXQucDEueC1jLHMucDEueT10LnAxLnkrYX1hZGRJbnNpZGVUdXJuKHQsZSl7aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9vZmZzZXQwLnAwLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx0aGlzLl9vZmZzZXQxLnAxKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSl0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKSk7ZWxzZSBpZih0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITAsdGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKTx0aGlzLl9kaXN0YW5jZSp5aS5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtlbHNle2lmKHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj4wKXtjb25zdCB0PW5ldyBtKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDAucDEueCt0aGlzLl9zMS54KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQwLnAxLnkrdGhpcy5fczEueSkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQodCk7Y29uc3QgZT1uZXcgbSgodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQxLnAwLngrdGhpcy5fczEueCkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MS5wMC55K3RoaXMuX3MxLnkpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLl9zZWdMaXN0LmFkZFB0KGUpfWVsc2UgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9zMSk7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKX19Y3JlYXRlQ2lyY2xlKHQpe2NvbnN0IGU9bmV3IG0odC54K3RoaXMuX2Rpc3RhbmNlLHQueSk7dGhpcy5fc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KHQsMCwyKk1hdGguUEksLTEsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9YWRkQmV2ZWxKb2luKHQsZSl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0LnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGUucDApfWluaXQodCl7dGhpcy5fZGlzdGFuY2U9dCx0aGlzLl9tYXhDdXJ2ZVNlZ21lbnRFcnJvcj10KigxLU1hdGguY29zKHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bS8yKSksdGhpcy5fc2VnTGlzdD1uZXcgZmksdGhpcy5fc2VnTGlzdC5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9wcmVjaXNpb25Nb2RlbCksdGhpcy5fc2VnTGlzdC5zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UodCp5aS5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpfWFkZENvbGxpbmVhcih0KXt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX3MwLHRoaXMuX3MxLHRoaXMuX3MxLHRoaXMuX3MyKTt0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKT49MiYmKHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWFpLkpPSU5fQkVWRUx8fHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWFpLkpPSU5fTUlUUkU/KHQmJnRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKSk6dGhpcy5hZGRDb3JuZXJGaWxsZXQodGhpcy5fczEsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHEuQ0xPQ0tXSVNFLHRoaXMuX2Rpc3RhbmNlKSl9Y2xvc2VSaW5nKCl7dGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1oYXNOYXJyb3dDb25jYXZlQW5nbGUoKXtyZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlfX15aS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj0uMDAxLHlpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0uMDAxLHlpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0xZS02LHlpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SPTgwO2NsYXNzIHhpe2NvbnN0cnVjdG9yKCl7eGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZGlzdGFuY2U9MCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2J1ZlBhcmFtcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fYnVmUGFyYW1zPWV9c3RhdGljIGNvcHlDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPW5ldyBtKHRbbl0pO3JldHVybiBlfWdldE9mZnNldEN1cnZlKHQsZSl7aWYodGhpcy5fZGlzdGFuY2U9ZSwwPT09ZSlyZXR1cm4gbnVsbDtjb25zdCBuPWU8MCxzPU1hdGguYWJzKGUpLGk9dGhpcy5nZXRTZWdHZW4ocyk7dC5sZW5ndGg8PTE/dGhpcy5jb21wdXRlUG9pbnRDdXJ2ZSh0WzBdLGkpOnRoaXMuY29tcHV0ZU9mZnNldEN1cnZlKHQsbixpKTtjb25zdCByPWkuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gbiYmX3QucmV2ZXJzZShyKSxyfWNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe24uYWRkU2VnbWVudHModCwhMCk7Y29uc3QgZT1taS5zaW1wbGlmeSh0LC1zKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbaV0sZVtpLTFdLGJuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PWktMjt0Pj0wO3QtLSluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTtjb25zdCBlPW1pLnNpbXBsaWZ5KHQscyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlWzBdLGVbMV0sYm4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfW4uYWRkTGFzdFNlZ21lbnQoKSxuLmNsb3NlUmluZygpfWNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLG4pe2xldCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2U9PT1ibi5SSUdIVCYmKHM9LXMpO2NvbnN0IGk9bWkuc2ltcGxpZnkodCxzKSxyPWkubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGlbci0xXSxpWzBdLGUpO2ZvcihsZXQgdD0xO3Q8PXI7dCsrKXtjb25zdCBlPTEhPT10O24uYWRkTmV4dFNlZ21lbnQoaVt0XSxlKX1uLmNsb3NlUmluZygpfWNvbXB1dGVMaW5lQnVmZmVyQ3VydmUodCxlKXtjb25zdCBuPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpLHM9bWkuc2ltcGxpZnkodCxuKSxpPXMubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKHNbMF0sc1sxXSxibi5MRUZUKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyllLmFkZE5leHRTZWdtZW50KHNbdF0sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAoc1tpLTFdLHNbaV0pO2NvbnN0IHI9bWkuc2ltcGxpZnkodCwtbiksbz1yLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhyW29dLHJbby0xXSxibi5MRUZUKTtmb3IobGV0IHQ9by0yO3Q+PTA7dC0tKWUuYWRkTmV4dFNlZ21lbnQoclt0XSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChyWzFdLHJbMF0pLGUuY2xvc2VSaW5nKCl9Y29tcHV0ZVBvaW50Q3VydmUodCxlKXtzd2l0Y2godGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgYWkuQ0FQX1JPVU5EOmUuY3JlYXRlQ2lyY2xlKHQpO2JyZWFrO2Nhc2UgYWkuQ0FQX1NRVUFSRTplLmNyZWF0ZVNxdWFyZSh0KX19Z2V0TGluZUN1cnZlKHQsZSl7aWYodGhpcy5fZGlzdGFuY2U9ZSx0aGlzLmlzTGluZU9mZnNldEVtcHR5KGUpKXJldHVybiBudWxsO2NvbnN0IG49TWF0aC5hYnMoZSkscz10aGlzLmdldFNlZ0dlbihuKTtpZih0Lmxlbmd0aDw9MSl0aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0scyk7ZWxzZSBpZih0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXtjb25zdCBuPWU8MDt0aGlzLmNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsbixzKX1lbHNlIHRoaXMuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LHMpO3JldHVybiBzLmdldENvb3JkaW5hdGVzKCl9Z2V0QnVmZmVyUGFyYW1ldGVycygpe3JldHVybiB0aGlzLl9idWZQYXJhbXN9c2ltcGxpZnlUb2xlcmFuY2UodCl7cmV0dXJuIHQqdGhpcy5fYnVmUGFyYW1zLmdldFNpbXBsaWZ5RmFjdG9yKCl9Z2V0UmluZ0N1cnZlKHQsZSxuKXtpZih0aGlzLl9kaXN0YW5jZT1uLHQubGVuZ3RoPD0yKXJldHVybiB0aGlzLmdldExpbmVDdXJ2ZSh0LG4pO2lmKDA9PT1uKXJldHVybiB4aS5jb3B5Q29vcmRpbmF0ZXModCk7Y29uc3Qgcz10aGlzLmdldFNlZ0dlbihuKTtyZXR1cm4gdGhpcy5jb21wdXRlUmluZ0J1ZmZlckN1cnZlKHQsZSxzKSxzLmdldENvb3JkaW5hdGVzKCl9Y29tcHV0ZU9mZnNldEN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe2NvbnN0IGU9bWkuc2ltcGxpZnkodCwtcyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlW2ldLGVbaS0xXSxibi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD1pLTI7dD49MDt0LS0pbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1lbHNle2NvbnN0IGU9bWkuc2ltcGxpZnkodCxzKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbMF0sZVsxXSxibi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpfWlzTGluZU9mZnNldEVtcHR5KHQpe3JldHVybiAwPT09dHx8dDwwJiYhdGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKX1nZXRTZWdHZW4odCl7cmV0dXJuIG5ldyB5aSh0aGlzLl9wcmVjaXNpb25Nb2RlbCx0aGlzLl9idWZQYXJhbXMsdCl9fWNsYXNzIEVpe2NvbnN0cnVjdG9yKCl7RWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3ViZ3JhcGhzPW51bGwsdGhpcy5fc2VnPW5ldyBLdDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJncmFwaHM9dH1maW5kU3RhYmJlZFNlZ21lbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7Zm9yKGxldCBuPXRoaXMuX3N1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0RW52ZWxvcGUoKTt0Lnk8aS5nZXRNaW5ZKCl8fHQueT5pLmdldE1heFkoKXx8dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQscy5nZXREaXJlY3RlZEVkZ2VzKCksZSl9cmV0dXJuIGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoSShhcmd1bWVudHNbMl0sQykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBycyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgaT0wO2k8cy5sZW5ndGgtMTtpKyspe3RoaXMuX3NlZy5wMD1zW2ldLHRoaXMuX3NlZy5wMT1zW2krMV0sdGhpcy5fc2VnLnAwLnk+dGhpcy5fc2VnLnAxLnkmJnRoaXMuX3NlZy5yZXZlcnNlKCk7aWYoTWF0aC5tYXgodGhpcy5fc2VnLnAwLngsdGhpcy5fc2VnLnAxLngpPHQueCljb250aW51ZTtpZih0aGlzLl9zZWcuaXNIb3Jpem9udGFsKCkpY29udGludWU7aWYodC55PHRoaXMuX3NlZy5wMC55fHx0Lnk+dGhpcy5fc2VnLnAxLnkpY29udGludWU7aWYocS5pbmRleCh0aGlzLl9zZWcucDAsdGhpcy5fc2VnLnAxLHQpPT09cS5SSUdIVCljb250aW51ZTtsZXQgcj1lLmdldERlcHRoKGJuLkxFRlQpO3RoaXMuX3NlZy5wMC5lcXVhbHMoc1tpXSl8fChyPWUuZ2V0RGVwdGgoYm4uUklHSFQpKTtjb25zdCBvPW5ldyBJaSh0aGlzLl9zZWcscik7bi5hZGQobyl9fWVsc2UgaWYoSShhcmd1bWVudHNbMl0sQykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmSShhcmd1bWVudHNbMV0sQykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdO2ZvcihsZXQgbj1hcmd1bWVudHNbMV0uaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5pc0ZvcndhcmQoKSYmdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQscyxlKX19fWdldERlcHRoKHQpe2NvbnN0IGU9dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQpO2lmKDA9PT1lLnNpemUoKSlyZXR1cm4gMDtyZXR1cm4geGUubWluKGUpLl9sZWZ0RGVwdGh9fWNsYXNzIElpe2NvbnN0cnVjdG9yKCl7SWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdXB3YXJkU2VnPW51bGwsdGhpcy5fbGVmdERlcHRoPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdXB3YXJkU2VnPW5ldyBLdCh0KSx0aGlzLl9sZWZ0RGVwdGg9ZX1jb21wYXJlVG8odCl7Y29uc3QgZT10O2lmKHRoaXMuX3Vwd2FyZFNlZy5taW5YKCk+PWUuX3Vwd2FyZFNlZy5tYXhYKCkpcmV0dXJuIDE7aWYodGhpcy5fdXB3YXJkU2VnLm1heFgoKTw9ZS5fdXB3YXJkU2VnLm1pblgoKSlyZXR1cm4tMTtsZXQgbj10aGlzLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleChlLl91cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KHRoaXMuX3Vwd2FyZFNlZyksMCE9PW4/bjp0aGlzLl91cHdhcmRTZWcuY29tcGFyZVRvKGUuX3Vwd2FyZFNlZykpfWNvbXBhcmVYKHQsZSl7Y29uc3Qgbj10LnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0LnAxLmNvbXBhcmVUbyhlLnAxKX10b1N0cmluZygpe3JldHVybiB0aGlzLl91cHdhcmRTZWcudG9TdHJpbmcoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fUVpLkRlcHRoU2VnbWVudD1JaTtjbGFzcyBOaXtjb25zdHJ1Y3Rvcigpe05pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5fY3VydmVCdWlsZGVyPW51bGwsdGhpcy5fY3VydmVMaXN0PW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2Rpc3RhbmNlPWUsdGhpcy5fY3VydmVCdWlsZGVyPW59YWRkUmluZ1NpZGUodCxlLG4scyxpKXtpZigwPT09ZSYmdC5sZW5ndGg8Z3QuTUlOSU1VTV9WQUxJRF9TSVpFKXJldHVybiBudWxsO2xldCByPXMsbz1pO3QubGVuZ3RoPj1ndC5NSU5JTVVNX1ZBTElEX1NJWkUmJnEuaXNDQ1codCkmJihyPWksbz1zLG49Ym4ub3Bwb3NpdGUobikpO2NvbnN0IGw9dGhpcy5fY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZSh0LG4sZSk7dGhpcy5hZGRDdXJ2ZShsLHIsbyl9YWRkUmluZ0JvdGhTaWRlcyh0LGUpe3RoaXMuYWRkUmluZ1NpZGUodCxlLGJuLkxFRlQsUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpLHRoaXMuYWRkUmluZ1NpZGUodCxlLGJuLlJJR0hULFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SKX1hZGRQb2ludCh0KXtpZih0aGlzLl9kaXN0YW5jZTw9MClyZXR1cm4gbnVsbDtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPXRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLl9kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKX1hZGRQb2x5Z29uKHQpe2xldCBlPXRoaXMuX2Rpc3RhbmNlLG49Ym4uTEVGVDt0aGlzLl9kaXN0YW5jZTwwJiYoZT0tdGhpcy5fZGlzdGFuY2Usbj1ibi5SSUdIVCk7Y29uc3Qgcz10LmdldEV4dGVyaW9yUmluZygpLGk9X3QucmVtb3ZlUmVwZWF0ZWRQb2ludHMocy5nZXRDb29yZGluYXRlcygpKTtpZih0aGlzLl9kaXN0YW5jZTwwJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShzLHRoaXMuX2Rpc3RhbmNlKSlyZXR1cm4gbnVsbDtpZih0aGlzLl9kaXN0YW5jZTw9MCYmaS5sZW5ndGg8MylyZXR1cm4gbnVsbDt0aGlzLmFkZFJpbmdTaWRlKGksZSxuLFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKTtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXtjb25zdCBpPXQuZ2V0SW50ZXJpb3JSaW5nTihzKSxyPV90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fZGlzdGFuY2U+MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkoaSwtdGhpcy5fZGlzdGFuY2UpfHx0aGlzLmFkZFJpbmdTaWRlKHIsZSxibi5vcHBvc2l0ZShuKSxRdC5JTlRFUklPUixRdC5FWFRFUklPUil9fWlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KHQsZSl7Y29uc3Qgbj1uZXcgbmUodFswXSx0WzFdLHRbMl0pLHM9bi5pbkNlbnRyZSgpO3JldHVybiB6LnBvaW50VG9TZWdtZW50KHMsbi5wMCxuLnAxKTxNYXRoLmFicyhlKX1hZGRMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2N1cnZlQnVpbGRlci5pc0xpbmVPZmZzZXRFbXB0eSh0aGlzLl9kaXN0YW5jZSkpcmV0dXJuIG51bGw7Y29uc3QgZT1fdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKF90LmlzUmluZyhlKSYmIXRoaXMuX2N1cnZlQnVpbGRlci5nZXRCdWZmZXJQYXJhbWV0ZXJzKCkuaXNTaW5nbGVTaWRlZCgpKXRoaXMuYWRkUmluZ0JvdGhTaWRlcyhlLHRoaXMuX2Rpc3RhbmNlKTtlbHNle2NvbnN0IHQ9dGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuX2Rpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKHQsUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpfX1hZGRDdXJ2ZSh0LGUsbil7aWYobnVsbD09PXR8fHQubGVuZ3RoPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz1uZXcgWnModCxuZXcgQm4oMCxRdC5CT1VOREFSWSxlLG4pKTt0aGlzLl9jdXJ2ZUxpc3QuYWRkKHMpfWdldEN1cnZlcygpe3JldHVybiB0aGlzLmFkZCh0aGlzLl9pbnB1dEdlb20pLHRoaXMuX2N1cnZlTGlzdH1hZGQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIHJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiAkKXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBldCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHV0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgeXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgaHQpKXRocm93IG5ldyBLKHQuZ2V0R2VvbWV0cnlUeXBlKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19aXNFcm9kZWRDb21wbGV0ZWx5KHQsZSl7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCk7aWYobi5sZW5ndGg8NClyZXR1cm4gZTwwO2lmKDQ9PT1uLmxlbmd0aClyZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShuLGUpO2NvbnN0IHM9dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1NYXRoLm1pbihzLmdldEhlaWdodCgpLHMuZ2V0V2lkdGgoKSk7cmV0dXJuIGU8MCYmMipNYXRoLmFicyhlKT5pfWFkZENvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fX1jbGFzcyB3aXtjb25zdHJ1Y3Rvcigpe3dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2VkZ2VNYXA9bmV3IFduLHRoaXMuX2VkZ2VMaXN0PW51bGwsdGhpcy5fcHRJbkFyZWFMb2NhdGlvbj1bUXQuTk9ORSxRdC5OT05FXX1nZXROZXh0Q1codCl7dGhpcy5nZXRFZGdlcygpO2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuaW5kZXhPZih0KTtsZXQgbj1lLTE7cmV0dXJuIDA9PT1lJiYobj10aGlzLl9lZGdlTGlzdC5zaXplKCktMSksdGhpcy5fZWRnZUxpc3QuZ2V0KG4pfXByb3BhZ2F0ZVNpZGVMYWJlbHModCl7bGV0IGU9UXQuTk9ORTtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKS5nZXRMYWJlbCgpO3MuaXNBcmVhKHQpJiZzLmdldExvY2F0aW9uKHQsYm4uTEVGVCkhPT1RdC5OT05FJiYoZT1zLmdldExvY2F0aW9uKHQsYm4uTEVGVCkpfWlmKGU9PT1RdC5OT05FKXJldHVybiBudWxsO2xldCBuPWU7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT1zLmdldExhYmVsKCk7aWYoaS5nZXRMb2NhdGlvbih0LGJuLk9OKT09PVF0Lk5PTkUmJmkuc2V0TG9jYXRpb24odCxibi5PTixuKSxpLmlzQXJlYSh0KSl7Y29uc3QgZT1pLmdldExvY2F0aW9uKHQsYm4uTEVGVCkscj1pLmdldExvY2F0aW9uKHQsYm4uUklHSFQpO2lmKHIhPT1RdC5OT05FKXtpZihyIT09bil0aHJvdyBuZXcgaXMoXCJzaWRlIGxvY2F0aW9uIGNvbmZsaWN0XCIscy5nZXRDb29yZGluYXRlKCkpO2U9PT1RdC5OT05FJiZnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZSAoYXQgXCIrcy5nZXRDb29yZGluYXRlKCkrXCIpXCIpLG49ZX1lbHNlIGcuaXNUcnVlKGkuZ2V0TG9jYXRpb24odCxibi5MRUZUKT09PVF0Lk5PTkUsXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlXCIpLGkuc2V0TG9jYXRpb24odCxibi5SSUdIVCxuKSxpLnNldExvY2F0aW9uKHQsYm4uTEVGVCxuKX19fWdldENvb3JkaW5hdGUoKXtjb25zdCB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7cmV0dXJuIHQubmV4dCgpLmdldENvb3JkaW5hdGUoKX1wcmludCh0KXtZLm91dC5wcmludGxuKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0KXtyZXR1cm4gdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0LmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KDApfWNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQodCl7Y29uc3QgZT10aGlzLmdldEVkZ2VzKCk7aWYoZS5zaXplKCk8PTApcmV0dXJuITA7Y29uc3Qgbj1lLnNpemUoKS0xLHM9ZS5nZXQobikuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGJuLkxFRlQpO2cuaXNUcnVlKHMhPT1RdC5OT05FLFwiRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2VcIik7bGV0IGk9cztmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRMYWJlbCgpO2cuaXNUcnVlKG4uaXNBcmVhKHQpLFwiRm91bmQgbm9uLWFyZWEgZWRnZVwiKTtjb25zdCBzPW4uZ2V0TG9jYXRpb24odCxibi5MRUZUKSxyPW4uZ2V0TG9jYXRpb24odCxibi5SSUdIVCk7aWYocz09PXIpcmV0dXJuITE7aWYociE9PWkpcmV0dXJuITE7aT1zfXJldHVybiEwfWZpbmRJbmRleCh0KXt0aGlzLml0ZXJhdG9yKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlTGlzdC5zaXplKCk7ZSsrKXtpZih0aGlzLl9lZGdlTGlzdC5nZXQoZSk9PT10KXJldHVybiBlfXJldHVybi0xfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoKS5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lZGdlTGlzdCYmKHRoaXMuX2VkZ2VMaXN0PW5ldyBMKHRoaXMuX2VkZ2VNYXAudmFsdWVzKCkpKSx0aGlzLl9lZGdlTGlzdH1nZXRMb2NhdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF09PT1RdC5OT05FJiYodGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XT1aZS5sb2NhdGUoZSxuW3RdLmdldEdlb21ldHJ5KCkpKSx0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdjt0LmFwcGVuZChcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKSx0LmFwcGVuZChcIlxcblwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0LmFwcGVuZChuKSx0LmFwcGVuZChcIlxcblwiKX1yZXR1cm4gdC50b1N0cmluZygpfWNvbXB1dGVFZGdlRW5kTGFiZWxzKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5jb21wdXRlTGFiZWwodCl9fWNvbXB1dGVMYWJlbGxpbmcodCl7dGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0WzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtjb25zdCBlPVshMSwhMV07Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkuZ2V0TGFiZWwoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKW4uaXNMaW5lKHQpJiZuLmdldExvY2F0aW9uKHQpPT09UXQuQk9VTkRBUlkmJihlW3RdPSEwKX1mb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtmb3IobGV0IG49MDtuPDI7bisrKWlmKGkuaXNBbnlOdWxsKG4pKXtsZXQgcj1RdC5OT05FO2lmKGVbbl0pcj1RdC5FWFRFUklPUjtlbHNle2NvbnN0IGU9cy5nZXRDb29yZGluYXRlKCk7cj10aGlzLmdldExvY2F0aW9uKG4sZSx0KX1pLnNldEFsbExvY2F0aW9uc0lmTnVsbChuLHIpfX19Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2VkZ2VNYXAuc2l6ZSgpfWluc2VydEVkZ2VFbmQodCxlKXt0aGlzLl9lZGdlTWFwLnB1dCh0LGUpLHRoaXMuX2VkZ2VMaXN0PW51bGx9fWxldCBDaT1jbGFzcyBleHRlbmRzIHdpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxDaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q9bnVsbCx0aGlzLl9sYWJlbD1udWxsLHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORz0xLHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc9Mn1saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpe3RoaXMuZ2V0UmVzdWx0QXJlYUVkZ2VzKCk7bGV0IHQ9bnVsbCxlPW51bGwsbj10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7Zm9yKGxldCBzPTA7czx0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpO3MrKyl7Y29uc3QgaT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KHMpLHI9aS5nZXRTeW0oKTtpZihpLmdldExhYmVsKCkuaXNBcmVhKCkpc3dpdGNoKG51bGw9PT10JiZpLmlzSW5SZXN1bHQoKSYmKHQ9aSksbil7Y2FzZSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoIXIuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2U9cixuPXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HOmlmKCFpLmlzSW5SZXN1bHQoKSljb250aW51ZTtlLnNldE5leHQoaSksbj10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkd9fWlmKG49PT10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HKXtpZihudWxsPT09dCl0aHJvdyBuZXcgaXMoXCJubyBvdXRnb2luZyBkaXJFZGdlIGZvdW5kXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO2cuaXNUcnVlKHQuaXNJblJlc3VsdCgpLFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLGUuc2V0TmV4dCh0KX19aW5zZXJ0KHQpe2NvbnN0IGU9dDt0aGlzLmluc2VydEVkZ2VFbmQoZSxlKX1nZXRSaWdodG1vc3RFZGdlKCl7Y29uc3QgdD10aGlzLmdldEVkZ2VzKCksZT10LnNpemUoKTtpZihlPDEpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldCgwKTtpZigxPT09ZSlyZXR1cm4gbjtjb25zdCBzPXQuZ2V0KGUtMSksaT1uLmdldFF1YWRyYW50KCkscj1zLmdldFF1YWRyYW50KCk7cmV0dXJuIENuLmlzTm9ydGhlcm4oaSkmJkNuLmlzTm9ydGhlcm4ocik/bjpDbi5pc05vcnRoZXJuKGkpfHxDbi5pc05vcnRoZXJuKHIpPzAhPT1uLmdldER5KCk/bjowIT09cy5nZXREeSgpP3M6KGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCB0d28gaG9yaXpvbnRhbCBlZGdlcyBpbmNpZGVudCBvbiBub2RlXCIpLG51bGwpOnN9cHJpbnQodCl7WS5vdXQucHJpbnRsbihcIkRpcmVjdGVkRWRnZVN0YXI6IFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0LnByaW50KFwib3V0IFwiKSxuLnByaW50KHQpLHQucHJpbnRsbigpLHQucHJpbnQoXCJpbiBcIiksbi5nZXRTeW0oKS5wcmludCh0KSx0LnByaW50bG4oKX19Z2V0UmVzdWx0QXJlYUVkZ2VzKCl7aWYobnVsbCE9PXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdClyZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0O3RoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdD1uZXcgTDtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTsoZS5pc0luUmVzdWx0KCl8fGUuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKSYmdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmFkZChlKX1yZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0fXVwZGF0ZUxhYmVsbGluZyh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRMYWJlbCgpO24uc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdC5nZXRMb2NhdGlvbigwKSksbi5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0LmdldExvY2F0aW9uKDEpKX19bGlua0FsbERpcmVjdGVkRWRnZXMoKXt0aGlzLmdldEVkZ2VzKCk7bGV0IHQ9bnVsbCxlPW51bGw7Zm9yKGxldCBuPXRoaXMuX2VkZ2VMaXN0LnNpemUoKS0xO24+PTA7bi0tKXtjb25zdCBzPXRoaXMuX2VkZ2VMaXN0LmdldChuKSxpPXMuZ2V0U3ltKCk7bnVsbD09PWUmJihlPWkpLG51bGwhPT10JiZpLnNldE5leHQodCksdD1zfWUuc2V0TmV4dCh0KX1jb21wdXRlRGVwdGhzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5maW5kSW5kZXgodCksbj10LmdldERlcHRoKGJuLkxFRlQpLHM9dC5nZXREZXB0aChibi5SSUdIVCksaT10aGlzLmNvbXB1dGVEZXB0aHMoZSsxLHRoaXMuX2VkZ2VMaXN0LnNpemUoKSxuKTtpZih0aGlzLmNvbXB1dGVEZXB0aHMoMCxlLGkpIT09cyl0aHJvdyBuZXcgaXMoXCJkZXB0aCBtaXNtYXRjaCBhdCBcIit0LmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07bGV0IGU9YXJndW1lbnRzWzJdO2ZvcihsZXQgbj1hcmd1bWVudHNbMF07bjx0O24rKyl7Y29uc3QgdD10aGlzLl9lZGdlTGlzdC5nZXQobik7dC5zZXRFZGdlRGVwdGhzKGJuLlJJR0hULGUpLGU9dC5nZXREZXB0aChibi5MRUZUKX1yZXR1cm4gZX19bWVyZ2VTeW1MYWJlbHMoKXtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmdldExhYmVsKCkubWVyZ2UoZS5nZXRTeW0oKS5nZXRMYWJlbCgpKX19bGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHQpe2xldCBlPW51bGwsbj1udWxsLHM9dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO2ZvcihsZXQgaT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpLTE7aT49MDtpLS0pe2NvbnN0IHI9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKSxvPXIuZ2V0U3ltKCk7c3dpdGNoKG51bGw9PT1lJiZyLmdldEVkZ2VSaW5nKCk9PT10JiYoZT1yKSxzKXtjYXNlIHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORzppZihvLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO249byxzPXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HOmlmKHIuZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bi5zZXROZXh0TWluKHIpLHM9dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1zPT09dGhpcy5fTElOS0lOR19UT19PVVRHT0lORyYmKGcuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBmb3IgZmlyc3Qgb3V0Z29pbmcgZGlyRWRnZVwiKSxnLmlzVHJ1ZShlLmdldEVkZ2VSaW5nKCk9PT10LFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLG4uc2V0TmV4dE1pbihlKSl9Z2V0T3V0Z29pbmdEZWdyZWUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuaXNJblJlc3VsdCgpJiZ0Kyt9cmV0dXJuIHR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmdldEVkZ2VSaW5nKCk9PT10JiZlKyt9cmV0dXJuIGV9fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl7bGV0IHQ9UXQuTk9ORTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0U3ltKCk7aWYoIW4uaXNMaW5lRWRnZSgpKXtpZihuLmlzSW5SZXN1bHQoKSl7dD1RdC5JTlRFUklPUjticmVha31pZihzLmlzSW5SZXN1bHQoKSl7dD1RdC5FWFRFUklPUjticmVha319fWlmKHQ9PT1RdC5OT05FKXJldHVybiBudWxsO2xldCBlPXQ7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldFN5bSgpO24uaXNMaW5lRWRnZSgpP24uZ2V0RWRnZSgpLnNldENvdmVyZWQoZT09PVF0LklOVEVSSU9SKToobi5pc0luUmVzdWx0KCkmJihlPVF0LkVYVEVSSU9SKSxzLmlzSW5SZXN1bHQoKSYmKGU9UXQuSU5URVJJT1IpKX19Y29tcHV0ZUxhYmVsbGluZyh0KXtzdXBlci5jb21wdXRlTGFiZWxsaW5nLmNhbGwodGhpcyx0KSx0aGlzLl9sYWJlbD1uZXcgQm4oUXQuTk9ORSk7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCkuZ2V0RWRnZSgpLmdldExhYmVsKCk7Zm9yKGxldCB0PTA7dDwyO3QrKyl7Y29uc3Qgbj1lLmdldExvY2F0aW9uKHQpO24hPT1RdC5JTlRFUklPUiYmbiE9PVF0LkJPVU5EQVJZfHx0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LFF0LklOVEVSSU9SKX19fX07Y2xhc3MgU2kgZXh0ZW5kcyBvc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IGVzKHQsbmV3IENpKX19Y2xhc3MgTGl7Y29uc3RydWN0b3IoKXtMaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9vcmllbnRhdGlvbj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10LHRoaXMuX29yaWVudGF0aW9uPUxpLm9yaWVudGF0aW9uKHQpfXN0YXRpYyBvcmllbnRhdGlvbih0KXtyZXR1cm4gMT09PV90LmluY3JlYXNpbmdEaXJlY3Rpb24odCl9c3RhdGljIGNvbXBhcmVPcmllbnRlZCh0LGUsbixzKXtjb25zdCBpPWU/MTotMSxyPXM/MTotMSxvPWU/dC5sZW5ndGg6LTEsbD1zP24ubGVuZ3RoOi0xO2xldCBhPWU/MDp0Lmxlbmd0aC0xLGM9cz8wOm4ubGVuZ3RoLTE7Zm9yKDs7KXtjb25zdCBlPXRbYV0uY29tcGFyZVRvKG5bY10pO2lmKDAhPT1lKXJldHVybiBlO2ErPWksYys9cjtjb25zdCBzPWE9PT1vLGg9Yz09PWw7aWYocyYmIWgpcmV0dXJuLTE7aWYoIXMmJmgpcmV0dXJuIDE7aWYocyYmaClyZXR1cm4gMH19Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gTGkuY29tcGFyZU9yaWVudGVkKHRoaXMuX3B0cyx0aGlzLl9vcmllbnRhdGlvbixlLl9wdHMsZS5fb3JpZW50YXRpb24pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgVGl7Y29uc3RydWN0b3IoKXtUaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lZGdlcz1uZXcgTCx0aGlzLl9vY2FNYXA9bmV3IFdufXByaW50KHQpe3QucHJpbnQoXCJNVUxUSUxJTkVTVFJJTkcgKCBcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlcy5zaXplKCk7ZSsrKXtjb25zdCBuPXRoaXMuX2VkZ2VzLmdldChlKTtlPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoXCIoXCIpO2NvbnN0IHM9bi5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludChzW2VdLngrXCIgXCIrc1tlXS55KTt0LnByaW50bG4oXCIpXCIpfXQucHJpbnQoXCIpICBcIil9YWRkQWxsKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKX1maW5kRWRnZUluZGV4KHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKylpZih0aGlzLl9lZGdlcy5nZXQoZSkuZXF1YWxzKHQpKXJldHVybiBlO3JldHVybi0xfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9Z2V0KHQpe3JldHVybiB0aGlzLl9lZGdlcy5nZXQodCl9ZmluZEVxdWFsRWRnZSh0KXtjb25zdCBlPW5ldyBMaSh0LmdldENvb3JkaW5hdGVzKCkpO3JldHVybiB0aGlzLl9vY2FNYXAuZ2V0KGUpfWFkZCh0KXt0aGlzLl9lZGdlcy5hZGQodCk7Y29uc3QgZT1uZXcgTGkodC5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9vY2FNYXAucHV0KGUsdCl9fWNsYXNzIFJpe3Byb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe31pc0RvbmUoKXt9fWNsYXNzIFBpe2NvbnN0cnVjdG9yKCl7UGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX2hhc1Byb3Blcj0hMSx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLl9oYXNJbnRlcmlvcj0hMSx0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dH1zdGF0aWMgaXNBZGphY2VudFNlZ21lbnRzKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfWlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXtpZih0PT09biYmMT09PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihQaS5pc0FkamFjZW50U2VnbWVudHMoZSxzKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe2NvbnN0IG49dC5zaXplKCktMTtpZigwPT09ZSYmcz09PW58fDA9PT1zJiZlPT09bilyZXR1cm4hMH19cmV0dXJuITF9Z2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKXtyZXR1cm4gdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9aGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3J9Z2V0TGluZUludGVyc2VjdG9yKCl7cmV0dXJuIHRoaXMuX2xpfWhhc1Byb3BlckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJ9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKztjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zKyssdGhpcy5faGFzSW50ZXJpb3I9ITApLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpLHRoaXMuX2xpLmlzUHJvcGVyKCkmJih0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMrKyx0aGlzLl9oYXNQcm9wZXI9ITAsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITApKSl9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hMX1oYXNJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcmlvcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUmldfX1jbGFzcyBPaXtjb25zdHJ1Y3Rvcigpe09pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2J1ZlBhcmFtcz1udWxsLHRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX3dvcmtpbmdOb2Rlcj1udWxsLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9lZGdlTGlzdD1uZXcgVGk7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYnVmUGFyYW1zPXR9c3RhdGljIGRlcHRoRGVsdGEodCl7Y29uc3QgZT10LmdldExvY2F0aW9uKDAsYm4uTEVGVCksbj10LmdldExvY2F0aW9uKDAsYm4uUklHSFQpO3JldHVybiBlPT09UXQuSU5URVJJT1ImJm49PT1RdC5FWFRFUklPUj8xOmU9PT1RdC5FWFRFUklPUiYmbj09PVF0LklOVEVSSU9SPy0xOjB9c3RhdGljIGNvbnZlcnRTZWdTdHJpbmdzKHQpe2NvbnN0IGU9bmV3IEx0LG49bmV3IEw7Zm9yKDt0Lmhhc05leHQoKTspe2NvbnN0IHM9dC5uZXh0KCksaT1lLmNyZWF0ZUxpbmVTdHJpbmcocy5nZXRDb29yZGluYXRlcygpKTtuLmFkZChpKX1yZXR1cm4gZS5idWlsZEdlb21ldHJ5KG4pfXNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw9dH1pbnNlcnRVbmlxdWVFZGdlKHQpe2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7Y29uc3Qgbj1lLmdldExhYmVsKCk7bGV0IHM9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KHM9bmV3IEJuKHQuZ2V0TGFiZWwoKSkscy5mbGlwKCkpLG4ubWVyZ2Uocyk7Y29uc3QgaT1PaS5kZXB0aERlbHRhKHMpLHI9ZS5nZXREZXB0aERlbHRhKCkraTtlLnNldERlcHRoRGVsdGEocil9ZWxzZSB0aGlzLl9lZGdlTGlzdC5hZGQodCksdC5zZXREZXB0aERlbHRhKE9pLmRlcHRoRGVsdGEodC5nZXRMYWJlbCgpKSl9YnVpbGRTdWJncmFwaHModCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9dC5nZXRSaWdodG1vc3RDb29yZGluYXRlKCkscj1uZXcgRWkobikuZ2V0RGVwdGgoaSk7dC5jb21wdXRlRGVwdGgociksdC5maW5kUmVzdWx0RWRnZXMoKSxuLmFkZCh0KSxlLmFkZCh0LmdldERpcmVjdGVkRWRnZXMoKSx0LmdldE5vZGVzKCkpfX1jcmVhdGVTdWJncmFwaHModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5nZXROb2RlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKCF0LmlzVmlzaXRlZCgpKXtjb25zdCBuPW5ldyB1aTtuLmNyZWF0ZSh0KSxlLmFkZChuKX19cmV0dXJuIHhlLnNvcnQoZSx4ZS5yZXZlcnNlT3JkZXIoKSksZX1jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oKX1nZXROb2Rlcih0KXtpZihudWxsIT09dGhpcy5fd29ya2luZ05vZGVyKXJldHVybiB0aGlzLl93b3JraW5nTm9kZXI7Y29uc3QgZT1uZXcgdGksbj1uZXcganQ7cmV0dXJuIG4uc2V0UHJlY2lzaW9uTW9kZWwodCksZS5zZXRTZWdtZW50SW50ZXJzZWN0b3IobmV3IFBpKG4pKSxlfWJ1ZmZlcih0LGUpe2xldCBuPXRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbDtudWxsPT09biYmKG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKTtjb25zdCBzPW5ldyB4aShuLHRoaXMuX2J1ZlBhcmFtcyksaT1uZXcgTmkodCxlLHMpLmdldEN1cnZlcygpO2lmKGkuc2l6ZSgpPD0wKXJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTt0aGlzLmNvbXB1dGVOb2RlZEVkZ2VzKGksbiksdGhpcy5fZ3JhcGg9bmV3IGxzKG5ldyBTaSksdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7Y29uc3Qgcj10aGlzLmNyZWF0ZVN1YmdyYXBocyh0aGlzLl9ncmFwaCksbz1uZXcgcGkodGhpcy5fZ2VvbUZhY3QpO3RoaXMuYnVpbGRTdWJncmFwaHMocixvKTtjb25zdCBsPW8uZ2V0UG9seWdvbnMoKTtpZihsLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkobCl9Y29tcHV0ZU5vZGVkRWRnZXModCxlKXtjb25zdCBuPXRoaXMuZ2V0Tm9kZXIoZSk7bi5jb21wdXRlTm9kZXModCk7Zm9yKGxldCB0PW4uZ2V0Tm9kZWRTdWJzdHJpbmdzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCk7aWYoMj09PW4ubGVuZ3RoJiZuWzBdLmVxdWFsczJEKG5bMV0pKWNvbnRpbnVlO2NvbnN0IHM9ZS5nZXREYXRhKCksaT1uZXcgdHMoZS5nZXRDb29yZGluYXRlcygpLG5ldyBCbihzKSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKGkpfX1zZXROb2Rlcih0KXt0aGlzLl93b3JraW5nTm9kZXI9dH19Y2xhc3Mgdml7Y29uc3RydWN0b3IoKXt2aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fc2VnU3RyaW5ncz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZ1N0cmluZ3M9dH1jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhlWzBdLHRoaXMuX3NlZ1N0cmluZ3MpLHRoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoZVtlLmxlbmd0aC0xXSx0aGlzLl9zZWdTdHJpbmdzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9YXJndW1lbnRzWzFdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTE7ZTxuLmxlbmd0aC0xO2UrKylpZihuW2VdLmVxdWFscyh0KSl0aHJvdyBuZXcgaChcImZvdW5kIGVuZHB0L2ludGVyaW9yIHB0IGludGVyc2VjdGlvbiBhdCBpbmRleCBcIitlK1wiIDpwdCBcIit0KX19fWNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7Zm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7dGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhlLG4pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxzPWUuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGk9MDtpPG4ubGVuZ3RoLTE7aSsrKWZvcihsZXQgbj0wO248cy5sZW5ndGgtMTtuKyspdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGksZSxuKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLl9saS5pc1Byb3BlcigpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLGkscil8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksbyxsKSkpdGhyb3cgbmV3IGgoXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGF0IFwiK2krXCItXCIrcitcIiBhbmQgXCIrbytcIi1cIitsKX19Y2hlY2tWYWxpZCgpe3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0NvbGxhcHNlcygpfWNoZWNrQ29sbGFwc2VzKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5jaGVja0NvbGxhcHNlcyhlKX1lbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspdGhpcy5jaGVja0NvbGxhcHNlKHRbZV0sdFtlKzFdLHRbZSsyXSl9fWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXtjb25zdCBpPXQuZ2V0SW50ZXJzZWN0aW9uKHMpO2lmKCFpLmVxdWFscyhlKSYmIWkuZXF1YWxzKG4pKXJldHVybiEwfXJldHVybiExfWNoZWNrQ29sbGFwc2UodCxlLG4pe2lmKHQuZXF1YWxzKG4pKXRocm93IG5ldyBoKFwiZm91bmQgbm9uLW5vZGVkIGNvbGxhcHNlIGF0IFwiK3ZpLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbdCxlLG5dKSl9fXZpLmZhY3Q9bmV3IEx0O2NsYXNzIGJpe2NvbnN0cnVjdG9yKCl7YmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bnVsbCx0aGlzLl9wdD1udWxsLHRoaXMuX29yaWdpbmFsUHQ9bnVsbCx0aGlzLl9wdFNjYWxlZD1udWxsLHRoaXMuX3AwU2NhbGVkPW51bGwsdGhpcy5fcDFTY2FsZWQ9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX21pbng9bnVsbCx0aGlzLl9tYXh4PW51bGwsdGhpcy5fbWlueT1udWxsLHRoaXMuX21heHk9bnVsbCx0aGlzLl9jb3JuZXI9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5fc2FmZUVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX29yaWdpbmFsUHQ9dCx0aGlzLl9wdD10LHRoaXMuX3NjYWxlRmFjdG9yPWUsdGhpcy5fbGk9bixlPD0wKXRocm93IG5ldyBzKFwiU2NhbGUgZmFjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7MSE9PWUmJih0aGlzLl9wdD1uZXcgbSh0aGlzLnNjYWxlKHQueCksdGhpcy5zY2FsZSh0LnkpKSx0aGlzLl9wMFNjYWxlZD1uZXcgbSx0aGlzLl9wMVNjYWxlZD1uZXcgbSksdGhpcy5pbml0Q29ybmVycyh0aGlzLl9wdCl9aW50ZXJzZWN0c1NjYWxlZCh0LGUpe2NvbnN0IG49TWF0aC5taW4odC54LGUueCkscz1NYXRoLm1heCh0LngsZS54KSxpPU1hdGgubWluKHQueSxlLnkpLHI9TWF0aC5tYXgodC55LGUueSksbz10aGlzLl9tYXh4PG58fHRoaXMuX21pbng+c3x8dGhpcy5fbWF4eTxpfHx0aGlzLl9taW55PnI7aWYobylyZXR1cm4hMTtjb25zdCBsPXRoaXMuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpO3JldHVybiBnLmlzVHJ1ZSghKG8mJmwpLFwiRm91bmQgYmFkIGVudmVsb3BlIHRlc3RcIiksbH1pbml0Q29ybmVycyh0KXtjb25zdCBlPS41O3RoaXMuX21pbng9dC54LWUsdGhpcy5fbWF4eD10LngrZSx0aGlzLl9taW55PXQueS1lLHRoaXMuX21heHk9dC55K2UsdGhpcy5fY29ybmVyWzBdPW5ldyBtKHRoaXMuX21heHgsdGhpcy5fbWF4eSksdGhpcy5fY29ybmVyWzFdPW5ldyBtKHRoaXMuX21pbngsdGhpcy5fbWF4eSksdGhpcy5fY29ybmVyWzJdPW5ldyBtKHRoaXMuX21pbngsdGhpcy5fbWlueSksdGhpcy5fY29ybmVyWzNdPW5ldyBtKHRoaXMuX21heHgsdGhpcy5fbWlueSl9aW50ZXJzZWN0cyh0LGUpe3JldHVybiAxPT09dGhpcy5fc2NhbGVGYWN0b3I/dGhpcy5pbnRlcnNlY3RzU2NhbGVkKHQsZSk6KHRoaXMuY29weVNjYWxlZCh0LHRoaXMuX3AwU2NhbGVkKSx0aGlzLmNvcHlTY2FsZWQoZSx0aGlzLl9wMVNjYWxlZCksdGhpcy5pbnRlcnNlY3RzU2NhbGVkKHRoaXMuX3AwU2NhbGVkLHRoaXMuX3AxU2NhbGVkKSl9c2NhbGUodCl7cmV0dXJuIE1hdGgucm91bmQodCp0aGlzLl9zY2FsZUZhY3Rvcil9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9vcmlnaW5hbFB0fWNvcHlTY2FsZWQodCxlKXtlLng9dGhpcy5zY2FsZSh0LngpLGUueT10aGlzLnNjYWxlKHQueSl9Z2V0U2FmZUVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX3NhZmVFbnYpe2NvbnN0IHQ9YmkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUi90aGlzLl9zY2FsZUZhY3Rvcjt0aGlzLl9zYWZlRW52PW5ldyBPKHRoaXMuX29yaWdpbmFsUHQueC10LHRoaXMuX29yaWdpbmFsUHQueCt0LHRoaXMuX29yaWdpbmFsUHQueS10LHRoaXMuX29yaWdpbmFsUHQueSt0KX1yZXR1cm4gdGhpcy5fc2FmZUVudn1pbnRlcnNlY3RzUGl4ZWxDbG9zdXJlKHQsZSl7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclswXSx0aGlzLl9jb3JuZXJbMV0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMV0sdGhpcy5fY29ybmVyWzJdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzJdLHRoaXMuX2Nvcm5lclszXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclszXSx0aGlzLl9jb3JuZXJbMF0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpKSl9aW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpe2xldCBuPSExLHM9ITE7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclswXSx0aGlzLl9jb3JuZXJbMV0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsxXSx0aGlzLl9jb3JuZXJbMl0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYobj0hMCksdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzJdLHRoaXMuX2Nvcm5lclszXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJihzPSEwKSx0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbM10sdGhpcy5fY29ybmVyWzBdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCghKCFufHwhcyl8fCghIXQuZXF1YWxzKHRoaXMuX3B0KXx8ISFlLmVxdWFscyh0aGlzLl9wdCkpKSkpKX1hZGRTbmFwcGVkTm9kZSh0LGUpe2NvbnN0IG49dC5nZXRDb29yZGluYXRlKGUpLHM9dC5nZXRDb29yZGluYXRlKGUrMSk7cmV0dXJuISF0aGlzLmludGVyc2VjdHMobixzKSYmKHQuYWRkSW50ZXJzZWN0aW9uKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpLCEwKX19YmkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUj0uNzU7Y2xhc3MgTWl7Y29uc3RydWN0b3IoKXtNaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnNlbGVjdGVkU2VnbWVudD1uZXcgS3R9c2VsZWN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1swXS5nZXRMaW5lU2VnbWVudCh0LHRoaXMuc2VsZWN0ZWRTZWdtZW50KSx0aGlzLnNlbGVjdCh0aGlzLnNlbGVjdGVkU2VnbWVudCl9fX1jbGFzcyBEaXtjb25zdHJ1Y3Rvcigpe0RpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2luZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5kZXg9dH1zbmFwKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNuYXAodCxudWxsLC0xKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmdldFNhZmVFbnZlbG9wZSgpLGk9bmV3IEFpKHQsZSxuKTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkocyxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RlXX12aXNpdEl0ZW0odCl7dC5zZWxlY3QocyxpKX19KSxpLmlzTm9kZUFkZGVkKCl9fX1jbGFzcyBBaSBleHRlbmRzIE1pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxBaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ob3RQaXhlbD1udWxsLHRoaXMuX3BhcmVudEVkZ2U9bnVsbCx0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4PW51bGwsdGhpcy5faXNOb2RlQWRkZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faG90UGl4ZWw9dCx0aGlzLl9wYXJlbnRFZGdlPWUsdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleD1ufWlzTm9kZUFkZGVkKCl7cmV0dXJuIHRoaXMuX2lzTm9kZUFkZGVkfXNlbGVjdCgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLcykpcmV0dXJuIHN1cGVyLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLmdldENvbnRleHQoKTtpZih0aGlzLl9wYXJlbnRFZGdlPT09ZSYmKHQ9PT10aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4fHx0KzE9PT10aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4KSlyZXR1cm4gbnVsbDt0aGlzLl9pc05vZGVBZGRlZHw9dGhpcy5faG90UGl4ZWwuYWRkU25hcHBlZE5vZGUoZSx0KX19fURpLkhvdFBpeGVsU25hcEFjdGlvbj1BaTtjbGFzcyBGaXtjb25zdHJ1Y3Rvcigpe0ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW51bGwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnM9bmV3IEx9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7dCsrKXRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucy5hZGQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKHQpKTt0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKX19aXNEb25lKCl7cmV0dXJuITF9Z2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUmldfX1jbGFzcyBHaXtjb25zdHJ1Y3Rvcigpe0dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BtPW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX25vZGVyPW51bGwsdGhpcy5fcG9pbnRTbmFwcGVyPW51bGwsdGhpcy5fbm9kZWRTZWdTdHJpbmdzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG09dCx0aGlzLl9saT1uZXcganQsdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwodCksdGhpcy5fc2NhbGVGYWN0b3I9dC5nZXRTY2FsZSgpfWNoZWNrQ29ycmVjdG5lc3ModCl7Y29uc3QgZT1acy5nZXROb2RlZFN1YnN0cmluZ3ModCkscz1uZXcgdmkoZSk7dHJ5e3MuY2hlY2tWYWxpZCgpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IHQ7dC5wcmludFN0YWNrVHJhY2UoKX19Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7cmV0dXJuIFpzLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpfXNuYXBSb3VuZCh0LGUpe2NvbnN0IG49dGhpcy5maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsZSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uU25hcHMobiksdGhpcy5jb21wdXRlVmVydGV4U25hcHModCl9ZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpe2NvbnN0IG49bmV3IEZpKGUpO3JldHVybiB0aGlzLl9ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobiksdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKHQpLG4uZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9Y29tcHV0ZVZlcnRleFNuYXBzKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5jb21wdXRlVmVydGV4U25hcHMoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBacyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2NvbnN0IHM9bmV3IGJpKGVbbl0sdGhpcy5fc2NhbGVGYWN0b3IsdGhpcy5fbGkpO3RoaXMuX3BvaW50U25hcHBlci5zbmFwKHMsdCxuKSYmdC5hZGRJbnRlcnNlY3Rpb24oZVtuXSxuKX19fWNvbXB1dGVOb2Rlcyh0KXt0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9dCx0aGlzLl9ub2Rlcj1uZXcgdGksdGhpcy5fcG9pbnRTbmFwcGVyPW5ldyBEaSh0aGlzLl9ub2Rlci5nZXRJbmRleCgpKSx0aGlzLnNuYXBSb3VuZCh0LHRoaXMuX2xpKX1jb21wdXRlSW50ZXJzZWN0aW9uU25hcHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj1uZXcgYmkodCx0aGlzLl9zY2FsZUZhY3Rvcix0aGlzLl9saSk7dGhpcy5fcG9pbnRTbmFwcGVyLnNuYXAobil9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKc119fWNsYXNzIHFpe2NvbnN0cnVjdG9yKCl7cWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fYXJnR2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5fYnVmUGFyYW1zPW5ldyBhaSx0aGlzLl9yZXN1bHRHZW9tZXRyeT1udWxsLHRoaXMuX3NhdmVFeGNlcHRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJnR2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2FyZ0dlb209dCx0aGlzLl9idWZQYXJhbXM9ZX19c3RhdGljIGJ1ZmZlck9wKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgcWkoYXJndW1lbnRzWzBdKS5nZXRSZXN1bHRHZW9tZXRyeSh0KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49bmV3IHFpKGFyZ3VtZW50c1swXSk7bi5zZXRRdWFkcmFudFNlZ21lbnRzKGUpO3JldHVybiBuLmdldFJlc3VsdEdlb21ldHJ5KHQpfWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgYWkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBxaShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzJdKS5nZXRSZXN1bHRHZW9tZXRyeSh0KX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM10scz1uZXcgcWkoYXJndW1lbnRzWzBdKTtzLnNldFF1YWRyYW50U2VnbWVudHMoZSkscy5zZXRFbmRDYXBTdHlsZShuKTtyZXR1cm4gcy5nZXRSZXN1bHRHZW9tZXRyeSh0KX19c3RhdGljIHByZWNpc2lvblNjYWxlRmFjdG9yKHQsZSxuKXtjb25zdCBzPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9Vi5tYXgoTWF0aC5hYnMocy5nZXRNYXhYKCkpLE1hdGguYWJzKHMuZ2V0TWF4WSgpKSxNYXRoLmFicyhzLmdldE1pblgoKSksTWF0aC5hYnMocy5nZXRNaW5ZKCkpKSsyKihlPjA/ZTowKSxyPW4tTWF0aC50cnVuYyhNYXRoLmxvZyhpKS9NYXRoLmxvZygxMCkrMSk7cmV0dXJuIE1hdGgucG93KDEwLHIpfWJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpe2NvbnN0IGU9bmV3IG5pKG5ldyBHaShuZXcgd3QoMSkpLHQuZ2V0U2NhbGUoKSksbj1uZXcgT2kodGhpcy5fYnVmUGFyYW1zKTtuLnNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KSxuLnNldE5vZGVyKGUpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5PW4uYnVmZmVyKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UpfWJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PXFpLk1BWF9QUkVDSVNJT05fRElHSVRTO3Q+PTA7dC0tKXt0cnl7dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHQpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGlzKSl0aHJvdyB0O3RoaXMuX3NhdmVFeGNlcHRpb249dH1pZihudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGx9dGhyb3cgdGhpcy5fc2F2ZUV4Y2VwdGlvbn1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1xaS5wcmVjaXNpb25TY2FsZUZhY3Rvcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlLHQpLG49bmV3IHd0KGUpO3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24obil9fWNvbXB1dGVHZW9tZXRyeSgpe2lmKHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKSxudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLl9hcmdHZW9tLmdldEZhY3RvcnkoKS5nZXRQcmVjaXNpb25Nb2RlbCgpO3QuZ2V0VHlwZSgpPT09d3QuRklYRUQ/dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbih0KTp0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKX1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX2J1ZlBhcmFtcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCl7dHJ5e2NvbnN0IHQ9bmV3IE9pKHRoaXMuX2J1ZlBhcmFtcyk7dGhpcy5fcmVzdWx0R2VvbWV0cnk9dC5idWZmZXIodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDt0aGlzLl9zYXZlRXhjZXB0aW9uPXR9fWdldFJlc3VsdEdlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9kaXN0YW5jZT10LHRoaXMuY29tcHV0ZUdlb21ldHJ5KCksdGhpcy5fcmVzdWx0R2VvbWV0cnl9c2V0RW5kQ2FwU3R5bGUodCl7dGhpcy5fYnVmUGFyYW1zLnNldEVuZENhcFN0eWxlKHQpfX1xaS5DQVBfUk9VTkQ9YWkuQ0FQX1JPVU5ELHFpLkNBUF9CVVRUPWFpLkNBUF9GTEFULHFpLkNBUF9GTEFUPWFpLkNBUF9GTEFULHFpLkNBUF9TUVVBUkU9YWkuQ0FQX1NRVUFSRSxxaS5NQVhfUFJFQ0lTSU9OX0RJR0lUUz0xMjt2YXIgQmk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQnVmZmVyT3A6cWksQnVmZmVyUGFyYW1ldGVyczphaX0pO2NsYXNzIFlpe2NvbnN0cnVjdG9yKCl7WWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fY29tcG9uZW50PW51bGwsdGhpcy5fc2VnSW5kZXg9bnVsbCx0aGlzLl9wdD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtZaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsWWkuSU5TSURFX0FSRUEsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29tcG9uZW50PXQsdGhpcy5fc2VnSW5kZXg9ZSx0aGlzLl9wdD1ufX1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fc2VnSW5kZXh9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH1pc0luc2lkZUFyZWEoKXtyZXR1cm4gdGhpcy5fc2VnSW5kZXg9PT1ZaS5JTlNJREVfQVJFQX10b1N0cmluZygpe3JldHVybiB0aGlzLl9jb21wb25lbnQuZ2V0R2VvbWV0cnlUeXBlKCkrXCJbXCIrdGhpcy5fc2VnSW5kZXgrXCJdLVwiK1d0LnRvUG9pbnQodGhpcy5fcHQpfWdldEdlb21ldHJ5Q29tcG9uZW50KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudH19WWkuSU5TSURFX0FSRUE9LTE7Y2xhc3MgVml7Y29uc3RydWN0b3IoKXtWaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9sb2NhdGlvbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sb2NhdGlvbnM9dH1zdGF0aWMgZ2V0TG9jYXRpb25zKHQpe2NvbnN0IGU9bmV3IEw7cmV0dXJuIHQuYXBwbHkobmV3IFZpKGUpKSxlfWZpbHRlcih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDsodCBpbnN0YW5jZW9mIGV0fHx0IGluc3RhbmNlb2YgJHx8dCBpbnN0YW5jZW9mIHJ0KSYmdGhpcy5fbG9jYXRpb25zLmFkZChuZXcgWWkodCwwLHQuZ2V0Q29vcmRpbmF0ZSgpKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pdfX1jbGFzcyB6aXtjb25zdHJ1Y3Rvcigpe3ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb209bnVsbCx0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT0wLHRoaXMuX3B0TG9jYXRvcj1uZXcgZm4sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbj1udWxsLHRoaXMuX21pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt6aS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSwwKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWUsdGhpcy5fdGVybWluYXRlRGlzdGFuY2U9bn19c3RhdGljIGRpc3RhbmNlKHQsZSl7cmV0dXJuIG5ldyB6aSh0LGUpLmRpc3RhbmNlKCl9c3RhdGljIGlzV2l0aGluRGlzdGFuY2UodCxlLG4pe2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT5uKXJldHVybiExO3JldHVybiBuZXcgemkodCxlLG4pLmRpc3RhbmNlKCk8PW59c3RhdGljIG5lYXJlc3RQb2ludHModCxlKXtyZXR1cm4gbmV3IHppKHQsZSkubmVhcmVzdFBvaW50cygpfWNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLHQpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9nZW9tW3RdO2lmKG4uZ2V0RGltZW5zaW9uKCk8MilyZXR1cm4gbnVsbDtjb25zdCBzPTEtdCxpPUllLmdldFBvbHlnb25zKG4pO2lmKGkuc2l6ZSgpPjApe2NvbnN0IG49VmkuZ2V0TG9jYXRpb25zKHRoaXMuX2dlb21bc10pO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UobixpLGUpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbltzXT1lWzBdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bdF09ZVsxXSxudWxsfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJkkoYXJndW1lbnRzWzBdLEMpJiZJKGFyZ3VtZW50c1sxXSxDKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0KyspaWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShpLGUuZ2V0KHQpLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFlpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKFF0LkVYVEVSSU9SIT09dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShzLGUpKXJldHVybiB0aGlzLl9taW5EaXN0YW5jZT0wLG5bMF09dCxuWzFdPW5ldyBZaShlLHMpLG51bGx9fWNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShpLHMsbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19Y29tcHV0ZUZhY2V0RGlzdGFuY2UoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGU9eWUuZ2V0TGluZXModGhpcy5fZ2VvbVswXSksbj15ZS5nZXRMaW5lcyh0aGlzLl9nZW9tWzFdKSxzPUVlLmdldFBvaW50cyh0aGlzLl9nZW9tWzBdKSxpPUVlLmdldFBvaW50cyh0aGlzLl9nZW9tWzFdKTtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhlLG4sdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKGUsaSx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMobixzLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMocyxpLHQpLHZvaWQgdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSkpKX1uZWFyZXN0TG9jYXRpb25zKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbn11cGRhdGVNaW5EaXN0YW5jZSh0LGUpe2lmKG51bGw9PT10WzBdKXJldHVybiBudWxsO2U/KHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF09dFsxXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMF0pOih0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMF0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzFdKX1uZWFyZXN0UG9pbnRzKCl7dGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKTtyZXR1cm5bdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXS5nZXRDb29yZGluYXRlKCksdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXS5nZXRDb29yZGluYXRlKCldfWNvbXB1dGVNaW5EaXN0YW5jZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihudWxsIT09dGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlRmFjZXREaXN0YW5jZSgpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGV0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGUoKTtmb3IobGV0IHI9MDtyPHMubGVuZ3RoLTE7cisrKXtjb25zdCBvPXoucG9pbnRUb1NlZ21lbnQoaSxzW3JdLHNbcisxXSk7aWYobzx0aGlzLl9taW5EaXN0YW5jZSl7dGhpcy5fbWluRGlzdGFuY2U9bztjb25zdCBsPW5ldyBLdChzW3JdLHNbcisxXSkuY2xvc2VzdFBvaW50KGkpO25bMF09bmV3IFlpKHQscixsKSxuWzFdPW5ldyBZaShlLDAsaSl9aWYodGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiAkKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCByPTA7cjxzLmxlbmd0aC0xO3IrKyl7Y29uc3Qgbz1uZXcgTyhzW3JdLHNbcisxXSk7aWYoIShvLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLl9taW5EaXN0YW5jZSkpZm9yKGxldCBsPTA7bDxpLmxlbmd0aC0xO2wrKyl7Y29uc3QgYT1uZXcgTyhpW2xdLGlbbCsxXSk7aWYoby5kaXN0YW5jZShhKT50aGlzLl9taW5EaXN0YW5jZSljb250aW51ZTtjb25zdCBjPXouc2VnbWVudFRvU2VnbWVudChzW3JdLHNbcisxXSxpW2xdLGlbbCsxXSk7aWYoYzx0aGlzLl9taW5EaXN0YW5jZSl7dGhpcy5fbWluRGlzdGFuY2U9Yztjb25zdCBvPW5ldyBLdChzW3JdLHNbcisxXSksYT1uZXcgS3QoaVtsXSxpW2wrMV0pLGg9by5jbG9zZXN0UG9pbnRzKGEpO25bMF09bmV3IFlpKHQscixoWzBdKSxuWzFdPW5ldyBZaShlLGwsaFsxXSl9aWYodGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19fWNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCkscj1pLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZShzLmdldENvb3JkaW5hdGUoKSk7aWYocjx0aGlzLl9taW5EaXN0YW5jZSYmKHRoaXMuX21pbkRpc3RhbmNlPXIsblswXT1uZXcgWWkoaSwwLGkuZ2V0Q29vcmRpbmF0ZSgpKSxuWzFdPW5ldyBZaShzLDAscy5nZXRDb29yZGluYXRlKCkpKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1kaXN0YW5jZSgpe2lmKG51bGw9PT10aGlzLl9nZW9tWzBdfHxudWxsPT09dGhpcy5fZ2VvbVsxXSl0aHJvdyBuZXcgcyhcIm51bGwgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gdGhpcy5fZ2VvbVswXS5pc0VtcHR5KCl8fHRoaXMuX2dlb21bMV0uaXNFbXB0eSgpPzA6KHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2UpfWNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShpLHMsbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19fXZhciBYaT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEaXN0YW5jZU9wOnppfSk7Y2xhc3Mga2l7Y29uc3RydWN0b3IoKXtraS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZGlyZWN0ZWRFZGdlcz1uZXcgTCx0aGlzLl9jb29yZGluYXRlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH1nZXRDb29yZGluYXRlcygpe2lmKG51bGw9PT10aGlzLl9jb29yZGluYXRlcyl7bGV0IHQ9MCxlPTA7Y29uc3Qgbj1uZXcgUjtmb3IobGV0IHM9dGhpcy5fZGlyZWN0ZWRFZGdlcy5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKTtpLmdldEVkZ2VEaXJlY3Rpb24oKT90Kys6ZSsrLG4uYWRkKGkuZ2V0RWRnZSgpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLCExLGkuZ2V0RWRnZURpcmVjdGlvbigpKX10aGlzLl9jb29yZGluYXRlcz1uLnRvQ29vcmRpbmF0ZUFycmF5KCksZT50JiZfdC5yZXZlcnNlKHRoaXMuX2Nvb3JkaW5hdGVzKX1yZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9dG9MaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpfWFkZCh0KXt0aGlzLl9kaXJlY3RlZEVkZ2VzLmFkZCh0KX19Y2xhc3MgVWl7Y29uc3RydWN0b3IoKXtVaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc01hcmtlZD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5fZGF0YT1udWxsfXN0YXRpYyBnZXRDb21wb25lbnRXaXRoVmlzaXRlZFN0YXRlKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7aWYobi5pc1Zpc2l0ZWQoKT09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9c3RhdGljIHNldFZpc2l0ZWQodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0VmlzaXRlZChlKX19c3RhdGljIHNldE1hcmtlZCh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRNYXJrZWQoZSl9fXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXNldE1hcmtlZCh0KXt0aGlzLl9pc01hcmtlZD10fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fZGF0YX1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfXNldENvbnRleHQodCl7dGhpcy5fZGF0YT10fX1jbGFzcyBIaSBleHRlbmRzIFVpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxIaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wYXJlbnRFZGdlPW51bGwsdGhpcy5fZnJvbT1udWxsLHRoaXMuX3RvPW51bGwsdGhpcy5fcDA9bnVsbCx0aGlzLl9wMT1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX2VkZ2VEaXJlY3Rpb249bnVsbCx0aGlzLl9xdWFkcmFudD1udWxsLHRoaXMuX2FuZ2xlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX2Zyb209dCx0aGlzLl90bz1lLHRoaXMuX2VkZ2VEaXJlY3Rpb249cyx0aGlzLl9wMD10LmdldENvb3JkaW5hdGUoKSx0aGlzLl9wMT1uO2NvbnN0IGk9dGhpcy5fcDEueC10aGlzLl9wMC54LHI9dGhpcy5fcDEueS10aGlzLl9wMC55O3RoaXMuX3F1YWRyYW50PUNuLnF1YWRyYW50KGksciksdGhpcy5fYW5nbGU9TWF0aC5hdGFuMihyLGkpfX1zdGF0aWMgdG9FZGdlcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuYWRkKG4ubmV4dCgpLl9wYXJlbnRFZGdlKTtyZXR1cm4gZX1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3BhcmVudEVkZ2V9Y29tcGFyZURpcmVjdGlvbih0KXtyZXR1cm4gdGhpcy5fcXVhZHJhbnQ+dC5fcXVhZHJhbnQ/MTp0aGlzLl9xdWFkcmFudDx0Ll9xdWFkcmFudD8tMTpxLmluZGV4KHQuX3AwLHQuX3AxLHRoaXMuX3AxKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Zyb20uZ2V0Q29vcmRpbmF0ZSgpfXByaW50KHQpe2NvbnN0IGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpLHM9ZS5zdWJzdHJpbmcobisxKTt0LnByaW50KFwiICBcIitzK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK3RoaXMuX2FuZ2xlKX1nZXREaXJlY3Rpb25QdCgpe3JldHVybiB0aGlzLl9wMX1nZXRBbmdsZSgpe3JldHVybiB0aGlzLl9hbmdsZX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9Z2V0RnJvbU5vZGUoKXtyZXR1cm4gdGhpcy5fZnJvbX1nZXRTeW0oKXtyZXR1cm4gdGhpcy5fc3ltfXNldEVkZ2UodCl7dGhpcy5fcGFyZW50RWRnZT10fXJlbW92ZSgpe3RoaXMuX3N5bT1udWxsLHRoaXMuX3BhcmVudEVkZ2U9bnVsbH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX3BhcmVudEVkZ2V9Z2V0UXVhZHJhbnQoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnR9c2V0U3ltKHQpe3RoaXMuX3N5bT10fWdldFRvTm9kZSgpe3JldHVybiB0aGlzLl90b31nZXRFZGdlRGlyZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2VkZ2VEaXJlY3Rpb259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBXaSBleHRlbmRzIEhpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxXaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtIaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLHMpfWdldE5leHQoKXtyZXR1cm4gMiE9PXRoaXMuZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCk/bnVsbDp0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCk9PT10aGlzLmdldFN5bSgpP3RoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKTooZy5pc1RydWUodGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpPT09dGhpcy5nZXRTeW0oKSksdGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApKX19Y2xhc3MgWmkgZXh0ZW5kcyBVaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksWmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGlyRWRnZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldERpcmVjdGVkRWRnZXModCxlKX19aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9kaXJFZGdlfXNldERpcmVjdGVkRWRnZXModCxlKXt0aGlzLl9kaXJFZGdlPVt0LGVdLHQuc2V0RWRnZSh0aGlzKSxlLnNldEVkZ2UodGhpcyksdC5zZXRTeW0oZSksZS5zZXRTeW0odCksdC5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UodCksZS5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UoZSl9Z2V0RGlyRWRnZSgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VbdF19aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVswXTp0aGlzLl9kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMV06bnVsbH19cmVtb3ZlKCl7dGhpcy5fZGlyRWRnZT1udWxsfWdldE9wcG9zaXRlTm9kZSh0KXtyZXR1cm4gdGhpcy5fZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzBdLmdldFRvTm9kZSgpOnRoaXMuX2RpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVsxXS5nZXRUb05vZGUoKTpudWxsfX1jbGFzcyBqaXtjb25zdHJ1Y3Rvcigpe2ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX291dEVkZ2VzPW5ldyBMLHRoaXMuX3NvcnRlZD0hMX1nZXROZXh0RWRnZSh0KXtjb25zdCBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMuX291dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUrMSkpfWdldENvb3JkaW5hdGUoKXtjb25zdCB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7cmV0dXJuIHQubmV4dCgpLmdldENvb3JkaW5hdGUoKX1pdGVyYXRvcigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMuX291dEVkZ2VzLml0ZXJhdG9yKCl9c29ydEVkZ2VzKCl7dGhpcy5fc29ydGVkfHwoeGUuc29ydCh0aGlzLl9vdXRFZGdlcyksdGhpcy5fc29ydGVkPSEwKX1yZW1vdmUodCl7dGhpcy5fb3V0RWRnZXMucmVtb3ZlKHQpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5fb3V0RWRnZXN9Z2V0TmV4dENXRWRnZSh0KXtjb25zdCBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMuX291dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUtMSkpfWdldEluZGV4KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBaaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX291dEVkZ2VzLnNpemUoKTtlKyspe2lmKHRoaXMuX291dEVkZ2VzLmdldChlKS5nZXRFZGdlKCk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9vdXRFZGdlcy5zaXplKCk7ZSsrKXtpZih0aGlzLl9vdXRFZGdlcy5nZXQoZSk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7bGV0IHQ9YXJndW1lbnRzWzBdJXRoaXMuX291dEVkZ2VzLnNpemUoKTtyZXR1cm4gdDwwJiYodCs9dGhpcy5fb3V0RWRnZXMuc2l6ZSgpKSx0fX1hZGQodCl7dGhpcy5fb3V0RWRnZXMuYWRkKHQpLHRoaXMuX3NvcnRlZD0hMX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuc2l6ZSgpfX1jbGFzcyBLaSBleHRlbmRzIFVpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxLaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wdD1udWxsLHRoaXMuX2RlU3Rhcj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtLaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbmV3IGppKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdD10LHRoaXMuX2RlU3Rhcj1lfX1zdGF0aWMgZ2V0RWRnZXNCZXR3ZWVuKHQsZSl7Y29uc3Qgbj1IaS50b0VkZ2VzKHQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKSxzPW5ldyBFdChuKSxpPUhpLnRvRWRnZXMoZS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpO3JldHVybiBzLnJldGFpbkFsbChpKSxzfWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fcHR9YWRkT3V0RWRnZSh0KXt0aGlzLl9kZVN0YXIuYWRkKHQpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0T3V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZGVTdGFyfXJlbW92ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX3B0PW51bGw7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZGVTdGFyLnJlbW92ZSh0KX19Z2V0SW5kZXgodCl7cmV0dXJuIHRoaXMuX2RlU3Rhci5nZXRJbmRleCh0KX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fZGVTdGFyLmdldERlZ3JlZSgpfX1jbGFzcyBRaSBleHRlbmRzIFppe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxRaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fWdldExpbmUoKXtyZXR1cm4gdGhpcy5fbGluZX19Y2xhc3MgSml7Y29uc3RydWN0b3IoKXtKaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2RlTWFwPW5ldyBXbn1maW5kKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLmdldCh0KX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9cmVtb3ZlKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLnJlbW92ZSh0KX12YWx1ZXMoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKX1hZGQodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHR9fWNsYXNzICRpe2NvbnN0cnVjdG9yKCl7JGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZWRnZXM9bmV3IEV0LHRoaXMuX2RpckVkZ2VzPW5ldyBFdCx0aGlzLl9ub2RlTWFwPW5ldyBKaX1maW5kTm9kZXNPZkRlZ3JlZSh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10aGlzLm5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmdldERlZ3JlZSgpPT09dCYmZS5hZGQocyl9cmV0dXJuIGV9ZGlyRWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCl9ZWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9cmVtb3ZlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBaaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDApKSx0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMSkpLHRoaXMuX2VkZ2VzLnJlbW92ZSh0KSx0LnJlbW92ZSgpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBIaSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmdldFN5bSgpO251bGwhPT1lJiZlLnNldFN5bShudWxsKSx0LmdldEZyb21Ob2RlKCkucmVtb3ZlKHQpLHQucmVtb3ZlKCksdGhpcy5fZGlyRWRnZXMucmVtb3ZlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRTeW0oKTtudWxsIT09biYmdGhpcy5yZW1vdmUobiksdGhpcy5fZGlyRWRnZXMucmVtb3ZlKHQpO2NvbnN0IHM9dC5nZXRFZGdlKCk7bnVsbCE9PXMmJnRoaXMuX2VkZ2VzLnJlbW92ZShzKX10aGlzLl9ub2RlTWFwLnJlbW92ZSh0LmdldENvb3JkaW5hdGUoKSksdC5yZW1vdmUoKX19ZmluZE5vZGUodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuZmluZCh0KX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31ub2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5pdGVyYXRvcigpfWNvbnRhaW5zKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBaaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlcy5jb250YWlucyh0KX19YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbm9kZU1hcC5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFppKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlcy5hZGQodCksdGhpcy5hZGQodC5nZXREaXJFZGdlKDApKSx0aGlzLmFkZCh0LmdldERpckVkZ2UoMSkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBIaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZGlyRWRnZXMuYWRkKHQpfX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpfX1jbGFzcyB0ciBleHRlbmRzICRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1hZGRFZGdlKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IGU9X3QucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDtjb25zdCBuPWVbMF0scz1lW2UubGVuZ3RoLTFdLGk9dGhpcy5nZXROb2RlKG4pLHI9dGhpcy5nZXROb2RlKHMpLG89bmV3IFdpKGkscixlWzFdLCEwKSxsPW5ldyBXaShyLGksZVtlLmxlbmd0aC0yXSwhMSksYT1uZXcgUWkodCk7YS5zZXREaXJlY3RlZEVkZ2VzKG8sbCksdGhpcy5hZGQoYSl9Z2V0Tm9kZSh0KXtsZXQgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IEtpKHQpLHRoaXMuYWRkKGUpKSxlfX1jbGFzcyBlcntjb25zdHJ1Y3Rvcigpe2VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW5ldyB0cix0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9lZGdlU3RyaW5ncz1udWxsfWJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5pc01hcmtlZCgpfHwoZy5pc1RydWUoMj09PWUuZ2V0RGVncmVlKCkpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19YnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpOzIhPT1lLmdldERlZ3JlZSgpJiYodGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX1idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKX1nZXRNZXJnZWRMaW5lU3RyaW5ncygpe3JldHVybiB0aGlzLm1lcmdlKCksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3N9YnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQodCl7Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmdldEVkZ2UoKS5pc01hcmtlZCgpfHx0aGlzLl9lZGdlU3RyaW5ncy5hZGQodGhpcy5idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgodCkpfX1tZXJnZSgpe2lmKG51bGwhPT10aGlzLl9tZXJnZWRMaW5lU3RyaW5ncylyZXR1cm4gbnVsbDtVaS5zZXRNYXJrZWQodGhpcy5fZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpLFVpLnNldE1hcmtlZCh0aGlzLl9ncmFwaC5lZGdlSXRlcmF0b3IoKSwhMSksdGhpcy5fZWRnZVN0cmluZ3M9bmV3IEwsdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bmV3IEw7Zm9yKGxldCB0PXRoaXMuX2VkZ2VTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuX21lcmdlZExpbmVTdHJpbmdzLmFkZChlLnRvTGluZVN0cmluZygpKX19YWRkTGluZVN0cmluZyh0KXtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCl9YnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKHQpe2NvbnN0IGU9bmV3IGtpKHRoaXMuX2ZhY3RvcnkpO2xldCBuPXQ7ZG97ZS5hZGQobiksbi5nZXRFZGdlKCkuc2V0TWFya2VkKCEwKSxuPW4uZ2V0TmV4dCgpfXdoaWxlKG51bGwhPT1uJiZuIT09dCk7cmV0dXJuIGV9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtuIGluc3RhbmNlb2YgJCYmdGhpcy5hZGRMaW5lU3RyaW5nKG4pfX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuYWRkKHQpfX19YnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl9fWNsYXNzIG5ye2NvbnN0cnVjdG9yKCl7bnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcGFyZW50R3JhcGg9bnVsbCx0aGlzLl9lZGdlcz1uZXcgRXQsdGhpcy5fZGlyRWRnZXM9bmV3IEwsdGhpcy5fbm9kZU1hcD1uZXcgSmk7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50R3JhcGg9dH1kaXJFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKX1lZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50R3JhcGh9bm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuaXRlcmF0b3IoKX1jb250YWlucyh0KXtyZXR1cm4gdGhpcy5fZWRnZXMuY29udGFpbnModCl9YWRkKHQpe2lmKHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpKXJldHVybiBudWxsO3RoaXMuX2VkZ2VzLmFkZCh0KSx0aGlzLl9kaXJFZGdlcy5hZGQodC5nZXREaXJFZGdlKDApKSx0aGlzLl9kaXJFZGdlcy5hZGQodC5nZXREaXJFZGdlKDEpKSx0aGlzLl9ub2RlTWFwLmFkZCh0LmdldERpckVkZ2UoMCkuZ2V0RnJvbU5vZGUoKSksdGhpcy5fbm9kZU1hcC5hZGQodC5nZXREaXJFZGdlKDEpLmdldEZyb21Ob2RlKCkpfX1jbGFzcyBzcntjb25zdHJ1Y3Rvcigpe3NyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ3JhcGg9dH1hZGRSZWFjaGFibGUodCxlKXtjb25zdCBuPW5ldyBlbjtmb3Iobi5hZGQodCk7IW4uZW1wdHkoKTspe2NvbnN0IHQ9bi5wb3AoKTt0aGlzLmFkZEVkZ2VzKHQsbixlKX19ZmluZFN1YmdyYXBoKHQpe2NvbnN0IGU9bmV3IG5yKHRoaXMuX2dyYXBoKTtyZXR1cm4gdGhpcy5hZGRSZWFjaGFibGUodCxlKSxlfWdldENvbm5lY3RlZFN1YmdyYXBocygpe2NvbnN0IHQ9bmV3IEw7VWkuc2V0VmlzaXRlZCh0aGlzLl9ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSk7Zm9yKGxldCBlPXRoaXMuX2dyYXBoLmVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXREaXJFZGdlKDApLmdldEZyb21Ob2RlKCk7bi5pc1Zpc2l0ZWQoKXx8dC5hZGQodGhpcy5maW5kU3ViZ3JhcGgobikpfXJldHVybiB0fWFkZEVkZ2VzKHQsZSxuKXt0LnNldFZpc2l0ZWQoITApO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7bi5hZGQodC5nZXRFZGdlKCkpO2NvbnN0IGk9dC5nZXRUb05vZGUoKTtpLmlzVmlzaXRlZCgpfHxlLnB1c2goaSl9fX1jbGFzcyBpcntjb25zdHJ1Y3Rvcigpe2lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW5ldyB0cix0aGlzLl9mYWN0b3J5PW5ldyBMdCx0aGlzLl9saW5lQ291bnQ9MCx0aGlzLl9pc1J1bj0hMSx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeT1udWxsLHRoaXMuX2lzU2VxdWVuY2VhYmxlPSExfXN0YXRpYyBmaW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUodCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmdldEVkZ2UoKS5pc1Zpc2l0ZWQoKXx8KG49dCx0LmdldEVkZ2VEaXJlY3Rpb24oKSYmKGU9dCkpfXJldHVybiBudWxsIT09ZT9lOm59c3RhdGljIGZpbmRMb3dlc3REZWdyZWVOb2RlKHQpe2xldCBlPWIuTUFYX1ZBTFVFLG49bnVsbDtmb3IobGV0IHM9dC5ub2RlSXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7KG51bGw9PT1ufHx0LmdldERlZ3JlZSgpPGUpJiYoZT10LmdldERlZ3JlZSgpLG49dCl9cmV0dXJuIG59c3RhdGljIGlzU2VxdWVuY2VkKHQpe2lmKCEodCBpbnN0YW5jZW9mIFN0KSlyZXR1cm4hMDtjb25zdCBlPXQsbj1uZXcgYXQ7bGV0IHM9bnVsbDtjb25zdCBpPW5ldyBMO2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCByPWUuZ2V0R2VvbWV0cnlOKHQpLG89ci5nZXRDb29yZGluYXRlTigwKSxsPXIuZ2V0Q29vcmRpbmF0ZU4oci5nZXROdW1Qb2ludHMoKS0xKTtpZihuLmNvbnRhaW5zKG8pKXJldHVybiExO2lmKG4uY29udGFpbnMobCkpcmV0dXJuITE7bnVsbCE9PXMmJihvLmVxdWFscyhzKXx8KG4uYWRkQWxsKGkpLGkuY2xlYXIoKSkpLGkuYWRkKG8pLGkuYWRkKGwpLHM9bH1yZXR1cm4hMH1zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPW5ldyBBcnJheShlLmxlbmd0aCkuZmlsbChudWxsKSxzPWUubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8czt0KyspbltzLTEtdF09bmV3IG0oZVt0XSk7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobil9c3RhdGljIHNlcXVlbmNlKHQpe2NvbnN0IGU9bmV3IGlyO3JldHVybiBlLmFkZCh0KSxlLmdldFNlcXVlbmNlZExpbmVTdHJpbmdzKCl9YWRkTGluZSh0KXtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCksdGhpcy5fbGluZUNvdW50Kyt9aGFzU2VxdWVuY2UodCl7bGV0IGU9MDtmb3IobGV0IG49dC5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmdldERlZ3JlZSgpJTI9PTEmJmUrK31yZXR1cm4gZTw9Mn1jb21wdXRlU2VxdWVuY2UoKXtpZih0aGlzLl9pc1J1bilyZXR1cm4gbnVsbDt0aGlzLl9pc1J1bj0hMDtjb25zdCB0PXRoaXMuZmluZFNlcXVlbmNlcygpO2lmKG51bGw9PT10KXJldHVybiBudWxsO3RoaXMuX3NlcXVlbmNlZEdlb21ldHJ5PXRoaXMuYnVpbGRTZXF1ZW5jZWRHZW9tZXRyeSh0KSx0aGlzLl9pc1NlcXVlbmNlYWJsZT0hMDtjb25zdCBlPXRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5LmdldE51bUdlb21ldHJpZXMoKTtnLmlzVHJ1ZSh0aGlzLl9saW5lQ291bnQ9PT1lLFwiTGluZXMgd2VyZSBtaXNzaW5nIGZyb20gcmVzdWx0XCIpLGcuaXNUcnVlKHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5IGluc3RhbmNlb2YgJHx8dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkgaW5zdGFuY2VvZiBTdCxcIlJlc3VsdCBpcyBub3QgbGluZWFsXCIpfWZpbmRTZXF1ZW5jZXMoKXtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT1uZXcgc3IodGhpcy5fZ3JhcGgpLmdldENvbm5lY3RlZFN1YmdyYXBocygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKCF0aGlzLmhhc1NlcXVlbmNlKG4pKXJldHVybiBudWxsO3tjb25zdCBlPXRoaXMuZmluZFNlcXVlbmNlKG4pO3QuYWRkKGUpfX1yZXR1cm4gdH1hZGRSZXZlcnNlU3VicGF0aCh0LGUsbil7Y29uc3Qgcz10LmdldFRvTm9kZSgpO2xldCBpPW51bGw7Zm9yKDs7KXtlLmFkZCh0LmdldFN5bSgpKSx0LmdldEVkZ2UoKS5zZXRWaXNpdGVkKCEwKSxpPXQuZ2V0RnJvbU5vZGUoKTtjb25zdCBuPWlyLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERShpKTtpZihudWxsPT09bilicmVhazt0PW4uZ2V0U3ltKCl9biYmZy5pc1RydWUoaT09PXMsXCJwYXRoIG5vdCBjb250aWd1b3VzXCIpfWZpbmRTZXF1ZW5jZSh0KXtVaS5zZXRWaXNpdGVkKHQuZWRnZUl0ZXJhdG9yKCksITEpO2NvbnN0IGU9aXIuZmluZExvd2VzdERlZ3JlZU5vZGUodCkuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpLm5leHQoKS5nZXRTeW0oKSxuPW5ldyBoaSxzPW4ubGlzdEl0ZXJhdG9yKCk7Zm9yKHRoaXMuYWRkUmV2ZXJzZVN1YnBhdGgoZSxzLCExKTtzLmhhc1ByZXZpb3VzKCk7KXtjb25zdCB0PXMucHJldmlvdXMoKSxlPWlyLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERSh0LmdldEZyb21Ob2RlKCkpO251bGwhPT1lJiZ0aGlzLmFkZFJldmVyc2VTdWJwYXRoKGUuZ2V0U3ltKCkscywhMCl9cmV0dXJuIHRoaXMub3JpZW50KG4pfXJldmVyc2UodCl7Y29uc3QgZT1uZXcgaGk7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGRGaXJzdCh0LmdldFN5bSgpKX1yZXR1cm4gZX1vcmllbnQodCl7Y29uc3QgZT10LmdldCgwKSxuPXQuZ2V0KHQuc2l6ZSgpLTEpLHM9ZS5nZXRGcm9tTm9kZSgpLGk9bi5nZXRUb05vZGUoKTtsZXQgcj0hMTtpZigxPT09cy5nZXREZWdyZWUoKXx8MT09PWkuZ2V0RGVncmVlKCkpe2xldCB0PSExOzE9PT1uLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpJiYhMT09PW4uZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSEwKSwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYhMD09PWUuZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSExKSx0fHwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYocj0hMCl9cmV0dXJuIHI/dGhpcy5yZXZlcnNlKHQpOnR9YnVpbGRTZXF1ZW5jZWRHZW9tZXRyeSh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtmb3IobGV0IHQ9bi5uZXh0KCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldEVkZ2UoKS5nZXRMaW5lKCk7bGV0IGk9cztuLmdldEVkZ2VEaXJlY3Rpb24oKXx8cy5pc0Nsb3NlZCgpfHwoaT1pci5yZXZlcnNlKHMpKSxlLmFkZChpKX19cmV0dXJuIDA9PT1lLnNpemUoKT90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk6dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KGUpfWdldFNlcXVlbmNlZExpbmVTdHJpbmdzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVNlcXVlbmNlKCksdGhpcy5fc2VxdWVuY2VkR2VvbWV0cnl9aXNTZXF1ZW5jZWFibGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlU2VxdWVuY2UoKSx0aGlzLl9pc1NlcXVlbmNlYWJsZX1hZGQoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2FyZ3VtZW50c1swXS5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgJCYmdGhpcy5hZGRMaW5lKHQpfX0pfX19dmFyIHJyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExpbmVNZXJnZXI6ZXIsTGluZVNlcXVlbmNlcjppcn0pO2NsYXNzIG9ye2NvbnN0cnVjdG9yKCl7b3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc25hcFRvbGVyYW5jZT0wLHRoaXMuX3NyY1B0cz1udWxsLHRoaXMuX3NlZz1uZXcgS3QsdGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9ITEsdGhpcy5faXNDbG9zZWQ9ITEsYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtvci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZXMoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3NyY1B0cz10LHRoaXMuX2lzQ2xvc2VkPW9yLmlzQ2xvc2VkKHQpLHRoaXMuX3NuYXBUb2xlcmFuY2U9ZX19c3RhdGljIGlzQ2xvc2VkKHQpe3JldHVybiEodC5sZW5ndGg8PTEpJiZ0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfXNuYXBWZXJ0aWNlcyh0LGUpe2NvbnN0IG49dGhpcy5faXNDbG9zZWQ/dC5zaXplKCktMTp0LnNpemUoKTtmb3IobGV0IHM9MDtzPG47cysrKXtjb25zdCBuPXQuZ2V0KHMpLGk9dGhpcy5maW5kU25hcEZvclZlcnRleChuLGUpO251bGwhPT1pJiYodC5zZXQocyxuZXcgbShpKSksMD09PXMmJnRoaXMuX2lzQ2xvc2VkJiZ0LnNldCh0LnNpemUoKS0xLG5ldyBtKGkpKSl9fWZpbmRTbmFwRm9yVmVydGV4KHQsZSl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2lmKHQuZXF1YWxzMkQoZVtuXSkpcmV0dXJuIG51bGw7aWYodC5kaXN0YW5jZShlW25dKTx0aGlzLl9zbmFwVG9sZXJhbmNlKXJldHVybiBlW25dfXJldHVybiBudWxsfXNuYXBUbyh0KXtjb25zdCBlPW5ldyBSKHRoaXMuX3NyY1B0cyk7dGhpcy5zbmFwVmVydGljZXMoZSx0KSx0aGlzLnNuYXBTZWdtZW50cyhlLHQpO3JldHVybiBlLnRvQ29vcmRpbmF0ZUFycmF5KCl9c25hcFNlZ21lbnRzKHQsZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiBudWxsO2xldCBuPWUubGVuZ3RoO2VbMF0uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkmJihuPWUubGVuZ3RoLTEpO2ZvcihsZXQgcz0wO3M8bjtzKyspe2NvbnN0IG49ZVtzXSxpPXRoaXMuZmluZFNlZ21lbnRJbmRleFRvU25hcChuLHQpO2k+PTAmJnQuYWRkKGkrMSxuZXcgbShuKSwhMSl9fWZpbmRTZWdtZW50SW5kZXhUb1NuYXAodCxlKXtsZXQgbj1yLk1BWF9WQUxVRSxzPS0xO2ZvcihsZXQgaT0wO2k8ZS5zaXplKCktMTtpKyspe2lmKHRoaXMuX3NlZy5wMD1lLmdldChpKSx0aGlzLl9zZWcucDE9ZS5nZXQoaSsxKSx0aGlzLl9zZWcucDAuZXF1YWxzMkQodCl8fHRoaXMuX3NlZy5wMS5lcXVhbHMyRCh0KSl7aWYodGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpY29udGludWU7cmV0dXJuLTF9Y29uc3Qgcj10aGlzLl9zZWcuZGlzdGFuY2UodCk7cjx0aGlzLl9zbmFwVG9sZXJhbmNlJiZyPG4mJihuPXIscz1pKX1yZXR1cm4gc31zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0KXt0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz10fX1jbGFzcyBscntjb25zdHJ1Y3Rvcigpe2xyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NyY0dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zcmNHZW9tPXR9c3RhdGljIHNuYXAodCxlLG4pe2NvbnN0IHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksaT1uZXcgbHIodCk7c1swXT1pLnNuYXBUbyhlLG4pO2NvbnN0IHI9bmV3IGxyKGUpO3JldHVybiBzWzFdPXIuc25hcFRvKHNbMF0sbiksc31zdGF0aWMgY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPWxyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKHQpO2NvbnN0IG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpO2lmKG4uZ2V0VHlwZSgpPT09d3QuRklYRUQpe2NvbnN0IHQ9MS9uLmdldFNjYWxlKCkqMi8xLjQxNTt0PmUmJihlPXQpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gTWF0aC5taW4obHIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHQpLGxyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShlKSl9fXN0YXRpYyBjb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiBNYXRoLm1pbihlLmdldEhlaWdodCgpLGUuZ2V0V2lkdGgoKSkqbHIuU05BUF9QUkVDSVNJT05fRkFDVE9SfXN0YXRpYyBzbmFwVG9TZWxmKHQsZSxuKXtyZXR1cm4gbmV3IGxyKHQpLnNuYXBUb1NlbGYoZSxuKX1zbmFwVG8odCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpO3JldHVybiBuZXcgYXIoZSxuKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSl9c25hcFRvU2VsZih0LGUpe2NvbnN0IG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5fc3JjR2VvbSkscz1uZXcgYXIodCxuLCEwKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSk7bGV0IGk9cztyZXR1cm4gZSYmSShpLGl0KSYmKGk9cy5idWZmZXIoMCkpLGl9Y29tcHV0ZVNuYXBUb2xlcmFuY2UodCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpLzEwfWV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBhdCxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyllLmFkZChuW3RdKTtyZXR1cm4gZS50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgodCl7bGV0IGU9ci5NQVhfVkFMVUU7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl7Y29uc3Qgcz10W25dLmRpc3RhbmNlKHRbbisxXSk7czxlJiYoZT1zKX1yZXR1cm4gZX19bHIuU05BUF9QUkVDSVNJT05fRkFDVE9SPTFlLTk7Y2xhc3MgYXIgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksYXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuX3NuYXBQdHM9bnVsbCx0aGlzLl9pc1NlbGZTbmFwPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9zbmFwVG9sZXJhbmNlPXQsdGhpcy5fc25hcFB0cz1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3NuYXBUb2xlcmFuY2U9dCx0aGlzLl9zbmFwUHRzPWUsdGhpcy5faXNTZWxmU25hcD1ufX1zbmFwTGluZSh0LGUpe2NvbnN0IG49bmV3IG9yKHQsdGhpcy5fc25hcFRvbGVyYW5jZSk7cmV0dXJuIG4uc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModGhpcy5faXNTZWxmU25hcCksbi5zbmFwVG8oZSl9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxzPXRoaXMuc25hcExpbmUobix0aGlzLl9zbmFwUHRzKTtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfX12YXIgY3I9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlTbmFwcGVyOmxyLExpbmVTdHJpbmdTbmFwcGVyOm9yfSk7Y2xhc3MgaHJ7Y29uc3RydWN0b3IoKXtoci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9kYXRhPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fZGF0YT1lfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0c31zaXplKCl7cmV0dXJuIHRoaXMuX3B0cy5sZW5ndGh9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzW3RdfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGgtMV0pfWdldFNlZ21lbnRPY3RhbnQodCl7cmV0dXJuIHQ9PT10aGlzLl9wdHMubGVuZ3RoLTE/LTE6VXMub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyhuZXcgbXQodGhpcy5fcHRzKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hzXX19Y2xhc3MgdXJ7Y29uc3RydWN0b3IoKXt1ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5PSExLHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zPSEwLHRoaXMuX2lzSW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seT0hMSx0aGlzLl9saT1udWxsLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPW51bGwsdGhpcy5faW50U2VnbWVudHM9bnVsbCx0aGlzLl9pbnRlcnNlY3Rpb25zPW5ldyBMLHRoaXMuX2ludGVyc2VjdGlvbkNvdW50PTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj1udWxsfXN0YXRpYyBjcmVhdGVBbGxJbnRlcnNlY3Rpb25zRmluZGVyKHQpe2NvbnN0IGU9bmV3IHVyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlfXN0YXRpYyBpc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzNdO3JldHVybighYXJndW1lbnRzWzJdfHwhbikmJiEhdC5lcXVhbHMyRChlKX1pZig4PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV0sbz1hcmd1bWVudHNbNl0sbD1hcmd1bWVudHNbN107cmV0dXJuISF1ci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKHQsbixpLG8pfHwoISF1ci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKHQscyxpLGwpfHwoISF1ci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKGUsbixyLG8pfHwhIXVyLmlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24oZSxzLHIsbCkpKX19c3RhdGljIGNyZWF0ZUludGVyaW9ySW50ZXJzZWN0aW9uQ291bnRlcih0KXtjb25zdCBlPW5ldyB1cih0KTtyZXR1cm4gZS5zZXRJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5KCEwKSxlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEtlZXBJbnRlcnNlY3Rpb25zKCExKSxlfXN0YXRpYyBjcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyKHQpe2NvbnN0IGU9bmV3IHVyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEtlZXBJbnRlcnNlY3Rpb25zKCExKSxlfXN0YXRpYyBpc0VuZFNlZ21lbnQodCxlKXtyZXR1cm4gMD09PWV8fGU+PXQuc2l6ZSgpLTJ9c3RhdGljIGNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlcih0KXtyZXR1cm4gbmV3IHVyKHQpfXN0YXRpYyBjcmVhdGVJbnRlcmlvckludGVyc2VjdGlvbnNGaW5kZXIodCl7Y29uc3QgZT1uZXcgdXIodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuc2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seSghMCksZX1zZXRDaGVja0VuZFNlZ21lbnRzT25seSh0KXt0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5PXR9Z2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKXtyZXR1cm4gdGhpcy5faW50U2VnbWVudHN9Y291bnQoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uQ291bnR9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25zfXNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9c2V0S2VlcEludGVyc2VjdGlvbnModCl7dGhpcy5fa2VlcEludGVyc2VjdGlvbnM9dH1nZXRJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYoIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zJiZ0aGlzLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiBudWxsO2NvbnN0IGk9dD09PW47aWYoaSYmZT09PXMpcmV0dXJuIG51bGw7aWYodGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seSl7aWYoISh1ci5pc0VuZFNlZ21lbnQodCxlKXx8dXIuaXNFbmRTZWdtZW50KG4scykpKXJldHVybiBudWxsfWNvbnN0IHI9dC5nZXRDb29yZGluYXRlKGUpLG89dC5nZXRDb29yZGluYXRlKGUrMSksbD1uLmdldENvb3JkaW5hdGUocyksYT1uLmdldENvb3JkaW5hdGUocysxKSxjPTA9PT1lLGg9ZSsyPT09dC5zaXplKCksdT0wPT09cyxnPXMrMj09PW4uc2l6ZSgpO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocixvLGwsYSk7Y29uc3QgZD10aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpO2xldCBfPSExO2lmKCF0aGlzLl9pc0ludGVyaW9ySW50ZXJzZWN0aW9uc09ubHkpe189IShpJiZNYXRoLmFicyhzLWUpPD0xKSYmdXIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbihyLG8sbCxhLGMsaCx1LGcpfShkfHxfKSYmKHRoaXMuX2ludFNlZ21lbnRzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX2ludFNlZ21lbnRzWzBdPXIsdGhpcy5faW50U2VnbWVudHNbMV09byx0aGlzLl9pbnRTZWdtZW50c1syXT1sLHRoaXMuX2ludFNlZ21lbnRzWzNdPWEsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApLHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zJiZ0aGlzLl9pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiksdGhpcy5faW50ZXJzZWN0aW9uQ291bnQrKyl9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMmJm51bGwhPT10aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1zZXRJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5KHQpe3RoaXMuX2lzSW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seT10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltSaV19fWNsYXNzIGdye2NvbnN0cnVjdG9yKCl7Z3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX3NlZ1N0cmluZ3M9bnVsbCx0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLl9zZWdJbnQ9bnVsbCx0aGlzLl9pc1ZhbGlkPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZ1N0cmluZ3M9dH1zdGF0aWMgY29tcHV0ZUludGVyc2VjdGlvbnModCl7Y29uc3QgZT1uZXcgZ3IodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuaXNWYWxpZCgpLGUuZ2V0SW50ZXJzZWN0aW9ucygpfWV4ZWN1dGUoKXtpZihudWxsIT09dGhpcy5fc2VnSW50KXJldHVybiBudWxsO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKX1nZXRJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25zKCl9aXNWYWxpZCgpe3JldHVybiB0aGlzLmV4ZWN1dGUoKSx0aGlzLl9pc1ZhbGlkfXNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9Y2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKXt0aGlzLl9pc1ZhbGlkPSEwLHRoaXMuX3NlZ0ludD1uZXcgdXIodGhpcy5fbGkpLHRoaXMuX3NlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyk7Y29uc3QgdD1uZXcgdGk7aWYodC5zZXRTZWdtZW50SW50ZXJzZWN0b3IodGhpcy5fc2VnSW50KSx0LmNvbXB1dGVOb2Rlcyh0aGlzLl9zZWdTdHJpbmdzKSx0aGlzLl9zZWdJbnQuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIHRoaXMuX2lzVmFsaWQ9ITEsbnVsbH1jaGVja1ZhbGlkKCl7aWYodGhpcy5leGVjdXRlKCksIXRoaXMuX2lzVmFsaWQpdGhyb3cgbmV3IGlzKHRoaXMuZ2V0RXJyb3JNZXNzYWdlKCksdGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvbigpKX1nZXRFcnJvck1lc3NhZ2UoKXtpZih0aGlzLl9pc1ZhbGlkKXJldHVyblwibm8gaW50ZXJzZWN0aW9ucyBmb3VuZFwiO2NvbnN0IHQ9dGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7cmV0dXJuXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gXCIrV3QudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSkrXCIgYW5kIFwiK1d0LnRvTGluZVN0cmluZyh0WzJdLHRbM10pfX1jbGFzcyBkcntjb25zdHJ1Y3Rvcigpe2RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX252PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbnY9bmV3IGdyKGRyLnRvU2VnbWVudFN0cmluZ3ModCkpfXN0YXRpYyB0b1NlZ21lbnRTdHJpbmdzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IGhyKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSl9cmV0dXJuIGV9c3RhdGljIGNoZWNrVmFsaWQodCl7bmV3IGRyKHQpLmNoZWNrVmFsaWQoKX1jaGVja1ZhbGlkKCl7dGhpcy5fbnYuY2hlY2tWYWxpZCgpfX1jbGFzcyBfcntjb25zdHJ1Y3Rvcigpe19yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX29wPW51bGwsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5fcHRMb2NhdG9yPW51bGwsdGhpcy5fbGluZUVkZ2VzTGlzdD1uZXcgTCx0aGlzLl9yZXN1bHRMaW5lTGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9vcD10LHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1lLHRoaXMuX3B0TG9jYXRvcj1ufWNvbGxlY3RMaW5lcyh0KXtmb3IobGV0IGU9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuY29sbGVjdExpbmVFZGdlKG4sdCx0aGlzLl9saW5lRWRnZXNMaXN0KSx0aGlzLmNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZShuLHQsdGhpcy5fbGluZUVkZ2VzTGlzdCl9fWxhYmVsSXNvbGF0ZWRMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX29wLmdldEFyZ0dlb21ldHJ5KGUpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX1idWlsZCh0KXtyZXR1cm4gdGhpcy5maW5kQ292ZXJlZExpbmVFZGdlcygpLHRoaXMuY29sbGVjdExpbmVzKHQpLHRoaXMuYnVpbGRMaW5lcyh0KSx0aGlzLl9yZXN1bHRMaW5lTGlzdH1jb2xsZWN0TGluZUVkZ2UodCxlLG4pe2NvbnN0IHM9dC5nZXRMYWJlbCgpLGk9dC5nZXRFZGdlKCk7dC5pc0xpbmVFZGdlKCkmJih0LmlzVmlzaXRlZCgpfHwhd3IuaXNSZXN1bHRPZk9wKHMsZSl8fGkuaXNDb3ZlcmVkKCl8fChuLmFkZChpKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpfWZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5maW5kQ292ZXJlZExpbmVFZGdlcygpfWZvcihsZXQgdD10aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldEVkZ2UoKTtpZihlLmlzTGluZUVkZ2UoKSYmIW4uaXNDb3ZlcmVkU2V0KCkpe2NvbnN0IHQ9dGhpcy5fb3AuaXNDb3ZlcmVkQnlBKGUuZ2V0Q29vcmRpbmF0ZSgpKTtuLnNldENvdmVyZWQodCl9fX1sYWJlbElzb2xhdGVkTGluZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldExhYmVsKCk7dC5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKHQsMCk6dGhpcy5sYWJlbElzb2xhdGVkTGluZSh0LDEpKX19YnVpbGRMaW5lcyh0KXtmb3IobGV0IHQ9dGhpcy5fbGluZUVkZ2VzTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fcmVzdWx0TGluZUxpc3QuYWRkKG4pLGUuc2V0SW5SZXN1bHQoITApfX1jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UodCxlLG4pe2NvbnN0IHM9dC5nZXRMYWJlbCgpO3JldHVybiB0LmlzTGluZUVkZ2UoKXx8dC5pc1Zpc2l0ZWQoKXx8dC5pc0ludGVyaW9yQXJlYUVkZ2UoKXx8dC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpP251bGw6KGcuaXNUcnVlKCEodC5pc0luUmVzdWx0KCl8fHQuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKXx8IXQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSksdm9pZCh3ci5pc1Jlc3VsdE9mT3AocyxlKSYmZT09PXdyLklOVEVSU0VDVElPTiYmKG4uYWRkKHQuZ2V0RWRnZSgpKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpKX19Y2xhc3MgcHJ7Y29uc3RydWN0b3IoKXtwci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vcD1udWxsLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3Jlc3VsdFBvaW50TGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9vcD10LHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1lfWZpbHRlckNvdmVyZWROb2RlVG9Qb2ludCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKCF0aGlzLl9vcC5pc0NvdmVyZWRCeUxBKGUpKXtjb25zdCB0PXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKTt0aGlzLl9yZXN1bHRQb2ludExpc3QuYWRkKHQpfX1leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYoIW4uaXNJblJlc3VsdCgpJiYoIW4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpJiYoMD09PW4uZ2V0RWRnZXMoKS5nZXREZWdyZWUoKXx8dD09PXdyLklOVEVSU0VDVElPTikpKXtjb25zdCBlPW4uZ2V0TGFiZWwoKTt3ci5pc1Jlc3VsdE9mT3AoZSx0KSYmdGhpcy5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQobil9fX1idWlsZCh0KXtyZXR1cm4gdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpLHRoaXMuX3Jlc3VsdFBvaW50TGlzdH19Y2xhc3MgbXJ7Y29uc3RydWN0b3IoKXt0aGlzLl9pc0ZpcnN0PSEwLHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50PTUzLHRoaXMuX2NvbW1vbkJpdHM9bmV3IGksdGhpcy5fY29tbW9uU2lnbkV4cD1udWxsfWdldENvbW1vbigpe3JldHVybiByLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5fY29tbW9uQml0cyl9YWRkKHQpe2NvbnN0IGU9ci5kb3VibGVUb0xvbmdCaXRzKHQpO2lmKHRoaXMuX2lzRmlyc3QpcmV0dXJuIHRoaXMuX2NvbW1vbkJpdHM9ZSx0aGlzLl9jb21tb25TaWduRXhwPW1yLnNpZ25FeHBCaXRzKHRoaXMuX2NvbW1vbkJpdHMpLHRoaXMuX2lzRmlyc3Q9ITEsbnVsbDtpZihtci5zaWduRXhwQml0cyhlKSE9PXRoaXMuX2NvbW1vblNpZ25FeHApcmV0dXJuIHRoaXMuX2NvbW1vbkJpdHMuaGlnaD0wLHRoaXMuX2NvbW1vbkJpdHMubG93PTAsbnVsbDt0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudD1tci5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHRoaXMuX2NvbW1vbkJpdHMsZSksdGhpcy5fY29tbW9uQml0cz1tci56ZXJvTG93ZXJCaXRzKHRoaXMuX2NvbW1vbkJpdHMsNjQtKDEyK3RoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50KSl9dG9TdHJpbmcoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1yLmxvbmdCaXRzVG9Eb3VibGUodCksbj1cIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIitpLnRvQmluYXJ5U3RyaW5nKHQpLHM9bi5zdWJzdHJpbmcobi5sZW5ndGgtNjQpO3JldHVybiBzLnN1YnN0cmluZygwLDEpK1wiICBcIitzLnN1YnN0cmluZygxLDEyKStcIihleHApIFwiK3Muc3Vic3RyaW5nKDEyKStcIiBbIFwiK2UrXCIgXVwifX1nZXRDbGFzcygpe3JldHVybiBtcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX1zdGF0aWMgZ2V0Qml0KHQsZSl7Y29uc3Qgbj0xPDxlJTMyO3JldHVybiBlPDMyPzAhPSh0LmxvdyZuKT8xOjA6MCE9KHQuaGlnaCZuKT8xOjB9c3RhdGljIHNpZ25FeHBCaXRzKHQpe3JldHVybiB0LmhpZ2g+Pj4yMH1zdGF0aWMgemVyb0xvd2VyQml0cyh0LGUpe2xldCBuPVwibG93XCI7aWYoZT4zMiYmKHQubG93PTAsZSU9MzIsbj1cImhpZ2hcIiksZT4wKXtjb25zdCBzPWU8MzI/figoMTw8ZSktMSk6MDt0W25dJj1zfXJldHVybiB0fXN0YXRpYyBudW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHQsZSl7bGV0IG49MDtmb3IobGV0IHM9NTI7cz49MDtzLS0pe2lmKG1yLmdldEJpdCh0LHMpIT09bXIuZ2V0Qml0KGUscykpcmV0dXJuIG47bisrfXJldHVybiA1Mn19Y2xhc3MgZnJ7Y29uc3RydWN0b3IoKXtmci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb21tb25Db29yZD1udWxsLHRoaXMuX2NjRmlsdGVyPW5ldyB5cn1hZGRDb21tb25CaXRzKHQpe2NvbnN0IGU9bmV3IHhyKHRoaXMuX2NvbW1vbkNvb3JkKTt0LmFwcGx5KGUpLHQuZ2VvbWV0cnlDaGFuZ2VkKCl9cmVtb3ZlQ29tbW9uQml0cyh0KXtpZigwPT09dGhpcy5fY29tbW9uQ29vcmQueCYmMD09PXRoaXMuX2NvbW1vbkNvb3JkLnkpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgbSh0aGlzLl9jb21tb25Db29yZCk7ZS54PS1lLngsZS55PS1lLnk7Y29uc3Qgbj1uZXcgeHIoZSk7cmV0dXJuIHQuYXBwbHkobiksdC5nZW9tZXRyeUNoYW5nZWQoKSx0fWdldENvbW1vbkNvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fY29tbW9uQ29vcmR9YWRkKHQpe3QuYXBwbHkodGhpcy5fY2NGaWx0ZXIpLHRoaXMuX2NvbW1vbkNvb3JkPXRoaXMuX2NjRmlsdGVyLmdldENvbW1vbkNvb3JkaW5hdGUoKX19Y2xhc3MgeXJ7Y29uc3RydWN0b3IoKXt5ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb21tb25CaXRzWD1uZXcgbXIsdGhpcy5fY29tbW9uQml0c1k9bmV3IG1yfWZpbHRlcih0KXt0aGlzLl9jb21tb25CaXRzWC5hZGQodC54KSx0aGlzLl9jb21tb25CaXRzWS5hZGQodC55KX1nZXRDb21tb25Db29yZGluYXRlKCl7cmV0dXJuIG5ldyBtKHRoaXMuX2NvbW1vbkJpdHNYLmdldENvbW1vbigpLHRoaXMuX2NvbW1vbkJpdHNZLmdldENvbW1vbigpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSF19fWNsYXNzIHhye2NvbnN0cnVjdG9yKCl7eHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy50cmFucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMudHJhbnM9dH1maWx0ZXIodCxlKXtjb25zdCBuPXQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLnRyYW5zLngscz10LmdldE9yZGluYXRlKGUsMSkrdGhpcy50cmFucy55O3Quc2V0T3JkaW5hdGUoZSwwLG4pLHQuc2V0T3JkaW5hdGUoZSwxLHMpfWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1BdfX1mci5Db21tb25Db29yZGluYXRlRmlsdGVyPXlyLGZyLlRyYW5zbGF0ZXI9eHI7Y2xhc3MgRXJ7Y29uc3RydWN0b3IoKXtFci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX3NuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLl9jYnI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lLHRoaXMuY29tcHV0ZVNuYXBUb2xlcmFuY2UoKX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IEVyKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsd3IuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSx3ci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsd3IuU1lNRElGRkVSRU5DRSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSx3ci5ESUZGRVJFTkNFKX1zZWxmU25hcCh0KXtyZXR1cm4gbmV3IGxyKHQpLnNuYXBUbyh0LHRoaXMuX3NuYXBUb2xlcmFuY2UpfXJlbW92ZUNvbW1vbkJpdHModCl7dGhpcy5fY2JyPW5ldyBmcix0aGlzLl9jYnIuYWRkKHRbMF0pLHRoaXMuX2Nici5hZGQodFsxXSk7Y29uc3QgZT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gZVswXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzBdLmNvcHkoKSksZVsxXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzFdLmNvcHkoKSksZX1wcmVwYXJlUmVzdWx0KHQpe3JldHVybiB0aGlzLl9jYnIuYWRkQ29tbW9uQml0cyh0KSx0fWdldFJlc3VsdEdlb21ldHJ5KHQpe2NvbnN0IGU9dGhpcy5zbmFwKHRoaXMuX2dlb20pLG49d3Iub3ZlcmxheU9wKGVbMF0sZVsxXSx0KTtyZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KG4pfWNoZWNrVmFsaWQodCl7dC5pc1ZhbGlkKCl8fFkub3V0LnByaW50bG4oXCJTbmFwcGVkIGdlb21ldHJ5IGlzIGludmFsaWRcIil9Y29tcHV0ZVNuYXBUb2xlcmFuY2UoKXt0aGlzLl9zbmFwVG9sZXJhbmNlPWxyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0pfXNuYXAodCl7Y29uc3QgZT10aGlzLnJlbW92ZUNvbW1vbkJpdHModCk7cmV0dXJuIGxyLnNuYXAoZVswXSxlWzFdLHRoaXMuX3NuYXBUb2xlcmFuY2UpfX1jbGFzcyBJcntjb25zdHJ1Y3Rvcigpe0lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IElyKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuU1lNRElGRkVSRU5DRSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5ESUZGRVJFTkNFKX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtsZXQgZT1udWxsLG49ITEscz1udWxsO3RyeXtlPXdyLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0sdCk7ITAmJihuPSEwKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O3M9dH1pZighbil0cnl7ZT1Fci5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdLHQpfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBoP3M6dH1yZXR1cm4gZX19Y2xhc3MgTnJ7Y29uc3RydWN0b3IoKXtOci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9saT1uZXcganQsdGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9hcmc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuX2FyZz1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSx0aGlzLl9hcmdbMF09bmV3IGFzKDAsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07TnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsZ24uT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0LmdldFByZWNpc2lvbk1vZGVsKCkuY29tcGFyZVRvKGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk+PTA/dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpOnRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZS5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBhcygwLHQsbiksdGhpcy5fYXJnWzFdPW5ldyBhcygxLGUsbil9fWdldEFyZ0dlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9hcmdbdF0uZ2V0R2VvbWV0cnkoKX1zZXRDb21wdXRhdGlvblByZWNpc2lvbih0KXt0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbD10LHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsKX19Y2xhc3Mgd3IgZXh0ZW5kcyBOcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksd3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRMb2NhdG9yPW5ldyBmbix0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX3Jlc3VsdEdlb209bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2VkZ2VMaXN0PW5ldyBUaSx0aGlzLl9yZXN1bHRQb2x5TGlzdD1uZXcgTCx0aGlzLl9yZXN1bHRMaW5lTGlzdD1uZXcgTCx0aGlzLl9yZXN1bHRQb2ludExpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07TnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX2dyYXBoPW5ldyBscyhuZXcgU2kpLHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgd3IodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gd3IuY3JlYXRlRW1wdHlSZXN1bHQod3IuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBzKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXJldHVybiB3ci5jcmVhdGVFbXB0eVJlc3VsdCh3ci5JTlRFUlNFQ1RJT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe2NvbnN0IG49ZTtyZXR1cm4gY2UubWFwKHQsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltNYXBPcF19bWFwKHQpe3JldHVybiB3ci5pbnRlcnNlY3Rpb24odCxuKX19KX1yZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIHdyLmNyZWF0ZUVtcHR5UmVzdWx0KHdyLlNZTURJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBzKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyByZXN1bHREaW1lbnNpb24odCxlLG4pe2NvbnN0IHM9ZS5nZXREaW1lbnNpb24oKSxpPW4uZ2V0RGltZW5zaW9uKCk7bGV0IHI9LTE7c3dpdGNoKHQpe2Nhc2Ugd3IuSU5URVJTRUNUSU9OOnI9TWF0aC5taW4ocyxpKTticmVhaztjYXNlIHdyLlVOSU9OOnI9TWF0aC5tYXgocyxpKTticmVhaztjYXNlIHdyLkRJRkZFUkVOQ0U6cj1zO2JyZWFrO2Nhc2Ugd3IuU1lNRElGRkVSRU5DRTpyPU1hdGgubWF4KHMsaSl9cmV0dXJuIHJ9c3RhdGljIGNyZWF0ZUVtcHR5UmVzdWx0KHQsZSxuLHMpe2NvbnN0IGk9d3IucmVzdWx0RGltZW5zaW9uKHQsZSxuKTtyZXR1cm4gcy5jcmVhdGVFbXB0eShpKX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiB3ci5jcmVhdGVFbXB0eVJlc3VsdCh3ci5ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBzKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLkRJRkZFUkVOQ0UpfXN0YXRpYyBpc1Jlc3VsdE9mT3AoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldExvY2F0aW9uKDApLHM9dC5nZXRMb2NhdGlvbigxKTtyZXR1cm4gd3IuaXNSZXN1bHRPZk9wKG4scyxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3N3aXRjaCh0PT09UXQuQk9VTkRBUlkmJih0PVF0LklOVEVSSU9SKSxlPT09UXQuQk9VTkRBUlkmJihlPVF0LklOVEVSSU9SKSxuKXtjYXNlIHdyLklOVEVSU0VDVElPTjpyZXR1cm4gdD09PVF0LklOVEVSSU9SJiZlPT09UXQuSU5URVJJT1I7Y2FzZSB3ci5VTklPTjpyZXR1cm4gdD09PVF0LklOVEVSSU9SfHxlPT09UXQuSU5URVJJT1I7Y2FzZSB3ci5ESUZGRVJFTkNFOnJldHVybiB0PT09UXQuSU5URVJJT1ImJmUhPT1RdC5JTlRFUklPUjtjYXNlIHdyLlNZTURJRkZFUkVOQ0U6cmV0dXJuIHQ9PT1RdC5JTlRFUklPUiYmZSE9PVF0LklOVEVSSU9SfHx0IT09UXQuSU5URVJJT1ImJmU9PT1RdC5JTlRFUklPUn1yZXR1cm4hMX19aW5zZXJ0VW5pcXVlRWRnZSh0KXtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe2NvbnN0IG49ZS5nZXRMYWJlbCgpO2xldCBzPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChzPW5ldyBCbih0LmdldExhYmVsKCkpLHMuZmxpcCgpKTtjb25zdCBpPWUuZ2V0RGVwdGgoKTtpLmlzTnVsbCgpJiZpLmFkZChuKSxpLmFkZChzKSxuLm1lcmdlKHMpfWVsc2UgdGhpcy5fZWRnZUxpc3QuYWRkKHQpfWdldEdyYXBoKCl7cmV0dXJuIHRoaXMuX2dyYXBofWNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldFN5bSgpO2UuaXNJblJlc3VsdCgpJiZuLmlzSW5SZXN1bHQoKSYmKGUuc2V0SW5SZXN1bHQoITEpLG4uc2V0SW5SZXN1bHQoITEpKX19aXNDb3ZlcmVkQnlMQSh0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0TGluZUxpc3QpfHwhIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0UG9seUxpc3QpfWNvbXB1dGVHZW9tZXRyeSh0LGUsbixzKXtjb25zdCBpPW5ldyBMO3JldHVybiBpLmFkZEFsbCh0KSxpLmFkZEFsbChlKSxpLmFkZEFsbChuKSxpLmlzRW1wdHkoKT93ci5jcmVhdGVFbXB0eVJlc3VsdChzLHRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLHRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLHRoaXMuX2dlb21GYWN0KTp0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGkpfW1lcmdlU3ltTGFiZWxzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubWVyZ2VTeW1MYWJlbHMoKX19aXNDb3ZlcmVkKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7aWYodGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LGUpIT09UXQuRVhURVJJT1IpcmV0dXJuITB9cmV0dXJuITF9cmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCl7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9dGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bi5pc0NvbGxhcHNlZCgpJiYoZS5yZW1vdmUoKSx0LmFkZChuLmdldENvbGxhcHNlZEVkZ2UoKSkpfXRoaXMuX2VkZ2VMaXN0LmFkZEFsbCh0KX11cGRhdGVOb2RlTGFiZWxsaW5nKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtlLmdldExhYmVsKCkubWVyZ2Uobil9fWdldFJlc3VsdEdlb21ldHJ5KHQpe3JldHVybiB0aGlzLmNvbXB1dGVPdmVybGF5KHQpLHRoaXMuX3Jlc3VsdEdlb219aW5zZXJ0VW5pcXVlRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKHQpfX1jb21wdXRlT3ZlcmxheSh0KXt0aGlzLmNvcHlQb2ludHMoMCksdGhpcy5jb3B5UG9pbnRzKDEpLHRoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLl9hcmdbMV0sdGhpcy5fbGksITApO2NvbnN0IGU9bmV3IEw7dGhpcy5fYXJnWzBdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU3BsaXRFZGdlcyhlKSx0aGlzLmluc2VydFVuaXF1ZUVkZ2VzKGUpLHRoaXMuY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKSx0aGlzLnJlcGxhY2VDb2xsYXBzZWRFZGdlcygpLGRyLmNoZWNrVmFsaWQodGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5jb21wdXRlTGFiZWxsaW5nKCksdGhpcy5sYWJlbEluY29tcGxldGVOb2RlcygpLHRoaXMuZmluZFJlc3VsdEFyZWFFZGdlcyh0KSx0aGlzLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCk7Y29uc3Qgbj1uZXcgcGkodGhpcy5fZ2VvbUZhY3QpO24uYWRkKHRoaXMuX2dyYXBoKSx0aGlzLl9yZXN1bHRQb2x5TGlzdD1uLmdldFBvbHlnb25zKCk7Y29uc3Qgcz1uZXcgX3IodGhpcyx0aGlzLl9nZW9tRmFjdCx0aGlzLl9wdExvY2F0b3IpO3RoaXMuX3Jlc3VsdExpbmVMaXN0PXMuYnVpbGQodCk7Y29uc3QgaT1uZXcgcHIodGhpcyx0aGlzLl9nZW9tRmFjdCx0aGlzLl9wdExvY2F0b3IpO3RoaXMuX3Jlc3VsdFBvaW50TGlzdD1pLmJ1aWxkKHQpLHRoaXMuX3Jlc3VsdEdlb209dGhpcy5jb21wdXRlR2VvbWV0cnkodGhpcy5fcmVzdWx0UG9pbnRMaXN0LHRoaXMuX3Jlc3VsdExpbmVMaXN0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0LHQpfWxhYmVsSW5jb21wbGV0ZU5vZGUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfWNvcHlQb2ludHModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5fZ3JhcGguYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX1maW5kUmVzdWx0QXJlYUVkZ2VzKHQpe2ZvcihsZXQgZT10aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpO3MuaXNBcmVhKCkmJiFuLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZ3ci5pc1Jlc3VsdE9mT3Aocy5nZXRMb2NhdGlvbigwLGJuLlJJR0hUKSxzLmdldExvY2F0aW9uKDEsYm4uUklHSFQpLHQpJiZuLnNldEluUmVzdWx0KCEwKX19Y29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKXtmb3IobGV0IHQ9dGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCkscz1lLmdldERlcHRoKCk7aWYoIXMuaXNOdWxsKCkpe3Mubm9ybWFsaXplKCk7Zm9yKGxldCB0PTA7dDwyO3QrKyluLmlzTnVsbCh0KXx8IW4uaXNBcmVhKCl8fHMuaXNOdWxsKHQpfHwoMD09PXMuZ2V0RGVsdGEodCk/bi50b0xpbmUodCk6KGcuaXNUcnVlKCFzLmlzTnVsbCh0LGJuLkxFRlQpLFwiZGVwdGggb2YgTEVGVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHQsYm4uTEVGVCxzLmdldExvY2F0aW9uKHQsYm4uTEVGVCkpLGcuaXNUcnVlKCFzLmlzTnVsbCh0LGJuLlJJR0hUKSxcImRlcHRoIG9mIFJJR0hUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24odCxibi5SSUdIVCxzLmdldExvY2F0aW9uKHQsYm4uUklHSFQpKSkpfX19Y29tcHV0ZUxhYmVsbGluZygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5fYXJnKX10aGlzLm1lcmdlU3ltTGFiZWxzKCksdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCl9bGFiZWxJbmNvbXBsZXRlTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTtlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShlLDApOnRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShlLDEpKSxlLmdldEVkZ2VzKCkudXBkYXRlTGFiZWxsaW5nKG4pfX1pc0NvdmVyZWRCeUEodCl7cmV0dXJuISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0KX19d3IuSU5URVJTRUNUSU9OPTEsd3IuVU5JT049Mix3ci5ESUZGRVJFTkNFPTMsd3IuU1lNRElGRkVSRU5DRT00O3ZhciBDcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxzbmFwOmNyLE92ZXJsYXlPcDp3cn0pO2NsYXNzIFNyIGV4dGVuZHMgSGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLFNyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2VkZ2VSaW5nPW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2xhYmVsPS0xO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO0hpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4scyl9Z2V0TmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fWlzSW5SaW5nKCl7cmV0dXJuIG51bGwhPT10aGlzLl9lZGdlUmluZ31zZXRSaW5nKHQpe3RoaXMuX2VkZ2VSaW5nPXR9c2V0TGFiZWwodCl7dGhpcy5fbGFiZWw9dH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1nZXRSaW5nKCl7cmV0dXJuIHRoaXMuX2VkZ2VSaW5nfX1jbGFzcyBMciBleHRlbmRzIFppe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxMci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fWdldExpbmUoKXtyZXR1cm4gdGhpcy5fbGluZX19Y2xhc3MgVHJ7Y29uc3RydWN0b3IoKXtUci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bmV3IEx0LHRoaXMuX2dlb21HcmFwaD1udWxsLHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fXN0YXRpYyBmaW5kRGlmZmVyZW50UG9pbnQodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZSkpcmV0dXJuIHRbbl07cmV0dXJuIG51bGx9dmlzaXRJbnRlcmlvclJpbmcodCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxzPW5bMF0saT1Uci5maW5kRGlmZmVyZW50UG9pbnQobixzKSxyPWUuZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24ocyxpKSxvPWUuZmluZEVkZ2VFbmQocik7bGV0IGw9bnVsbDtvLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxibi5SSUdIVCk9PT1RdC5JTlRFUklPUj9sPW86by5nZXRTeW0oKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsYm4uUklHSFQpPT09UXQuSU5URVJJT1ImJihsPW8uZ2V0U3ltKCkpLGcuaXNUcnVlKG51bGwhPT1sLFwidW5hYmxlIHRvIGZpbmQgZGlyRWRnZSB3aXRoIEludGVyaW9yIG9uIFJIU1wiKSx0aGlzLnZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyhsKX12aXNpdFNoZWxsSW50ZXJpb3JzKHQsZSl7aWYodCBpbnN0YW5jZW9mIHJ0KXtjb25zdCBuPXQ7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfWlmKHQgaW5zdGFuY2VvZiB5dCl7Y29uc3Qgbj10O2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKHQpO3RoaXMudmlzaXRJbnRlcmlvclJpbmcocy5nZXRFeHRlcmlvclJpbmcoKSxlKX19fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fZGlzY29ubmVjdGVkUmluZ2Nvb3JkfXNldEludGVyaW9yRWRnZXNJblJlc3VsdCh0KXtmb3IobGV0IGU9dC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGJuLlJJR0hUKT09PVF0LklOVEVSSU9SJiZ0LnNldEluUmVzdWx0KCEwKX19dmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzKHQpe2NvbnN0IGU9dDtsZXQgbj10O2Rve2cuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBEaXJlY3RlZCBFZGdlXCIpLG4uc2V0VmlzaXRlZCghMCksbj1uLmdldE5leHQoKX13aGlsZShuIT09ZSl9YnVpbGRFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzSW5SZXN1bHQoKSYmbnVsbD09PXQuZ2V0RWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgX2kodCx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO24ubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7Y29uc3Qgcz1uLmJ1aWxkTWluaW1hbFJpbmdzKCk7ZS5hZGRBbGwocyl9fXJldHVybiBlfWhhc1VudmlzaXRlZFNoZWxsRWRnZSh0KXtmb3IobGV0IGU9MDtlPHQuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10LmdldChlKTtpZihuLmlzSG9sZSgpKWNvbnRpbnVlO2NvbnN0IHM9bi5nZXRFZGdlcygpO2xldCBpPXMuZ2V0KDApO2lmKGkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGJuLlJJR0hUKT09PVF0LklOVEVSSU9SKWZvcihsZXQgdD0wO3Q8cy5zaXplKCk7dCsrKWlmKGk9cy5nZXQodCksIWkuaXNWaXNpdGVkKCkpcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZD1pLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX1pc0ludGVyaW9yc0Nvbm5lY3RlZCgpe2NvbnN0IHQ9bmV3IEw7dGhpcy5fZ2VvbUdyYXBoLmNvbXB1dGVTcGxpdEVkZ2VzKHQpO2NvbnN0IGU9bmV3IGxzKG5ldyBTaSk7ZS5hZGRFZGdlcyh0KSx0aGlzLnNldEludGVyaW9yRWRnZXNJblJlc3VsdChlKSxlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7Y29uc3Qgbj10aGlzLmJ1aWxkRWRnZVJpbmdzKGUuZ2V0RWRnZUVuZHMoKSk7cmV0dXJuIHRoaXMudmlzaXRTaGVsbEludGVyaW9ycyh0aGlzLl9nZW9tR3JhcGguZ2V0R2VvbWV0cnkoKSxlKSwhdGhpcy5oYXNVbnZpc2l0ZWRTaGVsbEVkZ2Uobil9fWNsYXNzIFJye2NyZWF0ZUVkZ2VFbmRGb3JOZXh0KHQsZSxuLHMpe2NvbnN0IGk9bi5zZWdtZW50SW5kZXgrMTtpZihpPj10LmdldE51bVBvaW50cygpJiZudWxsPT09cylyZXR1cm4gbnVsbDtsZXQgcj10LmdldENvb3JkaW5hdGUoaSk7bnVsbCE9PXMmJnMuc2VnbWVudEluZGV4PT09bi5zZWdtZW50SW5kZXgmJihyPXMuY29vcmQpO2NvbnN0IG89bmV3IHNzKHQsbi5jb29yZCxyLG5ldyBCbih0LmdldExhYmVsKCkpKTtlLmFkZChvKX1jcmVhdGVFZGdlRW5kRm9yUHJldih0LGUsbixzKXtsZXQgaT1uLnNlZ21lbnRJbmRleDtpZigwPT09bi5kaXN0KXtpZigwPT09aSlyZXR1cm4gbnVsbDtpLS19bGV0IHI9dC5nZXRDb29yZGluYXRlKGkpO251bGwhPT1zJiZzLnNlZ21lbnRJbmRleD49aSYmKHI9cy5jb29yZCk7Y29uc3Qgbz1uZXcgQm4odC5nZXRMYWJlbCgpKTtvLmZsaXAoKTtjb25zdCBsPW5ldyBzcyh0LG4uY29vcmQscixvKTtlLmFkZChsKX1jb21wdXRlRWRnZUVuZHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtmb3IobGV0IG49dDtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5jb21wdXRlRWRnZUVuZHModCxlKX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCk7bi5hZGRFbmRwb2ludHMoKTtjb25zdCBzPW4uaXRlcmF0b3IoKTtsZXQgaT1udWxsLHI9bnVsbDtpZighcy5oYXNOZXh0KCkpcmV0dXJuIG51bGw7bGV0IG89cy5uZXh0KCk7ZG97aT1yLHI9byxvPW51bGwscy5oYXNOZXh0KCkmJihvPXMubmV4dCgpKSxudWxsIT09ciYmKHRoaXMuY3JlYXRlRWRnZUVuZEZvclByZXYodCxlLHIsaSksdGhpcy5jcmVhdGVFZGdlRW5kRm9yTmV4dCh0LGUscixvKSl9d2hpbGUobnVsbCE9PXIpfX19Y2xhc3MgUHIgZXh0ZW5kcyBzc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZWRnZUVuZHM9bmV3IEwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1ByLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbnVsbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtzcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQuZ2V0RWRnZSgpLHQuZ2V0Q29vcmRpbmF0ZSgpLHQuZ2V0RGlyZWN0ZWRDb29yZGluYXRlKCksbmV3IEJuKHQuZ2V0TGFiZWwoKSkpLHRoaXMuaW5zZXJ0KHQpfX1pbnNlcnQodCl7dGhpcy5fZWRnZUVuZHMuYWRkKHQpfXByaW50KHQpe3QucHJpbnRsbihcIkVkZ2VFbmRCdW5kbGUtLVxceDNlIExhYmVsOiBcIit0aGlzLl9sYWJlbCk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpLHQucHJpbnRsbigpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlRW5kcy5pdGVyYXRvcigpfWdldEVkZ2VFbmRzKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRzfWNvbXB1dGVMYWJlbE9uKHQsZSl7bGV0IG49MCxzPSExO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBpPWUubmV4dCgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7aT09PVF0LkJPVU5EQVJZJiZuKyssaT09PVF0LklOVEVSSU9SJiYocz0hMCl9bGV0IGk9UXQuTk9ORTtzJiYoaT1RdC5JTlRFUklPUiksbj4wJiYoaT1hcy5kZXRlcm1pbmVCb3VuZGFyeShlLG4pKSx0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGkpfWNvbXB1dGVMYWJlbFNpZGUodCxlKXtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzLmdldExhYmVsKCkuaXNBcmVhKCkpe2NvbnN0IG49cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQsZSk7aWYobj09PVF0LklOVEVSSU9SKXJldHVybiB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUsUXQuSU5URVJJT1IpLG51bGw7bj09PVF0LkVYVEVSSU9SJiZ0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUsUXQuRVhURVJJT1IpfX19Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Y29tcHV0ZUxhYmVsU2lkZXModCl7dGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsYm4uTEVGVCksdGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsYm4uUklHSFQpfXVwZGF0ZUlNKHQpe3RzLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLHQpfWNvbXB1dGVMYWJlbCh0KXtsZXQgZT0hMTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmKGU9ITApfXRoaXMuX2xhYmVsPWU/bmV3IEJuKFF0Lk5PTkUsUXQuTk9ORSxRdC5OT05FKTpuZXcgQm4oUXQuTk9ORSk7Zm9yKGxldCBuPTA7bjwyO24rKyl0aGlzLmNvbXB1dGVMYWJlbE9uKG4sdCksZSYmdGhpcy5jb21wdXRlTGFiZWxTaWRlcyhuKX19Y2xhc3MgT3IgZXh0ZW5kcyB3aXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9dXBkYXRlSU0odCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnVwZGF0ZUlNKHQpfX1pbnNlcnQodCl7bGV0IGU9dGhpcy5fZWRnZU1hcC5nZXQodCk7bnVsbD09PWU/KGU9bmV3IFByKHQpLHRoaXMuaW5zZXJ0RWRnZUVuZCh0LGUpKTplLmluc2VydCh0KX19Y2xhc3MgdnIgZXh0ZW5kcyBlc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZXMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfXVwZGF0ZUlNRnJvbUVkZ2VzKHQpe3RoaXMuX2VkZ2VzLnVwZGF0ZUlNKHQpfWNvbXB1dGVJTSh0KXt0LnNldEF0TGVhc3RJZlZhbGlkKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDApLHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDEpLDApfX1jbGFzcyBiciBleHRlbmRzIG9ze2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgdnIodCxuZXcgT3IpfX1jbGFzcyBNcntjb25zdHJ1Y3Rvcigpe01yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVzPW5ldyBucyhuZXcgYnIpfWluc2VydEVkZ2VFbmRzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuX25vZGVzLmFkZCh0KX19Z2V0Tm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKCl9Y29weU5vZGVzQW5kTGFiZWxzKHQsZSl7Zm9yKGxldCBuPXQuZ2V0Tm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX25vZGVzLmFkZE5vZGUodC5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKGUsdC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpKX19YnVpbGQodCl7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCwwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscyh0LDApO2NvbnN0IGU9KG5ldyBScikuY29tcHV0ZUVkZ2VFbmRzKHQuZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMoZSl9Y29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQsZSl7Zm9yKGxldCBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLHM9dC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpO2ZvcihsZXQgbj10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCksaT10aGlzLl9ub2Rlcy5hZGROb2RlKHQuY29vcmQpO3M9PT1RdC5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkoZSk6aS5nZXRMYWJlbCgpLmlzTnVsbChlKSYmaS5zZXRMYWJlbChlLFF0LklOVEVSSU9SKX19fX1jbGFzcyBEcntjb25zdHJ1Y3Rvcigpe0RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9nZW9tR3JhcGg9bnVsbCx0aGlzLl9ub2RlR3JhcGg9bmV3IE1yLHRoaXMuX2ludmFsaWRQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fWlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpe2ZvcihsZXQgdD10aGlzLl9ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2lmKCFlLmdldEVkZ2VzKCkuaXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0aGlzLl9nZW9tR3JhcGgpKXJldHVybiB0aGlzLl9pbnZhbGlkUG9pbnQ9ZS5nZXRDb29yZGluYXRlKCkuY29weSgpLCExfXJldHVybiEwfWdldEludmFsaWRQb2ludCgpe3JldHVybiB0aGlzLl9pbnZhbGlkUG9pbnR9aGFzRHVwbGljYXRlUmluZ3MoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Zm9yKGxldCBlPXQubmV4dCgpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodC5nZXRFZGdlRW5kcygpLnNpemUoKT4xKXJldHVybiB0aGlzLl9pbnZhbGlkUG9pbnQ9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZSgwKSwhMH19cmV0dXJuITF9aXNOb2RlQ29uc2lzdGVudEFyZWEoKXtjb25zdCB0PXRoaXMuX2dlb21HcmFwaC5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCEwLCEwKTtyZXR1cm4gdC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5faW52YWxpZFBvaW50PXQuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6KHRoaXMuX25vZGVHcmFwaC5idWlsZCh0aGlzLl9nZW9tR3JhcGgpLHRoaXMuaXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50KCkpfX1jbGFzcyBBcntjb25zdHJ1Y3Rvcigpe0FyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW51bGwsdGhpcy5fcmluZ3M9bmV3IEwsdGhpcy5fdG90YWxFbnY9bmV3IE8sdGhpcy5faW5kZXg9bnVsbCx0aGlzLl9uZXN0ZWRQdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dyYXBoPXR9YnVpbGRJbmRleCgpe3RoaXMuX2luZGV4PW5ldyBicztmb3IobGV0IHQ9MDt0PHRoaXMuX3JpbmdzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fcmluZ3MuZ2V0KHQpLG49ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7dGhpcy5faW5kZXguaW5zZXJ0KG4sZSl9fWdldE5lc3RlZFBvaW50KCl7cmV0dXJuIHRoaXMuX25lc3RlZFB0fWlzTm9uTmVzdGVkKCl7dGhpcy5idWlsZEluZGV4KCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9yaW5ncy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX3JpbmdzLmdldCh0KSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPXRoaXMuX2luZGV4LnF1ZXJ5KGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKyl7Y29uc3QgaT1zLmdldCh0KSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlPT09aSljb250aW51ZTtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpY29udGludWU7Y29uc3Qgbz1Hci5maW5kUHROb3ROb2RlKG4saSx0aGlzLl9ncmFwaCk7aWYobnVsbD09PW8pY29udGludWU7aWYoVWUuaXNJblJpbmcobyxyKSlyZXR1cm4gdGhpcy5fbmVzdGVkUHQ9bywhMX19cmV0dXJuITB9YWRkKHQpe3RoaXMuX3JpbmdzLmFkZCh0KSx0aGlzLl90b3RhbEVudi5leHBhbmRUb0luY2x1ZGUodC5nZXRFbnZlbG9wZUludGVybmFsKCkpfX1jbGFzcyBGcntjb25zdHJ1Y3Rvcigpe0ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2Vycm9yVHlwZT1udWxsLHRoaXMuX3B0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0ZyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9lcnJvclR5cGU9dCxudWxsIT09ZSYmKHRoaXMuX3B0PWUuY29weSgpKX19Z2V0RXJyb3JUeXBlKCl7cmV0dXJuIHRoaXMuX2Vycm9yVHlwZX1nZXRNZXNzYWdlKCl7cmV0dXJuIEZyLmVyck1zZ1t0aGlzLl9lcnJvclR5cGVdfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9dG9TdHJpbmcoKXtsZXQgdD1cIlwiO3JldHVybiBudWxsIT09dGhpcy5fcHQmJih0PVwiIGF0IG9yIG5lYXIgcG9pbnQgXCIrdGhpcy5fcHQpLHRoaXMuZ2V0TWVzc2FnZSgpK3R9fUZyLkVSUk9SPTAsRnIuUkVQRUFURURfUE9JTlQ9MSxGci5IT0xFX09VVFNJREVfU0hFTEw9MixGci5ORVNURURfSE9MRVM9MyxGci5ESVNDT05ORUNURURfSU5URVJJT1I9NCxGci5TRUxGX0lOVEVSU0VDVElPTj01LEZyLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT049NixGci5ORVNURURfU0hFTExTPTcsRnIuRFVQTElDQVRFX1JJTkdTPTgsRnIuVE9PX0ZFV19QT0lOVFM9OSxGci5JTlZBTElEX0NPT1JESU5BVEU9MTAsRnIuUklOR19OT1RfQ0xPU0VEPTExLEZyLmVyck1zZz1bXCJUb3BvbG9neSBWYWxpZGF0aW9uIEVycm9yXCIsXCJSZXBlYXRlZCBQb2ludFwiLFwiSG9sZSBsaWVzIG91dHNpZGUgc2hlbGxcIixcIkhvbGVzIGFyZSBuZXN0ZWRcIixcIkludGVyaW9yIGlzIGRpc2Nvbm5lY3RlZFwiLFwiU2VsZi1pbnRlcnNlY3Rpb25cIixcIlJpbmcgU2VsZi1pbnRlcnNlY3Rpb25cIixcIk5lc3RlZCBzaGVsbHNcIixcIkR1cGxpY2F0ZSBSaW5nc1wiLFwiVG9vIGZldyBkaXN0aW5jdCBwb2ludHMgaW4gZ2VvbWV0cnkgY29tcG9uZW50XCIsXCJJbnZhbGlkIENvb3JkaW5hdGVcIixcIlJpbmcgaXMgbm90IGNsb3NlZFwiXTtjbGFzcyBHcntjb25zdHJ1Y3Rvcigpe0dyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BhcmVudEdlb21ldHJ5PW51bGwsdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD0hMSx0aGlzLl92YWxpZEVycj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudEdlb21ldHJ5PXR9c3RhdGljIGZpbmRQdE5vdE5vZGUodCxlLG4pe2NvbnN0IHM9bi5maW5kRWRnZShlKS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPXRbZV07aWYoIXMuaXNJbnRlcnNlY3Rpb24obikpcmV0dXJuIG59cmV0dXJuIG51bGx9c3RhdGljIGlzVmFsaWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe3JldHVybiBuZXcgR3IoYXJndW1lbnRzWzBdKS5pc1ZhbGlkKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hci5pc05hTih0LngpJiYoIXIuaXNJbmZpbml0ZSh0LngpJiYoIXIuaXNOYU4odC55KSYmIXIuaXNJbmZpbml0ZSh0LnkpKSl9fWNoZWNrSW52YWxpZENvb3JkaW5hdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIUdyLmlzVmFsaWQodFtlXSkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5JTlZBTElEX0NPT1JESU5BVEUsdFtlXSksbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWNoZWNrSG9sZXNOb3ROZXN0ZWQodCxlKXtpZih0LmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiBudWxsO2NvbnN0IG49bmV3IEFyKGUpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IHM9dC5nZXRJbnRlcmlvclJpbmdOKGUpO3MuaXNFbXB0eSgpfHxuLmFkZChzKX1uLmlzTm9uTmVzdGVkKCl8fCh0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuTkVTVEVEX0hPTEVTLG4uZ2V0TmVzdGVkUG9pbnQoKSkpfWNoZWNrQ29uc2lzdGVudEFyZWEodCl7Y29uc3QgZT1uZXcgRHIodCk7aWYoIWUuaXNOb2RlQ29uc2lzdGVudEFyZWEoKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLlNFTEZfSU5URVJTRUNUSU9OLGUuZ2V0SW52YWxpZFBvaW50KCkpLG51bGw7ZS5oYXNEdXBsaWNhdGVSaW5ncygpJiYodGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLkRVUExJQ0FURV9SSU5HUyxlLmdldEludmFsaWRQb2ludCgpKSl9aXNWYWxpZCgpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5fcGFyZW50R2VvbWV0cnkpLG51bGw9PT10aGlzLl92YWxpZEVycn1jaGVja1NoZWxsSW5zaWRlSG9sZSh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGVzKCkscj1Hci5maW5kUHROb3ROb2RlKHMsZSxuKTtpZihudWxsIT09cil7aWYoIVVlLmlzSW5SaW5nKHIsaSkpcmV0dXJuIHJ9Y29uc3Qgbz1Hci5maW5kUHROb3ROb2RlKGksdCxuKTtpZihudWxsIT09byl7cmV0dXJuIFVlLmlzSW5SaW5nKG8scyk/bzpudWxsfXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwicG9pbnRzIGluIHNoZWxsIGFuZCBob2xlIGFwcGVhciB0byBiZSBlcXVhbFwiKSxudWxsfWNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3ModCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nKHQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1jaGVja0Nvbm5lY3RlZEludGVyaW9ycyh0KXtjb25zdCBlPW5ldyBUcih0KTtlLmlzSW50ZXJpb3JzQ29ubmVjdGVkKCl8fCh0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuRElTQ09OTkVDVEVEX0lOVEVSSU9SLGUuZ2V0Q29vcmRpbmF0ZSgpKSl9Y2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nKHQpe2NvbnN0IGU9bmV3IGF0O2xldCBuPSEwO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKG4pbj0hMTtlbHNle2lmKGUuY29udGFpbnModC5jb29yZCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5SSU5HX1NFTEZfSU5URVJTRUNUSU9OLHQuY29vcmQpLG51bGw7ZS5hZGQodC5jb29yZCl9fX1jaGVja0hvbGVzSW5TaGVsbCh0LGUpe2lmKHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk8PTApcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldEV4dGVyaW9yUmluZygpLHM9bi5pc0VtcHR5KCksaT1uZXcgemUobik7Zm9yKGxldCByPTA7cjx0LmdldE51bUludGVyaW9yUmluZygpO3IrKyl7Y29uc3Qgbz10LmdldEludGVyaW9yUmluZ04ocik7bGV0IGw9bnVsbDtpZihvLmlzRW1wdHkoKSljb250aW51ZTtpZihsPUdyLmZpbmRQdE5vdE5vZGUoby5nZXRDb29yZGluYXRlcygpLG4sZSksbnVsbD09PWwpcmV0dXJuIG51bGw7aWYoc3x8UXQuRVhURVJJT1I9PT1pLmxvY2F0ZShsKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLkhPTEVfT1VUU0lERV9TSEVMTCxsKSxudWxsfX1jaGVja1Rvb0Zld1BvaW50cyh0KXtpZih0Lmhhc1Rvb0Zld1BvaW50cygpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuVE9PX0ZFV19QT0lOVFMsdC5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbH1nZXRWYWxpZGF0aW9uRXJyb3IoKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMuX3BhcmVudEdlb21ldHJ5KSx0aGlzLl92YWxpZEVycn1jaGVja1ZhbGlkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBldCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB1dCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBndCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgYXMoMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBqdDtlLmNvbXB1dGVTZWxmTm9kZXMobiwhMCwhMCksdGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IGFzKDAsdCk7dGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgYXMoMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Y29uc3QgZT1uZXcgYXMoMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChzLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1mb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQocyxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9aWYodGhpcy5jaGVja1NoZWxsc05vdE5lc3RlZCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBodCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYodGhpcy5jaGVja1ZhbGlkKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX3ZhbGlkRXJyPW51bGwsdC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIGV0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB1dCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZ3QpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mICQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHJ0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB5dCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBodCkpdGhyb3cgbmV3IEsodC5nZXRHZW9tZXRyeVR5cGUoKSk7dGhpcy5jaGVja1ZhbGlkKHQpfX19c2V0U2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQodCl7dGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD10fWNoZWNrU2hlbGxOb3ROZXN0ZWQodCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRFeHRlcmlvclJpbmcoKTtpZihpLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCByPWkuZ2V0Q29vcmRpbmF0ZXMoKSxvPUdyLmZpbmRQdE5vdE5vZGUocyxpLG4pO2lmKG51bGw9PT1vKXJldHVybiBudWxsO2lmKCFVZS5pc0luUmluZyhvLHIpKXJldHVybiBudWxsO2lmKGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk8PTApcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5ORVNURURfU0hFTExTLG8pLG51bGw7bGV0IGw9bnVsbDtmb3IobGV0IHM9MDtzPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXtjb25zdCBpPWUuZ2V0SW50ZXJpb3JSaW5nTihzKTtpZihsPXRoaXMuY2hlY2tTaGVsbEluc2lkZUhvbGUodCxpLG4pLG51bGw9PT1sKXJldHVybiBudWxsfXRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5ORVNURURfU0hFTExTLGwpfWNoZWNrQ2xvc2VkUmluZ3ModCl7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Y2hlY2tDbG9zZWRSaW5nKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKCF0LmlzQ2xvc2VkKCkpe2xldCBlPW51bGw7dC5nZXROdW1Qb2ludHMoKT49MSYmKGU9dC5nZXRDb29yZGluYXRlTigwKSksdGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLlJJTkdfTk9UX0NMT1NFRCxlKX19Y2hlY2tTaGVsbHNOb3ROZXN0ZWQodCxlKXtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKS5nZXRFeHRlcmlvclJpbmcoKTtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7aWYobj09PWkpY29udGludWU7Y29uc3Qgcj10LmdldEdlb21ldHJ5TihpKTtpZih0aGlzLmNoZWNrU2hlbGxOb3ROZXN0ZWQocyxyLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19fX1jbGFzcyBxcntjb25zdHJ1Y3Rvcigpe3FyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9kZUxpc3Q9bmV3IEwsdGhpcy5fbG93ZXN0RWRnZT1udWxsLHRoaXMuX3Jpbmc9bnVsbCx0aGlzLl9sb2NhdG9yPW51bGwsdGhpcy5fcmluZ1B0cz1udWxsLHRoaXMuX2hvbGVzPW51bGwsdGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9pc1Byb2Nlc3NlZD0hMSx0aGlzLl9pc0luY2x1ZGVkU2V0PSExLHRoaXMuX2lzSW5jbHVkZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fXN0YXRpYyBmaW5kRGlyRWRnZXNJblJpbmcodCl7bGV0IGU9dDtjb25zdCBuPW5ldyBMO2Rve24uYWRkKGUpLGU9ZS5nZXROZXh0KCksZy5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZy5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUoZSE9PXQpO3JldHVybiBufXN0YXRpYyBhZGRFZGdlKHQsZSxuKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKW4uYWRkKHRbZV0sITEpO2Vsc2UgZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pbi5hZGQodFtlXSwhMSl9c3RhdGljIGZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0UmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCk7bGV0IGk9bi5nZXRDb29yZGluYXRlTigwKSxyPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLGw9ZS5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKGwuZXF1YWxzKHMpKWNvbnRpbnVlO2lmKCFsLmNvbnRhaW5zKHMpKWNvbnRpbnVlO2k9X3QucHROb3RJbkxpc3Qobi5nZXRDb29yZGluYXRlcygpLGUuZ2V0Q29vcmRpbmF0ZXMoKSk7ZS5pc0luUmluZyhpKSYmKG51bGw9PT1yfHxvLmNvbnRhaW5zKGwpKSYmKHI9ZSxvPXIuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9cmV0dXJuIHJ9aXNJbmNsdWRlZCgpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkfWdldENvb3JkaW5hdGVzKCl7aWYobnVsbD09PXRoaXMuX3JpbmdQdHMpe2NvbnN0IHQ9bmV3IFI7Zm9yKGxldCBlPXRoaXMuX2RlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0RWRnZSgpO3FyLmFkZEVkZ2Uocy5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuLmdldEVkZ2VEaXJlY3Rpb24oKSx0KX10aGlzLl9yaW5nUHRzPXQudG9Db29yZGluYXRlQXJyYXkoKX1yZXR1cm4gdGhpcy5fcmluZ1B0c31pc0luY2x1ZGVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWRTZXR9aXNWYWxpZCgpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksISh0aGlzLl9yaW5nUHRzLmxlbmd0aDw9MykmJih0aGlzLmdldFJpbmcoKSxHci5pc1ZhbGlkKHRoaXMuX3JpbmcpKX1idWlsZCh0KXtsZXQgZT10O2Rve3RoaXMuYWRkKGUpLGUuc2V0UmluZyh0aGlzKSxlPWUuZ2V0TmV4dCgpLGcuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGcuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKGUhPT10KX1pc0luUmluZyh0KXtyZXR1cm4gUXQuRVhURVJJT1IhPT10aGlzLmdldExvY2F0b3IoKS5sb2NhdGUodCl9aXNPdXRlckhvbGUoKXtyZXR1cm4hIXRoaXMuX2lzSG9sZSYmIXRoaXMuaGFzU2hlbGwoKX1nZXRQb2x5Z29uKCl7bGV0IHQ9bnVsbDtpZihudWxsIT09dGhpcy5faG9sZXMpe3Q9bmV3IEFycmF5KHRoaXMuX2hvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLnNpemUoKTtlKyspdFtlXT10aGlzLl9ob2xlcy5nZXQoZSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbih0aGlzLl9yaW5nLHQpfWlzSG9sZSgpe3JldHVybiB0aGlzLl9pc0hvbGV9aXNQcm9jZXNzZWQoKXtyZXR1cm4gdGhpcy5faXNQcm9jZXNzZWR9YWRkSG9sZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9ob2xlcyYmKHRoaXMuX2hvbGVzPW5ldyBMKSx0aGlzLl9ob2xlcy5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFyKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LnNldFNoZWxsKHRoaXMpO2NvbnN0IGU9dC5nZXRSaW5nKCk7bnVsbD09PXRoaXMuX2hvbGVzJiYodGhpcy5faG9sZXM9bmV3IEwpLHRoaXMuX2hvbGVzLmFkZChlKX19c2V0SW5jbHVkZWQodCl7dGhpcy5faXNJbmNsdWRlZD10LHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITB9Z2V0T3V0ZXJIb2xlKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMuX2RlTGlzdC5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX2RlTGlzdC5nZXQodCkuZ2V0U3ltKCkuZ2V0UmluZygpO2lmKGUuaXNPdXRlckhvbGUoKSlyZXR1cm4gZX1yZXR1cm4gbnVsbH1jb21wdXRlSG9sZSgpe2NvbnN0IHQ9dGhpcy5nZXRSaW5nKCk7dGhpcy5faXNIb2xlPXEuaXNDQ1codC5nZXRDb29yZGluYXRlcygpKX1oYXNTaGVsbCgpe3JldHVybiBudWxsIT09dGhpcy5fc2hlbGx9aXNPdXRlclNoZWxsKCl7cmV0dXJuIG51bGwhPT10aGlzLmdldE91dGVySG9sZSgpfWdldExpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLl9yaW5nUHRzKX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcobmV3IG10KHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkpfWdldExvY2F0b3IoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2xvY2F0b3ImJih0aGlzLl9sb2NhdG9yPW5ldyB6ZSh0aGlzLmdldFJpbmcoKSkpLHRoaXMuX2xvY2F0b3J9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5pc0hvbGUoKT90aGlzLl9zaGVsbDp0aGlzfWFkZCh0KXt0aGlzLl9kZUxpc3QuYWRkKHQpfWdldFJpbmcoKXtpZihudWxsIT09dGhpcy5fcmluZylyZXR1cm4gdGhpcy5fcmluZzt0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5fcmluZ1B0cy5sZW5ndGg8MyYmWS5vdXQucHJpbnRsbih0aGlzLl9yaW5nUHRzKTt0cnl7dGhpcy5fcmluZz10aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5fcmluZ1B0cyl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgdDtZLm91dC5wcmludGxuKHRoaXMuX3JpbmdQdHMpfXJldHVybiB0aGlzLl9yaW5nfXVwZGF0ZUluY2x1ZGVkKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMuX2RlTGlzdC5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX2RlTGlzdC5nZXQodCkuZ2V0U3ltKCkuZ2V0UmluZygpLmdldFNoZWxsKCk7aWYobnVsbCE9PWUmJmUuaXNJbmNsdWRlZFNldCgpKXJldHVybiB0aGlzLnNldEluY2x1ZGVkKCFlLmlzSW5jbHVkZWQoKSksbnVsbH19c2V0U2hlbGwodCl7dGhpcy5fc2hlbGw9dH1zZXRQcm9jZXNzZWQodCl7dGhpcy5faXNQcm9jZXNzZWQ9dH19cXIuRW52ZWxvcGVDb21wYXJhdG9yPWNsYXNze2NvbXBhcmUodCxlKXtjb25zdCBuPWU7cmV0dXJuIHQuZ2V0UmluZygpLmdldEVudmVsb3BlKCkuY29tcGFyZVRvKG4uZ2V0UmluZygpLmdldEVudmVsb3BlKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19O2NsYXNzIEJyIGV4dGVuZHMgJGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLEJyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZhY3Rvcnk9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9c3RhdGljIGZpbmRMYWJlbGVkRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IEw7bGV0IG49MTtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZih0LmlzTWFya2VkKCkpY29udGludWU7aWYodC5nZXRMYWJlbCgpPj0wKWNvbnRpbnVlO2UuYWRkKHQpO2NvbnN0IGk9cXIuZmluZERpckVkZ2VzSW5SaW5nKHQpO0JyLmxhYmVsKGksbiksbisrfXJldHVybiBlfXN0YXRpYyBnZXREZWdyZWVOb25EZWxldGVkKHQpe2xldCBlPTA7Zm9yKGxldCBuPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5pc01hcmtlZCgpfHxlKyt9cmV0dXJuIGV9c3RhdGljIGRlbGV0ZUFsbEVkZ2VzKHQpe2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldE1hcmtlZCghMCk7Y29uc3Qgbj10LmdldFN5bSgpO251bGwhPT1uJiZuLnNldE1hcmtlZCghMCl9fXN0YXRpYyBsYWJlbCh0LGUpe2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5zZXRMYWJlbChlKX19c3RhdGljIGNvbXB1dGVOZXh0Q1dFZGdlcyh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYoIXQuaXNNYXJrZWQoKSl7aWYobnVsbD09PWUmJihlPXQpLG51bGwhPT1uKXtuLmdldFN5bSgpLnNldE5leHQodCl9bj10fX1pZihudWxsIT09bil7bi5nZXRTeW0oKS5zZXROZXh0KGUpfX1zdGF0aWMgY29tcHV0ZU5leHRDQ1dFZGdlcyh0LGUpe2xldCBuPW51bGwscz1udWxsO2NvbnN0IGk9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCk7Zm9yKGxldCB0PWkuc2l6ZSgpLTE7dD49MDt0LS0pe2NvbnN0IHI9aS5nZXQodCksbz1yLmdldFN5bSgpO2xldCBsPW51bGw7ci5nZXRMYWJlbCgpPT09ZSYmKGw9cik7bGV0IGE9bnVsbDtvLmdldExhYmVsKCk9PT1lJiYoYT1vKSxudWxsPT09bCYmbnVsbD09PWF8fChudWxsIT09YSYmKHM9YSksbnVsbCE9PWwmJihudWxsIT09cyYmKHMuc2V0TmV4dChsKSxzPW51bGwpLG51bGw9PT1uJiYobj1sKSkpfW51bGwhPT1zJiYoZy5pc1RydWUobnVsbCE9PW4pLHMuc2V0TmV4dChuKSl9c3RhdGljIGdldERlZ3JlZSh0LGUpe2xldCBuPTA7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtzLm5leHQoKS5nZXRMYWJlbCgpPT09ZSYmbisrfXJldHVybiBufXN0YXRpYyBmaW5kSW50ZXJzZWN0aW9uTm9kZXModCxlKXtsZXQgbj10LHM9bnVsbDtkb3tjb25zdCBpPW4uZ2V0RnJvbU5vZGUoKTtCci5nZXREZWdyZWUoaSxlKT4xJiYobnVsbD09PXMmJihzPW5ldyBMKSxzLmFkZChpKSksbj1uLmdldE5leHQoKSxnLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxnLmlzVHJ1ZShuPT09dHx8IW4uaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShuIT09dCk7cmV0dXJuIHN9ZmluZEVkZ2VSaW5nKHQpe2NvbnN0IGU9bmV3IHFyKHRoaXMuX2ZhY3RvcnkpO3JldHVybiBlLmJ1aWxkKHQpLGV9Y29tcHV0ZURlcHRoUGFyaXR5KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKDs7KXJldHVybiBudWxsfWNvbXB1dGVOZXh0Q1dFZGdlcygpe2ZvcihsZXQgdD10aGlzLm5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtCci5jb21wdXRlTmV4dENXRWRnZXMoZSl9fWFkZEVkZ2UodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1fdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIG51bGw7Y29uc3Qgbj1lWzBdLHM9ZVtlLmxlbmd0aC0xXSxpPXRoaXMuZ2V0Tm9kZShuKSxyPXRoaXMuZ2V0Tm9kZShzKSxvPW5ldyBTcihpLHIsZVsxXSwhMCksbD1uZXcgU3IocixpLGVbZS5sZW5ndGgtMl0sITEpLGE9bmV3IExyKHQpO2Euc2V0RGlyZWN0ZWRFZGdlcyhvLGwpLHRoaXMuYWRkKGEpfWRlbGV0ZUN1dEVkZ2VzKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxCci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLl9kaXJFZGdlcyk7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9dGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobi5pc01hcmtlZCgpKWNvbnRpbnVlO2NvbnN0IHM9bi5nZXRTeW0oKTtpZihuLmdldExhYmVsKCk9PT1zLmdldExhYmVsKCkpe24uc2V0TWFya2VkKCEwKSxzLnNldE1hcmtlZCghMCk7Y29uc3QgZT1uLmdldEVkZ2UoKTt0LmFkZChlLmdldExpbmUoKSl9fXJldHVybiB0fWdldEVkZ2VSaW5ncygpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksQnIubGFiZWwodGhpcy5fZGlyRWRnZXMsLTEpO2NvbnN0IHQ9QnIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5fZGlyRWRnZXMpO3RoaXMuY29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCk7Y29uc3QgZT1uZXcgTDtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7aWYobi5pc01hcmtlZCgpKWNvbnRpbnVlO2lmKG4uaXNJblJpbmcoKSljb250aW51ZTtjb25zdCBzPXRoaXMuZmluZEVkZ2VSaW5nKG4pO2UuYWRkKHMpfXJldHVybiBlfWdldE5vZGUodCl7bGV0IGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBLaSh0KSx0aGlzLmFkZChlKSksZX1jb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5ncyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TGFiZWwoKSxzPUJyLmZpbmRJbnRlcnNlY3Rpb25Ob2Rlcyh0LG4pO2lmKG51bGwhPT1zKWZvcihsZXQgdD1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0JyLmNvbXB1dGVOZXh0Q0NXRWRnZXMoZSxuKX19fWRlbGV0ZURhbmdsZXMoKXtjb25zdCB0PXRoaXMuZmluZE5vZGVzT2ZEZWdyZWUoMSksZT1uZXcgRXQsbj1uZXcgZW47Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspbi5wdXNoKGUubmV4dCgpKTtmb3IoOyFuLmlzRW1wdHkoKTspe2NvbnN0IHQ9bi5wb3AoKTtCci5kZWxldGVBbGxFZGdlcyh0KTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5zZXRNYXJrZWQoITApO2NvbnN0IGk9dC5nZXRTeW0oKTtudWxsIT09aSYmaS5zZXRNYXJrZWQoITApO2NvbnN0IHI9dC5nZXRFZGdlKCk7ZS5hZGQoci5nZXRMaW5lKCkpO2NvbnN0IG89dC5nZXRUb05vZGUoKTsxPT09QnIuZ2V0RGVncmVlTm9uRGVsZXRlZChvKSYmbi5wdXNoKG8pfX1yZXR1cm4gZX19Y2xhc3MgWXJ7Y29uc3RydWN0b3IoKXtZci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaGVsbHM9bnVsbCx0aGlzLl9zaGVsbEluZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2hlbGxzPXQsdGhpcy5idWlsZEluZGV4KCl9c3RhdGljIGFzc2lnbkhvbGVzVG9TaGVsbHModCxlKXtuZXcgWXIoZSkuYXNzaWduSG9sZXNUb1NoZWxscyh0KX1hc3NpZ25Ib2xlc1RvU2hlbGxzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuYXNzaWduSG9sZVRvU2hlbGwodCl9fWJ1aWxkSW5kZXgoKXt0aGlzLl9zaGVsbEluZGV4PW5ldyBicztmb3IoY29uc3QgdCBvZiB0aGlzLl9zaGVsbHMpdGhpcy5fc2hlbGxJbmRleC5pbnNlcnQodC5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHQpfXF1ZXJ5T3ZlcmxhcHBpbmdTaGVsbHModCl7cmV0dXJuIHRoaXMuX3NoZWxsSW5kZXgucXVlcnkodCl9ZmluZFNoZWxsQ29udGFpbmluZyh0KXtjb25zdCBlPXQuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPXRoaXMucXVlcnlPdmVybGFwcGluZ1NoZWxscyhlKTtyZXR1cm4gcXIuZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LG4pfWFzc2lnbkhvbGVUb1NoZWxsKHQpe2NvbnN0IGU9dGhpcy5maW5kU2hlbGxDb250YWluaW5nKHQpO251bGwhPT1lJiZlLmFkZEhvbGUodCl9fWNsYXNzIFZye2NvbnN0cnVjdG9yKCl7VnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGluZVN0cmluZ0FkZGVyPW5ldyB6cih0aGlzKSx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2RhbmdsZXM9bmV3IEwsdGhpcy5fY3V0RWRnZXM9bmV3IEwsdGhpcy5faW52YWxpZFJpbmdMaW5lcz1uZXcgTCx0aGlzLl9ob2xlTGlzdD1udWxsLHRoaXMuX3NoZWxsTGlzdD1udWxsLHRoaXMuX3BvbHlMaXN0PW51bGwsdGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ9ITAsdGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw9bnVsbCx0aGlzLl9nZW9tRmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVZyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsITEpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsPXR9fXN0YXRpYyBleHRyYWN0UG9seWdvbnModCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpOyhlfHx0LmlzSW5jbHVkZWQoKSkmJm4uYWRkKHQuZ2V0UG9seWdvbigpKX1yZXR1cm4gbn1zdGF0aWMgZmluZE91dGVyU2hlbGxzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRPdXRlckhvbGUoKTtudWxsPT09bnx8bi5pc1Byb2Nlc3NlZCgpfHwodC5zZXRJbmNsdWRlZCghMCksbi5zZXRQcm9jZXNzZWQoITApKX19c3RhdGljIGZpbmREaXNqb2ludFNoZWxscyh0KXtWci5maW5kT3V0ZXJTaGVsbHModCk7bGV0IGU9bnVsbDtkb3tlPSExO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3QuaXNJbmNsdWRlZFNldCgpfHwodC51cGRhdGVJbmNsdWRlZCgpLHQuaXNJbmNsdWRlZFNldCgpfHwoZT0hMCkpfX13aGlsZShlKX1nZXRHZW9tZXRyeSgpe3JldHVybiBudWxsPT09dGhpcy5fZ2VvbUZhY3RvcnkmJih0aGlzLl9nZW9tRmFjdG9yeT1uZXcgTHQpLHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsP3RoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5fcG9seUxpc3QpOnRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihMdC50b0dlb21ldHJ5QXJyYXkodGhpcy5fcG9seUxpc3QpKX1nZXRJbnZhbGlkUmluZ0xpbmVzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2ludmFsaWRSaW5nTGluZXN9ZmluZFZhbGlkUmluZ3ModCxlLG4pe2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNWYWxpZCgpP2UuYWRkKHQpOm4uYWRkKHQuZ2V0TGluZVN0cmluZygpKX19cG9seWdvbml6ZSgpe2lmKG51bGwhPT10aGlzLl9wb2x5TGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLl9wb2x5TGlzdD1uZXcgTCxudWxsPT09dGhpcy5fZ3JhcGgpcmV0dXJuIG51bGw7dGhpcy5fZGFuZ2xlcz10aGlzLl9ncmFwaC5kZWxldGVEYW5nbGVzKCksdGhpcy5fY3V0RWRnZXM9dGhpcy5fZ3JhcGguZGVsZXRlQ3V0RWRnZXMoKTtjb25zdCB0PXRoaXMuX2dyYXBoLmdldEVkZ2VSaW5ncygpO2xldCBlPW5ldyBMO3RoaXMuX2ludmFsaWRSaW5nTGluZXM9bmV3IEwsdGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ/dGhpcy5maW5kVmFsaWRSaW5ncyh0LGUsdGhpcy5faW52YWxpZFJpbmdMaW5lcyk6ZT10LHRoaXMuZmluZFNoZWxsc0FuZEhvbGVzKGUpLFlyLmFzc2lnbkhvbGVzVG9TaGVsbHModGhpcy5faG9sZUxpc3QsdGhpcy5fc2hlbGxMaXN0KSx4ZS5zb3J0KHRoaXMuX3NoZWxsTGlzdCxuZXcgcXIuRW52ZWxvcGVDb21wYXJhdG9yKTtsZXQgbj0hMDt0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbCYmKFZyLmZpbmREaXNqb2ludFNoZWxscyh0aGlzLl9zaGVsbExpc3QpLG49ITEpLHRoaXMuX3BvbHlMaXN0PVZyLmV4dHJhY3RQb2x5Z29ucyh0aGlzLl9zaGVsbExpc3Qsbil9Z2V0RGFuZ2xlcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9kYW5nbGVzfWdldEN1dEVkZ2VzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2N1dEVkZ2VzfWdldFBvbHlnb25zKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX3BvbHlMaXN0fWFkZCgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksbnVsbD09PXRoaXMuX2dyYXBoJiYodGhpcy5fZ3JhcGg9bmV3IEJyKHRoaXMuX2dlb21GYWN0b3J5KSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7YXJndW1lbnRzWzBdLmFwcGx5KHRoaXMuX2xpbmVTdHJpbmdBZGRlcil9fXNldENoZWNrUmluZ3NWYWxpZCh0KXt0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD10fWZpbmRTaGVsbHNBbmRIb2xlcyh0KXt0aGlzLl9ob2xlTGlzdD1uZXcgTCx0aGlzLl9zaGVsbExpc3Q9bmV3IEw7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5jb21wdXRlSG9sZSgpLHQuaXNIb2xlKCk/dGhpcy5faG9sZUxpc3QuYWRkKHQpOnRoaXMuX3NoZWxsTGlzdC5hZGQodCl9fX1jbGFzcyB6cntjb25zdHJ1Y3Rvcigpe3pyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMucD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgJCYmdGhpcy5wLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119fVZyLkxpbmVTdHJpbmdBZGRlcj16cjt2YXIgWHI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUG9seWdvbml6ZXI6VnJ9KTtjbGFzcyBrcntjb25zdHJ1Y3Rvcigpe2tyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9wdExvY2F0b3I9bmV3IGZuLHRoaXMuX2FyZz1udWxsLHRoaXMuX25vZGVzPW5ldyBucyhuZXcgYnIpLHRoaXMuX2ltPW51bGwsdGhpcy5faXNvbGF0ZWRFZGdlcz1uZXcgTCx0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmc9dH1pbnNlcnRFZGdlRW5kcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGQodCl9fWNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTSh0LGUpe2NvbnN0IG49dGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCkscz10aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxpPXQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCkscj10Lmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCk7Mj09PW4mJjI9PT1zP2kmJmUuc2V0QXRMZWFzdChcIjIxMjEwMTIxMlwiKToyPT09biYmMT09PXM/KGkmJmUuc2V0QXRMZWFzdChcIkZGRjBGRkZGMlwiKSxyJiZlLnNldEF0TGVhc3QoXCIxRkZGRkYxRkZcIikpOjE9PT1uJiYyPT09cz8oaSYmZS5zZXRBdExlYXN0KFwiRjBGRkZGRkYyXCIpLHImJmUuc2V0QXRMZWFzdChcIjFGMUZGRkZGRlwiKSk6MT09PW4mJjE9PT1zJiZyJiZlLnNldEF0TGVhc3QoXCIwRkZGRkZGRkZcIil9bGFiZWxJc29sYXRlZEVkZ2VzKHQsZSl7Zm9yKGxldCBuPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dC5pc0lzb2xhdGVkKCkmJih0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlKHQsZSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSksdGhpcy5faXNvbGF0ZWRFZGdlcy5hZGQodCkpfX1sYWJlbElzb2xhdGVkRWRnZSh0LGUsbil7aWYobi5nZXREaW1lbnNpb24oKT4wKXtjb25zdCBzPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksbik7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLHMpfWVsc2UgdC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLFF0LkVYVEVSSU9SKX1jb21wdXRlSU0oKXtjb25zdCB0PW5ldyBKdDtpZih0LnNldChRdC5FWFRFUklPUixRdC5FWFRFUklPUiwyKSwhdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4gdGhpcy5jb21wdXRlRGlzam9pbnRJTSh0KSx0O3RoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSk7Y29uc3QgZT10aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSx0aGlzLl9saSwhMSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMSksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMSksdGhpcy5sYWJlbElzb2xhdGVkTm9kZXMoKSx0aGlzLmNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTShlLHQpO2NvbnN0IG49bmV3IFJyLHM9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzBdLmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKHMpO2NvbnN0IGk9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzFdLmdldEVkZ2VJdGVyYXRvcigpKTtyZXR1cm4gdGhpcy5pbnNlcnRFZGdlRW5kcyhpKSx0aGlzLmxhYmVsTm9kZUVkZ2VzKCksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMCwxKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygxLDApLHRoaXMudXBkYXRlSU0odCksdH1sYWJlbE5vZGVFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuX2FyZyl9fWNvcHlOb2Rlc0FuZExhYmVscyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fWxhYmVsSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxpPXRoaXMuX25vZGVzLmZpbmQobi5jb29yZCk7aS5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmKHM9PT1RdC5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkodCk6aS5zZXRMYWJlbCh0LFF0LklOVEVSSU9SKSl9fX1sYWJlbElzb2xhdGVkTm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG4pfWNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLGk9dGhpcy5fbm9kZXMuYWRkTm9kZShuLmNvb3JkKTtzPT09UXQuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KHQpOmkuZ2V0TGFiZWwoKS5pc051bGwodCkmJmkuc2V0TGFiZWwodCxRdC5JTlRFUklPUil9fX1sYWJlbElzb2xhdGVkTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7Zy5pc1RydWUobi5nZXRHZW9tZXRyeUNvdW50KCk+MCxcIm5vZGUgd2l0aCBlbXB0eSBsYWJlbCBmb3VuZFwiKSxlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwwKTp0aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMSkpfX11cGRhdGVJTSh0KXtmb3IobGV0IGU9dGhpcy5faXNvbGF0ZWRFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkudXBkYXRlSU0odCl9Zm9yKGxldCBlPXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24udXBkYXRlSU0odCksbi51cGRhdGVJTUZyb21FZGdlcyh0KX19Y29tcHV0ZURpc2pvaW50SU0odCl7Y29uc3QgZT10aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKTtlLmlzRW1wdHkoKXx8KHQuc2V0KFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SLGUuZ2V0RGltZW5zaW9uKCkpLHQuc2V0KFF0LkJPVU5EQVJZLFF0LkVYVEVSSU9SLGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpO2NvbnN0IG49dGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCk7bi5pc0VtcHR5KCl8fCh0LnNldChRdC5FWFRFUklPUixRdC5JTlRFUklPUixuLmdldERpbWVuc2lvbigpKSx0LnNldChRdC5FWFRFUklPUixRdC5CT1VOREFSWSxuLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKX19Y2xhc3MgVXJ7Y29uc3RydWN0b3IoKXtVci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0RW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1zdGF0aWMgY29udGFpbnModCxlKXtyZXR1cm4gbmV3IFVyKHQpLmNvbnRhaW5zKGUpfWlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KXtpZih0IGluc3RhbmNlb2YgcnQpcmV0dXJuITE7aWYodCBpbnN0YW5jZW9mIGV0KXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQgaW5zdGFuY2VvZiAkKXJldHVybiB0aGlzLmlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KG4pKXJldHVybiExfXJldHVybiEwfWlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KHQsZSl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodC54PT09ZS54KXtpZih0Lng9PT10aGlzLl9yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5fcmVjdEVudi5nZXRNYXhYKCkpcmV0dXJuITB9ZWxzZSBpZih0Lnk9PT1lLnkmJih0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNYXhZKCkpKXJldHVybiEwO3JldHVybiExfWlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49bmV3IG0scz1uZXcgbTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpLTE7dCsrKWlmKGUuZ2V0Q29vcmRpbmF0ZSh0LG4pLGUuZ2V0Q29vcmRpbmF0ZSh0KzEscyksIXRoaXMuaXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkobixzKSlyZXR1cm4hMTtyZXR1cm4hMH1pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0Lng9PT10aGlzLl9yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5fcmVjdEVudi5nZXRNYXhYKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1heFkoKX19Y29udGFpbnModCl7cmV0dXJuISF0aGlzLl9yZWN0RW52LmNvbnRhaW5zKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KHQpfX1jbGFzcyBIcntjb25zdHJ1Y3Rvcigpe0hyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fZGlhZ1VwMD1udWxsLHRoaXMuX2RpYWdVcDE9bnVsbCx0aGlzLl9kaWFnRG93bjA9bnVsbCx0aGlzLl9kaWFnRG93bjE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQsdGhpcy5fZGlhZ1VwMD1uZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksdGhpcy5fZGlhZ1VwMT1uZXcgbSh0LmdldE1heFgoKSx0LmdldE1heFkoKSksdGhpcy5fZGlhZ0Rvd24wPW5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSx0aGlzLl9kaWFnRG93bjE9bmV3IG0odC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpfWludGVyc2VjdHModCxlKXtjb25zdCBuPW5ldyBPKHQsZSk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhuKSlyZXR1cm4hMTtpZih0aGlzLl9yZWN0RW52LmludGVyc2VjdHModCkpcmV0dXJuITA7aWYodGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiEwO2lmKHQuY29tcGFyZVRvKGUpPjApe2NvbnN0IG49dDt0PWUsZT1ufWxldCBzPSExO3JldHVybiBlLnk+dC55JiYocz0hMCkscz90aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9kaWFnRG93bjAsdGhpcy5fZGlhZ0Rvd24xKTp0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9kaWFnVXAwLHRoaXMuX2RpYWdVcDEpLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl9fWNsYXNzIFdye2NvbnN0cnVjdG9yKCl7V3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdGFuZ2xlPW51bGwsdGhpcy5fcmVjdEVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RhbmdsZT10LHRoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9c3RhdGljIGludGVyc2VjdHModCxlKXtyZXR1cm4gbmV3IFdyKHQpLmludGVyc2VjdHMoZSl9aW50ZXJzZWN0cyh0KXtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTtjb25zdCBlPW5ldyBacih0aGlzLl9yZWN0RW52KTtpZihlLmFwcGx5VG8odCksZS5pbnRlcnNlY3RzKCkpcmV0dXJuITA7Y29uc3Qgbj1uZXcganIodGhpcy5fcmVjdGFuZ2xlKTtpZihuLmFwcGx5VG8odCksbi5jb250YWluc1BvaW50KCkpcmV0dXJuITA7Y29uc3Qgcz1uZXcgS3IodGhpcy5fcmVjdGFuZ2xlKTtyZXR1cm4gcy5hcHBseVRvKHQpLCEhcy5pbnRlcnNlY3RzKCl9fWNsYXNzIFpyIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLFpyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9pbnRlcnNlY3RzPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dH1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2ludGVyc2VjdHN9dmlzaXQodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpP3RoaXMuX3JlY3RFbnYuY29udGFpbnMoZSl8fGUuZ2V0TWluWCgpPj10aGlzLl9yZWN0RW52LmdldE1pblgoKSYmZS5nZXRNYXhYKCk8PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpfHxlLmdldE1pblkoKT49dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCkmJmUuZ2V0TWF4WSgpPD10aGlzLl9yZWN0RW52LmdldE1heFkoKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTp2b2lkIDA6bnVsbH1pbnRlcnNlY3RzKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdHN9fWNsYXNzIGpyIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGpyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RTZXE9bnVsbCx0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fY29udGFpbnNQb2ludD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0U2VxPXQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2NvbnRhaW5zUG9pbnR9dmlzaXQodCl7aWYoISh0IGluc3RhbmNlb2YgcnQpKXJldHVybiBudWxsO2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBtO2ZvcihsZXQgcz0wO3M8NDtzKyspaWYodGhpcy5fcmVjdFNlcS5nZXRDb29yZGluYXRlKHMsbiksZS5jb250YWlucyhuKSYmWmUuY29udGFpbnNQb2ludEluUG9seWdvbihuLHQpKXJldHVybiB0aGlzLl9jb250YWluc1BvaW50PSEwLG51bGx9Y29udGFpbnNQb2ludCgpe3JldHVybiB0aGlzLl9jb250YWluc1BvaW50fX1jbGFzcyBLciBleHRlbmRzIE5le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxLci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fcmVjdEludGVyc2VjdG9yPW51bGwsdGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX3AwPW5ldyBtLHRoaXMuX3AxPW5ldyBtO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCksdGhpcy5fcmVjdEludGVyc2VjdG9yPW5ldyBIcih0aGlzLl9yZWN0RW52KX1pbnRlcnNlY3RzKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2hhc0ludGVyc2VjdGlvbn12aXNpdCh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj15ZS5nZXRMaW5lcyh0KTt0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKG4pfWNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHRoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHModCksdGhpcy5faGFzSW50ZXJzZWN0aW9uKXJldHVybiBudWxsfX1jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTE7dDxlLnNpemUoKTt0KyspaWYoZS5nZXRDb29yZGluYXRlKHQtMSx0aGlzLl9wMCksZS5nZXRDb29yZGluYXRlKHQsdGhpcy5fcDEpLHRoaXMuX3JlY3RJbnRlcnNlY3Rvci5pbnRlcnNlY3RzKHRoaXMuX3AwLHRoaXMuX3AxKSlyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLG51bGx9fWNsYXNzIFFyIGV4dGVuZHMgTnJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLFFyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3JlbGF0ZT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtOci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fcmVsYXRlPW5ldyBrcih0aGlzLl9hcmcpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO05yLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4pLHRoaXMuX3JlbGF0ZT1uZXcga3IodGhpcy5fYXJnKX19c3RhdGljIGNvdmVycyh0LGUpe3JldHVybiEoMj09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MikmJighKDE9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDEmJmUuZ2V0TGVuZ3RoKCk+MCkmJighIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvdmVycyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJighIXQuaXNSZWN0YW5nbGUoKXx8bmV3IFFyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDb3ZlcnMoKSkpKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUpe2lmKCF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTtpZih0LmlzUmVjdGFuZ2xlKCkpcmV0dXJuIFdyLmludGVyc2VjdHModCxlKTtpZihlLmlzUmVjdGFuZ2xlKCkpcmV0dXJuIFdyLmludGVyc2VjdHMoZSx0KTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspZm9yKGxldCBzPTA7czxlLmdldE51bUdlb21ldHJpZXMoKTtzKyspaWYodC5nZXRHZW9tZXRyeU4obikuaW50ZXJzZWN0cyhlLmdldEdlb21ldHJ5TihzKSkpcmV0dXJuITA7cmV0dXJuITF9cmV0dXJuIG5ldyBRcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzSW50ZXJzZWN0cygpfXN0YXRpYyB0b3VjaGVzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IFFyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNUb3VjaGVzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGVxdWFsc1RvcG8odCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJlFyLnJlbGF0ZSh0LGUpLmlzRXF1YWxzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIHJlbGF0ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IFFyKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLmdldEludGVyc2VjdGlvbk1hdHJpeCgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IFFyKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKX19c3RhdGljIG92ZXJsYXBzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IFFyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNPdmVybGFwcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBjcm9zc2VzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IFFyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDcm9zc2VzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGNvbnRhaW5zKHQsZSl7cmV0dXJuISgyPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwyKSYmKCEoMT09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MSYmZS5nZXRMZW5ndGgoKT4wKSYmKCEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY29udGFpbnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYodC5pc1JlY3RhbmdsZSgpP1VyLmNvbnRhaW5zKHQsZSk6bmV3IFFyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDb250YWlucygpKSkpfWdldEludGVyc2VjdGlvbk1hdHJpeCgpe3JldHVybiB0aGlzLl9yZWxhdGUuY29tcHV0ZUlNKCl9fXZhciBKcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxSZWxhdGVPcDpRcn0pO2NsYXNzICRye2NvbnN0cnVjdG9yKCl7JHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcG9pbnRHZW9tPW51bGwsdGhpcy5fb3RoZXJHZW9tPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wb2ludEdlb209dCx0aGlzLl9vdGhlckdlb209ZSx0aGlzLl9nZW9tRmFjdD1lLmdldEZhY3RvcnkoKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gbmV3ICRyKHQsZSkudW5pb24oKX11bmlvbigpe2NvbnN0IHQ9bmV3IGZuLGU9bmV3IGF0O2ZvcihsZXQgbj0wO248dGhpcy5fcG9pbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dGhpcy5fcG9pbnRHZW9tLmdldEdlb21ldHJ5TihuKS5nZXRDb29yZGluYXRlKCk7dC5sb2NhdGUocyx0aGlzLl9vdGhlckdlb20pPT09UXQuRVhURVJJT1ImJmUuYWRkKHMpfWlmKDA9PT1lLnNpemUoKSlyZXR1cm4gdGhpcy5fb3RoZXJHZW9tO2xldCBuPW51bGw7Y29uc3Qgcz1fdC50b0Nvb3JkaW5hdGVBcnJheShlKTtyZXR1cm4gbj0xPT09cy5sZW5ndGg/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoc1swXSk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMocyksaGUuY29tYmluZShuLHRoaXMuX290aGVyR2VvbSl9fWNsYXNzIHRve2NvbnN0cnVjdG9yKCl7dG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9wb2x5Z29ucz1uZXcgTCx0aGlzLl9saW5lcz1uZXcgTCx0aGlzLl9wb2ludHM9bmV3IEwsdGhpcy5fZGltZW5zaW9uPVEuRkFMU0V9c3RhdGljIGV4dHJhY3QoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgdG87cmV0dXJuIGUuYWRkKHQpLGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB0bztyZXR1cm4gZS5hZGQodCksZX19Z2V0RmFjdG9yeSgpe3JldHVybiB0aGlzLl9nZW9tRmFjdG9yeX1yZWNvcmREaW1lbnNpb24odCl7dD50aGlzLl9kaW1lbnNpb24mJih0aGlzLl9kaW1lbnNpb249dCl9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuX2RpbWVuc2lvbn1maWx0ZXIodCl7cmV0dXJuIHRoaXMucmVjb3JkRGltZW5zaW9uKHQuZ2V0RGltZW5zaW9uKCkpLHQgaW5zdGFuY2VvZiBodHx8dC5pc0VtcHR5KCk/bnVsbDp0IGluc3RhbmNlb2YgcnQ/KHRoaXMuX3BvbHlnb25zLmFkZCh0KSxudWxsKTp0IGluc3RhbmNlb2YgJD8odGhpcy5fbGluZXMuYWRkKHQpLG51bGwpOnQgaW5zdGFuY2VvZiBldD8odGhpcy5fcG9pbnRzLmFkZCh0KSxudWxsKTp2b2lkIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogXCIrdC5nZXRHZW9tZXRyeVR5cGUoKSl9Z2V0RXh0cmFjdCh0KXtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB0aGlzLl9wb2ludHM7Y2FzZSAxOnJldHVybiB0aGlzLl9saW5lcztjYXNlIDI6cmV0dXJuIHRoaXMuX3BvbHlnb25zfXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiSW52YWxpZCBkaW1lbnNpb246IFwiK3QpLG51bGx9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9wb2x5Z29ucy5pc0VtcHR5KCkmJnRoaXMuX2xpbmVzLmlzRW1wdHkoKSYmdGhpcy5fcG9pbnRzLmlzRW1wdHkoKX1hZGQoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGNvbnN0IGUgb2YgdCl0aGlzLmFkZChlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2dlb21GYWN0b3J5JiYodGhpcy5fZ2VvbUZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHQuYXBwbHkodGhpcyl9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKXX19Y2xhc3MgZW97c3RhdGljIHVuaW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIHdyLmNyZWF0ZUVtcHR5UmVzdWx0KHdyLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1yZXR1cm4gVS5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSxVLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLElyLm92ZXJsYXlPcCh0LGUsd3IuVU5JT04pfX1jbGFzcyBub3tjb25zdHJ1Y3Rvcigpe25vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5fZzA9bnVsbCx0aGlzLl9nMT1udWxsLHRoaXMuX2lzVW5pb25TYWZlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZzA9dCx0aGlzLl9nMT1lLHRoaXMuX2dlb21GYWN0b3J5PXQuZ2V0RmFjdG9yeSgpfXN0YXRpYyBjb250YWluc1Byb3Blcmx5KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0LmlzTnVsbCgpJiYoZS5nZXRYKCk+dC5nZXRNaW5YKCkmJmUuZ2V0WCgpPHQuZ2V0TWF4WCgpJiZlLmdldFkoKT50LmdldE1pblkoKSYmZS5nZXRZKCk8dC5nZXRNYXhZKCkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbm8uY29udGFpbnNQcm9wZXJseSh0LGUpJiZuby5jb250YWluc1Byb3Blcmx5KHQsbil9fXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBuZXcgbm8odCxlKS51bmlvbigpfXN0YXRpYyBpbnRlcnNlY3RzKHQsZSxuKXtyZXR1cm4gdC5pbnRlcnNlY3RzKGUpfHx0LmludGVyc2VjdHMobil9c3RhdGljIG92ZXJsYXBFbnZlbG9wZSh0LGUpe2NvbnN0IG49dC5nZXRFbnZlbG9wZUludGVybmFsKCkscz1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gbi5pbnRlcnNlY3Rpb24ocyl9c3RhdGljIGV4dHJhY3RCb3JkZXJTZWdtZW50cyh0LGUsbil7dC5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1BdfWZpbHRlcih0LHMpe2lmKHM8PTApcmV0dXJuIG51bGw7Y29uc3QgaT10LmdldENvb3JkaW5hdGUocy0xKSxyPXQuZ2V0Q29vcmRpbmF0ZShzKTtpZihuby5pbnRlcnNlY3RzKGUsaSxyKSYmIW5vLmNvbnRhaW5zUHJvcGVybHkoZSxpLHIpKXtjb25zdCB0PW5ldyBLdChpLHIpO24uYWRkKHQpfX1pc0RvbmUoKXtyZXR1cm4hMX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiExfX0pfXN0YXRpYyB1bmlvbkJ1ZmZlcih0LGUpe3JldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oW3QsZV0pLmJ1ZmZlcigwKX1pc0JvcmRlclNlZ21lbnRzU2FtZSh0LGUpe2NvbnN0IG49dGhpcy5leHRyYWN0Qm9yZGVyU2VnbWVudHModGhpcy5fZzAsdGhpcy5fZzEsZSkscz1uZXcgTDtyZXR1cm4gbm8uZXh0cmFjdEJvcmRlclNlZ21lbnRzKHQsZSxzKSx0aGlzLmlzRXF1YWwobixzKX1leHRyYWN0QnlFbnZlbG9wZSh0LGUsbil7Y29uc3Qgcz1uZXcgTDtmb3IobGV0IGk9MDtpPGUuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7Y29uc3Qgcj1lLmdldEdlb21ldHJ5TihpKTtpZihyLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpKXMuYWRkKHIpO2Vsc2V7Y29uc3QgdD1yLmNvcHkoKTtuLmFkZCh0KX19cmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkocyl9aXNFcXVhbCh0LGUpe2lmKHQuc2l6ZSgpIT09ZS5zaXplKCkpcmV0dXJuITE7Y29uc3Qgbj1uZXcgRXQodCk7Zm9yKGNvbnN0IHQgb2YgZSlpZighbi5jb250YWlucyh0KSlyZXR1cm4hMTtyZXR1cm4hMH11bmlvbigpe2NvbnN0IHQ9bm8ub3ZlcmxhcEVudmVsb3BlKHRoaXMuX2cwLHRoaXMuX2cxKTtpZih0LmlzTnVsbCgpKXtjb25zdCB0PXRoaXMuX2cwLmNvcHkoKSxlPXRoaXMuX2cxLmNvcHkoKTtyZXR1cm4gaGUuY29tYmluZSh0LGUpfWNvbnN0IGU9bmV3IEwsbj10aGlzLmV4dHJhY3RCeUVudmVsb3BlKHQsdGhpcy5fZzAsZSkscz10aGlzLmV4dHJhY3RCeUVudmVsb3BlKHQsdGhpcy5fZzEsZSksaT10aGlzLnVuaW9uRnVsbChuLHMpO2xldCByPW51bGw7cmV0dXJuIHRoaXMuX2lzVW5pb25TYWZlPXRoaXMuaXNCb3JkZXJTZWdtZW50c1NhbWUoaSx0KSxyPXRoaXMuX2lzVW5pb25TYWZlP3RoaXMuY29tYmluZShpLGUpOnRoaXMudW5pb25GdWxsKHRoaXMuX2cwLHRoaXMuX2cxKSxyfWNvbWJpbmUodCxlKXtpZihlLnNpemUoKTw9MClyZXR1cm4gdDtlLmFkZCh0KTtyZXR1cm4gaGUuY29tYmluZShlKX11bmlvbkZ1bGwodCxlKXt0cnl7cmV0dXJuIGVvLnVuaW9uKHQsZSl9Y2F0Y2gobil7aWYobiBpbnN0YW5jZW9mIGlzKXJldHVybiBuby51bmlvbkJ1ZmZlcih0LGUpO3Rocm93IG59fWV4dHJhY3RCb3JkZXJTZWdtZW50cyh0LGUsbil7Y29uc3Qgcz1uZXcgTDtyZXR1cm4gbm8uZXh0cmFjdEJvcmRlclNlZ21lbnRzKHQsbixzKSxudWxsIT09ZSYmbm8uZXh0cmFjdEJvcmRlclNlZ21lbnRzKGUsbixzKSxzfWlzVW5pb25PcHRpbWl6ZWQoKXtyZXR1cm4gdGhpcy5faXNVbmlvblNhZmV9fWNsYXNzIHNve2NvbnN0cnVjdG9yKCl7c28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRQb2x5cz1udWxsLHRoaXMuX2dlb21GYWN0b3J5PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRQb2x5cz10LG51bGw9PT10aGlzLl9pbnB1dFBvbHlzJiYodGhpcy5faW5wdXRQb2x5cz1uZXcgTCl9c3RhdGljIHJlc3RyaWN0VG9Qb2x5Z29ucyh0KXtpZihJKHQsaXQpKXJldHVybiB0O2NvbnN0IGU9SWUuZ2V0UG9seWdvbnModCk7cmV0dXJuIDE9PT1lLnNpemUoKT9lLmdldCgwKTp0LmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oTHQudG9Qb2x5Z29uQXJyYXkoZSkpfXN0YXRpYyBnZXRHZW9tZXRyeSh0LGUpe3JldHVybiBlPj10LnNpemUoKT9udWxsOnQuZ2V0KGUpfXN0YXRpYyB1bmlvbih0KXtyZXR1cm4gbmV3IHNvKHQpLnVuaW9uKCl9cmVkdWNlVG9HZW9tZXRyaWVzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7bGV0IHM9bnVsbDtJKHQsQyk/cz10aGlzLnVuaW9uVHJlZSh0KTp0IGluc3RhbmNlb2YgVSYmKHM9dCksZS5hZGQocyl9cmV0dXJuIGV9dW5pb24oKXtpZihudWxsPT09dGhpcy5faW5wdXRQb2x5cyl0aHJvdyBuZXcgRChcInVuaW9uKCkgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2VcIik7aWYodGhpcy5faW5wdXRQb2x5cy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5fZ2VvbUZhY3Rvcnk9dGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCk7Y29uc3QgdD1uZXcgYnMoc28uU1RSVFJFRV9OT0RFX0NBUEFDSVRZKTtmb3IobGV0IGU9dGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0Lmluc2VydChuLmdldEVudmVsb3BlSW50ZXJuYWwoKSxuKX10aGlzLl9pbnB1dFBvbHlzPW51bGw7Y29uc3QgZT10Lml0ZW1zVHJlZSgpO3JldHVybiB0aGlzLnVuaW9uVHJlZShlKX1iaW5hcnlVbmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5iaW5hcnlVbmlvbih0LDAsdC5zaXplKCkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihuLWU8PTEpe2NvbnN0IG49c28uZ2V0R2VvbWV0cnkodCxlKTtyZXR1cm4gdGhpcy51bmlvblNhZmUobixudWxsKX1pZihuLWU9PTIpcmV0dXJuIHRoaXMudW5pb25TYWZlKHNvLmdldEdlb21ldHJ5KHQsZSksc28uZ2V0R2VvbWV0cnkodCxlKzEpKTt7Y29uc3Qgcz1NYXRoLnRydW5jKChuK2UpLzIpLGk9dGhpcy5iaW5hcnlVbmlvbih0LGUscykscj10aGlzLmJpbmFyeVVuaW9uKHQscyxuKTtyZXR1cm4gdGhpcy51bmlvblNhZmUoaSxyKX19fXJlcGVhdGVkVW5pb24odCl7bGV0IGU9bnVsbDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlPW51bGw9PT1lP3QuY29weSgpOmUudW5pb24odCl9cmV0dXJuIGV9dW5pb25TYWZlKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT10P2UuY29weSgpOm51bGw9PT1lP3QuY29weSgpOnRoaXMudW5pb25BY3R1YWwodCxlKX11bmlvbkFjdHVhbCh0LGUpe2NvbnN0IG49bm8udW5pb24odCxlKTtyZXR1cm4gc28ucmVzdHJpY3RUb1BvbHlnb25zKG4pfXVuaW9uVHJlZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlVG9HZW9tZXRyaWVzKHQpO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKGUpfWJ1ZmZlclVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldCgwKS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh0KS5idWZmZXIoMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oW3QsZV0pLmJ1ZmZlcigwKX19fXNvLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWT00O2NsYXNzIGlve2NvbnN0cnVjdG9yKCl7aW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9leHRyYWN0ZXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tRmFjdD1lLHRoaXMuZXh0cmFjdCh0KX19c3RhdGljIHVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtyZXR1cm4gbmV3IGlvKGFyZ3VtZW50c1swXSkudW5pb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe3JldHVybiBuZXcgaW8oYXJndW1lbnRzWzBdKS51bmlvbigpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IGlvKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLnVuaW9uKCl9fXVuaW9uTm9PcHQodCl7Y29uc3QgZT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludCgpO3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLlVOSU9OKX11bmlvbldpdGhOdWxsKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT1lP3Q6bnVsbD09PXQ/ZTp3ci51bmlvbih0LGUpfWV4dHJhY3QoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZXh0cmFjdGVyPXRvLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2V4dHJhY3Rlcj10by5leHRyYWN0KHQpfX11bmlvbigpe2lmKG51bGw9PT10aGlzLl9nZW9tRmFjdCYmKHRoaXMuX2dlb21GYWN0PXRoaXMuX2V4dHJhY3Rlci5nZXRGYWN0b3J5KCkpLG51bGw9PT10aGlzLl9nZW9tRmFjdClyZXR1cm4gbnVsbDtpZih0aGlzLl9leHRyYWN0ZXIuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVFbXB0eSh0aGlzLl9leHRyYWN0ZXIuZ2V0RGltZW5zaW9uKCkpO2NvbnN0IHQ9dGhpcy5fZXh0cmFjdGVyLmdldEV4dHJhY3QoMCksZT10aGlzLl9leHRyYWN0ZXIuZ2V0RXh0cmFjdCgxKSxuPXRoaXMuX2V4dHJhY3Rlci5nZXRFeHRyYWN0KDIpO2xldCBzPW51bGw7aWYodC5zaXplKCk+MCl7Y29uc3QgZT10aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHQpO3M9dGhpcy51bmlvbk5vT3B0KGUpfWxldCBpPW51bGw7aWYoZS5zaXplKCk+MCl7Y29uc3QgdD10aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGUpO2k9dGhpcy51bmlvbk5vT3B0KHQpfWxldCByPW51bGw7bi5zaXplKCk+MCYmKHI9c28udW5pb24obikpO2NvbnN0IG89dGhpcy51bmlvbldpdGhOdWxsKGkscik7bGV0IGw9bnVsbDtyZXR1cm4gbD1udWxsPT09cz9vOm51bGw9PT1vP3M6JHIudW5pb24ocyxvKSxudWxsPT09bD90aGlzLl9nZW9tRmFjdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTpsfX12YXIgcm89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVW5hcnlVbmlvbk9wOmlvfSksb289T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsSXNWYWxpZE9wOkdyLENvbnNpc3RlbnRBcmVhVGVzdGVyOkRyfSksbG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQm91bmRhcnlPcDppaSxJc1NpbXBsZU9wOm9pLGJ1ZmZlcjpCaSxkaXN0YW5jZTpYaSxsaW5lbWVyZ2U6cnIsb3ZlcmxheTpDcixwb2x5Z29uaXplOlhyLHJlbGF0ZTpKcix1bmlvbjpybyx2YWxpZDpvb30pO2NsYXNzIGFve2NvbnN0cnVjdG9yKCl7YW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcmV0dXJuVG9PcmlnaW5hbFByZWNpc2lvbj0hMCx0aGlzLl9jYnI9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClhby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLCEwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZXR1cm5Ub09yaWdpbmFsUHJlY2lzaW9uPXR9fWNvbXB1dGVSZXN1bHRQcmVjaXNpb24odCl7cmV0dXJuIHRoaXMuX3JldHVyblRvT3JpZ2luYWxQcmVjaXNpb24mJnRoaXMuX2Nici5hZGRDb21tb25CaXRzKHQpLHR9dW5pb24odCxlKXtjb25zdCBuPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0LGUpO3JldHVybiB0aGlzLmNvbXB1dGVSZXN1bHRQcmVjaXNpb24oblswXS51bmlvbihuWzFdKSl9aW50ZXJzZWN0aW9uKHQsZSl7Y29uc3Qgbj10aGlzLnJlbW92ZUNvbW1vbkJpdHModCxlKTtyZXR1cm4gdGhpcy5jb21wdXRlUmVzdWx0UHJlY2lzaW9uKG5bMF0uaW50ZXJzZWN0aW9uKG5bMV0pKX1yZW1vdmVDb21tb25CaXRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2Nicj1uZXcgZnIsdGhpcy5fY2JyLmFkZCh0KTtyZXR1cm4gdGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModC5jb3B5KCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jYnI9bmV3IGZyLHRoaXMuX2Nici5hZGQodCksdGhpcy5fY2JyLmFkZChlKTtjb25zdCBuPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiBuWzBdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHQuY29weSgpKSxuWzFdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKGUuY29weSgpKSxufX1idWZmZXIodCxlKXtjb25zdCBuPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0KTtyZXR1cm4gdGhpcy5jb21wdXRlUmVzdWx0UHJlY2lzaW9uKG4uYnVmZmVyKGUpKX1zeW1EaWZmZXJlbmNlKHQsZSl7Y29uc3Qgbj10aGlzLnJlbW92ZUNvbW1vbkJpdHModCxlKTtyZXR1cm4gdGhpcy5jb21wdXRlUmVzdWx0UHJlY2lzaW9uKG5bMF0uc3ltRGlmZmVyZW5jZShuWzFdKSl9ZGlmZmVyZW5jZSh0LGUpe2NvbnN0IG49dGhpcy5yZW1vdmVDb21tb25CaXRzKHQsZSk7cmV0dXJuIHRoaXMuY29tcHV0ZVJlc3VsdFByZWNpc2lvbihuWzBdLmRpZmZlcmVuY2UoblsxXSkpfX1jbGFzcyBjbyBleHRlbmRzIHVlLkNvb3JkaW5hdGVPcGVyYXRpb257Y29uc3RydWN0b3IoKXtzdXBlcigpLGNvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3RhcmdldFBNPW51bGwsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3RhcmdldFBNPXQsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPWV9ZWRpdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgcz1uZXcgbSh0W2VdKTt0aGlzLl90YXJnZXRQTS5tYWtlUHJlY2lzZShzKSxuW2VdPXN9Y29uc3Qgcz1uZXcgUihuLCExKS50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBpPTA7ZSBpbnN0YW5jZW9mICQmJihpPTIpLGUgaW5zdGFuY2VvZiBndCYmKGk9NCk7bGV0IHI9bjtyZXR1cm4gdGhpcy5fcmVtb3ZlQ29sbGFwc2VkJiYocj1udWxsKSxzLmxlbmd0aDxpP3I6c31yZXR1cm4gc3VwZXIuZWRpdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fWNsYXNzIGhve2NvbnN0cnVjdG9yKCl7aG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdGFyZ2V0UE09bnVsbCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ITAsdGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWw9ITEsdGhpcy5faXNQb2ludHdpc2U9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fdGFyZ2V0UE09dH1zdGF0aWMgcmVkdWNlKHQsZSl7cmV0dXJuIG5ldyBobyhlKS5yZWR1Y2UodCl9c3RhdGljIHJlZHVjZVBvaW50d2lzZSh0LGUpe2NvbnN0IG49bmV3IGhvKGUpO3JldHVybiBuLnNldFBvaW50d2lzZSghMCksbi5yZWR1Y2UodCl9Zml4UG9seWdvbmFsVG9wb2xvZ3kodCl7bGV0IGU9dDt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGU9dGhpcy5jaGFuZ2VQTSh0LHRoaXMuX3RhcmdldFBNKSk7cmV0dXJuIHFpLmJ1ZmZlck9wKGUsMCl9cmVkdWNlUG9pbnR3aXNlKHQpe2xldCBlPW51bGw7aWYodGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWwpe2NvbnN0IG49dGhpcy5jcmVhdGVGYWN0b3J5KHQuZ2V0RmFjdG9yeSgpLHRoaXMuX3RhcmdldFBNKTtlPW5ldyB1ZShuKX1lbHNlIGU9bmV3IHVlO2xldCBuPXRoaXMuX3JlbW92ZUNvbGxhcHNlZDt0LmdldERpbWVuc2lvbigpPj0yJiYobj0hMCk7cmV0dXJuIGUuZWRpdCh0LG5ldyBjbyh0aGlzLl90YXJnZXRQTSxuKSl9Y2hhbmdlUE0odCxlKXtyZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IodC5nZXRGYWN0b3J5KCksZSkuZWRpdCh0LG5ldyB1ZS5Ob09wR2VvbWV0cnlPcGVyYXRpb24pfXNldFJlbW92ZUNvbGxhcHNlZENvbXBvbmVudHModCl7dGhpcy5fcmVtb3ZlQ29sbGFwc2VkPXR9Y3JlYXRlRmFjdG9yeSh0LGUpe3JldHVybiBuZXcgTHQoZSx0LmdldFNSSUQoKSx0LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9c2V0Q2hhbmdlUHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWw9dH1yZWR1Y2UodCl7Y29uc3QgZT10aGlzLnJlZHVjZVBvaW50d2lzZSh0KTtyZXR1cm4gdGhpcy5faXNQb2ludHdpc2U/ZTpJKGUsaXQpP0dyLmlzVmFsaWQoZSk/ZTp0aGlzLmZpeFBvbHlnb25hbFRvcG9sb2d5KGUpOmV9c2V0UG9pbnR3aXNlKHQpe3RoaXMuX2lzUG9pbnR3aXNlPXR9Y3JlYXRlRWRpdG9yKHQsZSl7aWYodC5nZXRQcmVjaXNpb25Nb2RlbCgpPT09ZSlyZXR1cm4gbmV3IHVlO2NvbnN0IG49dGhpcy5jcmVhdGVGYWN0b3J5KHQsZSk7cmV0dXJuIG5ldyB1ZShuKX19Y2xhc3MgdW97Y29uc3RydWN0b3IoKXt1by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fcHRzPW51bGwsdGhpcy5fc3RhcnQ9bnVsbCx0aGlzLl9lbmQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fc3RhcnQ9ZSx0aGlzLl9lbmQ9ZSsxfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3B0cz10LHRoaXMuX3N0YXJ0PWUsdGhpcy5fZW5kPW59ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fZ2VvbT10LHRoaXMuX3B0cz1lLHRoaXMuX3N0YXJ0PW4sdGhpcy5fZW5kPXN9fWNvbXB1dGVEaXN0YW5jZUxpbmVMaW5lKHQsZSl7bGV0IG49ci5NQVhfVkFMVUU7Zm9yKGxldCBzPXRoaXMuX3N0YXJ0O3M8dGhpcy5fZW5kLTE7cysrKXtjb25zdCBpPXRoaXMuX3B0cy5nZXRDb29yZGluYXRlKHMpLHI9dGhpcy5fcHRzLmdldENvb3JkaW5hdGUocysxKTtmb3IobGV0IG89dC5fc3RhcnQ7bzx0Ll9lbmQtMTtvKyspe2NvbnN0IGw9dC5fcHRzLmdldENvb3JkaW5hdGUobyksYT10Ll9wdHMuZ2V0Q29vcmRpbmF0ZShvKzEpLGM9ei5zZWdtZW50VG9TZWdtZW50KGkscixsLGEpO2lmKGM8biYmKG49YyxudWxsIT09ZSYmdGhpcy51cGRhdGVOZWFyZXN0TG9jYXRpb25zTGluZUxpbmUocyxpLHIsdCxvLGwsYSxlKSxuPD0wKSlyZXR1cm4gbn19cmV0dXJuIG59dXBkYXRlTmVhcmVzdExvY2F0aW9uc1BvaW50TGluZSh0LGUsbixzLGkscil7clswXT1uZXcgWWkodGhpcy5fZ2VvbSx0aGlzLl9zdGFydCxuZXcgbSh0KSk7Y29uc3Qgbz1uZXcgS3QocyxpKS5jbG9zZXN0UG9pbnQodCk7clsxXT1uZXcgWWkoZS5fZ2VvbSxuLG5ldyBtKG8pKX1zaXplKCl7cmV0dXJuIHRoaXMuX2VuZC10aGlzLl9zdGFydH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9zdGFydCt0KX1uZWFyZXN0TG9jYXRpb25zKHQpe2NvbnN0IGU9dGhpcy5pc1BvaW50KCksbj10LmlzUG9pbnQoKSxzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKGUmJm4pe2NvbnN0IGU9dGhpcy5fcHRzLmdldENvb3JkaW5hdGUodGhpcy5fc3RhcnQpLG49dC5fcHRzLmdldENvb3JkaW5hdGUodC5fc3RhcnQpO3NbMF09bmV3IFlpKHRoaXMuX2dlb20sdGhpcy5fc3RhcnQsbmV3IG0oZSkpLHNbMV09bmV3IFlpKHQuX2dlb20sdC5fc3RhcnQsbmV3IG0obikpfWVsc2UgaWYoZSl7Y29uc3QgZT10aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9zdGFydCk7dGhpcy5jb21wdXRlRGlzdGFuY2VQb2ludExpbmUoZSx0LHMpfWVsc2UgaWYobil7Y29uc3QgZT10Ll9wdHMuZ2V0Q29vcmRpbmF0ZSh0Ll9zdGFydCk7dGhpcy5jb21wdXRlRGlzdGFuY2VQb2ludExpbmUoZSx0aGlzLHMpO2NvbnN0IG49c1swXTtzWzBdPXNbMV0sc1sxXT1ufWVsc2UgdGhpcy5jb21wdXRlRGlzdGFuY2VMaW5lTGluZSh0LHMpO3JldHVybiBzfWdldEVudmVsb3BlKCl7Y29uc3QgdD1uZXcgTztmb3IobGV0IGU9dGhpcy5fc3RhcnQ7ZTx0aGlzLl9lbmQ7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX3B0cy5nZXRYKGUpLHRoaXMuX3B0cy5nZXRZKGUpKTtyZXR1cm4gdH11cGRhdGVOZWFyZXN0TG9jYXRpb25zTGluZUxpbmUodCxlLG4scyxpLHIsbyxsKXtjb25zdCBhPW5ldyBLdChlLG4pLGM9bmV3IEt0KHIsbyksaD1hLmNsb3Nlc3RQb2ludHMoYyk7bFswXT1uZXcgWWkodGhpcy5fZ2VvbSx0LG5ldyBtKGhbMF0pKSxsWzFdPW5ldyBZaShzLl9nZW9tLGksbmV3IG0oaFsxXSkpfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdjt0LmFwcGVuZChcIkxJTkVTVFJJTkcgKCBcIik7Y29uc3QgZT1uZXcgbTtmb3IobGV0IG49dGhpcy5fc3RhcnQ7bjx0aGlzLl9lbmQ7bisrKW4+dGhpcy5fc3RhcnQmJnQuYXBwZW5kKFwiLCBcIiksdGhpcy5fcHRzLmdldENvb3JkaW5hdGUobixlKSx0LmFwcGVuZChlLngrXCIgXCIrZS55KTtyZXR1cm4gdC5hcHBlbmQoXCIgKVwiKSx0LnRvU3RyaW5nKCl9Y29tcHV0ZURpc3RhbmNlUG9pbnRMaW5lKHQsZSxuKXtsZXQgcz1yLk1BWF9WQUxVRTtmb3IobGV0IGk9ZS5fc3RhcnQ7aTxlLl9lbmQtMTtpKyspe2NvbnN0IHI9ZS5fcHRzLmdldENvb3JkaW5hdGUoaSksbz1lLl9wdHMuZ2V0Q29vcmRpbmF0ZShpKzEpLGw9ei5wb2ludFRvU2VnbWVudCh0LHIsbyk7aWYobDxzJiYocz1sLG51bGwhPT1uJiZ0aGlzLnVwZGF0ZU5lYXJlc3RMb2NhdGlvbnNQb2ludExpbmUodCxlLGkscixvLG4pLHM8PTApKXJldHVybiBzfXJldHVybiBzfWlzUG9pbnQoKXtyZXR1cm4gdGhpcy5fZW5kLXRoaXMuX3N0YXJ0PT0xfWRpc3RhbmNlKHQpe2NvbnN0IGU9dGhpcy5pc1BvaW50KCksbj10LmlzUG9pbnQoKTtsZXQgcz1udWxsO2lmKGUmJm4pe2NvbnN0IGU9dGhpcy5fcHRzLmdldENvb3JkaW5hdGUodGhpcy5fc3RhcnQpLG49dC5fcHRzLmdldENvb3JkaW5hdGUodC5fc3RhcnQpO3M9ZS5kaXN0YW5jZShuKX1lbHNlIGlmKGUpe2NvbnN0IGU9dGhpcy5fcHRzLmdldENvb3JkaW5hdGUodGhpcy5fc3RhcnQpO3M9dGhpcy5jb21wdXRlRGlzdGFuY2VQb2ludExpbmUoZSx0LG51bGwpfWVsc2UgaWYobil7Y29uc3QgZT10Ll9wdHMuZ2V0Q29vcmRpbmF0ZSh0Ll9zdGFydCk7cz10aGlzLmNvbXB1dGVEaXN0YW5jZVBvaW50TGluZShlLHRoaXMsbnVsbCl9ZWxzZSBzPXRoaXMuY29tcHV0ZURpc3RhbmNlTGluZUxpbmUodCxudWxsKTtyZXR1cm4gc319Y2xhc3MgZ297c3RhdGljIGFkZEZhY2V0U2VxdWVuY2VzKHQsZSxuKXtsZXQgcz0wO2NvbnN0IGk9ZS5zaXplKCk7Zm9yKDtzPD1pLTE7KXtsZXQgcj1zK2dvLkZBQ0VUX1NFUVVFTkNFX1NJWkUrMTtyPj1pLTEmJihyPWkpO2NvbnN0IG89bmV3IHVvKHQsZSxzLHIpO24uYWRkKG8pLHMrPWdvLkZBQ0VUX1NFUVVFTkNFX1NJWkV9fXN0YXRpYyBjb21wdXRlRmFjZXRTZXF1ZW5jZXModCl7Y29uc3QgZT1uZXcgTDtyZXR1cm4gdC5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfWZpbHRlcih0KXtsZXQgbj1udWxsOyh0IGluc3RhbmNlb2YgJHx8dCBpbnN0YW5jZW9mIGV0KSYmKG49dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxnby5hZGRGYWNldFNlcXVlbmNlcyh0LG4sZSkpfX0pLGV9c3RhdGljIGJ1aWxkKHQpe2NvbnN0IGU9bmV3IGJzKGdvLlNUUl9UUkVFX05PREVfQ0FQQUNJVFkpO2ZvcihsZXQgbj1nby5jb21wdXRlRmFjZXRTZXF1ZW5jZXModCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5pbnNlcnQodC5nZXRFbnZlbG9wZSgpLHQpfXJldHVybiBlLmJ1aWxkKCksZX19Z28uRkFDRVRfU0VRVUVOQ0VfU0laRT02LGdvLlNUUl9UUkVFX05PREVfQ0FQQUNJVFk9NDtjbGFzcyBfb3tjb25zdHJ1Y3Rvcigpe19vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX21pbkNsZWFyYW5jZT1udWxsLHRoaXMuX21pbkNsZWFyYW5jZVB0cz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBnZXRMaW5lKHQpe3JldHVybiBuZXcgX28odCkuZ2V0TGluZSgpfXN0YXRpYyBnZXREaXN0YW5jZSh0KXtyZXR1cm4gbmV3IF9vKHQpLmdldERpc3RhbmNlKCl9Z2V0TGluZSgpe3JldHVybiB0aGlzLmNvbXB1dGUoKSxudWxsPT09dGhpcy5fbWluQ2xlYXJhbmNlUHRzfHxudWxsPT09dGhpcy5fbWluQ2xlYXJhbmNlUHRzWzBdP3RoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpOnRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0aGlzLl9taW5DbGVhcmFuY2VQdHMpfWNvbXB1dGUoKXtpZihudWxsIT09dGhpcy5fbWluQ2xlYXJhbmNlUHRzKXJldHVybiBudWxsO2lmKHRoaXMuX21pbkNsZWFyYW5jZVB0cz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9taW5DbGVhcmFuY2U9ci5NQVhfVkFMVUUsdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCB0PWdvLmJ1aWxkKHRoaXMuX2lucHV0R2VvbSkubmVhcmVzdE5laWdoYm91cihuZXcgcG8pLGU9bmV3IHBvO3RoaXMuX21pbkNsZWFyYW5jZT1lLmRpc3RhbmNlKHRbMF0sdFsxXSksdGhpcy5fbWluQ2xlYXJhbmNlUHRzPWUuZ2V0Q29vcmRpbmF0ZXMoKX1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9taW5DbGVhcmFuY2V9fWNsYXNzIHBve2NvbnN0cnVjdG9yKCl7cG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWluRGlzdD1yLk1BWF9WQUxVRSx0aGlzLl9taW5QdHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCl9dmVydGV4RGlzdGFuY2UodCxlKXtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKylmb3IobGV0IHM9MDtzPGUuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldENvb3JkaW5hdGUobikscj1lLmdldENvb3JkaW5hdGUocyk7aWYoIWkuZXF1YWxzMkQocikpe2NvbnN0IHQ9aS5kaXN0YW5jZShyKTtpZih0PHRoaXMuX21pbkRpc3QmJih0aGlzLl9taW5EaXN0PXQsdGhpcy5fbWluUHRzWzBdPWksdGhpcy5fbWluUHRzWzFdPXIsMD09PXQpKXJldHVybiB0fX1yZXR1cm4gdGhpcy5fbWluRGlzdH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9taW5QdHN9c2VnbWVudERpc3RhbmNlKHQsZSl7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspZm9yKGxldCBzPTE7czxlLnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXRDb29yZGluYXRlKG4pLHI9ZS5nZXRDb29yZGluYXRlKHMtMSksbz1lLmdldENvb3JkaW5hdGUocyk7aWYoIWkuZXF1YWxzMkQocikmJiFpLmVxdWFsczJEKG8pKXtjb25zdCB0PXoucG9pbnRUb1NlZ21lbnQoaSxyLG8pO2lmKHQ8dGhpcy5fbWluRGlzdCYmKHRoaXMuX21pbkRpc3Q9dCx0aGlzLnVwZGF0ZVB0cyhpLHIsbyksMD09PXQpKXJldHVybiB0fX1yZXR1cm4gdGhpcy5fbWluRGlzdH1kaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3MmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgU3Mpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLmdldEl0ZW0oKSxuPXQuZ2V0SXRlbSgpO3JldHVybiB0aGlzLl9taW5EaXN0PXIuTUFYX1ZBTFVFLHRoaXMuZGlzdGFuY2UoZSxuKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHVvJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHVvKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy52ZXJ0ZXhEaXN0YW5jZSh0LGUpLDE9PT10LnNpemUoKSYmMT09PWUuc2l6ZSgpP3RoaXMuX21pbkRpc3Q6dGhpcy5fbWluRGlzdDw9MD90aGlzLl9taW5EaXN0Oih0aGlzLnNlZ21lbnREaXN0YW5jZSh0LGUpLHRoaXMuX21pbkRpc3Q8PTB8fHRoaXMuc2VnbWVudERpc3RhbmNlKGUsdCksdGhpcy5fbWluRGlzdCl9fXVwZGF0ZVB0cyh0LGUsbil7dGhpcy5fbWluUHRzWzBdPXQ7Y29uc3Qgcz1uZXcgS3QoZSxuKTt0aGlzLl9taW5QdHNbMV09bmV3IG0ocy5jbG9zZXN0UG9pbnQodCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblt2c119fV9vLk1pbkNsZWFyYW5jZURpc3RhbmNlPXBvO2NsYXNzIG1ve2NvbnN0cnVjdG9yKCl7bW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fbWluQ2xlYXJhbmNlPW51bGwsdGhpcy5fbWluQ2xlYXJhbmNlUHRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIGdldExpbmUodCl7cmV0dXJuIG5ldyBtbyh0KS5nZXRMaW5lKCl9c3RhdGljIGdldERpc3RhbmNlKHQpe3JldHVybiBuZXcgbW8odCkuZ2V0RGlzdGFuY2UoKX1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0aGlzLl9taW5DbGVhcmFuY2VQdHMpfXVwZGF0ZUNsZWFyYW5jZSgpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0PHRoaXMuX21pbkNsZWFyYW5jZSYmKHRoaXMuX21pbkNsZWFyYW5jZT10LHRoaXMuX21pbkNsZWFyYW5jZVB0c1swXT1uZXcgbShlKSx0aGlzLl9taW5DbGVhcmFuY2VQdHNbMV09bmV3IG0obikpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2lmKHQ8dGhpcy5fbWluQ2xlYXJhbmNlKXt0aGlzLl9taW5DbGVhcmFuY2U9dCx0aGlzLl9taW5DbGVhcmFuY2VQdHNbMF09bmV3IG0oZSk7Y29uc3QgaT1uZXcgS3QobixzKTt0aGlzLl9taW5DbGVhcmFuY2VQdHNbMV09bmV3IG0oaS5jbG9zZXN0UG9pbnQoZSkpfX19Y29tcHV0ZSgpe2lmKG51bGwhPT10aGlzLl9taW5DbGVhcmFuY2VQdHMpcmV0dXJuIG51bGw7dGhpcy5fbWluQ2xlYXJhbmNlUHRzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX21pbkNsZWFyYW5jZT1yLk1BWF9WQUxVRSx0aGlzLl9pbnB1dEdlb20uYXBwbHkobmV3IGZvKHRoaXMpKX1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9taW5DbGVhcmFuY2V9fWNsYXNzIGZve2NvbnN0cnVjdG9yKCl7Zm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5zbWM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNtYz10fWZpbHRlcih0KXt0aGlzLnNtYy5faW5wdXRHZW9tLmFwcGx5KG5ldyB5byh0aGlzLnNtYyx0KSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hdfX1jbGFzcyB5b3tjb25zdHJ1Y3Rvcigpe3lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuc21jPW51bGwsdGhpcy5fcXVlcnlQdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc21jPXQsdGhpcy5fcXVlcnlQdD1lfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITF9Y2hlY2tWZXJ0ZXhEaXN0YW5jZSh0KXtjb25zdCBlPXQuZGlzdGFuY2UodGhpcy5fcXVlcnlQdCk7ZT4wJiZ0aGlzLnNtYy51cGRhdGVDbGVhcmFuY2UoZSx0aGlzLl9xdWVyeVB0LHQpfWZpbHRlcih0LGUpe3RoaXMuY2hlY2tWZXJ0ZXhEaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoZSkpLGU+MCYmdGhpcy5jaGVja1NlZ21lbnREaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoZS0xKSx0LmdldENvb3JkaW5hdGUoZSkpfWNoZWNrU2VnbWVudERpc3RhbmNlKHQsZSl7aWYodGhpcy5fcXVlcnlQdC5lcXVhbHMyRCh0KXx8dGhpcy5fcXVlcnlQdC5lcXVhbHMyRChlKSlyZXR1cm4gbnVsbDtjb25zdCBuPXoucG9pbnRUb1NlZ21lbnQodGhpcy5fcXVlcnlQdCxlLHQpO24+MCYmdGhpcy5zbWMudXBkYXRlQ2xlYXJhbmNlKG4sdGhpcy5fcXVlcnlQdCxlLHQpfWlzRG9uZSgpe3JldHVybiExfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltQXX19bW8uVmVydGV4Q29vcmRpbmF0ZUZpbHRlcj1mbyxtby5Db21wdXRlTUNDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXI9eW87dmFyIHhvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvbW1vbkJpdHM6bXIsQ29tbW9uQml0c09wOmFvLENvbW1vbkJpdHNSZW1vdmVyOmZyLEVuaGFuY2VkUHJlY2lzaW9uT3A6Y2xhc3N7c3RhdGljIHVuaW9uKHQsZSl7bGV0IG49bnVsbDt0cnl7cmV0dXJuIHQudW5pb24oZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDtuPXR9dHJ5e2NvbnN0IHM9bmV3IGFvKCEwKS51bmlvbih0LGUpO2lmKCFzLmlzVmFsaWQoKSl0aHJvdyBuO3JldHVybiBzfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBoP246dH19c3RhdGljIGludGVyc2VjdGlvbih0LGUpe2xldCBuPW51bGw7dHJ5e3JldHVybiB0LmludGVyc2VjdGlvbihlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O249dH10cnl7Y29uc3Qgcz1uZXcgYW8oITApLmludGVyc2VjdGlvbih0LGUpO2lmKCFzLmlzVmFsaWQoKSl0aHJvdyBuO3JldHVybiBzfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBoP246dH19c3RhdGljIGJ1ZmZlcih0LGUpe2xldCBuPW51bGw7dHJ5e3JldHVybiB0LmJ1ZmZlcihlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O249dH10cnl7Y29uc3Qgcz1uZXcgYW8oITApLmJ1ZmZlcih0LGUpO2lmKCFzLmlzVmFsaWQoKSl0aHJvdyBuO3JldHVybiBzfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBoP246dH19c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtsZXQgbj1udWxsO3RyeXtyZXR1cm4gdC5zeW1EaWZmZXJlbmNlKGUpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7bj10fXRyeXtjb25zdCBzPW5ldyBhbyghMCkuc3ltRGlmZmVyZW5jZSh0LGUpO2lmKCFzLmlzVmFsaWQoKSl0aHJvdyBuO3JldHVybiBzfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBoP246dH19c3RhdGljIGRpZmZlcmVuY2UodCxlKXtsZXQgbj1udWxsO3RyeXtyZXR1cm4gdC5kaWZmZXJlbmNlKGUpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7bj10fXRyeXtjb25zdCBzPW5ldyBhbyghMCkuZGlmZmVyZW5jZSh0LGUpO2lmKCFzLmlzVmFsaWQoKSl0aHJvdyBuO3JldHVybiBzfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBoP246dH19fSxHZW9tZXRyeVByZWNpc2lvblJlZHVjZXI6aG8sTWluaW11bUNsZWFyYW5jZTpfbyxTaW1wbGVNaW5pbXVtQ2xlYXJhbmNlOm1vfSk7Y2xhc3MgRW97Y29uc3RydWN0b3IoKXtFby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl91c2VQdD1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5fc2VnPW5ldyBLdDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBFbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLnNpbXBsaWZ5KCl9c2ltcGxpZnlTZWN0aW9uKHQsZSl7aWYodCsxPT09ZSlyZXR1cm4gbnVsbDt0aGlzLl9zZWcucDA9dGhpcy5fcHRzW3RdLHRoaXMuX3NlZy5wMT10aGlzLl9wdHNbZV07bGV0IG49LTEscz10O2ZvcihsZXQgaT10KzE7aTxlO2krKyl7Y29uc3QgdD10aGlzLl9zZWcuZGlzdGFuY2UodGhpcy5fcHRzW2ldKTt0Pm4mJihuPXQscz1pKX1pZihuPD10aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSlmb3IobGV0IG49dCsxO248ZTtuKyspdGhpcy5fdXNlUHRbbl09ITE7ZWxzZSB0aGlzLnNpbXBsaWZ5U2VjdGlvbih0LHMpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKHMsZSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeSgpe3RoaXMuX3VzZVB0PW5ldyBBcnJheSh0aGlzLl9wdHMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcHRzLmxlbmd0aDt0KyspdGhpcy5fdXNlUHRbdF09ITA7dGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLl9wdHMubGVuZ3RoLTEpO2NvbnN0IHQ9bmV3IFI7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wdHMubGVuZ3RoO2UrKyl0aGlzLl91c2VQdFtlXSYmdC5hZGQobmV3IG0odGhpcy5fcHRzW2VdKSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX19Y2xhc3MgSW97Y29uc3RydWN0b3IoKXtJby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBJbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9c2V0RW5zdXJlVmFsaWQodCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLl9pbnB1dEdlb20uY29weSgpOm5ldyBObyh0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgcyhcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fX1jbGFzcyBObyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxOby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITAsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1lfXRyYW5zZm9ybVBvbHlnb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiB5dD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1udWxsO3JldHVybiBzPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpFby5zaW1wbGlmeShuLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPWUgaW5zdGFuY2VvZiBydCxzPXN1cGVyLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fHMgaW5zdGFuY2VvZiBndD9zOm51bGx9fUlvLkRQVHJhbnNmb3JtZXI9Tm87Y2xhc3Mgd28gZXh0ZW5kcyBLdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksd28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcGFyZW50PW51bGwsdGhpcy5faW5kZXg9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07d28uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbnVsbCwtMSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107S3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX3BhcmVudD1uLHRoaXMuX2luZGV4PXN9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuX2luZGV4fWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnR9fWNsYXNzIENve2NvbnN0cnVjdG9yKCl7Q28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcGFyZW50TGluZT1udWxsLHRoaXMuX3NlZ3M9bnVsbCx0aGlzLl9yZXN1bHRTZWdzPW5ldyBMLHRoaXMuX21pbmltdW1TaXplPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0NvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wYXJlbnRMaW5lPXQsdGhpcy5fbWluaW11bVNpemU9ZSx0aGlzLmluaXQoKX19c3RhdGljIGV4dHJhY3RDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSsxKS5maWxsKG51bGwpO2xldCBuPW51bGw7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspbj10LmdldChzKSxlW3NdPW4ucDA7cmV0dXJuIGVbZS5sZW5ndGgtMV09bi5wMSxlfWFkZFRvUmVzdWx0KHQpe3RoaXMuX3Jlc3VsdFNlZ3MuYWRkKHQpfWFzTGluZVN0cmluZygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKENvLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKSl9Z2V0UmVzdWx0U2l6ZSgpe2NvbnN0IHQ9dGhpcy5fcmVzdWx0U2Vncy5zaXplKCk7cmV0dXJuIDA9PT10PzA6dCsxfWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lfWdldFNlZ21lbnQodCl7cmV0dXJuIHRoaXMuX3NlZ3NbdF19Z2V0UGFyZW50Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpfWdldE1pbmltdW1TaXplKCl7cmV0dXJuIHRoaXMuX21pbmltdW1TaXplfWFzTGluZWFyUmluZygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKENvLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKSl9Z2V0U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fc2Vnc31pbml0KCl7Y29uc3QgdD10aGlzLl9wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5fc2Vncz1uZXcgQXJyYXkodC5sZW5ndGgtMSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTE7ZSsrKXtjb25zdCBuPW5ldyB3byh0W2VdLHRbZSsxXSx0aGlzLl9wYXJlbnRMaW5lLGUpO3RoaXMuX3NlZ3NbZV09bn19Z2V0UmVzdWx0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gQ28uZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpfX1jbGFzcyBTb3tjb25zdHJ1Y3Rvcigpe1NvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2luZGV4PW5ldyBOc31yZW1vdmUodCl7dGhpcy5faW5kZXgucmVtb3ZlKG5ldyBPKHQucDAsdC5wMSksdCl9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDbyl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0U2VnbWVudHMoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO3RoaXMuYWRkKG4pfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2luZGV4Lmluc2VydChuZXcgTyh0LnAwLHQucDEpLHQpfX1xdWVyeSh0KXtjb25zdCBlPW5ldyBPKHQucDAsdC5wMSksbj1uZXcgTG8odCk7dGhpcy5faW5kZXgucXVlcnkoZSxuKTtyZXR1cm4gbi5nZXRJdGVtcygpfX1jbGFzcyBMb3tjb25zdHJ1Y3Rvcigpe0xvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3F1ZXJ5U2VnPW51bGwsdGhpcy5faXRlbXM9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcXVlcnlTZWc9dH12aXNpdEl0ZW0odCl7Y29uc3QgZT10O08uaW50ZXJzZWN0cyhlLnAwLGUucDEsdGhpcy5fcXVlcnlTZWcucDAsdGhpcy5fcXVlcnlTZWcucDEpJiZ0aGlzLl9pdGVtcy5hZGQodCl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RlXX19Y2xhc3MgVG97Y29uc3RydWN0b3IoKXtUby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5faW5wdXRJbmRleD1uZXcgU28sdGhpcy5fb3V0cHV0SW5kZXg9bmV3IFNvLHRoaXMuX2xpbmU9bnVsbCx0aGlzLl9saW5lUHRzPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dEluZGV4PXQsdGhpcy5fb3V0cHV0SW5kZXg9ZX1zdGF0aWMgaXNJbkxpbmVTZWN0aW9uKHQsZSxuKXtpZihuLmdldFBhcmVudCgpIT09dC5nZXRQYXJlbnQoKSlyZXR1cm4hMTtjb25zdCBzPW4uZ2V0SW5kZXgoKTtyZXR1cm4gcz49ZVswXSYmczxlWzFdfWZsYXR0ZW4odCxlKXtjb25zdCBuPXRoaXMuX2xpbmVQdHNbdF0scz10aGlzLl9saW5lUHRzW2VdLGk9bmV3IEt0KG4scyk7cmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMuX2xpbmUsdCxlKSx0aGlzLl9vdXRwdXRJbmRleC5hZGQoaSksaX1oYXNCYWRJbnRlcnNlY3Rpb24odCxlLG4pe3JldHVybiEhdGhpcy5oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24obil8fCEhdGhpcy5oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeVNlY3Rpb24odCxlLG4pe24rPTE7Y29uc3Qgcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0KzE9PT1lKXtjb25zdCBlPXRoaXMuX2xpbmUuZ2V0U2VnbWVudCh0KTtyZXR1cm4gdGhpcy5fbGluZS5hZGRUb1Jlc3VsdChlKSxudWxsfWxldCBpPSEwO2lmKHRoaXMuX2xpbmUuZ2V0UmVzdWx0U2l6ZSgpPHRoaXMuX2xpbmUuZ2V0TWluaW11bVNpemUoKSl7bisxPHRoaXMuX2xpbmUuZ2V0TWluaW11bVNpemUoKSYmKGk9ITEpfWNvbnN0IHI9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbz10aGlzLmZpbmRGdXJ0aGVzdFBvaW50KHRoaXMuX2xpbmVQdHMsdCxlLHIpO3JbMF0+dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UmJihpPSExKTtjb25zdCBsPW5ldyBLdDtpZihsLnAwPXRoaXMuX2xpbmVQdHNbdF0sbC5wMT10aGlzLl9saW5lUHRzW2VdLHNbMF09dCxzWzFdPWUsdGhpcy5oYXNCYWRJbnRlcnNlY3Rpb24odGhpcy5fbGluZSxzLGwpJiYoaT0hMSksaSl7Y29uc3Qgbj10aGlzLmZsYXR0ZW4odCxlKTtyZXR1cm4gdGhpcy5fbGluZS5hZGRUb1Jlc3VsdChuKSxudWxsfXRoaXMuc2ltcGxpZnlTZWN0aW9uKHQsbyxuKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihvLGUsbil9aGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10aGlzLl9vdXRwdXRJbmRleC5xdWVyeSh0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKG4sdCkpcmV0dXJuITB9cmV0dXJuITF9ZmluZEZ1cnRoZXN0UG9pbnQodCxlLG4scyl7Y29uc3QgaT1uZXcgS3Q7aS5wMD10W2VdLGkucDE9dFtuXTtsZXQgcj0tMSxvPWU7Zm9yKGxldCBzPWUrMTtzPG47cysrKXtjb25zdCBlPXRbc10sbj1pLmRpc3RhbmNlKGUpO24+ciYmKHI9bixvPXMpfXJldHVybiBzWzBdPXIsb31zaW1wbGlmeSh0KXt0aGlzLl9saW5lPXQsdGhpcy5fbGluZVB0cz10LmdldFBhcmVudENvb3JkaW5hdGVzKCksdGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLl9saW5lUHRzLmxlbmd0aC0xLDApfXJlbW92ZSh0LGUsbil7Zm9yKGxldCBzPWU7czxuO3MrKyl7Y29uc3QgZT10LmdldFNlZ21lbnQocyk7dGhpcy5faW5wdXRJbmRleC5yZW1vdmUoZSl9fWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odC5wMCx0LnAxLGUucDAsZS5wMSksdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpfWhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKXtmb3IobGV0IHM9dGhpcy5faW5wdXRJbmRleC5xdWVyeShuKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKGksbikpe2lmKFRvLmlzSW5MaW5lU2VjdGlvbih0LGUsaSkpY29udGludWU7cmV0dXJuITB9fXJldHVybiExfX1jbGFzcyBSb3tjb25zdHJ1Y3Rvcigpe1JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0SW5kZXg9bmV3IFNvLHRoaXMuX291dHB1dEluZGV4PW5ldyBTbyx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT0wfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnkodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5faW5wdXRJbmRleC5hZGQoZS5uZXh0KCkpO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PW5ldyBUbyh0aGlzLl9pbnB1dEluZGV4LHRoaXMuX291dHB1dEluZGV4KTt0LnNldERpc3RhbmNlVG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0LnNpbXBsaWZ5KGUubmV4dCgpKX19fWNsYXNzIFBve2NvbnN0cnVjdG9yKCl7UG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fbGluZVNpbXBsaWZpZXI9bmV3IFJvLHRoaXMuX2xpbmVzdHJpbmdNYXA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBQbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtpZih0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLl9pbnB1dEdlb20uY29weSgpO3RoaXMuX2xpbmVzdHJpbmdNYXA9bmV3IE50LHRoaXMuX2lucHV0R2VvbS5hcHBseShuZXcgdm8odGhpcykpLHRoaXMuX2xpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KHRoaXMuX2xpbmVzdHJpbmdNYXAudmFsdWVzKCkpO3JldHVybiBuZXcgT28odGhpcy5fbGluZXN0cmluZ01hcCkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBzKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2xpbmVTaW1wbGlmaWVyLnNldERpc3RhbmNlVG9sZXJhbmNlKHQpfX1jbGFzcyBPbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxPby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lc3RyaW5nTWFwPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZXN0cmluZ01hcD10fXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7aWYoMD09PXQuc2l6ZSgpKXJldHVybiBudWxsO2lmKGUgaW5zdGFuY2VvZiAkKXtjb25zdCB0PXRoaXMuX2xpbmVzdHJpbmdNYXAuZ2V0KGUpO3JldHVybiB0aGlzLmNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSh0LmdldFJlc3VsdENvb3JkaW5hdGVzKCkpfXJldHVybiBzdXBlci50cmFuc2Zvcm1Db29yZGluYXRlcy5jYWxsKHRoaXMsdCxlKX19Y2xhc3Mgdm97Y29uc3RydWN0b3IoKXt2by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnRwcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMudHBzPXR9ZmlsdGVyKHQpe2lmKHQgaW5zdGFuY2VvZiAkKXtjb25zdCBlPXQ7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1lLmlzQ2xvc2VkKCk/NDoyLHM9bmV3IENvKGUsbik7dGhpcy50cHMuX2xpbmVzdHJpbmdNYXAucHV0KGUscyl9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX19UG8uTGluZVN0cmluZ1RyYW5zZm9ybWVyPU9vLFBvLkxpbmVTdHJpbmdNYXBCdWlsZGVyRmlsdGVyPXZvO2NsYXNzIGJve2NvbnN0cnVjdG9yKCl7Ym8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fdG9sZXJhbmNlPWUqZX1zdGF0aWMgc2ltcGxpZnkodCxlKXtyZXR1cm4gbmV3IGJvKHQsZSkuc2ltcGxpZnkoKX1zaW1wbGlmeVZlcnRleCh0KXtsZXQgZT10LG49ZS5nZXRBcmVhKCkscz1udWxsO2Zvcig7bnVsbCE9PWU7KXtjb25zdCB0PWUuZ2V0QXJlYSgpO3Q8biYmKG49dCxzPWUpLGU9ZS5fbmV4dH1yZXR1cm4gbnVsbCE9PXMmJm48dGhpcy5fdG9sZXJhbmNlJiZzLnJlbW92ZSgpLHQuaXNMaXZlKCk/bjotMX1zaW1wbGlmeSgpe2NvbnN0IHQ9TW8uYnVpbGRMaW5lKHRoaXMuX3B0cyk7bGV0IGU9dGhpcy5fdG9sZXJhbmNlO2Rve2U9dGhpcy5zaW1wbGlmeVZlcnRleCh0KX13aGlsZShlPHRoaXMuX3RvbGVyYW5jZSk7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIG4ubGVuZ3RoPDI/W25bMF0sbmV3IG0oblswXSldOm59fWNsYXNzIE1ve2NvbnN0cnVjdG9yKCl7TW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHQ9bnVsbCx0aGlzLl9wcmV2PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2FyZWE9TW8uTUFYX0FSRUEsdGhpcy5faXNMaXZlPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0PXR9c3RhdGljIGJ1aWxkTGluZSh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl7Y29uc3QgaT1uZXcgTW8odFtzXSk7bnVsbD09PWUmJihlPWkpLGkuc2V0UHJldihuKSxudWxsIT09biYmKG4uc2V0TmV4dChpKSxuLnVwZGF0ZUFyZWEoKSksbj1pfXJldHVybiBlfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgUjtsZXQgZT10aGlzO2Rve3QuYWRkKGUuX3B0LCExKSxlPWUuX25leHR9d2hpbGUobnVsbCE9PWUpO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9Z2V0QXJlYSgpe3JldHVybiB0aGlzLl9hcmVhfXVwZGF0ZUFyZWEoKXtpZihudWxsPT09dGhpcy5fcHJldnx8bnVsbD09PXRoaXMuX25leHQpcmV0dXJuIHRoaXMuX2FyZWE9TW8uTUFYX0FSRUEsbnVsbDt0aGlzLl9hcmVhPU1hdGguYWJzKG5lLmFyZWEodGhpcy5fcHJldi5fcHQsdGhpcy5fcHQsdGhpcy5fbmV4dC5fcHQpKX1yZW1vdmUoKXtjb25zdCB0PXRoaXMuX3ByZXYsZT10aGlzLl9uZXh0O2xldCBuPW51bGw7cmV0dXJuIG51bGwhPT10aGlzLl9wcmV2JiYodGhpcy5fcHJldi5zZXROZXh0KGUpLHRoaXMuX3ByZXYudXBkYXRlQXJlYSgpLG49dGhpcy5fcHJldiksbnVsbCE9PXRoaXMuX25leHQmJih0aGlzLl9uZXh0LnNldFByZXYodCksdGhpcy5fbmV4dC51cGRhdGVBcmVhKCksbnVsbD09PW4mJihuPXRoaXMuX25leHQpKSx0aGlzLl9pc0xpdmU9ITEsbn1pc0xpdmUoKXtyZXR1cm4gdGhpcy5faXNMaXZlfXNldFByZXYodCl7dGhpcy5fcHJldj10fXNldE5leHQodCl7dGhpcy5fbmV4dD10fX1Nby5NQVhfQVJFQT1yLk1BWF9WQUxVRSxiby5WV1ZlcnRleD1NbztjbGFzcyBEb3tjb25zdHJ1Y3Rvcigpe0RvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IERvKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1zZXRFbnN1cmVWYWxpZCh0KXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuX2lucHV0R2VvbS5jb3B5KCk6bmV3IEFvKHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neSx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBzKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9fWNsYXNzIEFvIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLEFvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPWV9dHJhbnNmb3JtUG9seWdvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIHl0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPW51bGw7cmV0dXJuIHM9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOmJvLnNpbXBsaWZ5KG4sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49ZSBpbnN0YW5jZW9mIHJ0LHM9c3VwZXIudHJhbnNmb3JtTGluZWFyUmluZy5jYWxsKHRoaXMsdCxlKTtyZXR1cm4hbnx8cyBpbnN0YW5jZW9mIGd0P3M6bnVsbH19RG8uVldUcmFuc2Zvcm1lcj1Bbzt2YXIgRm89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRG91Z2xhc1BldWNrZXJTaW1wbGlmaWVyOklvLFRvcG9sb2d5UHJlc2VydmluZ1NpbXBsaWZpZXI6UG8sVldTaW1wbGlmaWVyOkRvfSk7Y2xhc3MgR297Y29uc3RydWN0b3IoKXtHby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zZWc9bnVsbCx0aGlzLl9zZWdMZW49bnVsbCx0aGlzLl9zcGxpdFB0PW51bGwsdGhpcy5fbWluaW11bUxlbj0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZz10LHRoaXMuX3NlZ0xlbj10LmdldExlbmd0aCgpfXN0YXRpYyBwb2ludEFsb25nUmV2ZXJzZSh0LGUpe2NvbnN0IG49bmV3IG07cmV0dXJuIG4ueD10LnAxLngtZSoodC5wMS54LXQucDAueCksbi55PXQucDEueS1lKih0LnAxLnktdC5wMC55KSxufXNwbGl0QXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9taW5pbXVtTGVuL3RoaXMuX3NlZ0xlbjtpZih0LmRpc3RhbmNlKHRoaXMuX3NlZy5wMCk8dGhpcy5fbWluaW11bUxlbilyZXR1cm4gdGhpcy5fc3BsaXRQdD10aGlzLl9zZWcucG9pbnRBbG9uZyhlKSxudWxsO2lmKHQuZGlzdGFuY2UodGhpcy5fc2VnLnAxKTx0aGlzLl9taW5pbXVtTGVuKXJldHVybiB0aGlzLl9zcGxpdFB0PUdvLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuX3NlZyxlKSxudWxsO3RoaXMuX3NwbGl0UHQ9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuZ2V0Q29uc3RyYWluZWRMZW5ndGgodCkvdGhpcy5fc2VnTGVuO2UuZXF1YWxzMkQodGhpcy5fc2VnLnAwKT90aGlzLl9zcGxpdFB0PXRoaXMuX3NlZy5wb2ludEFsb25nKG4pOnRoaXMuX3NwbGl0UHQ9R28ucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5fc2VnLG4pfX1zZXRNaW5pbXVtTGVuZ3RoKHQpe3RoaXMuX21pbmltdW1MZW49dH1nZXRDb25zdHJhaW5lZExlbmd0aCh0KXtyZXR1cm4gdDx0aGlzLl9taW5pbXVtTGVuP3RoaXMuX21pbmltdW1MZW46dH1nZXRTcGxpdFBvaW50KCl7cmV0dXJuIHRoaXMuX3NwbGl0UHR9fWNsYXNzIHFve2ZpbmRTcGxpdFBvaW50KHQsZSl7fX1jbGFzcyBCb3tzdGF0aWMgcHJvamVjdGVkU3BsaXRQb2ludCh0LGUpe3JldHVybiB0LmdldExpbmVTZWdtZW50KCkucHJvamVjdChlKX1maW5kU3BsaXRQb2ludCh0LGUpe2NvbnN0IG49dC5nZXRMaW5lU2VnbWVudCgpLHM9bi5nZXRMZW5ndGgoKS8yLGk9bmV3IEdvKG4pLHI9Qm8ucHJvamVjdGVkU3BsaXRQb2ludCh0LGUpO2xldCBvPTIqci5kaXN0YW5jZShlKSouODtyZXR1cm4gbz5zJiYobz1zKSxpLnNldE1pbmltdW1MZW5ndGgobyksaS5zcGxpdEF0KHIpLGkuZ2V0U3BsaXRQb2ludCgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltxb119fWNsYXNzIFlve3N0YXRpYyB0cmlBcmVhKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShlLnktdC55KSoobi54LXQueCl9c3RhdGljIGlzSW5DaXJjbGVERE5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT1BLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qocy54KSxyPUEudmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChzLnkpLG89QS52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHMueCksbD1BLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3Qocy55KSxhPUEudmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdChzLngpLGM9QS52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHMueSksaD1pLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChvLm11bHRpcGx5KHIpKSx1PW8ubXVsdGlwbHkoYykuc2VsZlN1YnRyYWN0KGEubXVsdGlwbHkobCkpLGc9YS5tdWx0aXBseShyKS5zZWxmU3VidHJhY3QoaS5tdWx0aXBseShjKSksZD1pLm11bHRpcGx5KGkpLnNlbGZBZGQoci5tdWx0aXBseShyKSksXz1vLm11bHRpcGx5KG8pLnNlbGZBZGQobC5tdWx0aXBseShsKSkscD1hLm11bHRpcGx5KGEpLnNlbGZBZGQoYy5tdWx0aXBseShjKSk7cmV0dXJuIGQuc2VsZk11bHRpcGx5KHUpLnNlbGZBZGQoXy5zZWxmTXVsdGlwbHkoZykpLnNlbGZBZGQocC5zZWxmTXVsdGlwbHkoaCkpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgY2hlY2tSb2J1c3RJbkNpcmNsZSh0LGUsbixzKXtjb25zdCBpPVlvLmlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4scykscj1Zby5pc0luQ2lyY2xlRERTbG93KHQsZSxuLHMpLG89WW8uaXNJbkNpcmNsZUNDKHQsZSxuLHMpLGw9bmUuY2lyY3VtY2VudHJlKHQsZSxuKTtZLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS10LmRpc3RhbmNlKGwpKS90LmRpc3RhbmNlKGwpKSxpPT09ciYmaT09PW98fChZLm91dC5wcmludGxuKFwiaW5DaXJjbGUgcm9idXN0bmVzcyBmYWlsdXJlIChkb3VibGUgcmVzdWx0ID0gXCIraStcIiwgREQgcmVzdWx0ID0gXCIrcitcIiwgQ0MgcmVzdWx0ID0gXCIrbytcIilcIiksWS5vdXQucHJpbnRsbihXdC50b0xpbmVTdHJpbmcobmV3IG10KFt0LGUsbixzXSkpKSxZLm91dC5wcmludGxuKFwiQ2lyY3VtY2VudHJlID0gXCIrV3QudG9Qb2ludChsKStcIiByYWRpdXMgPSBcIit0LmRpc3RhbmNlKGwpKSxZLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS90LmRpc3RhbmNlKGwpLTEpKSxZLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBiID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9lLmRpc3RhbmNlKGwpLTEpKSxZLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBjID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9uLmRpc3RhbmNlKGwpLTEpKSxZLm91dC5wcmludGxuKCkpfXN0YXRpYyBpc0luQ2lyY2xlRERGYXN0KHQsZSxuLHMpe2NvbnN0IGk9QS5zcXIodC54KS5zZWxmQWRkKEEuc3FyKHQueSkpLnNlbGZNdWx0aXBseShZby50cmlBcmVhRERGYXN0KGUsbixzKSkscj1BLnNxcihlLngpLnNlbGZBZGQoQS5zcXIoZS55KSkuc2VsZk11bHRpcGx5KFlvLnRyaUFyZWFEREZhc3QodCxuLHMpKSxvPUEuc3FyKG4ueCkuc2VsZkFkZChBLnNxcihuLnkpKS5zZWxmTXVsdGlwbHkoWW8udHJpQXJlYURERmFzdCh0LGUscykpLGw9QS5zcXIocy54KS5zZWxmQWRkKEEuc3FyKHMueSkpLnNlbGZNdWx0aXBseShZby50cmlBcmVhRERGYXN0KHQsZSxuKSk7cmV0dXJuIGkuc2VsZlN1YnRyYWN0KHIpLnNlbGZBZGQobykuc2VsZlN1YnRyYWN0KGwpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZUNDKHQsZSxuLHMpe2NvbnN0IGk9bmUuY2lyY3VtY2VudHJlKHQsZSxuKSxyPXQuZGlzdGFuY2UoaSk7cmV0dXJuIHMuZGlzdGFuY2UoaSktcjw9MH1zdGF0aWMgaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT10Lngtcy54LHI9dC55LXMueSxvPWUueC1zLngsbD1lLnktcy55LGE9bi54LXMueCxjPW4ueS1zLnk7cmV0dXJuKGkqaStyKnIpKihvKmMtYSpsKSsobypvK2wqbCkqKGEqci1pKmMpKyhhKmErYypjKSooaSpsLW8qcik+MH1zdGF0aWMgaXNJbkNpcmNsZUREU2xvdyh0LGUsbixzKXtjb25zdCBpPUEudmFsdWVPZihzLngpLHI9QS52YWx1ZU9mKHMueSksbz1BLnZhbHVlT2YodC54KSxsPUEudmFsdWVPZih0LnkpLGE9QS52YWx1ZU9mKGUueCksYz1BLnZhbHVlT2YoZS55KSxoPUEudmFsdWVPZihuLngpLHU9QS52YWx1ZU9mKG4ueSksZz1vLm11bHRpcGx5KG8pLmFkZChsLm11bHRpcGx5KGwpKS5tdWx0aXBseShZby50cmlBcmVhRERTbG93KGEsYyxoLHUsaSxyKSksZD1hLm11bHRpcGx5KGEpLmFkZChjLm11bHRpcGx5KGMpKS5tdWx0aXBseShZby50cmlBcmVhRERTbG93KG8sbCxoLHUsaSxyKSksXz1oLm11bHRpcGx5KGgpLmFkZCh1Lm11bHRpcGx5KHUpKS5tdWx0aXBseShZby50cmlBcmVhRERTbG93KG8sbCxhLGMsaSxyKSkscD1pLm11bHRpcGx5KGkpLmFkZChyLm11bHRpcGx5KHIpKS5tdWx0aXBseShZby50cmlBcmVhRERTbG93KG8sbCxhLGMsaCx1KSk7cmV0dXJuIGcuc3VidHJhY3QoZCkuYWRkKF8pLnN1YnRyYWN0KHApLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixzKXtyZXR1cm4odC54KnQueCt0LnkqdC55KSpZby50cmlBcmVhKGUsbixzKS0oZS54KmUueCtlLnkqZS55KSpZby50cmlBcmVhKHQsbixzKSsobi54Km4ueCtuLnkqbi55KSpZby50cmlBcmVhKHQsZSxzKS0ocy54KnMueCtzLnkqcy55KSpZby50cmlBcmVhKHQsZSxuKT4wfXN0YXRpYyBpc0luQ2lyY2xlUm9idXN0KHQsZSxuLHMpe3JldHVybiBZby5pc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixzKX1zdGF0aWMgdHJpQXJlYUREU2xvdyh0LGUsbixzLGkscil7cmV0dXJuIG4uc3VidHJhY3QodCkubXVsdGlwbHkoci5zdWJ0cmFjdChlKSkuc3VidHJhY3Qocy5zdWJ0cmFjdChlKS5tdWx0aXBseShpLnN1YnRyYWN0KHQpKSl9c3RhdGljIHRyaUFyZWFEREZhc3QodCxlLG4pe2NvbnN0IHM9QS52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KEEudmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxpPUEudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShBLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QodC54KSk7cmV0dXJuIHMuc2VsZlN1YnRyYWN0KGkpfX1jbGFzcyBWb3tjb25zdHJ1Y3Rvcigpe1ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3A9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcD1uZXcgbSh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPW5ldyBtKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcD1uZXcgbSh0LGUsbil9fXN0YXRpYyBpbnRlcnBvbGF0ZVooKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmRpc3RhbmNlKG4pLGk9dC5kaXN0YW5jZShlKSxyPW4uZ2V0WigpLWUuZ2V0WigpO3JldHVybiBlLmdldFooKStyKihpL3MpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWUueCxyPWUueSxvPW4ueC1pLGw9cy54LWksYT1uLnktcixjPXMueS1yLGg9bypjLWwqYSx1PXQueC1pLGc9dC55LXIsZD0oYyp1LWwqZykvaCxfPSgtYSp1K28qZykvaDtyZXR1cm4gZS5nZXRaKCkrZCoobi5nZXRaKCktZS5nZXRaKCkpK18qKHMuZ2V0WigpLWUuZ2V0WigpKX19Y2lyY2xlQ2VudGVyKHQsZSl7Y29uc3Qgbj1uZXcgVm8odGhpcy5nZXRYKCksdGhpcy5nZXRZKCkpLHM9dGhpcy5iaXNlY3RvcihuLHQpLGk9dGhpcy5iaXNlY3Rvcih0LGUpLHI9bmV3IGVlKHMsaSk7bGV0IG89bnVsbDt0cnl7bz1uZXcgVm8oci5nZXRYKCksci5nZXRZKCkpfWNhdGNoKHMpe2lmKCEocyBpbnN0YW5jZW9mIHRlKSl0aHJvdyBzO1kuZXJyLnByaW50bG4oXCJhOiBcIituK1wiICBiOiBcIit0K1wiICBjOiBcIitlKSxZLmVyci5wcmludGxuKHMpfXJldHVybiBvfWRvdCh0KXtyZXR1cm4gdGhpcy5fcC54KnQuZ2V0WCgpK3RoaXMuX3AueSp0LmdldFkoKX1tYWduKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLl9wLngqdGhpcy5fcC54K3RoaXMuX3AueSp0aGlzLl9wLnkpfWdldFooKXtyZXR1cm4gdGhpcy5fcC5nZXRaKCl9YmlzZWN0b3IodCxlKXtjb25zdCBuPWUuZ2V0WCgpLXQuZ2V0WCgpLHM9ZS5nZXRZKCktdC5nZXRZKCksaT1uZXcgZWUodC5nZXRYKCkrbi8yLHQuZ2V0WSgpK3MvMiwxKSxyPW5ldyBlZSh0LmdldFgoKS1zK24vMix0LmdldFkoKStuK3MvMiwxKTtyZXR1cm4gbmV3IGVlKGkscil9ZXF1YWxzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9wLng9PT10LmdldFgoKSYmdGhpcy5fcC55PT09dC5nZXRZKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9wLmRpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZSgpKTxlfX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B9aXNJbkNpcmNsZSh0LGUsbil7cmV0dXJuIFlvLmlzSW5DaXJjbGVSb2J1c3QodC5fcCxlLl9wLG4uX3AsdGhpcy5fcCl9aW50ZXJwb2xhdGVaVmFsdWUodCxlLG4pe2NvbnN0IHM9dC5nZXRYKCksaT10LmdldFkoKSxyPWUuZ2V0WCgpLXMsbz1uLmdldFgoKS1zLGw9ZS5nZXRZKCktaSxhPW4uZ2V0WSgpLWksYz1yKmEtbypsLGg9dGhpcy5nZXRYKCktcyx1PXRoaXMuZ2V0WSgpLWksZz0oYSpoLW8qdSkvYyxkPSgtbCpoK3IqdSkvYztyZXR1cm4gdC5nZXRaKCkrZyooZS5nZXRaKCktdC5nZXRaKCkpK2QqKG4uZ2V0WigpLXQuZ2V0WigpKX1taWRQb2ludCh0KXtjb25zdCBlPSh0aGlzLl9wLngrdC5nZXRYKCkpLzIsbj0odGhpcy5fcC55K3QuZ2V0WSgpKS8yLHM9KHRoaXMuX3AuZ2V0WigpK3QuZ2V0WigpKS8yO3JldHVybiBuZXcgVm8oZSxuLHMpfXJpZ2h0T2YodCl7cmV0dXJuIHRoaXMuaXNDQ1codC5kZXN0KCksdC5vcmlnKCkpfWlzQ0NXKHQsZSl7cmV0dXJuKHQuX3AueC10aGlzLl9wLngpKihlLl9wLnktdGhpcy5fcC55KS0odC5fcC55LXRoaXMuX3AueSkqKGUuX3AueC10aGlzLl9wLngpPjB9Z2V0WCgpe3JldHVybiB0aGlzLl9wLnh9Y3Jvc3NQcm9kdWN0KHQpe3JldHVybiB0aGlzLl9wLngqdC5nZXRZKCktdGhpcy5fcC55KnQuZ2V0WCgpfXNldFoodCl7dGhpcy5fcC5zZXRaKHQpfXRpbWVzKHQpe3JldHVybiBuZXcgVm8odCp0aGlzLl9wLngsdCp0aGlzLl9wLnkpfWNyb3NzKCl7cmV0dXJuIG5ldyBWbyh0aGlzLl9wLnksLXRoaXMuX3AueCl9bGVmdE9mKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQub3JpZygpLHQuZGVzdCgpKX10b1N0cmluZygpe3JldHVyblwiUE9JTlQgKFwiK3RoaXMuX3AueCtcIiBcIit0aGlzLl9wLnkrXCIpXCJ9c3ViKHQpe3JldHVybiBuZXcgVm8odGhpcy5fcC54LXQuZ2V0WCgpLHRoaXMuX3AueS10LmdldFkoKSl9Z2V0WSgpe3JldHVybiB0aGlzLl9wLnl9Y2xhc3NpZnkodCxlKXtjb25zdCBuPXRoaXMscz1lLnN1Yih0KSxpPW4uc3ViKHQpLHI9cy5jcm9zc1Byb2R1Y3QoaSk7cmV0dXJuIHI+MD9Wby5MRUZUOnI8MD9Wby5SSUdIVDpzLmdldFgoKSppLmdldFgoKTwwfHxzLmdldFkoKSppLmdldFkoKTwwP1ZvLkJFSElORDpzLm1hZ24oKTxpLm1hZ24oKT9Wby5CRVlPTkQ6dC5lcXVhbHMobik/Vm8uT1JJR0lOOmUuZXF1YWxzKG4pP1ZvLkRFU1RJTkFUSU9OOlZvLkJFVFdFRU59c3VtKHQpe3JldHVybiBuZXcgVm8odGhpcy5fcC54K3QuZ2V0WCgpLHRoaXMuX3AueSt0LmdldFkoKSl9ZGlzdGFuY2UodCxlKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGUuZ2V0WCgpLXQuZ2V0WCgpLDIpK01hdGgucG93KGUuZ2V0WSgpLXQuZ2V0WSgpLDIpKX1jaXJjdW1SYWRpdXNSYXRpbyh0LGUpe2NvbnN0IG49dGhpcy5jaXJjbGVDZW50ZXIodCxlKSxzPXRoaXMuZGlzdGFuY2Uobix0KTtsZXQgaT10aGlzLmRpc3RhbmNlKHRoaXMsdCkscj10aGlzLmRpc3RhbmNlKHQsZSk7cmV0dXJuIHI8aSYmKGk9cikscj10aGlzLmRpc3RhbmNlKGUsdGhpcykscjxpJiYoaT1yKSxzL2l9fVZvLkxFRlQ9MCxWby5SSUdIVD0xLFZvLkJFWU9ORD0yLFZvLkJFSElORD0zLFZvLkJFVFdFRU49NCxWby5PUklHSU49NSxWby5ERVNUSU5BVElPTj02O2NsYXNzIHpvIGV4dGVuZHMgVm97Y29uc3RydWN0b3IoKXtzdXBlcigpLHpvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzT25Db25zdHJhaW50PW51bGwsdGhpcy5fY29uc3RyYWludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO1ZvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9Z2V0Q29uc3RyYWludCgpe3JldHVybiB0aGlzLl9jb25zdHJhaW50fXNldE9uQ29uc3RyYWludCh0KXt0aGlzLl9pc09uQ29uc3RyYWludD10fW1lcmdlKHQpe3QuX2lzT25Db25zdHJhaW50JiYodGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5fY29uc3RyYWludD10Ll9jb25zdHJhaW50KX1pc09uQ29uc3RyYWludCgpe3JldHVybiB0aGlzLl9pc09uQ29uc3RyYWludH1zZXRDb25zdHJhaW50KHQpe3RoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuX2NvbnN0cmFpbnQ9dH19Y2xhc3MgWG97Y29uc3RydWN0b3IoKXtYby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yb3Q9bnVsbCx0aGlzLl92ZXJ0ZXg9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fZGF0YT1udWxsfXN0YXRpYyBtYWtlRWRnZSh0LGUpe2NvbnN0IG49bmV3IFhvLHM9bmV3IFhvLGk9bmV3IFhvLHI9bmV3IFhvO24uX3JvdD1zLHMuX3JvdD1pLGkuX3JvdD1yLHIuX3JvdD1uLG4uc2V0TmV4dChuKSxzLnNldE5leHQociksaS5zZXROZXh0KGkpLHIuc2V0TmV4dChzKTtjb25zdCBvPW47cmV0dXJuIG8uc2V0T3JpZyh0KSxvLnNldERlc3QoZSksb31zdGF0aWMgc3dhcCh0KXtjb25zdCBlPXQub1ByZXYoKSxuPXQuc3ltKCkub1ByZXYoKTtYby5zcGxpY2UodCxlKSxYby5zcGxpY2UodC5zeW0oKSxuKSxYby5zcGxpY2UodCxlLmxOZXh0KCkpLFhvLnNwbGljZSh0LnN5bSgpLG4ubE5leHQoKSksdC5zZXRPcmlnKGUuZGVzdCgpKSx0LnNldERlc3Qobi5kZXN0KCkpfXN0YXRpYyBzcGxpY2UodCxlKXtjb25zdCBuPXQub05leHQoKS5yb3QoKSxzPWUub05leHQoKS5yb3QoKSxpPWUub05leHQoKSxyPXQub05leHQoKSxvPXMub05leHQoKSxsPW4ub05leHQoKTt0LnNldE5leHQoaSksZS5zZXROZXh0KHIpLG4uc2V0TmV4dChvKSxzLnNldE5leHQobCl9c3RhdGljIGNvbm5lY3QodCxlKXtjb25zdCBuPVhvLm1ha2VFZGdlKHQuZGVzdCgpLGUub3JpZygpKTtyZXR1cm4gWG8uc3BsaWNlKG4sdC5sTmV4dCgpKSxYby5zcGxpY2Uobi5zeW0oKSxlKSxufWVxdWFsc05vbk9yaWVudGVkKHQpe3JldHVybiEhdGhpcy5lcXVhbHNPcmllbnRlZCh0KXx8ISF0aGlzLmVxdWFsc09yaWVudGVkKHQuc3ltKCkpfXRvTGluZVNlZ21lbnQoKXtyZXR1cm4gbmV3IEt0KHRoaXMuX3ZlcnRleC5nZXRDb29yZGluYXRlKCksdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX1kZXN0KCl7cmV0dXJuIHRoaXMuc3ltKCkub3JpZygpfW9OZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9ZXF1YWxzT3JpZW50ZWQodCl7cmV0dXJuISghdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSl8fCF0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKSl9ZE5leHQoKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpLnN5bSgpfWxQcmV2KCl7cmV0dXJuIHRoaXMuX25leHQuc3ltKCl9clByZXYoKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpfXJvdCgpe3JldHVybiB0aGlzLl9yb3R9b1ByZXYoKXtyZXR1cm4gdGhpcy5fcm90Ll9uZXh0Ll9yb3R9c3ltKCl7cmV0dXJuIHRoaXMuX3JvdC5fcm90fXNldE9yaWcodCl7dGhpcy5fdmVydGV4PXR9bE5leHQoKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLnJvdCgpfWdldExlbmd0aCgpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UodGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX1pbnZSb3QoKXtyZXR1cm4gdGhpcy5fcm90LnN5bSgpfXNldERlc3QodCl7dGhpcy5zeW0oKS5zZXRPcmlnKHQpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1kZWxldGUoKXt0aGlzLl9yb3Q9bnVsbH1vcmlnKCl7cmV0dXJuIHRoaXMuX3ZlcnRleH1yTmV4dCgpe3JldHVybiB0aGlzLl9yb3QuX25leHQuaW52Um90KCl9dG9TdHJpbmcoKXtjb25zdCB0PXRoaXMuX3ZlcnRleC5nZXRDb29yZGluYXRlKCksZT10aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCk7cmV0dXJuIFd0LnRvTGluZVN0cmluZyh0LGUpfWlzTGl2ZSgpe3JldHVybiBudWxsIT09dGhpcy5fcm90fWdldFByaW1hcnkoKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpPD0wP3RoaXM6dGhpcy5zeW0oKX1kUHJldigpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkuaW52Um90KCl9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9fWNsYXNzIGtve2NvbnN0cnVjdG9yKCl7a28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3ViZGl2PW51bGwsdGhpcy5faXNVc2luZ1RvbGVyYW5jZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJkaXY9dCx0aGlzLl9pc1VzaW5nVG9sZXJhbmNlPXQuZ2V0VG9sZXJhbmNlKCk+MH1pbnNlcnRTaXRlKHQpe2xldCBlPXRoaXMuX3N1YmRpdi5sb2NhdGUodCk7aWYodGhpcy5fc3ViZGl2LmlzVmVydGV4T2ZFZGdlKGUsdCkpcmV0dXJuIGU7dGhpcy5fc3ViZGl2LmlzT25FZGdlKGUsdC5nZXRDb29yZGluYXRlKCkpJiYoZT1lLm9QcmV2KCksdGhpcy5fc3ViZGl2LmRlbGV0ZShlLm9OZXh0KCkpKTtsZXQgbj10aGlzLl9zdWJkaXYubWFrZUVkZ2UoZS5vcmlnKCksdCk7WG8uc3BsaWNlKG4sZSk7Y29uc3Qgcz1uO2Rve249dGhpcy5fc3ViZGl2LmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKX13aGlsZShlLmxOZXh0KCkhPT1zKTtmb3IoOzspe2NvbnN0IGk9ZS5vUHJldigpO2lmKGkuZGVzdCgpLnJpZ2h0T2YoZSkmJnQuaXNJbkNpcmNsZShlLm9yaWcoKSxpLmRlc3QoKSxlLmRlc3QoKSkpWG8uc3dhcChlKSxlPWUub1ByZXYoKTtlbHNle2lmKGUub05leHQoKT09PXMpcmV0dXJuIG47ZT1lLm9OZXh0KCkubFByZXYoKX19fWluc2VydFNpdGVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZSh0KX19fWNsYXNzIFVve2xvY2F0ZSh0KXt9fWNsYXNzIEhve2NvbnN0cnVjdG9yKCl7SG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fbGFzdEVkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJkaXY9dCx0aGlzLmluaXQoKX1pbml0KCl7dGhpcy5fbGFzdEVkZ2U9dGhpcy5maW5kRWRnZSgpfWxvY2F0ZSh0KXt0aGlzLl9sYXN0RWRnZS5pc0xpdmUoKXx8dGhpcy5pbml0KCk7Y29uc3QgZT10aGlzLl9zdWJkaXYubG9jYXRlRnJvbUVkZ2UodCx0aGlzLl9sYXN0RWRnZSk7cmV0dXJuIHRoaXMuX2xhc3RFZGdlPWUsZX1maW5kRWRnZSgpe3JldHVybiB0aGlzLl9zdWJkaXYuZ2V0RWRnZXMoKS5pdGVyYXRvcigpLm5leHQoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVW9dfX1jbGFzcyBXbyBleHRlbmRzIGh7Y29uc3RydWN0b3IoKXtzdXBlcigpLFdvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3NlZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsXCJMb2NhdGUgZmFpbGVkIHRvIGNvbnZlcmdlIChhdCBlZGdlOiBcIit0K1wiKS4gIFBvc3NpYmxlIGNhdXNlcyBpbmNsdWRlIGludmFsaWQgU3ViZGl2aXNpb24gdG9wb2xvZ3kgb3IgdmVyeSBjbG9zZSBzaXRlc1wiKSx0aGlzLl9zZWc9bmV3IEt0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsV28ubXNnV2l0aFNwYXRpYWwodCxlKSksdGhpcy5fc2VnPW5ldyBLdChlKX19c3RhdGljIG1zZ1dpdGhTcGF0aWFsKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitlK1wiIF1cIjp0fWdldFNlZ21lbnQoKXtyZXR1cm4gdGhpcy5fc2VnfX1jbGFzcyBab3t2aXNpdCh0KXt9fWNsYXNzIGpve2NvbnN0cnVjdG9yKCl7am8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdmlzaXRlZEtleT0wLHRoaXMuX3F1YWRFZGdlcz1uZXcgTCx0aGlzLl9zdGFydGluZ0VkZ2U9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbCx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9mcmFtZVZlcnRleD1uZXcgQXJyYXkoMykuZmlsbChudWxsKSx0aGlzLl9mcmFtZUVudj1udWxsLHRoaXMuX2xvY2F0b3I9bnVsbCx0aGlzLl9zZWc9bmV3IEt0LHRoaXMuX3RyaUVkZ2VzPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3RvbGVyYW5jZT1lLHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1lL2pvLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUix0aGlzLmNyZWF0ZUZyYW1lKHQpLHRoaXMuX3N0YXJ0aW5nRWRnZT10aGlzLmluaXRTdWJkaXYoKSx0aGlzLl9sb2NhdG9yPW5ldyBIbyh0aGlzKX1zdGF0aWMgZ2V0VHJpYW5nbGVFZGdlcyh0LGUpe2lmKGVbMF09dCxlWzFdPWVbMF0ubE5leHQoKSxlWzJdPWVbMV0ubE5leHQoKSxlWzJdLmxOZXh0KCkhPT1lWzBdKXRocm93IG5ldyBzKFwiRWRnZXMgZG8gbm90IGZvcm0gYSB0cmlhbmdsZVwiKX1nZXRUcmlhbmdsZVZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IEpvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZVZlcnRpY2VzKCl9aXNGcmFtZVZlcnRleCh0KXtyZXR1cm4hIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzBdKXx8KCEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMV0pfHwhIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzJdKSl9aXNWZXJ0ZXhPZkVkZ2UodCxlKXtyZXR1cm4hKCFlLmVxdWFscyh0Lm9yaWcoKSx0aGlzLl90b2xlcmFuY2UpJiYhZS5lcXVhbHModC5kZXN0KCksdGhpcy5fdG9sZXJhbmNlKSl9Y29ubmVjdCh0LGUpe2NvbnN0IG49WG8uY29ubmVjdCh0LGUpO3JldHVybiB0aGlzLl9xdWFkRWRnZXMuYWRkKG4pLG59Z2V0Vm9yb25vaUNlbGxQb2x5Z29uKHQsZSl7Y29uc3Qgbj1uZXcgTCxzPXQ7ZG97Y29uc3QgZT10LnJvdCgpLm9yaWcoKS5nZXRDb29yZGluYXRlKCk7bi5hZGQoZSksdD10Lm9QcmV2KCl9d2hpbGUodCE9PXMpO2NvbnN0IGk9bmV3IFI7aS5hZGRBbGwobiwhMSksaS5jbG9zZVJpbmcoKSxpLnNpemUoKTw0JiYoWS5vdXQucHJpbnRsbihpKSxpLmFkZChpLmdldChpLnNpemUoKS0xKSwhMCkpO2NvbnN0IHI9aS50b0Nvb3JkaW5hdGVBcnJheSgpLG89ZS5jcmVhdGVQb2x5Z29uKGUuY3JlYXRlTGluZWFyUmluZyhyKSksbD1zLm9yaWcoKTtyZXR1cm4gby5zZXRVc2VyRGF0YShsLmdldENvb3JkaW5hdGUoKSksb31zZXRMb2NhdG9yKHQpe3RoaXMuX2xvY2F0b3I9dH1pbml0U3ViZGl2KCl7Y29uc3QgdD10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzBdLHRoaXMuX2ZyYW1lVmVydGV4WzFdKSxlPXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMV0sdGhpcy5fZnJhbWVWZXJ0ZXhbMl0pO1hvLnNwbGljZSh0LnN5bSgpLGUpO2NvbnN0IG49dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFsyXSx0aGlzLl9mcmFtZVZlcnRleFswXSk7cmV0dXJuIFhvLnNwbGljZShlLnN5bSgpLG4pLFhvLnNwbGljZShuLnN5bSgpLHQpLHR9aXNGcmFtZUJvcmRlckVkZ2UodCl7Y29uc3QgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtqby5nZXRUcmlhbmdsZUVkZ2VzKHQsZSk7Y29uc3Qgbj1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtqby5nZXRUcmlhbmdsZUVkZ2VzKHQuc3ltKCksbik7Y29uc3Qgcz10LmxOZXh0KCkuZGVzdCgpO2lmKHRoaXMuaXNGcmFtZVZlcnRleChzKSlyZXR1cm4hMDtjb25zdCBpPXQuc3ltKCkubE5leHQoKS5kZXN0KCk7cmV0dXJuISF0aGlzLmlzRnJhbWVWZXJ0ZXgoaSl9bWFrZUVkZ2UodCxlKXtjb25zdCBuPVhvLm1ha2VFZGdlKHQsZSk7cmV0dXJuIHRoaXMuX3F1YWRFZGdlcy5hZGQobiksbn12aXNpdFRyaWFuZ2xlcyh0LGUpe3RoaXMuX3Zpc2l0ZWRLZXkrKztjb25zdCBuPW5ldyBlbjtuLnB1c2godGhpcy5fc3RhcnRpbmdFZGdlKTtjb25zdCBzPW5ldyBFdDtmb3IoOyFuLmVtcHR5KCk7KXtjb25zdCBpPW4ucG9wKCk7aWYoIXMuY29udGFpbnMoaSkpe2NvbnN0IHI9dGhpcy5mZXRjaFRyaWFuZ2xlVG9WaXNpdChpLG4sZSxzKTtudWxsIT09ciYmdC52aXNpdChyKX19fWlzRnJhbWVFZGdlKHQpe3JldHVybiEoIXRoaXMuaXNGcmFtZVZlcnRleCh0Lm9yaWcoKSkmJiF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5kZXN0KCkpKX1pc09uRWRnZSh0LGUpe3RoaXMuX3NlZy5zZXRDb29yZGluYXRlcyh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCksdC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTtyZXR1cm4gdGhpcy5fc2VnLmRpc3RhbmNlKGUpPHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZX1nZXRFbnZlbG9wZSgpe3JldHVybiBuZXcgTyh0aGlzLl9mcmFtZUVudil9Y3JlYXRlRnJhbWUodCl7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpO2xldCBzPTA7cz1lPm4/MTAqZToxMCpuLHRoaXMuX2ZyYW1lVmVydGV4WzBdPW5ldyBWbygodC5nZXRNYXhYKCkrdC5nZXRNaW5YKCkpLzIsdC5nZXRNYXhZKCkrcyksdGhpcy5fZnJhbWVWZXJ0ZXhbMV09bmV3IFZvKHQuZ2V0TWluWCgpLXMsdC5nZXRNaW5ZKCktcyksdGhpcy5fZnJhbWVWZXJ0ZXhbMl09bmV3IFZvKHQuZ2V0TWF4WCgpK3MsdC5nZXRNaW5ZKCktcyksdGhpcy5fZnJhbWVFbnY9bmV3IE8odGhpcy5fZnJhbWVWZXJ0ZXhbMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2ZyYW1lVmVydGV4WzFdLmdldENvb3JkaW5hdGUoKSksdGhpcy5fZnJhbWVFbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2ZyYW1lVmVydGV4WzJdLmdldENvb3JkaW5hdGUoKSl9Z2V0VHJpYW5nbGVDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyAkbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVzKCl9Z2V0VmVydGljZXModCl7Y29uc3QgZT1uZXcgRXQ7Zm9yKGxldCBuPXRoaXMuX3F1YWRFZGdlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMub3JpZygpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgoaSl8fGUuYWRkKGkpO2NvbnN0IHI9cy5kZXN0KCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQocil9cmV0dXJuIGV9ZmV0Y2hUcmlhbmdsZVRvVmlzaXQodCxlLG4scyl7bGV0IGk9dCxyPTAsbz0hMTtkb3t0aGlzLl90cmlFZGdlc1tyXT1pLHRoaXMuaXNGcmFtZUVkZ2UoaSkmJihvPSEwKTtjb25zdCB0PWkuc3ltKCk7cy5jb250YWlucyh0KXx8ZS5wdXNoKHQpLHMuYWRkKGkpLHIrKyxpPWkubE5leHQoKX13aGlsZShpIT09dCk7cmV0dXJuIG8mJiFuP251bGw6dGhpcy5fdHJpRWRnZXN9Z2V0RWRnZXMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0UHJpbWFyeUVkZ2VzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZUxpbmVTdHJpbmcoW2Uub3JpZygpLmdldENvb3JkaW5hdGUoKSxlLmRlc3QoKS5nZXRDb29yZGluYXRlKCldKX1yZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9fWdldFZlcnRleFVuaXF1ZUVkZ2VzKHQpe2NvbnN0IGU9bmV3IEwsbj1uZXcgRXQ7Zm9yKGxldCBzPXRoaXMuX3F1YWRFZGdlcy5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKSxyPWkub3JpZygpO24uY29udGFpbnMocil8fChuLmFkZChyKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHIpfHxlLmFkZChpKSk7Y29uc3Qgbz1pLnN5bSgpLGw9by5vcmlnKCk7bi5jb250YWlucyhsKXx8KG4uYWRkKGwpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgobCl8fGUuYWRkKG8pKX1yZXR1cm4gZX1nZXRUcmlhbmdsZUVkZ2VzKHQpe2NvbnN0IGU9bmV3IFFvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZUVkZ2VzKCl9Z2V0UHJpbWFyeUVkZ2VzKHQpe3RoaXMuX3Zpc2l0ZWRLZXkrKztjb25zdCBlPW5ldyBMLG49bmV3IGVuO24ucHVzaCh0aGlzLl9zdGFydGluZ0VkZ2UpO2NvbnN0IHM9bmV3IEV0O2Zvcig7IW4uZW1wdHkoKTspe2NvbnN0IGk9bi5wb3AoKTtpZighcy5jb250YWlucyhpKSl7Y29uc3Qgcj1pLmdldFByaW1hcnkoKTshdCYmdGhpcy5pc0ZyYW1lRWRnZShyKXx8ZS5hZGQociksbi5wdXNoKGkub05leHQoKSksbi5wdXNoKGkuc3ltKCkub05leHQoKSkscy5hZGQoaSkscy5hZGQoaS5zeW0oKSl9fXJldHVybiBlfWRlbGV0ZSh0KXtYby5zcGxpY2UodCx0Lm9QcmV2KCkpLFhvLnNwbGljZSh0LnN5bSgpLHQuc3ltKCkub1ByZXYoKSk7Y29uc3QgZT10LnN5bSgpLG49dC5yb3QoKSxzPXQucm90KCkuc3ltKCk7dGhpcy5fcXVhZEVkZ2VzLnJlbW92ZSh0KSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKGUpLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUobiksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShzKSx0LmRlbGV0ZSgpLGUuZGVsZXRlKCksbi5kZWxldGUoKSxzLmRlbGV0ZSgpfWxvY2F0ZUZyb21FZGdlKHQsZSl7bGV0IG49MDtjb25zdCBzPXRoaXMuX3F1YWRFZGdlcy5zaXplKCk7bGV0IGk9ZTtmb3IoOzspe2lmKG4rKyxuPnMpdGhyb3cgbmV3IFdvKGkudG9MaW5lU2VnbWVudCgpKTtpZih0LmVxdWFscyhpLm9yaWcoKSl8fHQuZXF1YWxzKGkuZGVzdCgpKSlicmVhaztpZih0LnJpZ2h0T2YoaSkpaT1pLnN5bSgpO2Vsc2UgaWYodC5yaWdodE9mKGkub05leHQoKSkpe2lmKHQucmlnaHRPZihpLmRQcmV2KCkpKWJyZWFrO2k9aS5kUHJldigpfWVsc2UgaT1pLm9OZXh0KCl9cmV0dXJuIGl9Z2V0VG9sZXJhbmNlKCl7cmV0dXJuIHRoaXMuX3RvbGVyYW5jZX1nZXRWb3Jvbm9pQ2VsbFBvbHlnb25zKHQpe3RoaXMudmlzaXRUcmlhbmdsZXMobmV3IEtvLCEwKTtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10aGlzLmdldFZlcnRleFVuaXF1ZUVkZ2VzKCExKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtlLmFkZCh0aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbihzLHQpKX1yZXR1cm4gZX1nZXRWb3Jvbm9pRGlhZ3JhbSh0KXtjb25zdCBlPXRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KTtyZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oTHQudG9HZW9tZXRyeUFycmF5KGUpKX1nZXRUcmlhbmdsZXModCl7Y29uc3QgZT10aGlzLmdldFRyaWFuZ2xlQ29vcmRpbmF0ZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBzPTA7Zm9yKGxldCBpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IGU9aS5uZXh0KCk7bltzKytdPXQuY3JlYXRlUG9seWdvbih0LmNyZWF0ZUxpbmVhclJpbmcoZSkpfXJldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX1pbnNlcnRTaXRlKHQpe2xldCBlPXRoaXMubG9jYXRlKHQpO2lmKHQuZXF1YWxzKGUub3JpZygpLHRoaXMuX3RvbGVyYW5jZSl8fHQuZXF1YWxzKGUuZGVzdCgpLHRoaXMuX3RvbGVyYW5jZSkpcmV0dXJuIGU7bGV0IG49dGhpcy5tYWtlRWRnZShlLm9yaWcoKSx0KTtYby5zcGxpY2UobixlKTtjb25zdCBzPW47ZG97bj10aGlzLmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKX13aGlsZShlLmxOZXh0KCkhPT1zKTtyZXR1cm4gc31sb2NhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBWbyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xvY2F0b3IubG9jYXRlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xvY2F0b3IubG9jYXRlKG5ldyBWbyh0KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbG9jYXRvci5sb2NhdGUobmV3IFZvKHQpKTtpZihudWxsPT09bilyZXR1cm4gbnVsbDtsZXQgcz1uO24uZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0KSYmKHM9bi5zeW0oKSk7bGV0IGk9cztkb3tpZihpLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQoZSkpcmV0dXJuIGk7aT1pLm9OZXh0KCl9d2hpbGUoaSE9PXMpO3JldHVybiBudWxsfX19Y2xhc3MgS297dmlzaXQodCl7Y29uc3QgZT10WzBdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksbj10WzFdLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscz10WzJdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksaT1uZS5jaXJjdW1jZW50cmVERChlLG4scykscj1uZXcgVm8oaSk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl0W2VdLnJvdCgpLnNldE9yaWcocil9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1pvXX19Y2xhc3MgUW97Y29uc3RydWN0b3IoKXtRby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90cmlMaXN0PW5ldyBMfWdldFRyaWFuZ2xlRWRnZXMoKXtyZXR1cm4gdGhpcy5fdHJpTGlzdH12aXNpdCh0KXt0aGlzLl90cmlMaXN0LmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bWm9dfX1jbGFzcyBKb3tjb25zdHJ1Y3Rvcigpe0pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3RyaUxpc3Q9bmV3IEx9dmlzaXQodCl7dGhpcy5fdHJpTGlzdC5hZGQoW3RbMF0ub3JpZygpLHRbMV0ub3JpZygpLHRbMl0ub3JpZygpXSl9Z2V0VHJpYW5nbGVWZXJ0aWNlcygpe3JldHVybiB0aGlzLl90cmlMaXN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltab119fWNsYXNzICRve2NvbnN0cnVjdG9yKCl7JG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmRMaXN0PW5ldyBSLHRoaXMuX3RyaUNvb3Jkcz1uZXcgTH1jaGVja1RyaWFuZ2xlU2l6ZSh0KXt0Lmxlbmd0aD49Mj9XdC50b0xpbmVTdHJpbmcodFswXSx0WzFdKTp0Lmxlbmd0aD49MSYmV3QudG9Qb2ludCh0WzBdKX12aXNpdCh0KXt0aGlzLl9jb29yZExpc3QuY2xlYXIoKTtmb3IobGV0IGU9MDtlPDM7ZSsrKXtjb25zdCBuPXRbZV0ub3JpZygpO3RoaXMuX2Nvb3JkTGlzdC5hZGQobi5nZXRDb29yZGluYXRlKCkpfWlmKHRoaXMuX2Nvb3JkTGlzdC5zaXplKCk+MCl7dGhpcy5fY29vcmRMaXN0LmNsb3NlUmluZygpO2NvbnN0IHQ9dGhpcy5fY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7aWYoNCE9PXQubGVuZ3RoKXJldHVybiBudWxsO3RoaXMuX3RyaUNvb3Jkcy5hZGQodCl9fWdldFRyaWFuZ2xlcygpe3JldHVybiB0aGlzLl90cmlDb29yZHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1pvXX19am8uVHJpYW5nbGVDaXJjdW1jZW50cmVWaXNpdG9yPUtvLGpvLlRyaWFuZ2xlRWRnZXNMaXN0VmlzaXRvcj1Rbyxqby5UcmlhbmdsZVZlcnRleExpc3RWaXNpdG9yPUpvLGpvLlRyaWFuZ2xlQ29vcmRpbmF0ZXNWaXNpdG9yPSRvLGpvLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUj0xZTM7Y2xhc3MgdGx7Y29uc3RydWN0b3IoKXt0bC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9scz1udWxsLHRoaXMuX2RhdGE9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbHM9bmV3IEt0KHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbHM9bmV3IEt0KHQsZSksdGhpcy5fZGF0YT1ufWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3RsLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IG0odCxlLG4pLG5ldyBtKHMsaSxyKSl9ZWxzZSBpZig3PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV0sbz1hcmd1bWVudHNbNl07dGwuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSh0LGUsbiksbmV3IG0ocyxpLHIpLG8pfX1nZXRMaW5lU2VnbWVudCgpe3JldHVybiB0aGlzLl9sc31nZXRFbmRaKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkuZ2V0WigpfWdldFN0YXJ0Wigpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApLmdldFooKX1pbnRlcnNlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2xzLmludGVyc2VjdGlvbih0LmdldExpbmVTZWdtZW50KCkpfWdldFN0YXJ0KCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCl9Z2V0RW5kKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSl9Z2V0RW5kWSgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLnl9Z2V0U3RhcnRYKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkueH1lcXVhbHNUb3BvKHQpe3JldHVybiB0aGlzLl9scy5lcXVhbHNUb3BvKHQuZ2V0TGluZVNlZ21lbnQoKSl9Z2V0U3RhcnRZKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkueX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9Z2V0RW5kWCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLnh9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fbHMudG9TdHJpbmcoKX19Y2xhc3MgZWwgZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxlbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGVsLm1zZ1dpdGhDb29yZCh0LGUpKSx0aGlzLl9wdD1uZXcgbShlKX19c3RhdGljIG1zZ1dpdGhDb29yZCh0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrV3QudG9Qb2ludChlKStcIiBdXCI6dH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fX1jbGFzcyBubHtjb25zdHJ1Y3Rvcigpe25sLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2luaXRpYWxWZXJ0aWNlcz1udWxsLHRoaXMuX3NlZ1ZlcnRpY2VzPW51bGwsdGhpcy5fc2VnbWVudHM9bmV3IEwsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5faW5jRGVsPW51bGwsdGhpcy5fY29udmV4SHVsbD1udWxsLHRoaXMuX3NwbGl0RmluZGVyPW5ldyBCbyx0aGlzLl9rZHQ9bnVsbCx0aGlzLl92ZXJ0ZXhGYWN0b3J5PW51bGwsdGhpcy5fY29tcHV0ZUFyZWFFbnY9bnVsbCx0aGlzLl9zcGxpdFB0PW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5pdGlhbFZlcnRpY2VzPW5ldyBMKHQpLHRoaXMuX3RvbGVyYW5jZT1lLHRoaXMuX2tkdD1uZXcgZ3MoZSl9c3RhdGljIGNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBPO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0Q29vcmRpbmF0ZSgpKX1yZXR1cm4gZX1nZXRJbml0aWFsVmVydGljZXMoKXtyZXR1cm4gdGhpcy5faW5pdGlhbFZlcnRpY2VzfWdldEtEVCgpe3JldHVybiB0aGlzLl9rZHR9ZW5mb3JjZUNvbnN0cmFpbnRzKCl7dGhpcy5hZGRDb25zdHJhaW50VmVydGljZXMoKTtsZXQgdD0wLGU9MDtkb3tlPXRoaXMuZW5mb3JjZUdhYnJpZWwodGhpcy5fc2VnbWVudHMpLHQrK313aGlsZShlPjAmJnQ8bmwuTUFYX1NQTElUX0lURVIpO2lmKHQ9PT1ubC5NQVhfU1BMSVRfSVRFUil0aHJvdyBuZXcgZWwoXCJUb28gbWFueSBzcGxpdHRpbmcgaXRlcmF0aW9ucyB3aGlsZSBlbmZvcmNpbmcgY29uc3RyYWludHMuICBMYXN0IHNwbGl0IHBvaW50IHdhcyBhdDogXCIsdGhpcy5fc3BsaXRQdCl9aW5zZXJ0U2l0ZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKHQpfX1nZXRWZXJ0ZXhGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX3ZlcnRleEZhY3Rvcnl9Z2V0UG9pbnRBcnJheSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2luaXRpYWxWZXJ0aWNlcy5zaXplKCkrdGhpcy5fc2VnVmVydGljZXMuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuX2luaXRpYWxWZXJ0aWNlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTt0W2UrK109cy5nZXRDb29yZGluYXRlKCl9Zm9yKGxldCBuPXRoaXMuX3NlZ1ZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3RbZSsrXT1zLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gdH1zZXRDb25zdHJhaW50cyh0LGUpe3RoaXMuX3NlZ21lbnRzPXQsdGhpcy5fc2VnVmVydGljZXM9ZX1jb21wdXRlQ29udmV4SHVsbCgpe2NvbnN0IHQ9bmV3IEx0LGU9dGhpcy5nZXRQb2ludEFycmF5KCksbj1uZXcgc24oZSx0KTt0aGlzLl9jb252ZXhIdWxsPW4uZ2V0Q29udmV4SHVsbCgpfWFkZENvbnN0cmFpbnRWZXJ0aWNlcygpe3RoaXMuY29tcHV0ZUNvbnZleEh1bGwoKSx0aGlzLmluc2VydFNpdGVzKHRoaXMuX3NlZ1ZlcnRpY2VzKX1maW5kTm9uR2FicmllbFBvaW50KHQpe2NvbnN0IGU9dC5nZXRTdGFydCgpLG49dC5nZXRFbmQoKSxzPW5ldyBtKChlLngrbi54KS8yLChlLnkrbi55KS8yKSxpPWUuZGlzdGFuY2Uocyksbz1uZXcgTyhzKTtvLmV4cGFuZEJ5KGkpO2NvbnN0IGw9dGhpcy5fa2R0LnF1ZXJ5KG8pO2xldCBhPW51bGwsYz1yLk1BWF9WQUxVRTtmb3IobGV0IHQ9bC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgcj10Lm5leHQoKS5nZXRDb29yZGluYXRlKCk7aWYoci5lcXVhbHMyRChlKXx8ci5lcXVhbHMyRChuKSljb250aW51ZTtjb25zdCBvPXMuZGlzdGFuY2Uocik7aWYobzxpKXtjb25zdCB0PW87KG51bGw9PT1hfHx0PGMpJiYoYT1yLGM9dCl9fXJldHVybiBhfWdldENvbnN0cmFpbnRTZWdtZW50cygpe3JldHVybiB0aGlzLl9zZWdtZW50c31zZXRTcGxpdFBvaW50RmluZGVyKHQpe3RoaXMuX3NwbGl0RmluZGVyPXR9Z2V0Q29udmV4SHVsbCgpe3JldHVybiB0aGlzLl9jb252ZXhIdWxsfWdldFRvbGVyYW5jZSgpe3JldHVybiB0aGlzLl90b2xlcmFuY2V9ZW5mb3JjZUdhYnJpZWwodCl7Y29uc3QgZT1uZXcgTDtsZXQgbj0wO2NvbnN0IHM9bmV3IEw7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCkscj10aGlzLmZpbmROb25HYWJyaWVsUG9pbnQodCk7aWYobnVsbD09PXIpY29udGludWU7dGhpcy5fc3BsaXRQdD10aGlzLl9zcGxpdEZpbmRlci5maW5kU3BsaXRQb2ludCh0LHIpO2NvbnN0IG89dGhpcy5jcmVhdGVWZXJ0ZXgodGhpcy5fc3BsaXRQdCx0KTt0aGlzLmluc2VydFNpdGUobykuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHRoaXMuX3NwbGl0UHQpO2NvbnN0IGw9bmV3IHRsKHQuZ2V0U3RhcnRYKCksdC5nZXRTdGFydFkoKSx0LmdldFN0YXJ0WigpLG8uZ2V0WCgpLG8uZ2V0WSgpLG8uZ2V0WigpLHQuZ2V0RGF0YSgpKSxhPW5ldyB0bChvLmdldFgoKSxvLmdldFkoKSxvLmdldFooKSx0LmdldEVuZFgoKSx0LmdldEVuZFkoKSx0LmdldEVuZFooKSx0LmdldERhdGEoKSk7ZS5hZGQobCksZS5hZGQoYSkscy5hZGQodCksbis9MX1yZXR1cm4gdC5yZW1vdmVBbGwocyksdC5hZGRBbGwoZSksbn1jcmVhdGVWZXJ0ZXgoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbDtyZXR1cm4gZT1udWxsIT09dGhpcy5fdmVydGV4RmFjdG9yeT90aGlzLl92ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleCh0LG51bGwpOm5ldyB6byh0KSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsO3JldHVybiBuPW51bGwhPT10aGlzLl92ZXJ0ZXhGYWN0b3J5P3RoaXMuX3ZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsZSk6bmV3IHpvKHQpLG4uc2V0T25Db25zdHJhaW50KCEwKSxufX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLl9zdWJkaXZ9Y29tcHV0ZUJvdW5kaW5nQm94KCl7Y29uc3QgdD1ubC5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5faW5pdGlhbFZlcnRpY2VzKSxlPW5sLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLl9zZWdWZXJ0aWNlcyksbj1uZXcgTyh0KTtuLmV4cGFuZFRvSW5jbHVkZShlKTtjb25zdCBzPS4yKm4uZ2V0V2lkdGgoKSxpPS4yKm4uZ2V0SGVpZ2h0KCkscj1NYXRoLm1heChzLGkpO3RoaXMuX2NvbXB1dGVBcmVhRW52PW5ldyBPKG4pLHRoaXMuX2NvbXB1dGVBcmVhRW52LmV4cGFuZEJ5KHIpfXNldFZlcnRleEZhY3RvcnkodCl7dGhpcy5fdmVydGV4RmFjdG9yeT10fWZvcm1Jbml0aWFsRGVsYXVuYXkoKXt0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuX3N1YmRpdj1uZXcgam8odGhpcy5fY29tcHV0ZUFyZWFFbnYsdGhpcy5fdG9sZXJhbmNlKSx0aGlzLl9zdWJkaXYuc2V0TG9jYXRvcihuZXcgSG8odGhpcy5fc3ViZGl2KSksdGhpcy5faW5jRGVsPW5ldyBrbyh0aGlzLl9zdWJkaXYpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5faW5pdGlhbFZlcnRpY2VzKX1pbnNlcnRTaXRlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB6byl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9rZHQuaW5zZXJ0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpO2lmKGUuaXNSZXBlYXRlZCgpKXtjb25zdCBuPWUuZ2V0RGF0YSgpO3JldHVybiBuLm1lcmdlKHQpLG59cmV0dXJuIHRoaXMuX2luY0RlbC5pbnNlcnRTaXRlKHQpLHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFNpdGUodGhpcy5jcmVhdGVWZXJ0ZXgodCkpfX19bmwuTUFYX1NQTElUX0lURVI9OTk7Y2xhc3Mgc2x7Y29uc3RydWN0b3IoKXtzbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGx9c3RhdGljIGV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KXtpZihudWxsPT09dClyZXR1cm4gbmV3IFI7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHNsLnVuaXF1ZShlKX1zdGF0aWMgZW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTztmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZSh0KX1yZXR1cm4gZX1zdGF0aWMgdW5pcXVlKHQpe2NvbnN0IGU9X3QuY29weURlZXAodCk7c3Quc29ydChlKTtyZXR1cm4gbmV3IFIoZSwhMSl9c3RhdGljIHRvVmVydGljZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgVm8odCkpfXJldHVybiBlfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1zbC5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKSxlPXNsLnRvVmVydGljZXModGhpcy5fc2l0ZUNvb3Jkcyk7dGhpcy5fc3ViZGl2PW5ldyBqbyh0LHRoaXMuX3RvbGVyYW5jZSk7bmV3IGtvKHRoaXMuX3N1YmRpdikuaW5zZXJ0U2l0ZXMoZSl9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldFNpdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPXNsLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPXNsLnVuaXF1ZShfdC50b0Nvb3JkaW5hdGVBcnJheSh0KSl9fWdldEVkZ2VzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRFZGdlcyh0KX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn1nZXRUcmlhbmdsZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX19Y2xhc3MgaWx7Y29uc3RydWN0b3IoKXtpbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fY29uc3RyYWludExpbmVzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fY29uc3RyYWludFZlcnRleE1hcD1uZXcgV259c3RhdGljIGNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXllLmdldExpbmVzKHQpLG49bmV3IEw7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7aWwuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKGUsbil9cmV0dXJuIG59aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDtuKyspdC5hZGQobmV3IHRsKGVbbi0xXSxlW25dKSl9fWNyZWF0ZVNpdGVWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAuY29udGFpbnNLZXkodCl8fGUuYWRkKG5ldyB6byh0KSl9cmV0dXJuIGV9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PXNsLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpO2xldCBlPW5ldyBMO251bGwhPT10aGlzLl9jb25zdHJhaW50TGluZXMmJih0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb25zdHJhaW50TGluZXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSx0aGlzLmNyZWF0ZVZlcnRpY2VzKHRoaXMuX2NvbnN0cmFpbnRMaW5lcyksZT1pbC5jcmVhdGVDb25zdHJhaW50U2VnbWVudHModGhpcy5fY29uc3RyYWludExpbmVzKSk7Y29uc3Qgbj10aGlzLmNyZWF0ZVNpdGVWZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKSxzPW5ldyBubChuLHRoaXMuX3RvbGVyYW5jZSk7cy5zZXRDb25zdHJhaW50cyhlLG5ldyBMKHRoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAudmFsdWVzKCkpKSxzLmZvcm1Jbml0aWFsRGVsYXVuYXkoKSxzLmVuZm9yY2VDb25zdHJhaW50cygpLHRoaXMuX3N1YmRpdj1zLmdldFN1YmRpdmlzaW9uKCl9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldENvbnN0cmFpbnRzKHQpe3RoaXMuX2NvbnN0cmFpbnRMaW5lcz10fXNldFNpdGVzKHQpe3RoaXMuX3NpdGVDb29yZHM9c2wuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWdldEVkZ2VzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRFZGdlcyh0KX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn1nZXRUcmlhbmdsZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX1jcmVhdGVWZXJ0aWNlcyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgbj1uZXcgem8oZVt0XSk7dGhpcy5fY29uc3RyYWludFZlcnRleE1hcC5wdXQoZVt0XSxuKX19fWNsYXNzIHJse2NvbnN0cnVjdG9yKCl7cmwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2NsaXBFbnY9bnVsbCx0aGlzLl9kaWFncmFtRW52PW51bGx9c3RhdGljIGNsaXBHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoZSkscz1uZXcgTDtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7Y29uc3Qgcj10LmdldEdlb21ldHJ5TihpKTtsZXQgbz1udWxsO2UuY29udGFpbnMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpP289cjplLmludGVyc2VjdHMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYobz13ci5pbnRlcnNlY3Rpb24obixyKSxvLnNldFVzZXJEYXRhKHIuZ2V0VXNlckRhdGEoKSkpLG51bGw9PT1vfHxvLmlzRW1wdHkoKXx8cy5hZGQobyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihMdC50b0dlb21ldHJ5QXJyYXkocykpfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1zbC5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKTtpZih0aGlzLl9kaWFncmFtRW52PXRoaXMuX2NsaXBFbnYsbnVsbD09PXRoaXMuX2RpYWdyYW1FbnYpe3RoaXMuX2RpYWdyYW1FbnY9dDtjb25zdCBlPXRoaXMuX2RpYWdyYW1FbnYuZ2V0RGlhbWV0ZXIoKTt0aGlzLl9kaWFncmFtRW52LmV4cGFuZEJ5KGUpfWNvbnN0IGU9c2wudG9WZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9zdWJkaXY9bmV3IGpvKHQsdGhpcy5fdG9sZXJhbmNlKTtuZXcga28odGhpcy5fc3ViZGl2KS5pbnNlcnRTaXRlcyhlKX1nZXREaWFncmFtKHQpe3RoaXMuY3JlYXRlKCk7Y29uc3QgZT10aGlzLl9zdWJkaXYuZ2V0Vm9yb25vaURpYWdyYW0odCk7cmV0dXJuIHJsLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb24oZSx0aGlzLl9kaWFncmFtRW52KX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0U2l0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9c2wuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9c2wudW5pcXVlKF90LnRvQ29vcmRpbmF0ZUFycmF5KHQpKX19c2V0Q2xpcEVudmVsb3BlKHQpe3RoaXMuX2NsaXBFbnY9dH1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn19dmFyIGxsPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFZlcnRleDpWb30pLGFsPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvbmZvcm1pbmdEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOmlsLERlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6c2wsVm9yb25vaURpYWdyYW1CdWlsZGVyOnJsLHF1YWRlZGdlOmxsfSk7Y2xhc3MgY2x7Y29uc3RydWN0b3IoKXtjbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9saW5lYXJHZW9tPW51bGwsdGhpcy5fbnVtTGluZXM9bnVsbCx0aGlzLl9jdXJyZW50TGluZT1udWxsLHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fdmVydGV4SW5kZXg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Y2wuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDAsMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Y2wuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUuZ2V0Q29tcG9uZW50SW5kZXgoKSxjbC5zZWdtZW50RW5kVmVydGV4SW5kZXgoZSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKCFJKHQsWikpdGhyb3cgbmV3IHMoXCJMaW5lYWwgZ2VvbWV0cnkgaXMgcmVxdWlyZWRcIik7dGhpcy5fbGluZWFyR2VvbT10LHRoaXMuX251bUxpbmVzPXQuZ2V0TnVtR2VvbWV0cmllcygpLHRoaXMuX2NvbXBvbmVudEluZGV4PWUsdGhpcy5fdmVydGV4SW5kZXg9bix0aGlzLmxvYWRDdXJyZW50TGluZSgpfX1zdGF0aWMgc2VnbWVudEVuZFZlcnRleEluZGV4KHQpe3JldHVybiB0LmdldFNlZ21lbnRGcmFjdGlvbigpPjA/dC5nZXRTZWdtZW50SW5kZXgoKSsxOnQuZ2V0U2VnbWVudEluZGV4KCl9Z2V0Q29tcG9uZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXh9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9jdXJyZW50TGluZX1nZXRWZXJ0ZXhJbmRleCgpe3JldHVybiB0aGlzLl92ZXJ0ZXhJbmRleH1nZXRTZWdtZW50RW5kKCl7cmV0dXJuIHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuZ2V0TGluZSgpLmdldE51bVBvaW50cygpLTE/dGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgrMSk6bnVsbH1uZXh0KCl7aWYoIXRoaXMuaGFzTmV4dCgpKXJldHVybiBudWxsO3RoaXMuX3ZlcnRleEluZGV4KyssdGhpcy5fdmVydGV4SW5kZXg+PXRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpJiYodGhpcy5fY29tcG9uZW50SW5kZXgrKyx0aGlzLmxvYWRDdXJyZW50TGluZSgpLHRoaXMuX3ZlcnRleEluZGV4PTApfWxvYWRDdXJyZW50TGluZSgpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcylyZXR1cm4gdGhpcy5fY3VycmVudExpbmU9bnVsbCxudWxsO3RoaXMuX2N1cnJlbnRMaW5lPXRoaXMuX2xpbmVhckdlb20uZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KX1nZXRTZWdtZW50U3RhcnQoKXtyZXR1cm4gdGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgpfWlzRW5kT2ZMaW5lKCl7cmV0dXJuISh0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpJiYhKHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpLTEpfWhhc05leHQoKXtyZXR1cm4hKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcykmJiEodGhpcy5fY29tcG9uZW50SW5kZXg9PT10aGlzLl9udW1MaW5lcy0xJiZ0aGlzLl92ZXJ0ZXhJbmRleD49dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCkpfX1jbGFzcyBobHtjb25zdHJ1Y3Rvcigpe2hsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9c3RhdGljIGluZGV4T2YodCxlKXtyZXR1cm4gbmV3IGhsKHQpLmluZGV4T2YoZSl9c3RhdGljIGluZGV4T2ZBZnRlcih0LGUsbil7cmV0dXJuIG5ldyBobCh0KS5pbmRleE9mQWZ0ZXIoZSxuKX1pbmRleE9mKHQpe3JldHVybiB0aGlzLmluZGV4T2ZGcm9tU3RhcnQodCwtMSl9aW5kZXhPZkZyb21TdGFydCh0LGUpe2xldCBuPXIuTUFYX1ZBTFVFLHM9ZSxpPTA7Y29uc3Qgbz1uZXcgS3QsbD1uZXcgY2wodGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtsLmhhc05leHQoKTspe2lmKCFsLmlzRW5kT2ZMaW5lKCkpe28ucDA9bC5nZXRTZWdtZW50U3RhcnQoKSxvLnAxPWwuZ2V0U2VnbWVudEVuZCgpO2NvbnN0IHI9by5kaXN0YW5jZSh0KSxhPXRoaXMuc2VnbWVudE5lYXJlc3RNZWFzdXJlKG8sdCxpKTtyPG4mJmE+ZSYmKHM9YSxuPXIpLGkrPW8uZ2V0TGVuZ3RoKCl9bC5uZXh0KCl9cmV0dXJuIHN9aW5kZXhPZkFmdGVyKHQsZSl7aWYoZTwwKXJldHVybiB0aGlzLmluZGV4T2YodCk7Y29uc3Qgbj10aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpO2lmKG48ZSlyZXR1cm4gbjtjb25zdCBzPXRoaXMuaW5kZXhPZkZyb21TdGFydCh0LGUpO3JldHVybiBnLmlzVHJ1ZShzPj1lLFwiY29tcHV0ZWQgaW5kZXggaXMgYmVmb3JlIHNwZWNpZmllZCBtaW5pbXVtIGluZGV4XCIpLHN9c2VnbWVudE5lYXJlc3RNZWFzdXJlKHQsZSxuKXtjb25zdCBzPXQucHJvamVjdGlvbkZhY3RvcihlKTtyZXR1cm4gczw9MD9uOnM8PTE/bitzKnQuZ2V0TGVuZ3RoKCk6bit0LmdldExlbmd0aCgpfX1jbGFzcyB1bHtjb25zdHJ1Y3Rvcigpe3VsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fc2VnbWVudEluZGV4PTAsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQuX2NvbXBvbmVudEluZGV4LHRoaXMuX3NlZ21lbnRJbmRleD10Ll9zZWdtZW50SW5kZXgsdGhpcy5fc2VnbWVudEZyYWN0aW9uPXQuX3NlZ21lbnRGcmFjdGlvbn1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt1bC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDAsdCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9jb21wb25lbnRJbmRleD10LHRoaXMuX3NlZ21lbnRJbmRleD1lLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj1uLHRoaXMubm9ybWFsaXplKCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fY29tcG9uZW50SW5kZXg9dCx0aGlzLl9zZWdtZW50SW5kZXg9ZSx0aGlzLl9zZWdtZW50RnJhY3Rpb249bixzJiZ0aGlzLm5vcm1hbGl6ZSgpfX1zdGF0aWMgZ2V0RW5kTG9jYXRpb24odCl7Y29uc3QgZT1uZXcgdWw7cmV0dXJuIGUuc2V0VG9FbmQodCksZX1zdGF0aWMgcG9pbnRBbG9uZ1NlZ21lbnRCeUZyYWN0aW9uKHQsZSxuKXtpZihuPD0wKXJldHVybiB0O2lmKG4+PTEpcmV0dXJuIGU7Y29uc3Qgcz0oZS54LXQueCkqbit0LngsaT0oZS55LXQueSkqbit0Lnkscj0oZS5nZXRaKCktdC5nZXRaKCkpKm4rdC5nZXRaKCk7cmV0dXJuIG5ldyBtKHMsaSxyKX1zdGF0aWMgY29tcGFyZUxvY2F0aW9uVmFsdWVzKHQsZSxuLHMsaSxyKXtyZXR1cm4gdDxzPy0xOnQ+cz8xOmU8aT8tMTplPmk/MTpuPHI/LTE6bj5yPzE6MH1zdGF0aWMgbnVtU2VnbWVudHModCl7Y29uc3QgZT10LmdldE51bVBvaW50cygpO3JldHVybiBlPD0xPzA6ZS0xfWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXh9Z2V0Q29tcG9uZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXh9aXNFbmRwb2ludCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPXVsLm51bVNlZ21lbnRzKGUpO3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXg+PW58fHRoaXMuX3NlZ21lbnRJbmRleD09PW4tMSYmdGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xfWlzVmFsaWQodCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg8MHx8dGhpcy5fY29tcG9uZW50SW5kZXg+PXQuZ2V0TnVtR2VvbWV0cmllcygpKXJldHVybiExO2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3JldHVybiEodGhpcy5fc2VnbWVudEluZGV4PDB8fHRoaXMuX3NlZ21lbnRJbmRleD5lLmdldE51bVBvaW50cygpKSYmKCh0aGlzLl9zZWdtZW50SW5kZXghPT1lLmdldE51bVBvaW50cygpfHwwPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uKSYmISh0aGlzLl9zZWdtZW50RnJhY3Rpb248MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPjEpKX1ub3JtYWxpemUoKXt0aGlzLl9zZWdtZW50RnJhY3Rpb248MCYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSx0aGlzLl9zZWdtZW50RnJhY3Rpb24+MSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKSx0aGlzLl9jb21wb25lbnRJbmRleDwwJiYodGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksdGhpcy5fc2VnbWVudEluZGV4PDAmJih0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksMT09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbiYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wLHRoaXMuX3NlZ21lbnRJbmRleCs9MSl9dG9Mb3dlc3QodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj11bC5udW1TZWdtZW50cyhlKTtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4PG4/dGhpczpuZXcgdWwodGhpcy5fY29tcG9uZW50SW5kZXgsbi0xLDEsITEpfWdldENvb3JkaW5hdGUodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCk7aWYodGhpcy5fc2VnbWVudEluZGV4Pj11bC5udW1TZWdtZW50cyhlKSlyZXR1cm4gbjtjb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KzEpO3JldHVybiB1bC5wb2ludEFsb25nU2VnbWVudEJ5RnJhY3Rpb24obixzLHRoaXMuX3NlZ21lbnRGcmFjdGlvbil9Z2V0U2VnbWVudEZyYWN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRGcmFjdGlvbn1nZXRTZWdtZW50KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgpO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49dWwubnVtU2VnbWVudHMoZSkpe2NvbnN0IHQ9ZS5nZXRDb29yZGluYXRlTihlLmdldE51bVBvaW50cygpLTIpO3JldHVybiBuZXcgS3QodCxuKX1jb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KzEpO3JldHVybiBuZXcgS3QobixzKX1jbGFtcCh0KXtpZih0aGlzLl9jb21wb25lbnRJbmRleD49dC5nZXROdW1HZW9tZXRyaWVzKCkpcmV0dXJuIHRoaXMuc2V0VG9FbmQodCksbnVsbDtpZih0aGlzLl9zZWdtZW50SW5kZXg+PXQuZ2V0TnVtUG9pbnRzKCkpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3RoaXMuX3NlZ21lbnRJbmRleD11bC5udW1TZWdtZW50cyhlKSx0aGlzLl9zZWdtZW50RnJhY3Rpb249MX19c2V0VG9FbmQodCl7dGhpcy5fY29tcG9uZW50SW5kZXg9dC5nZXROdW1HZW9tZXRyaWVzKCktMTtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTt0aGlzLl9zZWdtZW50SW5kZXg9dWwubnVtU2VnbWVudHMoZSksdGhpcy5fc2VnbWVudEZyYWN0aW9uPTB9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg8ZS5fY29tcG9uZW50SW5kZXg/LTE6dGhpcy5fY29tcG9uZW50SW5kZXg+ZS5fY29tcG9uZW50SW5kZXg/MTp0aGlzLl9zZWdtZW50SW5kZXg8ZS5fc2VnbWVudEluZGV4Py0xOnRoaXMuX3NlZ21lbnRJbmRleD5lLl9zZWdtZW50SW5kZXg/MTp0aGlzLl9zZWdtZW50RnJhY3Rpb248ZS5fc2VnbWVudEZyYWN0aW9uPy0xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbj5lLl9zZWdtZW50RnJhY3Rpb24/MTowfWNvcHkoKXtyZXR1cm4gbmV3IHVsKHRoaXMuX2NvbXBvbmVudEluZGV4LHRoaXMuX3NlZ21lbnRJbmRleCx0aGlzLl9zZWdtZW50RnJhY3Rpb24pfXRvU3RyaW5nKCl7cmV0dXJuXCJMaW5lYXJMb2NbXCIrdGhpcy5fY29tcG9uZW50SW5kZXgrXCIsIFwiK3RoaXMuX3NlZ21lbnRJbmRleCtcIiwgXCIrdGhpcy5fc2VnbWVudEZyYWN0aW9uK1wiXVwifWlzT25TYW1lU2VnbWVudCh0KXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg9PT10Ll9jb21wb25lbnRJbmRleCYmKHRoaXMuX3NlZ21lbnRJbmRleD09PXQuX3NlZ21lbnRJbmRleHx8KHQuX3NlZ21lbnRJbmRleC10aGlzLl9zZWdtZW50SW5kZXg9PTEmJjA9PT10Ll9zZWdtZW50RnJhY3Rpb258fHRoaXMuX3NlZ21lbnRJbmRleC10Ll9zZWdtZW50SW5kZXg9PTEmJjA9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24pKX1zbmFwVG9WZXJ0ZXgodCxlKXtpZih0aGlzLl9zZWdtZW50RnJhY3Rpb248PTB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MSlyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuZ2V0U2VnbWVudExlbmd0aCh0KSxzPXRoaXMuX3NlZ21lbnRGcmFjdGlvbipuLGk9bi1zO3M8PWkmJnM8ZT90aGlzLl9zZWdtZW50RnJhY3Rpb249MDppPD1zJiZpPGUmJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MSl9Y29tcGFyZUxvY2F0aW9uVmFsdWVzKHQsZSxuKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg8dD8tMTp0aGlzLl9jb21wb25lbnRJbmRleD50PzE6dGhpcy5fc2VnbWVudEluZGV4PGU/LTE6dGhpcy5fc2VnbWVudEluZGV4PmU/MTp0aGlzLl9zZWdtZW50RnJhY3Rpb248bj8tMTp0aGlzLl9zZWdtZW50RnJhY3Rpb24+bj8xOjB9Z2V0U2VnbWVudExlbmd0aCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTtsZXQgbj10aGlzLl9zZWdtZW50SW5kZXg7dGhpcy5fc2VnbWVudEluZGV4Pj11bC5udW1TZWdtZW50cyhlKSYmKG49ZS5nZXROdW1Qb2ludHMoKS0yKTtjb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4obiksaT1lLmdldENvb3JkaW5hdGVOKG4rMSk7cmV0dXJuIHMuZGlzdGFuY2UoaSl9aXNWZXJ0ZXgoKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9uPD0wfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBnbHtjb25zdHJ1Y3Rvcigpe2dsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9c3RhdGljIGluZGV4T2YodCxlKXtyZXR1cm4gbmV3IGdsKHQpLmluZGV4T2YoZSl9c3RhdGljIGluZGV4T2ZBZnRlcih0LGUsbil7cmV0dXJuIG5ldyBnbCh0KS5pbmRleE9mQWZ0ZXIoZSxuKX1pbmRleE9mKHQpe3JldHVybiB0aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxudWxsKX1pbmRleE9mRnJvbVN0YXJ0KHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz0wLGk9MCxvPS0xO2NvbnN0IGw9bmV3IEt0O2ZvcihsZXQgcj1uZXcgY2wodGhpcy5fbGluZWFyR2VvbSk7ci5oYXNOZXh0KCk7ci5uZXh0KCkpaWYoIXIuaXNFbmRPZkxpbmUoKSl7bC5wMD1yLmdldFNlZ21lbnRTdGFydCgpLGwucDE9ci5nZXRTZWdtZW50RW5kKCk7Y29uc3QgYT1sLmRpc3RhbmNlKHQpLGM9bC5zZWdtZW50RnJhY3Rpb24odCksaD1yLmdldENvbXBvbmVudEluZGV4KCksdT1yLmdldFZlcnRleEluZGV4KCk7YTxuJiYobnVsbD09PWV8fGUuY29tcGFyZUxvY2F0aW9uVmFsdWVzKGgsdSxjKTwwKSYmKHM9aCxpPXUsbz1jLG49YSl9aWYobj09PXIuTUFYX1ZBTFVFKXJldHVybiBuZXcgdWwoZSk7cmV0dXJuIG5ldyB1bChzLGksbyl9aW5kZXhPZkFmdGVyKHQsZSl7aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuaW5kZXhPZih0KTtjb25zdCBuPXVsLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pO2lmKG4uY29tcGFyZVRvKGUpPD0wKXJldHVybiBuO2NvbnN0IHM9dGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsZSk7cmV0dXJuIGcuaXNUcnVlKHMuY29tcGFyZVRvKGUpPj0wLFwiY29tcHV0ZWQgbG9jYXRpb24gaXMgYmVmb3JlIHNwZWNpZmllZCBtaW5pbXVtIGxvY2F0aW9uXCIpLHN9fWNsYXNzIGRse2NvbnN0cnVjdG9yKCl7ZGwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgaW5kaWNlc09mKHQsZSl7cmV0dXJuIG5ldyBkbCh0KS5pbmRpY2VzT2YoZSl9aW5kaWNlc09mKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4oMCkuZ2V0Q29vcmRpbmF0ZU4oMCksbj10LmdldEdlb21ldHJ5Tih0LmdldE51bUdlb21ldHJpZXMoKS0xKSxzPW4uZ2V0Q29vcmRpbmF0ZU4obi5nZXROdW1Qb2ludHMoKS0xKSxpPW5ldyBnbCh0aGlzLl9saW5lYXJHZW9tKSxyPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiByWzBdPWkuaW5kZXhPZihlKSwwPT09dC5nZXRMZW5ndGgoKT9yWzFdPXJbMF0uY29weSgpOnJbMV09aS5pbmRleE9mQWZ0ZXIocyxyWzBdKSxyfX1jbGFzcyBfbHtjb25zdHJ1Y3Rvcigpe19sLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9c3RhdGljIGdldExlbmd0aCh0LGUpe3JldHVybiBuZXcgX2wodCkuZ2V0TGVuZ3RoKGUpfXN0YXRpYyBnZXRMb2NhdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IF9sKGFyZ3VtZW50c1swXSkuZ2V0TG9jYXRpb24odCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO3JldHVybiBuZXcgX2woYXJndW1lbnRzWzBdKS5nZXRMb2NhdGlvbih0LGUpfX1nZXRMZW5ndGgodCl7bGV0IGU9MDtjb25zdCBuPW5ldyBjbCh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO24uaGFzTmV4dCgpOyl7aWYoIW4uaXNFbmRPZkxpbmUoKSl7Y29uc3Qgcz1uLmdldFNlZ21lbnRTdGFydCgpLGk9bi5nZXRTZWdtZW50RW5kKCkuZGlzdGFuY2Uocyk7aWYodC5nZXRDb21wb25lbnRJbmRleCgpPT09bi5nZXRDb21wb25lbnRJbmRleCgpJiZ0LmdldFNlZ21lbnRJbmRleCgpPT09bi5nZXRWZXJ0ZXhJbmRleCgpKXJldHVybiBlK2kqdC5nZXRTZWdtZW50RnJhY3Rpb24oKTtlKz1pfW4ubmV4dCgpfXJldHVybiBlfXJlc29sdmVIaWdoZXIodCl7aWYoIXQuaXNFbmRwb2ludCh0aGlzLl9saW5lYXJHZW9tKSlyZXR1cm4gdDtsZXQgZT10LmdldENvbXBvbmVudEluZGV4KCk7aWYoZT49dGhpcy5fbGluZWFyR2VvbS5nZXROdW1HZW9tZXRyaWVzKCktMSlyZXR1cm4gdDtkb3tlKyt9d2hpbGUoZTx0aGlzLl9saW5lYXJHZW9tLmdldE51bUdlb21ldHJpZXMoKS0xJiYwPT09dGhpcy5fbGluZWFyR2VvbS5nZXRHZW9tZXRyeU4oZSkuZ2V0TGVuZ3RoKCkpO3JldHVybiBuZXcgdWwoZSwwLDApfWdldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdldExvY2F0aW9uKHQsITApfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj10O2lmKHQ8MCl7bj10aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpK3R9Y29uc3Qgcz10aGlzLmdldExvY2F0aW9uRm9yd2FyZChuKTtyZXR1cm4gZT9zOnRoaXMucmVzb2x2ZUhpZ2hlcihzKX19Z2V0TG9jYXRpb25Gb3J3YXJkKHQpe2lmKHQ8PTApcmV0dXJuIG5ldyB1bDtsZXQgZT0wO2NvbnN0IG49bmV3IGNsKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bi5oYXNOZXh0KCk7KXtpZihuLmlzRW5kT2ZMaW5lKCkpe2lmKGU9PT10KXtjb25zdCB0PW4uZ2V0Q29tcG9uZW50SW5kZXgoKSxlPW4uZ2V0VmVydGV4SW5kZXgoKTtyZXR1cm4gbmV3IHVsKHQsZSwwKX19ZWxzZXtjb25zdCBzPW4uZ2V0U2VnbWVudFN0YXJ0KCksaT1uLmdldFNlZ21lbnRFbmQoKS5kaXN0YW5jZShzKTtpZihlK2k+dCl7Y29uc3Qgcz0odC1lKS9pLHI9bi5nZXRDb21wb25lbnRJbmRleCgpLG89bi5nZXRWZXJ0ZXhJbmRleCgpO3JldHVybiBuZXcgdWwocixvLHMpfWUrPWl9bi5uZXh0KCl9cmV0dXJuIHVsLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pfX1jbGFzcyBwbHtjb25zdHJ1Y3Rvcigpe3BsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fbGluZXM9bmV3IEwsdGhpcy5fY29vcmRMaXN0PW51bGwsdGhpcy5faWdub3JlSW52YWxpZExpbmVzPSExLHRoaXMuX2ZpeEludmFsaWRMaW5lcz0hMSx0aGlzLl9sYXN0UHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdD10fWdldEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuZW5kTGluZSgpLHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpfWdldExhc3RDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2xhc3RQdH1lbmRMaW5lKCl7aWYobnVsbD09PXRoaXMuX2Nvb3JkTGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXMmJnRoaXMuX2Nvb3JkTGlzdC5zaXplKCk8MilyZXR1cm4gdGhpcy5fY29vcmRMaXN0PW51bGwsbnVsbDtjb25zdCB0PXRoaXMuX2Nvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBlPXQ7dGhpcy5fZml4SW52YWxpZExpbmVzJiYoZT10aGlzLnZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpKSx0aGlzLl9jb29yZExpc3Q9bnVsbDtsZXQgbj1udWxsO3RyeXtuPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgcykpdGhyb3cgdDtpZighdGhpcy5faWdub3JlSW52YWxpZExpbmVzKXRocm93IHR9bnVsbCE9PW4mJnRoaXMuX2xpbmVzLmFkZChuKX1zZXRGaXhJbnZhbGlkTGluZXModCl7dGhpcy5fZml4SW52YWxpZExpbmVzPXR9YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLl9jb29yZExpc3QmJih0aGlzLl9jb29yZExpc3Q9bmV3IFIpLHRoaXMuX2Nvb3JkTGlzdC5hZGQodCxlKSx0aGlzLl9sYXN0UHQ9dH19c2V0SWdub3JlSW52YWxpZExpbmVzKHQpe3RoaXMuX2lnbm9yZUludmFsaWRMaW5lcz10fXZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpe2lmKHQubGVuZ3RoPj0yKXJldHVybiB0O3JldHVyblt0WzBdLHRbMF1dfX1jbGFzcyBtbHtjb25zdHJ1Y3Rvcigpe21sLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9c3RhdGljIGV4dHJhY3QodCxlLG4pe3JldHVybiBuZXcgbWwodCkuZXh0cmFjdChlLG4pfWNvbXB1dGVMaW5lYXIodCxlKXtjb25zdCBuPW5ldyBwbCh0aGlzLl9saW5lLmdldEZhY3RvcnkoKSk7bi5zZXRGaXhJbnZhbGlkTGluZXMoITApLHQuaXNWZXJ0ZXgoKXx8bi5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtmb3IobGV0IHM9bmV3IGNsKHRoaXMuX2xpbmUsdCk7cy5oYXNOZXh0KCkmJiEoZS5jb21wYXJlTG9jYXRpb25WYWx1ZXMocy5nZXRDb21wb25lbnRJbmRleCgpLHMuZ2V0VmVydGV4SW5kZXgoKSwwKTwwKTtzLm5leHQoKSl7Y29uc3QgdD1zLmdldFNlZ21lbnRTdGFydCgpO24uYWRkKHQpLHMuaXNFbmRPZkxpbmUoKSYmbi5lbmRMaW5lKCl9cmV0dXJuIGUuaXNWZXJ0ZXgoKXx8bi5hZGQoZS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKSxuLmdldEdlb21ldHJ5KCl9Y29tcHV0ZUxpbmUodCxlKXtjb25zdCBuPXRoaXMuX2xpbmUuZ2V0Q29vcmRpbmF0ZXMoKSxzPW5ldyBSO2xldCBpPXQuZ2V0U2VnbWVudEluZGV4KCk7dC5nZXRTZWdtZW50RnJhY3Rpb24oKT4wJiYoaSs9MSk7bGV0IHI9ZS5nZXRTZWdtZW50SW5kZXgoKTsxPT09ZS5nZXRTZWdtZW50RnJhY3Rpb24oKSYmKHIrPTEpLHI+PW4ubGVuZ3RoJiYocj1uLmxlbmd0aC0xKSx0LmlzVmVydGV4KCl8fHMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7Zm9yKGxldCB0PWk7dDw9cjt0Kyspcy5hZGQoblt0XSk7ZS5pc1ZlcnRleCgpfHxzLmFkZChlLmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpLHMuc2l6ZSgpPD0wJiZzLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2xldCBvPXMudG9Db29yZGluYXRlQXJyYXkoKTtyZXR1cm4gby5sZW5ndGg8PTEmJihvPVtvWzBdLG9bMF1dKSx0aGlzLl9saW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKG8pfWV4dHJhY3QodCxlKXtyZXR1cm4gZS5jb21wYXJlVG8odCk8MD90aGlzLnJldmVyc2UodGhpcy5jb21wdXRlTGluZWFyKGUsdCkpOnRoaXMuY29tcHV0ZUxpbmVhcih0LGUpfXJldmVyc2UodCl7cmV0dXJuIEkodCxaKT90LnJldmVyc2UoKTooZy5zaG91bGROZXZlclJlYWNoSGVyZShcIm5vbi1saW5lYXIgZ2VvbWV0cnkgZW5jb3VudGVyZWRcIiksbnVsbCl9fWNsYXNzIGZse2NvbnN0cnVjdG9yKCl7ZmwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dGhpcy5wb3NpdGl2ZUluZGV4KHQpLG49dGhpcy5nZXRTdGFydEluZGV4KCk7aWYoZTxuKXJldHVybiBuO2NvbnN0IHM9dGhpcy5nZXRFbmRJbmRleCgpO3JldHVybiBlPnM/czplfWxvY2F0aW9uT2YoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIF9sLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBfbC5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQsZSl9fXByb2plY3QodCl7cmV0dXJuIGhsLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1wb3NpdGl2ZUluZGV4KHQpe3JldHVybiB0Pj0wP3Q6dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKSt0fWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gX2wuZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmVhckdlb20pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPV9sLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCkudG9Mb3dlc3QodGhpcy5fbGluZWFyR2VvbSk7cmV0dXJuIG4uZ2V0U2VnbWVudCh0aGlzLl9saW5lYXJHZW9tKS5wb2ludEFsb25nT2Zmc2V0KG4uZ2V0U2VnbWVudEZyYWN0aW9uKCksZSl9fWlzVmFsaWRJbmRleCh0KXtyZXR1cm4gdD49dGhpcy5nZXRTdGFydEluZGV4KCkmJnQ8PXRoaXMuZ2V0RW5kSW5kZXgoKX1nZXRFbmRJbmRleCgpe3JldHVybiB0aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gMH1pbmRleE9mQWZ0ZXIodCxlKXtyZXR1cm4gaGwuaW5kZXhPZkFmdGVyKHRoaXMuX2xpbmVhckdlb20sdCxlKX1leHRyYWN0TGluZSh0LGUpe2NvbnN0IG49dGhpcy5jbGFtcEluZGV4KHQpLHM9dGhpcy5jbGFtcEluZGV4KGUpLGk9bj09PXMscj10aGlzLmxvY2F0aW9uT2YobixpKSxvPXRoaXMubG9jYXRpb25PZihzKTtyZXR1cm4gbWwuZXh0cmFjdCh0aGlzLl9saW5lYXJHZW9tLHIsbyl9aW5kZXhPZih0KXtyZXR1cm4gaGwuaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWluZGljZXNPZih0KXtjb25zdCBlPWRsLmluZGljZXNPZih0aGlzLl9saW5lYXJHZW9tLHQpO3JldHVybltfbC5nZXRMZW5ndGgodGhpcy5fbGluZWFyR2VvbSxlWzBdKSxfbC5nZXRMZW5ndGgodGhpcy5fbGluZWFyR2VvbSxlWzFdKV19fWNsYXNzIHlse2NvbnN0cnVjdG9yKCl7eWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dCx0aGlzLmNoZWNrR2VvbWV0cnlUeXBlKCl9Y2xhbXBJbmRleCh0KXtjb25zdCBlPXQuY29weSgpO3JldHVybiBlLmNsYW1wKHRoaXMuX2xpbmVhckdlb20pLGV9cHJvamVjdCh0KXtyZXR1cm4gZ2wuaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWNoZWNrR2VvbWV0cnlUeXBlKCl7aWYoISh0aGlzLl9saW5lYXJHZW9tIGluc3RhbmNlb2YgJHx8dGhpcy5fbGluZWFyR2VvbSBpbnN0YW5jZW9mIFN0KSl0aHJvdyBuZXcgcyhcIklucHV0IGdlb21ldHJ5IG11c3QgYmUgbGluZWFyXCIpfWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gYXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGUodGhpcy5fbGluZWFyR2VvbSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLnRvTG93ZXN0KHRoaXMuX2xpbmVhckdlb20pO3JldHVybiBlLmdldFNlZ21lbnQodGhpcy5fbGluZWFyR2VvbSkucG9pbnRBbG9uZ09mZnNldChlLmdldFNlZ21lbnRGcmFjdGlvbigpLHQpfX1pc1ZhbGlkSW5kZXgodCl7cmV0dXJuIHQuaXNWYWxpZCh0aGlzLl9saW5lYXJHZW9tKX1nZXRFbmRJbmRleCgpe3JldHVybiB1bC5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKX1nZXRTdGFydEluZGV4KCl7cmV0dXJuIG5ldyB1bH1pbmRleE9mQWZ0ZXIodCxlKXtyZXR1cm4gZ2wuaW5kZXhPZkFmdGVyKHRoaXMuX2xpbmVhckdlb20sdCxlKX1leHRyYWN0TGluZSh0LGUpe3JldHVybiBtbC5leHRyYWN0KHRoaXMuX2xpbmVhckdlb20sdCxlKX1pbmRleE9mKHQpe3JldHVybiBnbC5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9aW5kaWNlc09mKHQpe3JldHVybiBkbC5pbmRpY2VzT2YodGhpcy5fbGluZWFyR2VvbSx0KX19dmFyIHhsPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExlbmd0aEluZGV4ZWRMaW5lOmZsLExlbmd0aExvY2F0aW9uTWFwOl9sLExpbmVhckdlb21ldHJ5QnVpbGRlcjpwbCxMaW5lYXJJdGVyYXRvcjpjbCxMaW5lYXJMb2NhdGlvbjp1bCxMb2NhdGlvbkluZGV4ZWRMaW5lOnlsfSk7Y2xhc3MgRWx7c3RhdGljIHRyYW5zZm9ybSh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspbi5hZGQoZS5leGVjdXRlKHMubmV4dCgpKSk7cmV0dXJuIG59c3RhdGljIHNlbGVjdCh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7Qm9vbGVhbi5UUlVFLmVxdWFscyhlLmV4ZWN1dGUodCkpJiZuLmFkZCh0KX1yZXR1cm4gbn1zdGF0aWMgYXBwbHkodCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmV4ZWN1dGUobi5uZXh0KCkpfX1FbC5GdW5jdGlvbj1mdW5jdGlvbigpe307Y2xhc3MgSWx7Y29uc3RydWN0b3IoKXtJbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnB0cz1udWxsLHRoaXMubj0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpfWZpbHRlcih0KXt0aGlzLnB0c1t0aGlzLm4rK109dH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSF19fWNsYXNzIE5se2NvbnN0cnVjdG9yKCl7TmwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbj0wfWZpbHRlcih0KXt0aGlzLl9uKyt9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSF19fWNsYXNzIHdse2NvbnN0cnVjdG9yKCl7d2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY291bnRzPW5ldyBOdH1jb3VudCh0KXtjb25zdCBlPXRoaXMuX2NvdW50cy5nZXQodCk7cmV0dXJuIG51bGw9PT1lPzA6ZS5jb3VudCgpfWFkZCh0KXtjb25zdCBlPXRoaXMuX2NvdW50cy5nZXQodCk7bnVsbD09PWU/dGhpcy5fY291bnRzLnB1dCh0LG5ldyBDbCgxKSk6ZS5pbmNyZW1lbnQoKX19Y2xhc3MgQ2x7Y29uc3RydWN0b3IoKXtDbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLmNvdW50PTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY291bnQ9dH19Y291bnQoKXtyZXR1cm4gdGhpcy5jb3VudH1pbmNyZW1lbnQoKXt0aGlzLmNvdW50Kyt9fWZ1bmN0aW9uIFNsKCl7fWZ1bmN0aW9uIExsKCl7fWZ1bmN0aW9uIFRsKCl7fXdsLkNvdW50ZXI9Q2w7Y2xhc3MgUmwgZXh0ZW5kcyBue31mdW5jdGlvbiBQbCgpe31jbGFzcyBPbHtzdGF0aWMgY2hhcnModCxlKXtjb25zdCBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2ZvcihsZXQgcz0wO3M8ZTtzKyspbltzXT10O3JldHVybiBuZXcgU3RyaW5nKG4pfXN0YXRpYyBnZXRTdGFja1RyYWNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IFRsLG49bmV3IFNsO3JldHVybiB0LnByaW50U3RhY2tUcmFjZShuKSxlLnRvU3RyaW5nKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPVwiXCI7bmV3IExsKE9sLmdldFN0YWNrVHJhY2UodCkpO2NvbnN0IHM9bmV3IFBsO2ZvcihsZXQgdD0wO3Q8ZTt0KyspdHJ5e24rPXMucmVhZExpbmUoKStPbC5ORVdMSU5FfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFJsKSl0aHJvdyB0O2cuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbn19c3RhdGljIHNwYWNlcyh0KXtyZXR1cm4gT2wuY2hhcnMoXCIgXCIsdCl9c3RhdGljIHNwbGl0KHQsZSl7Y29uc3Qgbj1lLmxlbmd0aCxzPW5ldyBMO2xldCBpPVwiXCIrdCxyPWkuaW5kZXhPZihlKTtmb3IoO3I+PTA7KXtjb25zdCB0PWkuc3Vic3RyaW5nKDAscik7cy5hZGQodCksaT1pLnN1YnN0cmluZyhyK24pLHI9aS5pbmRleE9mKGUpfWkubGVuZ3RoPjAmJnMuYWRkKGkpO2NvbnN0IG89bmV3IEFycmF5KHMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKW9bdF09cy5nZXQodCk7cmV0dXJuIG99fU9sLk5FV0xJTkU9WS5nZXRQcm9wZXJ0eShcImxpbmUuc2VwYXJhdG9yXCIpO3ZhciB2bD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb2xsZWN0aW9uVXRpbDpFbCxDb29yZGluYXRlQXJyYXlGaWx0ZXI6SWwsQ29vcmRpbmF0ZUNvdW50RmlsdGVyOk5sLEdlb21ldHJpY1NoYXBlRmFjdG9yeTp3ZSxOdW1iZXJVdGlsOmUsT2JqZWN0Q291bnRlcjp3bCxQcmlvcml0eVF1ZXVlOkxzLFN0cmluZ1V0aWw6T2wsVW5pcXVlQ29vcmRpbmF0ZUFycmF5RmlsdGVyOm5ufSk7JC5wcm90b3R5cGUuZ2V0Qm91bmRhcnk9ZnVuY3Rpb24oKXtyZXR1cm4gaWkuZ2V0Qm91bmRhcnkodGhpcyl9LFN0LnByb3RvdHlwZS5nZXRCb3VuZGFyeT1mdW5jdGlvbigpe3JldHVybiBpaS5nZXRCb3VuZGFyeSh0aGlzKX0sVS5wcm90b3R5cGUuZXF1YWxzVG9wbz1mdW5jdGlvbih0KXtyZXR1cm4gUXIuZXF1YWxzVG9wbyh0aGlzLHQpfSxVLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiZRci5lcXVhbHNUb3BvKHRoaXMsdCl9LFUucHJvdG90eXBlLnVuaW9uPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGlvLnVuaW9uKHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gZW8udW5pb24odGhpcyx0KX19LFUucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gR3IuaXNWYWxpZCh0aGlzKX0sVS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB3ci5pbnRlcnNlY3Rpb24odGhpcyx0KX0sVS5wcm90b3R5cGUuY292ZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBRci5jb3ZlcnModGhpcyx0KX0sVS5wcm90b3R5cGUuY292ZXJlZEJ5PWZ1bmN0aW9uKHQpe3JldHVybiBRci5jb3ZlcnModCx0aGlzKX0sVS5wcm90b3R5cGUudG91Y2hlcz1mdW5jdGlvbih0KXtyZXR1cm4gUXIudG91Y2hlcyh0aGlzLHQpfSxVLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKHQpe3JldHVybiBRci5pbnRlcnNlY3RzKHRoaXMsdCl9LFUucHJvdG90eXBlLndpdGhpbj1mdW5jdGlvbih0KXtyZXR1cm4gUXIuY29udGFpbnModCx0aGlzKX0sVS5wcm90b3R5cGUub3ZlcmxhcHM9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLm92ZXJsYXBzKHRoaXMsdCl9LFUucHJvdG90eXBlLmRpc2pvaW50PWZ1bmN0aW9uKHQpe3JldHVybiBRci5kaXNqb2ludCh0aGlzLHQpfSxVLnByb3RvdHlwZS5jcm9zc2VzPWZ1bmN0aW9uKHQpe3JldHVybiBRci5jcm9zc2VzKHRoaXMsdCl9LFUucHJvdG90eXBlLmJ1ZmZlcj1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gcWkuYnVmZmVyT3AodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHFpLmJ1ZmZlck9wKHRoaXMsdCxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHFpLmJ1ZmZlck9wKHRoaXMsdCxlLG4pfX0sVS5wcm90b3R5cGUuY29udmV4SHVsbD1mdW5jdGlvbigpe3JldHVybiBuZXcgc24odGhpcykuZ2V0Q29udmV4SHVsbCgpfSxVLnByb3RvdHlwZS5yZWxhdGU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFFyLnJlbGF0ZSh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gUXIucmVsYXRlKHRoaXMsdCkubWF0Y2hlcyhlKX19LFUucHJvdG90eXBlLmdldENlbnRyb2lkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQoKTtjb25zdCB0PSRlLmdldENlbnRyb2lkKHRoaXMpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCx0aGlzKX0sVS5wcm90b3R5cGUuZ2V0SW50ZXJpb3JQb2ludD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KCk7bGV0IHQ9bnVsbDtjb25zdCBlPXRoaXMuZ2V0RGltZW5zaW9uKCk7dD0wPT09ZT9uZXcgdW4odGhpcyk6MT09PWU/bmV3IGhuKHRoaXMpOm5ldyBvbih0aGlzKTtjb25zdCBuPXQuZ2V0SW50ZXJpb3JQb2ludCgpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQobix0aGlzKX0sVS5wcm90b3R5cGUuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gd3Iuc3ltRGlmZmVyZW5jZSh0aGlzLHQpfSxVLnByb3RvdHlwZS5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX0sVS5wcm90b3R5cGUudG9UZXh0PWZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBXdCkud3JpdGUodGhpcyl9LFUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9UZXh0KCl9LFUucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe3JldHVybiBRci5jb250YWlucyh0aGlzLHQpfSxVLnByb3RvdHlwZS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiB3ci5kaWZmZXJlbmNlKHRoaXMsdCl9LFUucHJvdG90eXBlLmlzU2ltcGxlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBvaSh0aGlzKS5pc1NpbXBsZSgpfSxVLnByb3RvdHlwZS5pc1dpdGhpbkRpc3RhbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk+ZSkmJnppLmlzV2l0aGluRGlzdGFuY2UodGhpcyx0LGUpfSxVLnByb3RvdHlwZS5kaXN0YW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gemkuZGlzdGFuY2UodGhpcyx0KX07dC5hbGdvcml0aG09RW4sdC5kZW5zaWZ5PXduLHQuZGlzc29sdmU9dm4sdC5nZW9tPVRlLHQuZ2VvbWdyYXBoPWNzLHQuaW5kZXg9QXMsdC5pbz1Wcyx0LmxpbmVhcnJlZj14bCx0Lm5vZGluZz1zaSx0Lm9wZXJhdGlvbj1sbyx0LnByZWNpc2lvbj14byx0LnNpbXBsaWZ5PUZvLHQudHJpYW5ndWxhdGU9YWwsdC51dGlsPXZsLHQudmVyc2lvbj1cIjIuOS4zXCJ9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc3RzLm1pbi5qcy5tYXBcbiIsIiFmdW5jdGlvbih0LGkpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWkoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGkpOih0PXR8fHNlbGYpLlJCdXNoPWkoKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCxyLGUsYSxoKXshZnVuY3Rpb24gdChuLHIsZSxhLGgpe2Zvcig7YT5lOyl7aWYoYS1lPjYwMCl7dmFyIG89YS1lKzEscz1yLWUrMSxsPU1hdGgubG9nKG8pLGY9LjUqTWF0aC5leHAoMipsLzMpLHU9LjUqTWF0aC5zcXJ0KGwqZiooby1mKS9vKSoocy1vLzI8MD8tMToxKSxtPU1hdGgubWF4KGUsTWF0aC5mbG9vcihyLXMqZi9vK3UpKSxjPU1hdGgubWluKGEsTWF0aC5mbG9vcihyKyhvLXMpKmYvbyt1KSk7dChuLHIsbSxjLGgpfXZhciBwPW5bcl0sZD1lLHg9YTtmb3IoaShuLGUsciksaChuW2FdLHApPjAmJmkobixlLGEpO2Q8eDspe2ZvcihpKG4sZCx4KSxkKysseC0tO2gobltkXSxwKTwwOylkKys7Zm9yKDtoKG5beF0scCk+MDspeC0tfTA9PT1oKG5bZV0scCk/aShuLGUseCk6aShuLCsreCxhKSx4PD1yJiYoZT14KzEpLHI8PXgmJihhPXgtMSl9fSh0LHIsZXx8MCxhfHx0Lmxlbmd0aC0xLGh8fG4pfWZ1bmN0aW9uIGkodCxpLG4pe3ZhciByPXRbaV07dFtpXT10W25dLHRbbl09cn1mdW5jdGlvbiBuKHQsaSl7cmV0dXJuIHQ8aT8tMTp0Pmk/MTowfXZhciByPWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PTkpLHRoaXMuX21heEVudHJpZXM9TWF0aC5tYXgoNCx0KSx0aGlzLl9taW5FbnRyaWVzPU1hdGgubWF4KDIsTWF0aC5jZWlsKC40KnRoaXMuX21heEVudHJpZXMpKSx0aGlzLmNsZWFyKCl9O2Z1bmN0aW9uIGUodCxpLG4pe2lmKCFuKXJldHVybiBpLmluZGV4T2YodCk7Zm9yKHZhciByPTA7cjxpLmxlbmd0aDtyKyspaWYobih0LGlbcl0pKXJldHVybiByO3JldHVybi0xfWZ1bmN0aW9uIGEodCxpKXtoKHQsMCx0LmNoaWxkcmVuLmxlbmd0aCxpLHQpfWZ1bmN0aW9uIGgodCxpLG4scixlKXtlfHwoZT1wKG51bGwpKSxlLm1pblg9MS8wLGUubWluWT0xLzAsZS5tYXhYPS0xLzAsZS5tYXhZPS0xLzA7Zm9yKHZhciBhPWk7YTxuO2ErKyl7dmFyIGg9dC5jaGlsZHJlblthXTtvKGUsdC5sZWFmP3IoaCk6aCl9cmV0dXJuIGV9ZnVuY3Rpb24gbyh0LGkpe3JldHVybiB0Lm1pblg9TWF0aC5taW4odC5taW5YLGkubWluWCksdC5taW5ZPU1hdGgubWluKHQubWluWSxpLm1pblkpLHQubWF4WD1NYXRoLm1heCh0Lm1heFgsaS5tYXhYKSx0Lm1heFk9TWF0aC5tYXgodC5tYXhZLGkubWF4WSksdH1mdW5jdGlvbiBzKHQsaSl7cmV0dXJuIHQubWluWC1pLm1pblh9ZnVuY3Rpb24gbCh0LGkpe3JldHVybiB0Lm1pblktaS5taW5ZfWZ1bmN0aW9uIGYodCl7cmV0dXJuKHQubWF4WC10Lm1pblgpKih0Lm1heFktdC5taW5ZKX1mdW5jdGlvbiB1KHQpe3JldHVybiB0Lm1heFgtdC5taW5YKyh0Lm1heFktdC5taW5ZKX1mdW5jdGlvbiBtKHQsaSl7cmV0dXJuIHQubWluWDw9aS5taW5YJiZ0Lm1pblk8PWkubWluWSYmaS5tYXhYPD10Lm1heFgmJmkubWF4WTw9dC5tYXhZfWZ1bmN0aW9uIGModCxpKXtyZXR1cm4gaS5taW5YPD10Lm1heFgmJmkubWluWTw9dC5tYXhZJiZpLm1heFg+PXQubWluWCYmaS5tYXhZPj10Lm1pbll9ZnVuY3Rpb24gcCh0KXtyZXR1cm57Y2hpbGRyZW46dCxoZWlnaHQ6MSxsZWFmOiEwLG1pblg6MS8wLG1pblk6MS8wLG1heFg6LTEvMCxtYXhZOi0xLzB9fWZ1bmN0aW9uIGQoaSxuLHIsZSxhKXtmb3IodmFyIGg9W24scl07aC5sZW5ndGg7KWlmKCEoKHI9aC5wb3AoKSktKG49aC5wb3AoKSk8PWUpKXt2YXIgbz1uK01hdGguY2VpbCgoci1uKS9lLzIpKmU7dChpLG8sbixyLGEpLGgucHVzaChuLG8sbyxyKX19cmV0dXJuIHIucHJvdG90eXBlLmFsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLFtdKX0sci5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZGF0YSxuPVtdO2lmKCFjKHQsaSkpcmV0dXJuIG47Zm9yKHZhciByPXRoaXMudG9CQm94LGU9W107aTspe2Zvcih2YXIgYT0wO2E8aS5jaGlsZHJlbi5sZW5ndGg7YSsrKXt2YXIgaD1pLmNoaWxkcmVuW2FdLG89aS5sZWFmP3IoaCk6aDtjKHQsbykmJihpLmxlYWY/bi5wdXNoKGgpOm0odCxvKT90aGlzLl9hbGwoaCxuKTplLnB1c2goaCkpfWk9ZS5wb3AoKX1yZXR1cm4gbn0sci5wcm90b3R5cGUuY29sbGlkZXM9ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5kYXRhO2lmKCFjKHQsaSkpcmV0dXJuITE7Zm9yKHZhciBuPVtdO2k7KXtmb3IodmFyIHI9MDtyPGkuY2hpbGRyZW4ubGVuZ3RoO3IrKyl7dmFyIGU9aS5jaGlsZHJlbltyXSxhPWkubGVhZj90aGlzLnRvQkJveChlKTplO2lmKGModCxhKSl7aWYoaS5sZWFmfHxtKHQsYSkpcmV0dXJuITA7bi5wdXNoKGUpfX1pPW4ucG9wKCl9cmV0dXJuITF9LHIucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24odCl7aWYoIXR8fCF0Lmxlbmd0aClyZXR1cm4gdGhpcztpZih0Lmxlbmd0aDx0aGlzLl9taW5FbnRyaWVzKXtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyl0aGlzLmluc2VydCh0W2ldKTtyZXR1cm4gdGhpc312YXIgbj10aGlzLl9idWlsZCh0LnNsaWNlKCksMCx0Lmxlbmd0aC0xLDApO2lmKHRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpaWYodGhpcy5kYXRhLmhlaWdodD09PW4uaGVpZ2h0KXRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsbik7ZWxzZXtpZih0aGlzLmRhdGEuaGVpZ2h0PG4uaGVpZ2h0KXt2YXIgcj10aGlzLmRhdGE7dGhpcy5kYXRhPW4sbj1yfXRoaXMuX2luc2VydChuLHRoaXMuZGF0YS5oZWlnaHQtbi5oZWlnaHQtMSwhMCl9ZWxzZSB0aGlzLmRhdGE9bjtyZXR1cm4gdGhpc30sci5wcm90b3R5cGUuaW5zZXJ0PWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLl9pbnNlcnQodCx0aGlzLmRhdGEuaGVpZ2h0LTEpLHRoaXN9LHIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YT1wKFtdKSx0aGlzfSxyLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCxpKXtpZighdClyZXR1cm4gdGhpcztmb3IodmFyIG4scixhLGg9dGhpcy5kYXRhLG89dGhpcy50b0JCb3godCkscz1bXSxsPVtdO2h8fHMubGVuZ3RoOyl7aWYoaHx8KGg9cy5wb3AoKSxyPXNbcy5sZW5ndGgtMV0sbj1sLnBvcCgpLGE9ITApLGgubGVhZil7dmFyIGY9ZSh0LGguY2hpbGRyZW4saSk7aWYoLTEhPT1mKXJldHVybiBoLmNoaWxkcmVuLnNwbGljZShmLDEpLHMucHVzaChoKSx0aGlzLl9jb25kZW5zZShzKSx0aGlzfWF8fGgubGVhZnx8IW0oaCxvKT9yPyhuKyssaD1yLmNoaWxkcmVuW25dLGE9ITEpOmg9bnVsbDoocy5wdXNoKGgpLGwucHVzaChuKSxuPTAscj1oLGg9aC5jaGlsZHJlblswXSl9cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLnRvQkJveD1mdW5jdGlvbih0KXtyZXR1cm4gdH0sci5wcm90b3R5cGUuY29tcGFyZU1pblg9ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC5taW5YLWkubWluWH0sci5wcm90b3R5cGUuY29tcGFyZU1pblk9ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC5taW5ZLWkubWluWX0sci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sci5wcm90b3R5cGUuZnJvbUpTT049ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YT10LHRoaXN9LHIucHJvdG90eXBlLl9hbGw9ZnVuY3Rpb24odCxpKXtmb3IodmFyIG49W107dDspdC5sZWFmP2kucHVzaC5hcHBseShpLHQuY2hpbGRyZW4pOm4ucHVzaC5hcHBseShuLHQuY2hpbGRyZW4pLHQ9bi5wb3AoKTtyZXR1cm4gaX0sci5wcm90b3R5cGUuX2J1aWxkPWZ1bmN0aW9uKHQsaSxuLHIpe3ZhciBlLGg9bi1pKzEsbz10aGlzLl9tYXhFbnRyaWVzO2lmKGg8PW8pcmV0dXJuIGEoZT1wKHQuc2xpY2UoaSxuKzEpKSx0aGlzLnRvQkJveCksZTtyfHwocj1NYXRoLmNlaWwoTWF0aC5sb2coaCkvTWF0aC5sb2cobykpLG89TWF0aC5jZWlsKGgvTWF0aC5wb3cobyxyLTEpKSksKGU9cChbXSkpLmxlYWY9ITEsZS5oZWlnaHQ9cjt2YXIgcz1NYXRoLmNlaWwoaC9vKSxsPXMqTWF0aC5jZWlsKE1hdGguc3FydChvKSk7ZCh0LGksbixsLHRoaXMuY29tcGFyZU1pblgpO2Zvcih2YXIgZj1pO2Y8PW47Zis9bCl7dmFyIHU9TWF0aC5taW4oZitsLTEsbik7ZCh0LGYsdSxzLHRoaXMuY29tcGFyZU1pblkpO2Zvcih2YXIgbT1mO208PXU7bSs9cyl7dmFyIGM9TWF0aC5taW4obStzLTEsdSk7ZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKHQsbSxjLHItMSkpfX1yZXR1cm4gYShlLHRoaXMudG9CQm94KSxlfSxyLnByb3RvdHlwZS5fY2hvb3NlU3VidHJlZT1mdW5jdGlvbih0LGksbixyKXtmb3IoO3IucHVzaChpKSwhaS5sZWFmJiZyLmxlbmd0aC0xIT09bjspe2Zvcih2YXIgZT0xLzAsYT0xLzAsaD12b2lkIDAsbz0wO288aS5jaGlsZHJlbi5sZW5ndGg7bysrKXt2YXIgcz1pLmNoaWxkcmVuW29dLGw9ZihzKSx1PShtPXQsYz1zLChNYXRoLm1heChjLm1heFgsbS5tYXhYKS1NYXRoLm1pbihjLm1pblgsbS5taW5YKSkqKE1hdGgubWF4KGMubWF4WSxtLm1heFkpLU1hdGgubWluKGMubWluWSxtLm1pblkpKS1sKTt1PGE/KGE9dSxlPWw8ZT9sOmUsaD1zKTp1PT09YSYmbDxlJiYoZT1sLGg9cyl9aT1ofHxpLmNoaWxkcmVuWzBdfXZhciBtLGM7cmV0dXJuIGl9LHIucHJvdG90eXBlLl9pbnNlcnQ9ZnVuY3Rpb24odCxpLG4pe3ZhciByPW4/dDp0aGlzLnRvQkJveCh0KSxlPVtdLGE9dGhpcy5fY2hvb3NlU3VidHJlZShyLHRoaXMuZGF0YSxpLGUpO2ZvcihhLmNoaWxkcmVuLnB1c2godCksbyhhLHIpO2k+PTAmJmVbaV0uY2hpbGRyZW4ubGVuZ3RoPnRoaXMuX21heEVudHJpZXM7KXRoaXMuX3NwbGl0KGUsaSksaS0tO3RoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhyLGUsaSl9LHIucHJvdG90eXBlLl9zcGxpdD1mdW5jdGlvbih0LGkpe3ZhciBuPXRbaV0scj1uLmNoaWxkcmVuLmxlbmd0aCxlPXRoaXMuX21pbkVudHJpZXM7dGhpcy5fY2hvb3NlU3BsaXRBeGlzKG4sZSxyKTt2YXIgaD10aGlzLl9jaG9vc2VTcGxpdEluZGV4KG4sZSxyKSxvPXAobi5jaGlsZHJlbi5zcGxpY2UoaCxuLmNoaWxkcmVuLmxlbmd0aC1oKSk7by5oZWlnaHQ9bi5oZWlnaHQsby5sZWFmPW4ubGVhZixhKG4sdGhpcy50b0JCb3gpLGEobyx0aGlzLnRvQkJveCksaT90W2ktMV0uY2hpbGRyZW4ucHVzaChvKTp0aGlzLl9zcGxpdFJvb3QobixvKX0sci5wcm90b3R5cGUuX3NwbGl0Um9vdD1mdW5jdGlvbih0LGkpe3RoaXMuZGF0YT1wKFt0LGldKSx0aGlzLmRhdGEuaGVpZ2h0PXQuaGVpZ2h0KzEsdGhpcy5kYXRhLmxlYWY9ITEsYSh0aGlzLmRhdGEsdGhpcy50b0JCb3gpfSxyLnByb3RvdHlwZS5fY2hvb3NlU3BsaXRJbmRleD1mdW5jdGlvbih0LGksbil7Zm9yKHZhciByLGUsYSxvLHMsbCx1LG09MS8wLGM9MS8wLHA9aTtwPD1uLWk7cCsrKXt2YXIgZD1oKHQsMCxwLHRoaXMudG9CQm94KSx4PWgodCxwLG4sdGhpcy50b0JCb3gpLHY9KGU9ZCxhPXgsbz12b2lkIDAscz12b2lkIDAsbD12b2lkIDAsdT12b2lkIDAsbz1NYXRoLm1heChlLm1pblgsYS5taW5YKSxzPU1hdGgubWF4KGUubWluWSxhLm1pblkpLGw9TWF0aC5taW4oZS5tYXhYLGEubWF4WCksdT1NYXRoLm1pbihlLm1heFksYS5tYXhZKSxNYXRoLm1heCgwLGwtbykqTWF0aC5tYXgoMCx1LXMpKSxNPWYoZCkrZih4KTt2PG0/KG09dixyPXAsYz1NPGM/TTpjKTp2PT09bSYmTTxjJiYoYz1NLHI9cCl9cmV0dXJuIHJ8fG4taX0sci5wcm90b3R5cGUuX2Nob29zZVNwbGl0QXhpcz1mdW5jdGlvbih0LGksbil7dmFyIHI9dC5sZWFmP3RoaXMuY29tcGFyZU1pblg6cyxlPXQubGVhZj90aGlzLmNvbXBhcmVNaW5ZOmw7dGhpcy5fYWxsRGlzdE1hcmdpbih0LGksbixyKTx0aGlzLl9hbGxEaXN0TWFyZ2luKHQsaSxuLGUpJiZ0LmNoaWxkcmVuLnNvcnQocil9LHIucHJvdG90eXBlLl9hbGxEaXN0TWFyZ2luPWZ1bmN0aW9uKHQsaSxuLHIpe3QuY2hpbGRyZW4uc29ydChyKTtmb3IodmFyIGU9dGhpcy50b0JCb3gsYT1oKHQsMCxpLGUpLHM9aCh0LG4taSxuLGUpLGw9dShhKSt1KHMpLGY9aTtmPG4taTtmKyspe3ZhciBtPXQuY2hpbGRyZW5bZl07byhhLHQubGVhZj9lKG0pOm0pLGwrPXUoYSl9Zm9yKHZhciBjPW4taS0xO2M+PWk7Yy0tKXt2YXIgcD10LmNoaWxkcmVuW2NdO28ocyx0LmxlYWY/ZShwKTpwKSxsKz11KHMpfXJldHVybiBsfSxyLnByb3RvdHlwZS5fYWRqdXN0UGFyZW50QkJveGVzPWZ1bmN0aW9uKHQsaSxuKXtmb3IodmFyIHI9bjtyPj0wO3ItLSlvKGlbcl0sdCl9LHIucHJvdG90eXBlLl9jb25kZW5zZT1mdW5jdGlvbih0KXtmb3IodmFyIGk9dC5sZW5ndGgtMSxuPXZvaWQgMDtpPj0wO2ktLSkwPT09dFtpXS5jaGlsZHJlbi5sZW5ndGg/aT4wPyhuPXRbaS0xXS5jaGlsZHJlbikuc3BsaWNlKG4uaW5kZXhPZih0W2ldKSwxKTp0aGlzLmNsZWFyKCk6YSh0W2ldLHRoaXMudG9CQm94KX0scn0pO1xuIiwiLy9AdHMtY2hlY2tcblxuLyoqICovXG5leHBvcnQgY2xhc3MgQWdlbnRQb2ludCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN5IFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHN4PTAsIHN5PTApIHtcblxuICAgICAgICAvL3Bvc2l0aW9uXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHlcblxuICAgICAgICAvL3NwZWVkXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc3ggPSBzeFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zeSA9IHN5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnMgPSB1bmRlZmluZWRcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2EgPSB1bmRlZmluZWRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWdlbnRQb2ludH0gYVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSB0byBhbm90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGQoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kUChhLngsIGEueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGRpc3RhbmNlIHRvIGEgcG9zaXRpb24uXG4gICAgICovXG4gICAgZFAoeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5oeXBvdCgoeCAtIHRoaXMueCksICh5IC0gdGhpcy55KSk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICogU2V0IHJhbmRvbSBzcGVlZFxuICAgICogXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZFxuICAgICovXG4gICAgc2V0UmFuZG9tU3BlZWQobWluU3BlZWQgPSAwLCBtYXhTcGVlZCA9IDAuMSkge1xuICAgICAgICB0aGlzLnMgPSBtaW5TcGVlZCArIE1hdGgucmFuZG9tKCkgKiAobWF4U3BlZWQgLSBtaW5TcGVlZCk7XG4gICAgICAgIHRoaXMuc2EgPSAyICogTWF0aC5yYW5kb20oKSAqIE1hdGguUEk7XG4gICAgICAgIHRoaXMuc3ggPSB0aGlzLnMgKiBNYXRoLmNvcyh0aGlzLnNhKVxuICAgICAgICB0aGlzLnN5ID0gdGhpcy5zICogTWF0aC5zaW4odGhpcy5zYSlcbiAgICB9XG5cbiAgICAvKiogKi9cbiAgICBjb21wdXRlU3BlZWQoKSB7XG4gICAgICAgIHRoaXMucyA9IE1hdGguaHlwb3QodGhpcy5zeCwgdGhpcy5zeSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNcbiAgICB9XG5cbiAgICAvKiogKi9cbiAgICBjb21wdXRlU3BlZWRBbmdsZSgpIHtcbiAgICAgICAgdGhpcy5zYSA9IE1hdGguYXRhbjIodGhpcy5zeSwgdGhpcy5zeCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNhXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuLyoqIEB0eXBlZGVmIHsge3hNaW46IG51bWJlciwgeE1heDogbnVtYmVyLCB5TWluOiBudW1iZXIsIHlNYXg6IG51bWJlcn0gfSBFbnZlbG9wZSAqL1xuXG5pbXBvcnQgeyB6b29tIGFzIGQzem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSBcImQzLXpvb21cIjtcbmltcG9ydCB7IHNlbGVjdCBhcyBkM3NlbGVjdCB9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuLyoqXG4gKiBBIEhUTUwgY2FudmFzIGZvciBnZW8gZGF0YSBkaXNwbGF5LCBlbmhhbmNlZCB3aXRoIHpvb20gYW5kIHBhbiBjYXBhYmlsaXRpZXMuXG4gKiBcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIEdlb0NhbnZhcyB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2VudGVyIEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpmIFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzSWQgPSBcInZhY2FudmFzXCIsIGNlbnRlciA9IHVuZGVmaW5lZCwgemYgPSAxKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtvYmplY3R9ICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IHRoaXMuY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMudztcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oO1xuXG4gICAgICAgIC8qKkB0eXBlIHtvYmplY3R9ICovXG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIC8vIHNldCBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlclxuICAgICAgICB0aGlzLnNldENlbnRlcihjZW50ZXIgfHwgeyB4OiB0aGlzLncgKiAwLjUsIHk6IHRoaXMuaCAqIDAuNSB9KVxuXG4gICAgICAgIC8vIHNldCB6b29tIGZhY3RvcjogcGl4ZWwgc2l6ZSwgaW4gbS9waXhcbiAgICAgICAgdGhpcy5zZXRaZih6Zik7XG5cbiAgICAgICAgLy9leHRlbnRcbiAgICAgICAgLyoqIEB0eXBlIHtFbnZlbG9wZX0gKi9cbiAgICAgICAgdGhpcy5leHRHZW8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcblxuICAgICAgICAvL3JlbHkgb24gZDMgem9vbSBmb3IgcGFuL3pvb21cbiAgICAgICAgbGV0IHRQID0gem9vbUlkZW50aXR5XG4gICAgICAgIGQzc2VsZWN0KHRoaXMuY2FudmFzKS5jYWxsKFxuICAgICAgICAgICAgZDN6b29tKCkub24oXCJ6b29tXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUudHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IHRQLmsgLyB0LmtcbiAgICAgICAgICAgICAgICBpZiAoZiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcGFuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gdFAueCAtIHQueFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeSA9IHRQLnkgLSB0LnlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW4oZHggKiB0aGlzLmdldFpmKCksIC1keSAqIHRoaXMuZ2V0WmYoKSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZSA9IGUuc291cmNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZSBpbnN0YW5jZW9mIFdoZWVsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vem9vbSBhdCB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbShmLCB0aGlzLnBpeFRvR2VvWChlLnNvdXJjZUV2ZW50Lm9mZnNldFgpLCB0aGlzLnBpeFRvR2VvWShlLnNvdXJjZUV2ZW50Lm9mZnNldFkpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlIGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIHRvdWNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eCA9IDAsIHR5ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHQgb2Ygc2UudGFyZ2V0VG91Y2hlcykgeyB0eCArPSB0dC5jbGllbnRYOyB0eSArPSB0dC5jbGllbnRZIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR4IC89IHNlLnRhcmdldFRvdWNoZXMubGVuZ3RoOyB0eSAvPSBzZS50YXJnZXRUb3VjaGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy96b29tIGF0IHRoaXMgYXZlcmFnZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tKGYsIHRoaXMucGl4VG9HZW9YKHR4KSwgdGhpcy5waXhUb0dlb1kodHkpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRQID0gdFxuICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IHYgR2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXIgKi9cbiAgICBzZXRDZW50ZXIodikgeyB0aGlzLmNlbnRlciA9IHY7IH1cbiAgICAvKiogQHJldHVybnMge3t4Om51bWJlcix5Om51bWJlcn19IEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyICovXG4gICAgZ2V0Q2VudGVyKCkgeyByZXR1cm4gdGhpcy5jZW50ZXI7IH1cblxuICAgIC8qKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgem9vbSBmYWN0b3IgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKSAqL1xuICAgIHNldFpmKHYpIHsgdGhpcy56ZiA9IHY7IH1cbiAgICAvKiogQHJldHVybnMge251bWJlcn0gVGhlIHpvb20gZmFjdG9yIChwaXhlbCBzaXplLCBpbiBncm91bmQgbSkgKi9cbiAgICBnZXRaZigpIHsgcmV0dXJuIHRoaXMuemY7IH1cblxuXG5cblxuICAgIC8qKiBJbml0aWFsaXNlIGNhbnZhcyB0cmFuc2Zvcm0gd2l0aCBpZGVudGl0eSB0cmFuc2Zvcm1hdGlvbi4gKi9cbiAgICBpbml0Q2FudmFzVHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqIEluaXRpYWxpc2UgY2FudmFzIHRyYW5zZm9ybSB3aXRoIGdlbyB0byBzY3JlZW4gdHJhbnNmb3JtYXRpb24sIHNvIHRoYXQgZ2VvIG9iamVjdHMgY2FuIGJlIGRyYXduIGRpcmVjdGx5IGluIGdlbyBjb29yZGluYXRlcy4gKi9cbiAgICBzZXRDYW52YXNUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC8gdGhpcy5nZXRaZigpO1xuICAgICAgICBjb25zdCB0eCA9IC10aGlzLmNlbnRlci54IC8gdGhpcy5nZXRaZigpICsgdGhpcy53ICogMC41O1xuICAgICAgICBjb25zdCB0eSA9IHRoaXMuY2VudGVyLnkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLmggKiAwLjU7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShrLCAwLCAwLCAtaywgdHgsIHR5KTtcbiAgICB9XG5cblxuICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyBob3cgdG8gZHJhdyB0aGUgbWFwLiAqL1xuICAgIHJlZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgcmVkcmF3IG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgYXBwIHNjcmVlbi4gVG8gYmUgdXNlZCBiZWZvcmUgYSByZWRyYXcgZm9yIGV4YW1wbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIFxuICAgICAqL1xuICAgIGNsZWFyKGNvbG9yID0gXCJ3aGl0ZVwiKSB7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG4gICAgfVxuXG4gICAgLy9jb252ZXJzaW9uIGZ1bmN0aW9uc1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4R2VvIEdlbyB4IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2NyZWVuIHggY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICovXG4gICAgZ2VvVG9QaXhYKHhHZW8pIHsgcmV0dXJuICh4R2VvIC0gdGhpcy5jZW50ZXIueCkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLncgKiAwLjU7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUdlbyBHZW8geSBjb29yZGluYXRlLCBpbiBtLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNjcmVlbiB5IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAqL1xuICAgIGdlb1RvUGl4WSh5R2VvKSB7IHJldHVybiAtKHlHZW8gLSB0aGlzLmNlbnRlci55KSAvIHRoaXMuZ2V0WmYoKSArIHRoaXMuaCAqIDAuNTsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjcmVlbiB4IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBHZW8geCBjb29yZGluYXRlLCBpbiBtLlxuICAgICovXG4gICAgcGl4VG9HZW9YKHgpIHsgcmV0dXJuICh4IC0gdGhpcy53ICogMC41KSAqIHRoaXMuZ2V0WmYoKSArIHRoaXMuY2VudGVyLng7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBTY3JlZW4geSBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHkgY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAqL1xuICAgIHBpeFRvR2VvWSh5KSB7IHJldHVybiAtKHkgLSB0aGlzLmggKiAwLjUpICogdGhpcy5nZXRaZigpICsgdGhpcy5jZW50ZXIueTsgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4R2VvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5R2VvXG4gICAgICovXG4gICAgcGFuKGR4R2VvLCBkeUdlbykge1xuICAgICAgICAvL1RPRE8gZm9yY2UgZXh0ZW5kIHRvIHJlbWFpblxuICAgICAgICB0aGlzLmNlbnRlci54ICs9IGR4R2VvO1xuICAgICAgICB0aGlzLmNlbnRlci55ICs9IGR5R2VvO1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWm9vbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiBUaGUgem9vbSBmYWN0b3IsIHdpdGhpbiBdMCwgSW5maW5pdHldLiAxIGlzIGZvciBubyBjaGFuZ2UuIDwxIHRvIHpvb20taW4sID4xIHRvIHpvb20tb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4R2VvIFRoZSB4IGdlbyBwb3NpdGlvbiBmaXhlZCBpbiB0aGUgc2NyZWVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5R2VvIFRoZSB5IGdlbyBwb3NpdGlvbiBmaXhlZCBpbiB0aGUgc2NyZWVuLlxuICAgICAqL1xuICAgIHpvb20oZiA9IDEsIHhHZW8gPSB0aGlzLmNlbnRlci54LCB5R2VvID0gdGhpcy5jZW50ZXIueSkge1xuICAgICAgICAvL1RPRE8gZm9yY2UgZXh0ZW5kIHRvIHJlbWFpblxuICAgICAgICB0aGlzLnNldFpmKGYgKiB0aGlzLmdldFpmKCkpO1xuICAgICAgICB0aGlzLmNlbnRlci54ICs9ICh4R2VvIC0gdGhpcy5jZW50ZXIueCkgKiAoMSAtIGYpXG4gICAgICAgIHRoaXMuY2VudGVyLnkgKz0gKHlHZW8gLSB0aGlzLmNlbnRlci55KSAqICgxIC0gZilcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRHZW8oKVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5QeCBcbiAgICAgKiBAcmV0dXJucyB7RW52ZWxvcGV9IFRoZSBlbnZlbG9wZSBvZiB0aGUgdmlldywgaW4gZ2VvIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIHVwZGF0ZUV4dGVudEdlbyhtYXJnaW5QeCA9IDIwKSB7XG4gICAgICAgIHRoaXMuZXh0R2VvID0ge1xuICAgICAgICAgICAgeE1pbjogdGhpcy5waXhUb0dlb1goLW1hcmdpblB4KSxcbiAgICAgICAgICAgIHhNYXg6IHRoaXMucGl4VG9HZW9YKHRoaXMudyArIG1hcmdpblB4KSxcbiAgICAgICAgICAgIHlNaW46IHRoaXMucGl4VG9HZW9ZKHRoaXMuaCArIG1hcmdpblB4KSxcbiAgICAgICAgICAgIHlNYXg6IHRoaXMucGl4VG9HZW9ZKC1tYXJnaW5QeClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHRHZW87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIG9iamVjdCBoYXMgdG8gYmUgZHJhd25cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IG9iaiBcbiAgICAgKi9cbiAgICB0b0RyYXcob2JqKSB7XG4gICAgICAgIGlmIChvYmoueCA8IHRoaXMuZXh0R2VvLnhNaW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9iai54ID4gdGhpcy5leHRHZW8ueE1heCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob2JqLnkgPCB0aGlzLmV4dEdlby55TWluKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvYmoueSA+IHRoaXMuZXh0R2VvLnlNYXgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5cbi8vc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoXG5pbXBvcnQgUkJ1c2ggZnJvbSAncmJ1c2gnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGF0aWFsSW5kZXgge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNsYXNzIE15UkJ1c2ggZXh0ZW5kcyBSQnVzaCB7XG4gICAgICAgICAgICAvKiogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBvYmogICovXG4gICAgICAgICAgICB0b0JCb3gob2JqKSB7IHJldHVybiB7IG1pblg6IG9iai54LCBtaW5ZOiBvYmoueSwgbWF4WDogb2JqLngsIG1heFk6IG9iai55IH07IH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBhIFxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBiIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb21wYXJlTWluWChhLCBiKSB7IHJldHVybiBhLnggLSBiLng7IH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBhIFxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBiIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb21wYXJlTWluWShhLCBiKSB7IHJldHVybiBhLnkgLSBiLnk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7TXlSQnVzaH0gKi9cbiAgICAgICAgdGhpcy50cmVlID0gbmV3IE15UkJ1c2goKTtcbiAgICB9XG5cbiAgICAvL1RPRE8gYnVsayByZW1vdmUgP1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geW1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4bWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHltYXhcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48VD59XG4gICAgICovXG4gICAgZ2V0KHhtaW4sIHltaW4sIHhtYXgsIHltYXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5zZWFyY2goe1xuICAgICAgICAgICAgbWluWDogeG1pbixcbiAgICAgICAgICAgIG1pblk6IHltaW4sXG4gICAgICAgICAgICBtYXhYOiB4bWF4LFxuICAgICAgICAgICAgbWF4WTogeW1heFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R9IG9ialxuICAgICAqL1xuICAgIGluc2VydChvYmopIHtcbiAgICAgICAgdGhpcy50cmVlLmluc2VydChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1bGsgaW5zZXJ0XG4gICAgICogXG4gICAgICogQHBhcmFtIHtBcnJheS48VD59IG9ianNcbiAgICAgKi9cbiAgICBsb2FkKG9ianMpIHtcbiAgICAgICAgdGhpcy50cmVlLmxvYWQob2Jqcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUfSBvYmpcbiAgICAgKi9cbiAgICByZW1vdmUob2JqKSB7XG4gICAgICAgIHRoaXMudHJlZS5yZW1vdmUob2JqKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnRyZWUuY2xlYXIoKVxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7T2JqZWN0Ljw/LCBUPn0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXkuPFQ+fVxuICovXG5leHBvcnQgY29uc3Qgb2JqVG9BcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgb3V0LnB1c2gob2JqW2tleV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyXG4gKiBAcGFyYW0ge1R9IG9ialxuICogQHBhcmFtIHtib29sZWFufSBtc2cgXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBvYmosIG1zZyA9IHRydWUpIHtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihvYmopO1xuICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBlbHNlXG4gICAgICAgIGlmIChtc2cpIGNvbnNvbGUubG9nKFwiSW1wb3NzaWJsZSB0byByZW1vdmUgZWxlbWVudCBub3QgcHJlc2VudCBpbiBhcnJheS5cIik7XG59O1xuXG4vKipcbiAqIFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnJcbiAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBvYmpzIFxuICogQHBhcmFtIHtib29sZWFufSBtc2cgXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVGcm9tQXJyYXlTID0gZnVuY3Rpb24gKGFyciwgb2JqcywgbXNnID0gdHJ1ZSkge1xuICAgIGZvciAobGV0IG9iaiBvZiBvYmpzKVxuICAgICAgICByZW1vdmVGcm9tQXJyYXkoYXJyLCBvYmosIG1zZylcbn07XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU2VhIH0gZnJvbSBcIi4vU2VhXCJcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gXCIuLi9iYXNlL0dlb0NhbnZhc1wiXG5pbXBvcnQgeyBBZ2VudFBvaW50IH0gZnJvbSBcIi4uL2Jhc2UvQWdlbnRQb2ludFwiO1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuXG4vKiogKi9cbmV4cG9ydCBjbGFzcyBTYXJkaW4gZXh0ZW5kcyBBZ2VudFBvaW50IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2VhfSBzZWEgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZWEsIHggPSBzZWEudyAqIE1hdGgucmFuZG9tKCksIHkgPSBzZWEuaCAqIE1hdGgucmFuZG9tKCksIHN4ID0gdW5kZWZpbmVkLCBzeSA9IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIC8vXG4gICAgICAgIHN1cGVyKHgsIHksIHN4LCBzeSlcblxuICAgICAgICAvKiogQHR5cGUge1NlYX0gKi9cbiAgICAgICAgdGhpcy5zZWEgPSBzZWE7XG5cbiAgICAgICAgLy9wb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geCA8IDAgPyAwIDogeCA+IHNlYS53ID8gc2VhLncgOiB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5IDwgMCA/IDAgOiB5ID4gc2VhLmggPyBzZWEuaCA6IHlcblxuICAgICAgICAvL3NwZWVkXG4gICAgICAgIGlmICghc3ggJiYgIXN5KSB7XG4gICAgICAgICAgICB0aGlzLnNldFJhbmRvbVNwZWVkKDAsIHRoaXMuc2VhLlZfTUFYKVxuXG4gICAgICAgICAgICAvL2FjY2VsZXJhdGlvblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICB0aGlzLmF4ID0gMFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICB0aGlzLmF5ID0gMFxuXG4gICAgICAgICAgICAvL2xpc3Qgb2Ygc2FyZGlucyBpbiB2aXNpb24gZmllbGRcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgICAgICB0aGlzLm9icyA9IFtdXG4gICAgICAgICAgICAvL2xpc3Qgb2Ygc2FyZGlucyBpbiBjb2xsaXNpb24gZmllbGRcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgICAgICB0aGlzLmNvbCA9IFtdXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3BhdGlhbEluZGV4LjxTYXJkaW4+fSBzaW5kZXggXG4gICAgICovXG4gICAgb2JzZXJ2ZShzaW5kZXgpIHtcblxuICAgICAgICAvKiogQHR5cGUge1NlYX0gKi9cbiAgICAgICAgY29uc3QgcyA9IHRoaXMuc2VhXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBjb25zdCBkTyA9IHMuRF9PQlNcblxuICAgICAgICAvL2luaXRpYWxpc2UgbGlzdHNcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5vYnMgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5jb2wgPSBbXTtcblxuICAgICAgICAvL2dldCBzYXJkaW5zIGFyb3VuZCB1c2luZyBzcGF0aWFsIGluZGV4XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIGNvbnN0IHNzID0gc2luZGV4LmdldCh0aGlzLnggLSBkTywgdGhpcy55IC0gZE8sIHRoaXMueCArIGRPLCB0aGlzLnkgKyBkTyk7XG5cbiAgICAgICAgLy9nZXQgc2FyZGlucyBpbiBvYnNlcnZhdGlvbiBhbmQgY29sbGlzaW9uIGZpZWxkc1xuICAgICAgICBmb3IgKGxldCBmIG9mIHNzKSB7XG4gICAgICAgICAgICBpZiAoZiA9PSB0aGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmQoZikgPD0gcy5EX0NPTClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbC5wdXNoKGYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZChmKSA8PSBkTykge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgYW5nbGVcbiAgICAgICAgICAgICAgICBsZXQgZGEgPSBNYXRoLmF0YW4yKGYueSAtIHRoaXMueSwgZi54IC0gdGhpcy54KSAtIHRoaXMuc2E7XG4gICAgICAgICAgICAgICAgaWYgKGRhID4gTWF0aC5QSSkgZGEgLT0gMiAqIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGEgPD0gLU1hdGguUEkpIGRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIGRhID0gTWF0aC5hYnMoZGEpO1xuICAgICAgICAgICAgICAgIGlmIChkYSA+IHMuQV9PQlMgKiAwLjUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRoaXMub2JzLnB1c2goZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2luaXRpYWxpc2UgYWNjZWxlcmF0aW9uXG4gICAgICAgIHRoaXMuYXggPSAwOyB0aGlzLmF5ID0gMDtcblxuICAgICAgICAvL2NvbGxpc2lvbjogcmVwdWxzaW9uXG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5jb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmQoZik7XG4gICAgICAgICAgICBjb25zdCBhID0gMS4wICogKDEgLyAoZCAqIGQpIC0gMSAvIChzLkRfQ09MICogcy5EX0NPTCkpO1xuICAgICAgICAgICAgdGhpcy5heCArPSBhICogKHRoaXMueCAtIGYueCkgLyBkO1xuICAgICAgICAgICAgdGhpcy5heSArPSBhICogKHRoaXMueSAtIGYueSkgLyBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG93YXJkIHRhcmdldCBzcGVlZFxuICAgICAgICBjb25zdCBkdiA9IChzLlZfVEFSR0VUIC0gdGhpcy5zKSAqIDAuMDE7XG4gICAgICAgIHRoaXMuYXggKz0gZHYgKiB0aGlzLnN4IC8gdGhpcy5zO1xuICAgICAgICB0aGlzLmF5ICs9IGR2ICogdGhpcy5zeSAvIHRoaXMucztcblxuICAgICAgICAvL3Rvd2FyZCB0aGUgb2JzZXJ2ZWQgbWVhbiBwb3NpdGlvblxuICAgICAgICAvKmlmKG9icy5zaXplKCk+MSl7XG4gICAgICAgICAgICBkb3VibGUgeG49MCx5bj0wO1xuICAgICAgICAgICAgZm9yKFNhcmRpbiBzOm9icyl7XG4gICAgICAgICAgICAgICAgeG4rPXMueDtcbiAgICAgICAgICAgICAgICB5bis9cy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeG49eG4vb2JzLnNpemUoKTtcbiAgICAgICAgICAgIHluPXluL29icy5zaXplKCk7XG4gICAgICAgICAgICBkb3VibGUgZD1NYXRoLmh5cG90KHhuLXgseW4teSk7XG4gICAgICAgICAgICBheCs9LTAuMSooeC14bikvZDtcbiAgICAgICAgICAgIGF5Kz0tMC4xKih5LXluKS9kO1xuICAgICAgICB9Ki9cblxuICAgICAgICAvL3Rvd2FyZCB0aGUgb2JzZXJ2ZWQgc3BlZWRcbiAgICAgICAgY29uc3QgdCA9IDAuOTtcbiAgICAgICAgaWYgKHRoaXMub2JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBkc3ggPSAwLCBkc3kgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLm9icykge1xuICAgICAgICAgICAgICAgIGRzeCArPSBzLnN4O1xuICAgICAgICAgICAgICAgIGRzeSArPSBzLnN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHN4ID0gKHQgLSAxKSAqIHRoaXMuc3ggKyAoMSAtIHQpICogZHN4IC8gdGhpcy5vYnMubGVuZ3RoO1xuICAgICAgICAgICAgZHN5ID0gKHQgLSAxKSAqIHRoaXMuc3kgKyAoMSAtIHQpICogZHN5IC8gdGhpcy5vYnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBjb25zdCBhID0gMC4xO1xuICAgICAgICAgICAgdGhpcy5heCArPSBhICogZHN4O1xuICAgICAgICAgICAgdGhpcy5heSArPSBhICogZHN5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hdm9pZCBzaGFya1xuICAgICAgICBjb25zdCBzaCA9IHMuc2hhcms7XG4gICAgICAgIGlmIChzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gTWF0aC5oeXBvdCgoc2gueCAtIHRoaXMueCksIChzaC55IC0gdGhpcy55KSk7XG4gICAgICAgICAgICBpZiAoZCA8PSBzLkRfT0JTKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IDUuMCAqICgxIC8gKGQgKiBkKSAtIDEgLyAoZE8gKiBkTykpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXggKz0gYSAqICh0aGlzLnggLSBzaC54KSAvIGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5heSArPSBhICogKHRoaXMueSAtIHNoLnkpIC8gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBtb3ZlKHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBuZXcgc3BlZWRcbiAgICAgICAgdGhpcy5zeCArPSB0aGlzLmF4ICogdGltZVN0ZXBNcyArICgxIC0gMiAqIE1hdGgucmFuZG9tKCkpICogMC4wMjtcbiAgICAgICAgdGhpcy5zeSArPSB0aGlzLmF5ICogdGltZVN0ZXBNcyArICgxIC0gMiAqIE1hdGgucmFuZG9tKCkpICogMC4wMjtcbiAgICAgICAgdGhpcy5zID0gdGhpcy5jb21wdXRlU3BlZWQoKVxuICAgICAgICBpZiAodGhpcy5zID4gdGhpcy5zZWEuVl9NQVgpIHtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMuc2VhLlZfTUFYO1xuICAgICAgICAgICAgdGhpcy5zeCA9IHRoaXMuc2VhLlZfTUFYICogTWF0aC5jb3ModGhpcy5zYSk7XG4gICAgICAgICAgICB0aGlzLnN5ID0gdGhpcy5zZWEuVl9NQVggKiBNYXRoLnNpbih0aGlzLnNhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBuZXcgcG9zaXRpb25cbiAgICAgICAgdGhpcy54ICs9IHRoaXMuc3ggKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy5zeSAqIHRpbWVTdGVwTXM7XG5cbiAgICAgICAgLy9saW1pdFxuICAgICAgICBpZiAodGhpcy54IDwgMCkgdGhpcy54ID0gdGhpcy5zZWEudztcbiAgICAgICAgaWYgKHRoaXMueSA8IDApIHRoaXMueSA9IHRoaXMuc2VhLmg7XG4gICAgICAgIGlmICh0aGlzLnggPiB0aGlzLnNlYS53KSB0aGlzLnggPSAwO1xuICAgICAgICBpZiAodGhpcy55ID4gdGhpcy5zZWEuaCkgdGhpcy55ID0gMDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgYSBzYXJkaW4gYm9keVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjb25zdCBjID0gTWF0aC5mbG9vcigyNTUgKiBNYXRoLmFicyh0aGlzLnNhKSAvIE1hdGguUEkpO1xuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwicmdiKDI1NSwgMjU1LCBcIiArIGMgKyBcIilcIlxuICAgICAgICBjb25zdCBhID0gbGVuZ3RoIC8gdGhpcy5zO1xuICAgICAgICBjb25zdCBkeCA9IGEgKiB0aGlzLnN4ICogMC41O1xuICAgICAgICBjb25zdCBkeSA9IGEgKiB0aGlzLnN5ICogMC41O1xuXG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5tb3ZlVG8odGhpcy54IC0gZHgsIHRoaXMueSAtIGR5KTtcbiAgICAgICAgYzIubGluZVRvKHRoaXMueCArIGR4LCB0aGlzLnkgKyBkeSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5zdHJva2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHNhcmRpbiB2aXNpb24gZmllbGRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGxTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqL1xuICAgIGRpc3BsYXlWaXNpb25GaWVsZChjcCwgZmlsbFN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLm1vdmVUbyh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGMyLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5zZWEuRF9PQlMgLyBjcC5nZXRaZigpLFxuICAgICAgICAgICAgdGhpcy5zYSAtIHRoaXMuc2VhLkFfT0JTICogMC41LFxuICAgICAgICAgICAgdGhpcy5zYSArIHRoaXMuc2VhLkFfT0JTICogMC41XG4gICAgICAgICk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5maWxsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBzYXJkaW4gdmlzaW9uIGxpbmtzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqL1xuICAgIGRpc3BsYXlWaXNpb25MaW5rcyhjcCwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGZvciAobGV0IHNhMiBvZiB0aGlzLm9icykge1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5tb3ZlVG8odGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgYzIubGluZVRvKHNhMi54LCBzYTIueSk7XG4gICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBzYXJkaW4gY29sbGlzaW9uIGZpZWxkXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqL1xuICAgIGRpc3BsYXlDb2xsaXNpb25GaWVsZChjcCwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuc2VhLkRfQ09MICogMC41IC8gY3AuZ2V0WmYoKSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU2FyZGluIH0gZnJvbSAnLi9TYXJkaW4nO1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgcmVtb3ZlRnJvbUFycmF5IH0gZnJvbSAnLi4vYmFzZS9saWInO1xuXG4vKiogKi9cbmV4cG9ydCBjbGFzcyBTZWEge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggXG4gICAgICovICAgICAgICAvL2dldCAxMCByYW5kb20gbG9jYXRpb25zXG5cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG5cbiAgICAgICAgLy9UT0RPIHNob3VsZCBiZWNvbWUgc3RhdGljIGF0dHJpYnV0ZXMgb2YgU2FyZGluIGNsYXNzXG5cbiAgICAgICAgLy9vYnNlcnZhdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5EX09CUyA9IDUwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkFfT0JTID0gMjAwICogTWF0aC5QSSAvIDE4MFxuXG4gICAgICAgIC8vY29sbGlzaW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkRfQ09MID0gMTBcblxuICAgICAgICAvL3NwZWVkXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLlZfVEFSR0VUID0gMC4zXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLlZfTUFYID0gMC42XG5cbiAgICAgICAgLy9zaGFya1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5EX1NIQVJLX0VBVCA9IDEyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkVBVEVOX1NBUkRJTl9OQiA9IDBcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICB0aGlzLmZpc2ggPSBbXVxuXG4gICAgICAgIC8vVE9ET1xuICAgICAgICB0aGlzLnNoYXJrID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICB0aGlzLmtpbGxlZCA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIHN0ZXAodGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9pbmlcbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmZpc2gpIHtcbiAgICAgICAgICAgIGYuY29tcHV0ZVNwZWVkKClcbiAgICAgICAgICAgIGYuY29tcHV0ZVNwZWVkQW5nbGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9tYWtlIHNwYXRpYWwgaW5kZXhcbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPFNhcmRpbj59ICovXG4gICAgICAgIGNvbnN0IHNpbmRleCA9IG5ldyBTcGF0aWFsSW5kZXgoKTtcbiAgICAgICAgc2luZGV4LmxvYWQodGhpcy5maXNoKVxuXG4gICAgICAgIC8vb2JzZXJ2ZVxuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuZmlzaClcbiAgICAgICAgICAgIGYub2JzZXJ2ZShzaW5kZXgpO1xuXG4gICAgICAgIC8vc2hhcmsgZWF0IGZpc2hcbiAgICAgICAgdGhpcy5zaGFya0VhdChzaW5kZXgpO1xuXG4gICAgICAgIC8vZGlzcG9zZSBzcGF0aWFsIGluZGV4XG4gICAgICAgIC8vc2luZGV4LmNsZWFyKClcblxuICAgICAgICAvL21vdmVcbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmZpc2gpXG4gICAgICAgICAgICBmLm1vdmUodGltZVN0ZXBNcyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48U2FyZGluPn0gc2luZGV4IFxuICAgICAqL1xuICAgIHNoYXJrRWF0KHNpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zaGFyayA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5raWxsZWQgPSBbXTtcblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5zaGFyay54LCB5ID0gdGhpcy5zaGFyay55O1xuICAgICAgICBjb25zdCBzcyA9IHNpbmRleC5nZXQoeCAtIHRoaXMuRF9TSEFSS19FQVQsIHkgLSB0aGlzLkRfU0hBUktfRUFULCB4ICsgdGhpcy5EX1NIQVJLX0VBVCwgeSArIHRoaXMuRF9TSEFSS19FQVQpO1xuICAgICAgICBmb3IgKGxldCBzIG9mIHNzKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gTWF0aC5oeXBvdCgoeCAtIHMueCksICh5IC0gcy55KSk7XG4gICAgICAgICAgICBpZiAoZCA+IHRoaXMuRF9TSEFSS19FQVQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5raWxsZWQucHVzaChzKTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLmZpc2gsIHMpXG4gICAgICAgICAgICAvL3NpbmRleC5yZW1vdmUocyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5FQVRFTl9TQVJESU5fTkIgKz0gdGhpcy5raWxsZWQubGVuZ3RoO1xuICAgICAgICAvL2VhdGVuRmlzaE5iLnNldFRleHQoXCJFYXRlbiBmaXNoOiBcIiArIEVBVEVOX1NBUkRJTl9OQik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBmaXNoXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGFkZEZpc2gobmIgPSAxKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKylcbiAgICAgICAgICAgIHRoaXMuZmlzaC5wdXNoKG5ldyBTYXJkaW4odGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCByYW5kb20gc3BlZWQgZm9yIGFsbCBmaXNoXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0UmFuZG9tU3BlZWQoKSB7XG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5maXNoKVxuICAgICAgICAgICAgZi5zZXRSYW5kb21TcGVlZCgpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU2VhIH0gZnJvbSAnLi9TZWEnO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuXG5jbGFzcyBGaXNoU2ltdWxhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvL1RPRE9cbiAgICAgICAgLy9hZGQgZWF0ZW4gZmlzaCBuYiBsYWJlbFxuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd0Zpc2hWaXNpb25GaWVsZCA9IGZhbHNlXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zaG93RmlzaFZpc2lvbkxpbmtzID0gZmFsc2VcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dGaXNoQ29sbGlzaW9uRmllbGQgPSBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHRoID0gdGhpcztcbiAgICAgICAgdGhpcy5jcGx1cy5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuY3R4XG4gICAgICAgICAgICBjb25zdCBzID0gdGguc2VhXG5cbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgICAgIC8vY2xlYXJcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmdiYSgxMjAsMTIwLDI1NSwwLjYpXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcblxuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL3Nob3cgdmlzaW9uIGZpZWxkXG4gICAgICAgICAgICBpZiAodGguc2hvd0Zpc2hWaXNpb25GaWVsZClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzYS5kaXNwbGF5VmlzaW9uRmllbGQodGhpcywgXCJyZ2JhKDIwMCwyMDAsMjAwLDAuMTUpXCIsIDEpXG4gICAgICAgICAgICAvL3Nob3cgdmlzaW9uIGxpbmtzXG4gICAgICAgICAgICBpZiAodGguc2hvd0Zpc2hWaXNpb25MaW5rcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzYS5kaXNwbGF5VmlzaW9uTGlua3ModGhpcywgXCJyZ2JhKDI1NSwxMDAsMTAwLDAuMylcIiwgMSlcbiAgICAgICAgICAgIC8vc2hvdyBjb2xsaXNpb24gZmllbGRcbiAgICAgICAgICAgIGlmICh0aC5zaG93RmlzaENvbGxpc2lvbkZpZWxkKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNhIG9mIHMuZmlzaClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KHNhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhLmRpc3BsYXlDb2xsaXNpb25GaWVsZCh0aGlzLCBcInB1cnBsZVwiLCAxKVxuXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBzYXJkaW5zXG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAyXG4gICAgICAgICAgICBjb25zdCBzYXJkaW5MZW5ndGggPSA3XG4gICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KHNhKSlcbiAgICAgICAgICAgICAgICAgICAgc2EuZGlzcGxheSh0aGlzLCBzYXJkaW5MZW5ndGgpXG5cblxuICAgICAgICAgICAgLy9kaXNwbGF5IHNoYXJrXG4gICAgICAgICAgICBpZiAocy5zaGFyayAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICBjMi5saW5lV2lkdGggPSA0XG4gICAgICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCJcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJrTGVuZ3RoID0gMTJcbiAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHNoYXJrTGVuZ3RoICogTWF0aC5jb3Mocy5zaGFyay5hbmdsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHkgPSBzaGFya0xlbmd0aCAqIE1hdGguc2luKHMuc2hhcmsuYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgYzIubW92ZVRvKHMuc2hhcmsueCwgcy5zaGFyay55KTtcbiAgICAgICAgICAgICAgICBjMi5saW5lVG8ocy5zaGFyay54IC0gZHgsIHMuc2hhcmsueSArIGR5KTtcbiAgICAgICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kaXNwbGF5IGJsb29kIHNwb3RcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxXG4gICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmtpbGxlZCkge1xuICAgICAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLm1vdmVUbyhzYS54LCBzYS55KTtcbiAgICAgICAgICAgICAgICBjMi5hcmMoc2EueCwgc2EueSwgNCwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLmZpbGwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNwbHVzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGUgPT4ge1xuICAgICAgICAgICAgdGguc2VhLnNoYXJrID0geyB4OiB0aC5jcGx1cy5waXhUb0dlb1goZS5vZmZzZXRYKSwgeTogdGguY3BsdXMucGl4VG9HZW9ZKGUub2Zmc2V0WSksIGFuZ2xlOiAwIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3BsdXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB4RyA9IHRoLmNwbHVzLnBpeFRvR2VvWChlLm9mZnNldFgpO1xuICAgICAgICAgICAgY29uc3QgeUcgPSB0aC5jcGx1cy5waXhUb0dlb1koZS5vZmZzZXRZKTtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMigteUcgKyB0aC5zZWEuc2hhcmsueSwgeEcgLSB0aC5zZWEuc2hhcmsueCk7XG4gICAgICAgICAgICB0aC5zZWEuc2hhcmsgPSB7IHg6IHhHLCB5OiB5RywgYW5nbGU6IGFuZ2xlIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3BsdXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoLnNlYS5zaGFyayA9IG51bGw7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtTZWF9ICovXG4gICAgICAgIHRoaXMuc2VhID0gbmV3IFNlYSh0aGlzLncsIHRoaXMuaClcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHkgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdFJhbmRvbShkZW5zaXR5ID0gMC4wMDEpIHtcbiAgICAgICAgdGhpcy5zZWEuYWRkRmlzaChkZW5zaXR5ICogdGhpcy5zZWEudyAqIHRoaXMuc2VhLmgpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYkl0ZXJhdGlvbnMgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RhcnQodGltZVN0ZXBNcyA9IDEwLCBuYkl0ZXJhdGlvbnMgPSAtMSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0LnNlYS5zdGVwKHRpbWVTdGVwTXMpO1xuICAgICAgICAgICAgdC5jcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYkl0ZXJhdGlvbnMgPiAwICYmIGkrKyA+IG5iSXRlcmF0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGVuZ2luZSgpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICovXG5leHBvcnQgY29uc3QgZmlzaCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBGaXNoU2ltdWxhdGlvbihvcHRzKVxufVxuIiwiLy9AdHMtY2hlY2tcblxuLyoqXG4gKiBcbiAqL1xuZXhwb3J0IGNsYXNzIENlbGwge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIG5iPTApIHtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubmIgPSBuYlxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IG9ialRvQXJyYXkgfSBmcm9tICcuLi9iYXNlL2xpYic7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5pbXBvcnQgeyBDZWxsIH0gZnJvbSAnLi9DZWxsJztcblxuLyoqXG4gKiBcbiAqL1xuZXhwb3J0IGNsYXNzIFVuaXZlcnNlIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBoO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPENlbGw+fSAqL1xuICAgICAgICB0aGlzLnBvcHVsYXRpb24gPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxDZWxsPn0gKi9cbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uSSA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Q2VsbHxudWxsfVxuICAgICAqL1xuICAgIGFkZCh4LCB5KSB7XG5cbiAgICAgICAgLy9maW5kIGNlbGwgYXQgbG9jYXRpb25cbiAgICAgICAgLyoqQHR5cGUge3N0cmluZ30qL1xuICAgICAgICBjb25zdCBpZCA9IHggKyBcIl9cIiArIHk7XG4gICAgICAgIGlmICh0aGlzLnBvcHVsYXRpb25JW2lkXSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy9jcmVhdGUgbmV3IGNlbGxcbiAgICAgICAgLyoqQHR5cGUge0NlbGx9ICovXG4gICAgICAgIGNvbnN0IGNlbGwgPSBuZXcgQ2VsbCh4LCB5LCAwKVxuICAgICAgICB0aGlzLnBvcHVsYXRpb24ucHVzaChjZWxsKVxuICAgICAgICB0aGlzLnBvcHVsYXRpb25JW2lkXSA9IGNlbGxcbiAgICAgICAgcmV0dXJuIGNlbGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGVwKCkge1xuXG4gICAgICAgIC8vVE9ETyBkb3VibGUgaW5kZXhpbmc/IGJ5IHJhdyBhbmQgdGhlbiBjb2x1bW4gP1xuICAgICAgICAvL3BvcHVsYXRlIGNlbGwgc3Vycm91bmRpbmdzXG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENlbGw+fVxuICAgICAgICAgKiBAZGljdCAqL1xuICAgICAgICBjb25zdCBzdXJJID0ge307XG4gICAgICAgIC8vZ28gdGhyb3VnaCBsaXN0IG9mIGNlbGxzXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgdGhpcy5wb3B1bGF0aW9uKSB7XG4gICAgICAgICAgICAvLyArMSBzdXJyb3VuZGluZyBjZWxsc1xuICAgICAgICAgICAgY29uc3Qgc3JzID0gVW5pdmVyc2UuZ2V0Q2VsbFN1cnJvdW5kaW5nKGNlbGwsIHRoaXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgc3VyIG9mIHNycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHN1ci54ICsgXCJfXCIgKyBzdXIueTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdXJfID0gc3VySVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChzdXJfKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cl8ubmIrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdXIubmIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBzdXJJW2tleV0gPSBzdXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9CMy9TMjNcbiAgICAgICAgLy9raWxsIGNlbGxzXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPENlbGw+fSAqL1xuICAgICAgICBjb25zdCBjZWxsc1RvS2VlcCA9IFtdO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBDZWxsPn1cbiAgICAgICAgICogQGRpY3QgKi9cbiAgICAgICAgY29uc3QgY2VsbHNUb0tlZXBJID0ge307XG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgdGhpcy5wb3B1bGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjZWxsLnggKyBcIl9cIiArIGNlbGwueTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxfID0gc3VySVtrZXldO1xuICAgICAgICAgICAgaWYgKCFjZWxsXykgY29udGludWU7XG4gICAgICAgICAgICAvL2lmIChuYjwyIG9yIG5iPjMpIC0+IGtpbGxcbiAgICAgICAgICAgIGlmIChjZWxsXy5uYiA8IDIgfHwgY2VsbF8ubmIgPiAzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNlbGxzVG9LZWVwLnB1c2goY2VsbCk7XG4gICAgICAgICAgICBjZWxsc1RvS2VlcElba2V5XSA9IGNlbGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uID0gY2VsbHNUb0tlZXA7XG4gICAgICAgIHRoaXMucG9wdWxhdGlvbkkgPSBjZWxsc1RvS2VlcEk7XG5cbiAgICAgICAgLy9jcmVhdGUgbmV3IGNlbGxzXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPENlbGw+fSAqL1xuICAgICAgICBjb25zdCBzdXJzID0gb2JqVG9BcnJheShzdXJJKTtcbiAgICAgICAgZm9yIChsZXQgc3VyIG9mIHN1cnMpIHtcblxuICAgICAgICAgICAgaWYgKHN1ci5uYiAhPT0gMykgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vY2hlY2sgaWYgYWxyZWFkeSBhbGl2ZVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gc3VyLnggKyBcIl9cIiArIHN1ci55O1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnBvcHVsYXRpb25JW2tleV07XG4gICAgICAgICAgICBpZiAoY2VsbCkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vY3JlYXRlIG5ldyBjZWxsXG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRpb24ucHVzaChzdXIpO1xuICAgICAgICAgICAgdGhpcy5wb3B1bGF0aW9uSVtrZXldID0gc3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNU1xuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcGx1c1xuICAgICAqIEByZXR1cm4ge1VuaXZlcnNlfVxuICAgICAqL1xuICAgIHN0YXJ0KG5iLCB0aW1lb3V0TVMsIGNwbHVzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdW5pID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhpKTtcbiAgICAgICAgICAgIHVuaS5zdGVwKCk7XG4gICAgICAgICAgICBjcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYiA+IDAgJiYgaSsrID4gbmIpIHJldHVybjtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5naW5lLCB0aW1lb3V0TVMpO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDZWxsfSBjZWxsXG4gICAgICogQHBhcmFtIHtVbml2ZXJzZX0gdW5pXG4gICAgICogQHJldHVybiB7QXJyYXkuPENlbGw+fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDZWxsU3Vycm91bmRpbmcoY2VsbCwgdW5pKSB7XG4gICAgICAgIGNvbnN0IHgxID0gY2VsbC54ID09PSAwID8gdW5pLncgLSAxIDogY2VsbC54IC0gMTtcbiAgICAgICAgY29uc3QgeDIgPSBjZWxsLnggPT09IHVuaS53IC0gMSA/IDAgOiBjZWxsLnggKyAxO1xuICAgICAgICBjb25zdCB5MSA9IGNlbGwueSA9PT0gMCA/IHVuaS5oIC0gMSA6IGNlbGwueSAtIDE7XG4gICAgICAgIGNvbnN0IHkyID0gY2VsbC55ID09PSB1bmkuaCAtIDEgPyAwIDogY2VsbC55ICsgMTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBDZWxsKHgxLCB5MSksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MSwgY2VsbC55KSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgxLCB5MiksXG4gICAgICAgICAgICBuZXcgQ2VsbChjZWxsLngsIHkxKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKGNlbGwueCwgeTIpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDIsIHkxKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgyLCBjZWxsLnkpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDIsIHkyKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5pbXBvcnQgeyBVbml2ZXJzZSB9IGZyb20gJy4vVW5pdmVyc2UnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbCc7XG5cbi8vVE9ETyB6b29tL3Bhbiwgd2l0aCBjYW52YXMgdHJhbnNmb3JtOiBiZXR0ZXIgdW5pdmVyc2UgbGltaXRzXG4vL1RPRE8gYnV0dG9ucyAocGxheSwgc3RvcCwgc3BlZWQsIGRyYXcsIHBhbilcbi8vVE9ETyBjaGVjayBjYW52YXMgYW5pbWF0aW9uXG5cblxuY2xhc3MgR29MU2ltdWxhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICAvL2NsZWFyXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIC8vZHJhdyBjZWxsc1xuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJibHVlXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHRoLnVuaS5wb3B1bGF0aW9uKVxuICAgICAgICAgICAgICAgIGMyLmZpbGxSZWN0KChjZWxsLngpLCAoY2VsbC55KSwgMSwgMSk7XG5cbiAgICAgICAgICAgIC8vZnJhbWVcbiAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJkYXJrZ3JheVwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMSAqIHRoLmNwbHVzLmdldFpmKCk7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLnJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVuaSA9IG5ldyBVbml2ZXJzZSh0aGlzLncsIHRoaXMuaCk7XG4gICAgfVxuXG5cbiAgICAvL1xuICAgIGluaXRSYW5kb20oZGVuc2l0eSA9IDAuMDUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3QgbmIgPSB0aGlzLnVuaS53ICogdGhpcy51bmkuaCAqIGRlbnNpdHk7XG4gICAgICAgIHdoaWxlIChpIDwgbmIpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHRoaXMudW5pLncgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHRoaXMudW5pLmggKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7Q2VsbH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLnVuaS5hZGQoeCwgeSk7XG4gICAgICAgICAgICBpZiAoY2VsbCkgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLy9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy51bmkuc3RhcnQoLTEsIDAsIHRoaXMuY3BsdXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cblxuXG5leHBvcnQgY29uc3QgZ2FtZU9mTGlmZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBHb0xTaW11bGF0aW9uKG9wdHMpXG59XG4iLCIvL0B0cy1jaGVja1xuXG5leHBvcnQgKiBmcm9tIFwiLi9wbGFuZXRzL2luZGV4XCJcbmV4cG9ydCAqIGZyb20gXCIuL2dvbC9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi9maXNoL2luZGV4XCJcbmV4cG9ydCAqIGZyb20gXCIuL3BwL2luZGV4XCJcbmV4cG9ydCAqIGZyb20gXCIuL3VyYmFuL2luZGV4XCJcbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBVbml2ZXJzZSB9IGZyb20gXCIuL1VuaXZlcnNlXCI7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgQWdlbnRQb2ludCB9IGZyb20gXCIuLi9iYXNlL0FnZW50UG9pbnRcIjtcblxuZXhwb3J0IGNsYXNzIFBsYW5ldCBleHRlbmRzIEFnZW50UG9pbnQge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtVbml2ZXJzZX0gdSBUaGUgdW5pdmVyc2UgdGhlIHBsYW5ldCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSBtYXNzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBUaGUgc3BlZWQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSBUaGUgc3BlZWQgeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHUsIG0sIHgsIHksIHN4ID0gMCwgc3kgPSAwKSB7XG5cbiAgICAgICAgLy9cbiAgICAgICAgc3VwZXIoeCwgeSwgc3gsIHN5KVxuXG4gICAgICAgIC8qKiBAdHlwZSB7VW5pdmVyc2V9ICovXG4gICAgICAgIHRoaXMudSA9IHU7XG4gICAgICAgIHUucHMucHVzaCh0aGlzKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm0gPSBtO1xuXG4gICAgICAgIC8vY29tcHV0ZSByYWRpdXNcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLnIoKTtcblxuICAgICAgICAvL3NldCBwb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geCA8IHIgPyByIDogeCA+IHUudyAtIHIgPyB1LncgLSByIDogeDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHkgPCByID8gciA6IHkgPiB1LmggLSByID8gdS5oIC0gciA6IHk7XG5cbiAgICAgICAgLy9hY2NlbGVyYXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXggPSAwO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5heSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBmb3JjZSwgYmFzZWQgb24gdGhlIGdyYXZpdHkgb2Ygb3RoZXIgcGxhbmV0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAgICAgKi9cbiAgICBvYnNlcnZlKGV4cG9uZW50KSB7XG5cbiAgICAgICAgLy9jb21wdXRlIGdyYXZpdHkgZmllbGQgYXQgcGxhbmV0IGxvY2F0aW9uXG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLnUuZ2V0R3Jhdml0eUZpZWxkKHRoaXMueCwgdGhpcy55LCB0aGlzLCBleHBvbmVudCk7XG5cbiAgICAgICAgLy9zZXQgYWNjZWxlcmF0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmF4ID0gZy5neDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXkgPSBnLmd5O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBwbGFuZXQsIGRlcGVuZGluZyBvbiBpdHMgbWFzcy5cbiAgICAgKi9cbiAgICByKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3codGhpcy5tIC8gTWF0aC5QSSwgMC41KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm91bmNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBjaGFuZ2UoYm91bmNlID0gZmFsc2UsIG1heFNwZWVkID0gMC44LCB0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHNwZWVkXG4gICAgICAgIHRoaXMuc3ggKz0gdGhpcy5heCAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMuc3kgKz0gdGhpcy5heSAqIHRpbWVTdGVwTXM7XG5cbiAgICAgICAgLy9jaGVjayB2bWF4XG4gICAgICAgIGlmIChtYXhTcGVlZCA+IDApIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgY29uc3QgdiA9IE1hdGguc3FydCh0aGlzLnN4ICogdGhpcy5zeCArIHRoaXMuc3kgKiB0aGlzLnN5KTtcbiAgICAgICAgICAgIGlmICh2ID4gbWF4U3BlZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN4ID0gbWF4U3BlZWQgKiB0aGlzLnN4IC8gdjtcbiAgICAgICAgICAgICAgICB0aGlzLnN5ID0gbWF4U3BlZWQgKiB0aGlzLnN5IC8gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBuZXcgcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBueCA9IHRoaXMueCArIHRoaXMuc3ggKiB0aW1lU3RlcE1zO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IG55ID0gdGhpcy55ICsgdGhpcy5zeSAqIHRpbWVTdGVwTXM7XG5cbiAgICAgICAgLy9oYW5kbGUgcG9zaXRpb24gbGltaXRcbiAgICAgICAgaWYgKGJvdW5jZSkge1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMucigpO1xuICAgICAgICAgICAgY29uc3QgZSA9IDE7XG4gICAgICAgICAgICBpZiAobnggPCByKSB7IG54ID0gcjsgdGhpcy5zeCA9IC10aGlzLnN4ICogZTsgfVxuICAgICAgICAgICAgaWYgKG55IDwgcikgeyBueSA9IHI7IHRoaXMuc3kgPSAtdGhpcy5zeSAqIGU7IH1cbiAgICAgICAgICAgIGlmIChueCA+IHRoaXMudS53IC0gcikgeyBueCA9IHRoaXMudS53IC0gcjsgdGhpcy5zeCA9IC10aGlzLnN4ICogZTsgfVxuICAgICAgICAgICAgaWYgKG55ID4gdGhpcy51LmggLSByKSB7IG55ID0gdGhpcy51LmggLSByOyB0aGlzLnN5ID0gLXRoaXMuc3kgKiBlOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobnggPCAwKSB7IG54ID0gdGhpcy51Lnc7IH1cbiAgICAgICAgICAgIGlmIChueSA8IDApIHsgbnkgPSB0aGlzLnUuaDsgfVxuICAgICAgICAgICAgaWYgKG54ID4gdGhpcy51LncpIHsgbnggPSAwOyB9XG4gICAgICAgICAgICBpZiAobnkgPiB0aGlzLnUuaCkgeyBueSA9IDA7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbW92ZVxuICAgICAgICB0aGlzLnggPSBueDtcbiAgICAgICAgdGhpcy55ID0gbnk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHBsYW5ldFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsbFN0eWxlIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGZpbGxTdHlsZSkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucigpIC8gY3AuZ2V0WmYoKSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuZmlsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgcGxhbmV0IGFjY2VsZXJhdGlvblxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIFxuICAgICAqL1xuICAgIGRpc3BsYXlBY2NlbGVyYXRpb24oY3AsIHN0cm9rZVN0eWxlID0gXCJjeWFuXCIsIGxpbmVXaWR0aCA9IDEsIGZhY3RvciA9IDUwMDApIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5tb3ZlVG8odGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjMi5saW5lVG8odGhpcy54ICsgZmFjdG9yICogdGhpcy5heCwgdGhpcy55ICsgZmFjdG9yICogdGhpcy5heSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5zdHJva2UoKTtcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyByZW1vdmVGcm9tQXJyYXkgfSBmcm9tICcuLi9iYXNlL2xpYic7XG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tICcuLi9iYXNlL1NwYXRpYWxJbmRleCc7XG5pbXBvcnQgeyBQbGFuZXQgfSBmcm9tICcuL1BsYW5ldCc7XG5cbmV4cG9ydCBjbGFzcyBVbml2ZXJzZSB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICB0aGlzLnBzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbWFzcyBvZiB0aGUgdW5pdmVyc2UsIGFzIHRoZSBzdW0gb2YgdGhlIG1hc3Mgb2YgaXRzIHBsYW5ldHMuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBtKCkge1xuICAgICAgICBsZXQgbSA9IDA7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIG0gKz0gcC5tO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEBwYXJhbSB7UGxhbmV0fSBwSWdub3JlIEEgcGxhbmV0IHRvIGlnbm9yZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICAgICAqIEByZXR1cm5zIHt7Z3g6bnVtYmVyLGd5Om51bWJlcn19XG4gICAgICovXG4gICAgZ2V0R3Jhdml0eUZpZWxkKHgsIHksIHBJZ25vcmUgPSB1bmRlZmluZWQsIGV4cG9uZW50ID0gMikge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgZ3ggPSAwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgZ3kgPSAwXG5cbiAgICAgICAgLy9nb3Rocm91Z2ggYWxsIHBsYW5ldHMgaW4gdGhlIHVuaXZlcnNlXG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcykge1xuXG4gICAgICAgICAgICAvL2lnbm9yZSBwbGFuZXRcbiAgICAgICAgICAgIGlmIChwSWdub3JlICYmIHAgPT0gcElnbm9yZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy9jb21wdXRlIGRpc3RhbmNlXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIGxldCBkID0gcC5kUCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChkID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL2NvbXB1dGUgYW5kIGFkZCBjb250cmlidXRpb25cbiAgICAgICAgICAgIGQgPSBkICogTWF0aC5wb3coZCwgZXhwb25lbnQpO1xuICAgICAgICAgICAgZ3ggKz0gMC4wMSAqIChwLnggLSB4KSAqIHAubSAvIGQ7XG4gICAgICAgICAgICBneSArPSAwLjAxICogKHAueSAtIHkpICogcC5tIC8gZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBneDogZ3gsIGd5OiBneSB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGUgdHdvIHBsYW5ldHNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcDFcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcDJcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48UGxhbmV0Pn0gc2luZGV4XG4gICAgICogQHJldHVybnMge1BsYW5ldH1cbiAgICAgKi9cbiAgICBhZ2dyZWdhdGUocDEsIHAyLCBzaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbSA9IHAxLm0gKyBwMi5tO1xuICAgICAgICBjb25zdCBwID0gbmV3IFBsYW5ldChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgKHAxLnggKiBwMS5tICsgcDIueCAqIHAyLm0pIC8gbSxcbiAgICAgICAgICAgIChwMS55ICogcDEubSArIHAyLnkgKiBwMi5tKSAvIG0sXG4gICAgICAgICAgICAocDEuc3ggKiBwMS5tICsgcDIuc3ggKiBwMi5tKSAvIG0sXG4gICAgICAgICAgICAocDEuc3kgKiBwMS5tICsgcDIuc3kgKiBwMi5tKSAvIG1cbiAgICAgICAgKTtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMucHMsIHAxKTtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMucHMsIHAyKTtcblxuICAgICAgICBpZiAoc2luZGV4KSB7XG4gICAgICAgICAgICBzaW5kZXgucmVtb3ZlKHAxKVxuICAgICAgICAgICAgc2luZGV4LnJlbW92ZShwMilcbiAgICAgICAgICAgIHNpbmRleC5pbnNlcnQocClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48UGxhbmV0Pn0gc2luZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpc2lvbkZhY3RvclxuICAgICAqIEByZXR1cm5zIHtBcnJheS48UGxhbmV0Pn1cbiAgICAgKi9cbiAgICBmaW5kQ29sbGlzaW9uKHNpbmRleCwgY29sbGlzaW9uRmFjdG9yID0gMSkge1xuICAgICAgICBmb3IgKGxldCBwaSBvZiB0aGlzLnBzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHcgPSAyICogcGkucigpO1xuICAgICAgICAgICAgY29uc3QgY2FuZCA9IHNpbmRleC5nZXQocGkueCAtIHcsIHBpLnkgLSB3LCBwaS54ICsgdywgcGkueSArIHcpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBwaiBvZiBjYW5kKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocGkgPT0gcGopIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICAgICAgY29uc3QgZDEgPSBwaS5kKHBqKTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBkMiA9IChwaS5yKCkgKyBwai5yKCkpICogY29sbGlzaW9uRmFjdG9yO1xuICAgICAgICAgICAgICAgIGlmIChkMSA+IGQyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BpLCBwal07XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBwbGFuZXRzIHdpdGggcmFuZG9tIHNwZWVkXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBhZGRQbGFuZXRzKG5iID0gMSwgbWkgPSAwLjUsIG1pblNwZWVkID0gMCwgbWF4U3BlZWQgPSAwLjEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFBsYW5ldCh0aGlzLCBtaSwgdGhpcy53ICogTWF0aC5yYW5kb20oKSwgdGhpcy5oICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBwLnNldFJhbmRvbVNwZWVkKG1pblNwZWVkLCBtYXhTcGVlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm91bmNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2bWF4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sbGlzaW9uRmFjdG9yIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0ZXAoYm91bmNlID0gZmFsc2UsIHZtYXggPSAwLjgsIGV4cG9uZW50ID0gMiwgY29sbGlzaW9uRmFjdG9yID0gMSwgdGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9vYnNlcnZhdGlvblxuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBwLm9ic2VydmUoZXhwb25lbnQpO1xuXG4gICAgICAgIC8vYWN0aW9uXG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIHAuY2hhbmdlKGJvdW5jZSwgdm1heCwgdGltZVN0ZXBNcyk7XG5cblxuICAgICAgICAvL2NvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgdGhpcy5kZXRlY3RDb2xsaXNpb25zKGNvbGxpc2lvbkZhY3RvcilcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sbGlzaW9uRmFjdG9yIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGRldGVjdENvbGxpc2lvbnMoY29sbGlzaW9uRmFjdG9yID0gMSkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxQbGFuZXQ+fSAqL1xuICAgICAgICBjb25zdCBzaW5kZXggPSBuZXcgU3BhdGlhbEluZGV4KCk7XG4gICAgICAgIHNpbmRleC5sb2FkKHRoaXMucHMpXG5cbiAgICAgICAgLy9maW5kIGZpcnN0IGNvbGxpc2lvblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICBsZXQgcGFpciA9IHRoaXMuZmluZENvbGxpc2lvbihzaW5kZXgsIGNvbGxpc2lvbkZhY3Rvcik7XG4gICAgICAgIHdoaWxlIChwYWlyICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vYWdncmVnYXRlXG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5hZ2dyZWdhdGUocGFpclswXSwgcGFpclsxXSwgc2luZGV4KVxuXG4gICAgICAgICAgICAvL2ZpbmQgbmV4dCBjb2xsaXNpb25cbiAgICAgICAgICAgIHBhaXIgPSB0aGlzLmZpbmRDb2xsaXNpb24oc2luZGV4LCBjb2xsaXNpb25GYWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gcmFuZG9tIHNwZWVkIHRvIGFsbCBwbGFuZXRzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRSYW5kb21TcGVlZChtaW5TcGVlZCA9IDAsIG1heFNwZWVkID0gMC4xKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIHAuc2V0UmFuZG9tU3BlZWQobWluU3BlZWQsIG1heFNwZWVkKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQbGFuZXR9IFRoZSBsYXJnZXN0IHBsYW5ldCBvZiB0aGUgdW5pdmVyc2UsIHVzdWFsbHkgdGhlIHN0YXIuXG4gICAgICovXG4gICAgZ2V0TGFyZ2VzdFBsYW5ldCgpIHtcbiAgICAgICAgbGV0IHBNID0gbnVsbCwgbU0gPSAwO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBpZiAocC5tID4gbU0pIHsgcE0gPSBwOyBtTSA9IHAubSB9XG4gICAgICAgIHJldHVybiBwTVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBsYXJnZXN0IHBsYW5ldCBhbmQgZXhwbG9kZSBpdC5cbiAgICAgKi9cbiAgICBleHBsb2RlTGFyZ2VzdFBsYW5ldCgpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuZ2V0TGFyZ2VzdFBsYW5ldCgpXG4gICAgICAgIHRoaXMuZXhwbG9kZShwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGxvZGUgYSBwbGFuZXQgaW50byBwaWVjZXNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIFxuICAgICAqL1xuICAgIGV4cGxvZGUocCwgbmIgPSAtMSwgbWluU3BlZWQgPSAwLjgsIG1heFNwZWVkID0gMS41LCByYWQgPSAtMSkge1xuICAgICAgICBpZiAobmIgPD0gMCkgbmIgPSBNYXRoLmZsb29yKHAubSk7XG4gICAgICAgIGlmIChuYiA8PSAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGFuZ2xlU3RlcCA9IDIgKiBNYXRoLlBJIC8gbmI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgLy9jcmVhdGUgcGxhbmV0XG5cbiAgICAgICAgICAgIC8vcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChyYWQgPCAwKSByYWQgPSAyICogcC5yKClcbiAgICAgICAgICAgIGNvbnN0IGQgPSByYWQgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgY29uc3QgYSA9IGkgKiBhbmdsZVN0ZXA7XG4gICAgICAgICAgICBjb25zdCB4ID0gZCAqIE1hdGguY29zKGEpLCB5ID0gZCAqIE1hdGguc2luKGEpO1xuXG4gICAgICAgICAgICAvL3NwZWVkXG4gICAgICAgICAgICBjb25zdCBzcGVlZCA9IG1pblNwZWVkICsgTWF0aC5yYW5kb20oKSAqIChtYXhTcGVlZCAtIG1pblNwZWVkKTtcbiAgICAgICAgICAgIGNvbnN0IGFTID0gYSArIDIgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyICogTWF0aC5QSSAvIDM7XG4gICAgICAgICAgICBjb25zdCBzeCA9IHNwZWVkICogTWF0aC5jb3MoYVMpLCBzeSA9IHNwZWVkICogTWF0aC5zaW4oYVMpO1xuXG4gICAgICAgICAgICBuZXcgUGxhbmV0KHRoaXMsIHAubSAvIG5iLCBwLnggKyB4LCBwLnkgKyB5LCBwLnN4ICsgc3gsIHAuc3kgKyBzeSlcbiAgICAgICAgfVxuICAgICAgICAvL3JlbW92ZSBwIGZyb20gdW5pdmVyc2VcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMucHMsIHApO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFVuaXZlcnNlIH0gZnJvbSAnLi9Vbml2ZXJzZSc7XG5pbXBvcnQgeyBQbGFuZXQgfSBmcm9tICcuL1BsYW5ldCc7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5cbi8qKiAgKi9cbmNsYXNzIFBsYW5ldFNpbXVsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuICAgICAgICBpZiAoY2FudmFzID09IG51bGwpIHRocm93IFwiTm8gY2FudmFzIFwiICsgb3B0cy5jYW52YXNJZDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gb3B0cy53IHx8IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm1heFNwZWVkID0gb3B0cy5tYXhTcGVlZCB8fCAwLjg7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5ib3VuY2UgPSBvcHRzLmJvdW5jZSB8fCBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5leHBvbmVudCA9IG9wdHMuZXhwb25lbnQgfHwgMjtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuY29sbGlzaW9uRmFjdG9yID0gb3B0cy5jb2xsaXNpb25GYWN0b3IgfHwgMTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd1BsYW5ldEFjY2VsZXJhdGlvbiA9IGZhbHNlXG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLnNob3dGaWVsZCA9IHVuZGVmaW5lZFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5maWVsZFJlcyA9IDIwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmZpZWxkRmFjdG9yID0gMTAwMFxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5maWVsZFN0cm9rZVN0eWxlID0gXCIjOTliYmZmXCI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudGFpbGluZ3MgPSBvcHRzLnRhaWxpbmdzIHx8IDAuMTtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgLy9jbGVhciwgd2l0aCB0cmFuc3BhcmVuY3lcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmdiYSgwLDAsMCxcIiArIHRoLnRhaWxpbmdzICsgXCIpXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIC8vYzIuZmlsbFJlY3QoLTFlMjAsIC0xZTIwLCAyZTIwLCAyZTIwKTsgLy90b2RvXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBncmF2aXR5IGZpZWxkXG4gICAgICAgICAgICBpZiAodGguc2hvd0ZpZWxkID09PSBcImZcIilcbiAgICAgICAgICAgICAgICB0aC5kaXNwbGF5R3Jhdml0eUZpZWxkKHRoaXMsIHRydWUpXG4gICAgICAgICAgICBlbHNlIGlmICh0aC5zaG93RmllbGQgPT09IFwiaVwiKVxuICAgICAgICAgICAgICAgIHRoLmRpc3BsYXlHcmF2aXR5RmllbGQodGhpcywgZmFsc2UpXG5cblxuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgcGxhbmV0c1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aC51bmkucHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudG9EcmF3KHApKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwLm0gLyB0aC51bmkubSgpO1xuICAgICAgICAgICAgICAgIHAuZGlzcGxheSh0aGlzLCBcInJnYigyNTUsMjU1LFwiICsgTWF0aC5mbG9vcigyNTUgKiAoMSAtIHQpKSArIFwiKVwiKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgcGxhbmV0cyBhY2NlbGVyYXRpb25cbiAgICAgICAgICAgIGlmICh0aC5zaG93UGxhbmV0QWNjZWxlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aC51bmkucHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhwKSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgcC5kaXNwbGF5QWNjZWxlcmF0aW9uKHRoaXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7VW5pdmVyc2V9ICovXG4gICAgICAgIHRoaXMudW5pID0gbmV3IFVuaXZlcnNlKHRoaXMudywgdGhpcy5oKVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmllbGQgXG4gICAgICovXG4gICAgZGlzcGxheUdyYXZpdHlGaWVsZChjcCwgZmllbGQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZmllbGRSZXNcbiAgICAgICAgY29uc3QgZiA9IHRoaXMuZmllbGRGYWN0b3JcbiAgICAgICAgY29uc3QgZl8gPSBmaWVsZCA/IDAuMyAqIHJlcyA6IDAuNiAqIHJlcztcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSB0aGlzLmZpZWxkU3Ryb2tlU3R5bGVcbiAgICAgICAgZm9yIChsZXQgeCA9IHJlcyAqIDAuNTsgeCA8IHRoaXMudzsgeCArPSByZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHhHID0gY3AucGl4VG9HZW9YKHgpO1xuICAgICAgICAgICAgaWYgKHhHID4gdGhpcy51bmkudyB8fCB4RyA8IDApIGNvbnRpbnVlXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gcmVzIC8gMjsgeSA8IHRoaXMuaDsgeSArPSByZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5RyA9IGNwLnBpeFRvR2VvWSh5KTtcbiAgICAgICAgICAgICAgICBpZiAoeUcgPiB0aGlzLnVuaS5oIHx8IHlHIDwgMCkgY29udGludWVcbiAgICAgICAgICAgICAgICAvL2dldCBncmF2aXR5IGZpZWxkXG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pLmdldEdyYXZpdHlGaWVsZCh4RywgeUcsIHVuZGVmaW5lZCwgdGhpcy5leHBvbmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ18gPSBNYXRoLmh5cG90KGcuZ3gsIGcuZ3kpXG5cbiAgICAgICAgICAgICAgICBjMi5saW5lV2lkdGggPSBNYXRoLm1pbihmICogZ18sIDAuMyAqIHJlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHggPSBmXyAqIGcuZ3ggLyBnXywgZHkgPSBmXyAqIGcuZ3kgLyBnX1xuXG4gICAgICAgICAgICAgICAgLy9kcmF3XG4gICAgICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZ3Jhdml0eSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBjMi5tb3ZlVG8oeCAtIGR4LCB5ICsgZHkpO1xuICAgICAgICAgICAgICAgICAgICBjMi5saW5lVG8oeCArIGR4LCB5IC0gZHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaXNvcG90ZW50aWFsIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgIGMyLm1vdmVUbyh4ICsgZHksIHkgKyBkeCk7XG4gICAgICAgICAgICAgICAgICAgIGMyLmxpbmVUbyh4IC0gZHksIHkgLSBkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHdpdGggcmFuZG9tIHBsYW5ldHNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdFJhbmRvbShuYiA9IDEwMDAsIG1pID0gMC41LCBtaW5TcGVlZCA9IDAsIG1heFNwZWVkID0gMC4xKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFBsYW5ldD59ICovXG4gICAgICAgIHRoaXMudW5pLnBzID0gW107XG4gICAgICAgIHRoaXMudW5pLmFkZFBsYW5ldHMobmIsIG1pLCBtaW5TcGVlZCwgbWF4U3BlZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHdpdGggYmlnIGJhbmcgc2V0dXBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBpbml0QmlnQmFuZyhuYiA9IDEwMDAsIG1pID0gMSwgbWluU3BlZWQgPSAwLjM1LCBtYXhTcGVlZCA9IDAuNywgcmFkID0gMTAwKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFBsYW5ldD59ICovXG4gICAgICAgIHRoaXMudW5pLnBzID0gW107XG4gICAgICAgIC8vY3JlYXRlIGJpZyBwbGFuZXQgaW4gdGhlIG1pZGRsZVxuICAgICAgICBjb25zdCBjeCA9IHRoaXMudyAqIDAuNSwgY3kgPSB0aGlzLmggKiAwLjU7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUGxhbmV0KHRoaXMudW5pLCBuYiAqIG1pLCBjeCwgY3ksIDAsIDApO1xuICAgICAgICAvL2V4cGxvZGUgaXRcbiAgICAgICAgdGhpcy51bmkuZXhwbG9kZShwLCBuYiwgbWluU3BlZWQsIG1heFNwZWVkLCByYWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHNpbXVsYXRpb25cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmJJdGVyYXRpb25zIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0YXJ0KHRpbWVTdGVwTXMgPSAxMCwgbmJJdGVyYXRpb25zID0gLTEpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCB0ID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdC51bmkuc3RlcCh0LmJvdW5jZSwgdC5tYXhTcGVlZCwgdC5leHBvbmVudCwgdC5jb2xsaXNpb25GYWN0b3IsIHRpbWVTdGVwTXMpO1xuICAgICAgICAgICAgdC5jcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYkl0ZXJhdGlvbnMgPiAwICYmIGkrKyA+IG5iSXRlcmF0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGVuZ2luZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvL3N0b3BcbiAgICBzdG9wKCkge1xuICAgICAgICAvL1RPRE9cbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYW5ldHMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgUGxhbmV0U2ltdWxhdGlvbihvcHRzKVxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IExhbmQgfSBmcm9tIFwiLi9MYW5kXCJcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gXCIuLi9iYXNlL0dlb0NhbnZhc1wiXG5pbXBvcnQgeyBBZ2VudFBvaW50IH0gZnJvbSBcIi4uL2Jhc2UvQWdlbnRQb2ludFwiXG5cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hbCBleHRlbmRzIEFnZW50UG9pbnQge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgXG4gICAgICogQHBhcmFtIHtMYW5kfSBsIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGwsIHggPSAwLCB5ID0gMCkge1xuXG4gICAgICAgIHN1cGVyKHgsIHkpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKiBAdHlwZSB7TGFuZH0gKi9cbiAgICAgICAgdGhpcy5sID0gbDtcblxuICAgICAgICAvL3Bvc2l0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4IDwgMCA/IDAgOiB4ID4gbC53ID8gbC53IDogeFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geSA8IDAgPyAwIDogeSA+IGwuaCA/IGwuaCA6IHlcblxuICAgICAgICAvL3RoZSBvdGhlciBhbmltYWxzIGFyb3VuZFxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLnByZWRhdG9ycyA9IFtdXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMucHJleXMgPSBbXVxuXG4gICAgICAgIC8vYWRkIHRvIHRoZSBzcGF0aWFsIGluZGV4XG4gICAgICAgIGwuZ3JpZC5pbnNlcnQodGhpcyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgbW92ZSh0aW1lU3RlcE1zID0gMTApIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMubFxuICAgICAgICBsLmdyaWQucmVtb3ZlKHRoaXMpO1xuXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCByID0gMC4wMSAqIE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgdGhpcy5zeCArPSByICogTWF0aC5jb3MoYW5nbGUpICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy5zeCA9IHRoaXMuc3ggPiBsLlZfTUFYID8gbC5WX01BWCA6IHRoaXMuc3ggPCAtbC5WX01BWCA/IC1sLlZfTUFYIDogdGhpcy5zeFxuXG4gICAgICAgIHRoaXMuc3kgKz0gciAqIE1hdGguc2luKGFuZ2xlKSAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMuc3kgPSB0aGlzLnN5ID4gbC5WX01BWCA/IGwuVl9NQVggOiB0aGlzLnN5IDwgLWwuVl9NQVggPyAtbC5WX01BWCA6IHRoaXMuc3lcblxuICAgICAgICB0aGlzLnggKz0gdGhpcy5zeCAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueCA8IDAgPyBsLncgOiB0aGlzLnggPiBsLncgPyAwIDogdGhpcy54XG5cbiAgICAgICAgdGhpcy55ICs9IHRoaXMuc3kgKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnkgPCAwID8gbC5oIDogdGhpcy55ID4gbC5oID8gMCA6IHRoaXMueVxuXG4gICAgICAgIGwuZ3JpZC5pbnNlcnQodGhpcyk7XG4gICAgfVxuXG5cbiAgICAvKiogT2JzZXJ2ZSAqL1xuICAgIG9ic2VydmUoKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxcblxuICAgICAgICAvL2dldCBhbmltYWxzIGFyb3VuZFxuICAgICAgICBjb25zdCBhcyA9IGwuZ3JpZC5nZXQodGhpcy54IC0gbC5kLCB0aGlzLnkgLSBsLmQsIHRoaXMueCArIGwuZCwgdGhpcy55ICsgbC5kKTtcblxuICAgICAgICB0aGlzLnByZXlzID0gW107XG4gICAgICAgIHRoaXMucHJlZGF0b3JzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgYSBvZiBhcykge1xuICAgICAgICAgICAgaWYgKGEgPT0gdGhpcykgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5kKGEpID4gbC5kKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChhLnR5cGUgPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXlzLnB1c2goYSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVkYXRvcnMucHVzaChhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcmV0dXJucyB7QW5pbWFsfSAqL1xuICAgIG1ha2VDaGlsZCgpIHtcbiAgICAgICAgLy9kbyBiZXR0ZXI6IG1ha2UgY2hpbGQgYXJvdW5kXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWFsKHRoaXMudHlwZSwgdGhpcy5sLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgYW5pbWFsXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgXG4gICAgICovXG4gICAgZGlzcGxheShjcCwgZmlsbFN0eWxlID0gXCJibHVlXCIsIHNpemUgPSAyKSB7XG4gICAgICAgIGNwLmN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGNwLmN0eC5maWxsUmVjdCh0aGlzLngsIHRoaXMueSwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgIC8qYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLmFyYyhhLngsIGEueSwgMC41LCAwLCAyKk1hdGguUEkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuZmlsbCgpOyovXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgcmVtb3ZlRnJvbUFycmF5UyB9IGZyb20gJy4uL2Jhc2UvbGliJztcbmltcG9ydCB7QW5pbWFsfSBmcm9tIFwiLi9BbmltYWxcIlxuXG5leHBvcnQgY2xhc3MgTGFuZCB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG5cbiAgICAgICAgLy90aGUgbWF4IHNwZWVkXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLlZfTUFYID0gMC4xXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucCA9IDAuMDIgLy9wcmVkYXRvciBkZWF0aCBwcm9iYWJpbGl0eVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5xID0gMC4xIC8vcHJleSByZXByb2R1Y3Rpb24gcHJvYmFiaWxpdHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuciA9IDAuNSAvL2VhdGVuIHByZXkgdHJhbnNmb3JtYXRpb24gcHJvYmFiaWxpdHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubmIgPSAzIC8vbmVpZ2hib3JzIG51bWJlclxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBoXG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5wcmVkYXRvcnMgPSBbXVxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLnByZXlzID0gW11cblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5kID0gMTBcbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBTcGF0aWFsSW5kZXgoKTtcblxuICAgICAgICAvKmludFtdW10gaGlzdG87XG4gICAgICAgIGludCBpbmRleD0wO1xuICAgICAgICB0aGlzLmMyQ2hhcnQ9YzJDaGFydDtcbiAgICAgICAgdGhpcy5oQ2hhcnQ9aENoYXJ0O1xuICAgICAgICB0aGlzLmhpc3RvPW5ldyBpbnRbd0NoYXJ0XVtdO1xuICAgICAgICBmb3IoaW50IGk9MDtpPHdDaGFydDtpKyspXG4gICAgICAgICAgICBoaXN0b1tpXT1uZXcgaW50W117MCwwfTsqL1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgc3RlcCh0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL29ic2VydmVcbiAgICAgICAgZm9yIChsZXQgYSBvZiB0aGlzLnByZXlzKSBhLm9ic2VydmUoKTtcbiAgICAgICAgZm9yIChsZXQgYSBvZiB0aGlzLnByZWRhdG9ycykgYS5vYnNlcnZlKCk7XG5cbiAgICAgICAgY29uc3QgcHJleXNUb0Jvcm4gPSBbXVxuICAgICAgICBjb25zdCBwcmV5c1RvRGllID0gW11cbiAgICAgICAgY29uc3QgcHJlZHNUb0Jvcm4gPSBbXVxuICAgICAgICBjb25zdCBwcmVkc1RvRGllID0gW11cblxuICAgICAgICAvL3ByZXlcbiAgICAgICAgZm9yIChsZXQgcHJleSBvZiB0aGlzLnByZXlzKSB7XG4gICAgICAgICAgICAvL3JlcHJvZHVjdGlvbiBpZiBubyBwcmVkYXRvciBhcm91bmRcbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gdGhpcy5xKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwcmV5LnByZWRhdG9ycy5sZW5ndGggIT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocHJleS5wcmV5cy5sZW5ndGggPj0gdGhpcy5uYikgY29udGludWU7XG4gICAgICAgICAgICBwcmV5c1RvQm9ybi5wdXNoKHByZXkubWFrZUNoaWxkKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9wcmVkYXRvclxuICAgICAgICBmb3IgKGxldCBwcmVkIG9mIHRoaXMucHJlZGF0b3JzKSB7XG4gICAgICAgICAgICAvL25vIHByZXkgYXJvdW5kOiBwcmVkYXRvciBkaWVzIHdpdGggcHJvYmFiaWxpdHkgcFxuICAgICAgICAgICAgaWYgKHByZWQucHJleXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHRoaXMucCkgcHJlZHNUb0RpZS5wdXNoKHByZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9wcmV5IGFyb3VuZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9lYXQgcHJleVxuICAgICAgICAgICAgICAgIC8vY2hvb3NlIHJhbmRvbWx5XG4gICAgICAgICAgICAgICAgY29uc3QgcHJleVRvRWF0ID0gcHJlZC5wcmV5c1tNYXRoLmZsb29yKHByZWQucHJleXMubGVuZ3RoICogTWF0aC5yYW5kb20oKSldO1xuICAgICAgICAgICAgICAgIHByZXlzVG9EaWUucHVzaChwcmV5VG9FYXQpO1xuXG4gICAgICAgICAgICAgICAgLy9wcmVkYXRvciByZXByb2R1Y3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IHRoaXMucikgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHByZWQucHJlZGF0b3JzLmxlbmd0aCA+PSB0aGlzLm5iKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBwcmVkc1RvQm9ybi5wdXNoKHByZWQubWFrZUNoaWxkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV5cy5wdXNoKC4uLnByZXlzVG9Cb3JuKTtcbiAgICAgICAgdGhpcy5wcmVkYXRvcnMucHVzaCguLi5wcmVkc1RvQm9ybik7XG5cbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5Uyh0aGlzLnByZXlzLCBwcmV5c1RvRGllLCBmYWxzZSlcbiAgICAgICAgZm9yIChsZXQgYSBvZiBwcmV5c1RvRGllKSB0aGlzLmdyaWQucmVtb3ZlKGEpO1xuICAgICAgICByZW1vdmVGcm9tQXJyYXlTKHRoaXMucHJlZGF0b3JzLCBwcmVkc1RvRGllLCBmYWxzZSlcbiAgICAgICAgZm9yIChsZXQgYSBvZiBwcmVkc1RvRGllKSB0aGlzLmdyaWQucmVtb3ZlKGEpO1xuXG4gICAgICAgIC8vbW92ZVxuICAgICAgICBmb3IgKGxldCBhIG9mIHRoaXMucHJleXMpXG4gICAgICAgICAgICBhLm1vdmUodGltZVN0ZXBNcyk7XG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5wcmVkYXRvcnMpXG4gICAgICAgICAgICBhLm1vdmUodGltZVN0ZXBNcyk7XG5cbiAgICAgICAgLyovaGlzdG9cbiAgICAgICAgaGlzdG9baW5kZXhdID0gbmV3IGludFtdeyBwcmV5cy5zaXplKCksIHByZWRhdG9ycy5zaXplKCkgfTtcbiAgICAgICAgaWYgKGluZGV4ID09IGhpc3RvLmxlbmd0aCAtIDEpIGluZGV4ID0gMDtcbiAgICAgICAgZWxzZSBpbmRleCsrOyovXG5cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgTGFuZCB9IGZyb20gJy4vTGFuZCc7XG5pbXBvcnQgeyBBbmltYWwgfSBmcm9tICcuL0FuaW1hbCc7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5cbi8qKiAqL1xuY2xhc3MgUHJleVByZWRhdG9yU2ltdWxhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICAvL3RyYW5zcGFyZW5jeVxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmdiYSgyNTUsMjU1LDI1NSwwLjUpXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcblxuICAgICAgICAgICAgLy9kaXNwbGF5IGFuaW1hbHNcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGZvciAobGV0IGEgb2YgdGgubGFuZC5wcmV5cylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoYSkpXG4gICAgICAgICAgICAgICAgICAgIGEuZGlzcGxheSh0aGlzLCBcImJsdWVcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBhIG9mIHRoLmxhbmQucHJlZGF0b3JzKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhhKSlcbiAgICAgICAgICAgICAgICAgICAgYS5kaXNwbGF5KHRoaXMsIFwicmVkXCIpO1xuXG4gICAgICAgICAgICAvKi9sYWJlbFxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJsaWdodGdyYXlcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIDY1LCAxMyk7XG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICBjMi5maWxsVGV4dChwcmV5cy5sZW5ndGggKyBcIi9cIiArIHByZWRhdG9ycy5sZW5ndGgsIDIsIDEwKTsqL1xuXG4gICAgICAgICAgICAvL2NoYXJ0XG4gICAgICAgICAgICAvL2MyQ2hhcnQuc2V0RmlsbFN0eWxlKGJhY2tDb2xvcjIpO1xuICAgICAgICAgICAgLy9jMkNoYXJ0LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICAgICAgICAvL2RvdWJsZSBtYXggPSBnZXRNYXhIaXN0bygpO1xuICAgICAgICAgICAgLypwdWJsaWMgaW50IGdldE1heEhpc3RvKCkge1xuICAgICAgICAgICAgICAgIGludCBtYXg9MDtcbiAgICAgICAgICAgICAgICBmb3IoaW50IGk9MDtpPGhpc3RvLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgICAgICAgICBpZihoaXN0b1tpXVswXT5tYXgpIG1heD1oaXN0b1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGlzdG9baV1bMV0+bWF4KSBtYXg9aGlzdG9baV1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VibGUgaDEsIGgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaGlzdG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDEgPSBoQ2hhcnQgKiBoaXN0b1tpXVswXSAvIG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSBoQ2hhcnQgKiBoaXN0b1tpXVsxXSAvIG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5zZXRGaWxsU3R5bGUocHJleUNvbG9yMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuZmlsbFJlY3QoaSwgaENoYXJ0IC0gaDEsIDEsIGgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5zZXRGaWxsU3R5bGUocHJlZGF0b3JDb2xvcjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LmZpbGxSZWN0KGksIGhDaGFydCAtIGgyLCAxLCBoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5zZXRGaWxsU3R5bGUoQ3NzQ29sb3IubWFrZSgyNTUsIDI1NSwgMjU1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LmZpbGxSZWN0KGluZGV4LCAwLCAxLCBoQ2hhcnQpO1xuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtMYW5kfSAqL1xuICAgICAgICB0aGlzLmxhbmQgPSBuZXcgTGFuZCh0aGlzLncsIHRoaXMuaClcblxuICAgIH1cblxuXG5cbiAgICAvL1RPRE8gdGVzdCBpbml0IGluIGEgYnViYmxlID9cbiAgICAvL1RPRE8gdXNlIGRlbnNpdHkgYXMgaW5wdXQgcGFyYW1ldGVycyBpbnN0ZWFkIG9mIG5iXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJleURlbnNpdHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByZWRhdG9yRGVuc2l0eSBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBpbml0UmFuZG9tKHByZXlEZW5zaXR5ID0gMC4wMDMsIHByZWRhdG9yRGVuc2l0eSA9IDAuMDAzKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxhbmRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV5RGVuc2l0eSAqIGwudyAqIGwuaDsgaSsrKVxuICAgICAgICAgICAgbC5wcmV5cy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBBbmltYWwoMCwgbCwgbC53ICogTWF0aC5yYW5kb20oKSwgbC5oICogTWF0aC5yYW5kb20oKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZGF0b3JEZW5zaXR5ICogbC53ICogbC5oOyBpKyspXG4gICAgICAgICAgICBsLnByZWRhdG9ycy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBBbmltYWwoMSwgbCwgbC53ICogTWF0aC5yYW5kb20oKSwgbC5oICogTWF0aC5yYW5kb20oKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubGFuZC5zdGVwKHRpbWVTdGVwTXMpO1xuICAgICAgICAgICAgdC5jcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYkl0ZXJhdGlvbnMgPiAwICYmIGkrKyA+IG5iSXRlcmF0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGVuZ2luZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICovXG5leHBvcnQgY29uc3QgcHJleVByZWRhdG9yID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByZXlQcmVkYXRvclNpbXVsYXRpb24ob3B0cylcbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSBcIi4uL2Jhc2UvU3BhdGlhbEluZGV4XCJcblxuZXhwb3J0IGNsYXNzIEJ1aWxkaW5nIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYSBUaGUgYXJlYVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIGFyZWEpIHtcblxuICAgICAgICAvL3NldCBwb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5hcmVhID0gYXJlYVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHsgbnVtYmVyIH1cbiAgICAgKi9cbiAgICByKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuYXJlYSAvIE1hdGguUEkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCdWlsZGluZ30gYiBcbiAgICAgKi9cbiAgICBvdmVybGFwKGIpIHtcbiAgICAgICAgY29uc3QgZDEgPSBiLnIoKSArIHRoaXMucigpXG4gICAgICAgIGNvbnN0IGQyID0gTWF0aC5oeXBvdCgoYi54IC0gdGhpcy54KSwgKGIueSAtIHRoaXMueSkpO1xuICAgICAgICByZXR1cm4gZDIgPCBkMVxuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48QnVpbGRpbmc+fSBzaW5kZXggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNEaXN0YW5jZSBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjaGVja0NvbGxpc2lvbihzaW5kZXgsIHNEaXN0YW5jZSkge1xuXG4gICAgICAgIC8vZ2V0IGJ1aWxkaW5ncyBhcm91bmQgdXNpbmcgc3BhdGlhbCBpbmRleFxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxCdWlsZGluZz59ICovXG4gICAgICAgIGNvbnN0IHNzID0gc2luZGV4LmdldCh0aGlzLnggLSBzRGlzdGFuY2UsIHRoaXMueSAtIHNEaXN0YW5jZSwgdGhpcy54ICsgc0Rpc3RhbmNlLCB0aGlzLnkgKyBzRGlzdGFuY2UpO1xuXG4gICAgICAgIGZvciAobGV0IGIgb2Ygc3MpIHtcbiAgICAgICAgICAgIGlmIChiID09IHRoaXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxhcChiKSkgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsbFN0eWxlIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJva2VTdHlsZSBcbiAgICAgKi9cbiAgICBkaXNwbGF5KGNwLCBmaWxsU3R5bGUsIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucigpLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5maWxsKCk7XG4gICAgICAgIGMyLnN0cm9rZSgpO1xuICAgIH1cblxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgQnVpbGRpbmcgfSBmcm9tICcuL0J1aWxkaW5nJztcbmltcG9ydCB7IFJvYWROZXR3b3JrIH0gZnJvbSAnLi9Sb2FkTmV0d29yayc7XG5cbmV4cG9ydCBjbGFzcyBNYXAge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHcsIGgpIHtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QnVpbGRpbmc+fSAqL1xuICAgICAgICB0aGlzLmJzID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxCdWlsZGluZz59ICovXG4gICAgICAgIHRoaXMuYnVJbmRleCA9IG5ldyBTcGF0aWFsSW5kZXgoKTtcblxuICAgICAgICAvKiogQHR5cGUge1JvYWROZXR3b3JrfSAqL1xuICAgICAgICB0aGlzLnJuID0gbmV3IFJvYWROZXR3b3JrKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgLy90ZXN0IHR1cmZcbiAgICAgICAgICAgICAgICB2YXIgbHMgPSB0dXJmLmxpbmVTdHJpbmcoW1sxMDAwLCAwXSwgWzEwMDAsIDEwMDBdXSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobHMpXG4gICAgICAgICAgICAgICAgLy92YXIgcHQgPSB0dXJmLnBvaW50KFsxMDAwLCAxMDAwXSk7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmYgPSB0dXJmLmJ1ZmZlcihscywgMTAsICdkZWdyZWVzJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYnVmZilcbiAgICAgICAgKi9cblxuICAgICAgICAvL3Rlc3QganN0c1xuICAgICAgICAvL2h0dHBzOi8vYmpvcm5oYXJydGVsbC5naXRodWIuaW8vanN0cy9cbiAgICAgICAgLyp2YXIgcmVhZGVyID0gbmV3IGpzdHMuaW8uV0tUUmVhZGVyKClcbiAgICAgICAgdmFyIGEgPSByZWFkZXIucmVhZCgnUE9JTlQgKC0yMCAwKScpXG4gICAgICAgIGNvbnNvbGUubG9nKHJlYWRlcilcbiAgICAgICAgY29uc29sZS5sb2coYSlcbiAgICAgICAgYSA9IGEuYnVmZmVyKDQwKVxuICAgICAgICBjb25zb2xlLmxvZyhhKVxuICAgICAgICB2YXIgdyA9IG5ldyBqc3RzLmlvLldLVFdyaXRlcigpXG4gICAgICAgIGNvbnNvbGUubG9nKHcud3JpdGUoYSkpKi9cbiAgICB9XG5cbiAgICAvKiogKi9cbiAgICBhZGRCdWlsZGluZygpIHtcblxuICAgICAgICAvL2NvbXB1dGUgY2FuZGlkYXRlIGxvY2F0aW9uLCBzaXplIGFuZCB0eXBlIGZvciBuZXh0IGJ1aWxkaW5nXG4gICAgICAgIC8vVE9ETyBsb3cgbG9jYWwgY29uZ2VzdGlvbiBBTkQgZ28gdG8gaGlnaCBkZW5zaXR5ICh3aXRoIGdvb2QgYWNjZXNzIHRvIG90aGVyIHN0dWZmKVxuXG4gICAgICAgIC8vbWFrZSByYW5kb20gYnVpbGRpbmdcbiAgICAgICAgY29uc3QgbWFrZVJhbmRvbUJ1aWxkaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMudyAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5oICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSA0MCArIDIwMCAqIE1hdGgucmFuZG9tKClcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVpbGRpbmcoeCwgeSwgYXJlYSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETyBzaG91bGQgbm90IG92ZXJsYXAgd2l0aCBvdGhlciBlbnRpdGllcyAocm9hZHMsIGJ1aWxkaW5nKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBjb25zdCBzRGlzdGFuY2UgPSAxMDA7XG4gICAgICAgIC8qKiBAdHlwZSB7QnVpbGRpbmd9ICovXG4gICAgICAgIGxldCBidSA9IG1ha2VSYW5kb21CdWlsZGluZygpO1xuICAgICAgICB3aGlsZSAoYnUuY2hlY2tDb2xsaXNpb24odGhpcy5idUluZGV4LCBzRGlzdGFuY2UpKSB7XG4gICAgICAgICAgICBidSA9IG1ha2VSYW5kb21CdWlsZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hZGQgYnVpbGRpbmdcbiAgICAgICAgdGhpcy5icy5wdXNoKGJ1KTtcbiAgICAgICAgdGhpcy5idUluZGV4LmxvYWQoW2J1XSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGVwKCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBidWlsZGluZyBuZWVkXG4gICAgICAgIGNvbnN0IGJ1TmVlZCA9IDEwO1xuXG4gICAgICAgIC8vdXJiYW5pc2VcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidU5lZWQ7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRCdWlsZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9leHRlbmQgcm9hZCBuZXR3b3JrXG4gICAgICAgIC8vVE9ET1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcblxuZXhwb3J0IGNsYXNzIFJvYWQge1xuXG4gICAgY29uc3RydWN0b3IoZ2VvbSkge1xuXG4gICAgICAgIHRoaXMuZ2VvbSA9IGdlb21cblxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFJvYWQgfSBmcm9tIFwiLi9Sb2FkXCJcbmltcG9ydCBqc3RzIGZyb20gJ2pzdHMnO1xuXG5leHBvcnQgY2xhc3MgUm9hZE5ldHdvcmsge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48Um9hZD59ICovXG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBbXVxuXG5cbiAgICAgICAgLy9hZGQgdGVzdCByb2FkXG4gICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0c1xuICAgICAgICAvL2h0dHA6Ly9iam9ybmhhcnJ0ZWxsLmdpdGh1Yi5pby9qc3RzL1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IGpzdHMuaW8uV0tUUmVhZGVyKClcbiAgICAgICAgdmFyIGcgPSByZWFkZXIucmVhZCgnTElORVNUUklORyAoMzAgMTAsIDEwIDMwMCwgNDAwIDQwKScpXG4gICAgICAgIHRoaXMuc2VjdGlvbnMucHVzaChuZXcgUm9hZChnKSk7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuaW1wb3J0IHsgTWFwIH0gZnJvbSBcIi4vTWFwXCI7XG5cbi8qKiAgKi9cbmNsYXNzIFVyYmFuU2ltdWxhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG4gICAgICAgIGlmIChjYW52YXMgPT0gbnVsbCkgdGhyb3cgXCJObyBjYW52YXMgXCIgKyBvcHRzLmNhbnZhc0lkO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIC8vY2xlYXJcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuXG4gICAgICAgICAgICB0aGlzLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBidWlsZGluZ3NcbiAgICAgICAgICAgIGZvciAobGV0IGIgb2YgdGgubWFwLmJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhiKSkgY29udGludWVcbiAgICAgICAgICAgICAgICBiLmRpc3BsYXkodGhpcywgXCJsaWdodGdyYXlcIiwgXCJibGFja1wiLCAyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7TWFwfSAqL1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAodGhpcy53LCB0aGlzLmgpXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBzaW11bGF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubWFwLnN0ZXAoKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9zdG9wXG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy9UT0RPXG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCB1cmJhbiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBVcmJhblNpbXVsYXRpb24ob3B0cylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=