(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vectag"] = factory();
	else
		root["vectag"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/index.js ***!
  \********************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: radians, degrees */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "./node_modules/d3-dispatch/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-dispatch/src/index.js ***!
  \***********************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassive"])
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view)
      .on("mousemove.drag", mousemoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"])
      .on("mouseup.drag", mouseupped, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"]);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(event.view, mousemoving);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"]("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-drag/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/index.js ***!
  \*******************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _drag_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });





/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nonpassive, nonpassivecapture, nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassive", function() { return nonpassive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassivecapture", function() { return nonpassivecapture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-(--t)) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-t) * Math.sin((s - t) / p)
        : 2 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


function expIn(t) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - +t);
}

function expOut(t) {
  return 1 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - t) : 2 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t - 1)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/index.js ***!
  \*******************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _linear_js__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _cubic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic.js */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _poly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./poly.js */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _sin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sin.js */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _exp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exp.js */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circle.js */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _bounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bounce.js */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _back_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./back.js */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _elastic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elastic.js */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });






















/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
const linear = t => +t;


/***/ }),

/***/ "./node_modules/d3-ease/src/math.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/math.js ***!
  \******************************************/
/*! exports provided: tpmt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tpmt", function() { return tpmt; });
// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default, genericArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genericArray", function() { return genericArray; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return (Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_1__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/discrete.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/discrete.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hue.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hue.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["hue"])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/index.js ***!
  \**************************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateNumberArray, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _value_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _array_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _date_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "./node_modules/d3-interpolate/src/discrete.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return _discrete_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "./node_modules/d3-interpolate/src/hue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return _hue_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _number_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _object_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _round_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _string_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformSvg"]; });

/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasisClosed"]; });

/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["hslLong"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["hclLong"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["cubehelixLong"]; });

/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _piecewise_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _quantize_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });
























/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/*! exports provided: default, isNumberArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumberArray", function() { return isNumberArray; });
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"] : Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_6__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_8__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__["genericArray"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ __webpack_exports__["default"] = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return array; });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return Object(_select_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/index.js ***!
  \************************************************/
/*! exports provided: create, creator, local, matcher, namespace, namespaces, pointer, pointers, select, selectAll, selection, selector, selectorAll, style, window */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create.js */ "./node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _creator_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local.js */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _local_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _namespace_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _namespaces_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointer", function() { return _pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _pointers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pointers.js */ "./node_modules/d3-selection/src/pointers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointers", function() { return _pointers_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _select_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _selectAll_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _selection_index_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector.js */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _selector_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _selection_style_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _selection_style_js__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./window.js */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _window_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });


















/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default, childMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "childMatcher", function() { return childMatcher; });
/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
});


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(event, node) {
  event = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointers.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/pointers.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(events, node) {
  if (events.target) { // i.e., instanceof Event, not TouchList or iterable
    events = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(events);
    if (node === undefined) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, event => Object(_pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event, node));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ __webpack_exports__["default"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return !this.node();
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function*() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(lower);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Array.from(this);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(raise);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(remove);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = Object(_selectorAll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(update) {
  return new Array(update.length);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),

/***/ "./node_modules/d3-timer/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/index.js ***!
  \********************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timeout.js */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _timeout_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _interval_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });








/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? Object(_timer_js__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"];
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return this.each(function() {
    Object(_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]
      : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");



var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["default"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        string1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["set"])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_3__["tweenValue"])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(_tween_js__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity, ZoomTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["Transform"]; });





/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved(event) {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(event.view, g.moved);
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
});


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/jsts/dist/jsts.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * @license
 */
!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class n extends Error{constructor(t){super(t),this.name=Object.keys({Exception:n})[0]}toString(){return this.message}}class s extends n{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:s})[0]}}class i{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function r(){}function o(){}function l(){}function a(){}function c(){}r.NaN=NaN,r.isNaN=t=>Number.isNaN(t),r.isInfinite=t=>!Number.isFinite(t),r.MAX_VALUE=Number.MAX_VALUE,r.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,r.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,e=new Float64Array(1),n=new Int32Array(e.buffer);r.doubleToLongBits=function(s){e[0]=s;let r=0|n[0],o=0|n[1];return(o&t)===t&&0!=(1048575&o)&&0!==r&&(r=0,o=2146959360),new i(o,r)},r.longBitsToDouble=function(t){return n[0]=t.low,n[1]=t.high,e[0]}}():function(){const t=1023,e=Math.log2,n=Math.floor,s=Math.pow,o=function(){for(let t=53;t>0;t--){const i=s(2,t)-1;if(n(e(i))+1===t)return i}return 0}();r.doubleToLongBits=function(r){let l,a,c,h,u,g,d,_,p;if(r<0||1/r===Number.NEGATIVE_INFINITY?(g=1<<31,r=-r):g=0,0===r)return p=0,_=g,new i(_,p);if(r===1/0)return p=0,_=2146435072|g,new i(_,p);if(r!=r)return p=0,_=2146959360,new i(_,p);if(h=0,p=0,l=n(r),l>1)if(l<=o)h=n(e(l)),h<=20?(p=0,_=l<<20-h&1048575):(c=h-20,a=s(2,c),p=l%a<<32-c,_=l/a&1048575);else for(c=l,p=0;a=c/2,c=n(a),0!==c;)h++,p>>>=1,p|=(1&_)<<31,_>>>=1,a!==c&&(_|=524288);if(d=h+t,u=0===l,l=r-l,h<52&&0!==l)for(c=0;;){if(a=2*l,a>=1?(l=a-1,u?(d--,u=!1):(c<<=1,c|=1,h++)):(l=a,u?0==--d&&(h++,u=!1):(c<<=1,h++)),20===h)_|=c,c=0;else if(52===h){p|=c;break}if(1===a){h<20?_|=c<<20-h:h<52&&(p|=c<<52-h);break}}return _|=d<<20,_|=g,new i(_,p)},r.longBitsToDouble=function(e){let n,i,r,o;const l=e.high,a=e.low,c=l&1<<31?-1:1;for(r=((2146435072&l)>>20)-t,o=0,i=1<<19,n=1;n<=20;n++)l&i&&(o+=s(2,-n)),i>>>=1;for(i=1<<31,n=21;n<=52;n++)a&i&&(o+=s(2,-n)),i>>>=1;if(-1023===r){if(0===o)return 0*c;r=-1022}else{if(1024===r)return 0===o?c/0:NaN;o+=1}return c*o*s(2,r)}}();class h extends n{constructor(t){super(t),this.name=Object.keys({RuntimeException:h})[0]}}class u extends h{constructor(){super(),u.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)h.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}}}class g{static shouldNeverReachHere(){if(0===arguments.length)g.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new u("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];g.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new u:new u(t)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];g.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new u("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}const d=new ArrayBuffer(8),_=new Float64Array(d),p=new Int32Array(d);class m{constructor(){m.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)m.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];m.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return _[0]=t,p[0]^p[1]}getM(){return r.NaN}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.setZ(e);break;default:throw new s("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}setM(t){throw new s("Invalid ordinate index: "+m.M)}getZ(){return this.z}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ()}throw new s("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||r.isNaN(this.getZ())&&r.isNaN(t.getZ()))}equals(t){return t instanceof m&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.getZ(),t.getZ(),n)}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return g.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new m(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+s*s)}getY(){return this.y}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this.x),t=37*t+m.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[o,l,c]}}class f{constructor(){f.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)f.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new s("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0}compare(t,e){const n=f.compare(t.x,e.x);if(0!==n)return n;const s=f.compare(t.y,e.y);if(0!==s)return s;if(this._dimensionsToTest<=2)return 0;return f.compare(t.getZ(),e.getZ())}get interfaces_(){return[a]}}m.DimensionalComparator=f,m.NULL_ORDINATE=r.NaN,m.X=0,m.Y=1,m.Z=2,m.M=3;class y extends m{constructor(){super(),y.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)m.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof y){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case y.X:this.x=e;break;case y.Y:this.y=e;break;default:throw new s("Invalid ordinate index: "+t)}}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case y.X:return this.x;case y.Y:return this.y}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new y(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}}y.X=0,y.Y=1,y.Z=-1,y.M=-1;class x extends m{constructor(){super(),x.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof x){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];m.constructor_.call(this,t,e,m.NULL_ORDINATE),this._m=n}}getM(){return this._m}setOrdinate(t,e){switch(t){case x.X:this.x=e;break;case x.Y:this.y=e;break;case x.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case x.X:return this.x;case x.Y:return this.y;case x.M:return this._m}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new x(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}x.X=0,x.Y=1,x.Z=-1,x.M=2;class E extends m{constructor(){super(),E.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof E){const t=arguments[0];m.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];m.constructor_.call(this,t,e,n),this._m=s}}getM(){return this._m}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.z=e;break;case m.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ();case m.M:return this.getM()}throw new s("Invalid ordinate index: "+t)}copy(){return new E(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}function I(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}class N{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class w extends n{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:w})[0]}}class C extends N{get(){}set(){}isEmpty(){}}class S extends n{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:S})[0]}}class L extends C{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}get interfaces_(){return[C,N]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new T(this)}get(t){if(t<0||t>=this.size())throw new w;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort(((e,n)=>t.compare(e,n))):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}let T=class{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new S;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}};class R extends L{constructor(){super(),R.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&I(arguments[0],N)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){if(0===arguments.length)return this.toArray(R.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(R.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof m&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}}R.coordArrayType=new Array(0).fill(null);class P{filter(t,e){}isDone(){}isGeometryChanged(){}}class O{constructor(){O.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof O))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new O;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new O(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof m){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new O(this)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new m((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this._minx),t=37*t+m.hashCode(this._maxx),t=37*t+m.hashCode(this._miny),t=37*t+m.hashCode(this._maxy),t}get interfaces_(){return[o,c]}}class v{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class b{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new b(t)}}class M{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class D extends n{constructor(t){super(t),this.name=Object.keys({IllegalStateException:D})[0]}}class A{constructor(){A.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof A){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];A.constructor_.call(this,A.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return A.determinant(A.valueOf(t),A.valueOf(e),A.valueOf(n),A.valueOf(s))}if(arguments[3]instanceof A&&arguments[2]instanceof A&&arguments[0]instanceof A&&arguments[1]instanceof A){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return A.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return A.parse(t)}if("number"==typeof arguments[0]){return new A(arguments[0])}}static sqrt(t){return A.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;M.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new A;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,M.isDigit(n)){const t=n-"0";i.selfMultiply(A.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=b.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=i;a||(o=r);const h=r-o-l;if(0===h)c=i;else if(h>0){const t=A.TEN.pow(h);c=i.divide(t)}else if(h<0){const t=A.TEN.pow(-h);c=i.multiply(t)}return s?c.negate():c}static createNaN(){return new A(r.NaN,r.NaN)}static copy(t){return new A(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new v;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=A.magnitude(n._hi);const i=A.TEN.pow(s);n=n.divide(i),n.gt(A.TEN)?(n=n.divide(A.TEN),s+=1):n.lt(A.ONE)&&(n=n.multiply(A.TEN),s-=1);const r=s+1,o=new v,l=A.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(A.valueOf(s)).multiply(A.TEN),i&&n.selfAdd(A.TEN);let c=!0;const h=A.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof A){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof A){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof A){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=A.SPLIT*o,n=l-o,c=A.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof A){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=A.SPLIT*r,e=o-r,a=A.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new A(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?A.createNaN():A.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return A.valueOf(1);let e=new A(this),n=A.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return A.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new A(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof A){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return A.valueOf(0);if(this.isNegative())return A.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=A.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=A.SPLIT*this._hi,n=o-this._hi,l=A.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return A.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new A(t,e)}negate(){return this.isNaN()?this:new A(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof A){const t=arguments[0];return t.isNaN()?A.createNaN():A.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?A.createNaN():A.copy(this).selfMultiply(t,0)}}isNaN(){return r.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=A.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+A.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+A.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=A.SPLIT*i,t=r-i,l=A.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new A(a,i-a+r)}toSciNotation(){if(this.isZero())return A.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=A.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new D("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?A.NaN:this.isNegative()?this.negate():new A(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof A){const t=arguments[0];return A.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return A.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof A){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?A.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[c,o,l]}}A.PI=new A(3.141592653589793,12246467991473532e-32),A.TWO_PI=new A(6.283185307179586,24492935982947064e-32),A.PI_2=new A(1.5707963267948966,6123233995736766e-32),A.E=new A(2.718281828459045,14456468917292502e-32),A.NaN=new A(r.NaN,r.NaN),A.EPS=123259516440783e-46,A.SPLIT=134217729,A.MAX_PRINT_DIGITS=32,A.TEN=A.valueOf(10),A.ONE=A.valueOf(1),A.SCI_NOT_EXPONENT_CHAR="E",A.SCI_NOT_ZERO="0.0E0";class F{static orientationIndex(t,e,n){const s=F.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=A.valueOf(e.x).selfAdd(-t.x),r=A.valueOf(e.y).selfAdd(-t.y),o=A.valueOf(n.x).selfAdd(-e.x),l=A.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof A&&arguments[2]instanceof A&&arguments[0]instanceof A&&arguments[1]instanceof A){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=A.valueOf(t),r=A.valueOf(e),o=A.valueOf(n),l=A.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=new A(t.y).selfSubtract(e.y),o=new A(e.x).selfSubtract(t.x),l=new A(t.x).selfMultiply(e.y).selfSubtract(new A(e.x).selfMultiply(t.y)),a=new A(n.y).selfSubtract(s.y),c=new A(s.x).selfSubtract(n.x),h=new A(n.x).selfMultiply(s.y).selfSubtract(new A(s.x).selfMultiply(n.y)),u=o.multiply(h).selfSubtract(c.multiply(l)),g=a.multiply(l).selfSubtract(i.multiply(h)),d=i.multiply(c).selfSubtract(a.multiply(o)),_=u.selfDivide(d).doubleValue(),p=g.selfDivide(d).doubleValue();return r.isNaN(_)||r.isInfinite(_)||r.isNaN(p)||r.isInfinite(p)?null:new m(_,p)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return F.signum(o);s=i+r}else{if(!(i<0))return F.signum(o);if(r>=0)return F.signum(o);s=-i-r}const l=F.DP_SAFE_EPSILON*s;return o>=l||-o>=l?F.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}F.DP_SAFE_EPSILON=1e-15;class G{getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return r.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):r.NaN}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}get interfaces_(){return[l]}}G.X=0,G.Y=1,G.Z=2,G.M=3;class q{static index(t,e,n){return F.orientationIndex(t,e,n)}static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(n)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(n)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(n)||a.equals2D(n)||l.equals2D(a))return!1;const c=q.index(l,n,a);let h=null;return h=0===c?l.x>a.x:c>0,h}if(I(arguments[0],G)){const t=arguments[0],e=t.size()-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let r=null,o=i;do{o-=1,o<0&&(o=e),r=t.getCoordinate(o)}while(r.equals2D(n)&&o!==i);let l=null,a=i;do{a=(a+1)%e,l=t.getCoordinate(a)}while(l.equals2D(n)&&a!==i);if(r.equals2D(n)||l.equals2D(n)||r.equals2D(l))return!1;const c=q.index(r,n,l);let h=null;return h=0===c?r.x>l.x:c>0,h}}}q.CLOCKWISE=-1,q.RIGHT=q.CLOCKWISE,q.COUNTERCLOCKWISE=1,q.LEFT=q.COUNTERCLOCKWISE,q.COLLINEAR=0,q.STRAIGHT=q.COLLINEAR;class B{static intersection(t,e,n,s){const i=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((i>c?i:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2,p=t.x-d,f=t.y-_,y=e.x-d,x=e.y-_,E=n.x-d,I=n.y-_,N=s.x-d,w=s.y-_,C=f-x,S=y-p,L=p*x-y*f,T=I-w,R=N-E,P=E*w-N*I,O=C*R-T*S,v=(S*P-R*L)/O,b=(T*L-C*P)/O;return r.isNaN(v)||r.isInfinite(v)||r.isNaN(b)||r.isInfinite(b)?null:new m(v+d,b+_)}}class Y{static arraycopy(t,e,n,s,i){let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class V{static log10(t){const e=Math.log(t);return r.isInfinite(e)||r.isNaN(e)?e:e/V.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let s=arguments[0];return t>s&&(s=t),e>s&&(s=e),n>s&&(s=n),s}}static average(t,e){return(t+e)/2}}V.LOG_10=Math.log(10);class z{static segmentToSegment(t,e,n,s){if(t.equals(e))return z.pointToSegment(t,n,s);if(n.equals(s))return z.pointToSegment(s,t,e);let i=!1;if(O.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?V.min(z.pointToSegment(t,n,s),z.pointToSegment(e,n,s),z.pointToSegment(n,t,e),z.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new s("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let s=0;s<e.length-1;s++){const i=z.pointToSegment(t,e[s],e[s+1]);i<n&&(n=i)}return n}}class X{create(){if(1===arguments.length)arguments[0]instanceof Array||I(arguments[0],G);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class k{filter(t){}}class U{constructor(){U.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===U.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(U.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===U.TYPECODE_GEOMETRYCOLLECTION)throw new s("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new O(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[l,o,c]}getClass(){return U}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}U.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},U.TYPECODE_POINT=0,U.TYPECODE_MULTIPOINT=1,U.TYPECODE_LINESTRING=2,U.TYPECODE_LINEARRING=3,U.TYPECODE_MULTILINESTRING=4,U.TYPECODE_POLYGON=5,U.TYPECODE_MULTIPOLYGON=6,U.TYPECODE_GEOMETRYCOLLECTION=7,U.TYPENAME_POINT="Point",U.TYPENAME_MULTIPOINT="MultiPoint",U.TYPENAME_LINESTRING="LineString",U.TYPENAME_LINEARRING="LinearRing",U.TYPENAME_MULTILINESTRING="MultiLineString",U.TYPENAME_POLYGON="Polygon",U.TYPENAME_MULTIPOLYGON="MultiPolygon",U.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",U.geometryChangedFilter={get interfaces_(){return[k]},filter(t){t.geometryChangedAction()}};class H{filter(t){}}class W{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new m;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}}class Z{}class j{static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,G.X)===t.getOrdinate(e-1,G.X)&&t.getOrdinate(0,G.Y)===t.getOrdinate(e-1,G.Y))}static scroll(){if(2===arguments.length){if(I(arguments[0],G)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];j.scroll(t,e,j.isRing(t))}else if(I(arguments[0],G)&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=j.indexOf(e,t);if(n<=0)return null;j.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const s=t.copy(),i=n?t.size()-1:t.size();for(let n=0;n<i;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,s.getOrdinate((e+n)%i,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(i,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let i=0;i<n;i++)for(let n=0;n<s;n++){const s=t.getOrdinate(i,n),o=e.getOrdinate(i,n);if(t.getOrdinate(i,n)!==e.getOrdinate(i,n)&&(!r.isNaN(s)||!r.isNaN(o)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return j.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,s=null;for(let i=arguments[1];i<=e;i++){const e=t.getCoordinate(i);(null===s||s.compareTo(e)>0)&&(s=e,n=i)}return n}}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(j.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)j.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)j.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)j.copyCoord(t,e+r,n,s+r)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return j.createClosedRing(t,e,4);return e.getOrdinate(0,G.X)===e.getOrdinate(n-1,G.X)&&e.getOrdinate(0,G.Y)===e.getOrdinate(n-1,G.Y)?e:j.createClosedRing(t,e,n+1)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,G.X)&&t.y===e.getOrdinate(n,G.Y))return n;return-1}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();j.copy(e,0,s,0,i);for(let t=i;t<n;t++)j.copy(e,0,s,t,1);return s}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const s=t.getCoordinate(n);(null===e||e.compareTo(s)>0)&&(e=s)}return e}}class K extends n{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:K})[0]}}class Q{static toDimensionSymbol(t){switch(t){case Q.FALSE:return Q.SYM_FALSE;case Q.TRUE:return Q.SYM_TRUE;case Q.DONTCARE:return Q.SYM_DONTCARE;case Q.P:return Q.SYM_P;case Q.L:return Q.SYM_L;case Q.A:return Q.SYM_A}throw new s("Unknown dimension value: "+t)}static toDimensionValue(t){switch(M.toUpperCase(t)){case Q.SYM_FALSE:return Q.FALSE;case Q.SYM_TRUE:return Q.TRUE;case Q.SYM_DONTCARE:return Q.DONTCARE;case Q.SYM_P:return Q.P;case Q.SYM_L:return Q.L;case Q.SYM_A:return Q.A}throw new s("Unknown dimension symbol: "+t)}}Q.P=0,Q.L=1,Q.A=2,Q.FALSE=-1,Q.TRUE=-2,Q.DONTCARE=-3,Q.SYM_FALSE="F",Q.SYM_TRUE="T",Q.SYM_DONTCARE="*",Q.SYM_P="0",Q.SYM_L="1",Q.SYM_A="2";class J{filter(t){}}class $ extends U{constructor(){super(),$.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new O:this._points.expandEnvelope(new O)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new $(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();j.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?Q.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return j.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return U.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return W.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(I(arguments[0],H)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){throw new K}isEquivalentClass(t){return t instanceof $}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return U.TYPENAME_LINESTRING}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new s("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}get interfaces_(){return[Z]}}class tt{}class et extends U{constructor(){super(),et.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new O;const t=new O;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new et(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return Q.FALSE}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return U.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new D("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(I(arguments[0],H)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(I(arguments[0],P)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return U.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new D("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),g.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}get interfaces_(){return[tt]}}class nt{static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(nt.ofRingSigned(t))}if(I(arguments[0],G)){const t=arguments[0];return Math.abs(nt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(I(arguments[0],G)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new m,s=new m,i=new m;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}}class st{static sort(){const t=arguments[0];if(1===arguments.length)t.sort(((t,e)=>t.compareTo(e)));else if(2===arguments.length)t.sort(((t,e)=>arguments[1].compare(t,e)));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort(((t,e)=>arguments[3].compare(t,e)));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new L;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class it{}class rt extends U{constructor(){super(),rt.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(U.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),U.hasNullElements(e))throw new s("holes must not contain null elements");if(t.isEmpty()&&U.hasNonEmptyElements(e))throw new s("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=nt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=nt.ofRing(this._holes[e].getCoordinateSequence());return t}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new rt(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);st.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),s=j.minCoordinateIndex(n,0,n.size()-2);j.scroll(n,s,!0),q.isCCW(n)===e&&j.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return U.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,s=e._shell,i=n.compareToSameClass(s,t);if(0!==i)return i;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),s=e.getInteriorRingN(l),i=n.compareToSameClass(s,t);if(0!==i)return i;l++}return l<r?1:l<o?-1:0}}apply(){if(I(arguments[0],H)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return U.TYPENAME_POLYGON}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[it]}}class ot extends N{contains(){}}class lt extends ot{}class at extends lt{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new K}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new ct(this.array)}}let ct=class{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new S;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new K}};class ht extends U{constructor(){super(),ht.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(U.constructor_.call(this,e),null===t&&(t=[]),U.hasNullElements(t))throw new s("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new O;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ht(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();st.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=Q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}reverseInternal(){const t=this._geometries.length,e=new L(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return U.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=Q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new at(st.asList(this._geometries)),n=new at(st.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),s=e.getNumGeometries();let i=0;for(;i<n&&i<s;){const n=this.getGeometryN(i),s=e.getGeometryN(i),r=n.compareToSameClass(s,t);if(0!==r)return r;i++}return i<n?1:i<s?-1:0}}apply(){if(I(arguments[0],H)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return U.checkNotGeometryCollection(this),g.shouldNeverReachHere(),null}getGeometryType(){return U.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}}class ut extends ht{constructor(){super(),ut.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ut(t,this._factory)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return Q.FALSE}getTypeCode(){return U.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return U.TYPENAME_MULTIPOINT}get interfaces_(){return[tt]}}class gt extends ${constructor(){super(),gt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];$.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new gt(this._points.copy(),this._factory)}getBoundaryDimension(){return Q.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return j.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return U.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new s("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<gt.MINIMUM_VALID_SIZE)throw new s("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return U.TYPENAME_LINEARRING}}gt.MINIMUM_VALID_SIZE=4;class dt{static measures(t){return t instanceof y?0:t instanceof x||t instanceof E?1:0}static dimension(t){return t instanceof y?2:t instanceof x?3:t instanceof E?4:3}static create(){if(1===arguments.length){const t=arguments[0];return dt.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new y:3===t&&0===e?new m:3===t&&1===e?new x:4===t&&1===e?new E:new m}}}class _t{static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(_t.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=_t.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);Y.arraycopy(t,n,s,0,t.length-n),Y.arraycopy(t,0,s,t.length-n,n),Y.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new R;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,dt.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!_t.hasRepeatedPoints(t))return t;return new R(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new O;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(_t.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,dt.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=V.clamp(e,0,t.length);let s=(n=V.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}}_t.ForwardComparator=class{compare(t,e){const n=t,s=e;return _t.compare(n,s)}get interfaces_(){return[a]}},_t.BidirectionalComparator=class{compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=_t.compare(n,s);return _t.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=_t.increasingDirection(n),r=_t.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}get interfaces_(){return[a]}},_t.coordArrayType=new Array(0).fill(null);class pt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class mt{constructor(){mt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];mt.constructor_.call(this,t,_t.dimension(t),_t.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new m}else if(I(arguments[0],G)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];mt.constructor_.call(this,t,e,_t.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=dt.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getM(t){return this.hasM()?this._coordinates[t].getM():r.NaN}setOrdinate(t,e,n){switch(e){case G.X:this._coordinates[t].x=n;break;case G.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():r.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case G.X:return this._coordinates[t].x;case G.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return dt.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new mt(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new pt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}get interfaces_(){return[G,c]}}class ft{static instance(){return ft.instanceObject}readResolve(){return ft.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new mt(arguments[0])}if(I(arguments[0],G)){return new mt(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new mt(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new mt(arguments[0],e+t,t)}}}get interfaces_(){return[X,c]}}ft.instanceObject=new ft;class yt extends ht{constructor(){super(),yt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new yt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return U.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new L;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return U.TYPENAME_MULTIPOLYGON}get interfaces_(){return[it]}}let xt=class{get(){}put(){}size(){}values(){}entrySet(){}};class Et extends ot{constructor(t){super(),this.map=new Map,t instanceof N&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new K}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new It(this.map)}[Symbol.iterator](){return this.map}}let It=class{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new S;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new K}};class Nt extends xt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new L,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new Et;return this.map.entries().forEach((e=>t.add(e))),t}size(){return this.map.size()}}class wt{constructor(){wt.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=wt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Ct){const t=arguments[0];this._modelType=t,t===wt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=wt.FIXED,this.setScale(t)}else if(arguments[0]instanceof wt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof wt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return b.compare(n,s)}getScale(){return this._scale}isFloating(){return this._modelType===wt.FLOATING||this._modelType===wt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===wt.FLOATING?t="Floating":this._modelType===wt.FLOATING_SINGLE?t="Floating-Single":this._modelType===wt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(r.isNaN(t))return t;if(this._modelType===wt.FLOATING_SINGLE){return t}return this._modelType===wt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof m){const t=arguments[0];if(this._modelType===wt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===wt.FLOATING?t=16:this._modelType===wt.FLOATING_SINGLE?t=6:this._modelType===wt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}get interfaces_(){return[c,o]}}class Ct{constructor(){Ct.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,Ct.nameToTypeMap.put(t,this)}readResolve(){return Ct.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[c]}}Ct.nameToTypeMap=new Nt,wt.Type=Ct,wt.FIXED=new Ct("FIXED"),wt.FLOATING=new Ct("FLOATING"),wt.FLOATING_SINGLE=new Ct("FLOATING SINGLE"),wt.maximumPreciseValue=9007199254740992;class St extends ht{constructor(){super(),St.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new St(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?Q.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return U.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new K}getGeometryType(){return U.TYPENAME_MULTILINESTRING}get interfaces_(){return[Z]}}class Lt{constructor(){Lt.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Lt.constructor_.call(this,new wt,0);else if(1===arguments.length){if(I(arguments[0],X)){const t=arguments[0];Lt.constructor_.call(this,new wt,0,t)}else if(arguments[0]instanceof wt){const t=arguments[0];Lt.constructor_.call(this,t,0,Lt.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Lt.constructor_.call(this,t,e,Lt.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return ft.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new s("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new m(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new m(t.getMinX(),t.getMinY()),new m(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new m(t.getMinX(),t.getMinY()),new m(t.getMinX(),t.getMaxY()),new m(t.getMaxX(),t.getMaxY()),new m(t.getMaxX(),t.getMinY()),new m(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],G)){return new $(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new St(null,this);if(1===arguments.length){return new St(arguments[0],this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof ht&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Lt.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof rt)return this.createMultiPolygon(Lt.toPolygonArray(t));if(i instanceof $)return this.createMultiLineString(Lt.toLineStringArray(t));if(i instanceof et)return this.createMultiPoint(Lt.toPointArray(t));g.shouldNeverReachHere("Unhandled geometry type: "+i.getGeometryType())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(I(arguments[0],G)){return new et(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(I(arguments[0],G)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof gt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new rt(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new ht(null,this);if(1===arguments.length){return new ht(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],G)){return new gt(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new yt(null,this);if(1===arguments.length){return new yt(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new ut(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new ut(arguments[0],this)}if(I(arguments[0],G)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());j.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}get interfaces_(){return[c]}}const Tt="XY",Rt="XYZ",Pt="XYM",Ot="XYZM",vt={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},bt="EMPTY",Mt=1,Dt=2,At=3,Ft=4,Gt=5,qt=6;for(const t in vt)vt[t].toUpperCase();class Bt{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,s=t;if("("==t)n=Dt;else if(","==t)n=Gt;else if(")"==t)n=At;else if(this.isNumeric_(t)||"-"==t)n=Ft,s=this.readNumber_();else if(this.isAlpha_(t))n=Mt,s=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=qt}return{position:e,value:s,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,s=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(s=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!s&&("e"==t||"E"==t)||s&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class Yt{constructor(t,e){this.lexer_=t,this.token_,this.layout_=Tt,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){this.consume_();return this.parseGeometry_()}parseGeometryLayout_(){let t=Tt;const e=this.token_;if(this.isTokenType(Mt)){const n=e.value;"Z"===n?t=Rt:"M"===n?t=Pt:"ZM"===n&&(t=Ot),t!==Tt&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(Dt)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(Gt));if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(Dt)){const t=this.parsePoint_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(Dt)){const t=this.parsePointList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(Dt)){const t=this.parseLineStringTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(Dt)){let t;if(t=this.token_.type==Dt?this.parsePointTextList_():this.parsePointList_(),this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(Dt)){const t=this.parseLineStringTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(Dt)){const t=this.parsePolygonTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(Ft))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(Gt);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(Gt);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(Gt);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(Gt);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(Mt)&&this.token_.value==bt;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>new m(...t),n=n=>{const s=n.map((n=>t.createLinearRing(n.map(e))));return s.length>1?t.createPolygon(s[0],s.slice(1)):t.createPolygon(s[0])},s=this.token_;if(this.match(Mt)){const i=s.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==i){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(i){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new m(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const s=n.map(e).map((e=>t.createPoint(e)));return t.createMultiPoint(s)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map((n=>t.createLineString(n.map(e))));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const s=e.map(n);return t.createMultiPolygon(s)}default:throw new Error("Invalid geometry type: "+i)}}throw new Error(this.formatErrorMessage_())}}function Vt(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return void 0===e.z||Number.isNaN(e.z)||n.push(e.z),void 0===e.m||Number.isNaN(e.m)||n.push(e.m),n.join(" ")}function zt(t){const e=t.getCoordinates().map((t=>{const e=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||e.push(t.z),void 0===t.m||Number.isNaN(t.m)||e.push(t.m),e})),n=[];for(let t=0,s=e.length;t<s;++t)n.push(e[t].join(" "));return n.join(", ")}function Xt(t){const e=[];e.push("("+zt(t.getExteriorRing())+")");for(let n=0,s=t.getNumInteriorRing();n<s;++n)e.push("("+zt(t.getInteriorRingN(n))+")");return e.join(", ")}const kt={Point:Vt,LineString:zt,LinearRing:zt,Polygon:Xt,MultiPoint:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Vt(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+zt(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Xt(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push(Ut(t.getGeometryN(n)));return e.join(", ")}};function Ut(t){let e=t.getGeometryType();const n=kt[e];e=e.toUpperCase();const s=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return void 0===n.z||Number.isNaN(n.z)||(e+="Z"),void 0===n.m||Number.isNaN(n.m)||(e+="M"),e}(t);if(s.length>0&&(e+=" "+s),t.isEmpty())return e+" "+bt;return e+" ("+n(t)+")"}class Ht{constructor(t){this.geometryFactory=t||new Lt,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new Bt(t);return new Yt(e,this.geometryFactory).parse()}write(t){return Ut(t)}}class Wt{constructor(t){this.parser=new Ht(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class Zt{constructor(){Zt.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map((()=>Array(2))),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new m,this._intPt[1]=new m,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return g.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return g.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new pt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map((()=>Array(2))),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Zt.NO_INTERSECTION}getEdgeDistance(t,e){return Zt.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Zt.COLLINEAR_INTERSECTION}toString(){return Wt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Wt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Zt.DONT_INTERSECT=0,Zt.DO_INTERSECT=1,Zt.COLLINEAR=2,Zt.NO_INTERSECTION=0,Zt.POINT_INTERSECTION=1,Zt.COLLINEAR_INTERSECTION=2;class jt extends Zt{constructor(){super()}static nearestEndpoint(t,e,n,s){let i=t,r=z.pointToSegment(t,n,s),o=z.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=z.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=z.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new O(this._inputLines[0][0],this._inputLines[0][1]),n=new O(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,O.intersects(e,n,t)&&0===q.index(e,n,t)&&0===q.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Zt.POINT_INTERSECTION,null;this._result=Zt.NO_INTERSECTION}}intersection(t,e,n,s){let i=this.intersectionSafe(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new m(jt.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}checkDD(t,e,n,s,i){const r=F.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);Y.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&Y.out.println("Distance = "+i.distance(r))}intersectionSafe(t,e,n,s){let i=B.intersection(t,e,n,s);return null===i&&(i=jt.nearestEndpoint(t,e,n,s)),i}computeCollinearIntersection(t,e,n,s){const i=O.intersects(t,e,n),r=O.intersects(t,e,s),o=O.intersects(n,s,t),l=O.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,Zt.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Zt.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):Zt.NO_INTERSECTION}computeIntersect(t,e,n,s){if(this._isProper=!1,!O.intersects(t,e,n,s))return Zt.NO_INTERSECTION;const i=q.index(t,e,n),r=q.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return Zt.NO_INTERSECTION;const o=q.index(n,s,t),l=q.index(n,s,e);if(o>0&&l>0||o<0&&l<0)return Zt.NO_INTERSECTION;return 0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new m(n):0===r?this._intPt[0]=new m(s):0===o?this._intPt[0]=new m(t):0===l&&(this._intPt[0]=new m(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),Zt.POINT_INTERSECTION)}}class Kt{constructor(){Kt.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)Kt.constructor_.call(this,new m,new m);else if(1===arguments.length){const t=arguments[0];Kt.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,new m(t,e),new m(n,s))}}static midPoint(t,e){return new m((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof Kt){const t=arguments[0],e=q.index(this.p0,this.p1,t.p0),n=q.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof m){const t=arguments[0];return q.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof Kt))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new jt;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof m){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new m(t);const e=this.projectionFactor(t),n=new m;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof Kt){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new Kt(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return z.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return Kt.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;if(s<=0)return r.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=r.MAX_VALUE,i=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);i=l.distance(t.p1),i<s&&(s=i,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);i=a.distance(this.p0),i<s&&(s=i,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return i=c.distance(this.p1),i<s&&(s=i,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return B.intersection(this.p0,this.p1,t.p0,t.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new D("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new m(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||r.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),s=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),i=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new m((-r*o-2*e*n*l-2*e*s)/i,(r*l-2*e*n*o-2*n*s)/i)}distance(){if(arguments[0]instanceof Kt){const t=arguments[0];return z.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof m){const t=arguments[0];return z.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new m;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=r.doubleToLongBits(this.p0.x);t^=31*r.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=r.doubleToLongBits(this.p1.x);n^=31*r.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))}get interfaces_(){return[o,c]}}class Qt{static toLocationSymbol(t){switch(t){case Qt.EXTERIOR:return"e";case Qt.BOUNDARY:return"b";case Qt.INTERIOR:return"i";case Qt.NONE:return"-"}throw new s("Unknown location value: "+t)}}Qt.INTERIOR=0,Qt.BOUNDARY=1,Qt.EXTERIOR=2,Qt.NONE=-1;class Jt{constructor(){Jt.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map((()=>Array(3))),this.setAll(Q.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Jt.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Jt){const t=arguments[0];Jt.constructor_.call(this),this._matrix[Qt.INTERIOR][Qt.INTERIOR]=t._matrix[Qt.INTERIOR][Qt.INTERIOR],this._matrix[Qt.INTERIOR][Qt.BOUNDARY]=t._matrix[Qt.INTERIOR][Qt.BOUNDARY],this._matrix[Qt.INTERIOR][Qt.EXTERIOR]=t._matrix[Qt.INTERIOR][Qt.EXTERIOR],this._matrix[Qt.BOUNDARY][Qt.INTERIOR]=t._matrix[Qt.BOUNDARY][Qt.INTERIOR],this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]=t._matrix[Qt.BOUNDARY][Qt.BOUNDARY],this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]=t._matrix[Qt.BOUNDARY][Qt.EXTERIOR],this._matrix[Qt.EXTERIOR][Qt.INTERIOR]=t._matrix[Qt.EXTERIOR][Qt.INTERIOR],this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]=t._matrix[Qt.EXTERIOR][Qt.BOUNDARY],this._matrix[Qt.EXTERIOR][Qt.EXTERIOR]=t._matrix[Qt.EXTERIOR][Qt.EXTERIOR]}}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===Q.SYM_DONTCARE||(e===Q.SYM_TRUE&&(t>=0||t===Q.TRUE)||(e===Q.SYM_FALSE&&t===Q.FALSE||(e===Q.SYM_P&&t===Q.P||(e===Q.SYM_L&&t===Q.L||e===Q.SYM_A&&t===Q.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Jt(arguments[0]).matches(t)}}static isTrue(t){return t>=0||t===Q.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE}isCoveredBy(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=Q.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,Q.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===Q.A&&e===Q.A||t===Q.L&&e===Q.L||t===Q.L&&e===Q.A||t===Q.P&&e===Q.A||t===Q.P&&e===Q.L)&&(this._matrix[Qt.INTERIOR][Qt.INTERIOR]===Q.FALSE&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY])))}isOverlaps(t,e){return t===Q.P&&e===Q.P||t===Q.A&&e===Q.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===Q.L&&e===Q.L&&(1===this._matrix[Qt.INTERIOR][Qt.INTERIOR]&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]))}isEquals(t,e){return t===e&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE)}toString(){const t=new pt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,Q.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new s("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Jt.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[Qt.INTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.INTERIOR][Qt.BOUNDARY]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]===Q.FALSE}isCrosses(t,e){return t===Q.P&&e===Q.L||t===Q.P&&e===Q.A||t===Q.L&&e===Q.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR]):t===Q.L&&e===Q.P||t===Q.A&&e===Q.P||t===Q.A&&e===Q.L?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===Q.L&&e===Q.L&&0===this._matrix[Qt.INTERIOR][Qt.INTERIOR]}get interfaces_(){return[l]}}class $t{static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=$t.PI_TIMES_2;for(;t<=-Math.PI;)t+=$t.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=$t.PI_TIMES_2;t>=$t.PI_TIMES_2&&(t=0)}else{for(;t>=$t.PI_TIMES_2;)t-=$t.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return $t.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?$t.COUNTERCLOCKWISE:n<0?$t.CLOCKWISE:$t.NONE}static angleBetweenOriented(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n)-s;return i<=-Math.PI?i+$t.PI_TIMES_2:i>Math.PI?i-$t.PI_TIMES_2:i}}$t.PI_TIMES_2=2*Math.PI,$t.PI_OVER_2=Math.PI/2,$t.PI_OVER_4=Math.PI/4,$t.COUNTERCLOCKWISE=q.COUNTERCLOCKWISE,$t.CLOCKWISE=q.CLOCKWISE,$t.NONE=q.COLLINEAR;class te extends n{constructor(){super(),te.constructor_.apply(this,arguments)}static constructor_(){n.constructor_.call(this,"Projective point not representable on the Cartesian plane.")}}class ee{constructor(){ee.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof ee&&arguments[1]instanceof ee){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}}getY(){const t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getX(){const t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getCoordinate(){const t=new m;return t.x=this.getX(),t.y=this.getY(),t}}class ne{constructor(){ne.constructor_.apply(this,arguments)}static constructor_(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static circumcentreDD(t,e,n){const s=A.valueOf(t.x).subtract(n.x),i=A.valueOf(t.y).subtract(n.y),r=A.valueOf(e.x).subtract(n.x),o=A.valueOf(e.y).subtract(n.y),l=A.determinant(s,i,r,o).multiply(2),a=s.sqr().add(i.sqr()),c=r.sqr().add(o.sqr()),h=A.determinant(i,a,o,c),u=A.determinant(s,a,r,c),g=A.valueOf(n.x).subtract(h.divide(l)).doubleValue(),d=A.valueOf(n.y).add(u.divide(l)).doubleValue();return new m(g,d)}static isAcute(t,e,n){return!!$t.isAcute(t,e,n)&&(!!$t.isAcute(e,n,t)&&!!$t.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*ne.det(r,o,l,a),h=ne.det(o,r*r+o*o,a,l*l+a*a),u=ne.det(r,r*r+o*o,l,l*l+a*a);return new m(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new ee(t.x+n/2,t.y+s/2,1),r=new ee(t.x-s+n/2,t.y+n+s/2,1);return new ee(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new m(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.getZ()-t.getZ(),o=n.x-t.x,l=n.y-t.y,a=n.getZ()-t.getZ(),c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new m(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new m(l,a)}area(){return ne.area(this.p0,this.p1,this.p2)}signedArea(){return ne.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new s("Supplied point is null.");return ne.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return ne.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return ne.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return ne.circumcentre(this.p0,this.p1,this.p2)}area3D(){return ne.area3D(this.p0,this.p1,this.p2)}centroid(){return ne.centroid(this.p0,this.p1,this.p2)}inCentre(){return ne.inCentre(this.p0,this.p1,this.p2)}}class se extends n{constructor(){super(),se.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)n.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];n.constructor_.call(this,t)}}}class ie{constructor(){ie.constructor_.apply(this,arguments)}static constructor_(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof ie){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}}static translationInstance(t,e){const n=new ie;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new ie;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return ie.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return ie.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,n,i){if(t===n&&e===i)throw new s("Reflection line points must be distinct");const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new se("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new ie(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof ie))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(ie.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(ie.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(ie.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.rotationInstance(t,e,n,s)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof n))throw t;g.shouldNeverReachHere()}return null}translate(t,e){return this.compose(ie.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const n=Math.sqrt(t*t+e*e),i=e/n,r=t/n;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];if(t===n&&e===i)throw new s("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(ie.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(I(arguments[0],G)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.reflectionInstance(t,e,n,s)),this}}get interfaces_(){return[l,P]}}class re{static solve(t,e){const n=e.length;if(t.length!==n||t[0].length!==n)throw new s("Matrix A is incorrectly sized");for(let s=0;s<n;s++){let i=s;for(let e=s+1;e<n;e++)Math.abs(t[e][s])>Math.abs(t[i][s])&&(i=e);if(0===t[i][s])return null;re.swapRows(t,s,i),re.swapRows(e,s,i);for(let i=s+1;i<n;i++){const r=t[i][s]/t[s][s];for(let e=n-1;e>=s;e--)t[i][e]-=t[s][e]*r;e[i]-=e[s]*r}}const i=new Array(n).fill(null);for(let s=n-1;s>=0;s--){let r=0;for(let e=s+1;e<n;e++)r+=t[s][e]*i[e];i[s]=(e[s]-r)/t[s][s]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}}class oe{constructor(){oe.constructor_.apply(this,arguments)}static constructor_(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return re.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new ie(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}}class le{static createFromBaseLines(t,e,n,s){const i=new m(t.x+s.x-n.x,t.y+s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new ie;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return ie.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new s("Src and Dest arrays are not the same length");if(t.length<=0)throw new s("Too few control points");if(t.length>3)throw new s("Too many control points");return 1===t.length?le.createFromControlVectors(t[0],e[0]):2===t.length?le.createFromControlVectors(t[0],t[1],e[0],e[1]):le.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new m(s.x-n.x,s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){return new oe(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]).getTransformation()}}}}class ae{constructor(){ae.constructor_.apply(this,arguments)}static constructor_(){this._coords=null;const t=arguments[0];this._coords=t}static getCoordinates(t){const e=new L;return t.apply(new ae(e)),e}filter(t){(t instanceof $||t instanceof et)&&this._coords.add(t.getCoordinate())}get interfaces_(){return[k]}}class ce{constructor(){ce.constructor_.apply(this,arguments)}static constructor_(){this._mapOp=null;const t=arguments[0];this._mapOp=t}static map(t,e){return new ce(e).map(t)}map(t){const e=new L;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Lt.toGeometryArray(e))}}class he{constructor(){he.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=he.extractFactory(t),this._inputGeoms=t}static combine(){if(1===arguments.length){return new he(arguments[0]).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new he(he.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new he(he.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new L;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new L;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}}class ue{constructor(){ue.constructor_.apply(this,arguments)}static constructor_(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof ht?this.editGeometryCollection(t,e):t instanceof rt?this.editPolygon(t,e):t instanceof et||t instanceof $?e.edit(t,this._factory):(g.shouldNeverReachHere("Unsupported Geometry type: "+t.getGeometryType()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new L;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getGeometryType()===U.TYPENAME_MULTIPOINT?this._factory.createMultiPoint(s.toArray([])):n.getGeometryType()===U.TYPENAME_MULTILINESTRING?this._factory.createMultiLineString(s.toArray([])):n.getGeometryType()===U.TYPENAME_MULTIPOLYGON?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new L;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}}function ge(){}ue.GeometryEditorOperation=ge;ue.NoOpGeometryOperation=class{edit(t,e){return t}get interfaces_(){return[ge]}},ue.CoordinateOperation=class{edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof gt?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof $?null===n?e.createLineString():e.createLineString(n):t instanceof et?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}get interfaces_(){return[ge]}},ue.CoordinateSequenceOperation=class{edit(t,e){return t instanceof gt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof $?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof et?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}get interfaces_(){return[ge]}};class de{constructor(){de.constructor_.apply(this,arguments)}static constructor_(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e}static isOfType(t,e){return t.getGeometryType()===e||e===U.TYPENAME_LINESTRING&&t.getGeometryType()===U.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return de.extract(t,e,new L)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof ht&&t.apply(new de(e,n)),n}}filter(t){(null===this._geometryType||de.isOfType(t,this._geometryType))&&this._comps.add(t)}get interfaces_(){return[J]}}class _e{static map(){if(arguments[0]instanceof U&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(I(arguments[0],N)&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}}function pe(){}_e.MapOp=pe;class me{constructor(){me.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof gt&&!s.isEmpty()||(n=!1);const i=new L;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof gt||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new L;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Lt.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof et)return this.transformPoint(t,null);if(t instanceof ut)return this.transformMultiPoint(t,null);if(t instanceof gt)return this.transformLinearRing(t,null);if(t instanceof $)return this.transformLineString(t,null);if(t instanceof St)return this.transformMultiLineString(t,null);if(t instanceof rt)return this.transformPolygon(t,null);if(t instanceof yt)return this.transformMultiPolygon(t,null);if(t instanceof ht)return this.transformGeometryCollection(t,null);throw new s("Unknown Geometry subtype: "+t.getGeometryType())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}}class fe{constructor(){fe.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getGeometry(t){return t.getFactory().buildGeometry(fe.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return fe.getLines(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof $?e.add(t):t instanceof ht&&t.apply(new fe(e)),e}}filter(t){t instanceof $&&this._comps.add(t)}get interfaces_(){return[J]}}class ye{constructor(){ye.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(ye.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(ye.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,!1)}if(2===arguments.length){if(I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();ye.getLines(n,t)}return t}if(arguments[0]instanceof U&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new L;return t.apply(new ye(n,e)),n}if(arguments[0]instanceof U&&I(arguments[1],N)){const t=arguments[0],e=arguments[1];return t instanceof $?e.add(t):t.apply(new ye(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const s=n.next();ye.getLines(s,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof U&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new ye(t,e)),t}}}filter(t){if(this._isForcedToLineString&&t instanceof gt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof $&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[k]}}const xe={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return xe.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?st.sort(n,e):st.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new L;return e.add(t),e}};class Ee{constructor(){Ee.constructor_.apply(this,arguments)}static constructor_(){this._pts=null;const t=arguments[0];this._pts=t}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof et?xe.singletonList(t):Ee.getPoints(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof et?e.add(t):t instanceof ht&&t.apply(new Ee(e)),e}}filter(t){t instanceof et&&this._pts.add(t)}get interfaces_(){return[J]}}class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ie.getPolygons(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof rt?e.add(t):t instanceof ht&&t.apply(new Ie(e)),e}}filter(t){t instanceof rt&&this._comps.add(t)}get interfaces_(){return[J]}}class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof ht)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class we{constructor(){we.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._precModel=null,this._dim=new Ce,this._nPts=100,this._rotationAngle=0,0===arguments.length)we.constructor_.call(this,new Lt);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new m(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=ie.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new m(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}}class Ce{constructor(){Ce.constructor_.apply(this,arguments)}static constructor_(){this.base=null,this.centre=null,this.width=null,this.height=null}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new m(t.getMinX(),t.getMinY()),this.centre=new m(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new O(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new O(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new O(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new m(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}}we.Dimensions=Ce;class Se extends we{constructor(){super(),Se.constructor_.apply(this,arguments)}static constructor_(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)we.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];we.constructor_.call(this,t)}}static create(t,e,n,s,i){const r=new Se;r.setCentre(t),r.setSize(e),r.setNumPoints(n),r.setArmLengthRatio(i),r.setNumArms(s);return r.createSineStar()}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new m(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}}var Le=Object.freeze({__proto__:null,AffineTransformation:ie,AffineTransformationBuilder:oe,AffineTransformationFactory:le,ComponentCoordinateExtracter:ae,GeometryCollectionMapper:ce,GeometryCombiner:he,GeometryEditor:ue,GeometryExtracter:de,GeometryMapper:_e,GeometryTransformer:me,LineStringExtracter:fe,LinearComponentExtracter:ye,PointExtracter:Ee,PolygonExtracter:Ie,ShortCircuitedGeometryVisitor:Ne,SineStarFactory:Se}),Te=Object.freeze({__proto__:null,Coordinate:m,CoordinateXY:y,CoordinateXYM:x,CoordinateXYZM:E,CoordinateList:R,CoordinateSequenceFilter:P,Envelope:O,LineSegment:Kt,GeometryFactory:Lt,Geometry:U,Point:et,LineString:$,LinearRing:gt,Polygon:rt,GeometryCollection:ht,MultiPoint:ut,MultiLineString:St,MultiPolygon:yt,Dimension:Q,IntersectionMatrix:Jt,PrecisionModel:wt,Location:Qt,Triangle:ne,util:Le});class Re{constructor(){Re.constructor_.apply(this,arguments)}static constructor_(){this._pt=[new m,new m],this._distance=r.NaN,this._isNull=!0}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Wt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}}class Pe{static computeDistance(){if(arguments[2]instanceof Re&&arguments[0]instanceof $&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Kt,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Re&&arguments[0]instanceof rt&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];Pe.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)Pe.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Re&&arguments[0]instanceof U&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof $)Pe.computeDistance(t,e,n);else if(t instanceof rt)Pe.computeDistance(t,e,n);else if(t instanceof ht){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);Pe.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Re&&arguments[0]instanceof Kt&&arguments[1]instanceof m){const t=arguments[1],e=arguments[2],n=arguments[0].closestPoint(t);e.setMinimum(n,t)}}}class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static constructor_(){this._g0=null,this._g1=null,this._ptDist=new Re,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e}static distance(){if(2===arguments.length){return new Oe(arguments[0],arguments[1]).distance()}if(3===arguments.length){const t=arguments[2],e=new Oe(arguments[0],arguments[1]);return e.setDensifyFraction(t),e.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new s("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new ve(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new be(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}}class ve{constructor(){ve.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._euclideanDist=new Pe,this._geom=null;const t=arguments[0];this._geom=t}filter(t){this._minPtDist.initialize(),Pe.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[H]}}class be{constructor(){be.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new m(e,s);this._minPtDist.initialize(),Pe.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[P]}}Oe.MaxPointDistanceFilter=ve,Oe.MaxDensifiedByFractionDistanceFilter=be;var Me=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:Pe,PointPairDistance:Re});class De{visitItem(t){}}class Ae{locate(t){}}class Fe{constructor(){Fe.constructor_.apply(this,arguments)}static constructor_(){this._min=r.POSITIVE_INFINITY,this._max=r.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Wt.toLineString(new m(this._min,0),new m(this._max,0))}}Fe.NodeComparator=class{compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}get interfaces_(){return[a]}};class Ge extends Fe{constructor(){super(),Ge.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class qe extends Fe{constructor(){super(),qe.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class Be{constructor(){Be.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new L,this._root=null,this._level=0}buildTree(){xe.sort(this._leaves,new Fe.NodeComparator);let t=this._leaves,e=null,n=new L;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new D("Index cannot be added to once it has been queried");this._leaves.add(new Ge(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){Y.out.println(Wt.toLineString(new m(t._min,this._level),new m(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new qe(t.get(n),t.get(n+1));e.add(s)}}}}class Ye{constructor(){Ye.constructor_.apply(this,arguments)}static constructor_(){this._items=new L}visitItem(t){this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class Ve{constructor(){Ve.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof m&&I(arguments[1],G)){const t=arguments[1],e=new Ve(arguments[0]),n=new m,s=new m;for(let i=1;i<t.size();i++)if(t.getCoordinate(i,n),t.getCoordinate(i-1,s),e.countSegment(n,s),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[1],e=new Ve(arguments[0]);for(let n=1;n<t.length;n++){const s=t[n],i=t[n-1];if(e.countSegment(s,i),e.isOnSegment())return e.getLocation()}return e.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=q.index(t,e,this._p);if(n===q.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===q.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==Qt.EXTERIOR}getLocation(){return this._isPointOnSegment?Qt.BOUNDARY:this._crossingCount%2==1?Qt.INTERIOR:Qt.EXTERIOR}isOnSegment(){return this._isPointOnSegment}}class ze{constructor(){ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(I(t,it)||t instanceof gt))throw new s("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new ke(this._geom),this._geom=null);const e=new Ve(t),n=new Xe(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[Ae]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[De]}}class ke{constructor(){ke.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new Be;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new Kt(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new L;const n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}ze.SegmentVisitor=Xe,ze.IntervalIndexedGeometry=ke;class Ue{static isOnLine(){if(arguments[0]instanceof m&&I(arguments[1],G)){const t=arguments[0],e=arguments[1],n=new jt,s=new m,i=new m,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new jt;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ve.locatePointInRing(t,e)}static isInRing(t,e){return Ue.locateInRing(t,e)!==Qt.EXTERIOR}}class He{hasNext(){}next(){}remove(){}}class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof ht)}next(){if(this._atStart)return this._atStart=!1,We.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new S;const t=this._parent.getGeometryN(this._index++);return t instanceof ht?(this._subcollectionIterator=new We(t),this._subcollectionIterator.next()):t}remove(){throw new K(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}get interfaces_(){return[He]}}class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==Qt.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===Qt.BOUNDARY)return Qt.BOUNDARY;if(i===Qt.INTERIOR)return Qt.EXTERIOR}return Qt.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}static containsPointInPolygon(t,e){return Qt.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof rt)return Ze.locatePointInPolygon(t,e);if(e instanceof ht){const n=new We(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==Qt.EXTERIOR)return e}}}return Qt.EXTERIOR}static isContained(t,e){return Qt.EXTERIOR!==Ze.locate(t,e)}static locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e.getEnvelopeInternal().intersects(t)?Ze.locateInGeometry(t,e):Qt.EXTERIOR}locate(t){return Ze.locate(t,this._geom)}get interfaces_(){return[Ae]}}var je=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ze,PointOnGeometryLocator:Ae,SimplePointInAreaLocator:Ze});class Ke{measure(t,e){}}class Qe{static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,Qe.DENSIFY_FRACTION),s=new O(t.getEnvelopeInternal());s.expandToInclude(e.getEnvelopeInternal());return 1-n/Qe.diagonalSize(s)}get interfaces_(){return[Ke]}}Qe.DENSIFY_FRACTION=.25;var Je=Object.freeze({__proto__:null,AreaSimilarityMeasure:class{measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}get interfaces_(){return[Ke]}},HausdorffSimilarityMeasure:Qe,SimilarityMeasure:Ke,SimilarityMeasureCombiner:class{static combine(t,e){return Math.min(t,e)}}});class $e{constructor(){$e.constructor_.apply(this,arguments)}static constructor_(){this._areaBasePt=null,this._triangleCent3=new m,this._areasum2=0,this._cg3=new m,this._lineCentSum=new m,this._totalLength=0,this._ptCount=0,this._ptCentSum=new m;const t=arguments[0];this._areaBasePt=null,this.add(t)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new $e(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=q.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new m;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!q.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;$e.centroid3(t,e,n,this._triangleCent3);const r=$e.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof rt){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof U){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof et)this.addPoint(t.getCoordinate());else if(t instanceof $)this.addLineSegments(t.getCoordinates());else if(t instanceof rt){const e=t;this.add(e)}else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}}class tn extends n{constructor(t){super(t),this.name=Object.keys({EmptyStackException:tn})[0]}}class en extends C{constructor(){super(),this.array=[]}add(t){return this.array.push(t),!0}get(t){if(t<0||t>=this.size())throw new w;return this.array[t]}push(t){return this.array.push(t),t}pop(){if(0===this.array.length)throw new tn;return this.array.pop()}peek(){if(0===this.array.length)throw new tn;return this.array[this.array.length-1]}empty(){return 0===this.array.length}isEmpty(){return this.empty()}search(t){return this.array.indexOf(t)}size(){return this.array.length}toArray(){return this.array.slice()}}class nn{constructor(){nn.constructor_.apply(this,arguments)}static constructor_(){this._coordSet=new Et,this._list=new L}static filterCoordinates(t){const e=new nn;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this._coordSet.add(t)&&this._list.add(t)}getCoordinates(){const t=new Array(this._list.size()).fill(null);return this._list.toArray(t)}get interfaces_(){return[H]}}class sn{constructor(){sn.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];sn.constructor_.call(this,sn.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=nn.filterCoordinates(t),this._geomFactory=e}}static extractCoordinates(t){const e=new nn;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return st.sort(t,1,t.length,new rn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new R;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){g.equals(t[0],t[t.length-1]);const e=new L;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==q.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new at;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)Ue.isInRing(t[s],e)||n.add(t[s]);const s=_t.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new en;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&q.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}}class rn{constructor(){rn.constructor_.apply(this,arguments)}static constructor_(){this._origin=null;const t=arguments[0];this._origin=t}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=q.index(t,e,n);if(l===q.COUNTERCLOCKWISE)return 1;if(l===q.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return rn.polarCompare(this._origin,n,s)}get interfaces_(){return[a]}}sn.RadialComparator=rn;class on{constructor(){on.constructor_.apply(this,arguments)}static constructor_(){this._interiorPoint=null,this._maxWidth=-1;const t=arguments[0];this.process(t)}static getInteriorPoint(t){return new on(t).getInteriorPoint()}static avg(t,e){return(t+e)/2}getInteriorPoint(){return this._interiorPoint}process(t){if(t.isEmpty())return null;if(t instanceof rt)this.processPolygon(t);else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.process(e.getGeometryN(t))}}processPolygon(t){const e=new ln(t);e.process();const n=e.getWidth();n>this._maxWidth&&(this._maxWidth=n,this._interiorPoint=e.getInteriorPoint())}}class ln{constructor(){ln.constructor_.apply(this,arguments)}static constructor_(){this._polygon=null,this._interiorPointY=null,this._interiorSectionWidth=0,this._interiorPoint=null;const t=arguments[0];this._polygon=t,this._interiorPointY=cn.getScanLineY(t)}static isEdgeCrossingCounted(t,e,n){const s=t.getY(),i=e.getY();return s!==i&&(!(s===n&&i<n)&&!(i===n&&s<n))}static intersectsHorizontalLine(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!(e<t.getMinY())&&!(e>t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return!(t.getY()>n&&e.getY()>n)&&!(t.getY()<n&&e.getY()<n)}}static intersection(t,e,n){const s=t.getX(),i=e.getX();if(s===i)return s;const r=i-s,o=(e.getY()-t.getY())/r;return s+(n-t.getY())/o}findBestMidpoint(t){if(0===t.size())return null;g.isTrue(0==t.size()%2,"Interior Point robustness failure: odd number of scanline crossings"),t.sort(new an);for(let e=0;e<t.size();e+=2){const n=t.get(e),s=t.get(e+1),i=s-n;if(i>this._interiorSectionWidth){this._interiorSectionWidth=i;const t=on.avg(n,s);this._interiorPoint=new m(t,this._interiorPointY)}}}process(){if(this._polygon.isEmpty())return null;this._interiorPoint=new m(this._polygon.getCoordinate());const t=new L;this.scanRing(this._polygon.getExteriorRing(),t);for(let e=0;e<this._polygon.getNumInteriorRing();e++)this.scanRing(this._polygon.getInteriorRingN(e),t);this.findBestMidpoint(t)}scanRing(t,e){if(!ln.intersectsHorizontalLine(t.getEnvelopeInternal(),this._interiorPointY))return null;const n=t.getCoordinateSequence();for(let t=1;t<n.size();t++){const s=n.getCoordinate(t-1),i=n.getCoordinate(t);this.addEdgeCrossing(s,i,this._interiorPointY,e)}}getWidth(){return this._interiorSectionWidth}getInteriorPoint(){return this._interiorPoint}addEdgeCrossing(t,e,n,s){if(!ln.intersectsHorizontalLine(t,e,n))return null;if(!ln.isEdgeCrossingCounted(t,e,n))return null;const i=ln.intersection(t,e,n);s.add(i)}}class an{compare(t,e){return t<e?-1:t>e?1:0}get interfaces_(){return[a]}}ln.DoubleComparator=an;class cn{constructor(){cn.constructor_.apply(this,arguments)}static constructor_(){this._poly=null,this._centreY=null,this._hiY=r.MAX_VALUE,this._loY=-r.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=on.avg(this._loY,this._hiY)}static getScanLineY(t){return new cn(t).getScanLineY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getScanLineY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return on.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}}on.InteriorPointPolygon=ln,on.ScanLineYOrdinateFinder=cn;class hn{constructor(){hn.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=null:(this._centroid=$e.getCentroid(t),t.getPrecisionModel().makePrecise(this._centroid)),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)}static getInteriorPoint(t){return new hn(t).getInteriorPoint()}addEndpoints(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof $)this.addEndpoints(t.getCoordinates());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof $)this.addInterior(t.getCoordinates());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}class un{constructor(){un.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=$e.getCentroid(t),this.add(t)}static getInteriorPoint(t){return new un(t).getInteriorPoint()}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof et)this.add(t.getCoordinate());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof m){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}}class gn{isInBoundary(t){}}class dn{isInBoundary(t){return t%2==1}get interfaces_(){return[gn]}}class _n{isInBoundary(t){return t>0}get interfaces_(){return[gn]}}class pn{isInBoundary(t){return t>1}get interfaces_(){return[gn]}}class mn{isInBoundary(t){return 1===t}get interfaces_(){return[gn]}}gn.Mod2BoundaryNodeRule=dn,gn.EndPointBoundaryNodeRule=_n,gn.MultiValentEndPointBoundaryNodeRule=pn,gn.MonoValentEndPointBoundaryNodeRule=mn,gn.MOD2_BOUNDARY_RULE=new dn,gn.ENDPOINT_BOUNDARY_RULE=new _n,gn.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new pn,gn.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new mn,gn.OGC_SFS_BOUNDARY_RULE=gn.MOD2_BOUNDARY_RULE;class fn{constructor(){fn.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=gn.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new s("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}intersects(t,e){return this.locate(t,e)!==Qt.EXTERIOR}updateLocationInfo(t){t===Qt.INTERIOR&&(this._isIn=!0),t===Qt.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof et&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof $)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof rt)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof St){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof yt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof ht){const n=new We(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?Qt.INTERIOR:Qt.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return Qt.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?Ue.isOnLine(t,n)?Qt.INTERIOR:Qt.EXTERIOR:Qt.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===Qt.EXTERIOR)return Qt.EXTERIOR;if(s===Qt.BOUNDARY)return Qt.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===Qt.INTERIOR)return Qt.EXTERIOR;if(i===Qt.BOUNDARY)return Qt.BOUNDARY}return Qt.INTERIOR}locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e instanceof $?this.locateOnLineString(t,e):e instanceof rt?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?Qt.BOUNDARY:this._numBoundaries>0||this._isIn?Qt.INTERIOR:Qt.EXTERIOR)}}class yn{constructor(){yn.constructor_.apply(this,arguments)}static constructor_(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t}static farthestPoints(t){const e=t[0].distance(t[1]),n=t[1].distance(t[2]),s=t[2].distance(t[0]);return e>=n&&e>=s?[t[0],t[1]]:n>=e&&n>=s?[t[1],t[2]]:[t[2],t[0]]}static pointWitMinAngleWithX(t,e){let n=r.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=r.MAX_VALUE,i=null;for(let r=0;r<t.length;r++){const o=t[r];if(o===e)continue;if(o===n)continue;const l=$t.angleBetween(e,o,n);l<s&&(s=l,i=o)}return i}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new m(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),_t.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=_t.copyDeep(e),null;let n=yn.lowestPoint(e),s=yn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=yn.pointWithMinAngleWithSegment(e,n,s);if($t.isObtuse(n,t,s))return this._extremalPts=[new m(n),new m(s)],null;if($t.isObtuse(t,n,s))n=t;else{if(!$t.isObtuse(t,s,n))return this._extremalPts=[new m(n),new m(s),new m(t)],null;s=t}}g.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}getMaximumDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre);case 2:return this._input.getFactory().createLineString([this._extremalPts[0],this._extremalPts[1]]);default:const t=yn.farthestPoints(this._extremalPts);return this._input.getFactory().createLineString(t)}}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new m((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=ne.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}}class xn{constructor(){xn.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new Kt,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];xn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new xn(t).getDiameter()}static getMinimumRectangle(t){return new xn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new m(0,n/e),i=new m(1,n/e-t/e)):(s=new m(n/t,0),i=new m(n/t-e/t,1)),new Kt(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof rt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=r.MAX_VALUE;let e=1;const n=new Kt;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new sn(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=xn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new Kt(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=r.MAX_VALUE,s=-r.MAX_VALUE,i=r.MAX_VALUE,o=-r.MAX_VALUE;for(let r=0;r<this._convexHullPts.length;r++){const l=xn.computeC(t,e,this._convexHullPts[r]);l>s&&(s=l),l<n&&(n=l);const a=xn.computeC(-e,t,this._convexHullPts[r]);a>o&&(o=a),a<i&&(i=a)}const l=xn.computeSegmentForLine(-t,-e,o),a=xn.computeSegmentForLine(-t,-e,i),c=xn.computeSegmentForLine(-e,t,s),h=xn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),p=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(p)}}var En=Object.freeze({__proto__:null,distance:Me,locate:je,match:Je,Angle:$t,Area:nt,Centroid:$e,ConvexHull:sn,Distance:z,InteriorPointArea:on,InteriorPointLine:hn,InteriorPointPoint:un,Length:W,Orientation:q,PointLocation:Ue,PointLocator:fn,RobustLineIntersector:jt,MinimumBoundingCircle:yn,MinimumDiameter:xn});class In{constructor(){In.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t}static densifyPoints(t,e,n){const s=new Kt,i=new R;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new In(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new Nn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new s("Tolerance must be positive");this._distanceTolerance=t}}class Nn extends me{constructor(){super(),Nn.constructor_.apply(this,arguments)}static constructor_(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=In.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof $&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}}In.DensifyTransformer=Nn;var wn=Object.freeze({__proto__:null,Densifier:In});class Cn{static isNorthern(t){return t===Cn.NE||t===Cn.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===Cn.SE?t===Cn.SE||t===Cn.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Cn.NE:Cn.SE:e>=0?Cn.NW:Cn.SW}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new s("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?Cn.NE:Cn.SE:e.y>=t.y?Cn.NW:Cn.SW}}}Cn.NE=0,Cn.NW=1,Cn.SW=2,Cn.SE=3;class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static constructor_(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t}static create(t,e){const n=new Sn(t),s=new Sn(e);return n.link(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}isEdgesSorted(){const t=this.findLowest();let e=t;do{const n=e.oNext();if(n===t)break;if(!(n.compareTo(e)>0))return!1;e=n}while(e!==t);return!0}oNext(){return this._sym._next}directionY(){return this.directionPt().getY()-this._orig.getY()}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;this.insertionEdge(t).insertAfter(t)}insertAfter(t){g.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof m&&arguments[0]instanceof m){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}findLowest(){let t=this,e=this.oNext();do{e.compareTo(t)<0&&(t=e),e=e.oNext()}while(e!==this);return t}directionPt(){return this.dest()}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.directionX(),n=this.directionY(),s=t.directionX(),i=t.directionY();if(e===s&&n===i)return 0;const r=Cn.quadrant(e,n),o=Cn.quadrant(s,i);if(r>o)return 1;if(r<o)return-1;const l=this.directionPt(),a=t.directionPt();return q.index(t._orig,a,l)}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}directionX(){return this.directionPt().getX()-this._orig.getX()}insertionEdge(t){let e=this;do{const n=e.oNext();if(n.compareTo(e)>0&&t.compareTo(e)>=0&&t.compareTo(n)<=0)return e;if(n.compareTo(e)<=0&&(t.compareTo(n)<=0||t.compareTo(e)>=0))return e;e=n}while(e!==this);return g.shouldNeverReachHere(),null}compareTo(t){const e=t;return this.compareAngularDirection(e)}toStringNode(){const t=this.orig();this.dest();const e=new pt;e.append("Node( "+Wt.format(t)+" )\n");let n=this;do{e.append("  -> "+n),e.append("\n"),n=n.oNext()}while(n!==this);return e.toString()}link(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}toStringNodeEdge(){return"  -> ("+Wt.format(this.dest())}setNext(t){this._next=t}}class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1;const t=arguments[0];Sn.constructor_.call(this,t)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}}class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static constructor_(){this._vertexMap=new Nt}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return n.link(s),n}createEdge(t){return new Sn(t)}addEdge(t,e){if(!Tn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}}class Rn extends Ln{constructor(){super(),Rn.constructor_.apply(this,arguments)}static constructor_(){this._isStart=!1;const t=arguments[0];Ln.constructor_.call(this,t)}setStart(){this._isStart=!0}isStart(){return this._isStart}}class Pn extends Tn{constructor(){super()}createEdge(t){return new Rn(t)}}class On{constructor(){On.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._factory=null,this._graph=null,this._lines=new L,this._nodeEdgeStack=new en,this._ringStartEdge=null,this._graph=new Pn}static dissolve(t){const e=new On;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new R;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new R;let n=t;for(this._ringStartEdge=null,Ln.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Ln.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Ln.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Ln.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Ln.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof U){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof $&&this.add(t)}})}else if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof $){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}}var vn=Object.freeze({__proto__:null,LineDissolver:On});class bn{static opposite(t){return t===bn.LEFT?bn.RIGHT:t===bn.RIGHT?bn.LEFT:t}}bn.ON=0,bn.LEFT=1,bn.RIGHT=2;let Mn=class{constructor(){Mn.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}};class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=Dn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=Dn.INSERT,this._label=t,this._xValue=e,this._obj=n}}isDelete(){return this._eventType===Dn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===Dn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}get interfaces_(){return[o]}}Dn.INSERT=1,Dn.DELETE=2;class An{}let Fn=class{constructor(){Fn.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Fn.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}};class Gn extends An{constructor(){super(),Gn.constructor_.apply(this,arguments)}static constructor_(){this.events=new L,this.nOverlaps=null}prepareEvents(){xe.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Fn&&I(arguments[0],C)&&I(arguments[1],C)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&I(arguments[0],C)&&arguments[1]instanceof Fn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new Mn(n,t),i=new Dn(e,n.getMinX(t),s);this.events.add(i),this.events.add(new Dn(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class qn{constructor(){qn.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[bn.ON]=t}else if(arguments[0]instanceof qn){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[bn.ON]=t,this.location[bn.LEFT]=e,this.location[bn.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==Qt.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[bn.ON]=this.location[bn.ON],t[bn.LEFT]=Qt.NONE,t[bn.RIGHT]=Qt.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[bn.LEFT];this.location[bn.LEFT]=this.location[bn.RIGHT],this.location[bn.RIGHT]=t}toString(){const t=new v;return this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[bn.LEFT])),t.append(Qt.toLocationSymbol(this.location[bn.ON])),this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[bn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[bn.ON]=t,this.location[bn.LEFT]=e,this.location[bn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:Qt.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===Qt.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(bn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(Qt.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}}class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new qn(t),this.elt[1]=new qn(t)}else if(arguments[0]instanceof Bn){const t=arguments[0];this.elt[0]=new qn(t.elt[0]),this.elt[1]=new qn(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new qn(Qt.NONE),this.elt[1]=new qn(Qt.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new qn(t,e,n),this.elt[1]=new qn(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new qn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[1]=new qn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[t].setLocations(e,n,s)}}static toLineLabel(t){const e=new Bn(Qt.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new qn(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(bn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new v;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(bn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new qn(this.elt[t].location[0]))}}class Yn{constructor(){Yn.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new m(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[o]}}class Vn extends xt{}function zn(t){return null==t?0:t.color}function Xn(t){return null==t?null:t.parent}function kn(t,e){null!==t&&(t.color=e)}function Un(t){return null==t?null:t.left}function Hn(t){return null==t?null:t.right}class Wn extends Vn{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,s,i=this.root_;do{if(n=i,s=t.compareTo(i.key),s<0)i=i.left;else{if(!(s>0)){const t=i.value;return i.value=e,t}i=i.right}}while(null!==i);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)Xn(t)===Un(Xn(Xn(t)))?(e=Hn(Xn(Xn(t))),1===zn(e)?(kn(Xn(t),0),kn(e,0),kn(Xn(Xn(t)),1),t=Xn(Xn(t))):(t===Hn(Xn(t))&&(t=Xn(t),this.rotateLeft(t)),kn(Xn(t),0),kn(Xn(Xn(t)),1),this.rotateRight(Xn(Xn(t))))):(e=Un(Xn(Xn(t))),1===zn(e)?(kn(Xn(t),0),kn(e,0),kn(Xn(Xn(t)),1),t=Xn(Xn(t))):(t===Un(Xn(t))&&(t=Xn(t),this.rotateRight(t)),kn(Xn(t),0),kn(Xn(Xn(t)),1),this.rotateLeft(Xn(Xn(t)))));this.root_.color=0}values(){const t=new L;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=Wn.successor(e));)t.add(e.value);return t}entrySet(){const t=new Et;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=Wn.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new ts(r,new Bn(this.edge._label))}add(t,e,n){const s=new Yn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}}class jn{constructor(){jn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)jn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),Y.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=st.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return Y.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class Kn{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new jn(Math.trunc(t.length/2));n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return n.toArray()}findChainEnd(t,e){const n=Cn.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(Cn.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}OLDgetChainStartIndices(t){let e=0;const n=new L;n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return Kn.toIntArray(n)}}class Qn{constructor(){Qn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return O.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}}class Jn{constructor(){Jn.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map((()=>Array(3)));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Jn.NULL_VALUE}static depthAtLocation(t){return t===Qt.EXTERIOR?0:t===Qt.INTERIOR?1:Jn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Jn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Jn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Jn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][bn.RIGHT]-this._depth[t][bn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?Qt.EXTERIOR:Qt.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==Qt.EXTERIOR&&s!==Qt.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Jn.depthAtLocation(s):this._depth[e][n]+=Jn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===Qt.INTERIOR&&this._depth[t][e]++}}}Jn.NULL_VALUE=-1;let $n=class{constructor(){$n.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){g.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}},ts=class extends $n{constructor(){super(),ts.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new Zn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Jn,this._depthDelta=0,1===arguments.length){const t=arguments[0];ts.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Jt&&arguments[0]instanceof Bn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,bn.ON),t.getLocation(1,bn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,bn.LEFT),t.getLocation(1,bn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,bn.RIGHT),t.getLocation(1,bn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new ts(t,Bn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof ts))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){ts.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Qn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new O;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new m(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new pt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}},es=class extends $n{constructor(){super(),es.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Bn(0,Qt.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=Qt.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==Qt.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Bn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof es){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Bn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===Qt.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=Qt.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case Qt.BOUNDARY:n=Qt.INTERIOR;break;case Qt.INTERIOR:default:n=Qt.BOUNDARY}this._label.setLocation(t,n)}},ns=class{constructor(){ns.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new Wn,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof m){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof es){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new L;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===Qt.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}};class ss{constructor(){ss.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ss.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ss.constructor_.call(this,t),this.init(e,n),this._label=s}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:q.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Cn.quadrant(this._dx,this._dy),g.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}get interfaces_(){return[o]}}class is extends h{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new m(e):void 0,this.name=Object.keys({TopologyException:is})[0]}getCoordinate(){return this.pt}}let rs=class extends ss{constructor(){super(),rs.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(ss.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===Qt.EXTERIOR&&e===Qt.INTERIOR?1:t===Qt.INTERIOR&&e===Qt.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Bn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new is("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,bn.LEFT)===Qt.INTERIOR&&this._label.getLocation(e,bn.RIGHT)===Qt.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[bn.LEFT]+"/"+this._depth[bn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Qt.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Qt.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===bn.LEFT&&(s=-1);const i=bn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}};class os{createNode(t){return new es(t,null)}}let ls=class{constructor(){ls.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new L,this._nodes=null,this._edgeEndList=new L,0===arguments.length)this._nodes=new ns(new os);else if(1===arguments.length){const t=arguments[0];this._nodes=new ns(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof es){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){Y.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===Qt.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(q.index(t,e,s)===q.COLLINEAR&&Cn.quadrant(t,e)===Cn.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){Y.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new rs(t,!0),s=new rs(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}};class as extends ls{constructor(){super(),as.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new Nt,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new fn,2===arguments.length){const t=arguments[0],e=arguments[1];as.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?Qt.BOUNDARY:Qt.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=Qt.NONE;i=n.getLocation(t,bn.ON),i===Qt.BOUNDARY&&s++;const r=as.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new Fn(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const s=this.createEdgeSetIntersector(),i=this._parentGeom instanceof gt||this._parentGeom instanceof rt||this._parentGeom instanceof yt,r=t||!i;return s.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new Fn(e,n,!0);s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof et){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,Qt.INTERIOR)}else if(arguments[0]instanceof m){const t=arguments[0];this.insertPoint(this._argIndex,t,Qt.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),Qt.EXTERIOR,Qt.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,Qt.INTERIOR,Qt.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],Qt.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],Qt.BOUNDARY)}addLineString(t){const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new ts(e,new Bn(this._argIndex,Qt.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),g.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===Qt.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=_t.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;q.isCCW(s)&&(i=n,r=e);const o=new ts(s,new Bn(this._argIndex,Qt.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],Qt.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new Bn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Gn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof U))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof yt&&(this._useBoundaryDeterminationRule=!1),t instanceof rt)this.addPolygon(t);else if(t instanceof $)this.addLineString(t);else if(t instanceof et)this.addPoint(t);else if(t instanceof ut)this.addCollection(t);else if(t instanceof St)this.addCollection(t);else if(t instanceof yt)this.addCollection(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return I(this._parentGeom,it)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ze(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof $){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}}var cs=Object.freeze({__proto__:null,GeometryGraph:as});class hs{visit(t){}}class us{constructor(){us.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e),this._left=null,this._right=null,this._count=1,this._data=n}}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}}class gs{constructor(){gs.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)gs.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return gs.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new R;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new us(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new L;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof O&&I(arguments[1],C)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[hs]}visit(t){e.add(t)}})}else if(arguments[0]instanceof O&&I(arguments[1],hs)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new ds(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new us(t,e);return r?s.setLeft(o):s.setRight(o),o}}class ds{constructor(){ds.constructor_.apply(this,arguments)}static constructor_(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new O(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}get interfaces_(){return[hs]}}gs.BestMatchVisitor=ds;var _s=Object.freeze({__proto__:null,KdTree:gs});class ps{constructor(){ps.constructor_.apply(this,arguments)}static constructor_(){this._items=new L,this._subnode=new Array(4).fill(null)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}get interfaces_(){return[c]}}function ms(){}ms.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},ms.powerOf2=function(t){return Math.pow(2,t)};class fs{constructor(){fs.constructor_.apply(this,arguments)}static constructor_(){this._pt=new m,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return ms.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=fs.computeQuadLevel(t),this._env=new O,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ms.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new m((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}}let ys=class extends ps{constructor(){super(),ys.constructor_.apply(this,arguments)}static constructor_(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2}static createNode(t){const e=new fs(t);return new ys(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new O(e);null!==t&&n.expandToInclude(t._env);const s=ys.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=ps.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=ps.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new O(e,n,s,i);return new ys(r,this._level-1)}insertNode(t){g.isTrue(null===this._env||this._env.contains(t._env));const e=ps.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}};class xs{static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return ms.exponent(s)<=xs.MIN_BINARY_EXPONENT}}xs.MIN_BINARY_EXPONENT=-50;class Es extends ps{constructor(){super()}insert(t,e){const n=ps.getSubnodeIndex(t,Es.origin.x,Es.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=ys.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){g.isTrue(t.getEnvelope().contains(e));const s=xs.isZeroWidth(e.getMinX(),e.getMaxX()),i=xs.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}}Es.origin=new m(0,0);class Is{insert(t,e){}remove(t,e){}query(){}}class Ns{constructor(){Ns.constructor_.apply(this,arguments)}static constructor_(){this._root=null,this._minExtent=1,this._root=new Es}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s+=e/2),i===r&&(i-=e/2,r+=e/2),new O(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=Ns.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new L;return this._root.addAllItems(t),t}remove(t,e){const n=Ns.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}get interfaces_(){return[Is,c]}}var ws=Object.freeze({__proto__:null,Quadtree:Ns});class Cs{getBounds(){}}class Ss{constructor(){Ss.constructor_.apply(this,arguments)}static constructor_(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e}getItem(){return this._item}getBounds(){return this._bounds}get interfaces_(){return[Cs,c]}}class Ls{constructor(){Ls.constructor_.apply(this,arguments)}static constructor_(){this._size=null,this._items=null,this._size=0,this._items=new L,this._items.add(null)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}}class Ts{constructor(){Ts.constructor_.apply(this,arguments)}static constructor_(){if(this._childBoundables=new L,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){g.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}get interfaces_(){return[Cs,c]}}class Rs{static maxDistance(t,e,n,s,i,r,o,l){let a=Rs.distance(t,e,i,r);return a=Math.max(a,Rs.distance(t,e,o,l)),a=Math.max(a,Rs.distance(n,s,i,r)),a=Math.max(a,Rs.distance(n,s,o,l)),a}static distance(t,e,n,s){const i=n-t,r=s-e;return Math.sqrt(i*i+r*r)}static maximumDistance(t,e){const n=Math.min(t.getMinX(),e.getMinX()),s=Math.min(t.getMinY(),e.getMinY()),i=Math.max(t.getMaxX(),e.getMaxX()),r=Math.max(t.getMaxY(),e.getMaxY());return Rs.distance(n,s,i,r)}static minMaxDistance(t,e){const n=t.getMinX(),s=t.getMinY(),i=t.getMaxX(),r=t.getMaxY(),o=e.getMinX(),l=e.getMinY(),a=e.getMaxX(),c=e.getMaxY();let h=Rs.maxDistance(n,s,n,r,o,l,o,c);return h=Math.min(h,Rs.maxDistance(n,s,n,r,o,l,a,l)),h=Math.min(h,Rs.maxDistance(n,s,n,r,a,c,o,c)),h=Math.min(h,Rs.maxDistance(n,s,n,r,a,c,a,l)),h=Math.min(h,Rs.maxDistance(n,s,i,s,o,l,o,c)),h=Math.min(h,Rs.maxDistance(n,s,i,s,o,l,a,l)),h=Math.min(h,Rs.maxDistance(n,s,i,s,a,c,o,c)),h=Math.min(h,Rs.maxDistance(n,s,i,s,a,c,a,l)),h=Math.min(h,Rs.maxDistance(i,r,n,r,o,l,o,c)),h=Math.min(h,Rs.maxDistance(i,r,n,r,o,l,a,l)),h=Math.min(h,Rs.maxDistance(i,r,n,r,a,c,o,c)),h=Math.min(h,Rs.maxDistance(i,r,n,r,a,c,a,l)),h=Math.min(h,Rs.maxDistance(i,r,i,s,o,l,o,c)),h=Math.min(h,Rs.maxDistance(i,r,i,s,o,l,a,l)),h=Math.min(h,Rs.maxDistance(i,r,i,s,a,c,o,c)),h=Math.min(h,Rs.maxDistance(i,r,i,s,a,c,a,l)),h}}class Ps{constructor(){Ps.constructor_.apply(this,arguments)}static constructor_(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof Ts}maximumDistance(){return Rs.maximumDistance(this._boundable1.getBounds(),this._boundable2.getBounds())}expandToQueue(t,e){const n=Ps.isComposite(this._boundable1),i=Ps.isComposite(this._boundable2);if(n&&i)return Ps.area(this._boundable1)>Ps.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,!1,t,e),null):(this.expand(this._boundable2,this._boundable1,!0,t,e),null);if(n)return this.expand(this._boundable1,this._boundable2,!1,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,!0,t,e),null;throw new s("neither boundable is composite")}isLeaves(){return!(Ps.isComposite(this._boundable1)||Ps.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s,i){for(let r=t.getChildBoundables().iterator();r.hasNext();){const t=r.next();let o=null;o=n?new Ps(e,t,this._itemDistance):new Ps(t,e,this._itemDistance),o.getDistance()<i&&s.add(o)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}get interfaces_(){return[o]}}class Os{constructor(){Os.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._built=!1,this._itemBoundables=new L,this._nodeCapacity=null,0===arguments.length)Os.constructor_.call(this,Os.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];g.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(I(arguments[2],De)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ts?this.queryInternal(t,i,e):i instanceof Ss?e.visitItem(i.getItem()):g.shouldNeverReachHere())}}else if(I(arguments[2],C)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ts?this.queryInternal(t,i,e):i instanceof Ss?e.add(i.getItem()):g.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof Ts?t+=this.size(n):n instanceof Ss&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof Ss&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new L:t}if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof Ts){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof Ss?e.add(t.getItem()):g.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){g.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new Ss(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new L;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(g.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof Ts?this.boundablesAtLevel(t,e,n):(g.isTrue(e instanceof Ss),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new L;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof Ts&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){g.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof Ts){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=new L;n.add(this.createNode(e));const s=new L(t);xe.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}get interfaces_(){return[c]}}Os.IntersectsOp=function(){},Os.DEFAULT_NODE_CAPACITY=10;class vs{distance(t,e){}}class bs extends Os{constructor(){super(),bs.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)bs.constructor_.call(this,bs.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];Os.constructor_.call(this,t)}}static centreX(t){return bs.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return bs.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){g.isTrue(t.length>0);const n=new L;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}nearestNeighbourK(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.nearestNeighbourK(t,r.POSITIVE_INFINITY,e)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=arguments[1];const s=new Ls;s.add(t);const i=new Ls;for(;!s.isEmpty()&&n>=0;){const t=s.poll(),r=t.getDistance();if(r>=n)break;if(t.isLeaves())if(i.size()<e)i.add(t);else{i.peek().getDistance()>r&&(i.poll(),i.add(t));n=i.peek().getDistance()}else t.expandToQueue(s,n)}return bs.getItems(i)}}createNode(t){return new Ms(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return bs.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new L;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return bs.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new L(t);xe.sort(s,bs.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(I(arguments[0],vs)){const t=arguments[0];if(this.isEmpty())return null;const e=new Ps(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof Ps){const t=arguments[0];let e=r.POSITIVE_INFINITY,n=null;const s=new Ls;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return null===n?null:[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}}else{if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isEmpty()||t.isEmpty())return null;const n=new Ps(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(3===arguments.length){const t=arguments[2],e=new Ss(arguments[0],arguments[1]),n=new Ps(this.getRoot(),e,t);return this.nearestNeighbour(n)[0]}if(4===arguments.length){const t=arguments[2],e=arguments[3],n=new Ss(arguments[0],arguments[1]),s=new Ps(this.getRoot(),n,t);return this.nearestNeighbourK(s,e)}}}isWithinDistance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=r.POSITIVE_INFINITY;const s=new Ls;for(s.add(t);!s.isEmpty();){const t=s.poll(),i=t.getDistance();if(i>e)return!1;if(t.maximumDistance()<=e)return!0;if(t.isLeaves()){if(n=i,n<=e)return!0}else t.expandToQueue(s,n)}return!1}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Ps(this.getRoot(),t.getRoot(),e);return this.isWithinDistance(s,n)}}get interfaces_(){return[Is,c]}}class Ms extends Ts{constructor(){super(),Ms.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0];Ts.constructor_.call(this,t)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new O(n.getBounds()):t.expandToInclude(n.getBounds())}return t}}bs.STRtreeNode=Ms,bs.xComparator=new class{get interfaces_(){return[a]}compare(t,e){return Os.compareDoubles(bs.centreX(t.getBounds()),bs.centreX(e.getBounds()))}},bs.yComparator=new class{get interfaces_(){return[a]}compare(t,e){return Os.compareDoubles(bs.centreY(t.getBounds()),bs.centreY(e.getBounds()))}},bs.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},bs.DEFAULT_NODE_CAPACITY=10;var Ds=Object.freeze({__proto__:null,STRtree:bs}),As=Object.freeze({__proto__:null,kdtree:_s,quadtree:ws,strtree:Ds});const Fs=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class Gs{constructor(t){this.geometryFactory=t||new Lt}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!qs[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==Fs.indexOf(n)?qs[n].call(this,e.coordinates):"GeometryCollection"===n?qs[n].call(this,e.geometries):qs[n].call(this,e)}write(t){const e=t.getGeometryType();if(!Bs[e])throw new Error("Geometry is not supported");return Bs[e].call(this,t)}}const qs={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!qs[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=qs.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new m(...s))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new m(t[0],t[1]),new m(t[2],t[1]),new m(t[2],t[3]),new m(t[0],t[3]),new m(t[0],t[1])])},Point:function(t){const e=new m(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(qs.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=qs.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(qs.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=qs.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=qs.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(qs.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},Bs={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:Bs.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(Bs.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=Bs.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=Bs.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(Bs[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Ys(t){return[t.x,t.y]}var Vs=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new Gs(t||new Lt)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new Gs(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Lt,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new m(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Ys);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Ys);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Ys)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Ys));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Ys))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Ht(t||new Lt)}read(t){return this.parser.read(t)}},WKTWriter:Wt});class zs{static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=zs.relativeSign(e.x,n.x),i=zs.relativeSign(e.y,n.y);switch(t){case 0:return zs.compareValue(s,i);case 1:return zs.compareValue(i,s);case 2:return zs.compareValue(i,-s);case 3:return zs.compareValue(-s,i);case 4:return zs.compareValue(-s,-i);case 5:return zs.compareValue(-i,-s);case 6:return zs.compareValue(-i,s);case 7:return zs.compareValue(s,-i)}return g.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}}class Xs{constructor(){Xs.constructor_.apply(this,arguments)}static constructor_(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new m(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:this._isInterior?e._isInterior?zs.compare(this._segmentOctant,this.coord,e.coord):1:-1}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}toString(){return this.segmentIndex+":"+this.coord.toString()}isInterior(){return this._isInterior}get interfaces_(){return[o]}}class ks{constructor(){ks.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn,this._edge=null;const t=arguments[0];this._edge=t}getSplitCoordinates(){const t=new R;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new L;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}createSplitEdgePts(t,e){let n=e.segmentIndex-t.segmentIndex+2;if(2===n)return[new m(t.coord),new m(e.coord)];const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new m(e.coord)),r}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e);this._edge.getCoordinate(e+1);const s=this._edge.getCoordinate(e+2);n.equals2D(s)&&t.add(b.valueOf(e+1))}}addEdgeCoordinates(t,e,n){const s=this.createSplitEdgePts(t,e);n.add(s,!1)}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(b.valueOf(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){const n=this.createSplitEdgePts(t,e);return new Zs(n,this._edge.getData())}add(t,e){const n=new Xs(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(g.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new h("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new h("bad split edge end point at "+i)}}class Us{static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the octant for point ( "+t+", "+e+" )");const n=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?n>=i?0:1:n>=i?7:6:e>=0?n>=i?3:2:n>=i?4:5}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,i=e.y-t.y;if(0===n&&0===i)throw new s("Cannot compute the octant for two identical points "+t);return Us.octant(n,i)}}}class Hs{getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}}class Ws{addIntersection(t,e){}get interfaces_(){return[Hs]}}class Zs{constructor(){Zs.constructor_.apply(this,arguments)}static constructor_(){this._nodeList=new ks(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new L;return Zs.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){e.next().getNodeList().addSplitEdges(t)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Us.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[1],e=arguments[3],n=new m(arguments[0].getIntersection(e));this.addIntersection(n,t)}}toString(){return Wt.toLineString(new mt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}get interfaces_(){return[Ws]}}class js{constructor(){js.constructor_.apply(this,arguments)}static constructor_(){this._overlapSeg1=new Kt,this._overlapSeg2=new Kt}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];arguments[0].getLineSegment(t,this._overlapSeg1),e.getLineSegment(n,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}}class Ks{constructor(){Ks.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new O(t,e)}return this._env}overlaps(t,e,n,s,i){return O.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}}class Qs{static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=Cn.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(Cn.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Qs.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;let s=0;do{const i=Qs.findChainEnd(t,s),r=new Ks(t,s,i,e);n.add(r),s=i}while(s<t.length-1);return n}}}class Js{computeNodes(t){}getNodedSubstrings(){}}class $s{constructor(){$s.constructor_.apply(this,arguments)}static constructor_(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}}setSegmentIntersector(t){this._segInt=t}get interfaces_(){return[Js]}}class ti extends $s{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){if(this._monoChains=new L,this._index=new bs,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];$s.constructor_.call(this,t)}}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Zs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Qs.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new ei(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}}class ei extends js{constructor(){super(),ei.constructor_.apply(this,arguments)}static constructor_(){this._si=null;const t=arguments[0];this._si=t}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[1],e=arguments[2],n=arguments[3],s=arguments[0].getContext(),i=e.getContext();this._si.processIntersections(s,t,i,n)}}}ti.SegmentOverlapAction=ei;class ni{constructor(){ni.constructor_.apply(this,arguments)}static constructor_(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ni.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}}rescale(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&Y.out.println(t)}}scale(){if(I(arguments[0],N)){const t=arguments[0],e=new L(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Zs(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new m(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].getZ());return _t.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}get interfaces_(){return[Js]}}var si=Object.freeze({__proto__:null,MCIndexNoder:ti,ScaledNoder:ni,SegmentString:Hs});class ii{constructor(){ii.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];ii.constructor_.call(this,t,gn.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}}static getBoundary(){if(1===arguments.length){return new ii(arguments[0]).getBoundary()}if(2===arguments.length){return new ii(arguments[0],arguments[1]).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof $?this.boundaryLineString(this._geom):this._geom instanceof St?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new L;this._endpointMap=new Wn;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return _t.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new ri,this._endpointMap.put(t,e)),e.count++}}let ri=class{constructor(){ri.constructor_.apply(this,arguments)}static constructor_(){this.count=null}};class oi{constructor(){oi.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}}static isSimple(){if(1===arguments.length){return new oi(arguments[0]).isSimple()}if(2===arguments.length){return new oi(arguments[0],arguments[1]).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new at;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new Wn;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.isClosed(),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new as(0,t),n=new jt,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new li(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof $||t instanceof St?this.isSimpleLinearGeometry(t):t instanceof ut?this.isSimpleMultiPoint(t):I(t,it)?this.isSimplePolygonal(t):!(t instanceof ht)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}}class li{constructor(){li.constructor_.apply(this,arguments)}static constructor_(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}}oi.EndpointInfo=li;class ai{constructor(){ai.constructor_.apply(this,arguments)}static constructor_(){if(this._quadrantSegments=ai.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=ai.CAP_ROUND,this._joinStyle=ai.JOIN_ROUND,this._mitreLimit=ai.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=ai.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=ai.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=ai.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==ai.JOIN_ROUND&&(this._quadrantSegments=ai.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}}ai.CAP_ROUND=1,ai.CAP_FLAT=2,ai.CAP_SQUARE=3,ai.JOIN_ROUND=1,ai.JOIN_MITRE=2,ai.JOIN_BEVEL=3,ai.DEFAULT_QUADRANT_SEGMENTS=8,ai.DEFAULT_MITRE_LIMIT=5,ai.DEFAULT_SIMPLIFY_FACTOR=.01;class ci{constructor(){ci.constructor_.apply(this,arguments)}static constructor_(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();g.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=q.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===q.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===q.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=bn.LEFT;return n[e].y<n[e+1].y&&(s=bn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}g.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe;this.getRightmostSide(this._minDe,this._minIndex)===bn.LEFT&&(this._orientedDe=this._minDe.getSym())}}class hi{constructor(){this.array=[]}addLast(t){this.array.push(t)}removeFirst(){return this.array.shift()}isEmpty(){return 0===this.array.length}}class ui{constructor(){ui.constructor_.apply(this,arguments)}static constructor_(){this._finder=null,this._dirEdgeList=new L,this._nodes=new L,this._rightMostCoord=null,this._env=null,this._finder=new ci}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new is("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel(),e.setEdgeDepths(bn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(bn.RIGHT)>=1&&e.getDepth(bn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new Et,n=new hi,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new O;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new en;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(bn.LEFT,t.getDepth(bn.RIGHT)),e.setDepth(bn.RIGHT,t.getDepth(bn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}get interfaces_(){return[o]}}let gi=class{constructor(){gi.constructor_.apply(this,arguments)}static constructor_(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new L,this._pts=new L,this._label=new Bn(Qt.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new L,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=q.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new is("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new is("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();g.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!Ue.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[1],e=arguments[0].getLocation(t,bn.RIGHT);if(e===Qt.NONE)return null;if(this._label.getLocation(t)===Qt.NONE)return this._label.setLocation(t,e),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}};class di extends gi{constructor(){super(),di.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];gi.constructor_.call(this,t,e)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}}class _i extends gi{constructor(){super(),_i.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];gi.constructor_.call(this,t,e)}buildMinimalRings(){const t=new L;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new di(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}}class pi{constructor(){pi.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=null,this._shellList=new L;const t=arguments[0];this._geometryFactory=t}static findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getLinearRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=_t.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;Ue.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getLinearRing().getEnvelopeInternal())}return r}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=pi.findEdgeRingContaining(e,t);if(null===n)throw new is("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}buildMaximalEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new _i(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return g.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ls.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new L,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}}class mi{constructor(){mi.constructor_.apply(this,arguments)}static constructor_(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=q.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t}static simplify(t,e){return new mi(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=mi.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){if(!(q.index(t,e,n)===this._angleOrientation))return!1;return z.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/mi.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return q.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=q.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===mi.DELETE;)e++;return e}isShallow(t,e,n,s){return z.pointToSegment(e,t,n)<s}collapseLine(){const t=new R;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==mi.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}}mi.INIT=0,mi.DELETE=1,mi.KEEP=1,mi.NUM_PTS_TO_CHECK=10;class fi{constructor(){fi.constructor_.apply(this,arguments)}static constructor_(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new L}getCoordinates(){return this._ptList.toArray(fi.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new m(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Lt).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new m(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}}fi.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class yi{constructor(){yi.constructor_.apply(this,arguments)}static constructor_(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new Kt,this._seg1=new Kt,this._offset0=new Kt,this._offset1=new Kt,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new jt,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===ai.JOIN_ROUND&&(this._closingSegLengthFactor=yi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=q.index(this._s0,this._s1,this._s2),s=n===q.CLOCKWISE&&this._side===bn.LEFT||n===q.COUNTERCLOCKWISE&&this._side===bn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new Kt(t,e),s=new Kt;this.computeOffsetSegment(n,bn.LEFT,this._distance,s);const i=new Kt;this.computeOffsetSegment(n,bn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case ai.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,q.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case ai.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case ai.CAP_SQUARE:const t=new m;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new m(s.p1.x+t.x,s.p1.y+t.y),r=new m(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){const i=B.intersection(e.p0,e.p1,n.p0,n.p1);if(null!==i){if((s<=0?1:i.distance(t)/Math.abs(s))<=this._bufParams.getMitreLimit())return this._segList.addPt(i),null}this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*yi.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===ai.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===ai.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new m(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new m(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===q.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=$t.angle(i,this._seg0.p0),o=$t.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2,l=$t.normalize(r+o),a=$t.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),g=i.y+c*Math.sin(a),d=new m(u,g),_=new Kt(i,d),p=_.pointAlongOffset(1,h),f=_.pointAlongOffset(1,-h);this._side===bn.LEFT?(this._segList.addPt(p),this._segList.addPt(f)):(this._segList.addPt(f),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===q.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;const a=o/l,c=new m;for(let n=0;n<l;n++){const s=e+r*n*a;c.x=t.x+i*Math.cos(s),c.y=t.y+i*Math.sin(s),this._segList.addPt(c)}}computeOffsetSegment(t,e,n,s){const i=e===bn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*yi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new m((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new m((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new m(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new fi,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*yi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2);this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===ai.JOIN_BEVEL||this._bufParams.getJoinStyle()===ai.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,q.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}}yi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,yi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,yi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,yi.MAX_CLOSING_SEG_LEN_FACTOR=80;class xi{constructor(){xi.constructor_.apply(this,arguments)}static constructor_(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new m(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&_t.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=mi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],bn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=mi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],bn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===bn.RIGHT&&(s=-s);const i=mi.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=mi.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],bn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=mi.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],bn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case ai.CAP_ROUND:e.createCircle(t);break;case ai.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,this.isLineOffsetEmpty(e))return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return xi.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=mi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],bn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=mi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],bn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}isLineOffsetEmpty(t){return 0===t||t<0&&!this._bufParams.isSingleSided()}getSegGen(t){return new yi(this._precisionModel,this._bufParams,t)}}class Ei{constructor(){Ei.constructor_.apply(this,arguments)}static constructor_(){this._subgraphs=null,this._seg=new Kt;const t=arguments[0];this._subgraphs=t}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(I(arguments[2],C)&&arguments[0]instanceof m&&arguments[1]instanceof rs){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse();if(Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(q.index(this._seg.p0,this._seg.p1,t)===q.RIGHT)continue;let r=e.getDepth(bn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(bn.RIGHT));const o=new Ii(this._seg,r);n.add(o)}}else if(I(arguments[2],C)&&arguments[0]instanceof m&&I(arguments[1],C)){const t=arguments[0],e=arguments[2];for(let n=arguments[1].iterator();n.hasNext();){const s=n.next();s.isForward()&&this.findStabbedSegments(t,s,e)}}}getDepth(t){const e=this.findStabbedSegments(t);if(0===e.size())return 0;return xe.min(e)._leftDepth}}class Ii{constructor(){Ii.constructor_.apply(this,arguments)}static constructor_(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new Kt(t),this._leftDepth=e}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}get interfaces_(){return[o]}}Ei.DepthSegment=Ii;class Ni{constructor(){Ni.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n}addRingSide(t,e,n,s,i){if(0===e&&t.length<gt.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=gt.MINIMUM_VALID_SIZE&&q.isCCW(t)&&(r=i,o=s,n=bn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}addRingBothSides(t,e){this.addRingSide(t,e,bn.LEFT,Qt.EXTERIOR,Qt.INTERIOR),this.addRingSide(t,e,bn.RIGHT,Qt.INTERIOR,Qt.EXTERIOR)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,Qt.EXTERIOR,Qt.INTERIOR)}addPolygon(t){let e=this._distance,n=bn.LEFT;this._distance<0&&(e=-this._distance,n=bn.RIGHT);const s=t.getExteriorRing(),i=_t.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addRingSide(i,e,n,Qt.EXTERIOR,Qt.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=_t.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addRingSide(r,e,bn.opposite(n),Qt.INTERIOR,Qt.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new ne(t[0],t[1],t[2]),s=n.inCentre();return z.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._curveBuilder.isLineOffsetEmpty(this._distance))return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(_t.isRing(e)&&!this._curveBuilder.getBufferParameters().isSingleSided())this.addRingBothSides(e,this._distance);else{const t=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(t,Qt.EXTERIOR,Qt.INTERIOR)}}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Zs(t,new Bn(0,Qt.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}add(t){if(t.isEmpty())return null;if(t instanceof rt)this.addPolygon(t);else if(t instanceof $)this.addLineString(t);else if(t instanceof et)this.addPoint(t);else if(t instanceof ut)this.addCollection(t);else if(t instanceof St)this.addCollection(t);else if(t instanceof yt)this.addCollection(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}}class wi{constructor(){wi.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new Wn,this._edgeList=null,this._ptInAreaLocation=[Qt.NONE,Qt.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=Qt.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,bn.LEFT)!==Qt.NONE&&(e=s.getLocation(t,bn.LEFT))}if(e===Qt.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,bn.ON)===Qt.NONE&&i.setLocation(t,bn.ON,n),i.isArea(t)){const e=i.getLocation(t,bn.LEFT),r=i.getLocation(t,bn.RIGHT);if(r!==Qt.NONE){if(r!==n)throw new is("side location conflict",s.getCoordinate());e===Qt.NONE&&g.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else g.isTrue(i.getLocation(t,bn.LEFT)===Qt.NONE,"found single null side"),i.setLocation(t,bn.RIGHT,n),i.setLocation(t,bn.LEFT,n)}}}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}print(t){Y.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,bn.LEFT);g.isTrue(s!==Qt.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();g.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,bn.LEFT),r=n.getLocation(t,bn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new L(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===Qt.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new v;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===Qt.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=Qt.NONE;if(e[n])r=Qt.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}}let Ci=class extends wi{constructor(){super(),Ci.constructor_.apply(this,arguments)}static constructor_(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new is("no outgoing dirEdge found",this.getCoordinate());g.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return Cn.isNorthern(i)&&Cn.isNorthern(r)?n:Cn.isNorthern(i)||Cn.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(g.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){Y.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new L;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(bn.LEFT),s=t.getDepth(bn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new is("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[1];let e=arguments[2];for(let n=arguments[0];n<t;n++){const t=this._edgeList.get(n);t.setEdgeDepths(bn.RIGHT,e),e=t.getDepth(bn.LEFT)}return e}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(g.isTrue(null!==e,"found null for first outgoing dirEdge"),g.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=Qt.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=Qt.INTERIOR;break}if(s.isInResult()){t=Qt.EXTERIOR;break}}}if(t===Qt.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===Qt.INTERIOR):(n.isInResult()&&(e=Qt.EXTERIOR),s.isInResult()&&(e=Qt.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Bn(Qt.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==Qt.INTERIOR&&n!==Qt.BOUNDARY||this._label.setLocation(t,Qt.INTERIOR)}}}};class Si extends os{constructor(){super()}createNode(t){return new es(t,new Ci)}}class Li{constructor(){Li.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=Li.orientation(t)}static orientation(t){return 1===_t.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return Li.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}get interfaces_(){return[o]}}class Ti{constructor(){Ti.constructor_.apply(this,arguments)}static constructor_(){this._edges=new L,this._ocaMap=new Wn}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new Li(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new Li(t.getCoordinates());this._ocaMap.put(e,t)}}class Ri{processIntersections(t,e,n,s){}isDone(){}}class Pi{constructor(){Pi.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Pi.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}get interfaces_(){return[Ri]}}class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static constructor_(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Ti;const t=arguments[0];this._bufParams=t}static depthDelta(t){const e=t.getLocation(0,bn.LEFT),n=t.getLocation(0,bn.RIGHT);return e===Qt.INTERIOR&&n===Qt.EXTERIOR?1:e===Qt.EXTERIOR&&n===Qt.INTERIOR?-1:0}static convertSegStrings(t){const e=new Lt,n=new L;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Bn(t.getLabel()),s.flip()),n.merge(s);const i=Oi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(Oi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new Ei(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new L;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new ui;n.create(t),e.add(n)}}return xe.sort(e,xe.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new ti,n=new jt;return n.setPrecisionModel(t),e.setSegmentIntersector(new Pi(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new xi(n,this._bufParams),i=new Ni(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new ls(new Si),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new pi(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();if(l.size()<=0)return this.createEmptyResultGeometry();return this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new ts(e.getCoordinates(),new Bn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}}class vi{constructor(){vi.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null;const t=arguments[0];this._segStrings=t}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new h("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new h("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new h("found non-noded collapse at "+vi.fact.createLineString([t,e,n]))}}vi.fact=new Lt;class bi{constructor(){bi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new s("Scale factor must be non-zero");1!==e&&(this._pt=new m(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new m,this._p1Scaled=new m),this.initCorners(this._pt)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return g.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){const e=.5;this._minx=t.x-e,this._maxx=t.x+e,this._miny=t.y-e,this._maxy=t.y+e,this._corner[0]=new m(this._maxx,this._maxy),this._corner[1]=new m(this._minx,this._maxy),this._corner[2]=new m(this._minx,this._miny),this._corner[3]=new m(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=bi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new O(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}}bi.SAFE_ENV_EXPANSION_FACTOR=.75;class Mi{constructor(){Mi.constructor_.apply(this,arguments)}static constructor_(){this.selectedSegment=new Kt}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[1];arguments[0].getLineSegment(t,this.selectedSegment),this.select(this.selectedSegment)}}}class Di{constructor(){Di.constructor_.apply(this,arguments)}static constructor_(){this._index=null;const t=arguments[0];this._index=t}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Ai(t,e,n);return this._index.query(s,new class{get interfaces_(){return[De]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}}class Ai extends Mi{constructor(){super(),Ai.constructor_.apply(this,arguments)}static constructor_(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof Ks))return super.select.apply(this,arguments);{const t=arguments[1],e=arguments[0].getContext();if(this._parentEdge===e&&(t===this._hotPixelVertexIndex||t+1===this._hotPixelVertexIndex))return null;this._isNodeAdded|=this._hotPixel.addSnappedNode(e,t)}}}Di.HotPixelSnapAction=Ai;class Fi{constructor(){Fi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new L}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}get interfaces_(){return[Ri]}}class Gi{constructor(){Gi.constructor_.apply(this,arguments)}static constructor_(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new jt,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()}checkCorrectness(t){const e=Zs.getNodedSubstrings(t),s=new vi(e);try{s.checkValid()}catch(t){if(!(t instanceof n))throw t;t.printStackTrace()}}getNodedSubstrings(){return Zs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Fi(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Zs){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new bi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new ti,this._pointSnapper=new Di(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new bi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}get interfaces_(){return[Js]}}class qi{constructor(){qi.constructor_.apply(this,arguments)}static constructor_(){if(this._argGeom=null,this._distance=null,this._bufParams=new ai,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}}static bufferOp(){if(2===arguments.length){const t=arguments[1];return new qi(arguments[0]).getResultGeometry(t)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof U&&"number"==typeof arguments[1]){const t=arguments[1],e=arguments[2],n=new qi(arguments[0]);n.setQuadrantSegments(e);return n.getResultGeometry(t)}if(arguments[2]instanceof ai&&arguments[0]instanceof U&&"number"==typeof arguments[1]){const t=arguments[1];return new qi(arguments[0],arguments[2]).getResultGeometry(t)}}else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3],s=new qi(arguments[0]);s.setQuadrantSegments(e),s.setEndCapStyle(n);return s.getResultGeometry(t)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=V.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ni(new Gi(new wt(1)),t.getScale()),n=new Oi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=qi.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof is))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=qi.precisionScaleFactor(this._argGeom,this._distance,t),n=new wt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===wt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new Oi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof h))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}}qi.CAP_ROUND=ai.CAP_ROUND,qi.CAP_BUTT=ai.CAP_FLAT,qi.CAP_FLAT=ai.CAP_FLAT,qi.CAP_SQUARE=ai.CAP_SQUARE,qi.MAX_PRECISION_DIGITS=12;var Bi=Object.freeze({__proto__:null,BufferOp:qi,BufferParameters:ai});class Yi{constructor(){Yi.constructor_.apply(this,arguments)}static constructor_(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Yi.constructor_.call(this,t,Yi.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}}getSegmentIndex(){return this._segIndex}getCoordinate(){return this._pt}isInsideArea(){return this._segIndex===Yi.INSIDE_AREA}toString(){return this._component.getGeometryType()+"["+this._segIndex+"]-"+Wt.toPoint(this._pt)}getGeometryComponent(){return this._component}}Yi.INSIDE_AREA=-1;class Vi{constructor(){Vi.constructor_.apply(this,arguments)}static constructor_(){this._locations=null;const t=arguments[0];this._locations=t}static getLocations(t){const e=new L;return t.apply(new Vi(e)),e}filter(t){if(t.isEmpty())return null;(t instanceof et||t instanceof $||t instanceof rt)&&this._locations.add(new Yi(t,0,t.getCoordinate()))}get interfaces_(){return[J]}}class zi{constructor(){zi.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new fn,this._minDistanceLocation=null,this._minDistance=r.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];zi.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}}static distance(t,e){return new zi(t,e).distance()}static isWithinDistance(t,e,n){if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)return!1;return new zi(t,e,n).distance()<=n}static nearestPoints(t,e){return new zi(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ie.getPolygons(n);if(i.size()>0){const n=Vi.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&I(arguments[0],C)&&I(arguments[1],C)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Yi&&arguments[1]instanceof rt){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(Qt.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Yi(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=ye.getLines(this._geom[0]),n=ye.getLines(this._geom[1]),s=Ee.getPoints(this._geom[0]),i=Ee.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){this.computeMinDistance();return[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof $&&arguments[1]instanceof et){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=z.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new Kt(s[r],s[r+1]).closestPoint(i);n[0]=new Yi(t,r,l),n[1]=new Yi(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof $&&arguments[1]instanceof $){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++){const o=new O(s[r],s[r+1]);if(!(o.distance(e.getEnvelopeInternal())>this._minDistance))for(let l=0;l<i.length-1;l++){const a=new O(i[l],i[l+1]);if(o.distance(a)>this._minDistance)continue;const c=z.segmentToSegment(s[r],s[r+1],i[l],i[l+1]);if(c<this._minDistance){this._minDistance=c;const o=new Kt(s[r],s[r+1]),a=new Kt(i[l],i[l+1]),h=o.closestPoints(a);n[0]=new Yi(t,r,h[0]),n[1]=new Yi(e,l,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Yi(i,0,i.getCoordinate()),n[1]=new Yi(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new s("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}}var Xi=Object.freeze({__proto__:null,DistanceOp:zi});class ki{constructor(){ki.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._directedEdges=new L,this._coordinates=null;const t=arguments[0];this._factory=t}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new R;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&_t.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}}class Ui{constructor(){Ui.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1,this._isVisited=!1,this._data=null}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}}class Hi extends Ui{constructor(){super(),Hi.constructor_.apply(this,arguments)}static constructor_(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=Cn.quadrant(i,r),this._angle=Math.atan2(r,i)}}static toEdges(t){const e=new L;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:q.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}get interfaces_(){return[o]}}class Wi extends Hi{constructor(){super(),Wi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hi.constructor_.call(this,t,e,n,s)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(g.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}}class Zi extends Ui{constructor(){super(),Zi.constructor_.apply(this,arguments)}static constructor_(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Ki){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}}class ji{constructor(){ji.constructor_.apply(this,arguments)}static constructor_(){this._outEdges=new L,this._sorted=!1}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(xe.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Zi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof Hi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}}class Ki extends Ui{constructor(){super(),Ki.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];Ki.constructor_.call(this,t,new ji)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}}static getEdgesBetween(t,e){const n=Hi.toEdges(t.getOutEdges().getEdges()),s=new Et(n),i=Hi.toEdges(e.getOutEdges().getEdges());return s.retainAll(i),s}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}}class Qi extends Zi{constructor(){super(),Qi.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}}class $i{constructor(){$i.constructor_.apply(this,arguments)}static constructor_(){this._edges=new Et,this._dirEdges=new Et,this._nodeMap=new Ji}findNodesOfDegree(t){const e=new L;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Zi){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof Hi){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Ki){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Zi){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof Hi){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Ki){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Zi){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof Hi){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}}class tr extends $i{constructor(){super()}addEdge(t){if(t.isEmpty())return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Wi(i,r,e[1],!0),l=new Wi(r,i,e[e.length-2],!1),a=new Qi(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new Ki(t),this.add(e)),e}}class er{constructor(){er.constructor_.apply(this,arguments)}static constructor_(){this._graph=new tr,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(g.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Ui.setMarked(this._graph.nodeIterator(),!1),Ui.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new L,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new L;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new ki(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof U){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof $&&this.addLineString(n)}}else if(I(arguments[0],N)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}}class nr{constructor(){nr.constructor_.apply(this,arguments)}static constructor_(){this._parentGraph=null,this._edges=new Et,this._dirEdges=new L,this._nodeMap=new Ji;const t=arguments[0];this._parentGraph=t}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}}class sr{constructor(){sr.constructor_.apply(this,arguments)}static constructor_(){this._graph=null;const t=arguments[0];this._graph=t}addReachable(t,e){const n=new en;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new nr(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new L;Ui.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}}class ir{constructor(){ir.constructor_.apply(this,arguments)}static constructor_(){this._graph=new tr,this._factory=new Lt,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=b.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof St))return!0;const e=t,n=new at;let s=null;const i=new L;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new m(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new ir;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();g.isTrue(this._lineCount===e,"Lines were missing from result"),g.isTrue(this._sequencedGeometry instanceof $||this._sequencedGeometry instanceof St,"Result is not lineal")}findSequences(){const t=new L;for(let e=new sr(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=ir.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&g.isTrue(i===s,"path not contiguous")}findSequence(t){Ui.setVisited(t.edgeIterator(),!1);const e=ir.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new hi,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=ir.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new hi;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new L;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=ir.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof U){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof $&&this.addLine(t)}})}}}var rr=Object.freeze({__proto__:null,LineMerger:er,LineSequencer:ir});class or{constructor(){or.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new Kt,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof $&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];or.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=or.isClosed(t),this._snapTolerance=e}}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new m(i)),0===s&&this._isClosed&&t.set(t.size()-1,new m(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new R(this._srcPts);this.snapVertices(e,t),this.snapSegments(e,t);return e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new m(n),!1)}}findSegmentIndexToSnap(t,e){let n=r.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}}class lr{constructor(){lr.constructor_.apply(this,arguments)}static constructor_(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t}static snap(t,e,n){const s=new Array(2).fill(null),i=new lr(t);s[0]=i.snapTo(e,n);const r=new lr(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=lr.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===wt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(lr.computeOverlaySnapTolerance(t),lr.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*lr.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new lr(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new ar(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new ar(t,n,!0).transform(this._srcGeom);let i=s;return e&&I(i,it)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new at,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=r.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}}lr.SNAP_PRECISION_FACTOR=1e-9;class ar extends me{constructor(){super(),ar.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}}snapLine(t,e){const n=new or(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}}var cr=Object.freeze({__proto__:null,GeometrySnapper:lr,LineStringSnapper:or});class hr{constructor(){hr.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Us.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Wt.toLineString(new mt(this._pts))}get interfaces_(){return[Hs]}}class ur{constructor(){ur.constructor_.apply(this,arguments)}static constructor_(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._keepIntersections=!0,this._isInteriorIntersectionsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new L,this._intersectionCount=0;const t=arguments[0];this._li=t,this._interiorIntersection=null}static createAllIntersectionsFinder(t){const e=new ur(t);return e.setFindAllIntersections(!0),e}static isInteriorVertexIntersection(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3];return(!arguments[2]||!n)&&!!t.equals2D(e)}if(8===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6],l=arguments[7];return!!ur.isInteriorVertexIntersection(t,n,i,o)||(!!ur.isInteriorVertexIntersection(t,s,i,l)||(!!ur.isInteriorVertexIntersection(e,n,r,o)||!!ur.isInteriorVertexIntersection(e,s,r,l)))}}static createInteriorIntersectionCounter(t){const e=new ur(t);return e.setInteriorIntersectionsOnly(!0),e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static createIntersectionCounter(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static isEndSegment(t,e){return 0===e||e>=t.size()-2}static createAnyIntersectionFinder(t){return new ur(t)}static createInteriorIntersectionsFinder(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.setInteriorIntersectionsOnly(!0),e}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}getIntersection(){return this._interiorIntersection}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;const i=t===n;if(i&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(ur.isEndSegment(t,e)||ur.isEndSegment(n,s)))return null}const r=t.getCoordinate(e),o=t.getCoordinate(e+1),l=n.getCoordinate(s),a=n.getCoordinate(s+1),c=0===e,h=e+2===t.size(),u=0===s,g=s+2===n.size();this._li.computeIntersection(r,o,l,a);const d=this._li.hasIntersection()&&this._li.isInteriorIntersection();let _=!1;if(!this._isInteriorIntersectionsOnly){_=!(i&&Math.abs(s-e)<=1)&&ur.isInteriorVertexIntersection(r,o,l,a,c,h,u,g)}(d||_)&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=r,this._intSegments[1]=o,this._intSegments[2]=l,this._intSegments[3]=a,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}setInteriorIntersectionsOnly(t){this._isInteriorIntersectionsOnly=t}get interfaces_(){return[Ri]}}class gr{constructor(){gr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t}static computeIntersections(t){const e=new gr(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new ur(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new ti;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new is(this.getErrorMessage(),this._segInt.getIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Wt.toLineString(t[0],t[1])+" and "+Wt.toLineString(t[2],t[3])}}class dr{constructor(){dr.constructor_.apply(this,arguments)}static constructor_(){this._nv=null;const t=arguments[0];this._nv=new gr(dr.toSegmentStrings(t))}static toSegmentStrings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new hr(t.getCoordinates(),t))}return e}static checkValid(t){new dr(t).checkValid()}checkValid(){this._nv.checkValid()}}class _r{constructor(){_r.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new L,this._resultLineList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!wr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=this._geometryFactory.createLineString(e.getCoordinates());this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(g.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(wr.isResultOfOp(s,e)&&e===wr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}}class pr{constructor(){pr.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._resultPointList=new L;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===wr.INTERSECTION))){const e=n.getLabel();wr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}}class mr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new i,this._commonSignExp=null}getCommon(){return r.longBitsToDouble(this._commonBits)}add(t){const e=r.doubleToLongBits(t);if(this._isFirst)return this._commonBits=e,this._commonSignExp=mr.signExpBits(this._commonBits),this._isFirst=!1,null;if(mr.signExpBits(e)!==this._commonSignExp)return this._commonBits.high=0,this._commonBits.low=0,null;this._commonMantissaBitsCount=mr.numCommonMostSigMantissaBits(this._commonBits,e),this._commonBits=mr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))}toString(){if(1===arguments.length){const t=arguments[0],e=r.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+i.toBinaryString(t),s=n.substring(n.length-64);return s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]"}}getClass(){return mr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(mr.getBit(t,s)!==mr.getBit(e,s))return n;n++}return 52}}class fr{constructor(){fr.constructor_.apply(this,arguments)}static constructor_(){this._commonCoord=null,this._ccFilter=new yr}addCommonBits(t){const e=new xr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new m(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new xr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}}class yr{constructor(){yr.constructor_.apply(this,arguments)}static constructor_(){this._commonBitsX=new mr,this._commonBitsY=new mr}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new m(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}get interfaces_(){return[H]}}class xr{constructor(){xr.constructor_.apply(this,arguments)}static constructor_(){this.trans=null;const t=arguments[0];this.trans=t}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}get interfaces_(){return[P]}}fr.CommonCoordinateFilter=yr,fr.Translater=xr;class Er{constructor(){Er.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()}static overlayOp(t,e,n){return new Er(t,e).getResultGeometry(n)}static union(t,e){return Er.overlayOp(t,e,wr.UNION)}static intersection(t,e){return Er.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){return Er.overlayOp(t,e,wr.SYMDIFFERENCE)}static difference(t,e){return Er.overlayOp(t,e,wr.DIFFERENCE)}selfSnap(t){return new lr(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new fr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=wr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||Y.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=lr.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return lr.snap(e[0],e[1],this._snapTolerance)}}class Ir{constructor(){Ir.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e}static overlayOp(t,e,n){return new Ir(t,e).getResultGeometry(n)}static union(t,e){return Ir.overlayOp(t,e,wr.UNION)}static intersection(t,e){return Ir.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){return Ir.overlayOp(t,e,wr.SYMDIFFERENCE)}static difference(t,e){return Ir.overlayOp(t,e,wr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=wr.overlayOp(this._geom[0],this._geom[1],t); true&&(n=!0)}catch(t){if(!(t instanceof h))throw t;s=t}if(!n)try{e=Er.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof h?s:t}return e}}class Nr{constructor(){Nr.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new jt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new as(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new as(0,t,n),this._arg[1]=new as(1,e,n)}}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}}class wr extends Nr{constructor(){super(),wr.constructor_.apply(this,arguments)}static constructor_(){this._ptLocator=new fn,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new Ti,this._resultPolyList=new L,this._resultLineList=new L,this._resultPointList=new L;const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e),this._graph=new ls(new Si),this._geomFact=t.getFactory()}static overlayOp(t,e,n){return new wr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return wr.createEmptyResult(wr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ce.map(t,new class{get interfaces_(){return[MapOp]}map(t){return wr.intersection(t,n)}})}return Ir.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case wr.INTERSECTION:r=Math.min(s,i);break;case wr.UNION:r=Math.max(s,i);break;case wr.DIFFERENCE:r=s;break;case wr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){const i=wr.resultDimension(t,e,n);return s.createEmpty(i)}static difference(t,e){if(t.isEmpty())return wr.createEmptyResult(wr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return wr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1],n=arguments[2];switch(t===Qt.BOUNDARY&&(t=Qt.INTERIOR),e===Qt.BOUNDARY&&(e=Qt.INTERIOR),n){case wr.INTERSECTION:return t===Qt.INTERIOR&&e===Qt.INTERIOR;case wr.UNION:return t===Qt.INTERIOR||e===Qt.INTERIOR;case wr.DIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR;case wr.SYMDIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR||t!==Qt.INTERIOR&&e===Qt.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Bn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new L;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?wr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==Qt.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new L;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new L;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),dr.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new pi(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new _r(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new pr(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&wr.isResultOfOp(s.getLocation(0,bn.RIGHT),s.getLocation(1,bn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(g.isTrue(!s.isNull(t,bn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,bn.LEFT,s.getLocation(t,bn.LEFT)),g.isTrue(!s.isNull(t,bn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,bn.RIGHT,s.getLocation(t,bn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}}wr.INTERSECTION=1,wr.UNION=2,wr.DIFFERENCE=3,wr.SYMDIFFERENCE=4;var Cr=Object.freeze({__proto__:null,snap:cr,OverlayOp:wr});class Sr extends Hi{constructor(){super(),Sr.constructor_.apply(this,arguments)}static constructor_(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hi.constructor_.call(this,t,e,n,s)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}}class Lr extends Zi{constructor(){super(),Lr.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Tr{constructor(){Tr.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=new Lt,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){if(t.isEmpty())return null;const n=t.getCoordinates(),s=n[0],i=Tr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR&&(l=o.getSym()),g.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof rt){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof yt){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{g.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new _i(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new L;this._geomGraph.computeSplitEdges(t);const e=new ls(new Si);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}}class Rr{createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new ss(t,n.coord,r,new Bn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new Bn(t.getLabel());o.flip();const l=new ss(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}}class Pr extends ss{constructor(){super(),Pr.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new L,1===arguments.length){const t=arguments[0];Pr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];ss.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Bn(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===Qt.BOUNDARY&&n++,i===Qt.INTERIOR&&(s=!0)}let i=Qt.NONE;s&&(i=Qt.INTERIOR),n>0&&(i=as.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===Qt.INTERIOR)return this._label.setLocation(t,e,Qt.INTERIOR),null;n===Qt.EXTERIOR&&this._label.setLocation(t,e,Qt.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,bn.LEFT),this.computeLabelSide(t,bn.RIGHT)}updateIM(t){ts.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Bn(Qt.NONE,Qt.NONE,Qt.NONE):new Bn(Qt.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class Or extends wi{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Pr(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class vr extends es{constructor(){super(),vr.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];es.constructor_.call(this,t,e)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}}class br extends os{constructor(){super()}createNode(t){return new vr(t,new Or)}}class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static constructor_(){this._nodes=new ns(new br)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new Rr).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===Qt.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,Qt.INTERIOR)}}}}class Dr{constructor(){Dr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._geomGraph=null,this._nodeGraph=new Mr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}}class Ar{constructor(){Ar.constructor_.apply(this,arguments)}static constructor_(){this._graph=null,this._rings=new L,this._totalEnv=new O,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t}buildIndex(){this._index=new bs;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Gr.findPtNotNode(n,i,this._graph);if(null===o)continue;if(Ue.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}}class Fr{constructor(){Fr.constructor_.apply(this,arguments)}static constructor_(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Fr.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}}getErrorType(){return this._errorType}getMessage(){return Fr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}}Fr.ERROR=0,Fr.REPEATED_POINT=1,Fr.HOLE_OUTSIDE_SHELL=2,Fr.NESTED_HOLES=3,Fr.DISCONNECTED_INTERIOR=4,Fr.SELF_INTERSECTION=5,Fr.RING_SELF_INTERSECTION=6,Fr.NESTED_SHELLS=7,Fr.DUPLICATE_RINGS=8,Fr.TOO_FEW_POINTS=9,Fr.INVALID_COORDINATE=10,Fr.RING_NOT_CLOSED=11,Fr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Gr{constructor(){Gr.constructor_.apply(this,arguments)}static constructor_(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof U){return new Gr(arguments[0]).isValid()}if(arguments[0]instanceof m){const t=arguments[0];return!r.isNaN(t.x)&&(!r.isInfinite(t.x)&&(!r.isNaN(t.y)&&!r.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Gr.isValid(t[e]))return this._validErr=new Fr(Fr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof rt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){if(t.getNumInteriorRing()<=0)return null;const n=new Ar(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);s.isEmpty()||n.add(s)}n.isNonNested()||(this._validErr=new Fr(Fr.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new Dr(t);if(!e.isNodeConsistentArea())return this._validErr=new Fr(Fr.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Fr(Fr.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Gr.findPtNotNode(s,e,n);if(null!==r){if(!Ue.isInRing(r,i))return r}const o=Gr.findPtNotNode(i,t,n);if(null!==o){return Ue.isInRing(o,s)?o:null}return g.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new Tr(t);e.isInteriorsConnected()||(this._validErr=new Fr(Fr.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new at;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Fr(Fr.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){if(t.getNumInteriorRing()<=0)return null;const n=t.getExteriorRing(),s=n.isEmpty(),i=new ze(n);for(let r=0;r<t.getNumInteriorRing();r++){const o=t.getInteriorRingN(r);let l=null;if(o.isEmpty())continue;if(l=Gr.findPtNotNode(o.getCoordinates(),n,e),null===l)return null;if(s||Qt.EXTERIOR===i.locate(l))return this._validErr=new Fr(Fr.HOLE_OUTSIDE_SHELL,l),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Fr(Fr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof et){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof ut){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof gt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new jt;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof $){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new as(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof rt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof yt){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof ht){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof U){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof et)this.checkValid(t);else if(t instanceof ut)this.checkValid(t);else if(t instanceof gt)this.checkValid(t);else if(t instanceof $)this.checkValid(t);else if(t instanceof rt)this.checkValid(t);else if(t instanceof yt)this.checkValid(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing();if(i.isEmpty())return null;const r=i.getCoordinates(),o=Gr.findPtNotNode(s,i,n);if(null===o)return null;if(!Ue.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Fr(Fr.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Fr(Fr.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(t.isEmpty())return null;if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Fr(Fr.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}}class qr{constructor(){qr.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._deList=new L,this._lowestEdge=null,this._ring=null,this._locator=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t}static findDirEdgesInRing(t){let e=t;const n=new L;do{n.add(e),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing().getEnvelopeInternal();if(l.equals(s))continue;if(!l.contains(s))continue;i=_t.ptNotInList(n.getCoordinates(),e.getCoordinates());e.isInRing(i)&&(null===r||o.contains(l))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new R;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();qr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Gr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isInRing(t){return Qt.EXTERIOR!==this.getLocator().locate(t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof gt){const t=arguments[0];null===this._holes&&(this._holes=new L),this._holes.add(t)}else if(arguments[0]instanceof qr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new L),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=q.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Wt.toLineString(new mt(this.getCoordinates()))}getLocator(){return null===this._locator&&(this._locator=new ze(this.getRing())),this._locator}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&Y.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof n))throw t;Y.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}}qr.EnvelopeComparator=class{compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}get interfaces_(){return[a]}};class Br extends $i{constructor(){super(),Br.constructor_.apply(this,arguments)}static constructor_(){this._factory=null;const t=arguments[0];this._factory=t}static findLabeledEdgeRings(t){const e=new L;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=qr.findDirEdgesInRing(t);Br.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(g.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();Br.getDegree(i,e)>1&&(null===s&&(s=new L),s.add(i)),n=n.getNext(),g.isTrue(null!==n,"found null DE in ring"),g.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new qr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();Br.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Sr(i,r,e[1],!0),l=new Sr(r,i,e[e.length-2],!1),a=new Lr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),Br.findLabeledEdgeRings(this._dirEdges);const t=new L;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Br.label(this._dirEdges,-1);const t=Br.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new L;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new Ki(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=Br.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();Br.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new Et,n=new en;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();Br.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===Br.getDegreeNonDeleted(o)&&n.push(o)}}return e}}class Yr{constructor(){Yr.constructor_.apply(this,arguments)}static constructor_(){this._shells=null,this._shellIndex=null;const t=arguments[0];this._shells=t,this.buildIndex()}static assignHolesToShells(t,e){new Yr(e).assignHolesToShells(t)}assignHolesToShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.assignHoleToShell(t)}}buildIndex(){this._shellIndex=new bs;for(const t of this._shells)this._shellIndex.insert(t.getRing().getEnvelopeInternal(),t)}queryOverlappingShells(t){return this._shellIndex.query(t)}findShellContaining(t){const e=t.getRing().getEnvelopeInternal(),n=this.queryOverlappingShells(e);return qr.findEdgeRingContaining(t,n)}assignHoleToShell(t){const e=this.findShellContaining(t);null!==e&&e.addHole(t)}}class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static constructor_(){if(this._lineStringAdder=new zr(this),this._graph=null,this._dangles=new L,this._cutEdges=new L,this._invalidRingLines=new L,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Vr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}}static extractPolygons(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static findDisjointShells(t){Vr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Lt),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Lt.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new L,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new L;this._invalidRingLines=new L,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Yr.assignHolesToShells(this._holeList,this._shellList),xe.sort(this._shellList,new qr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Vr.findDisjointShells(this._shellList),n=!1),this._polyList=Vr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof $){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Br(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof U){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new L,this._shellList=new L;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}}class zr{constructor(){zr.constructor_.apply(this,arguments)}static constructor_(){this.p=null;const t=arguments[0];this.p=t}filter(t){t instanceof $&&this.p.add(t)}get interfaces_(){return[k]}}Vr.LineStringAdder=zr;var Xr=Object.freeze({__proto__:null,Polygonizer:Vr});class kr{constructor(){kr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._ptLocator=new fn,this._arg=null,this._nodes=new ns(new br),this._im=null,this._isolatedEdges=new L,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,Qt.EXTERIOR)}computeIM(){const t=new Jt;if(t.set(Qt.EXTERIOR,Qt.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new Rr,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===Qt.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,Qt.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===Qt.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,Qt.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();g.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(Qt.INTERIOR,Qt.EXTERIOR,e.getDimension()),t.set(Qt.BOUNDARY,Qt.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(Qt.EXTERIOR,Qt.INTERIOR,n.getDimension()),t.set(Qt.EXTERIOR,Qt.BOUNDARY,n.getBoundaryDimension()))}}class Ur{constructor(){Ur.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new Ur(t).contains(e)}isContainedInBoundary(t){if(t instanceof rt)return!1;if(t instanceof et)return this.isPointContainedInBoundary(t);if(t instanceof $)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new m,s=new m;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof et){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof m){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new m(t.getMinX(),t.getMinY()),this._diagUp1=new m(t.getMaxX(),t.getMaxY()),this._diagDown0=new m(t.getMinX(),t.getMaxY()),this._diagDown1=new m(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new O(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Wr{constructor(){Wr.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Wr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Zr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new jr(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new Kr(this._rectangle);return s.applyTo(t),!!s.intersects()}}class Zr extends Ne{constructor(){super(),Zr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}}class jr extends Ne{constructor(){super(),jr.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof rt))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new m;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}}class Kr extends Ne{constructor(){super(),Kr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new m,this._p1=new m;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Hr(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=ye.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class Qr extends Nr{constructor(){super(),Qr.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e),this._relate=new kr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Nr.constructor_.call(this,t,e,n),this._relate=new kr(this._arg)}}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Qr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Wr.intersects(t,e);if(e.isRectangle())return Wr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Qr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Qr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){return new Qr(arguments[0],arguments[1]).getIntersectionMatrix()}if(3===arguments.length){return new Qr(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Ur.contains(t,e):new Qr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}}var Jr=Object.freeze({__proto__:null,RelateOp:Qr});class $r{constructor(){$r.constructor_.apply(this,arguments)}static constructor_(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()}static union(t,e){return new $r(t,e).union()}union(){const t=new fn,e=new at;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===Qt.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=_t.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),he.combine(n,this._otherGeom)}}class to{constructor(){to.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._polygons=new L,this._lines=new L,this._points=new L,this._dimension=Q.FALSE}static extract(){if(I(arguments[0],N)){const t=arguments[0],e=new to;return e.add(t),e}if(arguments[0]instanceof U){const t=arguments[0],e=new to;return e.add(t),e}}getFactory(){return this._geomFactory}recordDimension(t){t>this._dimension&&(this._dimension=t)}getDimension(){return this._dimension}filter(t){return this.recordDimension(t.getDimension()),t instanceof ht||t.isEmpty()?null:t instanceof rt?(this._polygons.add(t),null):t instanceof $?(this._lines.add(t),null):t instanceof et?(this._points.add(t),null):void g.shouldNeverReachHere("Unhandled geometry type: "+t.getGeometryType())}getExtract(t){switch(t){case 0:return this._points;case 1:return this._lines;case 2:return this._polygons}return g.shouldNeverReachHere("Invalid dimension: "+t),null}isEmpty(){return this._polygons.isEmpty()&&this._lines.isEmpty()&&this._points.isEmpty()}add(){if(I(arguments[0],N)){const t=arguments[0];for(const e of t)this.add(e)}else if(arguments[0]instanceof U){const t=arguments[0];null===this._geomFactory&&(this._geomFactory=t.getFactory()),t.apply(this)}}get interfaces_(){return[J]}}class eo{static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return U.checkNotGeometryCollection(t),U.checkNotGeometryCollection(e),Ir.overlayOp(t,e,wr.UNION)}}class no{constructor(){no.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._g0=null,this._g1=null,this._isUnionSafe=null;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e,this._geomFactory=t.getFactory()}static containsProperly(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!t.isNull()&&(e.getX()>t.getMinX()&&e.getX()<t.getMaxX()&&e.getY()>t.getMinY()&&e.getY()<t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return no.containsProperly(t,e)&&no.containsProperly(t,n)}}static union(t,e){return new no(t,e).union()}static intersects(t,e,n){return t.intersects(e)||t.intersects(n)}static overlapEnvelope(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();return n.intersection(s)}static extractBorderSegments(t,e,n){t.apply(new class{get interfaces_(){return[P]}filter(t,s){if(s<=0)return null;const i=t.getCoordinate(s-1),r=t.getCoordinate(s);if(no.intersects(e,i,r)&&!no.containsProperly(e,i,r)){const t=new Kt(i,r);n.add(t)}}isDone(){return!1}isGeometryChanged(){return!1}})}static unionBuffer(t,e){return t.getFactory().createGeometryCollection([t,e]).buffer(0)}isBorderSegmentsSame(t,e){const n=this.extractBorderSegments(this._g0,this._g1,e),s=new L;return no.extractBorderSegments(t,e,s),this.isEqual(n,s)}extractByEnvelope(t,e,n){const s=new L;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);if(r.getEnvelopeInternal().intersects(t))s.add(r);else{const t=r.copy();n.add(t)}}return this._geomFactory.buildGeometry(s)}isEqual(t,e){if(t.size()!==e.size())return!1;const n=new Et(t);for(const t of e)if(!n.contains(t))return!1;return!0}union(){const t=no.overlapEnvelope(this._g0,this._g1);if(t.isNull()){const t=this._g0.copy(),e=this._g1.copy();return he.combine(t,e)}const e=new L,n=this.extractByEnvelope(t,this._g0,e),s=this.extractByEnvelope(t,this._g1,e),i=this.unionFull(n,s);let r=null;return this._isUnionSafe=this.isBorderSegmentsSame(i,t),r=this._isUnionSafe?this.combine(i,e):this.unionFull(this._g0,this._g1),r}combine(t,e){if(e.size()<=0)return t;e.add(t);return he.combine(e)}unionFull(t,e){try{return eo.union(t,e)}catch(n){if(n instanceof is)return no.unionBuffer(t,e);throw n}}extractBorderSegments(t,e,n){const s=new L;return no.extractBorderSegments(t,n,s),null!==e&&no.extractBorderSegments(e,n,s),s}isUnionOptimized(){return this._isUnionSafe}}class so{constructor(){so.constructor_.apply(this,arguments)}static constructor_(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new L)}static restrictToPolygons(t){if(I(t,it))return t;const e=Ie.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Lt.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new so(t).union()}reduceToGeometries(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;I(t,C)?s=this.unionTree(t):t instanceof U&&(s=t),e.add(s)}return e}union(){if(null===this._inputPolys)throw new D("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new bs(so.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=so.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(so.getGeometry(t,e),so.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionActual(t,e)}unionActual(t,e){const n=no.union(t,e);return so.restrictToPolygons(n)}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}}so.STRTREE_NODE_CAPACITY=4;class io{constructor(){io.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._extracter=null,1===arguments.length){if(I(arguments[0],N)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof U){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}}static union(){if(1===arguments.length){if(I(arguments[0],N)){return new io(arguments[0]).union()}if(arguments[0]instanceof U){return new io(arguments[0]).union()}}else if(2===arguments.length){return new io(arguments[0],arguments[1]).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return Ir.overlayOp(t,e,wr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:wr.union(t,e)}extract(){if(I(arguments[0],N)){const t=arguments[0];this._extracter=to.extract(t)}else if(arguments[0]instanceof U){const t=arguments[0];this._extracter=to.extract(t)}}union(){if(null===this._geomFact&&(this._geomFact=this._extracter.getFactory()),null===this._geomFact)return null;if(this._extracter.isEmpty())return this._geomFact.createEmpty(this._extracter.getDimension());const t=this._extracter.getExtract(0),e=this._extracter.getExtract(1),n=this._extracter.getExtract(2);let s=null;if(t.size()>0){const e=this._geomFact.buildGeometry(t);s=this.unionNoOpt(e)}let i=null;if(e.size()>0){const t=this._geomFact.buildGeometry(e);i=this.unionNoOpt(t)}let r=null;n.size()>0&&(r=so.union(n));const o=this.unionWithNull(i,r);let l=null;return l=null===s?o:null===o?s:$r.union(s,o),null===l?this._geomFact.createGeometryCollection():l}}var ro=Object.freeze({__proto__:null,UnaryUnionOp:io}),oo=Object.freeze({__proto__:null,IsValidOp:Gr,ConsistentAreaTester:Dr}),lo=Object.freeze({__proto__:null,BoundaryOp:ii,IsSimpleOp:oi,buffer:Bi,distance:Xi,linemerge:rr,overlay:Cr,polygonize:Xr,relate:Jr,union:ro,valid:oo});class ao{constructor(){ao.constructor_.apply(this,arguments)}static constructor_(){if(this._returnToOriginalPrecision=!0,this._cbr=null,0===arguments.length)ao.constructor_.call(this,!0);else if(1===arguments.length){const t=arguments[0];this._returnToOriginalPrecision=t}}computeResultPrecision(t){return this._returnToOriginalPrecision&&this._cbr.addCommonBits(t),t}union(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].union(n[1]))}intersection(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].intersection(n[1]))}removeCommonBits(){if(1===arguments.length){const t=arguments[0];this._cbr=new fr,this._cbr.add(t);return this._cbr.removeCommonBits(t.copy())}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._cbr=new fr,this._cbr.add(t),this._cbr.add(e);const n=new Array(2).fill(null);return n[0]=this._cbr.removeCommonBits(t.copy()),n[1]=this._cbr.removeCommonBits(e.copy()),n}}buffer(t,e){const n=this.removeCommonBits(t);return this.computeResultPrecision(n.buffer(e))}symDifference(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].symDifference(n[1]))}difference(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].difference(n[1]))}}class co extends ue.CoordinateOperation{constructor(){super(),co.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e}edit(){if(2===arguments.length&&arguments[1]instanceof U&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new m(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new R(n,!1).toCoordinateArray();let i=0;e instanceof $&&(i=2),e instanceof gt&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}}class ho{constructor(){ho.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t}static reduce(t,e){return new ho(e).reduce(t)}static reducePointwise(t,e){const n=new ho(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));return qi.bufferOp(e,0)}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new ue(n)}else e=new ue;let n=this._removeCollapsed;t.getDimension()>=2&&(n=!0);return e.edit(t,new co(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new ue.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Lt(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:I(e,it)?Gr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new ue;const n=this.createFactory(t,e);return new ue(n)}}class uo{constructor(){uo.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._pts=null,this._start=null,this._end=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._pts=t,this._start=e,this._end=e+1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pts=t,this._start=e,this._end=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._geom=t,this._pts=e,this._start=n,this._end=s}}computeDistanceLineLine(t,e){let n=r.MAX_VALUE;for(let s=this._start;s<this._end-1;s++){const i=this._pts.getCoordinate(s),r=this._pts.getCoordinate(s+1);for(let o=t._start;o<t._end-1;o++){const l=t._pts.getCoordinate(o),a=t._pts.getCoordinate(o+1),c=z.segmentToSegment(i,r,l,a);if(c<n&&(n=c,null!==e&&this.updateNearestLocationsLineLine(s,i,r,t,o,l,a,e),n<=0))return n}}return n}updateNearestLocationsPointLine(t,e,n,s,i,r){r[0]=new Yi(this._geom,this._start,new m(t));const o=new Kt(s,i).closestPoint(t);r[1]=new Yi(e._geom,n,new m(o))}size(){return this._end-this._start}getCoordinate(t){return this._pts.getCoordinate(this._start+t)}nearestLocations(t){const e=this.isPoint(),n=t.isPoint(),s=new Array(2).fill(null);if(e&&n){const e=this._pts.getCoordinate(this._start),n=t._pts.getCoordinate(t._start);s[0]=new Yi(this._geom,this._start,new m(e)),s[1]=new Yi(t._geom,t._start,new m(n))}else if(e){const e=this._pts.getCoordinate(this._start);this.computeDistancePointLine(e,t,s)}else if(n){const e=t._pts.getCoordinate(t._start);this.computeDistancePointLine(e,this,s);const n=s[0];s[0]=s[1],s[1]=n}else this.computeDistanceLineLine(t,s);return s}getEnvelope(){const t=new O;for(let e=this._start;e<this._end;e++)t.expandToInclude(this._pts.getX(e),this._pts.getY(e));return t}updateNearestLocationsLineLine(t,e,n,s,i,r,o,l){const a=new Kt(e,n),c=new Kt(r,o),h=a.closestPoints(c);l[0]=new Yi(this._geom,t,new m(h[0])),l[1]=new Yi(s._geom,i,new m(h[1]))}toString(){const t=new v;t.append("LINESTRING ( ");const e=new m;for(let n=this._start;n<this._end;n++)n>this._start&&t.append(", "),this._pts.getCoordinate(n,e),t.append(e.x+" "+e.y);return t.append(" )"),t.toString()}computeDistancePointLine(t,e,n){let s=r.MAX_VALUE;for(let i=e._start;i<e._end-1;i++){const r=e._pts.getCoordinate(i),o=e._pts.getCoordinate(i+1),l=z.pointToSegment(t,r,o);if(l<s&&(s=l,null!==n&&this.updateNearestLocationsPointLine(t,e,i,r,o,n),s<=0))return s}return s}isPoint(){return this._end-this._start==1}distance(t){const e=this.isPoint(),n=t.isPoint();let s=null;if(e&&n){const e=this._pts.getCoordinate(this._start),n=t._pts.getCoordinate(t._start);s=e.distance(n)}else if(e){const e=this._pts.getCoordinate(this._start);s=this.computeDistancePointLine(e,t,null)}else if(n){const e=t._pts.getCoordinate(t._start);s=this.computeDistancePointLine(e,this,null)}else s=this.computeDistanceLineLine(t,null);return s}}class go{static addFacetSequences(t,e,n){let s=0;const i=e.size();for(;s<=i-1;){let r=s+go.FACET_SEQUENCE_SIZE+1;r>=i-1&&(r=i);const o=new uo(t,e,s,r);n.add(o),s+=go.FACET_SEQUENCE_SIZE}}static computeFacetSequences(t){const e=new L;return t.apply(new class{get interfaces_(){return[k]}filter(t){let n=null;(t instanceof $||t instanceof et)&&(n=t.getCoordinateSequence(),go.addFacetSequences(t,n,e))}}),e}static build(t){const e=new bs(go.STR_TREE_NODE_CAPACITY);for(let n=go.computeFacetSequences(t).iterator();n.hasNext();){const t=n.next();e.insert(t.getEnvelope(),t)}return e.build(),e}}go.FACET_SEQUENCE_SIZE=6,go.STR_TREE_NODE_CAPACITY=4;class _o{constructor(){_o.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._minClearance=null,this._minClearancePts=null;const t=arguments[0];this._inputGeom=t}static getLine(t){return new _o(t).getLine()}static getDistance(t){return new _o(t).getDistance()}getLine(){return this.compute(),null===this._minClearancePts||null===this._minClearancePts[0]?this._inputGeom.getFactory().createLineString():this._inputGeom.getFactory().createLineString(this._minClearancePts)}compute(){if(null!==this._minClearancePts)return null;if(this._minClearancePts=new Array(2).fill(null),this._minClearance=r.MAX_VALUE,this._inputGeom.isEmpty())return null;const t=go.build(this._inputGeom).nearestNeighbour(new po),e=new po;this._minClearance=e.distance(t[0],t[1]),this._minClearancePts=e.getCoordinates()}getDistance(){return this.compute(),this._minClearance}}class po{constructor(){po.constructor_.apply(this,arguments)}static constructor_(){this._minDist=r.MAX_VALUE,this._minPts=new Array(2).fill(null)}vertexDistance(t,e){for(let n=0;n<t.size();n++)for(let s=0;s<e.size();s++){const i=t.getCoordinate(n),r=e.getCoordinate(s);if(!i.equals2D(r)){const t=i.distance(r);if(t<this._minDist&&(this._minDist=t,this._minPts[0]=i,this._minPts[1]=r,0===t))return t}}return this._minDist}getCoordinates(){return this._minPts}segmentDistance(t,e){for(let n=0;n<t.size();n++)for(let s=1;s<e.size();s++){const i=t.getCoordinate(n),r=e.getCoordinate(s-1),o=e.getCoordinate(s);if(!i.equals2D(r)&&!i.equals2D(o)){const t=z.pointToSegment(i,r,o);if(t<this._minDist&&(this._minDist=t,this.updatePts(i,r,o),0===t))return t}}return this._minDist}distance(){if(arguments[0]instanceof Ss&&arguments[1]instanceof Ss){const t=arguments[1],e=arguments[0].getItem(),n=t.getItem();return this._minDist=r.MAX_VALUE,this.distance(e,n)}if(arguments[0]instanceof uo&&arguments[1]instanceof uo){const t=arguments[0],e=arguments[1];return this.vertexDistance(t,e),1===t.size()&&1===e.size()?this._minDist:this._minDist<=0?this._minDist:(this.segmentDistance(t,e),this._minDist<=0||this.segmentDistance(e,t),this._minDist)}}updatePts(t,e,n){this._minPts[0]=t;const s=new Kt(e,n);this._minPts[1]=new m(s.closestPoint(t))}get interfaces_(){return[vs]}}_o.MinClearanceDistance=po;class mo{constructor(){mo.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._minClearance=null,this._minClearancePts=null;const t=arguments[0];this._inputGeom=t}static getLine(t){return new mo(t).getLine()}static getDistance(t){return new mo(t).getDistance()}getLine(){return this.compute(),this._inputGeom.getFactory().createLineString(this._minClearancePts)}updateClearance(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t<this._minClearance&&(this._minClearance=t,this._minClearancePts[0]=new m(e),this._minClearancePts[1]=new m(n))}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t<this._minClearance){this._minClearance=t,this._minClearancePts[0]=new m(e);const i=new Kt(n,s);this._minClearancePts[1]=new m(i.closestPoint(e))}}}compute(){if(null!==this._minClearancePts)return null;this._minClearancePts=new Array(2).fill(null),this._minClearance=r.MAX_VALUE,this._inputGeom.apply(new fo(this))}getDistance(){return this.compute(),this._minClearance}}class fo{constructor(){fo.constructor_.apply(this,arguments)}static constructor_(){this.smc=null;const t=arguments[0];this.smc=t}filter(t){this.smc._inputGeom.apply(new yo(this.smc,t))}get interfaces_(){return[H]}}class yo{constructor(){yo.constructor_.apply(this,arguments)}static constructor_(){this.smc=null,this._queryPt=null;const t=arguments[0],e=arguments[1];this.smc=t,this._queryPt=e}isGeometryChanged(){return!1}checkVertexDistance(t){const e=t.distance(this._queryPt);e>0&&this.smc.updateClearance(e,this._queryPt,t)}filter(t,e){this.checkVertexDistance(t.getCoordinate(e)),e>0&&this.checkSegmentDistance(t.getCoordinate(e-1),t.getCoordinate(e))}checkSegmentDistance(t,e){if(this._queryPt.equals2D(t)||this._queryPt.equals2D(e))return null;const n=z.pointToSegment(this._queryPt,e,t);n>0&&this.smc.updateClearance(n,this._queryPt,e,t)}isDone(){return!1}get interfaces_(){return[P]}}mo.VertexCoordinateFilter=fo,mo.ComputeMCCoordinateSequenceFilter=yo;var xo=Object.freeze({__proto__:null,CommonBits:mr,CommonBitsOp:ao,CommonBitsRemover:fr,EnhancedPrecisionOp:class{static union(t,e){let n=null;try{return t.union(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).union(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static intersection(t,e){let n=null;try{return t.intersection(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).intersection(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static buffer(t,e){let n=null;try{return t.buffer(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).buffer(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static symDifference(t,e){let n=null;try{return t.symDifference(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).symDifference(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static difference(t,e){let n=null;try{return t.difference(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).difference(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}},GeometryPrecisionReducer:ho,MinimumClearance:_o,SimpleMinimumClearance:mo});class Eo{constructor(){Eo.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new Kt;const t=arguments[0];this._pts=t}static simplify(t,e){const n=new Eo(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new R;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new m(this._pts[e]));return t.toCoordinateArray()}}class Io{constructor(){Io.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Io(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new No(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class No extends me{constructor(){super(),No.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):Eo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof rt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof gt?s:null}}Io.DPTransformer=No;class wo extends Kt{constructor(){super(),wo.constructor_.apply(this,arguments)}static constructor_(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];wo.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,t,e),this._parent=n,this._index=s}}getIndex(){return this._index}getParent(){return this._parent}}class Co{constructor(){Co.constructor_.apply(this,arguments)}static constructor_(){if(this._parentLine=null,this._segs=null,this._resultSegs=new L,this._minimumSize=null,1===arguments.length){const t=arguments[0];Co.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(Co.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(Co.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new wo(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return Co.extractCoordinates(this._resultSegs)}}class So{constructor(){So.constructor_.apply(this,arguments)}static constructor_(){this._index=new Ns}remove(t){this._index.remove(new O(t.p0,t.p1),t)}add(){if(arguments[0]instanceof Co){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof Kt){const t=arguments[0];this._index.insert(new O(t.p0,t.p1),t)}}query(t){const e=new O(t.p0,t.p1),n=new Lo(t);this._index.query(e,n);return n.getItems()}}class Lo{constructor(){Lo.constructor_.apply(this,arguments)}static constructor_(){this._querySeg=null,this._items=new L;const t=arguments[0];this._querySeg=t}visitItem(t){const e=t;O.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class To{constructor(){To.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._inputIndex=new So,this._outputIndex=new So,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new Kt(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new Kt;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new Kt;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(To.isInLineSection(t,e,i))continue;return!0}}return!1}}class Ro{constructor(){Ro.constructor_.apply(this,arguments)}static constructor_(){this._inputIndex=new So,this._outputIndex=new So,this._distanceTolerance=0}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new To(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}}class Po{constructor(){Po.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._lineSimplifier=new Ro,this._linestringMap=null;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Po(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();this._linestringMap=new Nt,this._inputGeom.apply(new vo(this)),this._lineSimplifier.simplify(this._linestringMap.values());return new Oo(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}}class Oo extends me{constructor(){super(),Oo.constructor_.apply(this,arguments)}static constructor_(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof $){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}}class vo{constructor(){vo.constructor_.apply(this,arguments)}static constructor_(){this.tps=null;const t=arguments[0];this.tps=t}filter(t){if(t instanceof $){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new Co(e,n);this.tps._linestringMap.put(e,s)}}get interfaces_(){return[k]}}Po.LineStringTransformer=Oo,Po.LineStringMapBuilderFilter=vo;class bo{constructor(){bo.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e}static simplify(t,e){return new bo(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=Mo.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new m(n[0])]:n}}class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static constructor_(){this._pt=null,this._prev=null,this._next=null,this._area=Mo.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new Mo(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new R;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=Mo.MAX_AREA,null;this._area=Math.abs(ne.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}}Mo.MAX_AREA=r.MAX_VALUE,bo.VWVertex=Mo;class Do{constructor(){Do.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Do(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Ao(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class Ao extends me{constructor(){super(),Ao.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):bo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof rt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof gt?s:null}}Do.VWTransformer=Ao;var Fo=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Io,TopologyPreservingSimplifier:Po,VWSimplifier:Do});class Go{constructor(){Go.constructor_.apply(this,arguments)}static constructor_(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()}static pointAlongReverse(t,e){const n=new m;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=Go.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=Go.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}}class qo{findSplitPoint(t,e){}}class Bo{static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new Go(n),r=Bo.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}get interfaces_(){return[qo]}}class Yo{static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=A.valueOf(t.x).selfSubtract(s.x),r=A.valueOf(t.y).selfSubtract(s.y),o=A.valueOf(e.x).selfSubtract(s.x),l=A.valueOf(e.y).selfSubtract(s.y),a=A.valueOf(n.x).selfSubtract(s.x),c=A.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),p=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(p.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=Yo.isInCircleNonRobust(t,e,n,s),r=Yo.isInCircleDDSlow(t,e,n,s),o=Yo.isInCircleCC(t,e,n,s),l=ne.circumcentre(t,e,n);Y.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(Y.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),Y.out.println(Wt.toLineString(new mt([t,e,n,s]))),Y.out.println("Circumcentre = "+Wt.toPoint(l)+" radius = "+t.distance(l)),Y.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),Y.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),Y.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),Y.out.println())}static isInCircleDDFast(t,e,n,s){const i=A.sqr(t.x).selfAdd(A.sqr(t.y)).selfMultiply(Yo.triAreaDDFast(e,n,s)),r=A.sqr(e.x).selfAdd(A.sqr(e.y)).selfMultiply(Yo.triAreaDDFast(t,n,s)),o=A.sqr(n.x).selfAdd(A.sqr(n.y)).selfMultiply(Yo.triAreaDDFast(t,e,s)),l=A.sqr(s.x).selfAdd(A.sqr(s.y)).selfMultiply(Yo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=ne.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=A.valueOf(s.x),r=A.valueOf(s.y),o=A.valueOf(t.x),l=A.valueOf(t.y),a=A.valueOf(e.x),c=A.valueOf(e.y),h=A.valueOf(n.x),u=A.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(Yo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(Yo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(Yo.triAreaDDSlow(o,l,a,c,i,r)),p=i.multiply(i).add(r.multiply(r)).multiply(Yo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(p).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*Yo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*Yo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*Yo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*Yo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return Yo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=A.valueOf(e.x).selfSubtract(t.x).selfMultiply(A.valueOf(n.y).selfSubtract(t.y)),i=A.valueOf(e.y).selfSubtract(t.y).selfMultiply(A.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}}class Vo{constructor(){Vo.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new m(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e,n)}}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.getZ()-e.getZ();return e.getZ()+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}}circleCenter(t,e){const n=new Vo(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new ee(s,i);let o=null;try{o=new Vo(r.getX(),r.getY())}catch(s){if(!(s instanceof te))throw s;Y.err.println("a: "+n+"  b: "+t+"  c: "+e),Y.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.getZ()}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new ee(t.getX()+n/2,t.getY()+s/2,1),r=new ee(t.getX()-s+n/2,t.getY()+n+s/2,1);return new ee(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return Yo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.getZ()+t.getZ())/2;return new Vo(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.setZ(t)}times(t){return new Vo(t*this._p.x,t*this._p.y)}cross(){return new Vo(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new Vo(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=this,s=e.sub(t),i=n.sub(t),r=s.crossProduct(i);return r>0?Vo.LEFT:r<0?Vo.RIGHT:s.getX()*i.getX()<0||s.getY()*i.getY()<0?Vo.BEHIND:s.magn()<i.magn()?Vo.BEYOND:t.equals(n)?Vo.ORIGIN:e.equals(n)?Vo.DESTINATION:Vo.BETWEEN}sum(t){return new Vo(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}}Vo.LEFT=0,Vo.RIGHT=1,Vo.BEYOND=2,Vo.BEHIND=3,Vo.BETWEEN=4,Vo.ORIGIN=5,Vo.DESTINATION=6;class zo extends Vo{constructor(){super(),zo.constructor_.apply(this,arguments)}static constructor_(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];Vo.constructor_.call(this,t)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}}class Xo{constructor(){Xo.constructor_.apply(this,arguments)}static constructor_(){this._rot=null,this._vertex=null,this._next=null,this._data=null}static makeEdge(t,e){const n=new Xo,s=new Xo,i=new Xo,r=new Xo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();Xo.splice(t,e),Xo.splice(t.sym(),n),Xo.splice(t,e.lNext()),Xo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=Xo.makeEdge(t.dest(),e.orig());return Xo.splice(n,t.lNext()),Xo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new Kt(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Wt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}}class ko{constructor(){ko.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);Xo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))Xo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}}class Uo{locate(t){}}class Ho{constructor(){Ho.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}get interfaces_(){return[Uo]}}class Wo extends h{constructor(){super(),Wo.constructor_.apply(this,arguments)}static constructor_(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];h.constructor_.call(this,t)}else if(arguments[0]instanceof Kt){const t=arguments[0];h.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new Kt(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,Wo.msgWithSpatial(t,e)),this._seg=new Kt(e)}}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}}class Zo{visit(t){}}class jo{constructor(){jo.constructor_.apply(this,arguments)}static constructor_(){this._visitedKey=0,this._quadEdges=new L,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new Kt,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/jo.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Ho(this)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new s("Edges do not form a triangle")}getTriangleVertices(t){const e=new Jo;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=Xo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new L,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new R;i.addAll(n,!1),i.closeRing(),i.size()<4&&(Y.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);Xo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return Xo.splice(e.sym(),n),Xo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);jo.getTriangleEdges(t,e);const n=new Array(3).fill(null);jo.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=Xo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new en;n.push(this._startingEdge);const s=new Et;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());return this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new O(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new Vo((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new Vo(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new Vo(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new O(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new $o;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new Et;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new L,n=new Et;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Qo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new L,n=new en;n.push(this._startingEdge);const s=new Et;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){Xo.splice(t,t.oPrev()),Xo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new Wo(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new Ko,!0);const e=new L;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Lt.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);Xo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof Vo){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._locator.locate(new Vo(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new Vo(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}}class Ko{visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=ne.circumcentreDD(e,n,s),r=new Vo(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}get interfaces_(){return[Zo]}}class Qo{constructor(){Qo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}get interfaces_(){return[Zo]}}class Jo{constructor(){Jo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}get interfaces_(){return[Zo]}}class $o{constructor(){$o.constructor_.apply(this,arguments)}static constructor_(){this._coordList=new R,this._triCoords=new L}checkTriangleSize(t){t.length>=2?Wt.toLineString(t[0],t[1]):t.length>=1&&Wt.toPoint(t[0])}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}get interfaces_(){return[Zo]}}jo.TriangleCircumcentreVisitor=Ko,jo.TriangleEdgesListVisitor=Qo,jo.TriangleVertexListVisitor=Jo,jo.TriangleCoordinatesVisitor=$o,jo.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class tl{constructor(){tl.constructor_.apply(this,arguments)}static constructor_(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new Kt(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new Kt(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];tl.constructor_.call(this,new m(t,e,n),new m(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];tl.constructor_.call(this,new m(t,e,n),new m(s,i,r),o)}}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).getZ()}getStartZ(){return this._ls.getCoordinate(0).getZ()}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}}class el extends h{constructor(){super(),el.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,el.msgWithCoord(t,e)),this._pt=new m(e)}}static msgWithCoord(t,e){return null!==e?t+" [ "+Wt.toPoint(e)+" ]":t}getCoordinate(){return this._pt}}class nl{constructor(){nl.constructor_.apply(this,arguments)}static constructor_(){this._initialVertices=null,this._segVertices=null,this._segments=new L,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new Bo,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new L(t),this._tolerance=e,this._kdt=new gs(e)}static computeVertexEnvelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<nl.MAX_SPLIT_ITER);if(t===nl.MAX_SPLIT_ITER)throw new el("Too many splitting iterations while enforcing constraints.  Last split point was at: ",this._splitPt)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Lt,e=this.getPointArray(),n=new sn(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new m((e.x+n.x)/2,(e.y+n.y)/2),i=e.distance(s),o=new O(s);o.expandBy(i);const l=this._kdt.query(o);let a=null,c=r.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const r=t.next().getCoordinate();if(r.equals2D(e)||r.equals2D(n))continue;const o=s.distance(r);if(o<i){const t=o;(null===a||t<c)&&(a=r,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new L;let n=0;const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new tl(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new tl(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new zo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new zo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=nl.computeVertexEnvelope(this._initialVertices),e=nl.computeVertexEnvelope(this._segVertices),n=new O(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new O(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new jo(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Ho(this._subdiv)),this._incDel=new ko(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof zo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof m){const t=arguments[0];this.insertSite(this.createVertex(t))}}}nl.MAX_SPLIT_ITER=99;class sl{constructor(){sl.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null}static extractUniqueCoordinates(t){if(null===t)return new R;const e=t.getCoordinates();return sl.unique(e)}static envelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=_t.copyDeep(t);st.sort(e);return new R(e,!1)}static toVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Vo(t))}return e}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords),e=sl.toVertices(this._siteCoords);this._subdiv=new jo(t,this._tolerance);new ko(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof U){const t=arguments[0];this._siteCoords=sl.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=sl.unique(_t.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}}class il{constructor(){il.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new Wn}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=ye.getLines(t),n=new L;for(let t=e.iterator();t.hasNext();){const e=t.next();il.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[1],e=arguments[0].getCoordinates();for(let n=1;n<e.length;n++)t.add(new tl(e[n-1],e[n]))}}createSiteVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new zo(t))}return e}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords);let e=new L;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=il.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new nl(n,this._tolerance);s.setConstraints(e,new L(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=sl.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new zo(e[t]);this._constraintVertexMap.put(e[t],n)}}}class rl{constructor(){rl.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new L;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=wr.intersection(n,r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Lt.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords);if(this._diagramEnv=this._clipEnv,null===this._diagramEnv){this._diagramEnv=t;const e=this._diagramEnv.getDiameter();this._diagramEnv.expandBy(e)}const e=sl.toVertices(this._siteCoords);this._subdiv=new jo(t,this._tolerance);new ko(this._subdiv).insertSites(e)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return rl.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof U){const t=arguments[0];this._siteCoords=sl.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=sl.unique(_t.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}}var ll=Object.freeze({__proto__:null,Vertex:Vo}),al=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:il,DelaunayTriangulationBuilder:sl,VoronoiDiagramBuilder:rl,quadedge:ll});class cl{constructor(){cl.constructor_.apply(this,arguments)}static constructor_(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];cl.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];cl.constructor_.call(this,t,e.getComponentIndex(),cl.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!I(t,Z))throw new s("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=n,this.loadCurrentLine()}}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}}class hl{constructor(){hl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new hl(t).indexOf(e)}static indexOfAfter(t,e,n){return new hl(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=e,i=0;const o=new Kt,l=new cl(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const r=o.distance(t),a=this.segmentNearestMeasure(o,t,i);r<n&&a>e&&(s=a,n=r),i+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}}class ul{constructor(){ul.constructor_.apply(this,arguments)}static constructor_(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ul.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}}static getEndLocation(t){const e=new ul;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.getZ()-t.getZ())*n+t.getZ();return new m(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}static numSegments(t){const e=t.getNumPoints();return e<=1?0:e-1}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex),n=ul.numSegments(e);return this._segmentIndex>=n||this._segmentIndex===n-1&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex),n=ul.numSegments(e);return this._segmentIndex<n?this:new ul(this._componentIndex,n-1,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=ul.numSegments(e))return n;const s=e.getCoordinateN(this._segmentIndex+1);return ul.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=ul.numSegments(e)){const t=e.getCoordinateN(e.getNumPoints()-2);return new Kt(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new Kt(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=ul.numSegments(e),this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=ul.numSegments(e),this._segmentFraction=0}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new ul(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=ul.numSegments(e)&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}get interfaces_(){return[o]}}class gl{constructor(){gl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new gl(t).indexOf(e)}static indexOfAfter(t,e,n){return new gl(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=0,i=0,o=-1;const l=new Kt;for(let r=new cl(this._linearGeom);r.hasNext();r.next())if(!r.isEndOfLine()){l.p0=r.getSegmentStart(),l.p1=r.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=r.getComponentIndex(),u=r.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,i=u,o=c,n=a)}if(n===r.MAX_VALUE)return new ul(e);return new ul(s,i,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=ul.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}}class dl{constructor(){dl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indicesOf(t,e){return new dl(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new gl(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}}class _l{constructor(){_l.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static getLength(t,e){return new _l(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[1];return new _l(arguments[0]).getLocation(t)}if(3===arguments.length){const t=arguments[1],e=arguments[2];return new _l(arguments[0]).getLocation(t,e)}}getLength(t){let e=0;const n=new cl(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new ul(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new ul;let e=0;const n=new cl(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new ul(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new ul(r,o,s)}e+=i}n.next()}return ul.getEndLocation(this._linearGeom)}}class pl{constructor(){pl.constructor_.apply(this,arguments)}static constructor_(){this._geomFact=null,this._lines=new L,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let n=null;try{n=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof s))throw t;if(!this._ignoreInvalidLines)throw t}null!==n&&this._lines.add(n)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new R),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}}class ml{constructor(){ml.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}static extract(t,e,n){return new ml(t).extract(e,n)}computeLinear(t,e){const n=new pl(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new cl(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new R;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return I(t,Z)?t.reverse():(g.shouldNeverReachHere("non-linear geometry encountered"),null)}}class fl{constructor(){fl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return _l.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return _l.getLocation(this._linearGeom,t,e)}}project(t){return hl.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return _l.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=_l.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return hl.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return ml.extract(this._linearGeom,r,o)}indexOf(t){return hl.indexOf(this._linearGeom,t)}indicesOf(t){const e=dl.indicesOf(this._linearGeom,t);return[_l.getLength(this._linearGeom,e[0]),_l.getLength(this._linearGeom,e[1])]}}class yl{constructor(){yl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return gl.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof $||this._linearGeom instanceof St))throw new s("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[1],e=arguments[0].toLowest(this._linearGeom);return e.getSegment(this._linearGeom).pointAlongOffset(e.getSegmentFraction(),t)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return ul.getEndLocation(this._linearGeom)}getStartIndex(){return new ul}indexOfAfter(t,e){return gl.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return ml.extract(this._linearGeom,t,e)}indexOf(t){return gl.indexOf(this._linearGeom,t)}indicesOf(t){return dl.indicesOf(this._linearGeom,t)}}var xl=Object.freeze({__proto__:null,LengthIndexedLine:fl,LengthLocationMap:_l,LinearGeometryBuilder:pl,LinearIterator:cl,LinearLocation:ul,LocationIndexedLine:yl});class El{static transform(t,e){const n=new L;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}}El.Function=function(){};class Il{constructor(){Il.constructor_.apply(this,arguments)}static constructor_(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}get interfaces_(){return[H]}}class Nl{constructor(){Nl.constructor_.apply(this,arguments)}static constructor_(){this._n=0}filter(t){this._n++}getCount(){return this._n}get interfaces_(){return[H]}}class wl{constructor(){wl.constructor_.apply(this,arguments)}static constructor_(){this._counts=new Nt}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new Cl(1)):e.increment()}}class Cl{constructor(){Cl.constructor_.apply(this,arguments)}static constructor_(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}}count(){return this.count}increment(){this.count++}}function Sl(){}function Ll(){}function Tl(){}wl.Counter=Cl;class Rl extends n{}function Pl(){}class Ol{static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new Tl,n=new Sl;return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";new Ll(Ol.getStackTrace(t));const s=new Pl;for(let t=0;t<e;t++)try{n+=s.readLine()+Ol.NEWLINE}catch(t){if(!(t instanceof Rl))throw t;g.shouldNeverReachHere()}return n}}static spaces(t){return Ol.chars(" ",t)}static split(t,e){const n=e.length,s=new L;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}}Ol.NEWLINE=Y.getProperty("line.separator");var vl=Object.freeze({__proto__:null,CollectionUtil:El,CoordinateArrayFilter:Il,CoordinateCountFilter:Nl,GeometricShapeFactory:we,NumberUtil:e,ObjectCounter:wl,PriorityQueue:Ls,StringUtil:Ol,UniqueCoordinateArrayFilter:nn});$.prototype.getBoundary=function(){return ii.getBoundary(this)},St.prototype.getBoundary=function(){return ii.getBoundary(this)},U.prototype.equalsTopo=function(t){return Qr.equalsTopo(this,t)},U.prototype.equals=function(t){return null!==t&&Qr.equalsTopo(this,t)},U.prototype.union=function(){if(0===arguments.length)return io.union(this);if(1===arguments.length){const t=arguments[0];return eo.union(this,t)}},U.prototype.isValid=function(){return Gr.isValid(this)},U.prototype.intersection=function(t){return wr.intersection(this,t)},U.prototype.covers=function(t){return Qr.covers(this,t)},U.prototype.coveredBy=function(t){return Qr.covers(t,this)},U.prototype.touches=function(t){return Qr.touches(this,t)},U.prototype.intersects=function(t){return Qr.intersects(this,t)},U.prototype.within=function(t){return Qr.contains(t,this)},U.prototype.overlaps=function(t){return Qr.overlaps(this,t)},U.prototype.disjoint=function(t){return Qr.disjoint(this,t)},U.prototype.crosses=function(t){return Qr.crosses(this,t)},U.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return qi.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return qi.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return qi.bufferOp(this,t,e,n)}},U.prototype.convexHull=function(){return new sn(this).getConvexHull()},U.prototype.relate=function(){if(1===arguments.length){const t=arguments[0];return Qr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Qr.relate(this,t).matches(e)}},U.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=$e.getCentroid(this);return this.createPointFromInternalCoord(t,this)},U.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new un(this):1===e?new hn(this):new on(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},U.prototype.symDifference=function(t){return wr.symDifference(this,t)},U.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},U.prototype.toText=function(){return(new Wt).write(this)},U.prototype.toString=function(){return this.toText()},U.prototype.contains=function(t){return Qr.contains(this,t)},U.prototype.difference=function(t){return wr.difference(this,t)},U.prototype.isSimple=function(){return new oi(this).isSimple()},U.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&zi.isWithinDistance(this,t,e)},U.prototype.distance=function(t){return zi.distance(this,t)};t.algorithm=En,t.densify=wn,t.dissolve=vn,t.geom=Te,t.geomgraph=cs,t.index=As,t.io=Vs,t.linearref=xl,t.noding=si,t.operation=lo,t.precision=xo,t.simplify=Fo,t.triangulate=al,t.util=vl,t.version="2.9.3"}));
//# sourceMappingURL=jsts.min.js.map


/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./src/base/AgentPoint.js":
/*!********************************!*\
  !*** ./src/base/AgentPoint.js ***!
  \********************************/
/*! exports provided: AgentPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgentPoint", function() { return AgentPoint; });
//@ts-check

/** */
class AgentPoint {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(x, y, sx=0, sy=0) {

        //position

        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y

        //speed

        /** @type {number} */
        this.sx = sx
        /** @type {number} */
        this.sy = sy
        /** @type {number} */
        this.s = undefined
        /** @type {number} */
        this.sa = undefined
    }


    /**
     * @param {AgentPoint} a
     * @returns {number} The distance to another agent.
     */
    d(a) {
        return this.dP(a.x, a.y);
    }

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @returns {number} The distance to a position.
     */
    dP(x, y) {
        return Math.hypot((x - this.x), (y - this.y));
    }

    /** 
    * Set random speed
    * 
    * @param {number} minSpeed
    * @param {number} maxSpeed
    */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        this.s = minSpeed + Math.random() * (maxSpeed - minSpeed);
        this.sa = 2 * Math.random() * Math.PI;
        this.sx = this.s * Math.cos(this.sa)
        this.sy = this.s * Math.sin(this.sa)
    }

    /** */
    computeSpeed() {
        this.s = Math.hypot(this.sx, this.sy);
        return this.s
    }

    /** */
    computeSpeedAngle() {
        this.sa = Math.atan2(this.sy, this.sx);
        return this.sa
    }

}


/***/ }),

/***/ "./src/base/GeoCanvas.js":
/*!*******************************!*\
  !*** ./src/base/GeoCanvas.js ***!
  \*******************************/
/*! exports provided: GeoCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoCanvas", function() { return GeoCanvas; });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
//@ts-check
/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */




/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 * 
 * @author Julien Gaffuri
 */
class GeoCanvas {

    /**
     * @constructor
     * @param {string} canvasId
     * @param {object} center Geographical coordinates of the center
     * @param {number} zf The zoom factor (pixel size, in ground m)
     */
    constructor(canvasId = "vacanvas", center = undefined, zf = 1) {

        /** @type {object} */
        this.canvas = document.getElementById(canvasId);

        /** @type {number} */
        this.w = this.canvas.offsetWidth;
        /** @type {number} */
        this.h = this.canvas.offsetHeight;

        this.canvas.width = this.w;
        this.canvas.height = this.h;

        /**@type {object} */
        this.ctx = this.canvas.getContext("2d");

        // set geo coordinates of the center
        this.setCenter(center || { x: this.w * 0.5, y: this.h * 0.5 })

        // set zoom factor: pixel size, in m/pix
        this.setZf(zf);

        //extent
        /** @type {Envelope} */
        this.extGeo = undefined;
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoomIdentity"]
        Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(this.canvas).call(
            Object(d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoom"])().on("zoom", (e) => {
                const t = e.transform
                const f = tP.k / t.k
                if (f == 1) {
                    //pan
                    const dx = tP.x - t.x
                    const dy = tP.y - t.y
                    this.pan(dx * this.getZf(), -dy * this.getZf())
                } else {
                    const se = e.sourceEvent;
                    if (se instanceof WheelEvent) {
                        //zoom at the mouse position
                        this.zoom(f, this.pixToGeoX(e.sourceEvent.offsetX), this.pixToGeoY(e.sourceEvent.offsetY))
                    } else if (se instanceof TouchEvent) {
                        //compute average position of the touches
                        let tx = 0, ty = 0
                        for (let tt of se.targetTouches) { tx += tt.clientX; ty += tt.clientY }
                        tx /= se.targetTouches.length; ty /= se.targetTouches.length
                        //zoom at this average position
                        this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                    }
                }
                tP = t
            }));
    }

    /** @param {{x:number,y:number}} v Geographical coordinates of the center */
    setCenter(v) { this.center = v; }
    /** @returns {{x:number,y:number}} Geographical coordinates of the center */
    getCenter() { return this.center; }

    /** @param {number} v The zoom factor (pixel size, in ground m) */
    setZf(v) { this.zf = v; }
    /** @returns {number} The zoom factor (pixel size, in ground m) */
    getZf() { return this.zf; }




    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.getZf();
        const tx = -this.center.x / this.getZf() + this.w * 0.5;
        const ty = this.center.y / this.getZf() + this.h * 0.5;
        this.ctx.setTransform(k, 0, 0, -k, tx, ty);
    }


    /** The function specifying how to draw the map. */
    redraw() {
        throw new Error('Method redraw not implemented.');
    }

    /**
     * Clear the app screen. To be used before a redraw for example.
     * @param {string} color 
     */
    clear(color = "white") {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.w, this.h);
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
    */
    geoToPixX(xGeo) { return (xGeo - this.center.x) / this.getZf() + this.w * 0.5; }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
    */
    geoToPixY(yGeo) { return -(yGeo - this.center.y) / this.getZf() + this.h * 0.5; }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
    */
    pixToGeoX(x) { return (x - this.w * 0.5) * this.getZf() + this.center.x; }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
    */
    pixToGeoY(y) { return -(y - this.h * 0.5) * this.getZf() + this.center.y; }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo, dyGeo) {
        //TODO force extend to remain
        this.center.x += dxGeo;
        this.center.y += dyGeo;
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.center.x, yGeo = this.center.y) {
        //TODO force extend to remain
        this.setZf(f * this.getZf());
        this.center.x += (xGeo - this.center.x) * (1 - f)
        this.center.y += (yGeo - this.center.y) * (1 - f)
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * @param {number} marginPx 
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx)
        }
        return this.extGeo;
    }

    /**
     * Check if the object has to be drawn
     * 
     * @param {{x:number,y:number}} obj 
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false;
        if (obj.x > this.extGeo.xMax) return false;
        if (obj.y < this.extGeo.yMin) return false;
        if (obj.y > this.extGeo.yMax) return false;
        return true
    }

}


/***/ }),

/***/ "./src/base/SpatialIndex.js":
/*!**********************************!*\
  !*** ./src/base/SpatialIndex.js ***!
  \**********************************/
/*! exports provided: SpatialIndex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpatialIndex", function() { return SpatialIndex; });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
//@ts-check

//see https://github.com/mourner/rbush


/**
 * @template T
 */
class SpatialIndex {

    /**
     * @constructor
     */
    constructor() {
        class MyRBush extends rbush__WEBPACK_IMPORTED_MODULE_0___default.a {
            /** @param {{x:number,y:number}} obj  */
            toBBox(obj) { return { minX: obj.x, minY: obj.y, maxX: obj.x, maxY: obj.y }; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinX(a, b) { return a.x - b.x; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinY(a, b) { return a.y - b.y; }
        }

        /** @type {MyRBush} */
        this.tree = new MyRBush();
    }

    //TODO bulk remove ?

    /**
     * @param {number} xmin
     * @param {number} ymin
     * @param {number} xmax
     * @param {number} ymax
     * @return {Array.<T>}
     */
    get(xmin, ymin, xmax, ymax) {
        return this.tree.search({
            minX: xmin,
            minY: ymin,
            maxX: xmax,
            maxY: ymax
        });
    }

    /**
     * @param {T} obj
     */
    insert(obj) {
        this.tree.insert(obj);
    }

    /**
     * Bulk insert
     * 
     * @param {Array.<T>} objs
     */
    load(objs) {
        this.tree.load(objs);
    }

    /**
     * @param {T} obj
     */
    remove(obj) {
        this.tree.remove(obj)
    }

    /**
     */
    clear() {
        this.tree.clear()
    }

}


/***/ }),

/***/ "./src/base/lib.js":
/*!*************************!*\
  !*** ./src/base/lib.js ***!
  \*************************/
/*! exports provided: objToArray, removeFromArray, removeFromArrayS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objToArray", function() { return objToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArray", function() { return removeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArrayS", function() { return removeFromArrayS; });
//@ts-check
/**
 * @template T
 * @param {Object.<?, T>} obj
 * @returns {Array.<T>}
 */
const objToArray = function (obj) {
    var out = [];
    for (var key in obj)
        if (obj.hasOwnProperty(key))
            out.push(obj[key]);
    return out;
};

/**
 * @template T
 * @param {Array.<T>} arr
 * @param {T} obj
 * @param {boolean} msg 
 */
const removeFromArray = function (arr, obj, msg = true) {
    /** @type {number} */
    var index = arr.indexOf(obj);
    if (index > -1)
        arr.splice(index, 1);
    else
        if (msg) console.log("Impossible to remove element not present in array.");
};

/**
 * 
 * @template T
 * @param {Array.<T>} arr
 * @param {Array.<T>} objs 
 * @param {boolean} msg 
 */
const removeFromArrayS = function (arr, objs, msg = true) {
    for (let obj of objs)
        removeFromArray(arr, obj, msg)
};


/***/ }),

/***/ "./src/fish/Sardin.js":
/*!****************************!*\
  !*** ./src/fish/Sardin.js ***!
  \****************************/
/*! exports provided: Sardin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sardin", function() { return Sardin; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check





/** */
class Sardin extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {Sea} sea 
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(sea, x = sea.w * Math.random(), y = sea.h * Math.random(), sx = undefined, sy = undefined) {

        //
        super(x, y, sx, sy)

        /** @type {Sea} */
        this.sea = sea;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > sea.w ? sea.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > sea.h ? sea.h : y

        //speed
        if (!sx && !sy) {
            this.setRandomSpeed(0, this.sea.V_MAX)

            //acceleration
            /** @type {number} */
            this.ax = 0
            /** @type {number} */
            this.ay = 0

            //list of sardins in vision field
            /** @type {Array.<Sardin>} */
            this.obs = []
            //list of sardins in collision field
            /** @type {Array.<Sardin>} */
            this.col = []
        }
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    observe(sindex) {

        /** @type {Sea} */
        const s = this.sea
        /** @type {number} */
        const dO = s.D_OBS

        //initialise lists
        /** @type {Array.<Sardin>} */
        this.obs = [];
        /** @type {Array.<Sardin>} */
        this.col = [];

        //get sardins around using spatial index
        /** @type {Array.<Sardin>} */
        const ss = sindex.get(this.x - dO, this.y - dO, this.x + dO, this.y + dO);

        //get sardins in observation and collision fields
        for (let f of ss) {
            if (f == this) continue;
            if (this.d(f) <= s.D_COL)
                this.col.push(f);
            if (this.d(f) <= dO) {
                //check angle
                let da = Math.atan2(f.y - this.y, f.x - this.x) - this.sa;
                if (da > Math.PI) da -= 2 * Math.PI;
                else if (da <= -Math.PI) da += 2 * Math.PI;
                da = Math.abs(da);
                if (da > s.A_OBS * 0.5) continue;
                this.obs.push(f);
            }
        }

        //initialise acceleration
        this.ax = 0; this.ay = 0;

        //collision: repulsion
        for (let f of this.col) {
            const d = this.d(f);
            const a = 1.0 * (1 / (d * d) - 1 / (s.D_COL * s.D_COL));
            this.ax += a * (this.x - f.x) / d;
            this.ay += a * (this.y - f.y) / d;
        }

        // toward target speed
        const dv = (s.V_TARGET - this.s) * 0.01;
        this.ax += dv * this.sx / this.s;
        this.ay += dv * this.sy / this.s;

        //toward the observed mean position
        /*if(obs.size()>1){
            double xn=0,yn=0;
            for(Sardin s:obs){
                xn+=s.x;
                yn+=s.y;
            }
            xn=xn/obs.size();
            yn=yn/obs.size();
            double d=Math.hypot(xn-x,yn-y);
            ax+=-0.1*(x-xn)/d;
            ay+=-0.1*(y-yn)/d;
        }*/

        //toward the observed speed
        const t = 0.9;
        if (this.obs.length > 1) {
            let dsx = 0, dsy = 0;
            for (let s of this.obs) {
                dsx += s.sx;
                dsy += s.sy;
            }
            dsx = (t - 1) * this.sx + (1 - t) * dsx / this.obs.length;
            dsy = (t - 1) * this.sy + (1 - t) * dsy / this.obs.length;

            const a = 0.1;
            this.ax += a * dsx;
            this.ay += a * dsy;
        }

        //avoid shark
        const sh = s.shark;
        if (sh != null) {
            const d = Math.hypot((sh.x - this.x), (sh.y - this.y));
            if (d <= s.D_OBS) {
                const a = 5.0 * (1 / (d * d) - 1 / (dO * dO));
                this.ax += a * (this.x - sh.x) / d;
                this.ay += a * (this.y - sh.y) / d;
            }
        }

    }


    /**
     * @param {number} timeStepMs 
     */
    move(timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.sy += this.ay * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.s = this.computeSpeed()
        if (this.s > this.sea.V_MAX) {
            this.s = this.sea.V_MAX;
            this.sx = this.sea.V_MAX * Math.cos(this.sa);
            this.sy = this.sea.V_MAX * Math.sin(this.sa);
        }

        //compute new position
        this.x += this.sx * timeStepMs;
        this.y += this.sy * timeStepMs;

        //limit
        if (this.x < 0) this.x = this.sea.w;
        if (this.y < 0) this.y = this.sea.h;
        if (this.x > this.sea.w) this.x = 0;
        if (this.y > this.sea.h) this.y = 0;
    }


    /**
     * Display a sardin body
     * 
     * @param {GeoCanvas} cp 
     * @param {number} length 
     */
    display(cp, length) {
        const c2 = cp.ctx
        const c = Math.floor(255 * Math.abs(this.sa) / Math.PI);
        c2.strokeStyle = "rgb(255, 255, " + c + ")"
        const a = length / this.s;
        const dx = a * this.sx * 0.5;
        const dy = a * this.sy * 0.5;

        c2.beginPath();
        c2.moveTo(this.x - dx, this.y - dy);
        c2.lineTo(this.x + dx, this.y + dy);
        c2.closePath();
        c2.stroke();
    }

    /**
     * Display sardin vision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} lineWidth 
     */
    displayVisionField(cp, fillStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.arc(this.x, this.y, this.sea.D_OBS / cp.getZf(),
            this.sa - this.sea.A_OBS * 0.5,
            this.sa + this.sea.A_OBS * 0.5
        );
        c2.closePath();
        c2.fill();
    }

    /**
     * Display sardin vision links
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayVisionLinks(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        for (let sa2 of this.obs) {
            c2.beginPath();
            c2.moveTo(this.x, this.y);
            c2.lineTo(sa2.x, sa2.y);
            c2.closePath();
            c2.stroke();
        }
    }

    /**
     * Display sardin collision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayCollisionField(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.sea.D_COL * 0.5 / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/fish/Sea.js":
/*!*************************!*\
  !*** ./src/fish/Sea.js ***!
  \*************************/
/*! exports provided: Sea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sea", function() { return Sea; });
/* harmony import */ var _Sardin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sardin */ "./src/fish/Sardin.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
//@ts-check




/** */
class Sea {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */        //get 10 random locations

    constructor(w, h) {

        //TODO should become static attributes of Sardin class

        //observation
        /** @type {number} */
        this.D_OBS = 50
        /** @type {number} */
        this.A_OBS = 200 * Math.PI / 180

        //collision
        /** @type {number} */
        this.D_COL = 10

        //speed
        /** @type {number} */
        this.V_TARGET = 0.3
        /** @type {number} */
        this.V_MAX = 0.6

        //shark
        /** @type {number} */
        this.D_SHARK_EAT = 12
        /** @type {number} */
        this.EATEN_SARDIN_NB = 0


        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Sardin>} */
        this.fish = []

        //TODO
        this.shark = null;

        /** @type {Array.<Sardin>} */
        this.killed = [];
    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //ini
        for (let f of this.fish) {
            f.computeSpeed()
            f.computeSpeedAngle()
        }

        //make spatial index
        /** @type {SpatialIndex.<Sardin>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.fish)

        //observe
        for (let f of this.fish)
            f.observe(sindex);

        //shark eat fish
        this.sharkEat(sindex);

        //dispose spatial index
        //sindex.clear()

        //move
        for (let f of this.fish)
            f.move(timeStepMs);
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    sharkEat(sindex) {
        if (this.shark == null) return;

        /** @type {Array.<Sardin>} */
        this.killed = [];

        const x = this.shark.x, y = this.shark.y;
        const ss = sindex.get(x - this.D_SHARK_EAT, y - this.D_SHARK_EAT, x + this.D_SHARK_EAT, y + this.D_SHARK_EAT);
        for (let s of ss) {
            const d = Math.hypot((x - s.x), (y - s.y));
            if (d > this.D_SHARK_EAT) continue;
            this.killed.push(s);
            Object(_base_lib__WEBPACK_IMPORTED_MODULE_2__["removeFromArray"])(this.fish, s)
            //sindex.remove(s);
        }
        this.EATEN_SARDIN_NB += this.killed.length;
        //eatenFishNb.setText("Eaten fish: " + EATEN_SARDIN_NB);
        return this;
    }

    /**
     * Add fish
     * 
     * @param {number} nb 
     * @returns {this}
     */
    addFish(nb = 1) {
        for (let i = 0; i < nb; i++)
            this.fish.push(new _Sardin__WEBPACK_IMPORTED_MODULE_0__["Sardin"](this));
        return this
    }

    /**
     * Set random speed for all fish
     * @returns {this}
     */
    setRandomSpeed() {
        for (let f of this.fish)
            f.setRandomSpeed()
        return this
    }

}


/***/ }),

/***/ "./src/fish/index.js":
/*!***************************!*\
  !*** ./src/fish/index.js ***!
  \***************************/
/*! exports provided: fish */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return fish; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check



class FishSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        //TODO
        //add eaten fish nb label

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        /** @type {boolean} */
        this.showFishVisionField = false
        /** @type {boolean} */
        this.showFishVisionLinks = false
        /** @type {boolean} */
        this.showFishCollisionField = false

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx
            const s = th.sea

            this.initCanvasTransform()

            //clear
            c2.fillStyle = "rgba(120,120,255,0.6)";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //show vision field
            if (th.showFishVisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionField(this, "rgba(200,200,200,0.15)", 1)
            //show vision links
            if (th.showFishVisionLinks)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionLinks(this, "rgba(255,100,100,0.3)", 1)
            //show collision field
            if (th.showFishCollisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayCollisionField(this, "purple", 1)


            //display sardins
            c2.lineWidth = 2
            const sardinLength = 7
            for (let sa of s.fish)
                if (this.toDraw(sa))
                    sa.display(this, sardinLength)


            //display shark
            if (s.shark != null) {

                c2.lineWidth = 4
                c2.strokeStyle = "black"

                const sharkLength = 12
                const dx = sharkLength * Math.cos(s.shark.angle);
                const dy = sharkLength * Math.sin(s.shark.angle);

                c2.beginPath();
                c2.moveTo(s.shark.x, s.shark.y);
                c2.lineTo(s.shark.x - dx, s.shark.y + dy);
                c2.closePath();
                c2.stroke();
            }

            //display blood spot
            c2.fillStyle = "red";
            c2.lineWidth = 1
            for (let sa of s.killed) {
                c2.beginPath();
                c2.moveTo(sa.x, sa.y);
                c2.arc(sa.x, sa.y, 4, 0, 2 * Math.PI);
                c2.closePath();
                c2.fill();
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        this.cplus.canvas.addEventListener("mouseover", e => {
            th.sea.shark = { x: th.cplus.pixToGeoX(e.offsetX), y: th.cplus.pixToGeoY(e.offsetY), angle: 0 }
        });
        this.cplus.canvas.addEventListener("mousemove", e => {
            const xG = th.cplus.pixToGeoX(e.offsetX);
            const yG = th.cplus.pixToGeoY(e.offsetY);
            const angle = Math.atan2(-yG + th.sea.shark.y, xG - th.sea.shark.x);
            th.sea.shark = { x: xG, y: yG, angle: angle }
        });
        this.cplus.canvas.addEventListener("mouseout", e => {
            th.sea.shark = null;
        });


        /** @type {Sea} */
        this.sea = new _Sea__WEBPACK_IMPORTED_MODULE_0__["Sea"](this.w, this.h)

    }


    /**
     * @param {number} density 
     * @returns {this}
     */
    initRandom(density = 0.001) {
        this.sea.addFish(density * this.sea.w * this.sea.h);
        return this
    }

    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.sea.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this
    }

}

/**
 * @param {Object} opts 
 */
const fish = function (opts) {
    return new FishSimulation(opts)
}


/***/ }),

/***/ "./src/gol/Cell.js":
/*!*************************!*\
  !*** ./src/gol/Cell.js ***!
  \*************************/
/*! exports provided: Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return Cell; });
//@ts-check

/**
 * 
 */
class Cell {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} nb 
     */
    constructor(x, y, nb=0) {
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.nb = nb
    }

}


/***/ }),

/***/ "./src/gol/Universe.js":
/*!*****************************!*\
  !*** ./src/gol/Universe.js ***!
  \*****************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




/**
 * 
 */
class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Cell>} */
        this.population = [];
        /** @type {Object.<string,Cell>} */
        this.populationI = {};
    }

    /**
     * @param {number} x
     * @param {number} y
     * @returns {Cell|null}
     */
    add(x, y) {

        //find cell at location
        /**@type {string}*/
        const id = x + "_" + y;
        if (this.populationI[id]) return null;

        //create new cell
        /**@type {Cell} */
        const cell = new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x, y, 0)
        this.population.push(cell)
        this.populationI[id] = cell
        return cell
    }

    /**
     * @returns {this}
     */
    step() {

        //TODO double indexing? by raw and then column ?
        //populate cell surroundings
        /** @type {Object.<string, Cell>}
         * @dict */
        const surI = {};
        //go through list of cells
        for (let cell of this.population) {
            // +1 surrounding cells
            const srs = Universe.getCellSurrounding(cell, this);
            for (let sur of srs) {
                const key = sur.x + "_" + sur.y;
                const sur_ = surI[key];
                if (sur_) {
                    sur_.nb++;
                } else {
                    sur.nb = 1;
                    surI[key] = sur;
                }
            }
        }

        //B3/S23
        //kill cells
        /** @type {Array.<Cell>} */
        const cellsToKeep = [];
        /** @type {Object.<string, Cell>}
         * @dict */
        const cellsToKeepI = {};
        for (let cell of this.population) {
            const key = cell.x + "_" + cell.y;
            const cell_ = surI[key];
            if (!cell_) continue;
            //if (nb<2 or nb>3) -> kill
            if (cell_.nb < 2 || cell_.nb > 3) continue;
            cellsToKeep.push(cell);
            cellsToKeepI[key] = cell;
        }
        this.population = cellsToKeep;
        this.populationI = cellsToKeepI;

        //create new cells
        /** @type {Array.<Cell>} */
        const surs = Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["objToArray"])(surI);
        for (let sur of surs) {

            if (sur.nb !== 3) continue;

            //check if already alive
            const key = sur.x + "_" + sur.y;
            let cell = this.populationI[key];
            if (cell) continue;

            //create new cell
            this.population.push(sur);
            this.populationI[key] = sur;
        }
        return this;
    }


    /**
     * @param {number} nb
     * @param {number} timeoutMS
     * @param {GeoCanvas} cplus
     * @return {Universe}
     */
    start(nb, timeoutMS, cplus) {
        let i = 0;
        const uni = this;
        const engine = function () {
            //console.log(i);
            uni.step();
            cplus.redraw();
            if (nb > 0 && i++ > nb) return;
            setTimeout(engine, timeoutMS);
        };
        engine();
        return this;
    }

    /**
     * @param {Cell} cell
     * @param {Universe} uni
     * @return {Array.<Cell>}
     */
    static getCellSurrounding(cell, uni) {
        const x1 = cell.x === 0 ? uni.w - 1 : cell.x - 1;
        const x2 = cell.x === uni.w - 1 ? 0 : cell.x + 1;
        const y1 = cell.y === 0 ? uni.h - 1 : cell.y - 1;
        const y2 = cell.y === uni.h - 1 ? 0 : cell.y + 1;
        return [
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y2),
        ];
    }

}


/***/ }),

/***/ "./src/gol/index.js":
/*!**************************!*\
  !*** ./src/gol/index.js ***!
  \**************************/
/*! exports provided: gameOfLife */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return gameOfLife; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Universe */ "./src/gol/Universe.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




//TODO zoom/pan, with canvas transform: better universe limits
//TODO buttons (play, stop, speed, draw, pan)
//TODO check canvas animation


class GoLSimulation {

    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //clear
            this.initCanvasTransform()
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            //draw cells
            this.setCanvasTransform()
            c2.fillStyle = "blue";
            for (let cell of th.uni.population)
                c2.fillRect((cell.x), (cell.y), 1, 1);

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };

        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_1__["Universe"](this.w, this.h);
    }


    //
    initRandom(density = 0.05) {
        let i = 0;
        /** @type {number} */
        const nb = this.uni.w * this.uni.h * density;
        while (i < nb) {
            const x = Math.round(this.uni.w * Math.random());
            const y = Math.round(this.uni.h * Math.random());
            /** @type {Cell} */
            const cell = this.uni.add(x, y);
            if (cell) i++;
        }
        return this;
    }


    //
    start() {
        this.uni.start(-1, 0, this.cplus);
        return this;
    }

}


const gameOfLife = function (opts) {
    return new GoLSimulation(opts)
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: planets, gameOfLife, fish, preyPredator, urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _planets_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planets/index */ "./src/planets/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return _planets_index__WEBPACK_IMPORTED_MODULE_0__["planets"]; });

/* harmony import */ var _gol_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gol/index */ "./src/gol/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return _gol_index__WEBPACK_IMPORTED_MODULE_1__["gameOfLife"]; });

/* harmony import */ var _fish_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fish/index */ "./src/fish/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return _fish_index__WEBPACK_IMPORTED_MODULE_2__["fish"]; });

/* harmony import */ var _pp_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pp/index */ "./src/pp/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return _pp_index__WEBPACK_IMPORTED_MODULE_3__["preyPredator"]; });

/* harmony import */ var _urban_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./urban/index */ "./src/urban/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return _urban_index__WEBPACK_IMPORTED_MODULE_4__["urban"]; });

//@ts-check








/***/ }),

/***/ "./src/planets/Planet.js":
/*!*******************************!*\
  !*** ./src/planets/Planet.js ***!
  \*******************************/
/*! exports provided: Planet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Planet", function() { return Planet; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




class Planet extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @constructor
     * @param {Universe} u The universe the planet belongs to.
     * @param {number} m The mass
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} sx The speed x
     * @param {number} sy The speed y
     */
    constructor(u, m, x, y, sx = 0, sy = 0) {

        //
        super(x, y, sx, sy)

        /** @type {Universe} */
        this.u = u;
        u.ps.push(this)

        /** @type {number} */
        this.m = m;

        //compute radius
        /** @type {number} */
        const r = this.r();

        //set position
        /** @type {number} */
        this.x = x < r ? r : x > u.w - r ? u.w - r : x;
        /** @type {number} */
        this.y = y < r ? r : y > u.h - r ? u.h - r : y;

        //acceleration
        /** @type {number} */
        this.ax = 0;
        /** @type {number} */
        this.ay = 0;
    }

    /**
     * Update the force, based on the gravity of other planets.
     * @param {number} exponent
     */
    observe(exponent) {

        //compute gravity field at planet location
        const g = this.u.getGravityField(this.x, this.y, this, exponent);

        //set acceleration
        /** @type {number} */
        this.ax = g.gx;
        /** @type {number} */
        this.ay = g.gy;
    }


    /**
     * @return {number} The radius of the planet, depending on its mass.
     */
    r() {
        return Math.pow(this.m / Math.PI, 0.5);
    }


    /**
     * 
     * @param {boolean} bounce 
     * @param {number} maxSpeed 
     * @param {number} timeStepMs 
     */
    change(bounce = false, maxSpeed = 0.8, timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs;
        this.sy += this.ay * timeStepMs;

        //check vmax
        if (maxSpeed > 0) {
            /** @type {number} */
            const v = Math.sqrt(this.sx * this.sx + this.sy * this.sy);
            if (v > maxSpeed) {
                this.sx = maxSpeed * this.sx / v;
                this.sy = maxSpeed * this.sy / v;
            }
        }

        //compute new position
        /** @type {number} */
        let nx = this.x + this.sx * timeStepMs;
        /** @type {number} */
        let ny = this.y + this.sy * timeStepMs;

        //handle position limit
        if (bounce) {
            const r = this.r();
            const e = 1;
            if (nx < r) { nx = r; this.sx = -this.sx * e; }
            if (ny < r) { ny = r; this.sy = -this.sy * e; }
            if (nx > this.u.w - r) { nx = this.u.w - r; this.sx = -this.sx * e; }
            if (ny > this.u.h - r) { ny = this.u.h - r; this.sy = -this.sy * e; }
        } else {
            if (nx < 0) { nx = this.u.w; }
            if (ny < 0) { ny = this.u.h; }
            if (nx > this.u.w) { nx = 0; }
            if (ny > this.u.h) { ny = 0; }
        }

        //move
        this.x = nx;
        this.y = ny;
    }


    /**
     * Display planet
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     */
    display(cp, fillStyle) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r() / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
    }

    /**
     * Display planet acceleration
     * 
     * @param {GeoCanvas} cp 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     * @param {number} factor 
     */
    displayAcceleration(cp, strokeStyle = "cyan", lineWidth = 1, factor = 5000) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.lineTo(this.x + factor * this.ax, this.y + factor * this.ay);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/planets/Universe.js":
/*!*********************************!*\
  !*** ./src/planets/Universe.js ***!
  \*********************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
//@ts-check




class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Planet>} */
        this.ps = [];
    }

    /**
     * Compute the mass of the universe, as the sum of the mass of its planets.
     * @returns {number}
     */
    m() {
        let m = 0;
        for (let p of this.ps)
            m += p.m;
        return m;
    }


    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {Planet} pIgnore A planet to ignore
     * @param {number} exponent
     * @returns {{gx:number,gy:number}}
     */
    getGravityField(x, y, pIgnore = undefined, exponent = 2) {

        /** @type {number} */
        let gx = 0
        /** @type {number} */
        let gy = 0

        //gothrough all planets in the universe
        for (let p of this.ps) {

            //ignore planet
            if (pIgnore && p == pIgnore)
                continue;

            //compute distance
            /** @type {number} */
            let d = p.dP(x, y);
            if (d === 0)
                continue;

            //compute and add contribution
            d = d * Math.pow(d, exponent);
            gx += 0.01 * (p.x - x) * p.m / d;
            gy += 0.01 * (p.y - y) * p.m / d;
        }
        return { gx: gx, gy: gy }
    }


    /**
     * Aggregate two planets
     * 
     * @param {Planet} p1
     * @param {Planet} p2
     * @param {SpatialIndex.<Planet>} sindex
     * @returns {Planet}
     */
    aggregate(p1, p2, sindex) {
        const m = p1.m + p2.m;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](
            this,
            m,
            (p1.x * p1.m + p2.x * p2.m) / m,
            (p1.y * p1.m + p2.y * p2.m) / m,
            (p1.sx * p1.m + p2.sx * p2.m) / m,
            (p1.sy * p1.m + p2.sy * p2.m) / m
        );
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p1);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p2);

        if (sindex) {
            sindex.remove(p1)
            sindex.remove(p2)
            sindex.insert(p)
        }

        return p;
    }



    /**
     * @param {SpatialIndex.<Planet>} sindex
     * @param {number} collisionFactor
     * @returns {Array.<Planet>}
     */
    findCollision(sindex, collisionFactor = 1) {
        for (let pi of this.ps) {

            const w = 2 * pi.r();
            const cand = sindex.get(pi.x - w, pi.y - w, pi.x + w, pi.y + w);

            for (let pj of cand) {

                if (pi == pj) continue;

                /** @type {number} */
                const d1 = pi.d(pj);
                /** @type {number} */
                const d2 = (pi.r() + pj.r()) * collisionFactor;
                if (d1 > d2)
                    continue;
                return [pi, pj];

            }
        }
        return null;
    }


    /**
     * Add planets with random speed
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed
     * @param {number} maxSpeed
     * @returns {this}
     */
    addPlanets(nb = 1, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        for (let i = 0; i < nb; i++) {
            const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, mi, this.w * Math.random(), this.h * Math.random());
            p.setRandomSpeed(minSpeed, maxSpeed);
        }
        return this;
    }



    /**
     * 
     * @param {boolean} bounce 
     * @param {number} vmax 
     * @param {number} exponent 
     * @param {number} collisionFactor 
     * @param {number} timeStepMs 
     * @returns {this}
     */
    step(bounce = false, vmax = 0.8, exponent = 2, collisionFactor = 1, timeStepMs = 10) {

        //observation
        for (let p of this.ps)
            p.observe(exponent);

        //action
        for (let p of this.ps)
            p.change(bounce, vmax, timeStepMs);


        //collision detection
        this.detectCollisions(collisionFactor)

        return this;
    }

    /**
     * @param {number} collisionFactor 
     * @returns {this}
     */
    detectCollisions(collisionFactor = 1) {

        /** @type {SpatialIndex.<Planet>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.ps)

        //find first collision
        /** @type {Array.<Planet>} */
        let pair = this.findCollision(sindex, collisionFactor);
        while (pair !== null) {

            //aggregate
            const p = this.aggregate(pair[0], pair[1], sindex)

            //find next collision
            pair = this.findCollision(sindex, collisionFactor);
        }

        return this;
    }


    /**
     * Assign random speed to all planets
     * 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        for (let p of this.ps)
            p.setRandomSpeed(minSpeed, maxSpeed)
        return this
    }

    /**
     * @returns {Planet} The largest planet of the universe, usually the star.
     */
    getLargestPlanet() {
        let pM = null, mM = 0;
        for (let p of this.ps)
            if (p.m > mM) { pM = p; mM = p.m }
        return pM
    }

    /**
     * Get largest planet and explode it.
     */
    explodeLargestPlanet() {
        const p = this.getLargestPlanet()
        this.explode(p)
    }

    /**
     * Explode a planet into pieces
     * 
     * @param {Planet} p 
     * @param {number} nb 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     */
    explode(p, nb = -1, minSpeed = 0.8, maxSpeed = 1.5, rad = -1) {
        if (nb <= 0) nb = Math.floor(p.m);
        if (nb <= 0) return;
        const angleStep = 2 * Math.PI / nb;
        for (let i = 0; i < nb; i++) {
            //create planet

            //position
            if (rad < 0) rad = 2 * p.r()
            const d = rad * Math.random();
            const a = i * angleStep;
            const x = d * Math.cos(a), y = d * Math.sin(a);

            //speed
            const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
            const aS = a + 2 * (Math.random() - 0.5) * 2 * Math.PI / 3;
            const sx = speed * Math.cos(aS), sy = speed * Math.sin(aS);

            new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, p.m / nb, p.x + x, p.y + y, p.sx + sx, p.sy + sy)
        }
        //remove p from universe
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p);
    }

}


/***/ }),

/***/ "./src/planets/index.js":
/*!******************************!*\
  !*** ./src/planets/index.js ***!
  \******************************/
/*! exports provided: planets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return planets; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/**  */
class PlanetSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {number} */
        this.maxSpeed = opts.maxSpeed || 0.8;
        /** @type {boolean} */
        this.bounce = opts.bounce || false
        /** @type {number} */
        this.exponent = opts.exponent || 2;
        /** @type {number} */
        this.collisionFactor = opts.collisionFactor || 1;

        /** @type {boolean} */
        this.showPlanetAcceleration = false

        /** @type {string|undefined} */
        this.showField = undefined
        /** @type {number} */
        this.fieldRes = 20
        /** @type {number} */
        this.fieldFactor = 1000
        /** @type {string} */
        this.fieldStrokeStyle = "#99bbff";

        /** @type {number} */
        this.tailings = opts.tailings || 0.1;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear, with transparency
            c2.fillStyle = "rgba(0,0,0," + th.tailings + ")";
            c2.fillRect(0, 0, th.w, th.h);
            //c2.fillRect(-1e20, -1e20, 2e20, 2e20); //todo

            //display gravity field
            if (th.showField === "f")
                th.displayGravityField(this, true)
            else if (th.showField === "i")
                th.displayGravityField(this, false)


            this.setCanvasTransform()

            //display planets
            for (let p of th.uni.ps) {
                if (!this.toDraw(p)) continue
                const t = p.m / th.uni.m();
                p.display(this, "rgb(255,255," + Math.floor(255 * (1 - t)) + ")")
            }

            //display planets acceleration
            if (th.showPlanetAcceleration) {
                for (let p of th.uni.ps) {
                    if (!this.toDraw(p)) continue
                    p.displayAcceleration(this)
                }
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Universe} */
        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_0__["Universe"](this.w, this.h)
    }


    /**
     * @param {GeoCanvas} cp 
     * @param {boolean} field 
     */
    displayGravityField(cp, field = true) {
        const c2 = cp.ctx
        const res = this.fieldRes
        const f = this.fieldFactor
        const f_ = field ? 0.3 * res : 0.6 * res;
        c2.strokeStyle = this.fieldStrokeStyle
        for (let x = res * 0.5; x < this.w; x += res) {
            const xG = cp.pixToGeoX(x);
            if (xG > this.uni.w || xG < 0) continue
            for (let y = res / 2; y < this.h; y += res) {
                const yG = cp.pixToGeoY(y);
                if (yG > this.uni.h || yG < 0) continue
                //get gravity field
                const g = this.uni.getGravityField(xG, yG, undefined, this.exponent);
                const g_ = Math.hypot(g.gx, g.gy)

                c2.lineWidth = Math.min(f * g_, 0.3 * res);
                const dx = f_ * g.gx / g_, dy = f_ * g.gy / g_

                //draw
                c2.beginPath();
                if (field) {
                    //gravity field
                    c2.moveTo(x - dx, y + dy);
                    c2.lineTo(x + dx, y - dy);
                } else {
                    //isopotential lines
                    c2.moveTo(x + dy, y + dx);
                    c2.lineTo(x - dy, y - dx);
                }
                c2.closePath();
                c2.stroke();
            }
        }
    }


    /**
     * Initialise with random planets
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    initRandom(nb = 1000, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        this.uni.addPlanets(nb, mi, minSpeed, maxSpeed);
        return this;
    }

    /**
     * Initialise with big bang setup
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     * @returns {this}
     */
    initBigBang(nb = 1000, mi = 1, minSpeed = 0.35, maxSpeed = 0.7, rad = 100) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        //create big planet in the middle
        const cx = this.w * 0.5, cy = this.h * 0.5;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_1__["Planet"](this.uni, nb * mi, cx, cy, 0, 0);
        //explode it
        this.uni.explode(p, nb, minSpeed, maxSpeed, rad)
        return this;
    }

    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.uni.step(t.bounce, t.maxSpeed, t.exponent, t.collisionFactor, timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const planets = function (opts) {
    return new PlanetSimulation(opts)
}


/***/ }),

/***/ "./src/pp/Animal.js":
/*!**************************!*\
  !*** ./src/pp/Animal.js ***!
  \**************************/
/*! exports provided: Animal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animal", function() { return Animal; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




/** */
class Animal extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {number} type 
     * @param {Land} l 
     * @param {number} x 
     * @param {number} y 
     */
    constructor(type, l, x = 0, y = 0) {

        super(x, y)

        /** @type {number} */
        this.type = type;
        /** @type {Land} */
        this.l = l;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > l.w ? l.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > l.h ? l.h : y

        //the other animals around
        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        //add to the spatial index
        l.grid.insert(this);
    }


    /**
     * @param {*} timeStepMs 
     */
    move(timeStepMs = 10) {
        const l = this.l
        l.grid.remove(this);

        const angle = Math.random() * 2 * Math.PI;
        const r = 0.01 * Math.random();

        this.sx += r * Math.cos(angle) * timeStepMs;
        this.sx = this.sx > l.V_MAX ? l.V_MAX : this.sx < -l.V_MAX ? -l.V_MAX : this.sx

        this.sy += r * Math.sin(angle) * timeStepMs;
        this.sy = this.sy > l.V_MAX ? l.V_MAX : this.sy < -l.V_MAX ? -l.V_MAX : this.sy

        this.x += this.sx * timeStepMs;
        this.x = this.x < 0 ? l.w : this.x > l.w ? 0 : this.x

        this.y += this.sy * timeStepMs;
        this.y = this.y < 0 ? l.h : this.y > l.h ? 0 : this.y

        l.grid.insert(this);
    }


    /** Observe */
    observe() {
        const l = this.l

        //get animals around
        const as = l.grid.get(this.x - l.d, this.y - l.d, this.x + l.d, this.y + l.d);

        this.preys = [];
        this.predators = [];

        for (let a of as) {
            if (a == this) continue;
            if (this.d(a) > l.d) continue;
            if (a.type == 0)
                this.preys.push(a);
            else
                this.predators.push(a);
        }
    }

    /** @returns {Animal} */
    makeChild() {
        //do better: make child around
        return new Animal(this.type, this.l, this.x, this.y);
    }



    /**
     * Display animal
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} size 
     */
    display(cp, fillStyle = "blue", size = 2) {
        cp.ctx.fillStyle = fillStyle;
        cp.ctx.fillRect(this.x, this.y, size, size);
        /*c2.beginPath();
        c2.arc(a.x, a.y, 0.5, 0, 2*Math.PI);
        c2.closePath();
        c2.fill();*/
    }

}


/***/ }),

/***/ "./src/pp/Land.js":
/*!************************!*\
  !*** ./src/pp/Land.js ***!
  \************************/
/*! exports provided: Land */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Land", function() { return Land; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
//@ts-check




class Land {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */
    constructor(w, h) {

        //the max speed
        /** @type {number} */
        this.V_MAX = 0.1

        /** @type {number} */
        this.p = 0.02 //predator death probability
        /** @type {number} */
        this.q = 0.1 //prey reproduction probability
        /** @type {number} */
        this.r = 0.5 //eaten prey transformation probability
        /** @type {number} */
        this.nb = 3 //neighbors number

        /** @type {number} */
        this.w = w
        /** @type {number} */
        this.h = h

        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        /** @type {number} */
        this.d = 10
        /** @type {SpatialIndex.<Animal>} */
        this.grid = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /*int[][] histo;
        int index=0;
        this.c2Chart=c2Chart;
        this.hChart=hChart;
        this.histo=new int[wChart][];
        for(int i=0;i<wChart;i++)
            histo[i]=new int[]{0,0};*/

    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //observe
        for (let a of this.preys) a.observe();
        for (let a of this.predators) a.observe();

        const preysToBorn = []
        const preysToDie = []
        const predsToBorn = []
        const predsToDie = []

        //prey
        for (let prey of this.preys) {
            //reproduction if no predator around
            if (Math.random() > this.q) continue;
            if (prey.predators.length != 0) continue;
            if (prey.preys.length >= this.nb) continue;
            preysToBorn.push(prey.makeChild());
        }

        //predator
        for (let pred of this.predators) {
            //no prey around: predator dies with probability p
            if (pred.preys.length == 0) {
                if (Math.random() < this.p) predsToDie.push(pred);
            }
            //prey around
            else {
                //eat prey
                //choose randomly
                const preyToEat = pred.preys[Math.floor(pred.preys.length * Math.random())];
                preysToDie.push(preyToEat);

                //predator reproduction
                if (Math.random() > this.r) continue;
                if (pred.predators.length >= this.nb) continue;
                predsToBorn.push(pred.makeChild());
            }
        }

        this.preys.push(...preysToBorn);
        this.predators.push(...predsToBorn);

        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.preys, preysToDie, false)
        for (let a of preysToDie) this.grid.remove(a);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.predators, predsToDie, false)
        for (let a of predsToDie) this.grid.remove(a);

        //move
        for (let a of this.preys)
            a.move(timeStepMs);
        for (let a of this.predators)
            a.move(timeStepMs);

        /*/histo
        histo[index] = new int[]{ preys.size(), predators.size() };
        if (index == histo.length - 1) index = 0;
        else index++;*/

    }
}


/***/ }),

/***/ "./src/pp/index.js":
/*!*************************!*\
  !*** ./src/pp/index.js ***!
  \*************************/
/*! exports provided: preyPredator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return preyPredator; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/** */
class PreyPredatorSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);


        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //transparency
            this.initCanvasTransform()
            c2.fillStyle = "rgba(255,255,255,0.5)";
            c2.fillRect(0, 0, th.w, th.h);

            //display animals
            this.setCanvasTransform()
            for (let a of th.land.preys)
                if (this.toDraw(a))
                    a.display(this, "blue");
            for (let a of th.land.predators)
                if (this.toDraw(a))
                    a.display(this, "red");

            /*/label
            c2.fillStyle = "lightgray";
            c2.fillRect(0, 0, 65, 13);
            c2.fillStyle = "black";
            c2.fillText(preys.length + "/" + predators.length, 2, 10);*/

            //chart
            //c2Chart.setFillStyle(backColor2);
            //c2Chart.fillRect(0, 0, w, h);

            //double max = getMaxHisto();
            /*public int getMaxHisto() {
                int max=0;
                for(int i=0;i<histo.length;i++){
                    if(histo[i][0]>max) max=histo[i][0];
                    if(histo[i][1]>max) max=histo[i][1];
                }
                return max;
            }*/
            /*
                        if (max != 0) {
                            double h1, h2;
                            for (int i = 0; i < histo.length; i++) {
                                h1 = hChart * histo[i][0] / max;
                                h2 = hChart * histo[i][1] / max;
                                c2Chart.setFillStyle(preyColor2);
                                c2Chart.fillRect(i, hChart - h1, 1, h1);
                                c2Chart.setFillStyle(predatorColor2);
                                c2Chart.fillRect(i, hChart - h2, 1, h2);
                            }
                        }
                        c2Chart.setFillStyle(CssColor.make(255, 255, 255));
                        c2Chart.fillRect(index, 0, 1, hChart);
            */

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };


        /** @type {Land} */
        this.land = new _Land__WEBPACK_IMPORTED_MODULE_0__["Land"](this.w, this.h)

    }



    //TODO test init in a bubble ?
    //TODO use density as input parameters instead of nb

    /**
     * 
     * @param {number} preyDensity 
     * @param {number} predatorDensity 
     * @returns {this}
     */
    initRandom(preyDensity = 0.003, predatorDensity = 0.003) {
        const l = this.land
        for (let i = 0; i < preyDensity * l.w * l.h; i++)
            l.preys.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](0, l, l.w * Math.random(), l.h * Math.random())
            );
        for (let i = 0; i < predatorDensity * l.w * l.h; i++)
            l.predators.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](1, l, l.w * Math.random(), l.h * Math.random())
            );
        return this;
    }


    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.land.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

}


/**
 * @param {Object} opts 
 */
const preyPredator = function (opts) {
    return new PreyPredatorSimulation(opts)
}


/***/ }),

/***/ "./src/urban/Building.js":
/*!*******************************!*\
  !*** ./src/urban/Building.js ***!
  \*******************************/
/*! exports provided: Building */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Building", function() { return Building; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check



class Building {

    /**
     * @constructor
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} area The area
     */
    constructor(x, y, area) {

        //set position
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.area = area
    }

    /**
     * @returns { number }
     */
    r() {
        return Math.sqrt(this.area / Math.PI)
    }

    /**
     * @param {Building} b 
     */
    overlap(b) {
        const d1 = b.r() + this.r()
        const d2 = Math.hypot((b.x - this.x), (b.y - this.y));
        return d2 < d1
    }



    /**
     * @param {SpatialIndex.<Building>} sindex 
     * @param {number} sDistance 
     * @returns {boolean}
     */
    checkCollision(sindex, sDistance) {

        //get buildings around using spatial index
        /** @type {Array.<Building>} */
        const ss = sindex.get(this.x - sDistance, this.y - sDistance, this.x + sDistance, this.y + sDistance);

        for (let b of ss) {
            if (b == this) continue;
            if (this.overlap(b)) return true
        }
        return false;
    }




    /**
     * Display
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     * @param {String} strokeStyle 
     */
    display(cp, fillStyle, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
        c2.stroke();
    }


}


/***/ }),

/***/ "./src/urban/Map.js":
/*!**************************!*\
  !*** ./src/urban/Map.js ***!
  \**************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Building__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Building */ "./src/urban/Building.js");
/* harmony import */ var _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RoadNetwork */ "./src/urban/RoadNetwork.js");
//@ts-check




class Map {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Building>} */
        this.bs = [];
        /** @type {SpatialIndex.<Building>} */
        this.buIndex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /** @type {RoadNetwork} */
        this.rn = new _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__["RoadNetwork"]();

        /*
        //test turf
                var ls = turf.lineString([[1000, 0], [1000, 1000]]);
                console.log(ls)
                //var pt = turf.point([1000, 1000]);
                var buff = turf.buffer(ls, 10, 'degrees');
                console.log(buff)
        */

        //test jsts
        //https://bjornharrtell.github.io/jsts/
        /*var reader = new jsts.io.WKTReader()
        var a = reader.read('POINT (-20 0)')
        console.log(reader)
        console.log(a)
        a = a.buffer(40)
        console.log(a)
        var w = new jsts.io.WKTWriter()
        console.log(w.write(a))*/
    }

    /** */
    addBuilding() {

        //compute candidate location, size and type for next building
        //TODO low local congestion AND go to high density (with good access to other stuff)

        //make random building
        const makeRandomBuilding = () => {
            const x = this.w * Math.random();
            const y = this.h * Math.random();
            const area = 40 + 200 * Math.random()
            return new _Building__WEBPACK_IMPORTED_MODULE_1__["Building"](x, y, area)
        }

        //TODO should not overlap with other entities (roads, building)

        /** @type {number} */
        const sDistance = 100;
        /** @type {Building} */
        let bu = makeRandomBuilding();
        while (bu.checkCollision(this.buIndex, sDistance)) {
            bu = makeRandomBuilding();
        }

        //add building
        this.bs.push(bu);
        this.buIndex.load([bu])
    }

    /**
     * @returns {this}
     */
    step() {

        //compute building need
        const buNeed = 10;

        //urbanise
        for (let i = 0; i < buNeed; i++) {
            this.addBuilding();
        }

        //extend road network
        //TODO

        return this;
    }

}


/***/ }),

/***/ "./src/urban/Road.js":
/*!***************************!*\
  !*** ./src/urban/Road.js ***!
  \***************************/
/*! exports provided: Road */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Road", function() { return Road; });
//@ts-check

class Road {

    constructor(geom) {

        this.geom = geom

    }

}


/***/ }),

/***/ "./src/urban/RoadNetwork.js":
/*!**********************************!*\
  !*** ./src/urban/RoadNetwork.js ***!
  \**********************************/
/*! exports provided: RoadNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoadNetwork", function() { return RoadNetwork; });
/* harmony import */ var _Road__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Road */ "./src/urban/Road.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jsts__WEBPACK_IMPORTED_MODULE_1__);
//@ts-check



class RoadNetwork {

    constructor() {

        /** @type {Array.<Road>} */
        this.sections = []


        //add test road

        //https://github.com/bjornharrtell/jsts
        //http://bjornharrtell.github.io/jsts/
        var reader = new jsts__WEBPACK_IMPORTED_MODULE_1___default.a.io.WKTReader()
        var g = reader.read('LINESTRING (30 10, 10 300, 400 40)')
        //a = a.buffer(40)
        //var w = new jsts.io.WKTWriter()
        //console.log(w.write(a))

        this.sections.push(new _Road__WEBPACK_IMPORTED_MODULE_0__["Road"](g));
    }

}


/***/ }),

/***/ "./src/urban/index.js":
/*!****************************!*\
  !*** ./src/urban/index.js ***!
  \****************************/
/*! exports provided: urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return urban; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map */ "./src/urban/Map.js");
//@ts-check



/**  */
class UrbanSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //display buildings
            for (let b of th.map.bs) {
                if (!this.toDraw(b)) continue
                b.display(this, "lightgray", "black", 2)
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Map} */
        this.map = new _Map__WEBPACK_IMPORTED_MODULE_1__["Map"](this.w, this.h)
    }


    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.map.step();
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const urban = function (opts) {
    return new UrbanSimulation(opts)
}


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZWN0YWcvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3ZlY3RhZy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY3ViZWhlbGl4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2RyYWcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9iYWNrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9ib3VuY2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2V4cC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcG9seS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvc2luLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kaXNjcmV0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hjbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hzbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2h1ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbGFiLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JvdW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRvci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9sb2NhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tYXRjaGVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlcnMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2xvd2VyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZXMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvd2luZG93LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW50ZXJydXB0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0clR3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2RlbGF5LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZVZhcnlpbmcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2NoZWR1bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3R3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2pzdHMvZGlzdC9qc3RzLm1pbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvcmJ1c2gvcmJ1c2gubWluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL0FnZW50UG9pbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Jhc2UvR2VvQ2FudmFzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL1NwYXRpYWxJbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvYmFzZS9saWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Zpc2gvU2FyZGluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9maXNoL1NlYS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZmlzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL0NlbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2dvbC9Vbml2ZXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcGxhbmV0cy9QbGFuZXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvVW5pdmVyc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BwL0FuaW1hbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvTGFuZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL0J1aWxkaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9NYXAuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWROZXR3b3JrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDOztBQUVwQzs7QUFFQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBTSxXQUFXLHlEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FB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QUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjs7O0FBR0EsbUJBQW1CLFVBQVU7QUFDN0IseUJBQXlCLHlEQUFTO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixJQUFJO0FBQ3ZCLHVCQUF1Qix3Q0FBRztBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNPO0FBQ1A7QUFDQSIsImZpbGUiOiJ2ZWN0YWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ2ZWN0YWdcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1widmVjdGFnXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImJ1aWxkL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG5leHBvcnQgdmFyIGRhcmtlciA9IDAuNztcbmV4cG9ydCB2YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXG4gICAgcmVOID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIixcbiAgICByZVAgPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIixcbiAgICByZUhleCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLFxuICAgIHJlUmdiSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZUksIHJlSSwgcmVJXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYUludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlSSwgcmVJLCByZUksIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xcXFxcKFwiICsgW3JlTiwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsYVxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpO1xuXG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcblxuZGVmaW5lKENvbG9yLCBjb2xvciwge1xuICBjb3B5OiBmdW5jdGlvbihjaGFubmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCBjaGFubmVscyk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGNvbG9yX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBjb2xvcl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhzbDogY29sb3JfZm9ybWF0SHNsLFxuICBmb3JtYXRSZ2I6IGNvbG9yX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IGNvbG9yX2Zvcm1hdFJnYlxufSk7XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhzbCgpIHtcbiAgcmV0dXJuIGhzbENvbnZlcnQodGhpcykuZm9ybWF0SHNsKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdFJnYigpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICB2YXIgbSwgbDtcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKG0gPSByZUhleC5leGVjKGZvcm1hdCkpID8gKGwgPSBtWzFdLmxlbmd0aCwgbSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbCA9PT0gNiA/IHJnYm4obSkgLy8gI2ZmMDAwMFxuICAgICAgOiBsID09PSAzID8gbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpLCAxKSAvLyAjZjAwXG4gICAgICA6IGwgPT09IDggPyByZ2JhKG0gPj4gMjQgJiAweGZmLCBtID4+IDE2ICYgMHhmZiwgbSA+PiA4ICYgMHhmZiwgKG0gJiAweGZmKSAvIDB4ZmYpIC8vICNmZjAwMDAwMFxuICAgICAgOiBsID09PSA0ID8gcmdiYSgobSA+PiAxMiAmIDB4ZikgfCAobSA+PiA4ICYgMHhmMCksIChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSAvIDB4ZmYpIC8vICNmMDAwXG4gICAgICA6IG51bGwpIC8vIGludmFsaWQgaGV4XG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5nICYmIHRoaXMuZyA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogcmdiX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiByZ2JfZm9ybWF0SGV4LFxuICBmb3JtYXRSZ2I6IHJnYl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiByZ2JfZm9ybWF0UmdiXG59KSk7XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiBcIiNcIiArIGhleCh0aGlzLnIpICsgaGV4KHRoaXMuZykgKyBoZXgodGhpcy5iKTtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdFJnYigpIHtcbiAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gIHJldHVybiAoYSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwiKVxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5yKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmIpIHx8IDApKVxuICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgICByZXR1cm4gKGEgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIilcbiAgICAgICAgKyAodGhpcy5oIHx8IDApICsgXCIsIFwiXG4gICAgICAgICsgKHRoaXMucyB8fCAwKSAqIDEwMCArIFwiJSwgXCJcbiAgICAgICAgKyAodGhpcy5sIHx8IDApICogMTAwICsgXCIlXCJcbiAgICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbiAgfVxufSkpO1xuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcbmltcG9ydCB7Q29sb3IsIHJnYkNvbnZlcnQsIFJnYiwgZGFya2VyLCBicmlnaHRlcn0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmltcG9ydCB7ZGVncmVlcywgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG52YXIgQSA9IC0wLjE0ODYxLFxuICAgIEIgPSArMS43ODI3NyxcbiAgICBDID0gLTAuMjkyMjcsXG4gICAgRCA9IC0wLjkwNjQ5LFxuICAgIEUgPSArMS45NzI5NCxcbiAgICBFRCA9IEUgKiBELFxuICAgIEVCID0gRSAqIEIsXG4gICAgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXhDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHJldHVybiBuZXcgQ3ViZWhlbGl4KG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpLFxuICAgICAgYmwgPSBiIC0gbCxcbiAgICAgIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRCxcbiAgICAgIHMgPSBNYXRoLnNxcnQoayAqIGsgKyBibCAqIGJsKSAvIChFICogbCAqICgxIC0gbCkpLCAvLyBOYU4gaWYgbD0wIG9yIGw9MVxuICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIGRlZ3JlZXMgLSAxMjAgOiBOYU47XG4gIHJldHVybiBuZXcgQ3ViZWhlbGl4KGggPCAwID8gaCArIDM2MCA6IGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY3ViZWhlbGl4Q29udmVydChoKSA6IG5ldyBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShDdWJlaGVsaXgsIGN1YmVoZWxpeCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiByYWRpYW5zLFxuICAgICAgICBsID0gK3RoaXMubCxcbiAgICAgICAgYSA9IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zICogbCAqICgxIC0gbCksXG4gICAgICAgIGNvc2ggPSBNYXRoLmNvcyhoKSxcbiAgICAgICAgc2luaCA9IE1hdGguc2luKGgpO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgMjU1ICogKGwgKyBhICogKEEgKiBjb3NoICsgQiAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoRSAqIGNvc2gpKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGNvbG9yLCByZ2IsIGhzbH0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsYWIsIGhjbCwgbGNoLCBncmF5fSBmcm9tIFwiLi9sYWIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdWJlaGVsaXh9IGZyb20gXCIuL2N1YmVoZWxpeC5qc1wiO1xuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2J9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxuLy8gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxuY29uc3QgSyA9IDE4LFxuICAgIFhuID0gMC45NjQyMixcbiAgICBZbiA9IDEsXG4gICAgWm4gPSAwLjgyNTIxLFxuICAgIHQwID0gNCAvIDI5LFxuICAgIHQxID0gNiAvIDI5LFxuICAgIHQyID0gMyAqIHQxICogdDEsXG4gICAgdDMgPSB0MSAqIHQxICogdDE7XG5cbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIExhYikgcmV0dXJuIG5ldyBMYWIoby5sLCBvLmEsIG8uYiwgby5vcGFjaXR5KTtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBoY2wybGFiKG8pO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gcmdiMmxyZ2Ioby5yKSxcbiAgICAgIGcgPSByZ2IybHJnYihvLmcpLFxuICAgICAgYiA9IHJnYjJscmdiKG8uYiksXG4gICAgICB5ID0geHl6MmxhYigoMC4yMjI1MDQ1ICogciArIDAuNzE2ODc4NiAqIGcgKyAwLjA2MDYxNjkgKiBiKSAvIFluKSwgeCwgejtcbiAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikgeCA9IHogPSB5OyBlbHNlIHtcbiAgICB4ID0geHl6MmxhYigoMC40MzYwNzQ3ICogciArIDAuMzg1MDY0OSAqIGcgKyAwLjE0MzA4MDQgKiBiKSAvIFhuKTtcbiAgICB6ID0geHl6MmxhYigoMC4wMTM5MzIyICogciArIDAuMDk3MTA0NSAqIGcgKyAwLjcxNDE3MzMgKiBiKSAvIFpuKTtcbiAgfVxuICByZXR1cm4gbmV3IExhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geiksIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxuICAgICAgbHJnYjJyZ2IoLTAuOTc4NzY4NCAqIHggKyAxLjkxNjE0MTUgKiB5ICsgMC4wMzM0NTQwICogeiksXG4gICAgICBscmdiMnJnYiggMC4wNzE5NDUzICogeCAtIDAuMjI4OTkxNCAqIHkgKyAxLjQwNTI0MjcgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiBscmdiMnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IybHJnYih4KSB7XG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBuZXcgSGNsKG8uaCwgby5jLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMYWIpKSBvID0gbGFiQ29udmVydChvKTtcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCA8IG8ubCAmJiBvLmwgPCAxMDAgPyAwIDogTmFOLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiBkZWdyZWVzO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGNoKGwsIGMsIGgsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQoaCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBoY2wybGFiKG8pIHtcbiAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBvLmggKiByYWRpYW5zO1xuICByZXR1cm4gbmV3IExhYihvLmwsIE1hdGguY29zKGgpICogby5jLCBNYXRoLnNpbihoKSAqIG8uYywgby5vcGFjaXR5KTtcbn1cblxuZGVmaW5lKEhjbCwgaGNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaGNsMmxhYih0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuIiwiZXhwb3J0IGNvbnN0IHJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuIiwidmFyIG5vb3AgPSB7dmFsdWU6ICgpID0+IHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pIHx8IC9bXFxzLl0vLnRlc3QodCkpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlzcGF0Y2g7XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgZGlzcGF0Y2h9IGZyb20gXCIuL2Rpc3BhdGNoLmpzXCI7XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7c2VsZWN0LCBwb2ludGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9kcmFnLCB7eWVzZHJhZ30gZnJvbSBcIi4vbm9kcmFnLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vbnBhc3NpdmUsIG5vbnBhc3NpdmVjYXB0dXJlLCBub3Byb3BhZ2F0aW9ufSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBEcmFnRXZlbnQgZnJvbSBcIi4vZXZlbnQuanNcIjtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udGFpbmVyKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3ViamVjdChldmVudCwgZCkge1xuICByZXR1cm4gZCA9PSBudWxsID8ge3g6IGV2ZW50LngsIHk6IGV2ZW50Lnl9IDogZDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcixcbiAgICAgIHN1YmplY3QgPSBkZWZhdWx0U3ViamVjdCxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBnZXN0dXJlcyA9IHt9LFxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImRyYWdcIiwgXCJlbmRcIiksXG4gICAgICBhY3RpdmUgPSAwLFxuICAgICAgbW91c2Vkb3dueCxcbiAgICAgIG1vdXNlZG93bnksXG4gICAgICBtb3VzZW1vdmluZyxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgY2xpY2tEaXN0YW5jZTIgPSAwO1xuXG4gIGZ1bmN0aW9uIGRyYWcoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi5kcmFnXCIsIG1vdXNlZG93bmVkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuZHJhZ1wiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS5kcmFnXCIsIHRvdWNobW92ZWQsIG5vbnBhc3NpdmUpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLmRyYWcgdG91Y2hjYW5jZWwuZHJhZ1wiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZChldmVudCwgZCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmNhbGwodGhpcywgZXZlbnQsIGQpKSByZXR1cm47XG4gICAgdmFyIGdlc3R1cmUgPSBiZWZvcmVzdGFydCh0aGlzLCBjb250YWluZXIuY2FsbCh0aGlzLCBldmVudCwgZCksIGV2ZW50LCBkLCBcIm1vdXNlXCIpO1xuICAgIGlmICghZ2VzdHVyZSkgcmV0dXJuO1xuICAgIHNlbGVjdChldmVudC52aWV3KVxuICAgICAgLm9uKFwibW91c2Vtb3ZlLmRyYWdcIiwgbW91c2Vtb3ZlZCwgbm9ucGFzc2l2ZWNhcHR1cmUpXG4gICAgICAub24oXCJtb3VzZXVwLmRyYWdcIiwgbW91c2V1cHBlZCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICAgIG5vZHJhZyhldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBtb3VzZW1vdmluZyA9IGZhbHNlO1xuICAgIG1vdXNlZG93bnggPSBldmVudC5jbGllbnRYO1xuICAgIG1vdXNlZG93bnkgPSBldmVudC5jbGllbnRZO1xuICAgIGdlc3R1cmUoXCJzdGFydFwiLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZW1vdmVkKGV2ZW50KSB7XG4gICAgbm9ldmVudChldmVudCk7XG4gICAgaWYgKCFtb3VzZW1vdmluZykge1xuICAgICAgdmFyIGR4ID0gZXZlbnQuY2xpZW50WCAtIG1vdXNlZG93bngsIGR5ID0gZXZlbnQuY2xpZW50WSAtIG1vdXNlZG93bnk7XG4gICAgICBtb3VzZW1vdmluZyA9IGR4ICogZHggKyBkeSAqIGR5ID4gY2xpY2tEaXN0YW5jZTI7XG4gICAgfVxuICAgIGdlc3R1cmVzLm1vdXNlKFwiZHJhZ1wiLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZXVwcGVkKGV2ZW50KSB7XG4gICAgc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLmRyYWcgbW91c2V1cC5kcmFnXCIsIG51bGwpO1xuICAgIHllc2RyYWcoZXZlbnQudmlldywgbW91c2Vtb3ZpbmcpO1xuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGdlc3R1cmVzLm1vdXNlKFwiZW5kXCIsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZChldmVudCwgZCkge1xuICAgIGlmICghZmlsdGVyLmNhbGwodGhpcywgZXZlbnQsIGQpKSByZXR1cm47XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgYyA9IGNvbnRhaW5lci5jYWxsKHRoaXMsIGV2ZW50LCBkKSxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBiZWZvcmVzdGFydCh0aGlzLCBjLCBldmVudCwgZCwgdG91Y2hlc1tpXS5pZGVudGlmaWVyLCB0b3VjaGVzW2ldKSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgZ2VzdHVyZShcInN0YXJ0XCIsIGV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKGV2ZW50KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgICBnZXN0dXJlKFwiZHJhZ1wiLCBldmVudCwgdG91Y2hlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZChldmVudCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgNTAwKTsgLy8gR2hvc3QgY2xpY2tzIGFyZSBkZWxheWVkIVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgZ2VzdHVyZShcImVuZFwiLCBldmVudCwgdG91Y2hlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3Jlc3RhcnQodGhhdCwgY29udGFpbmVyLCBldmVudCwgZCwgaWRlbnRpZmllciwgdG91Y2gpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBsaXN0ZW5lcnMuY29weSgpLFxuICAgICAgICBwID0gcG9pbnRlcih0b3VjaCB8fCBldmVudCwgY29udGFpbmVyKSwgZHgsIGR5LFxuICAgICAgICBzO1xuXG4gICAgaWYgKChzID0gc3ViamVjdC5jYWxsKHRoYXQsIG5ldyBEcmFnRXZlbnQoXCJiZWZvcmVzdGFydFwiLCB7XG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudCxcbiAgICAgICAgdGFyZ2V0OiBkcmFnLFxuICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICBhY3RpdmUsXG4gICAgICAgIHg6IHBbMF0sXG4gICAgICAgIHk6IHBbMV0sXG4gICAgICAgIGR4OiAwLFxuICAgICAgICBkeTogMCxcbiAgICAgICAgZGlzcGF0Y2hcbiAgICAgIH0pLCBkKSkgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgZHggPSBzLnggLSBwWzBdIHx8IDA7XG4gICAgZHkgPSBzLnkgLSBwWzFdIHx8IDA7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZ2VzdHVyZSh0eXBlLCBldmVudCwgdG91Y2gpIHtcbiAgICAgIHZhciBwMCA9IHAsIG47XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6IGdlc3R1cmVzW2lkZW50aWZpZXJdID0gZ2VzdHVyZSwgbiA9IGFjdGl2ZSsrOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRlbnRpZmllcl0sIC0tYWN0aXZlOyAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgXCJkcmFnXCI6IHAgPSBwb2ludGVyKHRvdWNoIHx8IGV2ZW50LCBjb250YWluZXIpLCBuID0gYWN0aXZlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoLmNhbGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoYXQsXG4gICAgICAgIG5ldyBEcmFnRXZlbnQodHlwZSwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiBldmVudCxcbiAgICAgICAgICBzdWJqZWN0OiBzLFxuICAgICAgICAgIHRhcmdldDogZHJhZyxcbiAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgIGFjdGl2ZTogbixcbiAgICAgICAgICB4OiBwWzBdICsgZHgsXG4gICAgICAgICAgeTogcFsxXSArIGR5LFxuICAgICAgICAgIGR4OiBwWzBdIC0gcDBbMF0sXG4gICAgICAgICAgZHk6IHBbMV0gLSBwMFsxXSxcbiAgICAgICAgICBkaXNwYXRjaFxuICAgICAgICB9KSxcbiAgICAgICAgZFxuICAgICAgKTtcbiAgICB9O1xuICB9XG5cbiAgZHJhZy5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IGZpbHRlcjtcbiAgfTtcblxuICBkcmFnLmNvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250YWluZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IGNvbnRhaW5lcjtcbiAgfTtcblxuICBkcmFnLnN1YmplY3QgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ViamVjdCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogc3ViamVjdDtcbiAgfTtcblxuICBkcmFnLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGRyYWcub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gZHJhZyA6IHZhbHVlO1xuICB9O1xuXG4gIGRyYWcuY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgZHJhZykgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiBkcmFnO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHJhZ0V2ZW50KHR5cGUsIHtcbiAgc291cmNlRXZlbnQsXG4gIHN1YmplY3QsXG4gIHRhcmdldCxcbiAgaWRlbnRpZmllcixcbiAgYWN0aXZlLFxuICB4LCB5LCBkeCwgZHksXG4gIGRpc3BhdGNoXG59KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICB0eXBlOiB7dmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgc291cmNlRXZlbnQ6IHt2YWx1ZTogc291cmNlRXZlbnQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgc3ViamVjdDoge3ZhbHVlOiBzdWJqZWN0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRhcmdldDoge3ZhbHVlOiB0YXJnZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgaWRlbnRpZmllcjoge3ZhbHVlOiBpZGVudGlmaWVyLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIGFjdGl2ZToge3ZhbHVlOiBhY3RpdmUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgeDoge3ZhbHVlOiB4LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHk6IHt2YWx1ZTogeSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBkeDoge3ZhbHVlOiBkeCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBkeToge3ZhbHVlOiBkeSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBfOiB7dmFsdWU6IGRpc3BhdGNofVxuICB9KTtcbn1cblxuRHJhZ0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcbn07XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgZHJhZ30gZnJvbSBcIi4vZHJhZy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWdEaXNhYmxlLCB5ZXNkcmFnIGFzIGRyYWdFbmFibGV9IGZyb20gXCIuL25vZHJhZy5qc1wiO1xuIiwiaW1wb3J0IHtzZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2V2ZW50LCB7bm9ucGFzc2l2ZWNhcHR1cmV9IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgaWYgKG5vY2xpY2spIHtcbiAgICBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcbiAgfVxuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gcm9vdC5fX25vc2VsZWN0O1xuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XG4gIH1cbn1cbiIsIi8vIFRoZXNlIGFyZSB0eXBpY2FsbHkgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG5vZXZlbnQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuXG4vLyBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZSA9IHtwYXNzaXZlOiBmYWxzZX07XG5leHBvcnQgY29uc3Qgbm9ucGFzc2l2ZWNhcHR1cmUgPSB7Y2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogZmFsc2V9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJ2YXIgb3ZlcnNob290ID0gMS43MDE1ODtcblxuZXhwb3J0IHZhciBiYWNrSW4gPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgcmV0dXJuICh0ID0gK3QpICogdCAqIChzICogKHQgLSAxKSArIHQpO1xuICB9XG5cbiAgYmFja0luLm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja0luO1xufSkob3ZlcnNob290KTtcblxuZXhwb3J0IHZhciBiYWNrT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrT3V0KHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqICgodCArIDEpICogcyArIHQpICsgMTtcbiAgfVxuXG4gIGJhY2tPdXQub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrT3V0O1xufSkob3ZlcnNob290KTtcblxuZXhwb3J0IHZhciBiYWNrSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8IDEgPyB0ICogdCAqICgocyArIDEpICogdCAtIHMpIDogKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKSAvIDI7XG4gIH1cblxuICBiYWNrSW5PdXQub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW5PdXQ7XG59KShvdmVyc2hvb3QpO1xuIiwidmFyIGIxID0gNCAvIDExLFxuICAgIGIyID0gNiAvIDExLFxuICAgIGIzID0gOCAvIDExLFxuICAgIGI0ID0gMyAvIDQsXG4gICAgYjUgPSA5IC8gMTEsXG4gICAgYjYgPSAxMCAvIDExLFxuICAgIGI3ID0gMTUgLyAxNixcbiAgICBiOCA9IDIxIC8gMjIsXG4gICAgYjkgPSA2MyAvIDY0LFxuICAgIGIwID0gMSAvIGIxIC8gYjE7XG5cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gIHJldHVybiAxIC0gYm91bmNlT3V0KDEgLSB0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZU91dCh0KSB7XG4gIHJldHVybiAodCA9ICt0KSA8IGIxID8gYjAgKiB0ICogdCA6IHQgPCBiMyA/IGIwICogKHQgLT0gYjIpICogdCArIGI0IDogdCA8IGI2ID8gYjAgKiAodCAtPSBiNSkgKiB0ICsgYjcgOiBiMCAqICh0IC09IGI4KSAqIHQgKyBiOTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIGJvdW5jZU91dCgxIC0gdCkgOiBib3VuY2VPdXQodCAtIDEpICsgMSkgLyAyO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZUluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZU91dCh0KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCkgOiBNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSAvIDI7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbn1cbiIsImltcG9ydCB7dHBtdH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG52YXIgdGF1ID0gMiAqIE1hdGguUEksXG4gICAgYW1wbGl0dWRlID0gMSxcbiAgICBwZXJpb2QgPSAwLjM7XG5cbmV4cG9ydCB2YXIgZWxhc3RpY0luID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XG4gICAgcmV0dXJuIGEgKiB0cG10KC0oLS10KSkgKiBNYXRoLnNpbigocyAtIHQpIC8gcCk7XG4gIH1cblxuICBlbGFzdGljSW4uYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljSW4ucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljSW47XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbmV4cG9ydCB2YXIgZWxhc3RpY091dCA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljT3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIGEgKiB0cG10KHQgPSArdCkgKiBNYXRoLnNpbigodCArIHMpIC8gcCk7XG4gIH1cblxuICBlbGFzdGljT3V0LmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY091dC5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNPdXQ7XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbmV4cG9ydCB2YXIgZWxhc3RpY0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCA9IHQgKiAyIC0gMSkgPCAwXG4gICAgICAgID8gYSAqIHRwbXQoLXQpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApXG4gICAgICAgIDogMiAtIGEgKiB0cG10KHQpICogTWF0aC5zaW4oKHMgKyB0KSAvIHApKSAvIDI7XG4gIH1cblxuICBlbGFzdGljSW5PdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljSW5PdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljSW5PdXQ7XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG4iLCJpbXBvcnQge3RwbXR9IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cEluKHQpIHtcbiAgcmV0dXJuIHRwbXQoMSAtICt0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cE91dCh0KSB7XG4gIHJldHVybiAxIC0gdHBtdCh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cEluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdHBtdCgxIC0gdCkgOiAyIC0gdHBtdCh0IC0gMSkpIC8gMjtcbn1cbiIsImV4cG9ydCB7XG4gIGxpbmVhciBhcyBlYXNlTGluZWFyXG59IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuXG5leHBvcnQge1xuICBxdWFkSW5PdXQgYXMgZWFzZVF1YWQsXG4gIHF1YWRJbiBhcyBlYXNlUXVhZEluLFxuICBxdWFkT3V0IGFzIGVhc2VRdWFkT3V0LFxuICBxdWFkSW5PdXQgYXMgZWFzZVF1YWRJbk91dFxufSBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGN1YmljSW5PdXQgYXMgZWFzZUN1YmljLFxuICBjdWJpY0luIGFzIGVhc2VDdWJpY0luLFxuICBjdWJpY091dCBhcyBlYXNlQ3ViaWNPdXQsXG4gIGN1YmljSW5PdXQgYXMgZWFzZUN1YmljSW5PdXRcbn0gZnJvbSBcIi4vY3ViaWMuanNcIjtcblxuZXhwb3J0IHtcbiAgcG9seUluT3V0IGFzIGVhc2VQb2x5LFxuICBwb2x5SW4gYXMgZWFzZVBvbHlJbixcbiAgcG9seU91dCBhcyBlYXNlUG9seU91dCxcbiAgcG9seUluT3V0IGFzIGVhc2VQb2x5SW5PdXRcbn0gZnJvbSBcIi4vcG9seS5qc1wiO1xuXG5leHBvcnQge1xuICBzaW5Jbk91dCBhcyBlYXNlU2luLFxuICBzaW5JbiBhcyBlYXNlU2luSW4sXG4gIHNpbk91dCBhcyBlYXNlU2luT3V0LFxuICBzaW5Jbk91dCBhcyBlYXNlU2luSW5PdXRcbn0gZnJvbSBcIi4vc2luLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGV4cEluT3V0IGFzIGVhc2VFeHAsXG4gIGV4cEluIGFzIGVhc2VFeHBJbixcbiAgZXhwT3V0IGFzIGVhc2VFeHBPdXQsXG4gIGV4cEluT3V0IGFzIGVhc2VFeHBJbk91dFxufSBmcm9tIFwiLi9leHAuanNcIjtcblxuZXhwb3J0IHtcbiAgY2lyY2xlSW5PdXQgYXMgZWFzZUNpcmNsZSxcbiAgY2lyY2xlSW4gYXMgZWFzZUNpcmNsZUluLFxuICBjaXJjbGVPdXQgYXMgZWFzZUNpcmNsZU91dCxcbiAgY2lyY2xlSW5PdXQgYXMgZWFzZUNpcmNsZUluT3V0XG59IGZyb20gXCIuL2NpcmNsZS5qc1wiO1xuXG5leHBvcnQge1xuICBib3VuY2VPdXQgYXMgZWFzZUJvdW5jZSxcbiAgYm91bmNlSW4gYXMgZWFzZUJvdW5jZUluLFxuICBib3VuY2VPdXQgYXMgZWFzZUJvdW5jZU91dCxcbiAgYm91bmNlSW5PdXQgYXMgZWFzZUJvdW5jZUluT3V0XG59IGZyb20gXCIuL2JvdW5jZS5qc1wiO1xuXG5leHBvcnQge1xuICBiYWNrSW5PdXQgYXMgZWFzZUJhY2ssXG4gIGJhY2tJbiBhcyBlYXNlQmFja0luLFxuICBiYWNrT3V0IGFzIGVhc2VCYWNrT3V0LFxuICBiYWNrSW5PdXQgYXMgZWFzZUJhY2tJbk91dFxufSBmcm9tIFwiLi9iYWNrLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGVsYXN0aWNPdXQgYXMgZWFzZUVsYXN0aWMsXG4gIGVsYXN0aWNJbiBhcyBlYXNlRWxhc3RpY0luLFxuICBlbGFzdGljT3V0IGFzIGVhc2VFbGFzdGljT3V0LFxuICBlbGFzdGljSW5PdXQgYXMgZWFzZUVsYXN0aWNJbk91dFxufSBmcm9tIFwiLi9lbGFzdGljLmpzXCI7XG4iLCJleHBvcnQgY29uc3QgbGluZWFyID0gdCA9PiArdDtcbiIsIi8vIHRwbXQgaXMgdHdvIHBvd2VyIG1pbnVzIHRlbiB0aW1lcyB0IHNjYWxlZCB0byBbMCwxXVxuZXhwb3J0IGZ1bmN0aW9uIHRwbXQoeCkge1xuICByZXR1cm4gKE1hdGgucG93KDIsIC0xMCAqIHgpIC0gMC4wMDA5NzY1NjI1KSAqIDEuMDAwOTc3NTE3MTA2NTQ5NDtcbn1cbiIsInZhciBleHBvbmVudCA9IDM7XG5cbmV4cG9ydCB2YXIgcG9seUluID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5SW4odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0LCBlKTtcbiAgfVxuXG4gIHBvbHlJbi5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seUluO1xufSkoZXhwb25lbnQpO1xuXG5leHBvcnQgdmFyIHBvbHlPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlPdXQodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIGUpO1xuICB9XG5cbiAgcG9seU91dC5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seU91dDtcbn0pKGV4cG9uZW50KTtcblxuZXhwb3J0IHZhciBwb2x5SW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3codCwgZSkgOiAyIC0gTWF0aC5wb3coMiAtIHQsIGUpKSAvIDI7XG4gIH1cblxuICBwb2x5SW5PdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbk91dDtcbn0pKGV4cG9uZW50KTtcbiIsImV4cG9ydCBmdW5jdGlvbiBxdWFkSW4odCkge1xuICByZXR1cm4gdCAqIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFkT3V0KHQpIHtcbiAgcmV0dXJuIHQgKiAoMiAtIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgOiAtLXQgKiAoMiAtIHQpICsgMSkgLyAyO1xufVxuIiwidmFyIHBpID0gTWF0aC5QSSxcbiAgICBoYWxmUGkgPSBwaSAvIDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5Jbih0KSB7XG4gIHJldHVybiAoK3QgPT09IDEpID8gMSA6IDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbk91dCh0KSB7XG4gIHJldHVybiBNYXRoLnNpbih0ICogaGFsZlBpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbkluT3V0KHQpIHtcbiAgcmV0dXJuICgxIC0gTWF0aC5jb3MocGkgKiB0KSkgLyAyO1xufVxuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiAoaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5IDogZ2VuZXJpY0FycmF5KShhLCBiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyaWNBcnJheShhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gdmFsdWUoYVtpXSwgYltpXSk7XG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtiYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJpbXBvcnQge2N1YmVoZWxpeCBhcyBjb2xvckN1YmVoZWxpeH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeChodWUpIHtcbiAgcmV0dXJuIChmdW5jdGlvbiBjdWJlaGVsaXhHYW1tYSh5KSB7XG4gICAgeSA9ICt5O1xuXG4gICAgZnVuY3Rpb24gY3ViZWhlbGl4KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBoID0gaHVlKChzdGFydCA9IGNvbG9yQ3ViZWhlbGl4KHN0YXJ0KSkuaCwgKGVuZCA9IGNvbG9yQ3ViZWhlbGl4KGVuZCkpLmgpLFxuICAgICAgICAgIHMgPSBjb2xvcihzdGFydC5zLCBlbmQucyksXG4gICAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICAgIHN0YXJ0LnMgPSBzKHQpO1xuICAgICAgICBzdGFydC5sID0gbChNYXRoLnBvdyh0LCB5KSk7XG4gICAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjdWJlaGVsaXguZ2FtbWEgPSBjdWJlaGVsaXhHYW1tYTtcblxuICAgIHJldHVybiBjdWJlaGVsaXg7XG4gIH0pKDEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjdWJlaGVsaXgoaHVlKTtcbmV4cG9ydCB2YXIgY3ViZWhlbGl4TG9uZyA9IGN1YmVoZWxpeChjb2xvcik7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBkID0gbmV3IERhdGU7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkLnNldFRpbWUoYSAqICgxIC0gdCkgKyBiICogdCksIGQ7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYW5nZSkge1xuICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gcmFuZ2VbTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqIG4pKSldO1xuICB9O1xufVxuIiwiaW1wb3J0IHtoY2wgYXMgY29sb3JIY2x9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBoY2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JIY2woc3RhcnQpKS5oLCAoZW5kID0gY29sb3JIY2woZW5kKSkuaCksXG4gICAgICAgIGMgPSBjb2xvcihzdGFydC5jLCBlbmQuYyksXG4gICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQuYyA9IGModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhjbChodWUpO1xuZXhwb3J0IHZhciBoY2xMb25nID0gaGNsKGNvbG9yKTtcbiIsImltcG9ydCB7aHNsIGFzIGNvbG9ySHNsfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gaHNsKGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IGNvbG9ySHNsKHN0YXJ0KSkuaCwgKGVuZCA9IGNvbG9ySHNsKGVuZCkpLmgpLFxuICAgICAgICBzID0gY29sb3Ioc3RhcnQucywgZW5kLnMpLFxuICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LnMgPSBzKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBoc2woaHVlKTtcbmV4cG9ydCB2YXIgaHNsTG9uZyA9IGhzbChjb2xvcik7XG4iLCJpbXBvcnQge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgaSA9IGh1ZSgrYSwgK2IpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciB4ID0gaSh0KTtcbiAgICByZXR1cm4geCAtIDM2MCAqIE1hdGguZmxvb3IoeCAvIDM2MCk7XG4gIH07XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGV9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVBcnJheX0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUJhc2lzfSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQmFzaXNDbG9zZWR9IGZyb20gXCIuL2Jhc2lzQ2xvc2VkLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVEYXRlfSBmcm9tIFwiLi9kYXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVEaXNjcmV0ZX0gZnJvbSBcIi4vZGlzY3JldGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUh1ZX0gZnJvbSBcIi4vaHVlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVOdW1iZXJ9IGZyb20gXCIuL251bWJlci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVPYmplY3R9IGZyb20gXCIuL29iamVjdC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlUm91bmR9IGZyb20gXCIuL3JvdW5kLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVTdHJpbmd9IGZyb20gXCIuL3N0cmluZy5qc1wiO1xuZXhwb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcywgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Tdmd9IGZyb20gXCIuL3RyYW5zZm9ybS9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlWm9vbX0gZnJvbSBcIi4vem9vbS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlUmdiLCByZ2JCYXNpcyBhcyBpbnRlcnBvbGF0ZVJnYkJhc2lzLCByZ2JCYXNpc0Nsb3NlZCBhcyBpbnRlcnBvbGF0ZVJnYkJhc2lzQ2xvc2VkfSBmcm9tIFwiLi9yZ2IuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUhzbCwgaHNsTG9uZyBhcyBpbnRlcnBvbGF0ZUhzbExvbmd9IGZyb20gXCIuL2hzbC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlTGFifSBmcm9tIFwiLi9sYWIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUhjbCwgaGNsTG9uZyBhcyBpbnRlcnBvbGF0ZUhjbExvbmd9IGZyb20gXCIuL2hjbC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQ3ViZWhlbGl4LCBjdWJlaGVsaXhMb25nIGFzIGludGVycG9sYXRlQ3ViZWhlbGl4TG9uZ30gZnJvbSBcIi4vY3ViZWhlbGl4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGllY2V3aXNlfSBmcm9tIFwiLi9waWVjZXdpc2UuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBxdWFudGl6ZX0gZnJvbSBcIi4vcXVhbnRpemUuanNcIjtcbiIsImltcG9ydCB7bGFiIGFzIGNvbG9yTGFifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIoc3RhcnQsIGVuZCkge1xuICB2YXIgbCA9IGNvbG9yKChzdGFydCA9IGNvbG9yTGFiKHN0YXJ0KSkubCwgKGVuZCA9IGNvbG9yTGFiKGVuZCkpLmwpLFxuICAgICAgYSA9IGNvbG9yKHN0YXJ0LmEsIGVuZC5hKSxcbiAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgIHN0YXJ0LmEgPSBhKHQpO1xuICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICBpZiAoIWIpIGIgPSBbXTtcbiAgdmFyIG4gPSBhID8gTWF0aC5taW4oYi5sZW5ndGgsIGEubGVuZ3RoKSA6IDAsXG4gICAgICBjID0gYi5zbGljZSgpLFxuICAgICAgaTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjW2ldID0gYVtpXSAqICgxIC0gdCkgKyBiW2ldICogdDtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoeCkge1xuICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmICEoeCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cbiIsImltcG9ydCB2YWx1ZSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0ge30sXG4gICAgICBjID0ge30sXG4gICAgICBrO1xuXG4gIGlmIChhID09PSBudWxsIHx8IHR5cGVvZiBhICE9PSBcIm9iamVjdFwiKSBhID0ge307XG4gIGlmIChiID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKSBiID0ge307XG5cbiAgZm9yIChrIGluIGIpIHtcbiAgICBpZiAoayBpbiBhKSB7XG4gICAgICBpW2tdID0gdmFsdWUoYVtrXSwgYltrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNba10gPSBiW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuIiwiaW1wb3J0IHtkZWZhdWx0IGFzIHZhbHVlfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHZhbHVlcyA9IGludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSA9IHZhbHVlO1xuICB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMSwgdiA9IHZhbHVlc1swXSwgSSA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBJW2ldID0gaW50ZXJwb2xhdGUodiwgdiA9IHZhbHVlc1srK2ldKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKj0gbikpKTtcbiAgICByZXR1cm4gSVtpXSh0IC0gaSk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcnBvbGF0b3IsIG4pIHtcbiAgdmFyIHNhbXBsZXMgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKGkgLyAobiAtIDEpKTtcbiAgcmV0dXJuIHNhbXBsZXM7XG59XG4iLCJpbXBvcnQge3JnYiBhcyBjb2xvclJnYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgYmFzaXMgZnJvbSBcIi4vYmFzaXMuanNcIjtcbmltcG9ydCBiYXNpc0Nsb3NlZCBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuaW1wb3J0IG5vZ2FtbWEsIHtnYW1tYX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcbiAgdmFyIGNvbG9yID0gZ2FtbWEoeSk7XG5cbiAgZnVuY3Rpb24gcmdiKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGNvbG9yKChzdGFydCA9IGNvbG9yUmdiKHN0YXJ0KSkuciwgKGVuZCA9IGNvbG9yUmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3Ioc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYjtcbn0pKDEpO1xuXG5mdW5jdGlvbiByZ2JTcGxpbmUoc3BsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICB2YXIgbiA9IGNvbG9ycy5sZW5ndGgsXG4gICAgICAgIHIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGksIGNvbG9yO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbG9yID0gY29sb3JSZ2IoY29sb3JzW2ldKTtcbiAgICAgIHJbaV0gPSBjb2xvci5yIHx8IDA7XG4gICAgICBnW2ldID0gY29sb3IuZyB8fCAwO1xuICAgICAgYltpXSA9IGNvbG9yLmIgfHwgMDtcbiAgICB9XG4gICAgciA9IHNwbGluZShyKTtcbiAgICBnID0gc3BsaW5lKGcpO1xuICAgIGIgPSBzcGxpbmUoYik7XG4gICAgY29sb3Iub3BhY2l0eSA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbG9yLnIgPSByKHQpO1xuICAgICAgY29sb3IuZyA9IGcodCk7XG4gICAgICBjb2xvci5iID0gYih0KTtcbiAgICAgIHJldHVybiBjb2xvciArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyk7XG5leHBvcnQgdmFyIHJnYkJhc2lzQ2xvc2VkID0gcmdiU3BsaW5lKGJhc2lzQ2xvc2VkKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqICgxIC0gdCkgKyBiICogdCk7XG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLFxuICAgIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYmkgPSByZUEubGFzdEluZGV4ID0gcmVCLmxhc3RJbmRleCA9IDAsIC8vIHNjYW4gaW5kZXggZm9yIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcbiAgICAgIGJtLCAvLyBjdXJyZW50IG1hdGNoIGluIGJcbiAgICAgIGJzLCAvLyBzdHJpbmcgcHJlY2VkaW5nIGN1cnJlbnQgbnVtYmVyIGluIGIsIGlmIGFueVxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXG4gICAgICBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuXG4gIC8vIENvZXJjZSBpbnB1dHMgdG8gc3RyaW5ncy5cbiAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG5cbiAgLy8gSW50ZXJwb2xhdGUgcGFpcnMgb2YgbnVtYmVycyBpbiBhICYgYi5cbiAgd2hpbGUgKChhbSA9IHJlQS5leGVjKGEpKVxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7IC8vIGEgc3RyaW5nIHByZWNlZGVzIHRoZSBuZXh0IG51bWJlciBpbiBiXG4gICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBibTtcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgIHEucHVzaCh7aTogaSwgeDogbnVtYmVyKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufVxuIiwidmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgc2NhbGVYLCBzY2FsZVksIHNrZXdYO1xuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XG4gIGlmIChza2V3WCA9IGEgKiBjICsgYiAqIGQpIGMgLT0gYSAqIHNrZXdYLCBkIC09IGIgKiBza2V3WDtcbiAgaWYgKHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSkgYyAvPSBzY2FsZVksIGQgLz0gc2NhbGVZLCBza2V3WCAvPSBzY2FsZVk7XG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRlWDogZSxcbiAgICB0cmFuc2xhdGVZOiBmLFxuICAgIHJvdGF0ZTogTWF0aC5hdGFuMihiLCBhKSAqIGRlZ3JlZXMsXG4gICAgc2tld1g6IE1hdGguYXRhbihza2V3WCkgKiBkZWdyZWVzLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXIuanNcIjtcbmltcG9ydCB7cGFyc2VDc3MsIHBhcnNlU3ZnfSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZUNzcywgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuIiwiaW1wb3J0IGRlY29tcG9zZSwge2lkZW50aXR5fSBmcm9tIFwiLi9kZWNvbXBvc2UuanNcIjtcblxudmFyIHN2Z05vZGU7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDc3ModmFsdWUpIHtcbiAgY29uc3QgbSA9IG5ldyAodHlwZW9mIERPTU1hdHJpeCA9PT0gXCJmdW5jdGlvblwiID8gRE9NTWF0cml4IDogV2ViS2l0Q1NTTWF0cml4KSh2YWx1ZSArIFwiXCIpO1xuICByZXR1cm4gbS5pc0lkZW50aXR5ID8gaWRlbnRpdHkgOiBkZWNvbXBvc2UobS5hLCBtLmIsIG0uYywgbS5kLCBtLmUsIG0uZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gZGVjb21wb3NlKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgcmdiIGZyb20gXCIuL3JnYi5qc1wiO1xuaW1wb3J0IHtnZW5lcmljQXJyYXl9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgZGF0ZSBmcm9tIFwiLi9kYXRlLmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuaW1wb3J0IG9iamVjdCBmcm9tIFwiLi9vYmplY3QuanNcIjtcbmltcG9ydCBzdHJpbmcgZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIHQgPSB0eXBlb2YgYiwgYztcbiAgcmV0dXJuIGIgPT0gbnVsbCB8fCB0ID09PSBcImJvb2xlYW5cIiA/IGNvbnN0YW50KGIpXG4gICAgICA6ICh0ID09PSBcIm51bWJlclwiID8gbnVtYmVyXG4gICAgICA6IHQgPT09IFwic3RyaW5nXCIgPyAoKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIHJnYikgOiBzdHJpbmcpXG4gICAgICA6IGIgaW5zdGFuY2VvZiBjb2xvciA/IHJnYlxuICAgICAgOiBiIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVcbiAgICAgIDogaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5XG4gICAgICA6IEFycmF5LmlzQXJyYXkoYikgPyBnZW5lcmljQXJyYXlcbiAgICAgIDogdHlwZW9mIGIudmFsdWVPZiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiLnRvU3RyaW5nICE9PSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4oYikgPyBvYmplY3RcbiAgICAgIDogbnVtYmVyKShhLCBiKTtcbn1cbiIsInZhciBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gem9vbVJobyhyaG8sIHJobzIsIHJobzQpIHtcblxuICAvLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4gIC8vIHAxID0gW3V4MSwgdXkxLCB3MV1cbiAgZnVuY3Rpb24gem9vbShwMCwgcDEpIHtcbiAgICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLFxuICAgICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgICBkeSA9IHV5MSAtIHV5MCxcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgICAgaSxcbiAgICAgICAgUztcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICAgIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHQgKiBkeCxcbiAgICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpLmR1cmF0aW9uID0gUyAqIDEwMDAgKiByaG8gLyBNYXRoLlNRUlQyO1xuXG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICB6b29tLnJobyA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgXzEgPSBNYXRoLm1heCgxZS0zLCArXyksIF8yID0gXzEgKiBfMSwgXzQgPSBfMiAqIF8yO1xuICAgIHJldHVybiB6b29tUmhvKF8xLCBfMiwgXzQpO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufSkoTWF0aC5TUVJUMiwgMiwgNCk7XG4iLCIvLyBHaXZlbiBzb21ldGhpbmcgYXJyYXkgbGlrZSAob3IgbnVsbCksIHJldHVybnMgc29tZXRoaW5nIHRoYXQgaXMgc3RyaWN0bHkgYW5cbi8vIGFycmF5LiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYXJyYXktbGlrZSBvYmplY3RzIHBhc3NlZCB0byBkMy5zZWxlY3RBbGxcbi8vIG9yIHNlbGVjdGlvbi5zZWxlY3RBbGwgYXJlIGNvbnZlcnRlZCBpbnRvIHByb3BlciBhcnJheXMgd2hlbiBjcmVhdGluZyBhXG4vLyBzZWxlY3Rpb247IHdlIGRvbuKAmXQgZXZlciB3YW50IHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBiYWNrZWQgYnkgYSBsaXZlXG4vLyBIVE1MQ29sbGVjdGlvbiBvciBOb2RlTGlzdC4gSG93ZXZlciwgbm90ZSB0aGF0IHNlbGVjdGlvbi5zZWxlY3RBbGwgd2lsbCB1c2UgYVxuLy8gc3RhdGljIE5vZGVMaXN0IGFzIGEgZ3JvdXAsIHNpbmNlIGl0IHNhZmVseSBkZXJpdmVkIGZyb20gcXVlcnlTZWxlY3RvckFsbC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFycmF5KHgpIHtcbiAgcmV0dXJuIHggPT0gbnVsbCA/IFtdIDogQXJyYXkuaXNBcnJheSh4KSA/IHggOiBBcnJheS5mcm9tKHgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi9jcmVhdG9yLmpzXCI7XG5pbXBvcnQgc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3QoY3JlYXRvcihuYW1lKS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2UuanNcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdGV9IGZyb20gXCIuL2NyZWF0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0b3J9IGZyb20gXCIuL2NyZWF0b3IuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsb2NhbH0gZnJvbSBcIi4vbG9jYWwuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtYXRjaGVyfSBmcm9tIFwiLi9tYXRjaGVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmFtZXNwYWNlfSBmcm9tIFwiLi9uYW1lc3BhY2UuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2VzfSBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcG9pbnRlcn0gZnJvbSBcIi4vcG9pbnRlci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBvaW50ZXJzfSBmcm9tIFwiLi9wb2ludGVycy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdH0gZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0QWxsfSBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3Rpb259IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdG9yfSBmcm9tIFwiLi9zZWxlY3Rvci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdG9yQWxsfSBmcm9tIFwiLi9zZWxlY3RvckFsbC5qc1wiO1xuZXhwb3J0IHtzdHlsZVZhbHVlIGFzIHN0eWxlfSBmcm9tIFwiLi9zZWxlY3Rpb24vc3R5bGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB3aW5kb3d9IGZyb20gXCIuL3dpbmRvdy5qc1wiO1xuIiwidmFyIG5leHRJZCA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvY2FsKCkge1xuICByZXR1cm4gbmV3IExvY2FsO1xufVxuXG5mdW5jdGlvbiBMb2NhbCgpIHtcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcbn1cblxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTG9jYWwsXG4gIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICB3aGlsZSAoIShpZCBpbiBub2RlKSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gbm9kZVtpZF07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLl8gaW4gbm9kZSAmJiBkZWxldGUgbm9kZVt0aGlzLl9dO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkTWF0Y2hlcihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG4iLCJpbXBvcnQgbmFtZXNwYWNlcyBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG59XG4iLCJleHBvcnQgdmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQsIG5vZGUpIHtcbiAgZXZlbnQgPSBzb3VyY2VFdmVudChldmVudCk7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAobm9kZSkge1xuICAgIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtldmVudC5wYWdlWCwgZXZlbnQucGFnZVldO1xufVxuIiwiaW1wb3J0IHBvaW50ZXIgZnJvbSBcIi4vcG9pbnRlci5qc1wiO1xuaW1wb3J0IHNvdXJjZUV2ZW50IGZyb20gXCIuL3NvdXJjZUV2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50cywgbm9kZSkge1xuICBpZiAoZXZlbnRzLnRhcmdldCkgeyAvLyBpLmUuLCBpbnN0YW5jZW9mIEV2ZW50LCBub3QgVG91Y2hMaXN0IG9yIGl0ZXJhYmxlXG4gICAgZXZlbnRzID0gc291cmNlRXZlbnQoZXZlbnRzKTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSBub2RlID0gZXZlbnRzLmN1cnJlbnRUYXJnZXQ7XG4gICAgZXZlbnRzID0gZXZlbnRzLnRvdWNoZXMgfHwgW2V2ZW50c107XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRzLCBldmVudCA9PiBwb2ludGVyKGV2ZW50LCBub2RlKSk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFthcnJheShzZWxlY3RvcildLCByb290KTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuLi9uYW1lc3BhY2UuanNcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGUoZnVsbG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuIiwiZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUoZmFsc2UpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVEZWVwKCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZSh0cnVlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVlcCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZGVlcCA/IHNlbGVjdGlvbl9jbG9uZURlZXAgOiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHtFbnRlck5vZGV9IGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4uL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGJpbmRJbmRleChwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG5vZGUsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAvLyBQdXQgYW55IG51bGwgbm9kZXMgaW50byBlbnRlci5cbiAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cbiAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gIHZhciBpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVCeUtleVZhbHVlID0gbmV3IE1hcCxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkgKyBcIlwiO1xuICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmhhcyhrZXlWYWx1ZSkpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpICsgXCJcIjtcbiAgICBpZiAobm9kZSA9IG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZSkpIHtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIG5vZGVCeUtleVZhbHVlLmRlbGV0ZShrZXlWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBhbnkgcmVtYWluaW5nIG5vZGVzIHRoYXQgd2VyZSBub3QgYm91bmQgdG8gZGF0YSB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlc1tpXSkgPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0dW0obm9kZSkge1xuICByZXR1cm4gbm9kZS5fX2RhdGFfXztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBBcnJheS5mcm9tKHRoaXMsIGRhdHVtKTtcblxuICB2YXIgYmluZCA9IGtleSA/IGJpbmRLZXkgOiBiaW5kSW5kZXgsXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gY29uc3RhbnQodmFsdWUpO1xuXG4gIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICBncm91cCA9IGdyb3Vwc1tqXSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGEgPSBhcnJheWxpa2UodmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbi8vIEdpdmVuIHNvbWUgZGF0YSwgdGhpcyByZXR1cm5zIGFuIGFycmF5LWxpa2UgdmlldyBvZiBpdDogYW4gb2JqZWN0IHRoYXRcbi8vIGV4cG9zZXMgYSBsZW5ndGggcHJvcGVydHkgYW5kIGFsbG93cyBudW1lcmljIGluZGV4aW5nLiBOb3RlIHRoYXQgdW5saWtlXG4vLyBzZWxlY3RBbGwsIHRoaXMgaXNu4oCZdCB3b3JyaWVkIGFib3V0IOKAnGxpdmXigJ0gY29sbGVjdGlvbnMgYmVjYXVzZSB0aGUgcmVzdWx0aW5nXG4vLyBhcnJheSB3aWxsIG9ubHkgYmUgdXNlZCBicmllZmx5IHdoaWxlIGRhdGEgaXMgYmVpbmcgYm91bmQuIChJdCBpcyBwb3NzaWJsZSB0b1xuLy8gY2F1c2UgdGhlIGRhdGEgdG8gY2hhbmdlIHdoaWxlIGl0ZXJhdGluZyBieSB1c2luZyBhIGtleSBmdW5jdGlvbiwgYnV0IHBsZWFzZVxuLy8gZG9u4oCZdDsgd2XigJlkIHJhdGhlciBhdm9pZCBhIGdyYXR1aXRvdXMgY29weS4pXG5mdW5jdGlvbiBhcnJheWxpa2UoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiBkYXRhXG4gICAgPyBkYXRhIC8vIEFycmF5LCBUeXBlZEFycmF5LCBOb2RlTGlzdCwgYXJyYXktbGlrZVxuICAgIDogQXJyYXkuZnJvbShkYXRhKTsgLy8gTWFwLCBTZXQsIGl0ZXJhYmxlLCBzdHJpbmcsIG9yIGFueXRoaW5nIGVsc2Vcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSlcbiAgICAgIDogdGhpcy5ub2RlKCkuX19kYXRhX187XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KG5vZGUsIHR5cGUsIHBhcmFtcykge1xuICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXG4gICAgICBldmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gICAgZWxzZSBldmVudC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ29uc3RhbnQodHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGRpc3BhdGNoRnVuY3Rpb25cbiAgICAgIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjay5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMubm9kZSgpO1xufVxuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IHBhcmVudC5vd25lckRvY3VtZW50O1xuICB0aGlzLm5hbWVzcGFjZVVSSSA9IHBhcmVudC5uYW1lc3BhY2VVUkk7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19kYXRhX18gPSBkYXR1bTtcbn1cblxuRW50ZXJOb2RlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZCwgbmV4dCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7IH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbn07XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBtYXRjaGVyIGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICA6IGh0bWxDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59XG4iLCJpbXBvcnQgc2VsZWN0aW9uX3NlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RDaGlsZCBmcm9tIFwiLi9zZWxlY3RDaGlsZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RDaGlsZHJlbiBmcm9tIFwiLi9zZWxlY3RDaGlsZHJlbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9maWx0ZXIgZnJvbSBcIi4vZmlsdGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lbnRlciBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9leGl0IGZyb20gXCIuL2V4aXQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fam9pbiBmcm9tIFwiLi9qb2luLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX29yZGVyIGZyb20gXCIuL29yZGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NvcnQgZnJvbSBcIi4vc29ydC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jYWxsIGZyb20gXCIuL2NhbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbm9kZXMgZnJvbSBcIi4vbm9kZXMuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbm9kZSBmcm9tIFwiLi9ub2RlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NpemUgZnJvbSBcIi4vc2l6ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lbXB0eSBmcm9tIFwiLi9lbXB0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lYWNoIGZyb20gXCIuL2VhY2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3N0eWxlIGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3Byb3BlcnR5IGZyb20gXCIuL3Byb3BlcnR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NsYXNzZWQgZnJvbSBcIi4vY2xhc3NlZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faHRtbCBmcm9tIFwiLi9odG1sLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JhaXNlIGZyb20gXCIuL3JhaXNlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2xvd2VyIGZyb20gXCIuL2xvd2VyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2FwcGVuZCBmcm9tIFwiLi9hcHBlbmQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faW5zZXJ0IGZyb20gXCIuL2luc2VydC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2Nsb25lIGZyb20gXCIuL2Nsb25lLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2RhdHVtIGZyb20gXCIuL2RhdHVtLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2Rpc3BhdGNoIGZyb20gXCIuL2Rpc3BhdGNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2l0ZXJhdG9yIGZyb20gXCIuL2l0ZXJhdG9yLmpzXCI7XG5cbmV4cG9ydCB2YXIgcm9vdCA9IFtudWxsXTtcblxuZXhwb3J0IGZ1bmN0aW9uIFNlbGVjdGlvbihncm91cHMsIHBhcmVudHMpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCByb290KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9zZWxlY3RDaGlsZHJlbixcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHNlbGVjdGlvbl9zZWxlY3Rpb24sXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gIHNvcnQ6IHNlbGVjdGlvbl9zb3J0LFxuICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX25vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fZWFjaCxcbiAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gIHByb3BlcnR5OiBzZWxlY3Rpb25fcHJvcGVydHksXG4gIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgaHRtbDogc2VsZWN0aW9uX2h0bWwsXG4gIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gIGFwcGVuZDogc2VsZWN0aW9uX2FwcGVuZCxcbiAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gIGNsb25lOiBzZWxlY3Rpb25fY2xvbmUsXG4gIGRhdHVtOiBzZWxlY3Rpb25fZGF0dW0sXG4gIG9uOiBzZWxlY3Rpb25fb24sXG4gIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2gsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25faXRlcmF0b3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlbGVjdGlvbjtcbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yLmpzXCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpLFxuICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBzZWxlY3RvcihiZWZvcmUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiooKSB7XG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB5aWVsZCBub2RlO1xuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgaWYgKHR5cGVvZiBvbmVudGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlbnRlciA9IG9uZW50ZXIoZW50ZXIpO1xuICAgIGlmIChlbnRlcikgZW50ZXIgPSBlbnRlci5zZWxlY3Rpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBlbnRlciA9IGVudGVyLmFwcGVuZChvbmVudGVyICsgXCJcIik7XG4gIH1cbiAgaWYgKG9udXBkYXRlICE9IG51bGwpIHtcbiAgICB1cGRhdGUgPSBvbnVwZGF0ZSh1cGRhdGUpO1xuICAgIGlmICh1cGRhdGUpIHVwZGF0ZSA9IHVwZGF0ZS5zZWxlY3Rpb24oKTtcbiAgfVxuICBpZiAob25leGl0ID09IG51bGwpIGV4aXQucmVtb3ZlKCk7IGVsc2Ugb25leGl0KGV4aXQpO1xuICByZXR1cm4gZW50ZXIgJiYgdXBkYXRlID8gZW50ZXIubWVyZ2UodXBkYXRlKS5vcmRlcigpIDogdXBkYXRlO1xufVxuIiwiZnVuY3Rpb24gbG93ZXIoKSB7XG4gIGlmICh0aGlzLnByZXZpb3VzU2libGluZykgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKGxvd2VyKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBjb250ZXh0LnNlbGVjdGlvbiA/IGNvbnRleHQuc2VsZWN0aW9uKCkgOiBjb250ZXh0O1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xufVxuIiwiZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQsIHRoaXMuX19kYXRhX18pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uO1xuICAgIGlmICghb24pIHJldHVybjtcbiAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAobyA9IG9uW2pdLCAoIXR5cGVuYW1lLnR5cGUgfHwgby50eXBlID09PSB0eXBlbmFtZS50eXBlKSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uWysraV0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKytpKSBvbi5sZW5ndGggPSBpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BZGQodHlwZW5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb24sIG8sIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKHZhbHVlKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLm9wdGlvbnMgPSBvcHRpb25zKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgb3B0aW9uczogb3B0aW9uc307XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuIiwiZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgYXJyYXkgZnJvbSBcIi4uL2FycmF5LmpzXCI7XG5pbXBvcnQgc2VsZWN0b3JBbGwgZnJvbSBcIi4uL3NlbGVjdG9yQWxsLmpzXCI7XG5cbmZ1bmN0aW9uIGFycmF5QWxsKHNlbGVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFycmF5KHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ID09PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IGFycmF5QWxsKHNlbGVjdCk7XG4gIGVsc2Ugc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzdWJncm91cHMucHVzaChzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCBwYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmluZCA9IEFycmF5LnByb3RvdHlwZS5maW5kO1xuXG5mdW5jdGlvbiBjaGlsZEZpbmQobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaW5kLmNhbGwodGhpcy5jaGlsZHJlbiwgbWF0Y2gpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjaGlsZEZpcnN0KCkge1xuICByZXR1cm4gdGhpcy5maXJzdEVsZW1lbnRDaGlsZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KG1hdGNoID09IG51bGwgPyBjaGlsZEZpcnN0XG4gICAgICA6IGNoaWxkRmluZCh0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyO1xuXG5mdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuRmlsdGVyKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcy5jaGlsZHJlbiwgbWF0Y2gpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3RBbGwobWF0Y2ggPT0gbnVsbCA/IGNoaWxkcmVuXG4gICAgICA6IGNoaWxkcmVuRmlsdGVyKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcykgKytzaXplOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiBzaXplO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyZShhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzb3J0Z3JvdXAgPSBzb3J0Z3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzb3J0Z3JvdXBzLCB0aGlzLl9wYXJlbnRzKS5vcmRlcigpO1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih1cGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSh1cGRhdGUubGVuZ3RoKTtcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgIDogc3R5bGVDb25zdGFudCkobmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKVxuICAgICAgOiBzdHlsZVZhbHVlKHRoaXMubm9kZSgpLCBuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0eWxlVmFsdWUobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpXG4gICAgICB8fCBkZWZhdWx0Vmlldyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG59XG4iLCJmdW5jdGlvbiB0ZXh0UmVtb3ZlKCkge1xuICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHRleHRGdW5jdGlvblxuICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufVxuIiwiZnVuY3Rpb24gbm9uZSgpIHt9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gbm9uZSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9O1xufVxuIiwiZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBlbXB0eSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgbGV0IHNvdXJjZUV2ZW50O1xuICB3aGlsZSAoc291cmNlRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudCkgZXZlbnQgPSBzb3VyY2VFdmVudDtcbiAgcmV0dXJuIGV2ZW50O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIC8vIG5vZGUgaXMgYSBOb2RlXG4gICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICB8fCBub2RlLmRlZmF1bHRWaWV3OyAvLyBub2RlIGlzIGEgRG9jdW1lbnRcbn1cbiIsImV4cG9ydCB7XG4gIG5vdyxcbiAgdGltZXIsXG4gIHRpbWVyRmx1c2hcbn0gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aW1lb3V0XG59IGZyb20gXCIuL3RpbWVvdXQuanNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBpbnRlcnZhbFxufSBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuIiwiaW1wb3J0IHtUaW1lciwgbm93fSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXIsIHRvdGFsID0gZGVsYXk7XG4gIGlmIChkZWxheSA9PSBudWxsKSByZXR1cm4gdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSksIHQ7XG4gIHQuX3Jlc3RhcnQgPSB0LnJlc3RhcnQ7XG4gIHQucmVzdGFydCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGRlbGF5ID0gK2RlbGF5LCB0aW1lID0gdGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZTtcbiAgICB0Ll9yZXN0YXJ0KGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgICAgZWxhcHNlZCArPSB0b3RhbDtcbiAgICAgIHQuX3Jlc3RhcnQodGljaywgdG90YWwgKz0gZGVsYXksIHRpbWUpO1xuICAgICAgY2FsbGJhY2soZWxhcHNlZCk7XG4gICAgfSwgZGVsYXksIHRpbWUpO1xuICB9XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsImltcG9ydCB7VGltZXJ9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgZGVsYXkgPSBkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheTtcbiAgdC5yZXN0YXJ0KGVsYXBzZWQgPT4ge1xuICAgIHQuc3RvcCgpO1xuICAgIGNhbGxiYWNrKGVsYXBzZWQgKyBkZWxheSk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iLCJ2YXIgZnJhbWUgPSAwLCAvLyBpcyBhbiBhbmltYXRpb24gZnJhbWUgcGVuZGluZz9cbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XG4gICAgaW50ZXJ2YWwgPSAwLCAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG4gICAgcG9rZURlbGF5ID0gMTAwMCwgLy8gaG93IGZyZXF1ZW50bHkgd2UgY2hlY2sgZm9yIGNsb2NrIHNrZXdcbiAgICB0YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGNsb2NrTm93IHx8IChzZXRGcmFtZShjbGVhck5vdyksIGNsb2NrTm93ID0gY2xvY2subm93KCkgKyBjbG9ja1NrZXcpO1xufVxuXG5mdW5jdGlvbiBjbGVhck5vdygpIHtcbiAgY2xvY2tOb3cgPSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVGltZXIoKSB7XG4gIHRoaXMuX2NhbGwgPVxuICB0aGlzLl90aW1lID1cbiAgdGhpcy5fbmV4dCA9IG51bGw7XG59XG5cblRpbWVyLnByb3RvdHlwZSA9IHRpbWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRpbWVyLFxuICByZXN0YXJ0OiBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB0aW1lID0gKHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWUpICsgKGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5KTtcbiAgICBpZiAoIXRoaXMuX25leHQgJiYgdGFza1RhaWwgIT09IHRoaXMpIHtcbiAgICAgIGlmICh0YXNrVGFpbCkgdGFza1RhaWwuX25leHQgPSB0aGlzO1xuICAgICAgZWxzZSB0YXNrSGVhZCA9IHRoaXM7XG4gICAgICB0YXNrVGFpbCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2NhbGwgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBzbGVlcCgpO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2FsbCkge1xuICAgICAgdGhpcy5fY2FsbCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lID0gSW5maW5pdHk7XG4gICAgICBzbGVlcCgpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXJGbHVzaCgpIHtcbiAgbm93KCk7IC8vIEdldCB0aGUgY3VycmVudCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxuICB2YXIgdCA9IHRhc2tIZWFkLCBlO1xuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKHVuZGVmaW5lZCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQge1NDSEVEVUxFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGk7XG5cbiAgaWYgKHNjaGVkdWxlcykge1xuICAgIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oW1tub2RlXV0sIHJvb3QsIG5hbWUsICtpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGFjdGl2ZX0gZnJvbSBcIi4vYWN0aXZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJydXB0fSBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbiIsImltcG9ydCB7U1RBUlRJTkcsIEVORElORywgRU5ERUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGVtcHR5ID0gdHJ1ZSxcbiAgICAgIGk7XG5cbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcblxuICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuXG4gIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5uYW1lICE9PSBuYW1lKSB7IGVtcHR5ID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgYWN0aXZlID0gc2NoZWR1bGUuc3RhdGUgPiBTVEFSVElORyAmJiBzY2hlZHVsZS5zdGF0ZSA8IEVORElORztcbiAgICBzY2hlZHVsZS5zdGF0ZSA9IEVOREVEO1xuICAgIHNjaGVkdWxlLnRpbWVyLnN0b3AoKTtcbiAgICBzY2hlZHVsZS5vbi5jYWxsKGFjdGl2ZSA/IFwiaW50ZXJydXB0XCIgOiBcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzY2hlZHVsZS5pbmRleCwgc2NoZWR1bGUuZ3JvdXApO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gIH1cblxuICBpZiAoZW1wdHkpIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ludGVycnVwdCBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdHJhbnNpdGlvbiBmcm9tIFwiLi90cmFuc2l0aW9uLmpzXCI7XG5cbnNlbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJydXB0ID0gc2VsZWN0aW9uX2ludGVycnVwdDtcbnNlbGVjdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbiA9IHNlbGVjdGlvbl90cmFuc2l0aW9uO1xuIiwiaW1wb3J0IGludGVycnVwdCBmcm9tIFwiLi4vaW50ZXJydXB0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICBpbnRlcnJ1cHQodGhpcywgbmFtZSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4uL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHtlYXNlQ3ViaWNJbk91dH0gZnJvbSBcImQzLWVhc2VcIjtcbmltcG9ydCB7bm93fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGRlZmF1bHRUaW1pbmcgPSB7XG4gIHRpbWU6IG51bGwsIC8vIFNldCBvbiB1c2UuXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogMjUwLFxuICBlYXNlOiBlYXNlQ3ViaWNJbk91dFxufTtcblxuZnVuY3Rpb24gaW5oZXJpdChub2RlLCBpZCkge1xuICB2YXIgdGltaW5nO1xuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xuICAgIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyYW5zaXRpb24gJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aW1pbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGlkLFxuICAgICAgdGltaW5nO1xuXG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xuICAgIGlkID0gbmFtZS5faWQsIG5hbWUgPSBuYW1lLl9uYW1lO1xuICB9IGVsc2Uge1xuICAgIGlkID0gbmV3SWQoKSwgKHRpbWluZyA9IGRlZmF1bHRUaW1pbmcpLnRpbWUgPSBub3coKSwgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpLCBncm91cCwgdGltaW5nIHx8IGluaGVyaXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtU3ZnIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKSwgaSA9IGZ1bGxuYW1lID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKShmdWxsbmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcImF0dHIuXCIgKyBuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHZhbHVlID09IG51bGwgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKShmdWxsbmFtZSlcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKGZ1bGxuYW1lLCBpLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlKG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGtleSA9IFwiYXR0ci5cIiArIG5hbWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIChmdWxsbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBpbml0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVsYXlDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkZWxheUZ1bmN0aW9uXG4gICAgICAgICAgOiBkZWxheUNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kZWxheTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkdXJhdGlvbkZ1bmN0aW9uXG4gICAgICAgICAgOiBkdXJhdGlvbkNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kdXJhdGlvbjtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGVhc2VDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKGVhc2VDb25zdGFudChpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5lYXNlO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGVhc2VWYXJ5aW5nKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0eXBlb2YgdiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLmVhY2goZWFzZVZhcnlpbmcodGhpcy5faWQsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBvbjAsIG9uMSwgdGhhdCA9IHRoaXMsIGlkID0gdGhhdC5faWQsIHNpemUgPSB0aGF0LnNpemUoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBjYW5jZWwgPSB7dmFsdWU6IHJlamVjdH0sXG4gICAgICAgIGVuZCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7IGlmICgtLXNpemUgPT09IDApIHJlc29sdmUoKTsgfX07XG5cbiAgICB0aGF0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgICBpZiAob24gIT09IG9uMCkge1xuICAgICAgICBvbjEgPSAob24wID0gb24pLmNvcHkoKTtcbiAgICAgICAgb24xLl8uY2FuY2VsLnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uaW50ZXJydXB0LnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uZW5kLnB1c2goZW5kKTtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGUub24gPSBvbjE7XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgc2VsZWN0aW9uIHdhcyBlbXB0eSwgcmVzb2x2ZSBlbmQgaW1tZWRpYXRlbHlcbiAgICBpZiAoc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7bWF0Y2hlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0clR3ZWVuIGZyb20gXCIuL2F0dHJUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZGVsYXkgZnJvbSBcIi4vZGVsYXkuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2R1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlIGZyb20gXCIuL2Vhc2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nIGZyb20gXCIuL2Vhc2VWYXJ5aW5nLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9maWx0ZXIgZnJvbSBcIi4vZmlsdGVyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdGlvbiBmcm9tIFwiLi9zZWxlY3Rpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlIGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZVR3ZWVuIGZyb20gXCIuL3N0eWxlVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dFR3ZWVuIGZyb20gXCIuL3RleHRUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHJhbnNpdGlvbiBmcm9tIFwiLi90cmFuc2l0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90d2VlbiBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZW5kIGZyb20gXCIuL2VuZC5qc1wiO1xuXG52YXIgaWQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNpdGlvbihncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9pZCA9IGlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2l0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdGlvbigpLnRyYW5zaXRpb24obmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdJZCgpIHtcbiAgcmV0dXJuICsraWQ7XG59XG5cbnZhciBzZWxlY3Rpb25fcHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZTtcblxuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB0cmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zaXRpb24sXG4gIHNlbGVjdDogdHJhbnNpdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogdHJhbnNpdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZHJlbixcbiAgZmlsdGVyOiB0cmFuc2l0aW9uX2ZpbHRlcixcbiAgbWVyZ2U6IHRyYW5zaXRpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25fdHJhbnNpdGlvbixcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiB0cmFuc2l0aW9uX29uLFxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXG4gIGF0dHJUd2VlbjogdHJhbnNpdGlvbl9hdHRyVHdlZW4sXG4gIHN0eWxlOiB0cmFuc2l0aW9uX3N0eWxlLFxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXG4gIHRleHQ6IHRyYW5zaXRpb25fdGV4dCxcbiAgdGV4dFR3ZWVuOiB0cmFuc2l0aW9uX3RleHRUd2VlbixcbiAgcmVtb3ZlOiB0cmFuc2l0aW9uX3JlbW92ZSxcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXG4gIGRlbGF5OiB0cmFuc2l0aW9uX2RlbGF5LFxuICBkdXJhdGlvbjogdHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlLFxuICBlYXNlVmFyeWluZzogdHJhbnNpdGlvbl9lYXNlVmFyeWluZyxcbiAgZW5kOiB0cmFuc2l0aW9uX2VuZCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXVxufTtcbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZU51bWJlciwgaW50ZXJwb2xhdGVSZ2IsIGludGVycG9sYXRlU3RyaW5nfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYztcbiAgcmV0dXJuICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiA/IGludGVycG9sYXRlTnVtYmVyXG4gICAgICA6IGIgaW5zdGFuY2VvZiBjb2xvciA/IGludGVycG9sYXRlUmdiXG4gICAgICA6IChjID0gY29sb3IoYikpID8gKGIgPSBjLCBpbnRlcnBvbGF0ZVJnYilcbiAgICAgIDogaW50ZXJwb2xhdGVTdHJpbmcpKGEsIGIpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uLl9pZCAhPT0gdGhpcy5faWQpIHRocm93IG5ldyBFcnJvcjtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gdHJhbnNpdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0LCBpbml0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBzdGFydChuYW1lKSB7XG4gIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gIXQgfHwgdCA9PT0gXCJzdGFydFwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9uMCwgb24xLCBzaXQgPSBzdGFydChuYW1lKSA/IGluaXQgOiBzZXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzaXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDJcbiAgICAgID8gZ2V0KHRoaXMubm9kZSgpLCBpZCkub24ub24obmFtZSlcbiAgICAgIDogdGhpcy5lYWNoKG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmVGdW5jdGlvbihpZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX190cmFuc2l0aW9uKSBpZiAoK2kgIT09IGlkKSByZXR1cm47XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub24oXCJlbmQucmVtb3ZlXCIsIHJlbW92ZUZ1bmN0aW9uKHRoaXMuX2lkKSk7XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7dGltZXIsIHRpbWVvdXR9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZW1wdHlPbiA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJjYW5jZWxcIiwgXCJpbnRlcnJ1cHRcIik7XG52YXIgZW1wdHlUd2VlbiA9IFtdO1xuXG5leHBvcnQgdmFyIENSRUFURUQgPSAwO1xuZXhwb3J0IHZhciBTQ0hFRFVMRUQgPSAxO1xuZXhwb3J0IHZhciBTVEFSVElORyA9IDI7XG5leHBvcnQgdmFyIFNUQVJURUQgPSAzO1xuZXhwb3J0IHZhciBSVU5OSU5HID0gNDtcbmV4cG9ydCB2YXIgRU5ESU5HID0gNTtcbmV4cG9ydCB2YXIgRU5ERUQgPSA2O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lLCBpZCwgaW5kZXgsIGdyb3VwLCB0aW1pbmcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtcbiAgZWxzZSBpZiAoaWQgaW4gc2NoZWR1bGVzKSByZXR1cm47XG4gIGNyZWF0ZShub2RlLCBpZCwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgaW5kZXg6IGluZGV4LCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgb246IGVtcHR5T24sXG4gICAgdHdlZW46IGVtcHR5VHdlZW4sXG4gICAgdGltZTogdGltaW5nLnRpbWUsXG4gICAgZGVsYXk6IHRpbWluZy5kZWxheSxcbiAgICBkdXJhdGlvbjogdGltaW5nLmR1cmF0aW9uLFxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBDUkVBVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzY2hlZHVsZWRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBTVEFSVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBydW5uaW5nXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGUgfHwgIShzY2hlZHVsZSA9IHNjaGVkdWxlW2lkXSkpIHRocm93IG5ldyBFcnJvcihcInRyYW5zaXRpb24gbm90IGZvdW5kXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShub2RlLCBpZCwgc2VsZikge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICB0d2VlbjtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzZWxmIHRpbWVyIHdoZW4gdGhlIHRyYW5zaXRpb24gaXMgY3JlYXRlZC5cbiAgLy8gTm90ZSB0aGUgYWN0dWFsIGRlbGF5IGlzIG5vdCBrbm93biB1bnRpbCB0aGUgZmlyc3QgY2FsbGJhY2shXG4gIHNjaGVkdWxlc1tpZF0gPSBzZWxmO1xuICBzZWxmLnRpbWVyID0gdGltZXIoc2NoZWR1bGUsIDAsIHNlbGYudGltZSk7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgIHNlbGYuc3RhdGUgPSBTQ0hFRFVMRUQ7XG4gICAgc2VsZi50aW1lci5yZXN0YXJ0KHN0YXJ0LCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuXG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgZGVsYXkgaXMgbGVzcyB0aGFuIG91ciBmaXJzdCBzbGVlcCwgc3RhcnQgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHNlbGYuZGVsYXkgPD0gZWxhcHNlZCkgc3RhcnQoZWxhcHNlZCAtIHNlbGYuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgIHZhciBpLCBqLCBuLCBvO1xuXG4gICAgLy8gSWYgdGhlIHN0YXRlIGlzIG5vdCBTQ0hFRFVMRUQsIHRoZW4gd2UgcHJldmlvdXNseSBlcnJvcmVkIG9uIHN0YXJ0LlxuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTQ0hFRFVMRUQpIHJldHVybiBzdG9wKCk7XG5cbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBvID0gc2NoZWR1bGVzW2ldO1xuICAgICAgaWYgKG8ubmFtZSAhPT0gc2VsZi5uYW1lKSBjb250aW51ZTtcblxuICAgICAgLy8gV2hpbGUgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgc3RhcnRpbmcgdHJhbnNpdGlvbiBkdXJpbmcgdGhpcyBmcmFtZSxcbiAgICAgIC8vIGRlZmVyIHN0YXJ0aW5nIGFuIGludGVycnVwdGluZyB0cmFuc2l0aW9uIHVudGlsIHRoYXQgdHJhbnNpdGlvbiBoYXMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcbiAgICAgIGlmIChvLnN0YXRlID09PSBTVEFSVEVEKSByZXR1cm4gdGltZW91dChzdGFydCk7XG5cbiAgICAgIC8vIEludGVycnVwdCB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGlmIGFueS5cbiAgICAgIGlmIChvLnN0YXRlID09PSBSVU5OSU5HKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGFueSBwcmUtZW1wdGVkIHRyYW5zaXRpb25zLlxuICAgICAgZWxzZSBpZiAoK2kgPCBpZCkge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmZXIgdGhlIGZpcnN0IHRpY2sgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lOyBzZWUgZDMvZDMjMTU3Ni5cbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIHNjaGVkdWxlZCBiZWZvcmUgdGhlIHN0YXJ0IGV2ZW50OyBzZWUgZDMvZDMtdHJhbnNpdGlvbiMxNiFcbiAgICAvLyBBc3N1bWluZyB0aGlzIGlzIHN1Y2Nlc3NmdWwsIHN1YnNlcXVlbnQgY2FsbGJhY2tzIGdvIHN0cmFpZ2h0IHRvIHRpY2suXG4gICAgdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBTVEFSVEVEKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBSVU5OSU5HO1xuICAgICAgICBzZWxmLnRpbWVyLnJlc3RhcnQodGljaywgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcbiAgICAgICAgdGljayhlbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERpc3BhdGNoIHRoZSBzdGFydCBldmVudC5cbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgdHdlZW4gYXJlIGluaXRpYWxpemVkLlxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVElORztcbiAgICBzZWxmLm9uLmNhbGwoXCJzdGFydFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU1RBUlRJTkcpIHJldHVybjsgLy8gaW50ZXJydXB0ZWRcbiAgICBzZWxmLnN0YXRlID0gU1RBUlRFRDtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHR3ZWVuLCBkZWxldGluZyBudWxsIHR3ZWVuLlxuICAgIHR3ZWVuID0gbmV3IEFycmF5KG4gPSBzZWxmLnR3ZWVuLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgaiA9IC0xOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobyA9IHNlbGYudHdlZW5baV0udmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKSkge1xuICAgICAgICB0d2VlblsrK2pdID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgdHdlZW4ubGVuZ3RoID0gaiArIDE7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICB2YXIgdCA9IGVsYXBzZWQgPCBzZWxmLmR1cmF0aW9uID8gc2VsZi5lYXNlLmNhbGwobnVsbCwgZWxhcHNlZCAvIHNlbGYuZHVyYXRpb24pIDogKHNlbGYudGltZXIucmVzdGFydChzdG9wKSwgc2VsZi5zdGF0ZSA9IEVORElORywgMSksXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IHR3ZWVuLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB0d2VlbltpXS5jYWxsKG5vZGUsIHQpO1xuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBlbmQgZXZlbnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IEVORElORykge1xuICAgICAgc2VsZi5vbi5jYWxsKFwiZW5kXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgICAgc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgc2VsZi5zdGF0ZSA9IEVOREVEO1xuICAgIHNlbGYudGltZXIuc3RvcCgpO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaWRdO1xuICAgIGZvciAodmFyIGkgaW4gc2NoZWR1bGVzKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG4gIH1cbn1cbiIsImltcG9ydCB7c2VsZWN0b3J9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIHNjaGVkdWxlKHN1Ymdyb3VwW2ldLCBuYW1lLCBpZCwgaSwgc3ViZ3JvdXAsIGdldChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0b3JBbGx9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbiA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSwgY2hpbGQsIGluaGVyaXQgPSBnZXQobm9kZSwgaWQpLCBrID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgayA8IGw7ICsraykge1xuICAgICAgICAgIGlmIChjaGlsZCA9IGNoaWxkcmVuW2tdKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShjaGlsZCwgbmFtZSwgaWQsIGssIGNoaWxkcmVuLCBpbmhlcml0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxudmFyIFNlbGVjdGlvbiA9IHNlbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9ncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3N0eWxlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZU51bGwobmFtZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICBzdHJpbmcxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgc3RyaW5nMTAgPSBzdHJpbmcxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSxcbiAgICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSBzdHJpbmcxID0gdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlTWF5YmVSZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIG9uMCwgb24xLCBsaXN0ZW5lcjAsIGtleSA9IFwic3R5bGUuXCIgKyBuYW1lLCBldmVudCA9IFwiZW5kLlwiICsga2V5LCByZW1vdmU7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uLFxuICAgICAgICBsaXN0ZW5lciA9IHNjaGVkdWxlLnZhbHVlW2tleV0gPT0gbnVsbCA/IHJlbW92ZSB8fCAocmVtb3ZlID0gc3R5bGVSZW1vdmUobmFtZSkpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wIHx8IGxpc3RlbmVyMCAhPT0gbGlzdGVuZXIpIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24oZXZlbnQsIGxpc3RlbmVyMCA9IGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGkgPSAobmFtZSArPSBcIlwiKSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVOdWxsKG5hbWUsIGkpKVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgc3R5bGVSZW1vdmUobmFtZSkpXG4gICAgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlRnVuY3Rpb24obmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUpKSlcbiAgICAgIC5lYWNoKHN0eWxlTWF5YmVSZW1vdmUodGhpcy5faWQsIG5hbWUpKVxuICAgIDogdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVDb25zdGFudChuYW1lLCBpLCB2YWx1ZSksIHByaW9yaXR5KVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgbnVsbCk7XG59XG4iLCJmdW5jdGlvbiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBpLmNhbGwodGhpcywgdCksIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIHQsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0ID0gKGkwID0gaSkgJiYgc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBrZXkgPSBcInN0eWxlLlwiICsgKG5hbWUgKz0gXCJcIik7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSk7XG59XG4iLCJpbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWUxID09IG51bGwgPyBcIlwiIDogdmFsdWUxO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdGhpcy50d2VlbihcInRleHRcIiwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gdGV4dEZ1bmN0aW9uKHR3ZWVuVmFsdWUodGhpcywgXCJ0ZXh0XCIsIHZhbHVlKSlcbiAgICAgIDogdGV4dENvbnN0YW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiKSk7XG59XG4iLCJmdW5jdGlvbiB0ZXh0SW50ZXJwb2xhdGUoaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBpLmNhbGwodGhpcywgdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRUd2Vlbih2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIHRleHRJbnRlcnBvbGF0ZShpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGtleSA9IFwidGV4dFwiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgdGV4dFR3ZWVuKHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQwID0gdGhpcy5faWQsXG4gICAgICBpZDEgPSBuZXdJZCgpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHZhciBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkMCk7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkMSwgaSwgZ3JvdXAsIHtcbiAgICAgICAgICB0aW1lOiBpbmhlcml0LnRpbWUgKyBpbmhlcml0LmRlbGF5ICsgaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQxKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjEgPSB0d2VlbjEuc2xpY2UoKTtcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHR3ZWVuRnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gKHR3ZWVuMCA9IHR3ZWVuKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgdCA9IHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9LCBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xW2ldID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IG4pIHR3ZWVuMS5wdXNoKHQpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICBuYW1lICs9IFwiXCI7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0KHRoaXMubm9kZSgpLCBpZCkudHdlZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2Vlbi5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodCA9IHR3ZWVuW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGwgPyB0d2VlblJlbW92ZSA6IHR3ZWVuRnVuY3Rpb24pKGlkLCBuYW1lLCB2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHdlZW5WYWx1ZSh0cmFuc2l0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0cmFuc2l0aW9uLl9pZDtcblxuICB0cmFuc2l0aW9uLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKTtcbiAgICAoc2NoZWR1bGUudmFsdWUgfHwgKHNjaGVkdWxlLnZhbHVlID0ge30pKVtuYW1lXSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIGdldChub2RlLCBpZCkudmFsdWVbbmFtZV07XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBab29tRXZlbnQodHlwZSwge1xuICBzb3VyY2VFdmVudCxcbiAgdGFyZ2V0LFxuICB0cmFuc2Zvcm0sXG4gIGRpc3BhdGNoXG59KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICB0eXBlOiB7dmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgc291cmNlRXZlbnQ6IHt2YWx1ZTogc291cmNlRXZlbnQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdGFyZ2V0OiB7dmFsdWU6IHRhcmdldCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0cmFuc2Zvcm06IHt2YWx1ZTogdHJhbnNmb3JtLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIF86IHt2YWx1ZTogZGlzcGF0Y2h9XG4gIH0pO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIHpvb219IGZyb20gXCIuL3pvb20uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tVHJhbnNmb3JtLCBpZGVudGl0eSBhcyB6b29tSWRlbnRpdHksIFRyYW5zZm9ybSBhcyBab29tVHJhbnNmb3JtfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbiIsImV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm0oaywgeCwgeSkge1xuICB0aGlzLmsgPSBrO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNmb3JtLFxuICBzY2FsZTogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrID09PSAxID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rICogaywgdGhpcy54LCB0aGlzLnkpO1xuICB9LFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9PT0gMCAmIHkgPT09IDAgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmssIHRoaXMueCArIHRoaXMuayAqIHgsIHRoaXMueSArIHRoaXMuayAqIHkpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gW3BvaW50WzBdICogdGhpcy5rICsgdGhpcy54LCBwb2ludFsxXSAqIHRoaXMuayArIHRoaXMueV07XG4gIH0sXG4gIGFwcGx5WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4ICogdGhpcy5rICsgdGhpcy54O1xuICB9LFxuICBhcHBseVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geSAqIHRoaXMuayArIHRoaXMueTtcbiAgfSxcbiAgaW52ZXJ0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiBbKGxvY2F0aW9uWzBdIC0gdGhpcy54KSAvIHRoaXMuaywgKGxvY2F0aW9uWzFdIC0gdGhpcy55KSAvIHRoaXMua107XG4gIH0sXG4gIGludmVydFg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHggLSB0aGlzLngpIC8gdGhpcy5rO1xuICB9LFxuICBpbnZlcnRZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuICh5IC0gdGhpcy55KSAvIHRoaXMuaztcbiAgfSxcbiAgcmVzY2FsZVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geC5jb3B5KCkuZG9tYWluKHgucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRYLCB0aGlzKS5tYXAoeC5pbnZlcnQsIHgpKTtcbiAgfSxcbiAgcmVzY2FsZVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geS5jb3B5KCkuZG9tYWluKHkucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRZLCB0aGlzKS5tYXAoeS5pbnZlcnQsIHkpKTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMueCArIFwiLFwiICsgdGhpcy55ICsgXCIpIHNjYWxlKFwiICsgdGhpcy5rICsgXCIpXCI7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgaWRlbnRpdHkgPSBuZXcgVHJhbnNmb3JtKDEsIDAsIDApO1xuXG50cmFuc2Zvcm0ucHJvdG90eXBlID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUpIHtcbiAgd2hpbGUgKCFub2RlLl9fem9vbSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybiBpZGVudGl0eTtcbiAgcmV0dXJuIG5vZGUuX196b29tO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge2RyYWdEaXNhYmxlLCBkcmFnRW5hYmxlfSBmcm9tIFwiZDMtZHJhZ1wiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZVpvb219IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzZWxlY3QsIHBvaW50ZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7aW50ZXJydXB0fSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgWm9vbUV2ZW50IGZyb20gXCIuL2V2ZW50LmpzXCI7XG5pbXBvcnQge1RyYW5zZm9ybSwgaWRlbnRpdHl9IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IG5vZXZlbnQsIHtub3Byb3BhZ2F0aW9ufSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuLy8gZXhjZXB0IGZvciBwaW5jaC10by16b29tLCB3aGljaCBpcyBzZW50IGFzIGEgd2hlZWwrY3RybEtleSBldmVudFxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcihldmVudCkge1xuICByZXR1cm4gKCFldmVudC5jdHJsS2V5IHx8IGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpICYmICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFeHRlbnQoKSB7XG4gIHZhciBlID0gdGhpcztcbiAgaWYgKGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgZSA9IGUub3duZXJTVkdFbGVtZW50IHx8IGU7XG4gICAgaWYgKGUuaGFzQXR0cmlidXRlKFwidmlld0JveFwiKSkge1xuICAgICAgZSA9IGUudmlld0JveC5iYXNlVmFsO1xuICAgICAgcmV0dXJuIFtbZS54LCBlLnldLCBbZS54ICsgZS53aWR0aCwgZS55ICsgZS5oZWlnaHRdXTtcbiAgICB9XG4gICAgcmV0dXJuIFtbMCwgMF0sIFtlLndpZHRoLmJhc2VWYWwudmFsdWUsIGUuaGVpZ2h0LmJhc2VWYWwudmFsdWVdXTtcbiAgfVxuICByZXR1cm4gW1swLCAwXSwgW2UuY2xpZW50V2lkdGgsIGUuY2xpZW50SGVpZ2h0XV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2Zvcm0oKSB7XG4gIHJldHVybiB0aGlzLl9fem9vbSB8fCBpZGVudGl0eTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdoZWVsRGVsdGEoZXZlbnQpIHtcbiAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKiAoZXZlbnQuY3RybEtleSA/IDEwIDogMSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb25zdHJhaW4odHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICB2YXIgZHgwID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzBdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVswXSxcbiAgICAgIGR4MSA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMF0sXG4gICAgICBkeTAgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMF1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzFdLFxuICAgICAgZHkxID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzFdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVsxXTtcbiAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGUoXG4gICAgZHgxID4gZHgwID8gKGR4MCArIGR4MSkgLyAyIDogTWF0aC5taW4oMCwgZHgwKSB8fCBNYXRoLm1heCgwLCBkeDEpLFxuICAgIGR5MSA+IGR5MCA/IChkeTAgKyBkeTEpIC8gMiA6IE1hdGgubWluKDAsIGR5MCkgfHwgTWF0aC5tYXgoMCwgZHkxKVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBleHRlbnQgPSBkZWZhdWx0RXh0ZW50LFxuICAgICAgY29uc3RyYWluID0gZGVmYXVsdENvbnN0cmFpbixcbiAgICAgIHdoZWVsRGVsdGEgPSBkZWZhdWx0V2hlZWxEZWx0YSxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBzY2FsZUV4dGVudCA9IFswLCBJbmZpbml0eV0sXG4gICAgICB0cmFuc2xhdGVFeHRlbnQgPSBbWy1JbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCBJbmZpbml0eV1dLFxuICAgICAgZHVyYXRpb24gPSAyNTAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlWm9vbSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJ6b29tXCIsIFwiZW5kXCIpLFxuICAgICAgdG91Y2hzdGFydGluZyxcbiAgICAgIHRvdWNoZmlyc3QsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIHRvdWNoRGVsYXkgPSA1MDAsXG4gICAgICB3aGVlbERlbGF5ID0gMTUwLFxuICAgICAgY2xpY2tEaXN0YW5jZTIgPSAwLFxuICAgICAgdGFwRGlzdGFuY2UgPSAxMDtcblxuICBmdW5jdGlvbiB6b29tKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSlcbiAgICAgICAgLm9uKFwid2hlZWwuem9vbVwiLCB3aGVlbGVkLCB7cGFzc2l2ZTogZmFsc2V9KVxuICAgICAgICAub24oXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZWRvd25lZClcbiAgICAgICAgLm9uKFwiZGJsY2xpY2suem9vbVwiLCBkYmxjbGlja2VkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS56b29tXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLnpvb20gdG91Y2hjYW5jZWwuem9vbVwiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgem9vbS50cmFuc2Zvcm0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBjb2xsZWN0aW9uLnNlbGVjdGlvbiA/IGNvbGxlY3Rpb24uc2VsZWN0aW9uKCkgOiBjb2xsZWN0aW9uO1xuICAgIHNlbGVjdGlvbi5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKTtcbiAgICBpZiAoY29sbGVjdGlvbiAhPT0gc2VsZWN0aW9uKSB7XG4gICAgICBzY2hlZHVsZShjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAuZXZlbnQoZXZlbnQpXG4gICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSlcbiAgICAgICAgICAuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgem9vbS5zY2FsZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20uc2NhbGVUbyhzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGswID0gdGhpcy5fX3pvb20uayxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGswICogazE7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20uc2NhbGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcCxcbiAgICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW4odGhpcy5fX3pvb20udHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHlcbiAgICAgICksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIG51bGwsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHA7XG4gICAgICByZXR1cm4gY29uc3RyYWluKGlkZW50aXR5LnRyYW5zbGF0ZShwMFswXSwgcDBbMV0pLnNjYWxlKHQuaykudHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8gLXguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC14LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8gLXkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC15XG4gICAgICApLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIGspIHtcbiAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBrKSk7XG4gICAgcmV0dXJuIGsgPT09IHRyYW5zZm9ybS5rID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybShrLCB0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgcDAsIHAxKSB7XG4gICAgdmFyIHggPSBwMFswXSAtIHAxWzBdICogdHJhbnNmb3JtLmssIHkgPSBwMFsxXSAtIHAxWzFdICogdHJhbnNmb3JtLms7XG4gICAgcmV0dXJuIHggPT09IHRyYW5zZm9ybS54ICYmIHkgPT09IHRyYW5zZm9ybS55ID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybSh0cmFuc2Zvcm0uaywgeCwgeSk7XG4gIH1cblxuICBmdW5jdGlvbiBjZW50cm9pZChleHRlbnQpIHtcbiAgICByZXR1cm4gWygrZXh0ZW50WzBdWzBdICsgK2V4dGVudFsxXVswXSkgLyAyLCAoK2V4dGVudFswXVsxXSArICtleHRlbnRbMV1bMV0pIC8gMl07XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZSh0cmFuc2l0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCkge1xuICAgIHRyYW5zaXRpb25cbiAgICAgICAgLm9uKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmV2ZW50KGV2ZW50KS5zdGFydCgpOyB9KVxuICAgICAgICAub24oXCJpbnRlcnJ1cHQuem9vbSBlbmQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmV2ZW50KGV2ZW50KS5lbmQoKTsgfSlcbiAgICAgICAgLnR3ZWVuKFwiem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGcgPSBnZXN0dXJlKHRoYXQsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgICAgICAgZSA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKSxcbiAgICAgICAgICAgICAgcCA9IHBvaW50ID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwb2ludCA9PT0gXCJmdW5jdGlvblwiID8gcG9pbnQuYXBwbHkodGhhdCwgYXJncykgOiBwb2ludCxcbiAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KGVbMV1bMF0gLSBlWzBdWzBdLCBlWzFdWzFdIC0gZVswXVsxXSksXG4gICAgICAgICAgICAgIGEgPSB0aGF0Ll9fem9vbSxcbiAgICAgICAgICAgICAgYiA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGF0LCBhcmdzKSA6IHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgaSA9IGludGVycG9sYXRlKGEuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYS5rKSwgYi5pbnZlcnQocCkuY29uY2F0KHcgLyBiLmspKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHQgPSBiOyAvLyBBdm9pZCByb3VuZGluZyBlcnJvciBvbiBlbmQuXG4gICAgICAgICAgICBlbHNlIHsgdmFyIGwgPSBpKHQpLCBrID0gdyAvIGxbMl07IHQgPSBuZXcgVHJhbnNmb3JtKGssIHBbMF0gLSBsWzBdICogaywgcFsxXSAtIGxbMV0gKiBrKTsgfVxuICAgICAgICAgICAgZy56b29tKG51bGwsIHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VzdHVyZSh0aGF0LCBhcmdzLCBjbGVhbikge1xuICAgIHJldHVybiAoIWNsZWFuICYmIHRoYXQuX196b29taW5nKSB8fCBuZXcgR2VzdHVyZSh0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdlc3R1cmUodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgdGhpcy5zb3VyY2VFdmVudCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgdGhpcy50YXBzID0gMDtcbiAgfVxuXG4gIEdlc3R1cmUucHJvdG90eXBlID0ge1xuICAgIGV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50KSB0aGlzLnNvdXJjZUV2ZW50ID0gZXZlbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgrK3RoaXMuYWN0aXZlID09PSAxKSB7XG4gICAgICAgIHRoaXMudGhhdC5fX3pvb21pbmcgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24oa2V5LCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0aGlzLm1vdXNlICYmIGtleSAhPT0gXCJtb3VzZVwiKSB0aGlzLm1vdXNlWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLm1vdXNlWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMCAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDBbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gwWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMSAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDFbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gxWzBdKTtcbiAgICAgIHRoaXMudGhhdC5fX3pvb20gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLmVtaXQoXCJ6b29tXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGhhdC5fX3pvb21pbmc7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGQgPSBzZWxlY3QodGhpcy50aGF0KS5kYXR1bSgpO1xuICAgICAgbGlzdGVuZXJzLmNhbGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoaXMudGhhdCxcbiAgICAgICAgbmV3IFpvb21FdmVudCh0eXBlLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IHRoaXMuc291cmNlRXZlbnQsXG4gICAgICAgICAgdGFyZ2V0OiB6b29tLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnRoYXQuX196b29tLFxuICAgICAgICAgIGRpc3BhdGNoOiBsaXN0ZW5lcnNcbiAgICAgICAgfSksXG4gICAgICAgIGRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdoZWVsZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCB0LmsgKiBNYXRoLnBvdygyLCB3aGVlbERlbHRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50KTtcblxuICAgIC8vIElmIHRoZSBtb3VzZSBpcyBpbiB0aGUgc2FtZSBsb2NhdGlvbiBhcyBiZWZvcmUsIHJldXNlIGl0LlxuICAgIC8vIElmIHRoZXJlIHdlcmUgcmVjZW50IHdoZWVsIGV2ZW50cywgcmVzZXQgdGhlIHdoZWVsIGlkbGUgdGltZW91dC5cbiAgICBpZiAoZy53aGVlbCkge1xuICAgICAgaWYgKGcubW91c2VbMF1bMF0gIT09IHBbMF0gfHwgZy5tb3VzZVswXVsxXSAhPT0gcFsxXSkge1xuICAgICAgICBnLm1vdXNlWzFdID0gdC5pbnZlcnQoZy5tb3VzZVswXSA9IHApO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGcud2hlZWwpO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2hlZWwgZXZlbnQgd29u4oCZdCB0cmlnZ2VyIGEgdHJhbnNmb3JtIGNoYW5nZSwgaWdub3JlIGl0LlxuICAgIGVsc2UgaWYgKHQuayA9PT0gaykgcmV0dXJuO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBjYXB0dXJlIHRoZSBtb3VzZSBwb2ludCBhbmQgbG9jYXRpb24gYXQgdGhlIHN0YXJ0LlxuICAgIGVsc2Uge1xuICAgICAgZy5tb3VzZSA9IFtwLCB0LmludmVydChwKV07XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZy53aGVlbCA9IHNldFRpbWVvdXQod2hlZWxpZGxlZCwgd2hlZWxEZWxheSk7XG4gICAgZy56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0LCBrKSwgZy5tb3VzZVswXSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcblxuICAgIGZ1bmN0aW9uIHdoZWVsaWRsZWQoKSB7XG4gICAgICBnLndoZWVsID0gbnVsbDtcbiAgICAgIGcuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCB0cnVlKS5ldmVudChldmVudCksXG4gICAgICAgIHYgPSBzZWxlY3QoZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZW1vdmVkLCB0cnVlKS5vbihcIm1vdXNldXAuem9vbVwiLCBtb3VzZXVwcGVkLCB0cnVlKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLFxuICAgICAgICB4MCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHkwID0gZXZlbnQuY2xpZW50WTtcblxuICAgIGRyYWdEaXNhYmxlKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGcubW91c2UgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApXTtcbiAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgZy5zdGFydCgpO1xuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlZChldmVudCkge1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBpZiAoIWcubW92ZWQpIHtcbiAgICAgICAgdmFyIGR4ID0gZXZlbnQuY2xpZW50WCAtIHgwLCBkeSA9IGV2ZW50LmNsaWVudFkgLSB5MDtcbiAgICAgICAgZy5tb3ZlZCA9IGR4ICogZHggKyBkeSAqIGR5ID4gY2xpY2tEaXN0YW5jZTI7XG4gICAgICB9XG4gICAgICBnLmV2ZW50KGV2ZW50KVxuICAgICAgIC56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShnLnRoYXQuX196b29tLCBnLm1vdXNlWzBdID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cHBlZChldmVudCkge1xuICAgICAgdi5vbihcIm1vdXNlbW92ZS56b29tIG1vdXNldXAuem9vbVwiLCBudWxsKTtcbiAgICAgIGRyYWdFbmFibGUoZXZlbnQudmlldywgZy5tb3ZlZCk7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGcuZXZlbnQoZXZlbnQpLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRibGNsaWNrZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgIHAwID0gcG9pbnRlcihldmVudC5jaGFuZ2VkVG91Y2hlcyA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQsIHRoaXMpLFxuICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgIGsxID0gdDAuayAqIChldmVudC5zaGlmdEtleSA/IDAuNSA6IDIpLFxuICAgICAgICB0MSA9IGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3MpLCB0cmFuc2xhdGVFeHRlbnQpO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgaWYgKGR1cmF0aW9uID4gMCkgc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChzY2hlZHVsZSwgdDEsIHAwLCBldmVudCk7XG4gICAgZWxzZSBzZWxlY3QodGhpcykuY2FsbCh6b29tLnRyYW5zZm9ybSwgdDEsIHAwLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA9PT0gbikuZXZlbnQoZXZlbnQpLFxuICAgICAgICBzdGFydGVkLCBpLCB0LCBwO1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgcCA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCksIHQuaWRlbnRpZmllcl07XG4gICAgICBpZiAoIWcudG91Y2gwKSBnLnRvdWNoMCA9IHAsIHN0YXJ0ZWQgPSB0cnVlLCBnLnRhcHMgPSAxICsgISF0b3VjaHN0YXJ0aW5nO1xuICAgICAgZWxzZSBpZiAoIWcudG91Y2gxICYmIGcudG91Y2gwWzJdICE9PSBwWzJdKSBnLnRvdWNoMSA9IHAsIGcudGFwcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRvdWNoc3RhcnRpbmcpIHRvdWNoc3RhcnRpbmcgPSBjbGVhclRpbWVvdXQodG91Y2hzdGFydGluZyk7XG5cbiAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgaWYgKGcudGFwcyA8IDIpIHRvdWNoZmlyc3QgPSBwWzBdLCB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQsIHAsIGw7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDBbMF0gPSBwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xuICAgIH1cbiAgICB0ID0gZy50aGF0Ll9fem9vbTtcbiAgICBpZiAoZy50b3VjaDEpIHtcbiAgICAgIHZhciBwMCA9IGcudG91Y2gwWzBdLCBsMCA9IGcudG91Y2gwWzFdLFxuICAgICAgICAgIHAxID0gZy50b3VjaDFbMF0sIGwxID0gZy50b3VjaDFbMV0sXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcbiAgICAgICAgICBkbCA9IChkbCA9IGwxWzBdIC0gbDBbMF0pICogZGwgKyAoZGwgPSBsMVsxXSAtIGwwWzFdKSAqIGRsO1xuICAgICAgdCA9IHNjYWxlKHQsIE1hdGguc3FydChkcCAvIGRsKSk7XG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xuICAgICAgbCA9IFsobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xuICAgIGVsc2UgcmV0dXJuO1xuXG4gICAgZy56b29tKFwidG91Y2hcIiwgY29uc3RyYWluKHRyYW5zbGF0ZSh0LCBwLCBsKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV07XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gxO1xuICAgIH1cbiAgICBpZiAoZy50b3VjaDEgJiYgIWcudG91Y2gwKSBnLnRvdWNoMCA9IGcudG91Y2gxLCBkZWxldGUgZy50b3VjaDE7XG4gICAgaWYgKGcudG91Y2gwKSBnLnRvdWNoMFsxXSA9IHRoaXMuX196b29tLmludmVydChnLnRvdWNoMFswXSk7XG4gICAgZWxzZSB7XG4gICAgICBnLmVuZCgpO1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYSBkYmx0YXAsIHJlcm91dGUgdG8gdGhlIChvcHRpb25hbCkgZGJsY2xpY2suem9vbSBoYW5kbGVyLlxuICAgICAgaWYgKGcudGFwcyA9PT0gMikge1xuICAgICAgICB0ID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgICAgaWYgKE1hdGguaHlwb3QodG91Y2hmaXJzdFswXSAtIHRbMF0sIHRvdWNoZmlyc3RbMV0gLSB0WzFdKSA8IHRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHAgPSBzZWxlY3QodGhpcykub24oXCJkYmxjbGljay56b29tXCIpO1xuICAgICAgICAgIGlmIChwKSBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB6b29tLndoZWVsRGVsdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAod2hlZWxEZWx0YSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB6b29tKSA6IHdoZWVsRGVsdGE7XG4gIH07XG5cbiAgem9vbS5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IGZpbHRlcjtcbiAgfTtcblxuICB6b29tLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIHpvb20uZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCB6b29tKSA6IGV4dGVudDtcbiAgfTtcblxuICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlRXh0ZW50WzBdID0gK19bMF0sIHNjYWxlRXh0ZW50WzFdID0gK19bMV0sIHpvb20pIDogW3NjYWxlRXh0ZW50WzBdLCBzY2FsZUV4dGVudFsxXV07XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNsYXRlRXh0ZW50WzBdWzBdID0gK19bMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVswXSA9ICtfWzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV0gPSArX1swXVsxXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdID0gK19bMV1bMV0sIHpvb20pIDogW1t0cmFuc2xhdGVFeHRlbnRbMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXV0sIFt0cmFuc2xhdGVFeHRlbnRbMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXV1dO1xuICB9O1xuXG4gIHpvb20uY29uc3RyYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnN0cmFpbiA9IF8sIHpvb20pIDogY29uc3RyYWluO1xuICB9O1xuXG4gIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHVyYXRpb24gPSArXywgem9vbSkgOiBkdXJhdGlvbjtcbiAgfTtcblxuICB6b29tLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgem9vbSkgOiBpbnRlcnBvbGF0ZTtcbiAgfTtcblxuICB6b29tLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IHpvb20gOiB2YWx1ZTtcbiAgfTtcblxuICB6b29tLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIHpvb20pIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICB6b29tLnRhcERpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcERpc3RhbmNlID0gK18sIHpvb20pIDogdGFwRGlzdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59XG4iLCIvKipcbiAqIEpTVFMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRURMdjEudHh0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRVBMdjEudHh0XG4gKiBAbGljZW5zZVxuICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxlKTplKCh0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikuanN0cz17fSl9KHRoaXMsKGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2NsYXNzIGV7c3RhdGljIGVxdWFsc1dpdGhUb2xlcmFuY2UodCxlLG4pe3JldHVybiBNYXRoLmFicyh0LWUpPD1ufX1jbGFzcyBuIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtFeGNlcHRpb246bn0pWzBdfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMubWVzc2FnZX19Y2xhc3MgcyBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb246c30pWzBdfX1jbGFzcyBpe2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5sb3c9ZXx8MCx0aGlzLmhpZ2g9dHx8MH1zdGF0aWMgdG9CaW5hcnlTdHJpbmcodCl7bGV0IGUsbj1cIlwiO2ZvcihlPTIxNDc0ODM2NDg7ZT4wO2U+Pj49MSluKz0odC5oaWdoJmUpPT09ZT9cIjFcIjpcIjBcIjtmb3IoZT0yMTQ3NDgzNjQ4O2U+MDtlPj4+PTEpbis9KHQubG93JmUpPT09ZT9cIjFcIjpcIjBcIjtyZXR1cm4gbn19ZnVuY3Rpb24gcigpe31mdW5jdGlvbiBvKCl7fWZ1bmN0aW9uIGwoKXt9ZnVuY3Rpb24gYSgpe31mdW5jdGlvbiBjKCl7fXIuTmFOPU5hTixyLmlzTmFOPXQ9Pk51bWJlci5pc05hTih0KSxyLmlzSW5maW5pdGU9dD0+IU51bWJlci5pc0Zpbml0ZSh0KSxyLk1BWF9WQUxVRT1OdW1iZXIuTUFYX1ZBTFVFLHIuUE9TSVRJVkVfSU5GSU5JVFk9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHIuTkVHQVRJVkVfSU5GSU5JVFk9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFwiZnVuY3Rpb25cIj09dHlwZW9mIEZsb2F0NjRBcnJheSYmXCJmdW5jdGlvblwiPT10eXBlb2YgSW50MzJBcnJheT9mdW5jdGlvbigpe2NvbnN0IHQ9MjE0NjQzNTA3MixlPW5ldyBGbG9hdDY0QXJyYXkoMSksbj1uZXcgSW50MzJBcnJheShlLmJ1ZmZlcik7ci5kb3VibGVUb0xvbmdCaXRzPWZ1bmN0aW9uKHMpe2VbMF09cztsZXQgcj0wfG5bMF0sbz0wfG5bMV07cmV0dXJuKG8mdCk9PT10JiYwIT0oMTA0ODU3NSZvKSYmMCE9PXImJihyPTAsbz0yMTQ2OTU5MzYwKSxuZXcgaShvLHIpfSxyLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5bMF09dC5sb3csblsxXT10LmhpZ2gsZVswXX19KCk6ZnVuY3Rpb24oKXtjb25zdCB0PTEwMjMsZT1NYXRoLmxvZzIsbj1NYXRoLmZsb29yLHM9TWF0aC5wb3csbz1mdW5jdGlvbigpe2ZvcihsZXQgdD01Mzt0PjA7dC0tKXtjb25zdCBpPXMoMix0KS0xO2lmKG4oZShpKSkrMT09PXQpcmV0dXJuIGl9cmV0dXJuIDB9KCk7ci5kb3VibGVUb0xvbmdCaXRzPWZ1bmN0aW9uKHIpe2xldCBsLGEsYyxoLHUsZyxkLF8scDtpZihyPDB8fDEvcj09PU51bWJlci5ORUdBVElWRV9JTkZJTklUWT8oZz0xPDwzMSxyPS1yKTpnPTAsMD09PXIpcmV0dXJuIHA9MCxfPWcsbmV3IGkoXyxwKTtpZihyPT09MS8wKXJldHVybiBwPTAsXz0yMTQ2NDM1MDcyfGcsbmV3IGkoXyxwKTtpZihyIT1yKXJldHVybiBwPTAsXz0yMTQ2OTU5MzYwLG5ldyBpKF8scCk7aWYoaD0wLHA9MCxsPW4ociksbD4xKWlmKGw8PW8paD1uKGUobCkpLGg8PTIwPyhwPTAsXz1sPDwyMC1oJjEwNDg1NzUpOihjPWgtMjAsYT1zKDIsYykscD1sJWE8PDMyLWMsXz1sL2EmMTA0ODU3NSk7ZWxzZSBmb3IoYz1sLHA9MDthPWMvMixjPW4oYSksMCE9PWM7KWgrKyxwPj4+PTEscHw9KDEmXyk8PDMxLF8+Pj49MSxhIT09YyYmKF98PTUyNDI4OCk7aWYoZD1oK3QsdT0wPT09bCxsPXItbCxoPDUyJiYwIT09bClmb3IoYz0wOzspe2lmKGE9MipsLGE+PTE/KGw9YS0xLHU/KGQtLSx1PSExKTooYzw8PTEsY3w9MSxoKyspKToobD1hLHU/MD09LS1kJiYoaCsrLHU9ITEpOihjPDw9MSxoKyspKSwyMD09PWgpX3w9YyxjPTA7ZWxzZSBpZig1Mj09PWgpe3B8PWM7YnJlYWt9aWYoMT09PWEpe2g8MjA/X3w9Yzw8MjAtaDpoPDUyJiYocHw9Yzw8NTItaCk7YnJlYWt9fXJldHVybiBffD1kPDwyMCxffD1nLG5ldyBpKF8scCl9LHIubG9uZ0JpdHNUb0RvdWJsZT1mdW5jdGlvbihlKXtsZXQgbixpLHIsbztjb25zdCBsPWUuaGlnaCxhPWUubG93LGM9bCYxPDwzMT8tMToxO2ZvcihyPSgoMjE0NjQzNTA3MiZsKT4+MjApLXQsbz0wLGk9MTw8MTksbj0xO248PTIwO24rKylsJmkmJihvKz1zKDIsLW4pKSxpPj4+PTE7Zm9yKGk9MTw8MzEsbj0yMTtuPD01MjtuKyspYSZpJiYobys9cygyLC1uKSksaT4+Pj0xO2lmKC0xMDIzPT09cil7aWYoMD09PW8pcmV0dXJuIDAqYztyPS0xMDIyfWVsc2V7aWYoMTAyND09PXIpcmV0dXJuIDA9PT1vP2MvMDpOYU47bys9MX1yZXR1cm4gYypvKnMoMixyKX19KCk7Y2xhc3MgaCBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtSdW50aW1lRXhjZXB0aW9uOmh9KVswXX19Y2xhc3MgdSBleHRlbmRzIGh7Y29uc3RydWN0b3IoKXtzdXBlcigpLHUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpaC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fX1jbGFzcyBne3N0YXRpYyBzaG91bGROZXZlclJlYWNoSGVyZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUobnVsbCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhyb3cgbmV3IHUoXCJTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZVwiKyhudWxsIT09dD9cIjogXCIrdDpcIlwiKSl9fXN0YXRpYyBpc1RydWUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zy5pc1RydWUodCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtpZighYXJndW1lbnRzWzBdKXRocm93IG51bGw9PT10P25ldyB1Om5ldyB1KHQpfX1zdGF0aWMgZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2cuZXF1YWxzKHQsZSxudWxsKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZighZS5lcXVhbHModCkpdGhyb3cgbmV3IHUoXCJFeHBlY3RlZCBcIit0K1wiIGJ1dCBlbmNvdW50ZXJlZCBcIitlKyhudWxsIT09bj9cIjogXCIrbjpcIlwiKSl9fX1jb25zdCBkPW5ldyBBcnJheUJ1ZmZlcig4KSxfPW5ldyBGbG9hdDY0QXJyYXkoZCkscD1uZXcgSW50MzJBcnJheShkKTtjbGFzcyBte2NvbnN0cnVjdG9yKCl7bS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLno9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCltLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSx0LmdldFooKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxtLk5VTExfT1JESU5BVEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMueD10LHRoaXMueT1lLHRoaXMuej1ufX1zdGF0aWMgaGFzaENvZGUodCl7cmV0dXJuIF9bMF09dCxwWzBdXnBbMV19Z2V0TSgpe3JldHVybiByLk5hTn1zZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaCh0KXtjYXNlIG0uWDp0aGlzLng9ZTticmVhaztjYXNlIG0uWTp0aGlzLnk9ZTticmVhaztjYXNlIG0uWjp0aGlzLnNldFooZSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX1lcXVhbHMyRCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy54PT09dC54JiZ0aGlzLnk9PT10Lnl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiEhZS5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueCx0LngsbikmJiEhZS5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueSx0Lnksbil9fXNldE0odCl7dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIittLk0pfWdldFooKXtyZXR1cm4gdGhpcy56fWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIG0uWDpyZXR1cm4gdGhpcy54O2Nhc2UgbS5ZOnJldHVybiB0aGlzLnk7Y2FzZSBtLlo6cmV0dXJuIHRoaXMuZ2V0WigpfXRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9ZXF1YWxzM0QodCl7cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55JiYodGhpcy5nZXRaKCk9PT10LmdldFooKXx8ci5pc05hTih0aGlzLmdldFooKSkmJnIuaXNOYU4odC5nZXRaKCkpKX1lcXVhbHModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBtJiZ0aGlzLmVxdWFsczJEKHQpfWVxdWFsSW5aKHQsbil7cmV0dXJuIGUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLmdldFooKSx0LmdldFooKSxuKX1zZXRYKHQpe3RoaXMueD10fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMueDxlLng/LTE6dGhpcy54PmUueD8xOnRoaXMueTxlLnk/LTE6dGhpcy55PmUueT8xOjB9Z2V0WCgpe3JldHVybiB0aGlzLnh9c2V0Wih0KXt0aGlzLno9dH1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJ0aGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGlzIGNsYXNzIGlzIENsb25lYWJsZVwiKSxudWxsO3Rocm93IHR9fWNvcHkoKXtyZXR1cm4gbmV3IG0odGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiwgXCIrdGhpcy5nZXRaKCkrXCIpXCJ9ZGlzdGFuY2UzRCh0KXtjb25zdCBlPXRoaXMueC10Lngsbj10aGlzLnktdC55LHM9dGhpcy5nZXRaKCktdC5nZXRaKCk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuK3Mqcyl9Z2V0WSgpe3JldHVybiB0aGlzLnl9c2V0WSh0KXt0aGlzLnk9dH1kaXN0YW5jZSh0KXtjb25zdCBlPXRoaXMueC10Lngsbj10aGlzLnktdC55O3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9aGFzaENvZGUoKXtsZXQgdD0xNztyZXR1cm4gdD0zNyp0K20uaGFzaENvZGUodGhpcy54KSx0PTM3KnQrbS5oYXNoQ29kZSh0aGlzLnkpLHR9c2V0Q29vcmRpbmF0ZSh0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuZ2V0WigpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvLGwsY119fWNsYXNzIGZ7Y29uc3RydWN0b3IoKXtmLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q9MiwwPT09YXJndW1lbnRzLmxlbmd0aClmLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMik7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMiE9PXQmJjMhPT10KXRocm93IG5ldyBzKFwib25seSAyIG9yIDMgZGltZW5zaW9ucyBtYXkgYmUgc3BlY2lmaWVkXCIpO3RoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q9dH19c3RhdGljIGNvbXBhcmUodCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOnIuaXNOYU4odCk/ci5pc05hTihlKT8wOi0xOnIuaXNOYU4oZSk/MTowfWNvbXBhcmUodCxlKXtjb25zdCBuPWYuY29tcGFyZSh0LngsZS54KTtpZigwIT09bilyZXR1cm4gbjtjb25zdCBzPWYuY29tcGFyZSh0LnksZS55KTtpZigwIT09cylyZXR1cm4gcztpZih0aGlzLl9kaW1lbnNpb25zVG9UZXN0PD0yKXJldHVybiAwO3JldHVybiBmLmNvbXBhcmUodC5nZXRaKCksZS5nZXRaKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19bS5EaW1lbnNpb25hbENvbXBhcmF0b3I9ZixtLk5VTExfT1JESU5BVEU9ci5OYU4sbS5YPTAsbS5ZPTEsbS5aPTIsbS5NPTM7Y2xhc3MgeSBleHRlbmRzIG17Y29uc3RydWN0b3IoKXtzdXBlcigpLHkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG0uTlVMTF9PUkRJTkFURSl9fXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgeS5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgeS5ZOnRoaXMueT1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19Z2V0Wigpe3JldHVybiBtLk5VTExfT1JESU5BVEV9Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgeS5YOnJldHVybiB0aGlzLng7Y2FzZSB5Llk6cmV0dXJuIHRoaXMueX10aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfXNldFoodCl7dGhyb3cgbmV3IHMoXCJDb29yZGluYXRlWFkgZGltZW5zaW9uIDIgZG9lcyBub3Qgc3VwcG9ydCB6LW9yZGluYXRlXCIpfWNvcHkoKXtyZXR1cm4gbmV3IHkodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIilcIn1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC5nZXRaKCl9fXkuWD0wLHkuWT0xLHkuWj0tMSx5Lk09LTE7Y2xhc3MgeCBleHRlbmRzIG17Y29uc3RydWN0b3IoKXtzdXBlcigpLHguY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKW0uY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5fbT0wO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnkpLHRoaXMuX209dC5fbX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnkpLHRoaXMuX209dGhpcy5nZXRNKCl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbS5OVUxMX09SRElOQVRFKSx0aGlzLl9tPW59fWdldE0oKXtyZXR1cm4gdGhpcy5fbX1zZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaCh0KXtjYXNlIHguWDp0aGlzLng9ZTticmVhaztjYXNlIHguWTp0aGlzLnk9ZTticmVhaztjYXNlIHguTTp0aGlzLl9tPWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX1zZXRNKHQpe3RoaXMuX209dH1nZXRaKCl7cmV0dXJuIG0uTlVMTF9PUkRJTkFURX1nZXRPcmRpbmF0ZSh0KXtzd2l0Y2godCl7Y2FzZSB4Llg6cmV0dXJuIHRoaXMueDtjYXNlIHguWTpyZXR1cm4gdGhpcy55O2Nhc2UgeC5NOnJldHVybiB0aGlzLl9tfXRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9c2V0Wih0KXt0aHJvdyBuZXcgcyhcIkNvb3JkaW5hdGVYWSBkaW1lbnNpb24gMiBkb2VzIG5vdCBzdXBwb3J0IHotb3JkaW5hdGVcIil9Y29weSgpe3JldHVybiBuZXcgeCh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiIG09XCIrdGhpcy5nZXRNKCkrXCIpXCJ9c2V0Q29vcmRpbmF0ZSh0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuZ2V0WigpLHRoaXMuX209dC5nZXRNKCl9fXguWD0wLHguWT0xLHguWj0tMSx4Lk09MjtjbGFzcyBFIGV4dGVuZHMgbXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpbS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLl9tPTA7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBFKXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCksdGhpcy5fbT10Ll9tfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCksdGhpcy5fbT10aGlzLmdldE0oKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuKSx0aGlzLl9tPXN9fWdldE0oKXtyZXR1cm4gdGhpcy5fbX1zZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaCh0KXtjYXNlIG0uWDp0aGlzLng9ZTticmVhaztjYXNlIG0uWTp0aGlzLnk9ZTticmVhaztjYXNlIG0uWjp0aGlzLno9ZTticmVhaztjYXNlIG0uTTp0aGlzLl9tPWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX1zZXRNKHQpe3RoaXMuX209dH1nZXRPcmRpbmF0ZSh0KXtzd2l0Y2godCl7Y2FzZSBtLlg6cmV0dXJuIHRoaXMueDtjYXNlIG0uWTpyZXR1cm4gdGhpcy55O2Nhc2UgbS5aOnJldHVybiB0aGlzLmdldFooKTtjYXNlIG0uTTpyZXR1cm4gdGhpcy5nZXRNKCl9dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1jb3B5KCl7cmV0dXJuIG5ldyBFKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIsIFwiK3RoaXMuZ2V0WigpK1wiIG09XCIrdGhpcy5nZXRNKCkrXCIpXCJ9c2V0Q29vcmRpbmF0ZSh0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuZ2V0WigpLHRoaXMuX209dC5nZXRNKCl9fWZ1bmN0aW9uIEkodCxlKXtyZXR1cm4gdC5pbnRlcmZhY2VzXyYmdC5pbnRlcmZhY2VzXy5pbmRleE9mKGUpPi0xfWNsYXNzIE57YWRkKCl7fWFkZEFsbCgpe31pc0VtcHR5KCl7fWl0ZXJhdG9yKCl7fXNpemUoKXt9dG9BcnJheSgpe31yZW1vdmUoKXt9fWNsYXNzIHcgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjp3fSlbMF19fWNsYXNzIEMgZXh0ZW5kcyBOe2dldCgpe31zZXQoKXt9aXNFbXB0eSgpe319Y2xhc3MgUyBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtOb1N1Y2hFbGVtZW50RXhjZXB0aW9uOlN9KVswXX19Y2xhc3MgTCBleHRlbmRzIEN7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmFycmF5PVtdLHQgaW5zdGFuY2VvZiBOJiZ0aGlzLmFkZEFsbCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQyxOXX1lbnN1cmVDYXBhY2l0eSgpe31hZGQodCl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMuYXJyYXkucHVzaCh0KTp0aGlzLmFycmF5LnNwbGljZShhcmd1bWVudHNbMF0sMCxhcmd1bWVudHNbMV0pLCEwfWNsZWFyKCl7dGhpcy5hcnJheT1bXX1hZGRBbGwodCl7Zm9yKGNvbnN0IGUgb2YgdCl0aGlzLmFycmF5LnB1c2goZSl9c2V0KHQsZSl7Y29uc3Qgbj10aGlzLmFycmF5W3RdO3JldHVybiB0aGlzLmFycmF5W3RdPWUsbn1pdGVyYXRvcigpe3JldHVybiBuZXcgVCh0aGlzKX1nZXQodCl7aWYodDwwfHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgdztyZXR1cm4gdGhpcy5hcnJheVt0XX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Lmxlbmd0aH1zb3J0KHQpe3Q/dGhpcy5hcnJheS5zb3J0KCgoZSxuKT0+dC5jb21wYXJlKGUsbikpKTp0aGlzLmFycmF5LnNvcnQoKX1zaXplKCl7cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RofXRvQXJyYXkoKXtyZXR1cm4gdGhpcy5hcnJheS5zbGljZSgpfXJlbW92ZSh0KXtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXkubGVuZ3RoO2U8bjtlKyspaWYodGhpcy5hcnJheVtlXT09PXQpcmV0dXJuISF0aGlzLmFycmF5LnNwbGljZShlLDEpO3JldHVybiExfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIHRoaXMuYXJyYXkudmFsdWVzKCl9fWxldCBUPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYXJyYXlMaXN0PXQsdGhpcy5wb3NpdGlvbj0wfW5leHQoKXtpZih0aGlzLnBvc2l0aW9uPT09dGhpcy5hcnJheUxpc3Quc2l6ZSgpKXRocm93IG5ldyBTO3JldHVybiB0aGlzLmFycmF5TGlzdC5nZXQodGhpcy5wb3NpdGlvbisrKX1oYXNOZXh0KCl7cmV0dXJuIHRoaXMucG9zaXRpb248dGhpcy5hcnJheUxpc3Quc2l6ZSgpfXNldCh0KXtyZXR1cm4gdGhpcy5hcnJheUxpc3Quc2V0KHRoaXMucG9zaXRpb24tMSx0KX1yZW1vdmUoKXt0aGlzLmFycmF5TGlzdC5yZW1vdmUodGhpcy5hcnJheUxpc3QuZ2V0KHRoaXMucG9zaXRpb24pKX19O2NsYXNzIFIgZXh0ZW5kcyBMe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxSLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LCEwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LGUpfX1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLmdldCh0KX1hZGRBbGwoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJkkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtsZXQgZT0hMTtmb3IobGV0IG49YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXRoaXMuYWRkKG4ubmV4dCgpLHQpLGU9ITA7cmV0dXJuIGV9cmV0dXJuIHN1cGVyLmFkZEFsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2xvbmUoKXtjb25zdCB0PXN1cGVyLmNsb25lLmNhbGwodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLnNpemUoKTtlKyspdC5hZGQoZSx0aGlzLmdldChlKS5jbG9uZSgpKTtyZXR1cm4gdH10b0Nvb3JkaW5hdGVBcnJheSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnRvQXJyYXkoUi5jb29yZEFycmF5VHlwZSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXSlyZXR1cm4gdGhpcy50b0FycmF5KFIuY29vcmRBcnJheVR5cGUpO2NvbnN0IHQ9dGhpcy5zaXplKCksZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQ7bisrKWVbbl09dGhpcy5nZXQodC1uLTEpO3JldHVybiBlfX1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHN1cGVyLmFkZC5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQodCxlLCEwKSwhMH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZighYXJndW1lbnRzWzFdJiZ0aGlzLnNpemUoKT49MSl7aWYodGhpcy5nZXQodGhpcy5zaXplKCktMSkuZXF1YWxzMkQodCkpcmV0dXJuIG51bGx9c3VwZXIuYWRkLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKHQsZSksITB9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoYXJndW1lbnRzWzJdKWZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXRoaXMuYWRkKHRbbl0sZSk7ZWxzZSBmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSl0aGlzLmFkZCh0W25dLGUpO3JldHVybiEwfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIWFyZ3VtZW50c1syXSl7Y29uc3Qgbj10aGlzLnNpemUoKTtpZihuPjApe2lmKHQ+MCl7aWYodGhpcy5nZXQodC0xKS5lcXVhbHMyRChlKSlyZXR1cm4gbnVsbH1pZih0PG4pe2lmKHRoaXMuZ2V0KHQpLmVxdWFsczJEKGUpKXJldHVybiBudWxsfX19c3VwZXIuYWRkLmNhbGwodGhpcyx0LGUpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtsZXQgaT0xO24+cyYmKGk9LTEpO2ZvcihsZXQgcj1uO3IhPT1zO3IrPWkpdGhpcy5hZGQodFtyXSxlKTtyZXR1cm4hMH19Y2xvc2VSaW5nKCl7aWYodGhpcy5zaXplKCk+MCl7Y29uc3QgdD10aGlzLmdldCgwKS5jb3B5KCk7dGhpcy5hZGQodCwhMSl9fX1SLmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIFB7ZmlsdGVyKHQsZSl7fWlzRG9uZSgpe31pc0dlb21ldHJ5Q2hhbmdlZCgpe319Y2xhc3MgT3tjb25zdHJ1Y3Rvcigpe08uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbWlueD1udWxsLHRoaXMuX21heHg9bnVsbCx0aGlzLl9taW55PW51bGwsdGhpcy5fbWF4eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQueCxlLngsdC55LGUueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5pbml0KHQsZSxuLHMpfX1zdGF0aWMgaW50ZXJzZWN0cygpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbi54Pj0odC54PGUueD90Lng6ZS54KSYmbi54PD0odC54PmUueD90Lng6ZS54KSYmbi55Pj0odC55PGUueT90Lnk6ZS55KSYmbi55PD0odC55PmUueT90Lnk6ZS55KX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9TWF0aC5taW4obi54LHMueCkscj1NYXRoLm1heChuLngscy54KSxvPU1hdGgubWluKHQueCxlLngpLGw9TWF0aC5tYXgodC54LGUueCk7cmV0dXJuIShvPnIpJiYoIShsPGkpJiYoaT1NYXRoLm1pbihuLnkscy55KSxyPU1hdGgubWF4KG4ueSxzLnkpLG89TWF0aC5taW4odC55LGUueSksbD1NYXRoLm1heCh0LnksZS55KSwhKG8+cikmJiEobDxpKSkpfX1nZXRBcmVhKCl7cmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSp0aGlzLmdldEhlaWdodCgpfWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBPKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKTp0aGlzLl9tYXh4PT09ZS5nZXRNYXhYKCkmJnRoaXMuX21heHk9PT1lLmdldE1heFkoKSYmdGhpcy5fbWlueD09PWUuZ2V0TWluWCgpJiZ0aGlzLl9taW55PT09ZS5nZXRNaW5ZKCl9aW50ZXJzZWN0aW9uKHQpe2lmKHRoaXMuaXNOdWxsKCl8fHQuaXNOdWxsKCl8fCF0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIG5ldyBPO2NvbnN0IGU9dGhpcy5fbWlueD50Ll9taW54P3RoaXMuX21pbng6dC5fbWlueCxuPXRoaXMuX21pbnk+dC5fbWlueT90aGlzLl9taW55OnQuX21pbnkscz10aGlzLl9tYXh4PHQuX21heHg/dGhpcy5fbWF4eDp0Ll9tYXh4LGk9dGhpcy5fbWF4eTx0Ll9tYXh5P3RoaXMuX21heHk6dC5fbWF4eTtyZXR1cm4gbmV3IE8oZSxzLG4saSl9aXNOdWxsKCl7cmV0dXJuIHRoaXMuX21heHg8dGhpcy5fbWlueH1nZXRNYXhYKCl7cmV0dXJuIHRoaXMuX21heHh9Y292ZXJzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQueCx0LnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYodC5nZXRNaW5YKCk+PXRoaXMuX21pbngmJnQuZ2V0TWF4WCgpPD10aGlzLl9tYXh4JiZ0LmdldE1pblkoKT49dGhpcy5fbWlueSYmdC5nZXRNYXhZKCk8PXRoaXMuX21heHkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmKHQ+PXRoaXMuX21pbngmJnQ8PXRoaXMuX21heHgmJmU+PXRoaXMuX21pbnkmJmU8PXRoaXMuX21heHkpfX1pbnRlcnNlY3RzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYhKHQuX21pbng+dGhpcy5fbWF4eHx8dC5fbWF4eDx0aGlzLl9taW54fHx0Ll9taW55PnRoaXMuX21heHl8fHQuX21heHk8dGhpcy5fbWlueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQueCx0LnkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5pc051bGwoKSlyZXR1cm4hMTtpZigodC54PGUueD90Lng6ZS54KT50aGlzLl9tYXh4KXJldHVybiExO2lmKCh0Lng+ZS54P3QueDplLngpPHRoaXMuX21pbngpcmV0dXJuITE7aWYoKHQueTxlLnk/dC55OmUueSk+dGhpcy5fbWF4eSlyZXR1cm4hMTtyZXR1cm4hKCh0Lnk+ZS55P3QueTplLnkpPHRoaXMuX21pbnkpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhKHQ+dGhpcy5fbWF4eHx8dDx0aGlzLl9taW54fHxlPnRoaXMuX21heHl8fGU8dGhpcy5fbWlueSl9fX1nZXRNaW5ZKCl7cmV0dXJuIHRoaXMuX21pbnl9Z2V0RGlhbWV0ZXIoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtlKmUpfWdldE1pblgoKXtyZXR1cm4gdGhpcy5fbWlueH1leHBhbmRUb0luY2x1ZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZFRvSW5jbHVkZSh0LngsdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmlzTnVsbCgpPyh0aGlzLl9taW54PXQuZ2V0TWluWCgpLHRoaXMuX21heHg9dC5nZXRNYXhYKCksdGhpcy5fbWlueT10LmdldE1pblkoKSx0aGlzLl9tYXh5PXQuZ2V0TWF4WSgpKToodC5fbWlueDx0aGlzLl9taW54JiYodGhpcy5fbWlueD10Ll9taW54KSx0Ll9tYXh4PnRoaXMuX21heHgmJih0aGlzLl9tYXh4PXQuX21heHgpLHQuX21pbnk8dGhpcy5fbWlueSYmKHRoaXMuX21pbnk9dC5fbWlueSksdC5fbWF4eT50aGlzLl9tYXh5JiYodGhpcy5fbWF4eT10Ll9tYXh5KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaXNOdWxsKCk/KHRoaXMuX21pbng9dCx0aGlzLl9tYXh4PXQsdGhpcy5fbWlueT1lLHRoaXMuX21heHk9ZSk6KHQ8dGhpcy5fbWlueCYmKHRoaXMuX21pbng9dCksdD50aGlzLl9tYXh4JiYodGhpcy5fbWF4eD10KSxlPHRoaXMuX21pbnkmJih0aGlzLl9taW55PWUpLGU+dGhpcy5fbWF4eSYmKHRoaXMuX21heHk9ZSkpfX1taW5FeHRlbnQoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdDxlP3Q6ZX1nZXRXaWR0aCgpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5fbWF4eC10aGlzLl9taW54fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKT8wOi0xOmUuaXNOdWxsKCk/MTp0aGlzLl9taW54PGUuX21pbng/LTE6dGhpcy5fbWlueD5lLl9taW54PzE6dGhpcy5fbWlueTxlLl9taW55Py0xOnRoaXMuX21pbnk+ZS5fbWlueT8xOnRoaXMuX21heHg8ZS5fbWF4eD8tMTp0aGlzLl9tYXh4PmUuX21heHg/MTp0aGlzLl9tYXh5PGUuX21heHk/LTE6dGhpcy5fbWF4eT5lLl9tYXh5PzE6MH10cmFuc2xhdGUodCxlKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaW5pdCh0aGlzLmdldE1pblgoKSt0LHRoaXMuZ2V0TWF4WCgpK3QsdGhpcy5nZXRNaW5ZKCkrZSx0aGlzLmdldE1heFkoKStlKX1jb3B5KCl7cmV0dXJuIG5ldyBPKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCJFbnZbXCIrdGhpcy5fbWlueCtcIiA6IFwiK3RoaXMuX21heHgrXCIsIFwiK3RoaXMuX21pbnkrXCIgOiBcIit0aGlzLl9tYXh5K1wiXVwifXNldFRvTnVsbCgpe3RoaXMuX21pbng9MCx0aGlzLl9tYXh4PS0xLHRoaXMuX21pbnk9MCx0aGlzLl9tYXh5PS0xfWRpc2pvaW50KHQpe3JldHVybiEoIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpKXx8KHQuX21pbng+dGhpcy5fbWF4eHx8dC5fbWF4eDx0aGlzLl9taW54fHx0Ll9taW55PnRoaXMuX21heHl8fHQuX21heHk8dGhpcy5fbWlueSl9Z2V0SGVpZ2h0KCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLl9tYXh5LXRoaXMuX21pbnl9bWF4RXh0ZW50KCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ+ZT90OmV9ZXhwYW5kQnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRCeSh0LHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5fbWlueC09dCx0aGlzLl9tYXh4Kz10LHRoaXMuX21pbnktPWUsdGhpcy5fbWF4eSs9ZSwodGhpcy5fbWlueD50aGlzLl9tYXh4fHx0aGlzLl9taW55PnRoaXMuX21heHkpJiZ0aGlzLnNldFRvTnVsbCgpfX1jb250YWlucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY292ZXJzKHQsZSl9fWNlbnRyZSgpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6bmV3IG0oKHRoaXMuZ2V0TWluWCgpK3RoaXMuZ2V0TWF4WCgpKS8yLCh0aGlzLmdldE1pblkoKSt0aGlzLmdldE1heFkoKSkvMil9aW5pdCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuc2V0VG9OdWxsKCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWlueD10Ll9taW54LHRoaXMuX21heHg9dC5fbWF4eCx0aGlzLl9taW55PXQuX21pbnksdGhpcy5fbWF4eT10Ll9tYXh5fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodC54LGUueCx0LnksZS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0PGU/KHRoaXMuX21pbng9dCx0aGlzLl9tYXh4PWUpOih0aGlzLl9taW54PWUsdGhpcy5fbWF4eD10KSxuPHM/KHRoaXMuX21pbnk9bix0aGlzLl9tYXh5PXMpOih0aGlzLl9taW55PXMsdGhpcy5fbWF4eT1uKX19Z2V0TWF4WSgpe3JldHVybiB0aGlzLl9tYXh5fWRpc3RhbmNlKHQpe2lmKHRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gMDtsZXQgZT0wO3RoaXMuX21heHg8dC5fbWlueD9lPXQuX21pbngtdGhpcy5fbWF4eDp0aGlzLl9taW54PnQuX21heHgmJihlPXRoaXMuX21pbngtdC5fbWF4eCk7bGV0IG49MDtyZXR1cm4gdGhpcy5fbWF4eTx0Ll9taW55P249dC5fbWlueS10aGlzLl9tYXh5OnRoaXMuX21pbnk+dC5fbWF4eSYmKG49dGhpcy5fbWlueS10Ll9tYXh5KSwwPT09ZT9uOjA9PT1uP2U6TWF0aC5zcXJ0KGUqZStuKm4pfWhhc2hDb2RlKCl7bGV0IHQ9MTc7cmV0dXJuIHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21pbngpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21heHgpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21pbnkpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21heHkpLHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW28sY119fWNsYXNzIHZ7Y29uc3RydWN0b3IodCl7dGhpcy5zdHI9dH1hcHBlbmQodCl7dGhpcy5zdHIrPXR9c2V0Q2hhckF0KHQsZSl7dGhpcy5zdHI9dGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX10b1N0cmluZygpe3JldHVybiB0aGlzLnN0cn19Y2xhc3MgYntjb25zdHJ1Y3Rvcih0KXt0aGlzLnZhbHVlPXR9aW50VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX1jb21wYXJlVG8odCl7cmV0dXJuIHRoaXMudmFsdWU8dD8tMTp0aGlzLnZhbHVlPnQ/MTowfXN0YXRpYyBjb21wYXJlKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTowfXN0YXRpYyBpc05hbih0KXtyZXR1cm4gTnVtYmVyLmlzTmFOKHQpfXN0YXRpYyB2YWx1ZU9mKHQpe3JldHVybiBuZXcgYih0KX19Y2xhc3MgTXtzdGF0aWMgaXNXaGl0ZXNwYWNlKHQpe3JldHVybiB0PD0zMiYmdD49MHx8MTI3PT09dH1zdGF0aWMgdG9VcHBlckNhc2UodCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX19Y2xhc3MgRCBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtJbGxlZ2FsU3RhdGVFeGNlcHRpb246RH0pWzBdfX1jbGFzcyBBe2NvbnN0cnVjdG9yKCl7QS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9oaT0wLHRoaXMuX2xvPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07QS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLEEucGFyc2UodCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodCxlKX19c3RhdGljIGRldGVybWluYW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1szXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIEEuZGV0ZXJtaW5hbnQoQS52YWx1ZU9mKHQpLEEudmFsdWVPZihlKSxBLnZhbHVlT2YobiksQS52YWx1ZU9mKHMpKX1pZihhcmd1bWVudHNbM11pbnN0YW5jZW9mIEEmJmFyZ3VtZW50c1syXWluc3RhbmNlb2YgQSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdO3JldHVybiBhcmd1bWVudHNbMF0ubXVsdGlwbHkobikuc2VsZlN1YnRyYWN0KHQubXVsdGlwbHkoZSkpfX1zdGF0aWMgc3FyKHQpe3JldHVybiBBLnZhbHVlT2YodCkuc2VsZk11bHRpcGx5KHQpfXN0YXRpYyB2YWx1ZU9mKCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEEucGFyc2UodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7cmV0dXJuIG5ldyBBKGFyZ3VtZW50c1swXSl9fXN0YXRpYyBzcXJ0KHQpe3JldHVybiBBLnZhbHVlT2YodCkuc3FydCgpfXN0YXRpYyBwYXJzZSh0KXtsZXQgZT0wO2NvbnN0IG49dC5sZW5ndGg7Zm9yKDtNLmlzV2hpdGVzcGFjZSh0LmNoYXJBdChlKSk7KWUrKztsZXQgcz0hMTtpZihlPG4pe2NvbnN0IG49dC5jaGFyQXQoZSk7XCItXCIhPT1uJiZcIitcIiE9PW58fChlKyssXCItXCI9PT1uJiYocz0hMCkpfWNvbnN0IGk9bmV3IEE7bGV0IHI9MCxvPTAsbD0wLGE9ITE7Zm9yKDshKGU+PW4pOyl7Y29uc3Qgbj10LmNoYXJBdChlKTtpZihlKyssTS5pc0RpZ2l0KG4pKXtjb25zdCB0PW4tXCIwXCI7aS5zZWxmTXVsdGlwbHkoQS5URU4pLGkuc2VsZkFkZCh0KSxyKyt9ZWxzZXtpZihcIi5cIiE9PW4pe2lmKFwiZVwiPT09bnx8XCJFXCI9PT1uKXtjb25zdCBuPXQuc3Vic3RyaW5nKGUpO3RyeXtsPWIucGFyc2VJbnQobil9Y2F0Y2goZSl7dGhyb3cgZSBpbnN0YW5jZW9mIE51bWJlckZvcm1hdEV4Y2VwdGlvbj9uZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiSW52YWxpZCBleHBvbmVudCBcIituK1wiIGluIHN0cmluZyBcIit0KTplfWJyZWFrfXRocm93IG5ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIrbitcIicgYXQgcG9zaXRpb24gXCIrZStcIiBpbiBzdHJpbmcgXCIrdCl9bz1yLGE9ITB9fWxldCBjPWk7YXx8KG89cik7Y29uc3QgaD1yLW8tbDtpZigwPT09aCljPWk7ZWxzZSBpZihoPjApe2NvbnN0IHQ9QS5URU4ucG93KGgpO2M9aS5kaXZpZGUodCl9ZWxzZSBpZihoPDApe2NvbnN0IHQ9QS5URU4ucG93KC1oKTtjPWkubXVsdGlwbHkodCl9cmV0dXJuIHM/Yy5uZWdhdGUoKTpjfXN0YXRpYyBjcmVhdGVOYU4oKXtyZXR1cm4gbmV3IEEoci5OYU4sci5OYU4pfXN0YXRpYyBjb3B5KHQpe3JldHVybiBuZXcgQSh0KX1zdGF0aWMgbWFnbml0dWRlKHQpe2NvbnN0IGU9TWF0aC5hYnModCksbj1NYXRoLmxvZyhlKS9NYXRoLmxvZygxMCk7bGV0IHM9TWF0aC50cnVuYyhNYXRoLmZsb29yKG4pKTtyZXR1cm4gMTAqTWF0aC5wb3coMTAscyk8PWUmJihzKz0xKSxzfXN0YXRpYyBzdHJpbmdPZkNoYXIodCxlKXtjb25zdCBuPW5ldyB2O2ZvcihsZXQgcz0wO3M8ZTtzKyspbi5hcHBlbmQodCk7cmV0dXJuIG4udG9TdHJpbmcoKX1sZSh0KXtyZXR1cm4gdGhpcy5faGk8dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPD10Ll9sb31leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModCxlKXtsZXQgbj10aGlzLmFicygpLHM9QS5tYWduaXR1ZGUobi5faGkpO2NvbnN0IGk9QS5URU4ucG93KHMpO249bi5kaXZpZGUoaSksbi5ndChBLlRFTik/KG49bi5kaXZpZGUoQS5URU4pLHMrPTEpOm4ubHQoQS5PTkUpJiYobj1uLm11bHRpcGx5KEEuVEVOKSxzLT0xKTtjb25zdCByPXMrMSxvPW5ldyB2LGw9QS5NQVhfUFJJTlRfRElHSVRTLTE7Zm9yKGxldCBlPTA7ZTw9bDtlKyspe3QmJmU9PT1yJiZvLmFwcGVuZChcIi5cIik7Y29uc3Qgcz1NYXRoLnRydW5jKG4uX2hpKTtpZihzPDApYnJlYWs7bGV0IGk9ITEsYT0wO3M+OT8oaT0hMCxhPVwiOVwiKTphPVwiMFwiK3Msby5hcHBlbmQoYSksbj1uLnN1YnRyYWN0KEEudmFsdWVPZihzKSkubXVsdGlwbHkoQS5URU4pLGkmJm4uc2VsZkFkZChBLlRFTik7bGV0IGM9ITA7Y29uc3QgaD1BLm1hZ25pdHVkZShuLl9oaSk7aWYoaDwwJiZNYXRoLmFicyhoKT49bC1lJiYoYz0hMSksIWMpYnJlYWt9cmV0dXJuIGVbMF09cyxvLnRvU3RyaW5nKCl9c3FyKCl7cmV0dXJuIHRoaXMubXVsdGlwbHkodGhpcyl9ZG91YmxlVmFsdWUoKXtyZXR1cm4gdGhpcy5faGkrdGhpcy5fbG99c3VidHJhY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCh0Lm5lZ2F0ZSgpKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQoLXQpfX1lcXVhbHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG89PT10Ll9sb319aXNaZXJvKCl7cmV0dXJuIDA9PT10aGlzLl9oaSYmMD09PXRoaXMuX2xvfXNlbGZTdWJ0cmFjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtdC5faGksLXQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10LDApfX1nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCl7cmV0dXJuIHRoaXMuaXNaZXJvKCk/XCIwLjBcIjp0aGlzLmlzTmFOKCk/XCJOYU4gXCI6bnVsbH1taW4odCl7cmV0dXJuIHRoaXMubGUodCk/dGhpczp0fXNlbGZEaXZpZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHQsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGwsYz1udWxsO3JldHVybiBvPXRoaXMuX2hpL3QsbD1BLlNQTElUKm8sbj1sLW8sYz1BLlNQTElUKnQsbj1sLW4scz1vLW4saT1jLXQsYT1vKnQsaT1jLWkscj10LWksYz1uKmktYStuKnIrcyppK3MqcixsPSh0aGlzLl9oaS1hLWMrdGhpcy5fbG8tbyplKS90LGM9bytsLHRoaXMuX2hpPWMsdGhpcy5fbG89by1jK2wsdGhpc319ZHVtcCgpe3JldHVyblwiREQ8XCIrdGhpcy5faGkrXCIsIFwiK3RoaXMuX2xvK1wiPlwifWRpdmlkZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGw7cj10aGlzLl9oaS90Ll9oaSxvPUEuU1BMSVQqcixlPW8tcixhPUEuU1BMSVQqdC5faGksZT1vLWUsbj1yLWUscz1hLXQuX2hpLGw9cip0Ll9oaSxzPWEtcyxpPXQuX2hpLXMsYT1lKnMtbCtlKmkrbipzK24qaSxvPSh0aGlzLl9oaS1sLWErdGhpcy5fbG8tcip0Ll9sbykvdC5faGksYT1yK287cmV0dXJuIG5ldyBBKGEsci1hK28pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKHQpP0EuY3JlYXRlTmFOKCk6QS5jb3B5KHRoaXMpLnNlbGZEaXZpZGUodCwwKX19Z2UodCl7cmV0dXJuIHRoaXMuX2hpPnQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz49dC5fbG99cG93KHQpe2lmKDA9PT10KXJldHVybiBBLnZhbHVlT2YoMSk7bGV0IGU9bmV3IEEodGhpcyksbj1BLnZhbHVlT2YoMSkscz1NYXRoLmFicyh0KTtpZihzPjEpZm9yKDtzPjA7KXMlMj09MSYmbi5zZWxmTXVsdGlwbHkoZSkscy89MixzPjAmJihlPWUuc3FyKCkpO2Vsc2Ugbj1lO3JldHVybiB0PDA/bi5yZWNpcHJvY2FsKCk6bn1jZWlsKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBBLk5hTjtjb25zdCB0PU1hdGguY2VpbCh0aGlzLl9oaSk7bGV0IGU9MDtyZXR1cm4gdD09PXRoaXMuX2hpJiYoZT1NYXRoLmNlaWwodGhpcy5fbG8pKSxuZXcgQSh0LGUpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX2hpPGUuX2hpPy0xOnRoaXMuX2hpPmUuX2hpPzE6dGhpcy5fbG88ZS5fbG8/LTE6dGhpcy5fbG8+ZS5fbG8/MTowfXJpbnQoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIHRoaXM7cmV0dXJuIHRoaXMuYWRkKC41KS5mbG9vcigpfXNldFZhbHVlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KHQpLHRoaXN9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfX1tYXgodCl7cmV0dXJuIHRoaXMuZ2UodCk/dGhpczp0fXNxcnQoKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBBLnZhbHVlT2YoMCk7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIEEuTmFOO2NvbnN0IHQ9MS9NYXRoLnNxcnQodGhpcy5faGkpLGU9dGhpcy5faGkqdCxuPUEudmFsdWVPZihlKSxzPXRoaXMuc3VidHJhY3Qobi5zcXIoKSkuX2hpKiguNSp0KTtyZXR1cm4gbi5hZGQocyl9c2VsZkFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZBZGQodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbDtyZXR1cm4gcz10aGlzLl9oaSt0LHI9cy10aGlzLl9oaSxpPXMtcixpPXQtcisodGhpcy5faGktaSksbz1pK3RoaXMuX2xvLGU9cytvLG49bysocy1lKSx0aGlzLl9oaT1lK24sdGhpcy5fbG89bisoZS10aGlzLl9oaSksdGhpc319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbCxjPW51bGw7bz10aGlzLl9oaSt0LGk9dGhpcy5fbG8rZSxhPW8tdGhpcy5faGksYz1pLXRoaXMuX2xvLGw9by1hLHI9aS1jLGw9dC1hKyh0aGlzLl9oaS1sKSxyPWUtYysodGhpcy5fbG8tciksYT1sK2ksbj1vK2Escz1hKyhvLW4pLGE9citzO2NvbnN0IGg9bithLHU9YSsobi1oKTtyZXR1cm4gdGhpcy5faGk9aCx0aGlzLl9sbz11LHRoaXN9fXNlbGZNdWx0aXBseSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHQsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbDtvPUEuU1BMSVQqdGhpcy5faGksbj1vLXRoaXMuX2hpLGw9QS5TUExJVCp0LG49by1uLHM9dGhpcy5faGktbixpPWwtdCxvPXRoaXMuX2hpKnQsaT1sLWkscj10LWksbD1uKmktbytuKnIrcyppK3MqcisodGhpcy5faGkqZSt0aGlzLl9sbyp0KTtjb25zdCBhPW8rbDtuPW8tYTtjb25zdCBjPWwrbjtyZXR1cm4gdGhpcy5faGk9YSx0aGlzLl9sbz1jLHRoaXN9fXNlbGZTcXIoKXtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodGhpcyl9Zmxvb3IoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIEEuTmFOO2NvbnN0IHQ9TWF0aC5mbG9vcih0aGlzLl9oaSk7bGV0IGU9MDtyZXR1cm4gdD09PXRoaXMuX2hpJiYoZT1NYXRoLmZsb29yKHRoaXMuX2xvKSksbmV3IEEodCxlKX1uZWdhdGUoKXtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6bmV3IEEoLXRoaXMuX2hpLC10aGlzLl9sbyl9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBudWxsO3Rocm93IHR9fW11bHRpcGx5KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5pc05hTigpP0EuY3JlYXRlTmFOKCk6QS5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTih0KT9BLmNyZWF0ZU5hTigpOkEuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCwwKX19aXNOYU4oKXtyZXR1cm4gci5pc05hTih0aGlzLl9oaSl9aW50VmFsdWUoKXtyZXR1cm4gTWF0aC50cnVuYyh0aGlzLl9oaSl9dG9TdHJpbmcoKXtjb25zdCB0PUEubWFnbml0dWRlKHRoaXMuX2hpKTtyZXR1cm4gdD49LTMmJnQ8PTIwP3RoaXMudG9TdGFuZGFyZE5vdGF0aW9uKCk6dGhpcy50b1NjaU5vdGF0aW9uKCl9dG9TdGFuZGFyZE5vdGF0aW9uKCl7Y29uc3QgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITAsZSkscz1lWzBdKzE7bGV0IGk9bjtpZihcIi5cIj09PW4uY2hhckF0KDApKWk9XCIwXCIrbjtlbHNlIGlmKHM8MClpPVwiMC5cIitBLnN0cmluZ09mQ2hhcihcIjBcIiwtcykrbjtlbHNlIGlmKC0xPT09bi5pbmRleE9mKFwiLlwiKSl7Y29uc3QgdD1zLW4ubGVuZ3RoO2k9bitBLnN0cmluZ09mQ2hhcihcIjBcIix0KStcIi4wXCJ9cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK2k6aX1yZWNpcHJvY2FsKCl7bGV0IHQ9bnVsbCxlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGw7aT0xL3RoaXMuX2hpLHI9QS5TUExJVCppLHQ9ci1pLGw9QS5TUExJVCp0aGlzLl9oaSx0PXItdCxlPWktdCxuPWwtdGhpcy5faGksbz1pKnRoaXMuX2hpLG49bC1uLHM9dGhpcy5faGktbixsPXQqbi1vK3QqcytlKm4rZSpzLHI9KDEtby1sLWkqdGhpcy5fbG8pL3RoaXMuX2hpO2NvbnN0IGE9aStyO3JldHVybiBuZXcgQShhLGktYStyKX10b1NjaU5vdGF0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gQS5TQ0lfTk9UX1pFUk87Y29uc3QgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITEsZSkscz1BLlNDSV9OT1RfRVhQT05FTlRfQ0hBUitlWzBdO2lmKFwiMFwiPT09bi5jaGFyQXQoMCkpdGhyb3cgbmV3IEQoXCJGb3VuZCBsZWFkaW5nIHplcm86IFwiK24pO2xldCBpPVwiXCI7bi5sZW5ndGg+MSYmKGk9bi5zdWJzdHJpbmcoMSkpO2NvbnN0IHI9bi5jaGFyQXQoMCkrXCIuXCIraTtyZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIrcitzOnIrc31hYnMoKXtyZXR1cm4gdGhpcy5pc05hTigpP0EuTmFOOnRoaXMuaXNOZWdhdGl2ZSgpP3RoaXMubmVnYXRlKCk6bmV3IEEodGhpcyl9aXNQb3NpdGl2ZSgpe3JldHVybiB0aGlzLl9oaT4wfHwwPT09dGhpcy5faGkmJnRoaXMuX2xvPjB9bHQodCl7cmV0dXJuIHRoaXMuX2hpPHQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbzx0Ll9sb31hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBBLmNvcHkodGhpcykuc2VsZkFkZCh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gQS5jb3B5KHRoaXMpLnNlbGZBZGQodCl9fWluaXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faGk9dCx0aGlzLl9sbz0wfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9oaT10Ll9oaSx0aGlzLl9sbz10Ll9sb319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faGk9dCx0aGlzLl9sbz1lfX1ndCh0KXtyZXR1cm4gdGhpcy5faGk+dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPnQuX2xvfWlzTmVnYXRpdmUoKXtyZXR1cm4gdGhpcy5faGk8MHx8MD09PXRoaXMuX2hpJiZ0aGlzLl9sbzwwfXRydW5jKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9BLk5hTjp0aGlzLmlzUG9zaXRpdmUoKT90aGlzLmZsb29yKCk6dGhpcy5jZWlsKCl9c2lnbnVtKCl7cmV0dXJuIHRoaXMuX2hpPjA/MTp0aGlzLl9oaTwwPy0xOnRoaXMuX2xvPjA/MTp0aGlzLl9sbzwwPy0xOjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2MsbyxsXX19QS5QST1uZXcgQSgzLjE0MTU5MjY1MzU4OTc5MywxMjI0NjQ2Nzk5MTQ3MzUzMmUtMzIpLEEuVFdPX1BJPW5ldyBBKDYuMjgzMTg1MzA3MTc5NTg2LDI0NDkyOTM1OTgyOTQ3MDY0ZS0zMiksQS5QSV8yPW5ldyBBKDEuNTcwNzk2MzI2Nzk0ODk2Niw2MTIzMjMzOTk1NzM2NzY2ZS0zMiksQS5FPW5ldyBBKDIuNzE4MjgxODI4NDU5MDQ1LDE0NDU2NDY4OTE3MjkyNTAyZS0zMiksQS5OYU49bmV3IEEoci5OYU4sci5OYU4pLEEuRVBTPTEyMzI1OTUxNjQ0MDc4M2UtNDYsQS5TUExJVD0xMzQyMTc3MjksQS5NQVhfUFJJTlRfRElHSVRTPTMyLEEuVEVOPUEudmFsdWVPZigxMCksQS5PTkU9QS52YWx1ZU9mKDEpLEEuU0NJX05PVF9FWFBPTkVOVF9DSEFSPVwiRVwiLEEuU0NJX05PVF9aRVJPPVwiMC4wRTBcIjtjbGFzcyBGe3N0YXRpYyBvcmllbnRhdGlvbkluZGV4KHQsZSxuKXtjb25zdCBzPUYub3JpZW50YXRpb25JbmRleEZpbHRlcih0LGUsbik7aWYoczw9MSlyZXR1cm4gcztjb25zdCBpPUEudmFsdWVPZihlLngpLnNlbGZBZGQoLXQueCkscj1BLnZhbHVlT2YoZS55KS5zZWxmQWRkKC10LnkpLG89QS52YWx1ZU9mKG4ueCkuc2VsZkFkZCgtZS54KSxsPUEudmFsdWVPZihuLnkpLnNlbGZBZGQoLWUueSk7cmV0dXJuIGkuc2VsZk11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChyLnNlbGZNdWx0aXBseShvKSkuc2lnbnVtKCl9c3RhdGljIHNpZ25PZkRldDJ4Migpe2lmKGFyZ3VtZW50c1szXWluc3RhbmNlb2YgQSYmYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM107cmV0dXJuIGFyZ3VtZW50c1swXS5tdWx0aXBseShuKS5zZWxmU3VidHJhY3QodC5tdWx0aXBseShlKSkuc2lnbnVtKCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1szXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1BLnZhbHVlT2YodCkscj1BLnZhbHVlT2YoZSksbz1BLnZhbHVlT2YobiksbD1BLnZhbHVlT2Yocyk7cmV0dXJuIGkubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHIubXVsdGlwbHkobykpLnNpZ251bSgpfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9bmV3IEEodC55KS5zZWxmU3VidHJhY3QoZS55KSxvPW5ldyBBKGUueCkuc2VsZlN1YnRyYWN0KHQueCksbD1uZXcgQSh0LngpLnNlbGZNdWx0aXBseShlLnkpLnNlbGZTdWJ0cmFjdChuZXcgQShlLngpLnNlbGZNdWx0aXBseSh0LnkpKSxhPW5ldyBBKG4ueSkuc2VsZlN1YnRyYWN0KHMueSksYz1uZXcgQShzLngpLnNlbGZTdWJ0cmFjdChuLngpLGg9bmV3IEEobi54KS5zZWxmTXVsdGlwbHkocy55KS5zZWxmU3VidHJhY3QobmV3IEEocy54KS5zZWxmTXVsdGlwbHkobi55KSksdT1vLm11bHRpcGx5KGgpLnNlbGZTdWJ0cmFjdChjLm11bHRpcGx5KGwpKSxnPWEubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KGkubXVsdGlwbHkoaCkpLGQ9aS5tdWx0aXBseShjKS5zZWxmU3VidHJhY3QoYS5tdWx0aXBseShvKSksXz11LnNlbGZEaXZpZGUoZCkuZG91YmxlVmFsdWUoKSxwPWcuc2VsZkRpdmlkZShkKS5kb3VibGVWYWx1ZSgpO3JldHVybiByLmlzTmFOKF8pfHxyLmlzSW5maW5pdGUoXyl8fHIuaXNOYU4ocCl8fHIuaXNJbmZpbml0ZShwKT9udWxsOm5ldyBtKF8scCl9c3RhdGljIG9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pe2xldCBzPW51bGw7Y29uc3QgaT0odC54LW4ueCkqKGUueS1uLnkpLHI9KHQueS1uLnkpKihlLngtbi54KSxvPWktcjtpZihpPjApe2lmKHI8PTApcmV0dXJuIEYuc2lnbnVtKG8pO3M9aStyfWVsc2V7aWYoIShpPDApKXJldHVybiBGLnNpZ251bShvKTtpZihyPj0wKXJldHVybiBGLnNpZ251bShvKTtzPS1pLXJ9Y29uc3QgbD1GLkRQX1NBRkVfRVBTSUxPTipzO3JldHVybiBvPj1sfHwtbz49bD9GLnNpZ251bShvKToyfXN0YXRpYyBzaWdudW0odCl7cmV0dXJuIHQ+MD8xOnQ8MD8tMTowfX1GLkRQX1NBRkVfRVBTSUxPTj0xZS0xNTtjbGFzcyBHe2dldE0odCl7aWYodGhpcy5oYXNNKCkpe2NvbnN0IGU9dGhpcy5nZXREaW1lbnNpb24oKS10aGlzLmdldE1lYXN1cmVzKCk7cmV0dXJuIHRoaXMuZ2V0T3JkaW5hdGUodCxlKX1yZXR1cm4gci5OYU59c2V0T3JkaW5hdGUodCxlLG4pe31nZXRaKHQpe3JldHVybiB0aGlzLmhhc1ooKT90aGlzLmdldE9yZGluYXRlKHQsMik6ci5OYU59c2l6ZSgpe31nZXRPcmRpbmF0ZSh0LGUpe31nZXRDb29yZGluYXRlKCl7fWdldENvb3JkaW5hdGVDb3B5KHQpe31jcmVhdGVDb29yZGluYXRlKCl7fWdldERpbWVuc2lvbigpe31oYXNNKCl7cmV0dXJuIHRoaXMuZ2V0TWVhc3VyZXMoKT4wfWdldFgodCl7fWhhc1ooKXtyZXR1cm4gdGhpcy5nZXREaW1lbnNpb24oKS10aGlzLmdldE1lYXN1cmVzKCk+Mn1nZXRNZWFzdXJlcygpe3JldHVybiAwfWV4cGFuZEVudmVsb3BlKHQpe31jb3B5KCl7fWdldFkodCl7fXRvQ29vcmRpbmF0ZUFycmF5KCl7fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19Ry5YPTAsRy5ZPTEsRy5aPTIsRy5NPTM7Y2xhc3MgcXtzdGF0aWMgaW5kZXgodCxlLG4pe3JldHVybiBGLm9yaWVudGF0aW9uSW5kZXgodCxlLG4pfXN0YXRpYyBpc0NDVygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5sZW5ndGgtMTtpZihlPDMpdGhyb3cgbmV3IHMoXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtsZXQgbj10WzBdLGk9MDtmb3IobGV0IHM9MTtzPD1lO3MrKyl7Y29uc3QgZT10W3NdO2UueT5uLnkmJihuPWUsaT1zKX1sZXQgcj1pO2Rve3ItPTEscjwwJiYocj1lKX13aGlsZSh0W3JdLmVxdWFsczJEKG4pJiZyIT09aSk7bGV0IG89aTtkb3tvPShvKzEpJWV9d2hpbGUodFtvXS5lcXVhbHMyRChuKSYmbyE9PWkpO2NvbnN0IGw9dFtyXSxhPXRbb107aWYobC5lcXVhbHMyRChuKXx8YS5lcXVhbHMyRChuKXx8bC5lcXVhbHMyRChhKSlyZXR1cm4hMTtjb25zdCBjPXEuaW5kZXgobCxuLGEpO2xldCBoPW51bGw7cmV0dXJuIGg9MD09PWM/bC54PmEueDpjPjAsaH1pZihJKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKS0xO2lmKGU8Myl0aHJvdyBuZXcgcyhcIlJpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkXCIpO2xldCBuPXQuZ2V0Q29vcmRpbmF0ZSgwKSxpPTA7Zm9yKGxldCBzPTE7czw9ZTtzKyspe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKHMpO2UueT5uLnkmJihuPWUsaT1zKX1sZXQgcj1udWxsLG89aTtkb3tvLT0xLG88MCYmKG89ZSkscj10LmdldENvb3JkaW5hdGUobyl9d2hpbGUoci5lcXVhbHMyRChuKSYmbyE9PWkpO2xldCBsPW51bGwsYT1pO2Rve2E9KGErMSklZSxsPXQuZ2V0Q29vcmRpbmF0ZShhKX13aGlsZShsLmVxdWFsczJEKG4pJiZhIT09aSk7aWYoci5lcXVhbHMyRChuKXx8bC5lcXVhbHMyRChuKXx8ci5lcXVhbHMyRChsKSlyZXR1cm4hMTtjb25zdCBjPXEuaW5kZXgocixuLGwpO2xldCBoPW51bGw7cmV0dXJuIGg9MD09PWM/ci54PmwueDpjPjAsaH19fXEuQ0xPQ0tXSVNFPS0xLHEuUklHSFQ9cS5DTE9DS1dJU0UscS5DT1VOVEVSQ0xPQ0tXSVNFPTEscS5MRUZUPXEuQ09VTlRFUkNMT0NLV0lTRSxxLkNPTExJTkVBUj0wLHEuU1RSQUlHSFQ9cS5DT0xMSU5FQVI7Y2xhc3MgQntzdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9dC54PGUueD90Lng6ZS54LG89dC55PGUueT90Lnk6ZS55LGw9dC54PmUueD90Lng6ZS54LGE9dC55PmUueT90Lnk6ZS55LGM9bi54PHMueD9uLng6cy54LGg9bi55PHMueT9uLnk6cy55LHU9bi54PnMueD9uLng6cy54LGc9bi55PnMueT9uLnk6cy55LGQ9KChpPmM/aTpjKSsobDx1P2w6dSkpLzIsXz0oKG8+aD9vOmgpKyhhPGc/YTpnKSkvMixwPXQueC1kLGY9dC55LV8seT1lLngtZCx4PWUueS1fLEU9bi54LWQsST1uLnktXyxOPXMueC1kLHc9cy55LV8sQz1mLXgsUz15LXAsTD1wKngteSpmLFQ9SS13LFI9Ti1FLFA9RSp3LU4qSSxPPUMqUi1UKlMsdj0oUypQLVIqTCkvTyxiPShUKkwtQypQKS9PO3JldHVybiByLmlzTmFOKHYpfHxyLmlzSW5maW5pdGUodil8fHIuaXNOYU4oYil8fHIuaXNJbmZpbml0ZShiKT9udWxsOm5ldyBtKHYrZCxiK18pfX1jbGFzcyBZe3N0YXRpYyBhcnJheWNvcHkodCxlLG4scyxpKXtsZXQgcj0wO2ZvcihsZXQgbz1lO288ZStpO28rKyluW3Mrcl09dFtvXSxyKyt9c3RhdGljIGdldFByb3BlcnR5KHQpe3JldHVybntcImxpbmUuc2VwYXJhdG9yXCI6XCJcXG5cIn1bdF19fWNsYXNzIFZ7c3RhdGljIGxvZzEwKHQpe2NvbnN0IGU9TWF0aC5sb2codCk7cmV0dXJuIHIuaXNJbmZpbml0ZShlKXx8ci5pc05hTihlKT9lOmUvVi5MT0dfMTB9c3RhdGljIG1pbih0LGUsbixzKXtsZXQgaT10O3JldHVybiBlPGkmJihpPWUpLG48aSYmKGk9biksczxpJiYoaT1zKSxpfXN0YXRpYyBjbGFtcCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0PGU/ZTp0Pm4/bjp0fWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0PGU/ZTp0Pm4/bjp0fX1zdGF0aWMgd3JhcCh0LGUpe3JldHVybiB0PDA/ZS0gLXQlZTp0JWV9c3RhdGljIG1heCgpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXTtsZXQgbj1hcmd1bWVudHNbMF07cmV0dXJuIHQ+biYmKG49dCksZT5uJiYobj1lKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXTtsZXQgcz1hcmd1bWVudHNbMF07cmV0dXJuIHQ+cyYmKHM9dCksZT5zJiYocz1lKSxuPnMmJihzPW4pLHN9fXN0YXRpYyBhdmVyYWdlKHQsZSl7cmV0dXJuKHQrZSkvMn19Vi5MT0dfMTA9TWF0aC5sb2coMTApO2NsYXNzIHp7c3RhdGljIHNlZ21lbnRUb1NlZ21lbnQodCxlLG4scyl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIHoucG9pbnRUb1NlZ21lbnQodCxuLHMpO2lmKG4uZXF1YWxzKHMpKXJldHVybiB6LnBvaW50VG9TZWdtZW50KHMsdCxlKTtsZXQgaT0hMTtpZihPLmludGVyc2VjdHModCxlLG4scykpe2NvbnN0IHI9KGUueC10LngpKihzLnktbi55KS0oZS55LXQueSkqKHMueC1uLngpO2lmKDA9PT1yKWk9ITA7ZWxzZXtjb25zdCBvPSh0Lnktbi55KSoocy54LW4ueCktKHQueC1uLngpKihzLnktbi55KSxsPSgodC55LW4ueSkqKGUueC10LngpLSh0Lngtbi54KSooZS55LXQueSkpL3IsYT1vL3I7KGE8MHx8YT4xfHxsPDB8fGw+MSkmJihpPSEwKX19ZWxzZSBpPSEwO3JldHVybiBpP1YubWluKHoucG9pbnRUb1NlZ21lbnQodCxuLHMpLHoucG9pbnRUb1NlZ21lbnQoZSxuLHMpLHoucG9pbnRUb1NlZ21lbnQobix0LGUpLHoucG9pbnRUb1NlZ21lbnQocyx0LGUpKTowfXN0YXRpYyBwb2ludFRvU2VnbWVudCh0LGUsbil7aWYoZS54PT09bi54JiZlLnk9PT1uLnkpcmV0dXJuIHQuZGlzdGFuY2UoZSk7Y29uc3Qgcz0obi54LWUueCkqKG4ueC1lLngpKyhuLnktZS55KSoobi55LWUueSksaT0oKHQueC1lLngpKihuLngtZS54KSsodC55LWUueSkqKG4ueS1lLnkpKS9zO2lmKGk8PTApcmV0dXJuIHQuZGlzdGFuY2UoZSk7aWYoaT49MSlyZXR1cm4gdC5kaXN0YW5jZShuKTtjb25zdCByPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb0xpbmVQZXJwZW5kaWN1bGFyKHQsZSxuKXtjb25zdCBzPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxpPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKGkpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb1NlZ21lbnRTdHJpbmcodCxlKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IHMoXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2xldCBuPXQuZGlzdGFuY2UoZVswXSk7Zm9yKGxldCBzPTA7czxlLmxlbmd0aC0xO3MrKyl7Y29uc3QgaT16LnBvaW50VG9TZWdtZW50KHQsZVtzXSxlW3MrMV0pO2k8biYmKG49aSl9cmV0dXJuIG59fWNsYXNzIFh7Y3JlYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheXx8SShhcmd1bWVudHNbMF0sRyk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY3JlYXRlKHQsZSl9fX1jbGFzcyBre2ZpbHRlcih0KXt9fWNsYXNzIFV7Y29uc3RydWN0b3IoKXtVLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNHZW9tZXRyeUNvbGxlY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRUeXBlQ29kZSgpPT09VS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT059Z2V0RmFjdG9yeSgpe3JldHVybiB0aGlzLl9mYWN0b3J5fWdldEdlb21ldHJ5Tih0KXtyZXR1cm4gdGhpc31nZXRBcmVhKCl7cmV0dXJuIDB9aXNSZWN0YW5nbGUoKXtyZXR1cm4hMX1lcXVhbHNFeGFjdCh0KXtyZXR1cm4gdGhpcz09PXR8fHRoaXMuZXF1YWxzRXhhY3QodCwwKX1nZW9tZXRyeUNoYW5nZWQoKXt0aGlzLmFwcGx5KFUuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyKX1nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKXt0aGlzLl9lbnZlbG9wZT1udWxsfWVxdWFsc05vcm0odCl7cmV0dXJuIG51bGwhPT10JiZ0aGlzLm5vcm0oKS5lcXVhbHNFeGFjdCh0Lm5vcm0oKSl9Z2V0TGVuZ3RoKCl7cmV0dXJuIDB9Z2V0TnVtR2VvbWV0cmllcygpe3JldHVybiAxfWNvbXBhcmVUbygpe2xldCB0O2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdD1lLHRoaXMuZ2V0VHlwZUNvZGUoKSE9PXQuZ2V0VHlwZUNvZGUoKT90aGlzLmdldFR5cGVDb2RlKCktdC5nZXRUeXBlQ29kZSgpOnRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOnQuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MoZSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0PWUsdGhpcy5nZXRUeXBlQ29kZSgpIT09dC5nZXRUeXBlQ29kZSgpP3RoaXMuZ2V0VHlwZUNvZGUoKS10LmdldFR5cGVDb2RlKCk6dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6dC5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhlLG4pfX1nZXRVc2VyRGF0YSgpe3JldHVybiB0aGlzLl91c2VyRGF0YX1nZXRTUklEKCl7cmV0dXJuIHRoaXMuX1NSSUR9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeSh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9c3RhdGljIGNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpe2lmKHQuZ2V0VHlwZUNvZGUoKT09PVUuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OKXRocm93IG5ldyBzKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpfWVxdWFsKHQsZSxuKXtyZXR1cm4gMD09PW4/dC5lcXVhbHMoZSk6dC5kaXN0YW5jZShlKTw9bn1ub3JtKCl7Y29uc3QgdD10aGlzLmNvcHkoKTtyZXR1cm4gdC5ub3JtYWxpemUoKSx0fXJldmVyc2UoKXtjb25zdCB0PXRoaXMucmV2ZXJzZUludGVybmFsKCk7cmV0dXJuIG51bGwhPXRoaXMuZW52ZWxvcGUmJih0LmVudmVsb3BlPXRoaXMuZW52ZWxvcGUuY29weSgpKSx0LnNldFNSSUQodGhpcy5nZXRTUklEKCkpLHR9Y29weSgpe2NvbnN0IHQ9dGhpcy5jb3B5SW50ZXJuYWwoKTtyZXR1cm4gdC5lbnZlbG9wZT1udWxsPT10aGlzLl9lbnZlbG9wZT9udWxsOnRoaXMuX2VudmVsb3BlLmNvcHkoKSx0Ll9TUklEPXRoaXMuX1NSSUQsdC5fdXNlckRhdGE9dGhpcy5fdXNlckRhdGEsdH1nZXRQcmVjaXNpb25Nb2RlbCgpe3JldHVybiB0aGlzLl9mYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCl9Z2V0RW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiBudWxsPT09dGhpcy5fZW52ZWxvcGUmJih0aGlzLl9lbnZlbG9wZT10aGlzLmNvbXB1dGVFbnZlbG9wZUludGVybmFsKCkpLG5ldyBPKHRoaXMuX2VudmVsb3BlKX1zZXRTUklEKHQpe3RoaXMuX1NSSUQ9dH1zZXRVc2VyRGF0YSh0KXt0aGlzLl91c2VyRGF0YT10fWNvbXBhcmUodCxlKXtjb25zdCBuPXQuaXRlcmF0b3IoKSxzPWUuaXRlcmF0b3IoKTtmb3IoO24uaGFzTmV4dCgpJiZzLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCksZT1zLm5leHQoKSxpPXQuY29tcGFyZVRvKGUpO2lmKDAhPT1pKXJldHVybiBpfXJldHVybiBuLmhhc05leHQoKT8xOnMuaGFzTmV4dCgpPy0xOjB9aGFzaENvZGUoKXtyZXR1cm4gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuaGFzaENvZGUoKX1pc0VxdWl2YWxlbnRDbGFzcyh0KXtyZXR1cm4gdGhpcy5nZXRUeXBlQ29kZSgpPT10LmdldFR5cGVDb2RlKCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2wsbyxjXX1nZXRDbGFzcygpe3JldHVybiBVfXN0YXRpYyBoYXNOb25FbXB0eUVsZW1lbnRzKHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCF0W2VdLmlzRW1wdHkoKSlyZXR1cm4hMDtyZXR1cm4hMX1zdGF0aWMgaGFzTnVsbEVsZW1lbnRzKHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKG51bGw9PT10W2VdKXJldHVybiEwO3JldHVybiExfX1VLmNvbnN0cnVjdG9yXz1mdW5jdGlvbih0KXt0JiYodGhpcy5fZW52ZWxvcGU9bnVsbCx0aGlzLl91c2VyRGF0YT1udWxsLHRoaXMuX2ZhY3Rvcnk9dCx0aGlzLl9TUklEPXQuZ2V0U1JJRCgpKX0sVS5UWVBFQ09ERV9QT0lOVD0wLFUuVFlQRUNPREVfTVVMVElQT0lOVD0xLFUuVFlQRUNPREVfTElORVNUUklORz0yLFUuVFlQRUNPREVfTElORUFSUklORz0zLFUuVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HPTQsVS5UWVBFQ09ERV9QT0xZR09OPTUsVS5UWVBFQ09ERV9NVUxUSVBPTFlHT049NixVLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTj03LFUuVFlQRU5BTUVfUE9JTlQ9XCJQb2ludFwiLFUuVFlQRU5BTUVfTVVMVElQT0lOVD1cIk11bHRpUG9pbnRcIixVLlRZUEVOQU1FX0xJTkVTVFJJTkc9XCJMaW5lU3RyaW5nXCIsVS5UWVBFTkFNRV9MSU5FQVJSSU5HPVwiTGluZWFyUmluZ1wiLFUuVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HPVwiTXVsdGlMaW5lU3RyaW5nXCIsVS5UWVBFTkFNRV9QT0xZR09OPVwiUG9seWdvblwiLFUuVFlQRU5BTUVfTVVMVElQT0xZR09OPVwiTXVsdGlQb2x5Z29uXCIsVS5UWVBFTkFNRV9HRU9NRVRSWUNPTExFQ1RJT049XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixVLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcj17Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfSxmaWx0ZXIodCl7dC5nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKX19O2NsYXNzIEh7ZmlsdGVyKHQpe319Y2xhc3MgV3tzdGF0aWMgb2ZMaW5lKHQpe2NvbnN0IGU9dC5zaXplKCk7aWYoZTw9MSlyZXR1cm4gMDtsZXQgbj0wO2NvbnN0IHM9bmV3IG07dC5nZXRDb29yZGluYXRlKDAscyk7bGV0IGk9cy54LHI9cy55O2ZvcihsZXQgbz0xO288ZTtvKyspe3QuZ2V0Q29vcmRpbmF0ZShvLHMpO2NvbnN0IGU9cy54LGw9cy55LGE9ZS1pLGM9bC1yO24rPU1hdGguc3FydChhKmErYypjKSxpPWUscj1sfXJldHVybiBufX1jbGFzcyBae31jbGFzcyBqe3N0YXRpYyBjb3B5Q29vcmQodCxlLG4scyl7Y29uc3QgaT1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLG4uZ2V0RGltZW5zaW9uKCkpO2ZvcihsZXQgcj0wO3I8aTtyKyspbi5zZXRPcmRpbmF0ZShzLHIsdC5nZXRPcmRpbmF0ZShlLHIpKX1zdGF0aWMgaXNSaW5nKHQpe2NvbnN0IGU9dC5zaXplKCk7cmV0dXJuIDA9PT1lfHwhKGU8PTMpJiYodC5nZXRPcmRpbmF0ZSgwLEcuWCk9PT10LmdldE9yZGluYXRlKGUtMSxHLlgpJiZ0LmdldE9yZGluYXRlKDAsRy5ZKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEcuWSkpfXN0YXRpYyBzY3JvbGwoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sRykmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ai5zY3JvbGwodCxlLGouaXNSaW5nKHQpKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEcpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ai5pbmRleE9mKGUsdCk7aWYobjw9MClyZXR1cm4gbnVsbDtqLnNjcm9sbCh0LG4pfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPD0wKXJldHVybiBudWxsO2NvbnN0IHM9dC5jb3B5KCksaT1uP3Quc2l6ZSgpLTE6dC5zaXplKCk7Zm9yKGxldCBuPTA7bjxpO24rKylmb3IobGV0IHI9MDtyPHQuZ2V0RGltZW5zaW9uKCk7cisrKXQuc2V0T3JkaW5hdGUobixyLHMuZ2V0T3JkaW5hdGUoKGUrbiklaSxyKSk7aWYobilmb3IobGV0IGU9MDtlPHQuZ2V0RGltZW5zaW9uKCk7ZSsrKXQuc2V0T3JkaW5hdGUoaSxlLHQuZ2V0T3JkaW5hdGUoMCxlKSl9fXN0YXRpYyBpc0VxdWFsKHQsZSl7Y29uc3Qgbj10LnNpemUoKTtpZihuIT09ZS5zaXplKCkpcmV0dXJuITE7Y29uc3Qgcz1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpO2ZvcihsZXQgaT0wO2k8bjtpKyspZm9yKGxldCBuPTA7bjxzO24rKyl7Y29uc3Qgcz10LmdldE9yZGluYXRlKGksbiksbz1lLmdldE9yZGluYXRlKGksbik7aWYodC5nZXRPcmRpbmF0ZShpLG4pIT09ZS5nZXRPcmRpbmF0ZShpLG4pJiYoIXIuaXNOYU4ocyl8fCFyLmlzTmFOKG8pKSlyZXR1cm4hMX1yZXR1cm4hMH1zdGF0aWMgbWluQ29vcmRpbmF0ZUluZGV4KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBqLm1pbkNvb3JkaW5hdGVJbmRleCh0LDAsdC5zaXplKCktMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdO2xldCBuPS0xLHM9bnVsbDtmb3IobGV0IGk9YXJndW1lbnRzWzFdO2k8PWU7aSsrKXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZShpKTsobnVsbD09PXN8fHMuY29tcGFyZVRvKGUpPjApJiYocz1lLG49aSl9cmV0dXJuIG59fXN0YXRpYyBleHRlbmQodCxlLG4pe2NvbnN0IHM9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxpPWUuc2l6ZSgpO2lmKGouY29weShlLDAscywwLGkpLGk+MClmb3IobGV0IHQ9aTt0PG47dCsrKWouY29weShlLGktMSxzLHQsMSk7cmV0dXJuIHN9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10LnNpemUoKS0xLG49TWF0aC50cnVuYyhlLzIpO2ZvcihsZXQgcz0wO3M8PW47cysrKWouc3dhcCh0LHMsZS1zKX1zdGF0aWMgc3dhcCh0LGUsbil7aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKGxldCBzPTA7czx0LmdldERpbWVuc2lvbigpO3MrKyl7Y29uc3QgaT10LmdldE9yZGluYXRlKGUscyk7dC5zZXRPcmRpbmF0ZShlLHMsdC5nZXRPcmRpbmF0ZShuLHMpKSx0LnNldE9yZGluYXRlKG4scyxpKX19c3RhdGljIGNvcHkodCxlLG4scyxpKXtmb3IobGV0IHI9MDtyPGk7cisrKWouY29weUNvb3JkKHQsZStyLG4scytyKX1zdGF0aWMgZW5zdXJlVmFsaWRSaW5nKHQsZSl7Y29uc3Qgbj1lLnNpemUoKTtpZigwPT09bilyZXR1cm4gZTtpZihuPD0zKXJldHVybiBqLmNyZWF0ZUNsb3NlZFJpbmcodCxlLDQpO3JldHVybiBlLmdldE9yZGluYXRlKDAsRy5YKT09PWUuZ2V0T3JkaW5hdGUobi0xLEcuWCkmJmUuZ2V0T3JkaW5hdGUoMCxHLlkpPT09ZS5nZXRPcmRpbmF0ZShuLTEsRy5ZKT9lOmouY3JlYXRlQ2xvc2VkUmluZyh0LGUsbisxKX1zdGF0aWMgaW5kZXhPZih0LGUpe2ZvcihsZXQgbj0wO248ZS5zaXplKCk7bisrKWlmKHQueD09PWUuZ2V0T3JkaW5hdGUobixHLlgpJiZ0Lnk9PT1lLmdldE9yZGluYXRlKG4sRy5ZKSlyZXR1cm4gbjtyZXR1cm4tMX1zdGF0aWMgY3JlYXRlQ2xvc2VkUmluZyh0LGUsbil7Y29uc3Qgcz10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLGk9ZS5zaXplKCk7ai5jb3B5KGUsMCxzLDAsaSk7Zm9yKGxldCB0PWk7dDxuO3QrKylqLmNvcHkoZSwwLHMsdCwxKTtyZXR1cm4gc31zdGF0aWMgbWluQ29vcmRpbmF0ZSh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZShuKTsobnVsbD09PWV8fGUuY29tcGFyZVRvKHMpPjApJiYoZT1zKX1yZXR1cm4gZX19Y2xhc3MgSyBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjpLfSlbMF19fWNsYXNzIFF7c3RhdGljIHRvRGltZW5zaW9uU3ltYm9sKHQpe3N3aXRjaCh0KXtjYXNlIFEuRkFMU0U6cmV0dXJuIFEuU1lNX0ZBTFNFO2Nhc2UgUS5UUlVFOnJldHVybiBRLlNZTV9UUlVFO2Nhc2UgUS5ET05UQ0FSRTpyZXR1cm4gUS5TWU1fRE9OVENBUkU7Y2FzZSBRLlA6cmV0dXJuIFEuU1lNX1A7Y2FzZSBRLkw6cmV0dXJuIFEuU1lNX0w7Y2FzZSBRLkE6cmV0dXJuIFEuU1lNX0F9dGhyb3cgbmV3IHMoXCJVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogXCIrdCl9c3RhdGljIHRvRGltZW5zaW9uVmFsdWUodCl7c3dpdGNoKE0udG9VcHBlckNhc2UodCkpe2Nhc2UgUS5TWU1fRkFMU0U6cmV0dXJuIFEuRkFMU0U7Y2FzZSBRLlNZTV9UUlVFOnJldHVybiBRLlRSVUU7Y2FzZSBRLlNZTV9ET05UQ0FSRTpyZXR1cm4gUS5ET05UQ0FSRTtjYXNlIFEuU1lNX1A6cmV0dXJuIFEuUDtjYXNlIFEuU1lNX0w6cmV0dXJuIFEuTDtjYXNlIFEuU1lNX0E6cmV0dXJuIFEuQX10aHJvdyBuZXcgcyhcIlVua25vd24gZGltZW5zaW9uIHN5bWJvbDogXCIrdCl9fVEuUD0wLFEuTD0xLFEuQT0yLFEuRkFMU0U9LTEsUS5UUlVFPS0yLFEuRE9OVENBUkU9LTMsUS5TWU1fRkFMU0U9XCJGXCIsUS5TWU1fVFJVRT1cIlRcIixRLlNZTV9ET05UQ0FSRT1cIipcIixRLlNZTV9QPVwiMFwiLFEuU1lNX0w9XCIxXCIsUS5TWU1fQT1cIjJcIjtjbGFzcyBKe2ZpbHRlcih0KXt9fWNsYXNzICQgZXh0ZW5kcyBVe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSwkLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BvaW50cz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtVLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9uZXcgTzp0aGlzLl9wb2ludHMuZXhwYW5kRW52ZWxvcGUobmV3IE8pfWlzUmluZygpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCkmJnRoaXMuaXNTaW1wbGUoKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wb2ludHMudG9Db29yZGluYXRlQXJyYXkoKX1jb3B5SW50ZXJuYWwoKXtyZXR1cm4gbmV3ICQodGhpcy5fcG9pbnRzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dDtpZih0aGlzLl9wb2ludHMuc2l6ZSgpIT09bi5fcG9pbnRzLnNpemUoKSlyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX3BvaW50cy5zaXplKCk7dCsrKWlmKCF0aGlzLmVxdWFsKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLG4uX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDxNYXRoLnRydW5jKHRoaXMuX3BvaW50cy5zaXplKCkvMik7dCsrKXtjb25zdCBlPXRoaXMuX3BvaW50cy5zaXplKCktMS10O2lmKCF0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5lcXVhbHModGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpKXtpZih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5jb21wYXJlVG8odGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpPjApe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtqLnJldmVyc2UodCksdGhpcy5fcG9pbnRzPXR9cmV0dXJuIG51bGx9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoMCl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP1EuRkFMU0U6MH1pc0Nsb3NlZCgpe3JldHVybiF0aGlzLmlzRW1wdHkoKSYmdGhpcy5nZXRDb29yZGluYXRlTigwKS5lcXVhbHMyRCh0aGlzLmdldENvb3JkaW5hdGVOKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSkpfXJldmVyc2VJbnRlcm5hbCgpe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtyZXR1cm4gai5yZXZlcnNlKHQpLHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodCl9Z2V0RW5kUG9pbnQoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50Tih0aGlzLmdldE51bVBvaW50cygpLTEpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfTElORVNUUklOR31nZXREaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRMZW5ndGgoKXtyZXR1cm4gVy5vZkxpbmUodGhpcy5fcG9pbnRzKX1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5fcG9pbnRzLnNpemUoKX1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9MCxuPTA7Zm9yKDtlPHRoaXMuX3BvaW50cy5zaXplKCkmJm48dC5fcG9pbnRzLnNpemUoKTspe2NvbnN0IHM9dGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuY29tcGFyZVRvKHQuX3BvaW50cy5nZXRDb29yZGluYXRlKG4pKTtpZigwIT09cylyZXR1cm4gcztlKyssbisrfXJldHVybiBlPHRoaXMuX3BvaW50cy5zaXplKCk/MTpuPHQuX3BvaW50cy5zaXplKCk/LTE6MH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1sxXS5jb21wYXJlKHRoaXMuX3BvaW50cyx0Ll9wb2ludHMpfX1hcHBseSgpe2lmKEkoYXJndW1lbnRzWzBdLEgpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCk7ZSsrKXQuZmlsdGVyKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFApKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5fcG9pbnRzLnNpemUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCkmJih0LmZpbHRlcih0aGlzLl9wb2ludHMsZSksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sSikpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxrKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX19Z2V0Qm91bmRhcnkoKXt0aHJvdyBuZXcgS31pc0VxdWl2YWxlbnRDbGFzcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mICR9Z2V0Q29vcmRpbmF0ZU4odCl7cmV0dXJuIHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX0xJTkVTVFJJTkd9Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCl7cmV0dXJuIHRoaXMuX3BvaW50c31pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9wb2ludHMuc2l6ZSgpfWluaXQodCl7aWYobnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSwxPT09dC5zaXplKCkpdGhyb3cgbmV3IHMoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZVN0cmluZyAoZm91bmQgXCIrdC5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gMilcIik7dGhpcy5fcG9pbnRzPXR9aXNDb29yZGluYXRlKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKTtlKyspaWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuZXF1YWxzKHQpKXJldHVybiEwO3JldHVybiExfWdldFN0YXJ0UG9pbnQoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50TigwKX1nZXRQb2ludE4odCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bWl19fWNsYXNzIHR0e31jbGFzcyBldCBleHRlbmRzIFV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGV0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3JkaW5hdGVzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07VS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBuZXcgTztjb25zdCB0PW5ldyBPO3JldHVybiB0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlcy5nZXRYKDApLHRoaXMuX2Nvb3JkaW5hdGVzLmdldFkoMCkpLHR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/W106W3RoaXMuZ2V0Q29vcmRpbmF0ZSgpXX1jb3B5SW50ZXJuYWwoKXtyZXR1cm4gbmV3IGV0KHRoaXMuX2Nvb3JkaW5hdGVzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmKCEoIXRoaXMuaXNFbXB0eSgpfHwhdC5pc0VtcHR5KCkpfHx0aGlzLmlzRW1wdHkoKT09PXQuaXNFbXB0eSgpJiZ0aGlzLmVxdWFsKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe31nZXRDb29yZGluYXRlKCl7cmV0dXJuIDAhPT10aGlzLl9jb29yZGluYXRlcy5zaXplKCk/dGhpcy5fY29vcmRpbmF0ZXMuZ2V0Q29vcmRpbmF0ZSgwKTpudWxsfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIFEuRkFMU0V9cmV2ZXJzZUludGVybmFsKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2Nvb3JkaW5hdGVzLmNvcHkoKSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9QT0lOVH1nZXREaW1lbnNpb24oKXtyZXR1cm4gMH1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoxfWdldFgoKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IEQoXCJnZXRYIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueH1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0LmdldENvb3JkaW5hdGUoKSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBhcmd1bWVudHNbMV0uY29tcGFyZSh0aGlzLl9jb29yZGluYXRlcyx0Ll9jb29yZGluYXRlcyl9fWFwcGx5KCl7aWYoSShhcmd1bWVudHNbMF0sSCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFApKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0LmZpbHRlcih0aGlzLl9jb29yZGluYXRlcywwKSx0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxKKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLGspKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfX1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9QT0lOVH1nZXRDb29yZGluYXRlU2VxdWVuY2UoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9Z2V0WSgpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgRChcImdldFkgY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55fWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKX1pbml0KHQpe251bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksZy5pc1RydWUodC5zaXplKCk8PTEpLHRoaXMuX2Nvb3JkaW5hdGVzPXR9aXNTaW1wbGUoKXtyZXR1cm4hMH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bdHRdfX1jbGFzcyBudHtzdGF0aWMgb2ZSaW5nKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYWJzKG50Lm9mUmluZ1NpZ25lZCh0KSl9aWYoSShhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmFicyhudC5vZlJpbmdTaWduZWQodCkpfX1zdGF0aWMgb2ZSaW5nU2lnbmVkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5sZW5ndGg8MylyZXR1cm4gMDtsZXQgZT0wO2NvbnN0IG49dFswXS54O2ZvcihsZXQgcz0xO3M8dC5sZW5ndGgtMTtzKyspe2NvbnN0IGk9dFtzXS54LW4scj10W3MrMV0ueTtlKz1pKih0W3MtMV0ueS1yKX1yZXR1cm4gZS8yfWlmKEkoYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpO2lmKGU8MylyZXR1cm4gMDtjb25zdCBuPW5ldyBtLHM9bmV3IG0saT1uZXcgbTt0LmdldENvb3JkaW5hdGUoMCxzKSx0LmdldENvb3JkaW5hdGUoMSxpKTtjb25zdCByPXMueDtpLngtPXI7bGV0IG89MDtmb3IobGV0IGw9MTtsPGUtMTtsKyspbi55PXMueSxzLng9aS54LHMueT1pLnksdC5nZXRDb29yZGluYXRlKGwrMSxpKSxpLngtPXIsbys9cy54KihuLnktaS55KTtyZXR1cm4gby8yfX19Y2xhc3Mgc3R7c3RhdGljIHNvcnQoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl0LnNvcnQoKCh0LGUpPT50LmNvbXBhcmVUbyhlKSkpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpdC5zb3J0KCgodCxlKT0+YXJndW1lbnRzWzFdLmNvbXBhcmUodCxlKSkpO2Vsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9dC5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKTtlLnNvcnQoKTtjb25zdCBuPXQuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChlLHQuc2xpY2UoYXJndW1lbnRzWzJdLHQubGVuZ3RoKSk7dC5zcGxpY2UoMCx0Lmxlbmd0aCk7Zm9yKGNvbnN0IGUgb2Ygbil0LnB1c2goZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT10LnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO2Uuc29ydCgoKHQsZSk9PmFyZ3VtZW50c1szXS5jb21wYXJlKHQsZSkpKTtjb25zdCBuPXQuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChlLHQuc2xpY2UoYXJndW1lbnRzWzJdLHQubGVuZ3RoKSk7dC5zcGxpY2UoMCx0Lmxlbmd0aCk7Zm9yKGNvbnN0IGUgb2Ygbil0LnB1c2goZSl9fXN0YXRpYyBhc0xpc3QodCl7Y29uc3QgZT1uZXcgTDtmb3IoY29uc3QgbiBvZiB0KWUuYWRkKG4pO3JldHVybiBlfXN0YXRpYyBjb3B5T2YodCxlKXtyZXR1cm4gdC5zbGljZSgwLGUpfX1jbGFzcyBpdHt9Y2xhc3MgcnQgZXh0ZW5kcyBVe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxydC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2hvbGVzPW51bGw7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKFUuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuKSxudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZygpKSxudWxsPT09ZSYmKGU9W10pLFUuaGFzTnVsbEVsZW1lbnRzKGUpKXRocm93IG5ldyBzKFwiaG9sZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO2lmKHQuaXNFbXB0eSgpJiZVLmhhc05vbkVtcHR5RWxlbWVudHMoZSkpdGhyb3cgbmV3IHMoXCJzaGVsbCBpcyBlbXB0eSBidXQgaG9sZXMgYXJlIG5vdFwiKTt0aGlzLl9zaGVsbD10LHRoaXMuX2hvbGVzPWV9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5fc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWdldENvb3JkaW5hdGVzKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuW107Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtsZXQgZT0tMTtjb25zdCBuPXRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspZSsrLHRbZV09bltzXTtmb3IobGV0IG49MDtuPHRoaXMuX2hvbGVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dGhpcy5faG9sZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyllKyssdFtlXT1zW25dfXJldHVybiB0fWdldEFyZWEoKXtsZXQgdD0wO3QrPW50Lm9mUmluZyh0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQtPW50Lm9mUmluZyh0aGlzLl9ob2xlc1tlXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHR9Y29weUludGVybmFsKCl7Y29uc3QgdD10aGlzLl9zaGVsbC5jb3B5KCksZT1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKyllW3RdPXRoaXMuX2hvbGVzW3RdLmNvcHkoKTtyZXR1cm4gbmV3IHJ0KHQsZSx0aGlzLl9mYWN0b3J5KX1pc1JlY3RhbmdsZSgpe2lmKDAhPT10aGlzLmdldE51bUludGVyaW9yUmluZygpKXJldHVybiExO2lmKG51bGw9PT10aGlzLl9zaGVsbClyZXR1cm4hMTtpZig1IT09dGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCkpcmV0dXJuITE7Y29uc3QgdD10aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxlPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2ZvcihsZXQgbj0wO248NTtuKyspe2NvbnN0IHM9dC5nZXRYKG4pO2lmKHMhPT1lLmdldE1pblgoKSYmcyE9PWUuZ2V0TWF4WCgpKXJldHVybiExO2NvbnN0IGk9dC5nZXRZKG4pO2lmKGkhPT1lLmdldE1pblkoKSYmaSE9PWUuZ2V0TWF4WSgpKXJldHVybiExfWxldCBuPXQuZ2V0WCgwKSxzPXQuZ2V0WSgwKTtmb3IobGV0IGU9MTtlPD00O2UrKyl7Y29uc3QgaT10LmdldFgoZSkscj10LmdldFkoZSk7aWYoaSE9PW49PT0ociE9PXMpKXJldHVybiExO249aSxzPXJ9cmV0dXJuITB9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQscz10aGlzLl9zaGVsbCxpPW4uX3NoZWxsO2lmKCFzLmVxdWFsc0V4YWN0KGksZSkpcmV0dXJuITE7aWYodGhpcy5faG9sZXMubGVuZ3RoIT09bi5faG9sZXMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKylpZighdGhpcy5faG9sZXNbdF0uZXF1YWxzRXhhY3Qobi5faG9sZXNbdF0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5fc2hlbGw9dGhpcy5ub3JtYWxpemVkKHRoaXMuX3NoZWxsLCEwKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspdGhpcy5faG9sZXNbdF09dGhpcy5ub3JtYWxpemVkKHRoaXMuX2hvbGVzW3RdLCExKTtzdC5zb3J0KHRoaXMuX2hvbGVzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkscz1qLm1pbkNvb3JkaW5hdGVJbmRleChuLDAsbi5zaXplKCktMik7ai5zY3JvbGwobixzLCEwKSxxLmlzQ0NXKG4pPT09ZSYmai5yZXZlcnNlKG4pfX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGUoKX1nZXROdW1JbnRlcmlvclJpbmcoKXtyZXR1cm4gdGhpcy5faG9sZXMubGVuZ3RofWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIDF9cmV2ZXJzZUludGVybmFsKCl7Y29uc3QgdD10aGlzLmdldEV4dGVyaW9yUmluZygpLnJldmVyc2UoKSxlPW5ldyBBcnJheSh0aGlzLmdldE51bUludGVyaW9yUmluZygpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF09dGhpcy5nZXRJbnRlcmlvclJpbmdOKHQpLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbih0LGUpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfUE9MWUdPTn1nZXREaW1lbnNpb24oKXtyZXR1cm4gMn1nZXRMZW5ndGgoKXtsZXQgdD0wO3QrPXRoaXMuX3NoZWxsLmdldExlbmd0aCgpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9ob2xlc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH1nZXROdW1Qb2ludHMoKXtsZXQgdD10aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5faG9sZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9Y29udmV4SHVsbCgpe3JldHVybiB0aGlzLmdldEV4dGVyaW9yUmluZygpLmNvbnZleEh1bGwoKX1ub3JtYWxpemVkKHQsZSl7Y29uc3Qgbj10LmNvcHkoKTtyZXR1cm4gdGhpcy5ub3JtYWxpemUobixlKSxufWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX3NoZWxsLG49dC5fc2hlbGw7cmV0dXJuIGUuY29tcGFyZVRvU2FtZUNsYXNzKG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXSxuPXRoaXMuX3NoZWxsLHM9ZS5fc2hlbGwsaT1uLmNvbXBhcmVUb1NhbWVDbGFzcyhzLHQpO2lmKDAhPT1pKXJldHVybiBpO2NvbnN0IHI9dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSxvPWUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bGV0IGw9MDtmb3IoO2w8ciYmbDxvOyl7Y29uc3Qgbj10aGlzLmdldEludGVyaW9yUmluZ04obCkscz1lLmdldEludGVyaW9yUmluZ04obCksaT1uLmNvbXBhcmVUb1NhbWVDbGFzcyhzLHQpO2lmKDAhPT1pKXJldHVybiBpO2wrK31yZXR1cm4gbDxyPzE6bDxvPy0xOjB9fWFwcGx5KCl7aWYoSShhcmd1bWVudHNbMF0sSCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NoZWxsLmFwcGx5KHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0aGlzLl9ob2xlc1tlXS5hcHBseSh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFApKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl9zaGVsbC5hcHBseSh0KSwhdC5pc0RvbmUoKSlmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aCYmKHRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEopKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpLHRoaXMuX3NoZWxsLmFwcGx5KHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0aGlzLl9ob2xlc1tlXS5hcHBseSh0KX19Z2V0Qm91bmRhcnkoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKzEpLmZpbGwobnVsbCk7dFswXT10aGlzLl9zaGVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdFtlKzFdPXRoaXMuX2hvbGVzW2VdO3JldHVybiB0Lmxlbmd0aDw9MT90aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHRbMF0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpOnRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0KX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9QT0xZR09OfWdldEV4dGVyaW9yUmluZygpe3JldHVybiB0aGlzLl9zaGVsbH1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX3NoZWxsLmlzRW1wdHkoKX1nZXRJbnRlcmlvclJpbmdOKHQpe3JldHVybiB0aGlzLl9ob2xlc1t0XX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5baXRdfX1jbGFzcyBvdCBleHRlbmRzIE57Y29udGFpbnMoKXt9fWNsYXNzIGx0IGV4dGVuZHMgb3R7fWNsYXNzIGF0IGV4dGVuZHMgbHR7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmFycmF5PVtdLHQgaW5zdGFuY2VvZiBOJiZ0aGlzLmFkZEFsbCh0KX1jb250YWlucyh0KXtmb3IoY29uc3QgZSBvZiB0aGlzLmFycmF5KWlmKDA9PT1lLmNvbXBhcmVUbyh0KSlyZXR1cm4hMDtyZXR1cm4hMX1hZGQodCl7aWYodGhpcy5jb250YWlucyh0KSlyZXR1cm4hMTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXkubGVuZ3RoO2U8bjtlKyspe2lmKDE9PT10aGlzLmFycmF5W2VdLmNvbXBhcmVUbyh0KSlyZXR1cm4hIXRoaXMuYXJyYXkuc3BsaWNlKGUsMCx0KX1yZXR1cm4gdGhpcy5hcnJheS5wdXNoKHQpLCEwfWFkZEFsbCh0KXtmb3IoY29uc3QgZSBvZiB0KXRoaXMuYWRkKGUpO3JldHVybiEwfXJlbW92ZSgpe3Rocm93IG5ldyBLfXNpemUoKXtyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGh9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9dG9BcnJheSgpe3JldHVybiB0aGlzLmFycmF5LnNsaWNlKCl9aXRlcmF0b3IoKXtyZXR1cm4gbmV3IGN0KHRoaXMuYXJyYXkpfX1sZXQgY3Q9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5hcnJheT10LHRoaXMucG9zaXRpb249MH1uZXh0KCl7aWYodGhpcy5wb3NpdGlvbj09PXRoaXMuYXJyYXkubGVuZ3RoKXRocm93IG5ldyBTO3JldHVybiB0aGlzLmFycmF5W3RoaXMucG9zaXRpb24rK119aGFzTmV4dCgpe3JldHVybiB0aGlzLnBvc2l0aW9uPHRoaXMuYXJyYXkubGVuZ3RofXJlbW92ZSgpe3Rocm93IG5ldyBLfX07Y2xhc3MgaHQgZXh0ZW5kcyBVe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxodC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tZXRyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihVLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksbnVsbD09PXQmJih0PVtdKSxVLmhhc051bGxFbGVtZW50cyh0KSl0aHJvdyBuZXcgcyhcImdlb21ldHJpZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO3RoaXMuX2dlb21ldHJpZXM9dH19Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtjb25zdCB0PW5ldyBPO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gdH1nZXRHZW9tZXRyeU4odCl7cmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbdF19Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO2xldCBlPS0xO2ZvcihsZXQgbj0wO248dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKXtjb25zdCBzPXRoaXMuX2dlb21ldHJpZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyllKyssdFtlXT1zW25dfXJldHVybiB0fWdldEFyZWEoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0QXJlYSgpO3JldHVybiB0fWNvcHlJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBodCh0LHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10O2lmKHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoIT09bi5fZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uZXF1YWxzRXhhY3Qobi5fZ2VvbWV0cmllc1t0XSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKXRoaXMuX2dlb21ldHJpZXNbdF0ubm9ybWFsaXplKCk7c3Quc29ydCh0aGlzLl9nZW9tZXRyaWVzKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5fZ2VvbWV0cmllc1swXS5nZXRDb29yZGluYXRlKCl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtsZXQgdD1RLkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpO3JldHVybiB0fXJldmVyc2VJbnRlcm5hbCgpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgTCh0KTtmb3IobGV0IG49MDtuPHQ7bisrKWUuYWRkKHRoaXMuX2dlb21ldHJpZXNbbl0ucmV2ZXJzZSgpKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShlKX1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTn1nZXREaW1lbnNpb24oKXtsZXQgdD1RLkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldERpbWVuc2lvbigpKTtyZXR1cm4gdH1nZXRMZW5ndGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9Z2V0TnVtUG9pbnRzKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fWdldE51bUdlb21ldHJpZXMoKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGh9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IGF0KHN0LmFzTGlzdCh0aGlzLl9nZW9tZXRyaWVzKSksbj1uZXcgYXQoc3QuYXNMaXN0KHQuX2dlb21ldHJpZXMpKTtyZXR1cm4gdGhpcy5jb21wYXJlKGUsbil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLG49dGhpcy5nZXROdW1HZW9tZXRyaWVzKCkscz1lLmdldE51bUdlb21ldHJpZXMoKTtsZXQgaT0wO2Zvcig7aTxuJiZpPHM7KXtjb25zdCBuPXRoaXMuZ2V0R2VvbWV0cnlOKGkpLHM9ZS5nZXRHZW9tZXRyeU4oaSkscj1uLmNvbXBhcmVUb1NhbWVDbGFzcyhzLHQpO2lmKDAhPT1yKXJldHVybiByO2krK31yZXR1cm4gaTxuPzE6aTxzPy0xOjB9fWFwcGx5KCl7aWYoSShhcmd1bWVudHNbMF0sSCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxQKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgmJih0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEopKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIFUuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksZy5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OfWlzRW1wdHkoKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5pc0VtcHR5KCkpcmV0dXJuITE7cmV0dXJuITB9fWNsYXNzIHV0IGV4dGVuZHMgaHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHV0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2h0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgdXQodCx0aGlzLl9mYWN0b3J5KX1pc1ZhbGlkKCl7cmV0dXJuITB9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9nZW9tZXRyaWVzW3RdLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gc3VwZXIuZ2V0Q29vcmRpbmF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gUS5GQUxTRX1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX01VTFRJUE9JTlR9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDB9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfTVVMVElQT0lOVH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bdHRdfX1jbGFzcyBndCBleHRlbmRzICR7Y29uc3RydWN0b3IoKXtzdXBlcigpLGd0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdOyQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMudmFsaWRhdGVDb25zdHJ1Y3Rpb24oKX1jb3B5SW50ZXJuYWwoKXtyZXR1cm4gbmV3IGd0KHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gUS5GQUxTRX1pc0Nsb3NlZCgpe3JldHVybiEhdGhpcy5pc0VtcHR5KCl8fHN1cGVyLmlzQ2xvc2VkLmNhbGwodGhpcyl9cmV2ZXJzZUludGVybmFsKCl7Y29uc3QgdD10aGlzLl9wb2ludHMuY29weSgpO3JldHVybiBqLnJldmVyc2UodCksdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0KX1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX0xJTkVBUlJJTkd9dmFsaWRhdGVDb25zdHJ1Y3Rpb24oKXtpZighdGhpcy5pc0VtcHR5KCkmJiFzdXBlci5pc0Nsb3NlZC5jYWxsKHRoaXMpKXRocm93IG5ldyBzKFwiUG9pbnRzIG9mIExpbmVhclJpbmcgZG8gbm90IGZvcm0gYSBjbG9zZWQgbGluZXN0cmluZ1wiKTtpZih0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKT49MSYmdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk8Z3QuTUlOSU1VTV9WQUxJRF9TSVpFKXRocm93IG5ldyBzKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVhclJpbmcgKGZvdW5kIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDQpXCIpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX0xJTkVBUlJJTkd9fWd0Lk1JTklNVU1fVkFMSURfU0laRT00O2NsYXNzIGR0e3N0YXRpYyBtZWFzdXJlcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHk/MDp0IGluc3RhbmNlb2YgeHx8dCBpbnN0YW5jZW9mIEU/MTowfXN0YXRpYyBkaW1lbnNpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB5PzI6dCBpbnN0YW5jZW9mIHg/Mzp0IGluc3RhbmNlb2YgRT80OjN9c3RhdGljIGNyZWF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gZHQuY3JlYXRlKHQsMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiAyPT09dD9uZXcgeTozPT09dCYmMD09PWU/bmV3IG06Mz09PXQmJjE9PT1lP25ldyB4OjQ9PT10JiYxPT09ZT9uZXcgRTpuZXcgbX19fWNsYXNzIF90e3N0YXRpYyBpc1JpbmcodCl7cmV0dXJuISh0Lmxlbmd0aDw0KSYmISF0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfXN0YXRpYyBwdE5vdEluTGlzdCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl07aWYoX3QuaW5kZXhPZihzLGUpPDApcmV0dXJuIHN9cmV0dXJuIG51bGx9c3RhdGljIHNjcm9sbCh0LGUpe2NvbnN0IG49X3QuaW5kZXhPZihlLHQpO2lmKG48MClyZXR1cm4gbnVsbDtjb25zdCBzPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtZLmFycmF5Y29weSh0LG4scywwLHQubGVuZ3RoLW4pLFkuYXJyYXljb3B5KHQsMCxzLHQubGVuZ3RoLW4sbiksWS5hcnJheWNvcHkocywwLHQsMCx0Lmxlbmd0aCl9c3RhdGljIGVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT09dHx8bnVsbD09PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZVtuXSkpcmV0dXJuITE7cmV0dXJuITB9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKWlmKDAhPT1uLmNvbXBhcmUodFtzXSxlW3NdKSlyZXR1cm4hMTtyZXR1cm4hMH19c3RhdGljIGludGVyc2VjdGlvbih0LGUpe2NvbnN0IG49bmV3IFI7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspZS5pbnRlcnNlY3RzKHRbc10pJiZuLmFkZCh0W3NdLCEwKTtyZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyBtZWFzdXJlcyh0KXtpZihudWxsPT09dHx8MD09PXQubGVuZ3RoKXJldHVybiAwO2xldCBlPTA7Zm9yKGNvbnN0IG4gb2YgdCllPU1hdGgubWF4KGUsZHQubWVhc3VyZXMobikpO3JldHVybiBlfXN0YXRpYyBoYXNSZXBlYXRlZFBvaW50cyh0KXtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0W2UtMV0uZXF1YWxzKHRbZV0pKXJldHVybiEwO3JldHVybiExfXN0YXRpYyByZW1vdmVSZXBlYXRlZFBvaW50cyh0KXtpZighX3QuaGFzUmVwZWF0ZWRQb2ludHModCkpcmV0dXJuIHQ7cmV0dXJuIG5ldyBSKHQsITEpLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10Lmxlbmd0aC0xLG49TWF0aC50cnVuYyhlLzIpO2ZvcihsZXQgcz0wO3M8PW47cysrKXtjb25zdCBuPXRbc107dFtzXT10W2Utc10sdFtlLXNdPW59fXN0YXRpYyByZW1vdmVOdWxsKHQpe2xldCBlPTA7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspbnVsbCE9PXRbbl0mJmUrKztjb25zdCBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2lmKDA9PT1lKXJldHVybiBuO2xldCBzPTA7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspbnVsbCE9PXRbZV0mJihuW3MrK109dFtlXSk7cmV0dXJuIG59c3RhdGljIGNvcHlEZWVwKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWVbbl09dFtuXS5jb3B5KCk7cmV0dXJuIGV9aWYoNT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdO2ZvcihsZXQgcj0wO3I8aTtyKyspbltzK3JdPXRbZStyXS5jb3B5KCl9fXN0YXRpYyBpc0VxdWFsUmV2ZXJzZWQodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dLGk9ZVt0Lmxlbmd0aC1uLTFdO2lmKDAhPT1zLmNvbXBhcmVUbyhpKSlyZXR1cm4hMX1yZXR1cm4hMH1zdGF0aWMgZW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTztmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllLmV4cGFuZFRvSW5jbHVkZSh0W25dKTtyZXR1cm4gZX1zdGF0aWMgdG9Db29yZGluYXRlQXJyYXkodCl7cmV0dXJuIHQudG9BcnJheShfdC5jb29yZEFycmF5VHlwZSl9c3RhdGljIGRpbWVuc2lvbih0KXtpZihudWxsPT09dHx8MD09PXQubGVuZ3RoKXJldHVybiAzO2xldCBlPTA7Zm9yKGNvbnN0IG4gb2YgdCllPU1hdGgubWF4KGUsZHQuZGltZW5zaW9uKG4pKTtyZXR1cm4gZX1zdGF0aWMgYXRMZWFzdE5Db29yZGluYXRlc09yTm90aGluZyh0LGUpe3JldHVybiBlLmxlbmd0aD49dD9lOltdfXN0YXRpYyBpbmRleE9mKHQsZSl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspaWYodC5lcXVhbHMoZVtuXSkpcmV0dXJuIG47cmV0dXJuLTF9c3RhdGljIGluY3JlYXNpbmdEaXJlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTxNYXRoLnRydW5jKHQubGVuZ3RoLzIpO2UrKyl7Y29uc3Qgbj10Lmxlbmd0aC0xLWUscz10W2VdLmNvbXBhcmVUbyh0W25dKTtpZigwIT09cylyZXR1cm4gc31yZXR1cm4gMX1zdGF0aWMgY29tcGFyZSh0LGUpe2xldCBuPTA7Zm9yKDtuPHQubGVuZ3RoJiZuPGUubGVuZ3RoOyl7Y29uc3Qgcz10W25dLmNvbXBhcmVUbyhlW25dKTtpZigwIT09cylyZXR1cm4gcztuKyt9cmV0dXJuIG48ZS5sZW5ndGg/LTE6bjx0Lmxlbmd0aD8xOjB9c3RhdGljIG1pbkNvb3JkaW5hdGUodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKykobnVsbD09PWV8fGUuY29tcGFyZVRvKHRbbl0pPjApJiYoZT10W25dKTtyZXR1cm4gZX1zdGF0aWMgZXh0cmFjdCh0LGUsbil7ZT1WLmNsYW1wKGUsMCx0Lmxlbmd0aCk7bGV0IHM9KG49Vi5jbGFtcChuLC0xLHQubGVuZ3RoKSktZSsxO248MCYmKHM9MCksZT49dC5sZW5ndGgmJihzPTApLG48ZSYmKHM9MCk7Y29uc3QgaT1uZXcgQXJyYXkocykuZmlsbChudWxsKTtpZigwPT09cylyZXR1cm4gaTtsZXQgcj0wO2ZvcihsZXQgcz1lO3M8PW47cysrKWlbcisrXT10W3NdO3JldHVybiBpfX1fdC5Gb3J3YXJkQ29tcGFyYXRvcj1jbGFzc3tjb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtyZXR1cm4gX3QuY29tcGFyZShuLHMpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19LF90LkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yPWNsYXNze2NvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO2lmKG4ubGVuZ3RoPHMubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPnMubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtjb25zdCBpPV90LmNvbXBhcmUobixzKTtyZXR1cm4gX3QuaXNFcXVhbFJldmVyc2VkKG4scyk/MDppfU9MRGNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO2lmKG4ubGVuZ3RoPHMubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPnMubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtjb25zdCBpPV90LmluY3JlYXNpbmdEaXJlY3Rpb24obikscj1fdC5pbmNyZWFzaW5nRGlyZWN0aW9uKHMpO2xldCBvPWk+MD8wOm4ubGVuZ3RoLTEsbD1yPjA/MDpuLmxlbmd0aC0xO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCB0PW5bb10uY29tcGFyZVRvKHNbbF0pO2lmKDAhPT10KXJldHVybiB0O28rPWksbCs9cn1yZXR1cm4gMH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fSxfdC5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKTtjbGFzcyBwdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLnN0cj10fWFwcGVuZCh0KXt0aGlzLnN0cis9dH1zZXRDaGFyQXQodCxlKXt0aGlzLnN0cj10aGlzLnN0ci5zdWJzdHIoMCx0KStlK3RoaXMuc3RyLnN1YnN0cih0KzEpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc3RyfX1jbGFzcyBtdHtjb25zdHJ1Y3Rvcigpe210LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2RpbWVuc2lvbj0zLHRoaXMuX21lYXN1cmVzPTAsdGhpcy5fY29vcmRpbmF0ZXM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bXQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LF90LmRpbWVuc2lvbih0KSxfdC5tZWFzdXJlcyh0KSl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09bmV3IG19ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7dGhpcy5fZGltZW5zaW9uPXQuZ2V0RGltZW5zaW9uKCksdGhpcy5fbWVhc3VyZXM9dC5nZXRNZWFzdXJlcygpLHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09dC5nZXRDb29yZGluYXRlQ29weShlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTttdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxfdC5tZWFzdXJlcyh0KSl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5fZGltZW5zaW9uPWU7Zm9yKGxldCBuPTA7bjx0O24rKyl0aGlzLl9jb29yZGluYXRlc1tuXT1kdC5jcmVhdGUoZSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2RpbWVuc2lvbj1lLHRoaXMuX21lYXN1cmVzPW4sdGhpcy5fY29vcmRpbmF0ZXM9bnVsbD09PXQ/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6dH1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuX2RpbWVuc2lvbj1lLHRoaXMuX21lYXN1cmVzPW47Zm9yKGxldCBlPTA7ZTx0O2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT10aGlzLmNyZWF0ZUNvb3JkaW5hdGUoKX19Z2V0TSh0KXtyZXR1cm4gdGhpcy5oYXNNKCk/dGhpcy5fY29vcmRpbmF0ZXNbdF0uZ2V0TSgpOnIuTmFOfXNldE9yZGluYXRlKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBHLlg6dGhpcy5fY29vcmRpbmF0ZXNbdF0ueD1uO2JyZWFrO2Nhc2UgRy5ZOnRoaXMuX2Nvb3JkaW5hdGVzW3RdLnk9bjticmVhaztkZWZhdWx0OnRoaXMuX2Nvb3JkaW5hdGVzW3RdLnNldE9yZGluYXRlKGUsbil9fWdldFoodCl7cmV0dXJuIHRoaXMuaGFzWigpP3RoaXMuX2Nvb3JkaW5hdGVzW3RdLmdldFooKTpyLk5hTn1zaXplKCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aH1nZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaChlKXtjYXNlIEcuWDpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueDtjYXNlIEcuWTpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueTtkZWZhdWx0OnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS5nZXRPcmRpbmF0ZShlKX19Z2V0Q29vcmRpbmF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF19aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2FyZ3VtZW50c1sxXS5zZXRDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW3RdKX19Z2V0Q29vcmRpbmF0ZUNvcHkodCl7Y29uc3QgZT10aGlzLmNyZWF0ZUNvb3JkaW5hdGUoKTtyZXR1cm4gZS5zZXRDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW3RdKSxlfWNyZWF0ZUNvb3JkaW5hdGUoKXtyZXR1cm4gZHQuY3JlYXRlKHRoaXMuZ2V0RGltZW5zaW9uKCksdGhpcy5nZXRNZWFzdXJlcygpKX1nZXREaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5fZGltZW5zaW9ufWdldFgodCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnh9Z2V0TWVhc3VyZXMoKXtyZXR1cm4gdGhpcy5fbWVhc3VyZXN9ZXhwYW5kRW52ZWxvcGUodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdH1jb3B5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuY3JlYXRlQ29vcmRpbmF0ZSgpO24uc2V0Q29vcmRpbmF0ZSh0aGlzLl9jb29yZGluYXRlc1tlXSksdFtlXT1ufXJldHVybiBuZXcgbXQodCx0aGlzLl9kaW1lbnNpb24sdGhpcy5fbWVhc3VyZXMpfXRvU3RyaW5nKCl7aWYodGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoPjApe2NvbnN0IHQ9bmV3IHB0KDE3KnRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCk7dC5hcHBlbmQoXCIoXCIpLHQuYXBwZW5kKHRoaXMuX2Nvb3JkaW5hdGVzWzBdKTtmb3IobGV0IGU9MTtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5hcHBlbmQoXCIsIFwiKSx0LmFwcGVuZCh0aGlzLl9jb29yZGluYXRlc1tlXSk7cmV0dXJuIHQuYXBwZW5kKFwiKVwiKSx0LnRvU3RyaW5nKCl9cmV0dXJuXCIoKVwifWdldFkodCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnl9dG9Db29yZGluYXRlQXJyYXkoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0csY119fWNsYXNzIGZ0e3N0YXRpYyBpbnN0YW5jZSgpe3JldHVybiBmdC5pbnN0YW5jZU9iamVjdH1yZWFkUmVzb2x2ZSgpe3JldHVybiBmdC5pbnN0YW5jZSgpfWNyZWF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtyZXR1cm4gbmV3IG10KGFyZ3VtZW50c1swXSl9aWYoSShhcmd1bWVudHNbMF0sRykpe3JldHVybiBuZXcgbXQoYXJndW1lbnRzWzBdKX19ZWxzZXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzFdO3JldHVybiB0PjMmJih0PTMpLHQ8MiYmKHQ9MiksbmV3IG10KGFyZ3VtZW50c1swXSx0KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzJdLGU9YXJndW1lbnRzWzFdLXQ7cmV0dXJuIHQ+MSYmKHQ9MSksZT4zJiYoZT0zKSxlPDImJihlPTIpLG5ldyBtdChhcmd1bWVudHNbMF0sZSt0LHQpfX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1gsY119fWZ0Lmluc3RhbmNlT2JqZWN0PW5ldyBmdDtjbGFzcyB5dCBleHRlbmRzIGh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx5dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtodC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9Y29weUludGVybmFsKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IHl0KHQsdGhpcy5fZmFjdG9yeSl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX01VTFRJUE9MWUdPTn1nZXREaW1lbnNpb24oKXtyZXR1cm4gMn1nZXRCb3VuZGFyeSgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0Qm91bmRhcnkoKTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl0LmFkZChuLmdldEdlb21ldHJ5TihlKSl9Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0LnRvQXJyYXkoZSkpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX01VTFRJUE9MWUdPTn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5baXRdfX1sZXQgeHQ9Y2xhc3N7Z2V0KCl7fXB1dCgpe31zaXplKCl7fXZhbHVlcygpe31lbnRyeVNldCgpe319O2NsYXNzIEV0IGV4dGVuZHMgb3R7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLm1hcD1uZXcgTWFwLHQgaW5zdGFuY2VvZiBOJiZ0aGlzLmFkZEFsbCh0KX1jb250YWlucyh0KXtjb25zdCBlPXQuaGFzaENvZGU/dC5oYXNoQ29kZSgpOnQ7cmV0dXJuISF0aGlzLm1hcC5oYXMoZSl9YWRkKHQpe2NvbnN0IGU9dC5oYXNoQ29kZT90Lmhhc2hDb2RlKCk6dDtyZXR1cm4hdGhpcy5tYXAuaGFzKGUpJiYhIXRoaXMubWFwLnNldChlLHQpfWFkZEFsbCh0KXtmb3IoY29uc3QgZSBvZiB0KXRoaXMuYWRkKGUpO3JldHVybiEwfXJlbW92ZSgpe3Rocm93IG5ldyBLfXNpemUoKXtyZXR1cm4gdGhpcy5tYXAuc2l6ZX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLm1hcC5zaXplfXRvQXJyYXkoKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1hcC52YWx1ZXMoKSl9aXRlcmF0b3IoKXtyZXR1cm4gbmV3IEl0KHRoaXMubWFwKX1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLm1hcH19bGV0IEl0PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuaXRlcmF0b3I9dC52YWx1ZXMoKTtjb25zdHtkb25lOmUsdmFsdWU6bn09dGhpcy5pdGVyYXRvci5uZXh0KCk7dGhpcy5kb25lPWUsdGhpcy52YWx1ZT1ufW5leHQoKXtpZih0aGlzLmRvbmUpdGhyb3cgbmV3IFM7Y29uc3QgdD10aGlzLnZhbHVlLHtkb25lOmUsdmFsdWU6bn09dGhpcy5pdGVyYXRvci5uZXh0KCk7cmV0dXJuIHRoaXMuZG9uZT1lLHRoaXMudmFsdWU9bix0fWhhc05leHQoKXtyZXR1cm4hdGhpcy5kb25lfXJlbW92ZSgpe3Rocm93IG5ldyBLfX07Y2xhc3MgTnQgZXh0ZW5kcyB4dHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5tYXA9bmV3IE1hcH1nZXQodCl7cmV0dXJuIHRoaXMubWFwLmdldCh0KXx8bnVsbH1wdXQodCxlKXtyZXR1cm4gdGhpcy5tYXAuc2V0KHQsZSksZX12YWx1ZXMoKXtjb25zdCB0PW5ldyBMLGU9dGhpcy5tYXAudmFsdWVzKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDshbi5kb25lOyl0LmFkZChuLnZhbHVlKSxuPWUubmV4dCgpO3JldHVybiB0fWVudHJ5U2V0KCl7Y29uc3QgdD1uZXcgRXQ7cmV0dXJuIHRoaXMubWFwLmVudHJpZXMoKS5mb3JFYWNoKChlPT50LmFkZChlKSkpLHR9c2l6ZSgpe3JldHVybiB0aGlzLm1hcC5zaXplKCl9fWNsYXNzIHd0e2NvbnN0cnVjdG9yKCl7d3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbW9kZWxUeXBlPW51bGwsdGhpcy5fc2NhbGU9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9tb2RlbFR5cGU9d3QuRkxPQVRJTkc7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEN0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9dCx0PT09d3QuRklYRUQmJnRoaXMuc2V0U2NhbGUoMSl9ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9d3QuRklYRUQsdGhpcy5zZXRTY2FsZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygd3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT10Ll9tb2RlbFR5cGUsdGhpcy5fc2NhbGU9dC5fc2NhbGV9fXN0YXRpYyBtb3N0UHJlY2lzZSh0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKT49MD90OmV9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIHd0KSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWUuX21vZGVsVHlwZSYmdGhpcy5fc2NhbGU9PT1lLl9zY2FsZX1jb21wYXJlVG8odCl7Y29uc3QgZT10LG49dGhpcy5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKSxzPWUuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7cmV0dXJuIGIuY29tcGFyZShuLHMpfWdldFNjYWxlKCl7cmV0dXJuIHRoaXMuX3NjYWxlfWlzRmxvYXRpbmcoKXtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkd8fHRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HX1NJTkdMRX1nZXRUeXBlKCl7cmV0dXJuIHRoaXMuX21vZGVsVHlwZX10b1N0cmluZygpe2xldCB0PVwiVU5LTk9XTlwiO3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElORz90PVwiRmxvYXRpbmdcIjp0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElOR19TSU5HTEU/dD1cIkZsb2F0aW5nLVNpbmdsZVwiOnRoaXMuX21vZGVsVHlwZT09PXd0LkZJWEVEJiYodD1cIkZpeGVkIChTY2FsZT1cIit0aGlzLmdldFNjYWxlKCkrXCIpXCIpLHR9bWFrZVByZWNpc2UoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihyLmlzTmFOKHQpKXJldHVybiB0O2lmKHRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HX1NJTkdMRSl7cmV0dXJuIHR9cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PXd0LkZJWEVEP01hdGgucm91bmQodCp0aGlzLl9zY2FsZSkvdGhpcy5fc2NhbGU6dH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HKXJldHVybiBudWxsO3QueD10aGlzLm1ha2VQcmVjaXNlKHQueCksdC55PXRoaXMubWFrZVByZWNpc2UodC55KX19Z2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCl7bGV0IHQ9MTY7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HP3Q9MTY6dGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkdfU0lOR0xFP3Q9Njp0aGlzLl9tb2RlbFR5cGU9PT13dC5GSVhFRCYmKHQ9MStNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLmxvZyh0aGlzLmdldFNjYWxlKCkpL01hdGgubG9nKDEwKSkpKSx0fXNldFNjYWxlKHQpe3RoaXMuX3NjYWxlPU1hdGguYWJzKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjLG9dfX1jbGFzcyBDdHtjb25zdHJ1Y3Rvcigpe0N0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25hbWU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9uYW1lPXQsQ3QubmFtZVRvVHlwZU1hcC5wdXQodCx0aGlzKX1yZWFkUmVzb2x2ZSgpe3JldHVybiBDdC5uYW1lVG9UeXBlTWFwLmdldCh0aGlzLl9uYW1lKX10b1N0cmluZygpe3JldHVybiB0aGlzLl9uYW1lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjXX19Q3QubmFtZVRvVHlwZU1hcD1uZXcgTnQsd3QuVHlwZT1DdCx3dC5GSVhFRD1uZXcgQ3QoXCJGSVhFRFwiKSx3dC5GTE9BVElORz1uZXcgQ3QoXCJGTE9BVElOR1wiKSx3dC5GTE9BVElOR19TSU5HTEU9bmV3IEN0KFwiRkxPQVRJTkcgU0lOR0xFXCIpLHd0Lm1heGltdW1QcmVjaXNlVmFsdWU9OTAwNzE5OTI1NDc0MDk5MjtjbGFzcyBTdCBleHRlbmRzIGh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxTdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtodC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9Y29weUludGVybmFsKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IFN0KHQsdGhpcy5fZmFjdG9yeSl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP1EuRkFMU0U6MH1pc0Nsb3NlZCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9nZW9tZXRyaWVzW3RdLmlzQ2xvc2VkKCkpcmV0dXJuITE7cmV0dXJuITB9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9NVUxUSUxJTkVTVFJJTkd9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0Qm91bmRhcnkoKXt0aHJvdyBuZXcgS31nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9NVUxUSUxJTkVTVFJJTkd9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1pdfX1jbGFzcyBMdHtjb25zdHJ1Y3Rvcigpe0x0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1udWxsLHRoaXMuX1NSSUQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClMdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyB3dCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxYKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07THQuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgd3QsMCx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygd3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0x0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwwLEx0LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtMdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxMdC5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wcmVjaXNpb25Nb2RlbD10LHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bix0aGlzLl9TUklEPWV9fXN0YXRpYyB0b011bHRpUG9seWdvbkFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvR2VvbWV0cnlBcnJheSh0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyBnZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpe3JldHVybiBmdC5pbnN0YW5jZSgpfXN0YXRpYyB0b011bHRpTGluZVN0cmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTGluZVN0cmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTXVsdGlQb2ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTGluZWFyUmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvUG9pbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b1BvbHlnb25BcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyBjcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX1jcmVhdGVFbXB0eSh0KXtzd2l0Y2godCl7Y2FzZS0xOnJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2Nhc2UgMDpyZXR1cm4gdGhpcy5jcmVhdGVQb2ludCgpO2Nhc2UgMTpyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAyOnJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24oKTtkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBkaW1lbnNpb246IFwiK3QpfX10b0dlb21ldHJ5KHQpe3JldHVybiB0LmlzTnVsbCgpP3RoaXMuY3JlYXRlUG9pbnQoKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpJiZ0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlUG9pbnQobmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpfHx0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlTGluZVN0cmluZyhbbmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBtKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKV0pOnRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoW25ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgbSh0LmdldE1pblgoKSx0LmdldE1heFkoKSksbmV3IG0odC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLG5ldyBtKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKSxuZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSldKSxudWxsKX1jcmVhdGVMaW5lU3RyaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoSShhcmd1bWVudHNbMF0sRykpe3JldHVybiBuZXcgJChhcmd1bWVudHNbMF0sdGhpcyl9fX1jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IFN0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgU3QoYXJndW1lbnRzWzBdLHRoaXMpfX1idWlsZEdlb21ldHJ5KHQpe2xldCBlPW51bGwsbj0hMSxzPSExO2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpLHI9dC5nZXRUeXBlQ29kZSgpO251bGw9PT1lJiYoZT1yKSxyIT09ZSYmKG49ITApLHQgaW5zdGFuY2VvZiBodCYmKHM9ITApfWlmKG51bGw9PT1lKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKG58fHMpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEx0LnRvR2VvbWV0cnlBcnJheSh0KSk7Y29uc3QgaT10Lml0ZXJhdG9yKCkubmV4dCgpO2lmKHQuc2l6ZSgpPjEpe2lmKGkgaW5zdGFuY2VvZiBydClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvbHlnb24oTHQudG9Qb2x5Z29uQXJyYXkodCkpO2lmKGkgaW5zdGFuY2VvZiAkKXJldHVybiB0aGlzLmNyZWF0ZU11bHRpTGluZVN0cmluZyhMdC50b0xpbmVTdHJpbmdBcnJheSh0KSk7aWYoaSBpbnN0YW5jZW9mIGV0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoTHQudG9Qb2ludEFycmF5KHQpKTtnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5oYW5kbGVkIGdlb21ldHJ5IHR5cGU6IFwiK2kuZ2V0R2VvbWV0cnlUeXBlKCkpfXJldHVybiBpfWNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKHQpe3JldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWNyZWF0ZVBvaW50KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFt0XSk6bnVsbCl9aWYoSShhcmd1bWVudHNbMF0sRykpe3JldHVybiBuZXcgZXQoYXJndW1lbnRzWzBdLHRoaXMpfX19Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5fWNyZWF0ZVBvbHlnb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKG51bGwsbnVsbCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odCxudWxsKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBydChhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdLHRoaXMpfX1nZXRTUklEKCl7cmV0dXJuIHRoaXMuX1NSSUR9Y3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBodChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IGh0KGFyZ3VtZW50c1swXSx0aGlzKX19Z2V0UHJlY2lzaW9uTW9kZWwoKXtyZXR1cm4gdGhpcy5fcHJlY2lzaW9uTW9kZWx9Y3JlYXRlTGluZWFyUmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKEkoYXJndW1lbnRzWzBdLEcpKXtyZXR1cm4gbmV3IGd0KGFyZ3VtZW50c1swXSx0aGlzKX19fWNyZWF0ZU11bHRpUG9seWdvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgeXQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyB5dChhcmd1bWVudHNbMF0sdGhpcyl9fWNyZWF0ZU11bHRpUG9pbnQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IHV0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3JldHVybiBuZXcgdXQoYXJndW1lbnRzWzBdLHRoaXMpfWlmKEkoYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoMSx0LmdldERpbWVuc2lvbigpLHQuZ2V0TWVhc3VyZXMoKSk7ai5jb3B5KHQsbixzLDAsMSksZVtuXT10aGlzLmNyZWF0ZVBvaW50KHMpfXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoZSl9fX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bY119fWNvbnN0IFR0PVwiWFlcIixSdD1cIlhZWlwiLFB0PVwiWFlNXCIsT3Q9XCJYWVpNXCIsdnQ9e1BPSU5UOlwiUG9pbnRcIixMSU5FX1NUUklORzpcIkxpbmVTdHJpbmdcIixMSU5FQVJfUklORzpcIkxpbmVhclJpbmdcIixQT0xZR09OOlwiUG9seWdvblwiLE1VTFRJX1BPSU5UOlwiTXVsdGlQb2ludFwiLE1VTFRJX0xJTkVfU1RSSU5HOlwiTXVsdGlMaW5lU3RyaW5nXCIsTVVMVElfUE9MWUdPTjpcIk11bHRpUG9seWdvblwiLEdFT01FVFJZX0NPTExFQ1RJT046XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixDSVJDTEU6XCJDaXJjbGVcIn0sYnQ9XCJFTVBUWVwiLE10PTEsRHQ9MixBdD0zLEZ0PTQsR3Q9NSxxdD02O2Zvcihjb25zdCB0IGluIHZ0KXZ0W3RdLnRvVXBwZXJDYXNlKCk7Y2xhc3MgQnR7Y29uc3RydWN0b3IodCl7dGhpcy53a3Q9dCx0aGlzLmluZGV4Xz0tMX1pc0FscGhhXyh0KXtyZXR1cm4gdD49XCJhXCImJnQ8PVwielwifHx0Pj1cIkFcIiYmdDw9XCJaXCJ9aXNOdW1lcmljXyh0LGUpe3JldHVybiB0Pj1cIjBcIiYmdDw9XCI5XCJ8fFwiLlwiPT10JiYhKHZvaWQgMCE9PWUmJmUpfWlzV2hpdGVTcGFjZV8odCl7cmV0dXJuXCIgXCI9PXR8fFwiXFx0XCI9PXR8fFwiXFxyXCI9PXR8fFwiXFxuXCI9PXR9bmV4dENoYXJfKCl7cmV0dXJuIHRoaXMud2t0LmNoYXJBdCgrK3RoaXMuaW5kZXhfKX1uZXh0VG9rZW4oKXtjb25zdCB0PXRoaXMubmV4dENoYXJfKCksZT10aGlzLmluZGV4XztsZXQgbixzPXQ7aWYoXCIoXCI9PXQpbj1EdDtlbHNlIGlmKFwiLFwiPT10KW49R3Q7ZWxzZSBpZihcIilcIj09dCluPUF0O2Vsc2UgaWYodGhpcy5pc051bWVyaWNfKHQpfHxcIi1cIj09dCluPUZ0LHM9dGhpcy5yZWFkTnVtYmVyXygpO2Vsc2UgaWYodGhpcy5pc0FscGhhXyh0KSluPU10LHM9dGhpcy5yZWFkVGV4dF8oKTtlbHNle2lmKHRoaXMuaXNXaGl0ZVNwYWNlXyh0KSlyZXR1cm4gdGhpcy5uZXh0VG9rZW4oKTtpZihcIlwiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIrdCk7bj1xdH1yZXR1cm57cG9zaXRpb246ZSx2YWx1ZTpzLHR5cGU6bn19cmVhZE51bWJlcl8oKXtsZXQgdDtjb25zdCBlPXRoaXMuaW5kZXhfO2xldCBuPSExLHM9ITE7ZG97XCIuXCI9PXQ/bj0hMDpcImVcIiE9dCYmXCJFXCIhPXR8fChzPSEwKSx0PXRoaXMubmV4dENoYXJfKCl9d2hpbGUodGhpcy5pc051bWVyaWNfKHQsbil8fCFzJiYoXCJlXCI9PXR8fFwiRVwiPT10KXx8cyYmKFwiLVwiPT10fHxcIitcIj09dCkpO3JldHVybiBwYXJzZUZsb2F0KHRoaXMud2t0LnN1YnN0cmluZyhlLHRoaXMuaW5kZXhfLS0pKX1yZWFkVGV4dF8oKXtsZXQgdDtjb25zdCBlPXRoaXMuaW5kZXhfO2Rve3Q9dGhpcy5uZXh0Q2hhcl8oKX13aGlsZSh0aGlzLmlzQWxwaGFfKHQpKTtyZXR1cm4gdGhpcy53a3Quc3Vic3RyaW5nKGUsdGhpcy5pbmRleF8tLSkudG9VcHBlckNhc2UoKX19Y2xhc3MgWXR7Y29uc3RydWN0b3IodCxlKXt0aGlzLmxleGVyXz10LHRoaXMudG9rZW5fLHRoaXMubGF5b3V0Xz1UdCx0aGlzLmZhY3Rvcnk9ZX1jb25zdW1lXygpe3RoaXMudG9rZW5fPXRoaXMubGV4ZXJfLm5leHRUb2tlbigpfWlzVG9rZW5UeXBlKHQpe3JldHVybiB0aGlzLnRva2VuXy50eXBlPT10fW1hdGNoKHQpe2NvbnN0IGU9dGhpcy5pc1Rva2VuVHlwZSh0KTtyZXR1cm4gZSYmdGhpcy5jb25zdW1lXygpLGV9cGFyc2UoKXt0aGlzLmNvbnN1bWVfKCk7cmV0dXJuIHRoaXMucGFyc2VHZW9tZXRyeV8oKX1wYXJzZUdlb21ldHJ5TGF5b3V0Xygpe2xldCB0PVR0O2NvbnN0IGU9dGhpcy50b2tlbl87aWYodGhpcy5pc1Rva2VuVHlwZShNdCkpe2NvbnN0IG49ZS52YWx1ZTtcIlpcIj09PW4/dD1SdDpcIk1cIj09PW4/dD1QdDpcIlpNXCI9PT1uJiYodD1PdCksdCE9PVR0JiZ0aGlzLmNvbnN1bWVfKCl9cmV0dXJuIHR9cGFyc2VHZW9tZXRyeUNvbGxlY3Rpb25UZXh0Xygpe2lmKHRoaXMubWF0Y2goRHQpKXtjb25zdCB0PVtdO2Rve3QucHVzaCh0aGlzLnBhcnNlR2VvbWV0cnlfKCkpfXdoaWxlKHRoaXMubWF0Y2goR3QpKTtpZih0aGlzLm1hdGNoKEF0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VQb2ludFRleHRfKCl7aWYodGhpcy5tYXRjaChEdCkpe2NvbnN0IHQ9dGhpcy5wYXJzZVBvaW50XygpO2lmKHRoaXMubWF0Y2goQXQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuIG51bGw7dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZUxpbmVTdHJpbmdUZXh0Xygpe2lmKHRoaXMubWF0Y2goRHQpKXtjb25zdCB0PXRoaXMucGFyc2VQb2ludExpc3RfKCk7aWYodGhpcy5tYXRjaChBdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlUG9seWdvblRleHRfKCl7aWYodGhpcy5tYXRjaChEdCkpe2NvbnN0IHQ9dGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0TGlzdF8oKTtpZih0aGlzLm1hdGNoKEF0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VNdWx0aVBvaW50VGV4dF8oKXtpZih0aGlzLm1hdGNoKER0KSl7bGV0IHQ7aWYodD10aGlzLnRva2VuXy50eXBlPT1EdD90aGlzLnBhcnNlUG9pbnRUZXh0TGlzdF8oKTp0aGlzLnBhcnNlUG9pbnRMaXN0XygpLHRoaXMubWF0Y2goQXQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZU11bHRpTGluZVN0cmluZ1RleHRfKCl7aWYodGhpcy5tYXRjaChEdCkpe2NvbnN0IHQ9dGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0TGlzdF8oKTtpZih0aGlzLm1hdGNoKEF0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VNdWx0aVBvbHlnb25UZXh0Xygpe2lmKHRoaXMubWF0Y2goRHQpKXtjb25zdCB0PXRoaXMucGFyc2VQb2x5Z29uVGV4dExpc3RfKCk7aWYodGhpcy5tYXRjaChBdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlUG9pbnRfKCl7Y29uc3QgdD1bXSxlPXRoaXMubGF5b3V0Xy5sZW5ndGg7Zm9yKGxldCBuPTA7bjxlOysrbil7Y29uc3QgZT10aGlzLnRva2VuXztpZighdGhpcy5tYXRjaChGdCkpYnJlYWs7dC5wdXNoKGUudmFsdWUpfWlmKHQubGVuZ3RoPT1lKXJldHVybiB0O3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VQb2ludExpc3RfKCl7Y29uc3QgdD1bdGhpcy5wYXJzZVBvaW50XygpXTtmb3IoO3RoaXMubWF0Y2goR3QpOyl0LnB1c2godGhpcy5wYXJzZVBvaW50XygpKTtyZXR1cm4gdH1wYXJzZVBvaW50VGV4dExpc3RfKCl7Y29uc3QgdD1bdGhpcy5wYXJzZVBvaW50VGV4dF8oKV07Zm9yKDt0aGlzLm1hdGNoKEd0KTspdC5wdXNoKHRoaXMucGFyc2VQb2ludFRleHRfKCkpO3JldHVybiB0fXBhcnNlTGluZVN0cmluZ1RleHRMaXN0Xygpe2NvbnN0IHQ9W3RoaXMucGFyc2VMaW5lU3RyaW5nVGV4dF8oKV07Zm9yKDt0aGlzLm1hdGNoKEd0KTspdC5wdXNoKHRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dF8oKSk7cmV0dXJuIHR9cGFyc2VQb2x5Z29uVGV4dExpc3RfKCl7Y29uc3QgdD1bdGhpcy5wYXJzZVBvbHlnb25UZXh0XygpXTtmb3IoO3RoaXMubWF0Y2goR3QpOyl0LnB1c2godGhpcy5wYXJzZVBvbHlnb25UZXh0XygpKTtyZXR1cm4gdH1pc0VtcHR5R2VvbWV0cnlfKCl7Y29uc3QgdD10aGlzLmlzVG9rZW5UeXBlKE10KSYmdGhpcy50b2tlbl8udmFsdWU9PWJ0O3JldHVybiB0JiZ0aGlzLmNvbnN1bWVfKCksdH1mb3JtYXRFcnJvck1lc3NhZ2VfKCl7cmV0dXJuXCJVbmV4cGVjdGVkIGBcIit0aGlzLnRva2VuXy52YWx1ZStcImAgYXQgcG9zaXRpb24gXCIrdGhpcy50b2tlbl8ucG9zaXRpb24rXCIgaW4gYFwiK3RoaXMubGV4ZXJfLndrdCtcImBcIn1wYXJzZUdlb21ldHJ5Xygpe2NvbnN0IHQ9dGhpcy5mYWN0b3J5LGU9dD0+bmV3IG0oLi4udCksbj1uPT57Y29uc3Qgcz1uLm1hcCgobj0+dC5jcmVhdGVMaW5lYXJSaW5nKG4ubWFwKGUpKSkpO3JldHVybiBzLmxlbmd0aD4xP3QuY3JlYXRlUG9seWdvbihzWzBdLHMuc2xpY2UoMSkpOnQuY3JlYXRlUG9seWdvbihzWzBdKX0scz10aGlzLnRva2VuXztpZih0aGlzLm1hdGNoKE10KSl7Y29uc3QgaT1zLnZhbHVlO2lmKHRoaXMubGF5b3V0Xz10aGlzLnBhcnNlR2VvbWV0cnlMYXlvdXRfKCksXCJHRU9NRVRSWUNPTExFQ1RJT05cIj09aSl7Y29uc3QgZT10aGlzLnBhcnNlR2VvbWV0cnlDb2xsZWN0aW9uVGV4dF8oKTtyZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9c3dpdGNoKGkpe2Nhc2VcIlBPSU5UXCI6e2NvbnN0IGU9dGhpcy5wYXJzZVBvaW50VGV4dF8oKTtyZXR1cm4gZT90LmNyZWF0ZVBvaW50KG5ldyBtKC4uLmUpKTp0LmNyZWF0ZVBvaW50KCl9Y2FzZVwiTElORVNUUklOR1wiOntjb25zdCBuPXRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dF8oKS5tYXAoZSk7cmV0dXJuIHQuY3JlYXRlTGluZVN0cmluZyhuKX1jYXNlXCJMSU5FQVJSSU5HXCI6e2NvbnN0IG49dGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpLm1hcChlKTtyZXR1cm4gdC5jcmVhdGVMaW5lYXJSaW5nKG4pfWNhc2VcIlBPTFlHT05cIjp7Y29uc3QgZT10aGlzLnBhcnNlUG9seWdvblRleHRfKCk7cmV0dXJuIGUmJjAhPT1lLmxlbmd0aD9uKGUpOnQuY3JlYXRlUG9seWdvbigpfWNhc2VcIk1VTFRJUE9JTlRcIjp7Y29uc3Qgbj10aGlzLnBhcnNlTXVsdGlQb2ludFRleHRfKCk7aWYoIW58fDA9PT1uLmxlbmd0aClyZXR1cm4gdC5jcmVhdGVNdWx0aVBvaW50KCk7Y29uc3Qgcz1uLm1hcChlKS5tYXAoKGU9PnQuY3JlYXRlUG9pbnQoZSkpKTtyZXR1cm4gdC5jcmVhdGVNdWx0aVBvaW50KHMpfWNhc2VcIk1VTFRJTElORVNUUklOR1wiOntjb25zdCBuPXRoaXMucGFyc2VNdWx0aUxpbmVTdHJpbmdUZXh0XygpLm1hcCgobj0+dC5jcmVhdGVMaW5lU3RyaW5nKG4ubWFwKGUpKSkpO3JldHVybiB0LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuKX1jYXNlXCJNVUxUSVBPTFlHT05cIjp7Y29uc3QgZT10aGlzLnBhcnNlTXVsdGlQb2x5Z29uVGV4dF8oKTtpZighZXx8MD09PWUubGVuZ3RoKXJldHVybiB0LmNyZWF0ZU11bHRpUG9seWdvbigpO2NvbnN0IHM9ZS5tYXAobik7cmV0dXJuIHQuY3JlYXRlTXVsdGlQb2x5Z29uKHMpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBnZW9tZXRyeSB0eXBlOiBcIitpKX19dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX19ZnVuY3Rpb24gVnQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuXCJcIjtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpLG49W2UueCxlLnldO3JldHVybiB2b2lkIDA9PT1lLnp8fE51bWJlci5pc05hTihlLnopfHxuLnB1c2goZS56KSx2b2lkIDA9PT1lLm18fE51bWJlci5pc05hTihlLm0pfHxuLnB1c2goZS5tKSxuLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIHp0KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLm1hcCgodD0+e2NvbnN0IGU9W3QueCx0LnldO3JldHVybiB2b2lkIDA9PT10Lnp8fE51bWJlci5pc05hTih0LnopfHxlLnB1c2godC56KSx2b2lkIDA9PT10Lm18fE51bWJlci5pc05hTih0Lm0pfHxlLnB1c2godC5tKSxlfSkpLG49W107Zm9yKGxldCB0PTAscz1lLmxlbmd0aDt0PHM7Kyt0KW4ucHVzaChlW3RdLmpvaW4oXCIgXCIpKTtyZXR1cm4gbi5qb2luKFwiLCBcIil9ZnVuY3Rpb24gWHQodCl7Y29uc3QgZT1bXTtlLnB1c2goXCIoXCIrenQodC5nZXRFeHRlcmlvclJpbmcoKSkrXCIpXCIpO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1JbnRlcmlvclJpbmcoKTtuPHM7KytuKWUucHVzaChcIihcIit6dCh0LmdldEludGVyaW9yUmluZ04obikpK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9Y29uc3Qga3Q9e1BvaW50OlZ0LExpbmVTdHJpbmc6enQsTGluZWFyUmluZzp6dCxQb2x5Z29uOlh0LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MCxzPXQuZ2V0TnVtR2VvbWV0cmllcygpO248czsrK24pZS5wdXNoKFwiKFwiK1Z0KHQuZ2V0R2VvbWV0cnlOKG4pKStcIilcIik7cmV0dXJuIGUuam9pbihcIiwgXCIpfSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MCxzPXQuZ2V0TnVtR2VvbWV0cmllcygpO248czsrK24pZS5wdXNoKFwiKFwiK3p0KHQuZ2V0R2VvbWV0cnlOKG4pKStcIilcIik7cmV0dXJuIGUuam9pbihcIiwgXCIpfSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MCxzPXQuZ2V0TnVtR2VvbWV0cmllcygpO248czsrK24pZS5wdXNoKFwiKFwiK1h0KHQuZ2V0R2VvbWV0cnlOKG4pKStcIilcIik7cmV0dXJuIGUuam9pbihcIiwgXCIpfSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MCxzPXQuZ2V0TnVtR2VvbWV0cmllcygpO248czsrK24pZS5wdXNoKFV0KHQuZ2V0R2VvbWV0cnlOKG4pKSk7cmV0dXJuIGUuam9pbihcIiwgXCIpfX07ZnVuY3Rpb24gVXQodCl7bGV0IGU9dC5nZXRHZW9tZXRyeVR5cGUoKTtjb25zdCBuPWt0W2VdO2U9ZS50b1VwcGVyQ2FzZSgpO2NvbnN0IHM9ZnVuY3Rpb24odCl7bGV0IGU9XCJcIjtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZTtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZSgpO3JldHVybiB2b2lkIDA9PT1uLnp8fE51bWJlci5pc05hTihuLnopfHwoZSs9XCJaXCIpLHZvaWQgMD09PW4ubXx8TnVtYmVyLmlzTmFOKG4ubSl8fChlKz1cIk1cIiksZX0odCk7aWYocy5sZW5ndGg+MCYmKGUrPVwiIFwiK3MpLHQuaXNFbXB0eSgpKXJldHVybiBlK1wiIFwiK2J0O3JldHVybiBlK1wiIChcIituKHQpK1wiKVwifWNsYXNzIEh0e2NvbnN0cnVjdG9yKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBMdCx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCl9cmVhZCh0KXtjb25zdCBlPW5ldyBCdCh0KTtyZXR1cm4gbmV3IFl0KGUsdGhpcy5nZW9tZXRyeUZhY3RvcnkpLnBhcnNlKCl9d3JpdGUodCl7cmV0dXJuIFV0KHQpfX1jbGFzcyBXdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgSHQodCl9d3JpdGUodCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfXN0YXRpYyB0b0xpbmVTdHJpbmcodCxlKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7cmV0dXJuXCJMSU5FU1RSSU5HICggXCIrdC54K1wiIFwiK3QueStcIiwgXCIrZS54K1wiIFwiK2UueStcIiApXCJ9fWNsYXNzIFp0e2NvbnN0cnVjdG9yKCl7WnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVzdWx0PW51bGwsdGhpcy5faW5wdXRMaW5lcz1BcnJheSgyKS5maWxsKCkubWFwKCgoKT0+QXJyYXkoMikpKSx0aGlzLl9pbnRQdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9pbnRMaW5lSW5kZXg9bnVsbCx0aGlzLl9pc1Byb3Blcj1udWxsLHRoaXMuX3BhPW51bGwsdGhpcy5fcGI9bnVsbCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2ludFB0WzBdPW5ldyBtLHRoaXMuX2ludFB0WzFdPW5ldyBtLHRoaXMuX3BhPXRoaXMuX2ludFB0WzBdLHRoaXMuX3BiPXRoaXMuX2ludFB0WzFdLHRoaXMuX3Jlc3VsdD0wfXN0YXRpYyBjb21wdXRlRWRnZURpc3RhbmNlKHQsZSxuKXtjb25zdCBzPU1hdGguYWJzKG4ueC1lLngpLGk9TWF0aC5hYnMobi55LWUueSk7bGV0IHI9LTE7aWYodC5lcXVhbHMoZSkpcj0wO2Vsc2UgaWYodC5lcXVhbHMobikpcj1zPmk/czppO2Vsc2V7Y29uc3Qgbj1NYXRoLmFicyh0LngtZS54KSxvPU1hdGguYWJzKHQueS1lLnkpO3I9cz5pP246bywwIT09cnx8dC5lcXVhbHMoZSl8fChyPU1hdGgubWF4KG4sbykpfXJldHVybiBnLmlzVHJ1ZSghKDA9PT1yJiYhdC5lcXVhbHMoZSkpLFwiQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHJ9c3RhdGljIG5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnkscj1NYXRoLnNxcnQocypzK2kqaSk7cmV0dXJuIGcuaXNUcnVlKCEoMD09PXImJiF0LmVxdWFscyhlKSksXCJJbnZhbGlkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHJ9Z2V0SW5kZXhBbG9uZ1NlZ21lbnQodCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5faW50TGluZUluZGV4W3RdW2VdfWdldFRvcG9sb2d5U3VtbWFyeSgpe2NvbnN0IHQ9bmV3IHB0O3JldHVybiB0aGlzLmlzRW5kUG9pbnQoKSYmdC5hcHBlbmQoXCIgZW5kcG9pbnRcIiksdGhpcy5faXNQcm9wZXImJnQuYXBwZW5kKFwiIHByb3BlclwiKSx0aGlzLmlzQ29sbGluZWFyKCkmJnQuYXBwZW5kKFwiIGNvbGxpbmVhclwiKSx0LnRvU3RyaW5nKCl9Y29tcHV0ZUludGVyc2VjdGlvbih0LGUsbixzKXt0aGlzLl9pbnB1dExpbmVzWzBdWzBdPXQsdGhpcy5faW5wdXRMaW5lc1swXVsxXT1lLHRoaXMuX2lucHV0TGluZXNbMV1bMF09bix0aGlzLl9pbnB1dExpbmVzWzFdWzFdPXMsdGhpcy5fcmVzdWx0PXRoaXMuY29tcHV0ZUludGVyc2VjdCh0LGUsbixzKX1nZXRJbnRlcnNlY3Rpb25OdW0oKXtyZXR1cm4gdGhpcy5fcmVzdWx0fWNvbXB1dGVJbnRMaW5lSW5kZXgoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCludWxsPT09dGhpcy5faW50TGluZUluZGV4JiYodGhpcy5faW50TGluZUluZGV4PUFycmF5KDIpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgyKSkpLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMSkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMCk+dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwxKT8odGhpcy5faW50TGluZUluZGV4W3RdWzBdPTAsdGhpcy5faW50TGluZUluZGV4W3RdWzFdPTEpOih0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMF09MSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMV09MCl9fWlzUHJvcGVyKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2lzUHJvcGVyfXNldFByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3ByZWNpc2lvbk1vZGVsPXR9aXNJbnRlcmlvckludGVyc2VjdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDApfHwhIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigxKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9yZXN1bHQ7ZSsrKWlmKCF0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLl9pbnB1dExpbmVzW3RdWzBdKSYmIXRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHRoaXMuX2lucHV0TGluZXNbdF1bMV0pKXJldHVybiEwO3JldHVybiExfX1nZXRJbnRlcnNlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2ludFB0W3RdfWlzRW5kUG9pbnQoKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9yZXN1bHQhPT1adC5OT19JTlRFUlNFQ1RJT059Z2V0RWRnZURpc3RhbmNlKHQsZSl7cmV0dXJuIFp0LmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5faW50UHRbZV0sdGhpcy5faW5wdXRMaW5lc1t0XVswXSx0aGlzLl9pbnB1dExpbmVzW3RdWzFdKX1pc0NvbGxpbmVhcigpe3JldHVybiB0aGlzLl9yZXN1bHQ9PT1adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLHRoaXMuX2lucHV0TGluZXNbMF1bMV0pK1wiIC0gXCIrV3QudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sdGhpcy5faW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX1nZXRFbmRwb2ludCh0LGUpe3JldHVybiB0aGlzLl9pbnB1dExpbmVzW3RdW2VdfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcmVzdWx0O2UrKylpZih0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0KSlyZXR1cm4hMDtyZXR1cm4hMX1nZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQodCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5faW50UHRbdGhpcy5faW50TGluZUluZGV4W3RdW2VdXX19WnQuRE9OVF9JTlRFUlNFQ1Q9MCxadC5ET19JTlRFUlNFQ1Q9MSxadC5DT0xMSU5FQVI9MixadC5OT19JTlRFUlNFQ1RJT049MCxadC5QT0lOVF9JTlRFUlNFQ1RJT049MSxadC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OPTI7Y2xhc3MganQgZXh0ZW5kcyBadHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9c3RhdGljIG5lYXJlc3RFbmRwb2ludCh0LGUsbixzKXtsZXQgaT10LHI9ei5wb2ludFRvU2VnbWVudCh0LG4scyksbz16LnBvaW50VG9TZWdtZW50KGUsbixzKTtyZXR1cm4gbzxyJiYocj1vLGk9ZSksbz16LnBvaW50VG9TZWdtZW50KG4sdCxlKSxvPHImJihyPW8saT1uKSxvPXoucG9pbnRUb1NlZ21lbnQocyx0LGUpLG88ciYmKHI9byxpPXMpLGl9aXNJblNlZ21lbnRFbnZlbG9wZXModCl7Y29uc3QgZT1uZXcgTyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLHRoaXMuX2lucHV0TGluZXNbMF1bMV0pLG49bmV3IE8odGhpcy5faW5wdXRMaW5lc1sxXVswXSx0aGlzLl9pbnB1dExpbmVzWzFdWzFdKTtyZXR1cm4gZS5jb250YWlucyh0KSYmbi5jb250YWlucyh0KX1jb21wdXRlSW50ZXJzZWN0aW9uKCl7aWYoMyE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHN1cGVyLmNvbXB1dGVJbnRlcnNlY3Rpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLl9pc1Byb3Blcj0hMSxPLmludGVyc2VjdHMoZSxuLHQpJiYwPT09cS5pbmRleChlLG4sdCkmJjA9PT1xLmluZGV4KG4sZSx0KSlyZXR1cm4gdGhpcy5faXNQcm9wZXI9ITAsKHQuZXF1YWxzKGUpfHx0LmVxdWFscyhuKSkmJih0aGlzLl9pc1Byb3Blcj0hMSksdGhpcy5fcmVzdWx0PVp0LlBPSU5UX0lOVEVSU0VDVElPTixudWxsO3RoaXMuX3Jlc3VsdD1adC5OT19JTlRFUlNFQ1RJT059fWludGVyc2VjdGlvbih0LGUsbixzKXtsZXQgaT10aGlzLmludGVyc2VjdGlvblNhZmUodCxlLG4scyk7cmV0dXJuIHRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMoaSl8fChpPW5ldyBtKGp0Lm5lYXJlc3RFbmRwb2ludCh0LGUsbixzKSkpLG51bGwhPT10aGlzLl9wcmVjaXNpb25Nb2RlbCYmdGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoaSksaX1jaGVja0REKHQsZSxuLHMsaSl7Y29uc3Qgcj1GLmludGVyc2VjdGlvbih0LGUsbixzKSxvPXRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMocik7WS5vdXQucHJpbnRsbihcIkREIGluIGVudiA9IFwiK28rXCIgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcIityKSxpLmRpc3RhbmNlKHIpPjFlLTQmJlkub3V0LnByaW50bG4oXCJEaXN0YW5jZSA9IFwiK2kuZGlzdGFuY2UocikpfWludGVyc2VjdGlvblNhZmUodCxlLG4scyl7bGV0IGk9Qi5pbnRlcnNlY3Rpb24odCxlLG4scyk7cmV0dXJuIG51bGw9PT1pJiYoaT1qdC5uZWFyZXN0RW5kcG9pbnQodCxlLG4scykpLGl9Y29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPU8uaW50ZXJzZWN0cyh0LGUsbikscj1PLmludGVyc2VjdHModCxlLHMpLG89Ty5pbnRlcnNlY3RzKG4scyx0KSxsPU8uaW50ZXJzZWN0cyhuLHMsZSk7cmV0dXJuIGkmJnI/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09cyxadC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpvJiZsPyh0aGlzLl9pbnRQdFswXT10LHRoaXMuX2ludFB0WzFdPWUsWnQuQ09MTElORUFSX0lOVEVSU0VDVElPTik6aSYmbz8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT10LCFuLmVxdWFscyh0KXx8cnx8bD9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6aSYmbD8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT1lLCFuLmVxdWFscyhlKXx8cnx8bz9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6ciYmbz8odGhpcy5faW50UHRbMF09cyx0aGlzLl9pbnRQdFsxXT10LCFzLmVxdWFscyh0KXx8aXx8bD9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6ciYmbD8odGhpcy5faW50UHRbMF09cyx0aGlzLl9pbnRQdFsxXT1lLCFzLmVxdWFscyhlKXx8aXx8bz9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6WnQuTk9fSU5URVJTRUNUSU9OfWNvbXB1dGVJbnRlcnNlY3QodCxlLG4scyl7aWYodGhpcy5faXNQcm9wZXI9ITEsIU8uaW50ZXJzZWN0cyh0LGUsbixzKSlyZXR1cm4gWnQuTk9fSU5URVJTRUNUSU9OO2NvbnN0IGk9cS5pbmRleCh0LGUsbikscj1xLmluZGV4KHQsZSxzKTtpZihpPjAmJnI+MHx8aTwwJiZyPDApcmV0dXJuIFp0Lk5PX0lOVEVSU0VDVElPTjtjb25zdCBvPXEuaW5kZXgobixzLHQpLGw9cS5pbmRleChuLHMsZSk7aWYobz4wJiZsPjB8fG88MCYmbDwwKXJldHVybiBadC5OT19JTlRFUlNFQ1RJT047cmV0dXJuIDA9PT1pJiYwPT09ciYmMD09PW8mJjA9PT1sP3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixzKTooMD09PWl8fDA9PT1yfHwwPT09b3x8MD09PWw/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQocyk/dGhpcy5faW50UHRbMF09dDplLmVxdWFsczJEKG4pfHxlLmVxdWFsczJEKHMpP3RoaXMuX2ludFB0WzBdPWU6MD09PWk/dGhpcy5faW50UHRbMF09bmV3IG0obik6MD09PXI/dGhpcy5faW50UHRbMF09bmV3IG0ocyk6MD09PW8/dGhpcy5faW50UHRbMF09bmV3IG0odCk6MD09PWwmJih0aGlzLl9pbnRQdFswXT1uZXcgbShlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLl9pbnRQdFswXT10aGlzLmludGVyc2VjdGlvbih0LGUsbixzKSksWnQuUE9JTlRfSU5URVJTRUNUSU9OKX19Y2xhc3MgS3R7Y29uc3RydWN0b3IoKXtLdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUt0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IG0sbmV3IG0pO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0t0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnAwPXQsdGhpcy5wMT1lfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO0t0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IG0odCxlKSxuZXcgbShuLHMpKX19c3RhdGljIG1pZFBvaW50KHQsZSl7cmV0dXJuIG5ldyBtKCh0LngrZS54KS8yLCh0LnkrZS55KS8yKX1taW5YKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueCx0aGlzLnAxLngpfW9yaWVudGF0aW9uSW5kZXgoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXEuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDApLG49cS5pbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMSk7cmV0dXJuIGU+PTAmJm4+PTB8fGU8PTAmJm48PTA/TWF0aC5tYXgoZSxuKTowfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHEuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQpfX10b0dlb21ldHJ5KHQpe3JldHVybiB0LmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMucDAsdGhpcy5wMV0pfWlzVmVydGljYWwoKXtyZXR1cm4gdGhpcy5wMC54PT09dGhpcy5wMS54fWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBLdCkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLnAwLmVxdWFscyhlLnAwKSYmdGhpcy5wMS5lcXVhbHMoZS5wMSl9aW50ZXJzZWN0aW9uKHQpe2NvbnN0IGU9bmV3IGp0O3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfXByb2plY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuZXF1YWxzKHRoaXMucDApfHx0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gbmV3IG0odCk7Y29uc3QgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgbTtyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMCksbj10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMSk7aWYoZT49MSYmbj49MSlyZXR1cm4gbnVsbDtpZihlPD0wJiZuPD0wKXJldHVybiBudWxsO2xldCBzPXRoaXMucHJvamVjdCh0LnAwKTtlPDAmJihzPXRoaXMucDApLGU+MSYmKHM9dGhpcy5wMSk7bGV0IGk9dGhpcy5wcm9qZWN0KHQucDEpO3JldHVybiBuPDAmJihpPXRoaXMucDApLG4+MSYmKGk9dGhpcy5wMSksbmV3IEt0KHMsaSl9fW5vcm1hbGl6ZSgpe3RoaXMucDEuY29tcGFyZVRvKHRoaXMucDApPDAmJnRoaXMucmV2ZXJzZSgpfWFuZ2xlKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX1nZXRDb29yZGluYXRlKHQpe3JldHVybiAwPT09dD90aGlzLnAwOnRoaXMucDF9ZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHQpe3JldHVybiB6LnBvaW50VG9MaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9bWluWSgpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLnksdGhpcy5wMS55KX1taWRQb2ludCgpe3JldHVybiBLdC5taWRQb2ludCh0aGlzLnAwLHRoaXMucDEpfXByb2plY3Rpb25GYWN0b3IodCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7Y29uc3QgZT10aGlzLnAxLngtdGhpcy5wMC54LG49dGhpcy5wMS55LXRoaXMucDAueSxzPWUqZStuKm47aWYoczw9MClyZXR1cm4gci5OYU47cmV0dXJuKCh0LngtdGhpcy5wMC54KSplKyh0LnktdGhpcy5wMC55KSpuKS9zfWNsb3Nlc3RQb2ludHModCl7Y29uc3QgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTtjb25zdCBuPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2xldCBzPXIuTUFYX1ZBTFVFLGk9bnVsbDtjb25zdCBvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO3M9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO2NvbnN0IGw9dGhpcy5jbG9zZXN0UG9pbnQodC5wMSk7aT1sLmRpc3RhbmNlKHQucDEpLGk8cyYmKHM9aSxuWzBdPWwsblsxXT10LnAxKTtjb25zdCBhPXQuY2xvc2VzdFBvaW50KHRoaXMucDApO2k9YS5kaXN0YW5jZSh0aGlzLnAwKSxpPHMmJihzPWksblswXT10aGlzLnAwLG5bMV09YSk7Y29uc3QgYz10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gaT1jLmRpc3RhbmNlKHRoaXMucDEpLGk8cyYmKHM9aSxuWzBdPXRoaXMucDEsblsxXT1jKSxufWNsb3Nlc3RQb2ludCh0KXtjb25zdCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtpZihlPjAmJmU8MSlyZXR1cm4gdGhpcy5wcm9qZWN0KHQpO3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHQpPHRoaXMucDEuZGlzdGFuY2UodCk/dGhpcy5wMDp0aGlzLnAxfW1heFgoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LHRoaXMucDEueCl9Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMucDAuZGlzdGFuY2UodGhpcy5wMSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dCxuPXRoaXMucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnRoaXMucDEuY29tcGFyZVRvKGUucDEpfXJldmVyc2UoKXtjb25zdCB0PXRoaXMucDA7dGhpcy5wMD10aGlzLnAxLHRoaXMucDE9dH1lcXVhbHNUb3BvKHQpe3JldHVybiB0aGlzLnAwLmVxdWFscyh0LnAwKSYmdGhpcy5wMS5lcXVhbHModC5wMSl8fHRoaXMucDAuZXF1YWxzKHQucDEpJiZ0aGlzLnAxLmVxdWFscyh0LnAwKX1saW5lSW50ZXJzZWN0aW9uKHQpe3JldHVybiBCLmludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1tYXhZKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMucDAueSx0aGlzLnAxLnkpfXBvaW50QWxvbmdPZmZzZXQodCxlKXtjb25zdCBuPXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxzPXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxpPXRoaXMucDEueC10aGlzLnAwLngscj10aGlzLnAxLnktdGhpcy5wMC55LG89TWF0aC5zcXJ0KGkqaStyKnIpO2xldCBsPTAsYT0wO2lmKDAhPT1lKXtpZihvPD0wKXRocm93IG5ldyBEKFwiQ2Fubm90IGNvbXB1dGUgb2Zmc2V0IGZyb20gemVyby1sZW5ndGggbGluZSBzZWdtZW50XCIpO2w9ZSppL28sYT1lKnIvb31yZXR1cm4gbmV3IG0obi1hLHMrbCl9c2V0Q29vcmRpbmF0ZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb29yZGluYXRlcyh0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucDAueD10LngsdGhpcy5wMC55PXQueSx0aGlzLnAxLng9ZS54LHRoaXMucDEueT1lLnl9fXNlZ21lbnRGcmFjdGlvbih0KXtsZXQgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7cmV0dXJuIGU8MD9lPTA6KGU+MXx8ci5pc05hTihlKSkmJihlPTEpLGV9dG9TdHJpbmcoKXtyZXR1cm5cIkxJTkVTVFJJTkcoIFwiK3RoaXMucDAueCtcIiBcIit0aGlzLnAwLnkrXCIsIFwiK3RoaXMucDEueCtcIiBcIit0aGlzLnAxLnkrXCIpXCJ9aXNIb3Jpem9udGFsKCl7cmV0dXJuIHRoaXMucDAueT09PXRoaXMucDEueX1yZWZsZWN0KHQpe2NvbnN0IGU9dGhpcy5wMS5nZXRZKCktdGhpcy5wMC5nZXRZKCksbj10aGlzLnAwLmdldFgoKS10aGlzLnAxLmdldFgoKSxzPXRoaXMucDAuZ2V0WSgpKih0aGlzLnAxLmdldFgoKS10aGlzLnAwLmdldFgoKSktdGhpcy5wMC5nZXRYKCkqKHRoaXMucDEuZ2V0WSgpLXRoaXMucDAuZ2V0WSgpKSxpPWUqZStuKm4scj1lKmUtbipuLG89dC5nZXRYKCksbD10LmdldFkoKTtyZXR1cm4gbmV3IG0oKC1yKm8tMiplKm4qbC0yKmUqcykvaSwocipsLTIqZSpuKm8tMipuKnMpL2kpfWRpc3RhbmNlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHouc2VnbWVudFRvU2VnbWVudCh0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB6LnBvaW50VG9TZWdtZW50KHQsdGhpcy5wMCx0aGlzLnAxKX19cG9pbnRBbG9uZyh0KXtjb25zdCBlPW5ldyBtO3JldHVybiBlLng9dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLGUueT10aGlzLnAwLnkrdCoodGhpcy5wMS55LXRoaXMucDAueSksZX1oYXNoQ29kZSgpe2xldCB0PXIuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLngpO3RePTMxKnIuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLnkpO2NvbnN0IGU9TWF0aC50cnVuYyh0KV5NYXRoLnRydW5jKHQ+PjMyKTtsZXQgbj1yLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS54KTtuXj0zMSpyLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS55KTtyZXR1cm4gZV4oTWF0aC50cnVuYyhuKV5NYXRoLnRydW5jKG4+PjMyKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW28sY119fWNsYXNzIFF0e3N0YXRpYyB0b0xvY2F0aW9uU3ltYm9sKHQpe3N3aXRjaCh0KXtjYXNlIFF0LkVYVEVSSU9SOnJldHVyblwiZVwiO2Nhc2UgUXQuQk9VTkRBUlk6cmV0dXJuXCJiXCI7Y2FzZSBRdC5JTlRFUklPUjpyZXR1cm5cImlcIjtjYXNlIFF0Lk5PTkU6cmV0dXJuXCItXCJ9dGhyb3cgbmV3IHMoXCJVbmtub3duIGxvY2F0aW9uIHZhbHVlOiBcIit0KX19UXQuSU5URVJJT1I9MCxRdC5CT1VOREFSWT0xLFF0LkVYVEVSSU9SPTIsUXQuTk9ORT0tMTtjbGFzcyBKdHtjb25zdHJ1Y3Rvcigpe0p0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX21hdHJpeD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX21hdHJpeD1BcnJheSgzKS5maWxsKCkubWFwKCgoKT0+QXJyYXkoMykpKSx0aGlzLnNldEFsbChRLkZBTFNFKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0p0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuc2V0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBKdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07SnQuY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl09dC5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0sdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV09dC5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV0sdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl09dC5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl0sdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl09dC5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl0sdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5CT1VOREFSWV09dC5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5CT1VOREFSWV0sdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5FWFRFUklPUl09dC5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5FWFRFUklPUl0sdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl09dC5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl0sdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV09dC5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV0sdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5FWFRFUklPUl09dC5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5FWFRFUklPUl19fXN0YXRpYyBtYXRjaGVzKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gZT09PVEuU1lNX0RPTlRDQVJFfHwoZT09PVEuU1lNX1RSVUUmJih0Pj0wfHx0PT09US5UUlVFKXx8KGU9PT1RLlNZTV9GQUxTRSYmdD09PVEuRkFMU0V8fChlPT09US5TWU1fUCYmdD09PVEuUHx8KGU9PT1RLlNZTV9MJiZ0PT09US5MfHxlPT09US5TWU1fQSYmdD09PVEuQSkpKSl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBKdChhcmd1bWVudHNbMF0pLm1hdGNoZXModCl9fXN0YXRpYyBpc1RydWUodCl7cmV0dXJuIHQ+PTB8fHQ9PT1RLlRSVUV9aXNJbnRlcnNlY3RzKCl7cmV0dXJuIXRoaXMuaXNEaXNqb2ludCgpfWlzQ292ZXJzKCl7cmV0dXJuKEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXSkpJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldPT09US5GQUxTRX1pc0NvdmVyZWRCeSgpe3JldHVybihKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5CT1VOREFSWV0pKSYmdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXT09PVEuRkFMU0V9c2V0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPU1hdGgudHJ1bmMoZS8zKSxzPWUlMzt0aGlzLl9tYXRyaXhbbl1bc109US50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWF0cml4W3RdW2VdPW59fWlzQ29udGFpbnMoKXtyZXR1cm4gSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXT09PVEuRkFMU0V9c2V0QXRMZWFzdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj1NYXRoLnRydW5jKGUvMykscz1lJTM7dGhpcy5zZXRBdExlYXN0KG4scyxRLnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWF0cml4W3RdW2VdPG4mJih0aGlzLl9tYXRyaXhbdF1bZV09bil9fXNldEF0TGVhc3RJZlZhbGlkKHQsZSxuKXt0Pj0wJiZlPj0wJiZ0aGlzLnNldEF0TGVhc3QodCxlLG4pfWlzV2l0aGluKCl7cmV0dXJuIEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5FWFRFUklPUl09PT1RLkZBTFNFfWlzVG91Y2hlcyh0LGUpe3JldHVybiB0PmU/dGhpcy5pc1RvdWNoZXMoZSx0KToodD09PVEuQSYmZT09PVEuQXx8dD09PVEuTCYmZT09PVEuTHx8dD09PVEuTCYmZT09PVEuQXx8dD09PVEuUCYmZT09PVEuQXx8dD09PVEuUCYmZT09PVEuTCkmJih0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXT09PVEuRkFMU0UmJihKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5CT1VOREFSWV0pKSl9aXNPdmVybGFwcyh0LGUpe3JldHVybiB0PT09US5QJiZlPT09US5QfHx0PT09US5BJiZlPT09US5BP0p0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXSkmJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXSk6dD09PVEuTCYmZT09PVEuTCYmKDE9PT10aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdKSl9aXNFcXVhbHModCxlKXtyZXR1cm4gdD09PWUmJihKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXT09PVEuRkFMU0UpfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgcHQoXCIxMjM0NTY3ODlcIik7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXQuc2V0Q2hhckF0KDMqZStuLFEudG9EaW1lbnNpb25TeW1ib2wodGhpcy5fbWF0cml4W2VdW25dKSk7cmV0dXJuIHQudG9TdHJpbmcoKX1zZXRBbGwodCl7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXRoaXMuX21hdHJpeFtlXVtuXT10fWdldCh0LGUpe3JldHVybiB0aGlzLl9tYXRyaXhbdF1bZV19dHJhbnNwb3NlKCl7bGV0IHQ9dGhpcy5fbWF0cml4WzFdWzBdO3JldHVybiB0aGlzLl9tYXRyaXhbMV1bMF09dGhpcy5fbWF0cml4WzBdWzFdLHRoaXMuX21hdHJpeFswXVsxXT10LHQ9dGhpcy5fbWF0cml4WzJdWzBdLHRoaXMuX21hdHJpeFsyXVswXT10aGlzLl9tYXRyaXhbMF1bMl0sdGhpcy5fbWF0cml4WzBdWzJdPXQsdD10aGlzLl9tYXRyaXhbMl1bMV0sdGhpcy5fbWF0cml4WzJdWzFdPXRoaXMuX21hdHJpeFsxXVsyXSx0aGlzLl9tYXRyaXhbMV1bMl09dCx0aGlzfW1hdGNoZXModCl7aWYoOSE9PXQubGVuZ3RoKXRocm93IG5ldyBzKFwiU2hvdWxkIGJlIGxlbmd0aCA5OiBcIit0KTtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspaWYoIUp0Lm1hdGNoZXModGhpcy5fbWF0cml4W2VdW25dLHQuY2hhckF0KDMqZStuKSkpcmV0dXJuITE7cmV0dXJuITB9YWRkKHQpe2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0aGlzLnNldEF0TGVhc3QoZSxuLHQuZ2V0KGUsbikpfWlzRGlzam9pbnQoKXtyZXR1cm4gdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5CT1VOREFSWV09PT1RLkZBTFNFfWlzQ3Jvc3Nlcyh0LGUpe3JldHVybiB0PT09US5QJiZlPT09US5MfHx0PT09US5QJiZlPT09US5BfHx0PT09US5MJiZlPT09US5BP0p0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXSk6dD09PVEuTCYmZT09PVEuUHx8dD09PVEuQSYmZT09PVEuUHx8dD09PVEuQSYmZT09PVEuTD9KdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl0pOnQ9PT1RLkwmJmU9PT1RLkwmJjA9PT10aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fWNsYXNzICR0e3N0YXRpYyB0b0RlZ3JlZXModCl7cmV0dXJuIDE4MCp0L01hdGguUEl9c3RhdGljIG5vcm1hbGl6ZSh0KXtmb3IoO3Q+TWF0aC5QSTspdC09JHQuUElfVElNRVNfMjtmb3IoO3Q8PS1NYXRoLlBJOyl0Kz0kdC5QSV9USU1FU18yO3JldHVybiB0fXN0YXRpYyBhbmdsZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hdGFuMih0LnksdC54KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1lLngtdC54LHM9ZS55LXQueTtyZXR1cm4gTWF0aC5hdGFuMihzLG4pfX1zdGF0aWMgaXNBY3V0ZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueTtyZXR1cm4gcyoobi54LWUueCkraSoobi55LWUueSk+MH1zdGF0aWMgaXNPYnR1c2UodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnk7cmV0dXJuIHMqKG4ueC1lLngpK2kqKG4ueS1lLnkpPDB9c3RhdGljIGludGVyaW9yQW5nbGUodCxlLG4pe2NvbnN0IHM9JHQuYW5nbGUoZSx0KSxpPSR0LmFuZ2xlKGUsbik7cmV0dXJuIE1hdGguYWJzKGktcyl9c3RhdGljIG5vcm1hbGl6ZVBvc2l0aXZlKHQpe2lmKHQ8MCl7Zm9yKDt0PDA7KXQrPSR0LlBJX1RJTUVTXzI7dD49JHQuUElfVElNRVNfMiYmKHQ9MCl9ZWxzZXtmb3IoO3Q+PSR0LlBJX1RJTUVTXzI7KXQtPSR0LlBJX1RJTUVTXzI7dDwwJiYodD0wKX1yZXR1cm4gdH1zdGF0aWMgYW5nbGVCZXR3ZWVuKHQsZSxuKXtjb25zdCBzPSR0LmFuZ2xlKGUsdCksaT0kdC5hbmdsZShlLG4pO3JldHVybiAkdC5kaWZmKHMsaSl9c3RhdGljIGRpZmYodCxlKXtsZXQgbj1udWxsO3JldHVybiBuPXQ8ZT9lLXQ6dC1lLG4+TWF0aC5QSSYmKG49MipNYXRoLlBJLW4pLG59c3RhdGljIHRvUmFkaWFucyh0KXtyZXR1cm4gdCpNYXRoLlBJLzE4MH1zdGF0aWMgZ2V0VHVybih0LGUpe2NvbnN0IG49TWF0aC5zaW4oZS10KTtyZXR1cm4gbj4wPyR0LkNPVU5URVJDTE9DS1dJU0U6bjwwPyR0LkNMT0NLV0lTRTokdC5OT05FfXN0YXRpYyBhbmdsZUJldHdlZW5PcmllbnRlZCh0LGUsbil7Y29uc3Qgcz0kdC5hbmdsZShlLHQpLGk9JHQuYW5nbGUoZSxuKS1zO3JldHVybiBpPD0tTWF0aC5QST9pKyR0LlBJX1RJTUVTXzI6aT5NYXRoLlBJP2ktJHQuUElfVElNRVNfMjppfX0kdC5QSV9USU1FU18yPTIqTWF0aC5QSSwkdC5QSV9PVkVSXzI9TWF0aC5QSS8yLCR0LlBJX09WRVJfND1NYXRoLlBJLzQsJHQuQ09VTlRFUkNMT0NLV0lTRT1xLkNPVU5URVJDTE9DS1dJU0UsJHQuQ0xPQ0tXSVNFPXEuQ0xPQ0tXSVNFLCR0Lk5PTkU9cS5DT0xMSU5FQVI7Y2xhc3MgdGUgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsXCJQcm9qZWN0aXZlIHBvaW50IG5vdCByZXByZXNlbnRhYmxlIG9uIHRoZSBDYXJ0ZXNpYW4gcGxhbmUuXCIpfX1jbGFzcyBlZXtjb25zdHJ1Y3Rvcigpe2VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMudz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMueD0wLHRoaXMueT0wLHRoaXMudz0xO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLnc9MX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLnc9MX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMueD10LnkqZS53LWUueSp0LncsdGhpcy55PWUueCp0LnctdC54KmUudyx0aGlzLnc9dC54KmUueS1lLngqdC55fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMueD10LnktZS55LHRoaXMueT1lLngtdC54LHRoaXMudz10LngqZS55LWUueCp0Lnl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMueD10LHRoaXMueT1lLHRoaXMudz1ufWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9dC55LWUueSxyPWUueC10Lngsbz10LngqZS55LWUueCp0LnksbD1uLnktcy55LGE9cy54LW4ueCxjPW4ueCpzLnktcy54Km4ueTt0aGlzLng9cipjLWEqbyx0aGlzLnk9bCpvLWkqYyx0aGlzLnc9aSphLWwqcn19Z2V0WSgpe2NvbnN0IHQ9dGhpcy55L3RoaXMudztpZihyLmlzTmFOKHQpfHxyLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IHRlO3JldHVybiB0fWdldFgoKXtjb25zdCB0PXRoaXMueC90aGlzLnc7aWYoci5pc05hTih0KXx8ci5pc0luZmluaXRlKHQpKXRocm93IG5ldyB0ZTtyZXR1cm4gdH1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD1uZXcgbTtyZXR1cm4gdC54PXRoaXMuZ2V0WCgpLHQueT10aGlzLmdldFkoKSx0fX1jbGFzcyBuZXtjb25zdHJ1Y3Rvcigpe25lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5wMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMucDA9dCx0aGlzLnAxPWUsdGhpcy5wMj1ufXN0YXRpYyBhcmVhKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnMoKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMil9c3RhdGljIHNpZ25lZEFyZWEodCxlLG4pe3JldHVybigobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzJ9c3RhdGljIGRldCh0LGUsbixzKXtyZXR1cm4gdCpzLWUqbn1zdGF0aWMgaW50ZXJwb2xhdGVaKHQsZSxuLHMpe2NvbnN0IGk9ZS54LHI9ZS55LG89bi54LWksbD1zLngtaSxhPW4ueS1yLGM9cy55LXIsaD1vKmMtbCphLHU9dC54LWksZz10LnktcixkPShjKnUtbCpnKS9oLF89KC1hKnUrbypnKS9oO3JldHVybiBlLmdldFooKStkKihuLmdldFooKS1lLmdldFooKSkrXyoocy5nZXRaKCktZS5nZXRaKCkpfXN0YXRpYyBsb25nZXN0U2lkZUxlbmd0aCh0LGUsbil7Y29uc3Qgcz10LmRpc3RhbmNlKGUpLGk9ZS5kaXN0YW5jZShuKSxyPW4uZGlzdGFuY2UodCk7bGV0IG89cztyZXR1cm4gaT5vJiYobz1pKSxyPm8mJihvPXIpLG99c3RhdGljIGNpcmN1bWNlbnRyZUREKHQsZSxuKXtjb25zdCBzPUEudmFsdWVPZih0LngpLnN1YnRyYWN0KG4ueCksaT1BLnZhbHVlT2YodC55KS5zdWJ0cmFjdChuLnkpLHI9QS52YWx1ZU9mKGUueCkuc3VidHJhY3Qobi54KSxvPUEudmFsdWVPZihlLnkpLnN1YnRyYWN0KG4ueSksbD1BLmRldGVybWluYW50KHMsaSxyLG8pLm11bHRpcGx5KDIpLGE9cy5zcXIoKS5hZGQoaS5zcXIoKSksYz1yLnNxcigpLmFkZChvLnNxcigpKSxoPUEuZGV0ZXJtaW5hbnQoaSxhLG8sYyksdT1BLmRldGVybWluYW50KHMsYSxyLGMpLGc9QS52YWx1ZU9mKG4ueCkuc3VidHJhY3QoaC5kaXZpZGUobCkpLmRvdWJsZVZhbHVlKCksZD1BLnZhbHVlT2Yobi55KS5hZGQodS5kaXZpZGUobCkpLmRvdWJsZVZhbHVlKCk7cmV0dXJuIG5ldyBtKGcsZCl9c3RhdGljIGlzQWN1dGUodCxlLG4pe3JldHVybiEhJHQuaXNBY3V0ZSh0LGUsbikmJighISR0LmlzQWN1dGUoZSxuLHQpJiYhISR0LmlzQWN1dGUobix0LGUpKX1zdGF0aWMgY2lyY3VtY2VudHJlKHQsZSxuKXtjb25zdCBzPW4ueCxpPW4ueSxyPXQueC1zLG89dC55LWksbD1lLngtcyxhPWUueS1pLGM9MipuZS5kZXQocixvLGwsYSksaD1uZS5kZXQobyxyKnIrbypvLGEsbCpsK2EqYSksdT1uZS5kZXQocixyKnIrbypvLGwsbCpsK2EqYSk7cmV0dXJuIG5ldyBtKHMtaC9jLGkrdS9jKX1zdGF0aWMgcGVycGVuZGljdWxhckJpc2VjdG9yKHQsZSl7Y29uc3Qgbj1lLngtdC54LHM9ZS55LXQueSxpPW5ldyBlZSh0Lngrbi8yLHQueStzLzIsMSkscj1uZXcgZWUodC54LXMrbi8yLHQueStuK3MvMiwxKTtyZXR1cm4gbmV3IGVlKGkscil9c3RhdGljIGFuZ2xlQmlzZWN0b3IodCxlLG4pe2NvbnN0IHM9ZS5kaXN0YW5jZSh0KSxpPXMvKHMrZS5kaXN0YW5jZShuKSkscj1uLngtdC54LG89bi55LXQueTtyZXR1cm4gbmV3IG0odC54K2kqcix0LnkraSpvKX1zdGF0aWMgYXJlYTNEKHQsZSxuKXtjb25zdCBzPWUueC10LngsaT1lLnktdC55LHI9ZS5nZXRaKCktdC5nZXRaKCksbz1uLngtdC54LGw9bi55LXQueSxhPW4uZ2V0WigpLXQuZ2V0WigpLGM9aSphLXIqbCxoPXIqby1zKmEsdT1zKmwtaSpvLGc9YypjK2gqaCt1KnU7cmV0dXJuIE1hdGguc3FydChnKS8yfXN0YXRpYyBjZW50cm9pZCh0LGUsbil7Y29uc3Qgcz0odC54K2UueCtuLngpLzMsaT0odC55K2UueStuLnkpLzM7cmV0dXJuIG5ldyBtKHMsaSl9c3RhdGljIGluQ2VudHJlKHQsZSxuKXtjb25zdCBzPWUuZGlzdGFuY2UobiksaT10LmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShlKSxvPXMraStyLGw9KHMqdC54K2kqZS54K3Iqbi54KS9vLGE9KHMqdC55K2kqZS55K3Iqbi55KS9vO3JldHVybiBuZXcgbShsLGEpfWFyZWEoKXtyZXR1cm4gbmUuYXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9c2lnbmVkQXJlYSgpe3JldHVybiBuZS5zaWduZWRBcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pbnRlcnBvbGF0ZVoodCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IHMoXCJTdXBwbGllZCBwb2ludCBpcyBudWxsLlwiKTtyZXR1cm4gbmUuaW50ZXJwb2xhdGVaKHQsdGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWxvbmdlc3RTaWRlTGVuZ3RoKCl7cmV0dXJuIG5lLmxvbmdlc3RTaWRlTGVuZ3RoKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pc0FjdXRlKCl7cmV0dXJuIG5lLmlzQWN1dGUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWNpcmN1bWNlbnRyZSgpe3JldHVybiBuZS5jaXJjdW1jZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWFyZWEzRCgpe3JldHVybiBuZS5hcmVhM0QodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWNlbnRyb2lkKCl7cmV0dXJuIG5lLmNlbnRyb2lkKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pbkNlbnRyZSgpe3JldHVybiBuZS5pbkNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9fWNsYXNzIHNlIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksc2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fX1jbGFzcyBpZXtjb25zdHJ1Y3Rvcigpe2llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX20wMD1udWxsLHRoaXMuX20wMT1udWxsLHRoaXMuX20wMj1udWxsLHRoaXMuX20xMD1udWxsLHRoaXMuX20xMT1udWxsLHRoaXMuX20xMj1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuc2V0VG9JZGVudGl0eSgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX20wMD10WzBdLHRoaXMuX20wMT10WzFdLHRoaXMuX20wMj10WzJdLHRoaXMuX20xMD10WzNdLHRoaXMuX20xMT10WzRdLHRoaXMuX20xMj10WzVdfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBpZSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRUcmFuc2Zvcm1hdGlvbih0KX19ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1s1XSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1s0XSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1szXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07dGhpcy5zZXRUcmFuc2Zvcm1hdGlvbih0LGUsbixzLGkscil9fXN0YXRpYyB0cmFuc2xhdGlvbkluc3RhbmNlKHQsZSl7Y29uc3Qgbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9UcmFuc2xhdGlvbih0LGUpLG59c3RhdGljIHNoZWFySW5zdGFuY2UodCxlKXtjb25zdCBuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1NoZWFyKHQsZSksbn1zdGF0aWMgcmVmbGVjdGlvbkluc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGllO3JldHVybiBuLnNldFRvUmVmbGVjdGlvbih0LGUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGllO3JldHVybiBpLnNldFRvUmVmbGVjdGlvbih0LGUsbixzKSxpfX1zdGF0aWMgcm90YXRpb25JbnN0YW5jZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gaWUucm90YXRpb25JbnN0YW5jZShNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGllO3JldHVybiBuLnNldFRvUm90YXRpb24odCxlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gaWUucm90YXRpb25JbnN0YW5jZShNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSxlLG4pfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBpZTtyZXR1cm4gaS5zZXRUb1JvdGF0aW9uKHQsZSxuLHMpLGl9fXN0YXRpYyBzY2FsZUluc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGllO3JldHVybiBuLnNldFRvU2NhbGUodCxlKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBpZTtyZXR1cm4gaS50cmFuc2xhdGUoLW4sLXMpLGkuc2NhbGUodCxlKSxpLnRyYW5zbGF0ZShuLHMpLGl9fXNldFRvUmVmbGVjdGlvbkJhc2ljKHQsZSxuLGkpe2lmKHQ9PT1uJiZlPT09aSl0aHJvdyBuZXcgcyhcIlJlZmxlY3Rpb24gbGluZSBwb2ludHMgbXVzdCBiZSBkaXN0aW5jdFwiKTtjb25zdCByPW4tdCxvPWktZSxsPU1hdGguc3FydChyKnIrbypvKSxhPW8vbCxjPXIvbCxoPTIqYSpjLHU9YypjLWEqYTtyZXR1cm4gdGhpcy5fbTAwPXUsdGhpcy5fbTAxPWgsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPWgsdGhpcy5fbTExPS11LHRoaXMuX20xMj0wLHRoaXN9Z2V0SW52ZXJzZSgpe2NvbnN0IHQ9dGhpcy5nZXREZXRlcm1pbmFudCgpO2lmKDA9PT10KXRocm93IG5ldyBzZShcIlRyYW5zZm9ybWF0aW9uIGlzIG5vbi1pbnZlcnRpYmxlXCIpO2NvbnN0IGU9dGhpcy5fbTExL3Qsbj0tdGhpcy5fbTEwL3Qscz0tdGhpcy5fbTAxL3QsaT10aGlzLl9tMDAvdCxyPSh0aGlzLl9tMDEqdGhpcy5fbTEyLXRoaXMuX20wMip0aGlzLl9tMTEpL3Qsbz0oLXRoaXMuX20wMCp0aGlzLl9tMTIrdGhpcy5fbTEwKnRoaXMuX20wMikvdDtyZXR1cm4gbmV3IGllKGUscyxyLG4saSxvKX1jb21wb3NlKHQpe2NvbnN0IGU9dC5fbTAwKnRoaXMuX20wMCt0Ll9tMDEqdGhpcy5fbTEwLG49dC5fbTAwKnRoaXMuX20wMSt0Ll9tMDEqdGhpcy5fbTExLHM9dC5fbTAwKnRoaXMuX20wMit0Ll9tMDEqdGhpcy5fbTEyK3QuX20wMixpPXQuX20xMCp0aGlzLl9tMDArdC5fbTExKnRoaXMuX20xMCxyPXQuX20xMCp0aGlzLl9tMDErdC5fbTExKnRoaXMuX20xMSxvPXQuX20xMCp0aGlzLl9tMDIrdC5fbTExKnRoaXMuX20xMit0Ll9tMTI7cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT1uLHRoaXMuX20wMj1zLHRoaXMuX20xMD1pLHRoaXMuX20xMT1yLHRoaXMuX20xMj1vLHRoaXN9ZXF1YWxzKHQpe2lmKG51bGw9PT10KXJldHVybiExO2lmKCEodCBpbnN0YW5jZW9mIGllKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX20wMD09PWUuX20wMCYmdGhpcy5fbTAxPT09ZS5fbTAxJiZ0aGlzLl9tMDI9PT1lLl9tMDImJnRoaXMuX20xMD09PWUuX20xMCYmdGhpcy5fbTExPT09ZS5fbTExJiZ0aGlzLl9tMTI9PT1lLl9tMTJ9c2V0VG9TY2FsZSh0LGUpe3JldHVybiB0aGlzLl9tMDA9dCx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9MCx0aGlzfWlzSWRlbnRpdHkoKXtyZXR1cm4gMT09PXRoaXMuX20wMCYmMD09PXRoaXMuX20wMSYmMD09PXRoaXMuX20wMiYmMD09PXRoaXMuX20xMCYmMT09PXRoaXMuX20xMSYmMD09PXRoaXMuX20xMn1zY2FsZSh0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UoaWUuc2NhbGVJbnN0YW5jZSh0LGUpKSx0aGlzfXNldFRvSWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTAsdGhpcy5fbTExPTEsdGhpcy5fbTEyPTAsdGhpc31pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiEwfXNldFRyYW5zZm9ybWF0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9tMDA9dC5fbTAwLHRoaXMuX20wMT10Ll9tMDEsdGhpcy5fbTAyPXQuX20wMix0aGlzLl9tMTA9dC5fbTEwLHRoaXMuX20xMT10Ll9tMTEsdGhpcy5fbTEyPXQuX20xMix0aGlzfWlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtyZXR1cm4gdGhpcy5fbTAwPXQsdGhpcy5fbTAxPWUsdGhpcy5fbTAyPW4sdGhpcy5fbTEwPXMsdGhpcy5fbTExPWksdGhpcy5fbTEyPXIsdGhpc319c2V0VG9Sb3RhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZXRUb1JvdGF0aW9uKE1hdGguc2luKHQpLE1hdGguY29zKHQpKSx0aGlzfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPS10LHRoaXMuX20wMj0wLHRoaXMuX20xMD10LHRoaXMuX20xMT1lLHRoaXMuX20xMj0wLHRoaXN9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLnNldFRvUm90YXRpb24oTWF0aC5zaW4odCksTWF0aC5jb3ModCksZSxuKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPS10LHRoaXMuX20wMj1uLW4qZStzKnQsdGhpcy5fbTEwPXQsdGhpcy5fbTExPWUsdGhpcy5fbTEyPXMtbip0LXMqZSx0aGlzfX1nZXRNYXRyaXhFbnRyaWVzKCl7cmV0dXJuW3RoaXMuX20wMCx0aGlzLl9tMDEsdGhpcy5fbTAyLHRoaXMuX20xMCx0aGlzLl9tMTEsdGhpcy5fbTEyXX1maWx0ZXIodCxlKXt0aGlzLnRyYW5zZm9ybSh0LGUpfXJvdGF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJvdGF0aW9uSW5zdGFuY2UodCkpLHRoaXN9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucm90YXRpb25JbnN0YW5jZSh0LGUpKSx0aGlzfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJvdGF0aW9uSW5zdGFuY2UodCxlLG4pKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJvdGF0aW9uSW5zdGFuY2UodCxlLG4scykpLHRoaXN9fWdldERldGVybWluYW50KCl7cmV0dXJuIHRoaXMuX20wMCp0aGlzLl9tMTEtdGhpcy5fbTAxKnRoaXMuX20xMH1jb21wb3NlQmVmb3JlKHQpe2NvbnN0IGU9dGhpcy5fbTAwKnQuX20wMCt0aGlzLl9tMDEqdC5fbTEwLG49dGhpcy5fbTAwKnQuX20wMSt0aGlzLl9tMDEqdC5fbTExLHM9dGhpcy5fbTAwKnQuX20wMit0aGlzLl9tMDEqdC5fbTEyK3RoaXMuX20wMixpPXRoaXMuX20xMCp0Ll9tMDArdGhpcy5fbTExKnQuX20xMCxyPXRoaXMuX20xMCp0Ll9tMDErdGhpcy5fbTExKnQuX20xMSxvPXRoaXMuX20xMCp0Ll9tMDIrdGhpcy5fbTExKnQuX20xMit0aGlzLl9tMTI7cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT1uLHRoaXMuX20wMj1zLHRoaXMuX20xMD1pLHRoaXMuX20xMT1yLHRoaXMuX20xMj1vLHRoaXN9c2V0VG9TaGVhcih0LGUpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9dCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9ZSx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9MCx0aGlzfWlzRG9uZSgpe3JldHVybiExfWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IHQ7Zy5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBudWxsfXRyYW5zbGF0ZSh0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UoaWUudHJhbnNsYXRpb25JbnN0YW5jZSh0LGUpKSx0aGlzfXNldFRvUmVmbGVjdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IHMoXCJSZWZsZWN0aW9uIHZlY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpO2lmKHQ9PT1lKXJldHVybiB0aGlzLl9tMDA9MCx0aGlzLl9tMDE9MSx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MSx0aGlzLl9tMTE9MCx0aGlzLl9tMTI9MCx0aGlzO2NvbnN0IG49TWF0aC5zcXJ0KHQqdCtlKmUpLGk9ZS9uLHI9dC9uO3JldHVybiB0aGlzLnJvdGF0ZSgtaSxyKSx0aGlzLnNjYWxlKDEsLTEpLHRoaXMucm90YXRlKGksciksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107aWYodD09PW4mJmU9PT1pKXRocm93IG5ldyBzKFwiUmVmbGVjdGlvbiBsaW5lIHBvaW50cyBtdXN0IGJlIGRpc3RpbmN0XCIpO3RoaXMuc2V0VG9UcmFuc2xhdGlvbigtdCwtZSk7Y29uc3Qgcj1uLXQsbz1pLWUsbD1NYXRoLnNxcnQocipyK28qbyksYT1vL2wsYz1yL2w7cmV0dXJuIHRoaXMucm90YXRlKC1hLGMpLHRoaXMuc2NhbGUoMSwtMSksdGhpcy5yb3RhdGUoYSxjKSx0aGlzLnRyYW5zbGF0ZSh0LGUpLHRoaXN9fXRvU3RyaW5nKCl7cmV0dXJuXCJBZmZpbmVUcmFuc2Zvcm1hdGlvbltbXCIrdGhpcy5fbTAwK1wiLCBcIit0aGlzLl9tMDErXCIsIFwiK3RoaXMuX20wMitcIl0sIFtcIit0aGlzLl9tMTArXCIsIFwiK3RoaXMuX20xMStcIiwgXCIrdGhpcy5fbTEyK1wiXV1cIn1zZXRUb1RyYW5zbGF0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT0wLHRoaXMuX20wMj10LHRoaXMuX20xMD0wLHRoaXMuX20xMT0xLHRoaXMuX20xMj1lLHRoaXN9c2hlYXIodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnNoZWFySW5zdGFuY2UodCxlKSksdGhpc310cmFuc2Zvcm0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uY29weSgpO3JldHVybiB0LmFwcGx5KHRoaXMpLHR9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX20wMCp0LngrdGhpcy5fbTAxKnQueSt0aGlzLl9tMDIscz10aGlzLl9tMTAqdC54K3RoaXMuX20xMSp0LnkrdGhpcy5fbTEyO3JldHVybiBlLng9bixlLnk9cyxlfWlmKEkoYXJndW1lbnRzWzBdLEcpJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbTAwKnQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLl9tMDEqdC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMuX20wMixzPXRoaXMuX20xMCp0LmdldE9yZGluYXRlKGUsMCkrdGhpcy5fbTExKnQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLl9tMTI7dC5zZXRPcmRpbmF0ZShlLDAsbiksdC5zZXRPcmRpbmF0ZShlLDEscyl9fX1yZWZsZWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucmVmbGVjdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucmVmbGVjdGlvbkluc3RhbmNlKHQsZSxuLHMpKSx0aGlzfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbCxQXX19Y2xhc3MgcmV7c3RhdGljIHNvbHZlKHQsZSl7Y29uc3Qgbj1lLmxlbmd0aDtpZih0Lmxlbmd0aCE9PW58fHRbMF0ubGVuZ3RoIT09bil0aHJvdyBuZXcgcyhcIk1hdHJpeCBBIGlzIGluY29ycmVjdGx5IHNpemVkXCIpO2ZvcihsZXQgcz0wO3M8bjtzKyspe2xldCBpPXM7Zm9yKGxldCBlPXMrMTtlPG47ZSsrKU1hdGguYWJzKHRbZV1bc10pPk1hdGguYWJzKHRbaV1bc10pJiYoaT1lKTtpZigwPT09dFtpXVtzXSlyZXR1cm4gbnVsbDtyZS5zd2FwUm93cyh0LHMsaSkscmUuc3dhcFJvd3MoZSxzLGkpO2ZvcihsZXQgaT1zKzE7aTxuO2krKyl7Y29uc3Qgcj10W2ldW3NdL3Rbc11bc107Zm9yKGxldCBlPW4tMTtlPj1zO2UtLSl0W2ldW2VdLT10W3NdW2VdKnI7ZVtpXS09ZVtzXSpyfX1jb25zdCBpPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2ZvcihsZXQgcz1uLTE7cz49MDtzLS0pe2xldCByPTA7Zm9yKGxldCBlPXMrMTtlPG47ZSsrKXIrPXRbc11bZV0qaVtlXTtpW3NdPShlW3NdLXIpL3Rbc11bc119cmV0dXJuIGl9c3RhdGljIHN3YXBSb3dzKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGU9PT1uKXJldHVybiBudWxsO2ZvcihsZXQgcz0wO3M8dFswXS5sZW5ndGg7cysrKXtjb25zdCBpPXRbZV1bc107dFtlXVtzXT10W25dW3NdLHRbbl1bc109aX19ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZT09PW4pcmV0dXJuIG51bGw7Y29uc3Qgcz10W2VdO3RbZV09dFtuXSx0W25dPXN9fX1jbGFzcyBvZXtjb25zdHJ1Y3Rvcigpe29lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NyYzA9bnVsbCx0aGlzLl9zcmMxPW51bGwsdGhpcy5fc3JjMj1udWxsLHRoaXMuX2Rlc3QwPW51bGwsdGhpcy5fZGVzdDE9bnVsbCx0aGlzLl9kZXN0Mj1udWxsLHRoaXMuX20wMD1udWxsLHRoaXMuX20wMT1udWxsLHRoaXMuX20wMj1udWxsLHRoaXMuX20xMD1udWxsLHRoaXMuX20xMT1udWxsLHRoaXMuX20xMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3RoaXMuX3NyYzA9dCx0aGlzLl9zcmMxPWUsdGhpcy5fc3JjMj1uLHRoaXMuX2Rlc3QwPXMsdGhpcy5fZGVzdDE9aSx0aGlzLl9kZXN0Mj1yfXNvbHZlKHQpe2NvbnN0IGU9W1t0aGlzLl9zcmMwLngsdGhpcy5fc3JjMC55LDFdLFt0aGlzLl9zcmMxLngsdGhpcy5fc3JjMS55LDFdLFt0aGlzLl9zcmMyLngsdGhpcy5fc3JjMi55LDFdXTtyZXR1cm4gcmUuc29sdmUoZSx0KX1jb21wdXRlKCl7Y29uc3QgdD1bdGhpcy5fZGVzdDAueCx0aGlzLl9kZXN0MS54LHRoaXMuX2Rlc3QyLnhdLGU9dGhpcy5zb2x2ZSh0KTtpZihudWxsPT09ZSlyZXR1cm4hMTt0aGlzLl9tMDA9ZVswXSx0aGlzLl9tMDE9ZVsxXSx0aGlzLl9tMDI9ZVsyXTtjb25zdCBuPVt0aGlzLl9kZXN0MC55LHRoaXMuX2Rlc3QxLnksdGhpcy5fZGVzdDIueV0scz10aGlzLnNvbHZlKG4pO3JldHVybiBudWxsIT09cyYmKHRoaXMuX20xMD1zWzBdLHRoaXMuX20xMT1zWzFdLHRoaXMuX20xMj1zWzJdLCEwKX1nZXRUcmFuc2Zvcm1hdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKT9uZXcgaWUodGhpcy5fbTAwLHRoaXMuX20wMSx0aGlzLl9tMDIsdGhpcy5fbTEwLHRoaXMuX20xMSx0aGlzLl9tMTIpOm51bGx9fWNsYXNzIGxle3N0YXRpYyBjcmVhdGVGcm9tQmFzZUxpbmVzKHQsZSxuLHMpe2NvbnN0IGk9bmV3IG0odC54K3MueC1uLngsdC55K3MueS1uLnkpLHI9JHQuYW5nbGVCZXR3ZWVuT3JpZW50ZWQoZSx0LGkpLG89ZS5kaXN0YW5jZSh0KSxsPXMuZGlzdGFuY2Uobik7aWYoMD09PW8pcmV0dXJuIG5ldyBpZTtjb25zdCBhPWwvbyxjPWllLnRyYW5zbGF0aW9uSW5zdGFuY2UoLXQueCwtdC55KTtyZXR1cm4gYy5yb3RhdGUociksYy5zY2FsZShhLGEpLGMudHJhbnNsYXRlKG4ueCxuLnkpLGN9c3RhdGljIGNyZWF0ZUZyb21Db250cm9sVmVjdG9ycygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1lLngtdC54LHM9ZS55LXQueTtyZXR1cm4gaWUudHJhbnNsYXRpb25JbnN0YW5jZShuLHMpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IHMoXCJTcmMgYW5kIERlc3QgYXJyYXlzIGFyZSBub3QgdGhlIHNhbWUgbGVuZ3RoXCIpO2lmKHQubGVuZ3RoPD0wKXRocm93IG5ldyBzKFwiVG9vIGZldyBjb250cm9sIHBvaW50c1wiKTtpZih0Lmxlbmd0aD4zKXRocm93IG5ldyBzKFwiVG9vIG1hbnkgY29udHJvbCBwb2ludHNcIik7cmV0dXJuIDE9PT10Lmxlbmd0aD9sZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSxlWzBdKToyPT09dC5sZW5ndGg/bGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sdFsxXSxlWzBdLGVbMV0pOmxlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLHRbMV0sdFsyXSxlWzBdLGVbMV0sZVsyXSl9fWVsc2V7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IG0ocy54LW4ueCxzLnktbi55KSxyPSR0LmFuZ2xlQmV0d2Vlbk9yaWVudGVkKGUsdCxpKSxvPWUuZGlzdGFuY2UodCksbD1zLmRpc3RhbmNlKG4pO2lmKDA9PT1vKXJldHVybiBudWxsO2NvbnN0IGE9bC9vLGM9aWUudHJhbnNsYXRpb25JbnN0YW5jZSgtdC54LC10LnkpO3JldHVybiBjLnJvdGF0ZShyKSxjLnNjYWxlKGEsYSksYy50cmFuc2xhdGUobi54LG4ueSksY31pZig2PT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBvZShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSkuZ2V0VHJhbnNmb3JtYXRpb24oKX19fX1jbGFzcyBhZXtjb25zdHJ1Y3Rvcigpe2FlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3Jkcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2Nvb3Jkcz10fXN0YXRpYyBnZXRDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBMO3JldHVybiB0LmFwcGx5KG5ldyBhZShlKSksZX1maWx0ZXIodCl7KHQgaW5zdGFuY2VvZiAkfHx0IGluc3RhbmNlb2YgZXQpJiZ0aGlzLl9jb29yZHMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119fWNsYXNzIGNle2NvbnN0cnVjdG9yKCl7Y2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWFwT3A9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tYXBPcD10fXN0YXRpYyBtYXAodCxlKXtyZXR1cm4gbmV3IGNlKGUpLm1hcCh0KX1tYXAodCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10aGlzLl9tYXBPcC5tYXAodC5nZXRHZW9tZXRyeU4obikpO3MuaXNFbXB0eSgpfHxlLmFkZChzKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEx0LnRvR2VvbWV0cnlBcnJheShlKSl9fWNsYXNzIGhle2NvbnN0cnVjdG9yKCl7aGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9za2lwRW1wdHk9ITEsdGhpcy5faW5wdXRHZW9tcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0b3J5PWhlLmV4dHJhY3RGYWN0b3J5KHQpLHRoaXMuX2lucHV0R2VvbXM9dH1zdGF0aWMgY29tYmluZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IGhlKGFyZ3VtZW50c1swXSkuY29tYmluZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IGhlKGhlLmNyZWF0ZUxpc3QodCxlKSkuY29tYmluZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IGhlKGhlLmNyZWF0ZUxpc3QodCxlLG4pKS5jb21iaW5lKCl9fXN0YXRpYyBleHRyYWN0RmFjdG9yeSh0KXtyZXR1cm4gdC5pc0VtcHR5KCk/bnVsbDp0Lml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKX1zdGF0aWMgY3JlYXRlTGlzdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO3JldHVybiBuLmFkZCh0KSxuLmFkZChlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBMO3JldHVybiBzLmFkZCh0KSxzLmFkZChlKSxzLmFkZChuKSxzfX1leHRyYWN0RWxlbWVudHModCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTt0aGlzLl9za2lwRW1wdHkmJnMuaXNFbXB0eSgpfHxlLmFkZChzKX19Y29tYmluZSgpe2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPXRoaXMuX2lucHV0R2VvbXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5leHRyYWN0RWxlbWVudHMobix0KX1yZXR1cm4gMD09PXQuc2l6ZSgpP251bGwhPT10aGlzLl9nZW9tRmFjdG9yeT90aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTpudWxsOnRoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9fWNsYXNzIHVle2NvbnN0cnVjdG9yKCl7dWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2lzVXNlckRhdGFDb3BpZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH19c2V0Q29weVVzZXJEYXRhKHQpe3RoaXMuX2lzVXNlckRhdGFDb3BpZWQ9dH1lZGl0KHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLmVkaXRJbnRlcm5hbCh0LGUpO3JldHVybiB0aGlzLl9pc1VzZXJEYXRhQ29waWVkJiZuLnNldFVzZXJEYXRhKHQuZ2V0VXNlckRhdGEoKSksbn1lZGl0SW50ZXJuYWwodCxlKXtyZXR1cm4gbnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0IGluc3RhbmNlb2YgaHQ/dGhpcy5lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKHQsZSk6dCBpbnN0YW5jZW9mIHJ0P3RoaXMuZWRpdFBvbHlnb24odCxlKTp0IGluc3RhbmNlb2YgZXR8fHQgaW5zdGFuY2VvZiAkP2UuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpOihnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5zdXBwb3J0ZWQgR2VvbWV0cnkgdHlwZTogXCIrdC5nZXRHZW9tZXRyeVR5cGUoKSksbnVsbCl9ZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSkscz1uZXcgTDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3QgaT10aGlzLmVkaXQobi5nZXRHZW9tZXRyeU4odCksZSk7bnVsbD09PWl8fGkuaXNFbXB0eSgpfHxzLmFkZChpKX1yZXR1cm4gbi5nZXRHZW9tZXRyeVR5cGUoKT09PVUuVFlQRU5BTUVfTVVMVElQT0lOVD90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQocy50b0FycmF5KFtdKSk6bi5nZXRHZW9tZXRyeVR5cGUoKT09PVUuVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHMudG9BcnJheShbXSkpOm4uZ2V0R2VvbWV0cnlUeXBlKCk9PT1VLlRZUEVOQU1FX01VTFRJUE9MWUdPTj90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihzLnRvQXJyYXkoW10pKTp0aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihzLnRvQXJyYXkoW10pKX1lZGl0UG9seWdvbih0LGUpe2xldCBuPWUuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpO2lmKG51bGw9PT1uJiYobj10aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKSksbi5pc0VtcHR5KCkpcmV0dXJuIG47Y29uc3Qgcz10aGlzLmVkaXQobi5nZXRFeHRlcmlvclJpbmcoKSxlKTtpZihudWxsPT09c3x8cy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbigpO2NvbnN0IGk9bmV3IEw7Zm9yKGxldCB0PTA7dDxuLmdldE51bUludGVyaW9yUmluZygpO3QrKyl7Y29uc3Qgcz10aGlzLmVkaXQobi5nZXRJbnRlcmlvclJpbmdOKHQpLGUpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8aS5hZGQocyl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzLGkudG9BcnJheShbXSkpfX1mdW5jdGlvbiBnZSgpe311ZS5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbj1nZTt1ZS5Ob09wR2VvbWV0cnlPcGVyYXRpb249Y2xhc3N7ZWRpdCh0LGUpe3JldHVybiB0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnZV19fSx1ZS5Db29yZGluYXRlT3BlcmF0aW9uPWNsYXNze2VkaXQodCxlKXtjb25zdCBuPXRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVzKCksdCk7cmV0dXJuIHQgaW5zdGFuY2VvZiBndD9udWxsPT09bj9lLmNyZWF0ZUxpbmVhclJpbmcoKTplLmNyZWF0ZUxpbmVhclJpbmcobik6dCBpbnN0YW5jZW9mICQ/bnVsbD09PW4/ZS5jcmVhdGVMaW5lU3RyaW5nKCk6ZS5jcmVhdGVMaW5lU3RyaW5nKG4pOnQgaW5zdGFuY2VvZiBldD9udWxsPT09bnx8MD09PW4ubGVuZ3RoP2UuY3JlYXRlUG9pbnQoKTplLmNyZWF0ZVBvaW50KG5bMF0pOnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2dlXX19LHVlLkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbj1jbGFzc3tlZGl0KHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBndD9lLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnQgaW5zdGFuY2VvZiAkP2UuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIGV0P2UuY3JlYXRlUG9pbnQodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2dlXX19O2NsYXNzIGRle2NvbnN0cnVjdG9yKCl7ZGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbWV0cnlUeXBlPW51bGwsdGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tZXRyeVR5cGU9dCx0aGlzLl9jb21wcz1lfXN0YXRpYyBpc09mVHlwZSh0LGUpe3JldHVybiB0LmdldEdlb21ldHJ5VHlwZSgpPT09ZXx8ZT09PVUuVFlQRU5BTUVfTElORVNUUklORyYmdC5nZXRHZW9tZXRyeVR5cGUoKT09PVUuVFlQRU5BTUVfTElORUFSUklOR31zdGF0aWMgZXh0cmFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gZGUuZXh0cmFjdCh0LGUsbmV3IEwpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdC5nZXRHZW9tZXRyeVR5cGUoKT09PWU/bi5hZGQodCk6dCBpbnN0YW5jZW9mIGh0JiZ0LmFwcGx5KG5ldyBkZShlLG4pKSxufX1maWx0ZXIodCl7KG51bGw9PT10aGlzLl9nZW9tZXRyeVR5cGV8fGRlLmlzT2ZUeXBlKHQsdGhpcy5fZ2VvbWV0cnlUeXBlKSkmJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSl19fWNsYXNzIF9le3N0YXRpYyBtYXAoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUmJkkoYXJndW1lbnRzWzFdLHBlKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtR2VvbWV0cmllcygpO3MrKyl7Y29uc3QgaT1lLm1hcCh0LmdldEdlb21ldHJ5TihzKSk7bnVsbCE9PWkmJm4uYWRkKGkpfXJldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KG4pfWlmKEkoYXJndW1lbnRzWzBdLE4pJiZJKGFyZ3VtZW50c1sxXSxwZSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCksaT1lLm1hcCh0KTtudWxsIT09aSYmbi5hZGQoaSl9cmV0dXJuIG59fX1mdW5jdGlvbiBwZSgpe31fZS5NYXBPcD1wZTtjbGFzcyBtZXtjb25zdHJ1Y3Rvcigpe21lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9wcnVuZUVtcHR5R2VvbWV0cnk9ITAsdGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlPSEwLHRoaXMuX3ByZXNlcnZlQ29sbGVjdGlvbnM9ITEsdGhpcy5fcHJlc2VydmVUeXBlPSExfXRyYW5zZm9ybVBvaW50KHQsZSl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7bGV0IG49ITA7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSx0KTtudWxsIT09cyYmcyBpbnN0YW5jZW9mIGd0JiYhcy5pc0VtcHR5KCl8fChuPSExKTtjb25zdCBpPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSx0KTtudWxsPT09c3x8cy5pc0VtcHR5KCl8fChzIGluc3RhbmNlb2YgZ3R8fChuPSExKSxpLmFkZChzKSl9aWYobilyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHMsaS50b0FycmF5KFtdKSk7e2NvbnN0IHQ9bmV3IEw7cmV0dXJuIG51bGwhPT1zJiZ0LmFkZChzKSx0LmFkZEFsbChpKSx0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9fWNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSh0KXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpfWdldElucHV0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tfXRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7cmV0dXJuIHRoaXMuY29weSh0KX10cmFuc2Zvcm1MaW5lU3RyaW5nKHQsZSl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfXRyYW5zZm9ybU11bHRpUG9pbnQodCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtUG9pbnQodC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybVBvbHlnb24odC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9Y29weSh0KXtyZXR1cm4gdC5jb3B5KCl9dHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybSh0LmdldEdlb21ldHJ5TihlKSk7bnVsbCE9PXMmJih0aGlzLl9wcnVuZUVtcHR5R2VvbWV0cnkmJnMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT90aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihMdC50b0dlb21ldHJ5QXJyYXkobikpOnRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm0odCl7aWYodGhpcy5faW5wdXRHZW9tPXQsdGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0IGluc3RhbmNlb2YgZXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgdXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBndClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mICQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBTdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgcnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiB5dClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgaHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKHQsbnVsbCk7dGhyb3cgbmV3IHMoXCJVbmtub3duIEdlb21ldHJ5IHN1YnR5cGU6IFwiK3QuZ2V0R2VvbWV0cnlUeXBlKCkpfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPXRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KTtpZihudWxsPT09bilyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG51bGwpO2NvbnN0IHM9bi5zaXplKCk7cmV0dXJuIHM+MCYmczw0JiYhdGhpcy5fcHJlc2VydmVUeXBlP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhuKTp0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobil9fWNsYXNzIGZle2NvbnN0cnVjdG9yKCl7ZmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wcz10fXN0YXRpYyBnZXRHZW9tZXRyeSh0KXtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShmZS5nZXRMaW5lcyh0KSl9c3RhdGljIGdldExpbmVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBmZS5nZXRMaW5lcyh0LG5ldyBMKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiAkP2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBodCYmdC5hcHBseShuZXcgZmUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgJCYmdGhpcy5fY29tcHMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKXX19Y2xhc3MgeWV7Y29uc3RydWN0b3IoKXt5ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9saW5lcz1udWxsLHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPSExLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lcz10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2xpbmVzPXQsdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmc9ZX19c3RhdGljIGdldEdlb21ldHJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHllLmdldExpbmVzKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoeWUuZ2V0TGluZXModCxlKSl9fXN0YXRpYyBnZXRMaW5lcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4geWUuZ2V0TGluZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLE4pJiZJKGFyZ3VtZW50c1sxXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMV07Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt5ZS5nZXRMaW5lcyhuLHQpfXJldHVybiB0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7cmV0dXJuIHQuYXBwbHkobmV3IHllKG4sZSkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVJiZJKGFyZ3VtZW50c1sxXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiAkP2UuYWRkKHQpOnQuYXBwbHkobmV3IHllKGUpKSxlfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmSShhcmd1bWVudHNbMF0sTikmJkkoYXJndW1lbnRzWzFdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXTtmb3IobGV0IG49YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3llLmdldExpbmVzKHMsdCxlKX1yZXR1cm4gdH1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVJiZJKGFyZ3VtZW50c1sxXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl07cmV0dXJuIGFyZ3VtZW50c1swXS5hcHBseShuZXcgeWUodCxlKSksdH19fWZpbHRlcih0KXtpZih0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZyYmdCBpbnN0YW5jZW9mIGd0KXtjb25zdCBlPXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHRoaXMuX2xpbmVzLmFkZChlKSxudWxsfXQgaW5zdGFuY2VvZiAkJiZ0aGlzLl9saW5lcy5hZGQodCl9c2V0Rm9yY2VUb0xpbmVTdHJpbmcodCl7dGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmc9dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119fWNvbnN0IHhlPXtyZXZlcnNlT3JkZXI6ZnVuY3Rpb24oKXtyZXR1cm57Y29tcGFyZToodCxlKT0+ZS5jb21wYXJlVG8odCl9fSxtaW46ZnVuY3Rpb24odCl7cmV0dXJuIHhlLnNvcnQodCksdC5nZXQoMCl9LHNvcnQ6ZnVuY3Rpb24odCxlKXtjb25zdCBuPXQudG9BcnJheSgpO2U/c3Quc29ydChuLGUpOnN0LnNvcnQobik7Y29uc3Qgcz10Lml0ZXJhdG9yKCk7Zm9yKGxldCB0PTAsZT1uLmxlbmd0aDt0PGU7dCsrKXMubmV4dCgpLHMuc2V0KG5bdF0pfSxzaW5nbGV0b25MaXN0OmZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IEw7cmV0dXJuIGUuYWRkKHQpLGV9fTtjbGFzcyBFZXtjb25zdHJ1Y3Rvcigpe0VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10fXN0YXRpYyBnZXRQb2ludHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQgaW5zdGFuY2VvZiBldD94ZS5zaW5nbGV0b25MaXN0KHQpOkVlLmdldFBvaW50cyh0LG5ldyBMKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBldD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgaHQmJnQuYXBwbHkobmV3IEVlKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIGV0JiZ0aGlzLl9wdHMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKXX19Y2xhc3MgSWV7Y29uc3RydWN0b3IoKXtJZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBzPXR9c3RhdGljIGdldFBvbHlnb25zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBJZS5nZXRQb2x5Z29ucyh0LG5ldyBMKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBydD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgaHQmJnQuYXBwbHkobmV3IEllKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIHJ0JiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pdfX1jbGFzcyBOZXtjb25zdHJ1Y3Rvcigpe05lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRG9uZT0hMX1hcHBseVRvKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCkmJiF0aGlzLl9pc0RvbmU7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKG4gaW5zdGFuY2VvZiBodCl0aGlzLmFwcGx5VG8obik7ZWxzZSBpZih0aGlzLnZpc2l0KG4pLHRoaXMuaXNEb25lKCkpcmV0dXJuIHRoaXMuX2lzRG9uZT0hMCxudWxsfX19Y2xhc3Mgd2V7Y29uc3RydWN0b3IoKXt3ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX3ByZWNNb2RlbD1udWxsLHRoaXMuX2RpbT1uZXcgQ2UsdGhpcy5fblB0cz0xMDAsdGhpcy5fcm90YXRpb25BbmdsZT0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKXdlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IEx0KTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdD10LHRoaXMuX3ByZWNNb2RlbD10LmdldFByZWNpc2lvbk1vZGVsKCl9fWNyZWF0ZVN1cGVyY2lyY2xlKHQpe2NvbnN0IGU9MS90LG49dGhpcy5fZGltLmdldE1pblNpemUoKS8yLHM9dGhpcy5fZGltLmdldENlbnRyZSgpLGk9TWF0aC5wb3cobix0KSxyPW4sbz1NYXRoLnBvdyhpLzIsZSksbD1NYXRoLnRydW5jKHRoaXMuX25QdHMvOCksYT1uZXcgQXJyYXkoOCpsKzEpLmZpbGwobnVsbCksYz1vL2w7Zm9yKGxldCBuPTA7bjw9bDtuKyspe2xldCBvPTAsaD1yO2lmKDAhPT1uKXtvPWMqbjtjb25zdCBzPU1hdGgucG93KG8sdCk7aD1NYXRoLnBvdyhpLXMsZSl9YVtuXT10aGlzLmNvb3JkVHJhbnMobyxoLHMpLGFbMipsLW5dPXRoaXMuY29vcmRUcmFucyhoLG8scyksYVsyKmwrbl09dGhpcy5jb29yZFRyYW5zKGgsLW8scyksYVs0Kmwtbl09dGhpcy5jb29yZFRyYW5zKG8sLWgscyksYVs0Kmwrbl09dGhpcy5jb29yZFRyYW5zKC1vLC1oLHMpLGFbNipsLW5dPXRoaXMuY29vcmRUcmFucygtaCwtbyxzKSxhWzYqbCtuXT10aGlzLmNvb3JkVHJhbnMoLWgsbyxzKSxhWzgqbC1uXT10aGlzLmNvb3JkVHJhbnMoLW8saCxzKX1hW2EubGVuZ3RoLTFdPW5ldyBtKGFbMF0pO2NvbnN0IGg9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhhKSx1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oaCk7cmV0dXJuIHRoaXMucm90YXRlKHUpfXNldE51bVBvaW50cyh0KXt0aGlzLl9uUHRzPXR9c2V0QmFzZSh0KXt0aGlzLl9kaW0uc2V0QmFzZSh0KX1zZXRSb3RhdGlvbih0KXt0aGlzLl9yb3RhdGlvbkFuZ2xlPXR9c2V0V2lkdGgodCl7dGhpcy5fZGltLnNldFdpZHRoKHQpfWNyZWF0ZUVsbGlwc2UoKXtjb25zdCB0PXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLGU9dC5nZXRXaWR0aCgpLzIsbj10LmdldEhlaWdodCgpLzIscz10LmdldE1pblgoKStlLGk9dC5nZXRNaW5ZKCkrbixyPW5ldyBBcnJheSh0aGlzLl9uUHRzKzEpLmZpbGwobnVsbCk7bGV0IG89MDtmb3IobGV0IHQ9MDt0PHRoaXMuX25QdHM7dCsrKXtjb25zdCBsPXQqKDIqTWF0aC5QSS90aGlzLl9uUHRzKSxhPWUqTWF0aC5jb3MobCkrcyxjPW4qTWF0aC5zaW4obCkraTtyW28rK109dGhpcy5jb29yZChhLGMpfXJbb109bmV3IG0oclswXSk7Y29uc3QgbD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKHIpLGE9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihsKTtyZXR1cm4gdGhpcy5yb3RhdGUoYSl9Y29vcmRUcmFucyh0LGUsbil7cmV0dXJuIHRoaXMuY29vcmQodCtuLngsZStuLnkpfWNyZWF0ZVNxdWlyY2xlKCl7cmV0dXJuIHRoaXMuY3JlYXRlU3VwZXJjaXJjbGUoNCl9c2V0RW52ZWxvcGUodCl7dGhpcy5fZGltLnNldEVudmVsb3BlKHQpfXNldENlbnRyZSh0KXt0aGlzLl9kaW0uc2V0Q2VudHJlKHQpfWNyZWF0ZUFyYyh0LGUpe2NvbnN0IG49dGhpcy5fZGltLmdldEVudmVsb3BlKCkscz1uLmdldFdpZHRoKCkvMixpPW4uZ2V0SGVpZ2h0KCkvMixyPW4uZ2V0TWluWCgpK3Msbz1uLmdldE1pblkoKStpO2xldCBsPWU7KGw8PTB8fGw+MipNYXRoLlBJKSYmKGw9MipNYXRoLlBJKTtjb25zdCBhPWwvKHRoaXMuX25QdHMtMSksYz1uZXcgQXJyYXkodGhpcy5fblB0cykuZmlsbChudWxsKTtsZXQgaD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fblB0cztlKyspe2NvbnN0IG49dCtlKmEsbD1zKk1hdGguY29zKG4pK3IsdT1pKk1hdGguc2luKG4pK287Y1toKytdPXRoaXMuY29vcmQobCx1KX1jb25zdCB1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoYyk7cmV0dXJuIHRoaXMucm90YXRlKHUpfXJvdGF0ZSh0KXtpZigwIT09dGhpcy5fcm90YXRpb25BbmdsZSl7Y29uc3QgZT1pZS5yb3RhdGlvbkluc3RhbmNlKHRoaXMuX3JvdGF0aW9uQW5nbGUsdGhpcy5fZGltLmdldENlbnRyZSgpLngsdGhpcy5fZGltLmdldENlbnRyZSgpLnkpO3QuYXBwbHkoZSl9cmV0dXJuIHR9Y29vcmQodCxlKXtjb25zdCBuPW5ldyBtKHQsZSk7cmV0dXJuIHRoaXMuX3ByZWNNb2RlbC5tYWtlUHJlY2lzZShuKSxufWNyZWF0ZUFyY1BvbHlnb24odCxlKXtjb25zdCBuPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLHM9bi5nZXRXaWR0aCgpLzIsaT1uLmdldEhlaWdodCgpLzIscj1uLmdldE1pblgoKStzLG89bi5nZXRNaW5ZKCkraTtsZXQgbD1lOyhsPD0wfHxsPjIqTWF0aC5QSSkmJihsPTIqTWF0aC5QSSk7Y29uc3QgYT1sLyh0aGlzLl9uUHRzLTEpLGM9bmV3IEFycmF5KHRoaXMuX25QdHMrMikuZmlsbChudWxsKTtsZXQgaD0wO2NbaCsrXT10aGlzLmNvb3JkKHIsbyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9uUHRzO2UrKyl7Y29uc3Qgbj10K2EqZSxsPXMqTWF0aC5jb3Mobikrcix1PWkqTWF0aC5zaW4obikrbztjW2grK109dGhpcy5jb29yZChsLHUpfWNbaCsrXT10aGlzLmNvb3JkKHIsbyk7Y29uc3QgdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGMpLGc9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbih1KTtyZXR1cm4gdGhpcy5yb3RhdGUoZyl9Y3JlYXRlUmVjdGFuZ2xlKCl7bGV0IHQ9bnVsbCxlPTAsbj1NYXRoLnRydW5jKHRoaXMuX25QdHMvNCk7bjwxJiYobj0xKTtjb25zdCBzPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLmdldFdpZHRoKCkvbixpPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLmdldEhlaWdodCgpL24scj1uZXcgQXJyYXkoNCpuKzEpLmZpbGwobnVsbCksbz10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKTtmb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNaW5YKCkrdCpzLGk9by5nZXRNaW5ZKCk7cltlKytdPXRoaXMuY29vcmQobixpKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNYXhYKCkscz1vLmdldE1pblkoKSt0Kmk7cltlKytdPXRoaXMuY29vcmQobixzKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNYXhYKCktdCpzLGk9by5nZXRNYXhZKCk7cltlKytdPXRoaXMuY29vcmQobixpKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNaW5YKCkscz1vLmdldE1heFkoKS10Kmk7cltlKytdPXRoaXMuY29vcmQobixzKX1yW2UrK109bmV3IG0oclswXSk7Y29uc3QgbD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKHIpLGE9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihsKTtyZXR1cm4gdGhpcy5yb3RhdGUoYSl9Y3JlYXRlQ2lyY2xlKCl7cmV0dXJuIHRoaXMuY3JlYXRlRWxsaXBzZSgpfXNldEhlaWdodCh0KXt0aGlzLl9kaW0uc2V0SGVpZ2h0KHQpfXNldFNpemUodCl7dGhpcy5fZGltLnNldFNpemUodCl9fWNsYXNzIENle2NvbnN0cnVjdG9yKCl7Q2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5iYXNlPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLndpZHRoPW51bGwsdGhpcy5oZWlnaHQ9bnVsbH1zZXRCYXNlKHQpe3RoaXMuYmFzZT10fXNldFdpZHRoKHQpe3RoaXMud2lkdGg9dH1nZXRCYXNlKCl7cmV0dXJuIHRoaXMuYmFzZX1nZXRXaWR0aCgpe3JldHVybiB0aGlzLndpZHRofXNldEVudmVsb3BlKHQpe3RoaXMud2lkdGg9dC5nZXRXaWR0aCgpLHRoaXMuaGVpZ2h0PXQuZ2V0SGVpZ2h0KCksdGhpcy5iYXNlPW5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLmNlbnRyZT1uZXcgbSh0LmNlbnRyZSgpKX1zZXRDZW50cmUodCl7dGhpcy5jZW50cmU9dH1nZXRNaW5TaXplKCl7cmV0dXJuIE1hdGgubWluKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpfWdldEVudmVsb3BlKCl7cmV0dXJuIG51bGwhPT10aGlzLmJhc2U/bmV3IE8odGhpcy5iYXNlLngsdGhpcy5iYXNlLngrdGhpcy53aWR0aCx0aGlzLmJhc2UueSx0aGlzLmJhc2UueSt0aGlzLmhlaWdodCk6bnVsbCE9PXRoaXMuY2VudHJlP25ldyBPKHRoaXMuY2VudHJlLngtdGhpcy53aWR0aC8yLHRoaXMuY2VudHJlLngrdGhpcy53aWR0aC8yLHRoaXMuY2VudHJlLnktdGhpcy5oZWlnaHQvMix0aGlzLmNlbnRyZS55K3RoaXMuaGVpZ2h0LzIpOm5ldyBPKDAsdGhpcy53aWR0aCwwLHRoaXMuaGVpZ2h0KX1nZXRDZW50cmUoKXtyZXR1cm4gbnVsbD09PXRoaXMuY2VudHJlJiYodGhpcy5jZW50cmU9bmV3IG0odGhpcy5iYXNlLngrdGhpcy53aWR0aC8yLHRoaXMuYmFzZS55K3RoaXMuaGVpZ2h0LzIpKSx0aGlzLmNlbnRyZX1nZXRIZWlnaHQoKXtyZXR1cm4gdGhpcy5oZWlnaHR9c2V0SGVpZ2h0KHQpe3RoaXMuaGVpZ2h0PXR9c2V0U2l6ZSh0KXt0aGlzLmhlaWdodD10LHRoaXMud2lkdGg9dH19d2UuRGltZW5zaW9ucz1DZTtjbGFzcyBTZSBleHRlbmRzIHdle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxTZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9udW1Bcm1zPTgsdGhpcy5fYXJtTGVuZ3RoUmF0aW89LjUsMD09PWFyZ3VtZW50cy5sZW5ndGgpd2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07d2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19c3RhdGljIGNyZWF0ZSh0LGUsbixzLGkpe2NvbnN0IHI9bmV3IFNlO3Iuc2V0Q2VudHJlKHQpLHIuc2V0U2l6ZShlKSxyLnNldE51bVBvaW50cyhuKSxyLnNldEFybUxlbmd0aFJhdGlvKGkpLHIuc2V0TnVtQXJtcyhzKTtyZXR1cm4gci5jcmVhdGVTaW5lU3RhcigpfXNldE51bUFybXModCl7dGhpcy5fbnVtQXJtcz10fXNldEFybUxlbmd0aFJhdGlvKHQpe3RoaXMuX2FybUxlbmd0aFJhdGlvPXR9Y3JlYXRlU2luZVN0YXIoKXtjb25zdCB0PXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLGU9dC5nZXRXaWR0aCgpLzI7bGV0IG49dGhpcy5fYXJtTGVuZ3RoUmF0aW87bjwwJiYobj0wKSxuPjEmJihuPTEpO2NvbnN0IHM9biplLGk9KDEtbikqZSxyPXQuZ2V0TWluWCgpK2Usbz10LmdldE1pblkoKStlLGw9bmV3IEFycmF5KHRoaXMuX25QdHMrMSkuZmlsbChudWxsKTtsZXQgYT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fblB0czt0Kyspe2NvbnN0IGU9dC90aGlzLl9uUHRzKnRoaXMuX251bUFybXMsbj1lLU1hdGguZmxvb3IoZSksYz0yKk1hdGguUEkqbixoPWkrcyooKE1hdGguY29zKGMpKzEpLzIpLHU9dCooMipNYXRoLlBJL3RoaXMuX25QdHMpLGc9aCpNYXRoLmNvcyh1KStyLGQ9aCpNYXRoLnNpbih1KStvO2xbYSsrXT10aGlzLmNvb3JkKGcsZCl9bFthXT1uZXcgbShsWzBdKTtjb25zdCBjPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcobCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oYyl9fXZhciBMZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBZmZpbmVUcmFuc2Zvcm1hdGlvbjppZSxBZmZpbmVUcmFuc2Zvcm1hdGlvbkJ1aWxkZXI6b2UsQWZmaW5lVHJhbnNmb3JtYXRpb25GYWN0b3J5OmxlLENvbXBvbmVudENvb3JkaW5hdGVFeHRyYWN0ZXI6YWUsR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyOmNlLEdlb21ldHJ5Q29tYmluZXI6aGUsR2VvbWV0cnlFZGl0b3I6dWUsR2VvbWV0cnlFeHRyYWN0ZXI6ZGUsR2VvbWV0cnlNYXBwZXI6X2UsR2VvbWV0cnlUcmFuc2Zvcm1lcjptZSxMaW5lU3RyaW5nRXh0cmFjdGVyOmZlLExpbmVhckNvbXBvbmVudEV4dHJhY3Rlcjp5ZSxQb2ludEV4dHJhY3RlcjpFZSxQb2x5Z29uRXh0cmFjdGVyOkllLFNob3J0Q2lyY3VpdGVkR2VvbWV0cnlWaXNpdG9yOk5lLFNpbmVTdGFyRmFjdG9yeTpTZX0pLFRlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvb3JkaW5hdGU6bSxDb29yZGluYXRlWFk6eSxDb29yZGluYXRlWFlNOngsQ29vcmRpbmF0ZVhZWk06RSxDb29yZGluYXRlTGlzdDpSLENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcjpQLEVudmVsb3BlOk8sTGluZVNlZ21lbnQ6S3QsR2VvbWV0cnlGYWN0b3J5Okx0LEdlb21ldHJ5OlUsUG9pbnQ6ZXQsTGluZVN0cmluZzokLExpbmVhclJpbmc6Z3QsUG9seWdvbjpydCxHZW9tZXRyeUNvbGxlY3Rpb246aHQsTXVsdGlQb2ludDp1dCxNdWx0aUxpbmVTdHJpbmc6U3QsTXVsdGlQb2x5Z29uOnl0LERpbWVuc2lvbjpRLEludGVyc2VjdGlvbk1hdHJpeDpKdCxQcmVjaXNpb25Nb2RlbDp3dCxMb2NhdGlvbjpRdCxUcmlhbmdsZTpuZSx1dGlsOkxlfSk7Y2xhc3MgUmV7Y29uc3RydWN0b3IoKXtSZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdD1bbmV3IG0sbmV3IG1dLHRoaXMuX2Rpc3RhbmNlPXIuTmFOLHRoaXMuX2lzTnVsbD0hMH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdFt0XX1zZXRNaW5pbXVtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TWluaW11bSh0Ll9wdFswXSx0Ll9wdFsxXSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNOdWxsKXJldHVybiB0aGlzLmluaXRpYWxpemUodCxlKSxudWxsO2NvbnN0IG49dC5kaXN0YW5jZShlKTtuPHRoaXMuX2Rpc3RhbmNlJiZ0aGlzLmluaXRpYWxpemUodCxlLG4pfX1pbml0aWFsaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5faXNOdWxsPSEwO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUodCksdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShlKSx0aGlzLl9kaXN0YW5jZT10LmRpc3RhbmNlKGUpLHRoaXMuX2lzTnVsbD0hMX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHQpLHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUoZSksdGhpcy5fZGlzdGFuY2U9bix0aGlzLl9pc051bGw9ITF9fXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyh0aGlzLl9wdFswXSx0aGlzLl9wdFsxXSl9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9c2V0TWF4aW11bSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldE1heGltdW0odC5fcHRbMF0sdC5fcHRbMV0pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzTnVsbClyZXR1cm4gdGhpcy5pbml0aWFsaXplKHQsZSksbnVsbDtjb25zdCBuPXQuZGlzdGFuY2UoZSk7bj50aGlzLl9kaXN0YW5jZSYmdGhpcy5pbml0aWFsaXplKHQsZSxuKX19fWNsYXNzIFBle3N0YXRpYyBjb21wdXRlRGlzdGFuY2UoKXtpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFJlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgS3QsaT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxpLmxlbmd0aC0xO3QrKyl7cy5zZXRDb29yZGluYXRlcyhpW3RdLGlbdCsxXSk7Y29uc3Qgcj1zLmNsb3Nlc3RQb2ludChlKTtuLnNldE1pbmltdW0ocixlKX19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFJlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHJ0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO1BlLmNvbXB1dGVEaXN0YW5jZSh0LmdldEV4dGVyaW9yUmluZygpLGUsbik7Zm9yKGxldCBzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKylQZS5jb21wdXRlRGlzdGFuY2UodC5nZXRJbnRlcmlvclJpbmdOKHMpLGUsbil9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFJlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodCBpbnN0YW5jZW9mICQpUGUuY29tcHV0ZURpc3RhbmNlKHQsZSxuKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBydClQZS5jb21wdXRlRGlzdGFuY2UodCxlLG4pO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXtjb25zdCBzPXQ7Zm9yKGxldCB0PTA7dDxzLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IGk9cy5nZXRHZW9tZXRyeU4odCk7UGUuY29tcHV0ZURpc3RhbmNlKGksZSxuKX19ZWxzZSBuLnNldE1pbmltdW0odC5nZXRDb29yZGluYXRlKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFJlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzBdLmNsb3Nlc3RQb2ludCh0KTtlLnNldE1pbmltdW0obix0KX19fWNsYXNzIE9le2NvbnN0cnVjdG9yKCl7T2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZzA9bnVsbCx0aGlzLl9nMT1udWxsLHRoaXMuX3B0RGlzdD1uZXcgUmUsdGhpcy5fZGVuc2lmeUZyYWM9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nMD10LHRoaXMuX2cxPWV9c3RhdGljIGRpc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgT2UoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkuZGlzdGFuY2UoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMl0sZT1uZXcgT2UoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSk7cmV0dXJuIGUuc2V0RGVuc2lmeUZyYWN0aW9uKHQpLGUuZGlzdGFuY2UoKX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHREaXN0LmdldENvb3JkaW5hdGVzKCl9c2V0RGVuc2lmeUZyYWN0aW9uKHQpe2lmKHQ+MXx8dDw9MCl0aHJvdyBuZXcgcyhcIkZyYWN0aW9uIGlzIG5vdCBpbiByYW5nZSAoMC4wIC0gMS4wXVwiKTt0aGlzLl9kZW5zaWZ5RnJhYz10fWNvbXB1dGUodCxlKXt0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHQsZSx0aGlzLl9wdERpc3QpLHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UoZSx0LHRoaXMuX3B0RGlzdCl9ZGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlKHRoaXMuX2cwLHRoaXMuX2cxKSx0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKX1jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz1uZXcgdmUoZSk7aWYodC5hcHBseShzKSxuLnNldE1heGltdW0ocy5nZXRNYXhQb2ludERpc3RhbmNlKCkpLHRoaXMuX2RlbnNpZnlGcmFjPjApe2NvbnN0IHM9bmV3IGJlKGUsdGhpcy5fZGVuc2lmeUZyYWMpO3QuYXBwbHkocyksbi5zZXRNYXhpbXVtKHMuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKX19b3JpZW50ZWREaXN0YW5jZSgpe3JldHVybiB0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHRoaXMuX2cwLHRoaXMuX2cxLHRoaXMuX3B0RGlzdCksdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKCl9fWNsYXNzIHZle2NvbnN0cnVjdG9yKCl7dmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWF4UHREaXN0PW5ldyBSZSx0aGlzLl9taW5QdERpc3Q9bmV3IFJlLHRoaXMuX2V1Y2xpZGVhbkRpc3Q9bmV3IFBlLHRoaXMuX2dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tPXR9ZmlsdGVyKHQpe3RoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCksUGUuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sdCx0aGlzLl9taW5QdERpc3QpLHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCl9Z2V0TWF4UG9pbnREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9tYXhQdERpc3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hdfX1jbGFzcyBiZXtjb25zdHJ1Y3Rvcigpe2JlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21heFB0RGlzdD1uZXcgUmUsdGhpcy5fbWluUHREaXN0PW5ldyBSZSx0aGlzLl9nZW9tPW51bGwsdGhpcy5fbnVtU3ViU2Vncz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb209dCx0aGlzLl9udW1TdWJTZWdzPU1hdGgudHJ1bmMoTWF0aC5yb3VuZCgxL2UpKX1maWx0ZXIodCxlKXtpZigwPT09ZSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZShlLTEpLHM9dC5nZXRDb29yZGluYXRlKGUpLGk9KHMueC1uLngpL3RoaXMuX251bVN1YlNlZ3Mscj0ocy55LW4ueSkvdGhpcy5fbnVtU3ViU2Vncztmb3IobGV0IHQ9MDt0PHRoaXMuX251bVN1YlNlZ3M7dCsrKXtjb25zdCBlPW4ueCt0Kmkscz1uLnkrdCpyLG89bmV3IG0oZSxzKTt0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpLFBlLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLG8sdGhpcy5fbWluUHREaXN0KSx0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpfX1pc0RvbmUoKXtyZXR1cm4hMX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiExfWdldE1heFBvaW50RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fbWF4UHREaXN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltQXX19T2UuTWF4UG9pbnREaXN0YW5jZUZpbHRlcj12ZSxPZS5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXI9YmU7dmFyIE1lPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2U6T2UsRGlzdGFuY2VUb1BvaW50OlBlLFBvaW50UGFpckRpc3RhbmNlOlJlfSk7Y2xhc3MgRGV7dmlzaXRJdGVtKHQpe319Y2xhc3MgQWV7bG9jYXRlKHQpe319Y2xhc3MgRmV7Y29uc3RydWN0b3IoKXtGZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9taW49ci5QT1NJVElWRV9JTkZJTklUWSx0aGlzLl9tYXg9ci5ORUdBVElWRV9JTkZJTklUWX1nZXRNaW4oKXtyZXR1cm4gdGhpcy5fbWlufWludGVyc2VjdHModCxlKXtyZXR1cm4hKHRoaXMuX21pbj5lfHx0aGlzLl9tYXg8dCl9Z2V0TWF4KCl7cmV0dXJuIHRoaXMuX21heH10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcobmV3IG0odGhpcy5fbWluLDApLG5ldyBtKHRoaXMuX21heCwwKSl9fUZlLk5vZGVDb21wYXJhdG9yPWNsYXNze2NvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lLGk9KG4uX21pbituLl9tYXgpLzIscj0ocy5fbWluK3MuX21heCkvMjtyZXR1cm4gaTxyPy0xOmk+cj8xOjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX07Y2xhc3MgR2UgZXh0ZW5kcyBGZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksR2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXRlbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21pbj10LHRoaXMuX21heD1lLHRoaXMuX2l0ZW09bn1xdWVyeSh0LGUsbil7aWYoIXRoaXMuaW50ZXJzZWN0cyh0LGUpKXJldHVybiBudWxsO24udmlzaXRJdGVtKHRoaXMuX2l0ZW0pfX1jbGFzcyBxZSBleHRlbmRzIEZle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxxZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2RlMT1udWxsLHRoaXMuX25vZGUyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbm9kZTE9dCx0aGlzLl9ub2RlMj1lLHRoaXMuYnVpbGRFeHRlbnQodGhpcy5fbm9kZTEsdGhpcy5fbm9kZTIpfWJ1aWxkRXh0ZW50KHQsZSl7dGhpcy5fbWluPU1hdGgubWluKHQuX21pbixlLl9taW4pLHRoaXMuX21heD1NYXRoLm1heCh0Ll9tYXgsZS5fbWF4KX1xdWVyeSh0LGUsbil7aWYoIXRoaXMuaW50ZXJzZWN0cyh0LGUpKXJldHVybiBudWxsO251bGwhPT10aGlzLl9ub2RlMSYmdGhpcy5fbm9kZTEucXVlcnkodCxlLG4pLG51bGwhPT10aGlzLl9ub2RlMiYmdGhpcy5fbm9kZTIucXVlcnkodCxlLG4pfX1jbGFzcyBCZXtjb25zdHJ1Y3Rvcigpe0JlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xlYXZlcz1uZXcgTCx0aGlzLl9yb290PW51bGwsdGhpcy5fbGV2ZWw9MH1idWlsZFRyZWUoKXt4ZS5zb3J0KHRoaXMuX2xlYXZlcyxuZXcgRmUuTm9kZUNvbXBhcmF0b3IpO2xldCB0PXRoaXMuX2xlYXZlcyxlPW51bGwsbj1uZXcgTDtmb3IoOzspe2lmKHRoaXMuYnVpbGRMZXZlbCh0LG4pLDE9PT1uLnNpemUoKSlyZXR1cm4gbi5nZXQoMCk7ZT10LHQ9bixuPWV9fWluc2VydCh0LGUsbil7aWYobnVsbCE9PXRoaXMuX3Jvb3QpdGhyb3cgbmV3IEQoXCJJbmRleCBjYW5ub3QgYmUgYWRkZWQgdG8gb25jZSBpdCBoYXMgYmVlbiBxdWVyaWVkXCIpO3RoaXMuX2xlYXZlcy5hZGQobmV3IEdlKHQsZSxuKSl9cXVlcnkodCxlLG4pe2lmKHRoaXMuaW5pdCgpLG51bGw9PT10aGlzLl9yb290KXJldHVybiBudWxsO3RoaXMuX3Jvb3QucXVlcnkodCxlLG4pfWJ1aWxkUm9vdCgpe2lmKG51bGwhPT10aGlzLl9yb290KXJldHVybiBudWxsO3RoaXMuX3Jvb3Q9dGhpcy5idWlsZFRyZWUoKX1wcmludE5vZGUodCl7WS5vdXQucHJpbnRsbihXdC50b0xpbmVTdHJpbmcobmV3IG0odC5fbWluLHRoaXMuX2xldmVsKSxuZXcgbSh0Ll9tYXgsdGhpcy5fbGV2ZWwpKSl9aW5pdCgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdHx8MD09PXRoaXMuX2xlYXZlcy5zaXplKCk/bnVsbDp2b2lkIHRoaXMuYnVpbGRSb290KCl9YnVpbGRMZXZlbCh0LGUpe3RoaXMuX2xldmVsKyssZS5jbGVhcigpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bis9Mil7Y29uc3Qgcz10LmdldChuKTtpZihudWxsPT09KG4rMTx0LnNpemUoKT90LmdldChuKTpudWxsKSllLmFkZChzKTtlbHNle2NvbnN0IHM9bmV3IHFlKHQuZ2V0KG4pLHQuZ2V0KG4rMSkpO2UuYWRkKHMpfX19fWNsYXNzIFlle2NvbnN0cnVjdG9yKCl7WWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXRlbXM9bmV3IEx9dmlzaXRJdGVtKHQpe3RoaXMuX2l0ZW1zLmFkZCh0KX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRGVdfX1jbGFzcyBWZXtjb25zdHJ1Y3Rvcigpe1ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3A9bnVsbCx0aGlzLl9jcm9zc2luZ0NvdW50PTAsdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wPXR9c3RhdGljIGxvY2F0ZVBvaW50SW5SaW5nKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZJKGFyZ3VtZW50c1sxXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1uZXcgVmUoYXJndW1lbnRzWzBdKSxuPW5ldyBtLHM9bmV3IG07Zm9yKGxldCBpPTE7aTx0LnNpemUoKTtpKyspaWYodC5nZXRDb29yZGluYXRlKGksbiksdC5nZXRDb29yZGluYXRlKGktMSxzKSxlLmNvdW50U2VnbWVudChuLHMpLGUuaXNPblNlZ21lbnQoKSlyZXR1cm4gZS5nZXRMb2NhdGlvbigpO3JldHVybiBlLmdldExvY2F0aW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPW5ldyBWZShhcmd1bWVudHNbMF0pO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl0saT10W24tMV07aWYoZS5jb3VudFNlZ21lbnQocyxpKSxlLmlzT25TZWdtZW50KCkpcmV0dXJuIGUuZ2V0TG9jYXRpb24oKX1yZXR1cm4gZS5nZXRMb2NhdGlvbigpfX1jb3VudFNlZ21lbnQodCxlKXtpZih0Lng8dGhpcy5fcC54JiZlLng8dGhpcy5fcC54KXJldHVybiBudWxsO2lmKHRoaXMuX3AueD09PWUueCYmdGhpcy5fcC55PT09ZS55KXJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwLG51bGw7aWYodC55PT09dGhpcy5fcC55JiZlLnk9PT10aGlzLl9wLnkpe2xldCBuPXQueCxzPWUueDtyZXR1cm4gbj5zJiYobj1lLngscz10LngpLHRoaXMuX3AueD49biYmdGhpcy5fcC54PD1zJiYodGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCksbnVsbH1pZih0Lnk+dGhpcy5fcC55JiZlLnk8PXRoaXMuX3AueXx8ZS55PnRoaXMuX3AueSYmdC55PD10aGlzLl9wLnkpe2xldCBuPXEuaW5kZXgodCxlLHRoaXMuX3ApO2lmKG49PT1xLkNPTExJTkVBUilyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2UueTx0LnkmJihuPS1uKSxuPT09cS5MRUZUJiZ0aGlzLl9jcm9zc2luZ0NvdW50Kyt9fWlzUG9pbnRJblBvbHlnb24oKXtyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpIT09UXQuRVhURVJJT1J9Z2V0TG9jYXRpb24oKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD9RdC5CT1VOREFSWTp0aGlzLl9jcm9zc2luZ0NvdW50JTI9PTE/UXQuSU5URVJJT1I6UXQuRVhURVJJT1J9aXNPblNlZ21lbnQoKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudH19Y2xhc3MgemV7Y29uc3RydWN0b3IoKXt6ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW51bGwsdGhpcy5faW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTtpZighKEkodCxpdCl8fHQgaW5zdGFuY2VvZiBndCkpdGhyb3cgbmV3IHMoXCJBcmd1bWVudCBtdXN0IGJlIFBvbHlnb25hbCBvciBMaW5lYXJSaW5nXCIpO3RoaXMuX2dlb209dH1sb2NhdGUodCl7bnVsbD09PXRoaXMuX2luZGV4JiYodGhpcy5faW5kZXg9bmV3IGtlKHRoaXMuX2dlb20pLHRoaXMuX2dlb209bnVsbCk7Y29uc3QgZT1uZXcgVmUodCksbj1uZXcgWGUoZSk7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHQueSx0LnksbiksZS5nZXRMb2NhdGlvbigpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fWNsYXNzIFhle2NvbnN0cnVjdG9yKCl7WGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY291bnRlcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvdW50ZXI9dH12aXNpdEl0ZW0odCl7Y29uc3QgZT10O3RoaXMuX2NvdW50ZXIuY291bnRTZWdtZW50KGUuZ2V0Q29vcmRpbmF0ZSgwKSxlLmdldENvb3JkaW5hdGUoMSkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltEZV19fWNsYXNzIGtle2NvbnN0cnVjdG9yKCl7a2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNFbXB0eT0hMSx0aGlzLl9pbmRleD1uZXcgQmU7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5pc0VtcHR5KCk/dGhpcy5faXNFbXB0eT0hMDp0aGlzLmluaXQodCl9aW5pdCh0KXtmb3IobGV0IGU9eWUuZ2V0TGluZXModCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmFkZExpbmUodCl9fWFkZExpbmUodCl7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49bmV3IEt0KHRbZS0xXSx0W2VdKSxzPU1hdGgubWluKG4ucDAueSxuLnAxLnkpLGk9TWF0aC5tYXgobi5wMC55LG4ucDEueSk7dGhpcy5faW5kZXguaW5zZXJ0KHMsaSxuKX19cXVlcnkoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNFbXB0eSlyZXR1cm4gbmV3IEw7Y29uc3Qgbj1uZXcgWWU7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHQsZSxuKSxuLmdldEl0ZW1zKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX2lzRW1wdHkpcmV0dXJuIG51bGw7dGhpcy5faW5kZXgucXVlcnkodCxlLG4pfX19emUuU2VnbWVudFZpc2l0b3I9WGUsemUuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnk9a2U7Y2xhc3MgVWV7c3RhdGljIGlzT25MaW5lKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZJKGFyZ3VtZW50c1sxXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcganQscz1uZXcgbSxpPW5ldyBtLHI9ZS5zaXplKCk7Zm9yKGxldCBvPTE7bzxyO28rKylpZihlLmdldENvb3JkaW5hdGUoby0xLHMpLGUuZ2V0Q29vcmRpbmF0ZShvLGkpLG4uY29tcHV0ZUludGVyc2VjdGlvbih0LHMsaSksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGp0O2ZvcihsZXQgcz0xO3M8ZS5sZW5ndGg7cysrKXtjb25zdCBpPWVbcy0xXSxyPWVbc107aWYobi5jb21wdXRlSW50ZXJzZWN0aW9uKHQsaSxyKSxuLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiEwfXJldHVybiExfX1zdGF0aWMgbG9jYXRlSW5SaW5nKHQsZSl7cmV0dXJuIFZlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSl9c3RhdGljIGlzSW5SaW5nKHQsZSl7cmV0dXJuIFVlLmxvY2F0ZUluUmluZyh0LGUpIT09UXQuRVhURVJJT1J9fWNsYXNzIEhle2hhc05leHQoKXt9bmV4dCgpe31yZW1vdmUoKXt9fWNsYXNzIFdle2NvbnN0cnVjdG9yKCl7V2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcGFyZW50PW51bGwsdGhpcy5fYXRTdGFydD1udWxsLHRoaXMuX21heD1udWxsLHRoaXMuX2luZGV4PW51bGwsdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50PXQsdGhpcy5fYXRTdGFydD0hMCx0aGlzLl9pbmRleD0wLHRoaXMuX21heD10LmdldE51bUdlb21ldHJpZXMoKX1zdGF0aWMgaXNBdG9taWModCl7cmV0dXJuISh0IGluc3RhbmNlb2YgaHQpfW5leHQoKXtpZih0aGlzLl9hdFN0YXJ0KXJldHVybiB0aGlzLl9hdFN0YXJ0PSExLFdlLmlzQXRvbWljKHRoaXMuX3BhcmVudCkmJnRoaXMuX2luZGV4KyssdGhpcy5fcGFyZW50O2lmKG51bGwhPT10aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCk7dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9aWYodGhpcy5faW5kZXg+PXRoaXMuX21heCl0aHJvdyBuZXcgUztjb25zdCB0PXRoaXMuX3BhcmVudC5nZXRHZW9tZXRyeU4odGhpcy5faW5kZXgrKyk7cmV0dXJuIHQgaW5zdGFuY2VvZiBodD8odGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW5ldyBXZSh0KSx0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpKTp0fXJlbW92ZSgpe3Rocm93IG5ldyBLKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfWhhc05leHQoKXtpZih0aGlzLl9hdFN0YXJ0KXJldHVybiEwO2lmKG51bGwhPT10aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuITA7dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9cmV0dXJuISh0aGlzLl9pbmRleD49dGhpcy5fbWF4KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSGVdfX1jbGFzcyBaZXtjb25zdHJ1Y3Rvcigpe1plLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tPXR9c3RhdGljIGxvY2F0ZVBvaW50SW5Qb2x5Z29uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIFF0LkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRFeHRlcmlvclJpbmcoKSxzPVplLmxvY2F0ZVBvaW50SW5SaW5nKHQsbik7aWYocyE9PVF0LklOVEVSSU9SKXJldHVybiBzO2ZvcihsZXQgbj0wO248ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtuKyspe2NvbnN0IHM9ZS5nZXRJbnRlcmlvclJpbmdOKG4pLGk9WmUubG9jYXRlUG9pbnRJblJpbmcodCxzKTtpZihpPT09UXQuQk9VTkRBUlkpcmV0dXJuIFF0LkJPVU5EQVJZO2lmKGk9PT1RdC5JTlRFUklPUilyZXR1cm4gUXQuRVhURVJJT1J9cmV0dXJuIFF0LklOVEVSSU9SfXN0YXRpYyBsb2NhdGVQb2ludEluUmluZyh0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP1VlLmxvY2F0ZUluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6UXQuRVhURVJJT1J9c3RhdGljIGNvbnRhaW5zUG9pbnRJblBvbHlnb24odCxlKXtyZXR1cm4gUXQuRVhURVJJT1IhPT1aZS5sb2NhdGVQb2ludEluUG9seWdvbih0LGUpfXN0YXRpYyBsb2NhdGVJbkdlb21ldHJ5KHQsZSl7aWYoZSBpbnN0YW5jZW9mIHJ0KXJldHVybiBaZS5sb2NhdGVQb2ludEluUG9seWdvbih0LGUpO2lmKGUgaW5zdGFuY2VvZiBodCl7Y29uc3Qgbj1uZXcgV2UoZSk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocyE9PWUpe2NvbnN0IGU9WmUubG9jYXRlSW5HZW9tZXRyeSh0LHMpO2lmKGUhPT1RdC5FWFRFUklPUilyZXR1cm4gZX19fXJldHVybiBRdC5FWFRFUklPUn1zdGF0aWMgaXNDb250YWluZWQodCxlKXtyZXR1cm4gUXQuRVhURVJJT1IhPT1aZS5sb2NhdGUodCxlKX1zdGF0aWMgbG9jYXRlKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP1F0LkVYVEVSSU9SOmUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/WmUubG9jYXRlSW5HZW9tZXRyeSh0LGUpOlF0LkVYVEVSSU9SfWxvY2F0ZSh0KXtyZXR1cm4gWmUubG9jYXRlKHQsdGhpcy5fZ2VvbSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX19dmFyIGplPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3I6emUsUG9pbnRPbkdlb21ldHJ5TG9jYXRvcjpBZSxTaW1wbGVQb2ludEluQXJlYUxvY2F0b3I6WmV9KTtjbGFzcyBLZXttZWFzdXJlKHQsZSl7fX1jbGFzcyBRZXtzdGF0aWMgZGlhZ29uYWxTaXplKHQpe2lmKHQuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpO3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9bWVhc3VyZSh0LGUpe2NvbnN0IG49T2UuZGlzdGFuY2UodCxlLFFlLkRFTlNJRllfRlJBQ1RJT04pLHM9bmV3IE8odC5nZXRFbnZlbG9wZUludGVybmFsKCkpO3MuZXhwYW5kVG9JbmNsdWRlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gMS1uL1FlLmRpYWdvbmFsU2l6ZShzKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bS2VdfX1RZS5ERU5TSUZZX0ZSQUNUSU9OPS4yNTt2YXIgSmU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQXJlYVNpbWlsYXJpdHlNZWFzdXJlOmNsYXNze21lYXN1cmUodCxlKXtyZXR1cm4gdC5pbnRlcnNlY3Rpb24oZSkuZ2V0QXJlYSgpL3QudW5pb24oZSkuZ2V0QXJlYSgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltLZV19fSxIYXVzZG9yZmZTaW1pbGFyaXR5TWVhc3VyZTpRZSxTaW1pbGFyaXR5TWVhc3VyZTpLZSxTaW1pbGFyaXR5TWVhc3VyZUNvbWJpbmVyOmNsYXNze3N0YXRpYyBjb21iaW5lKHQsZSl7cmV0dXJuIE1hdGgubWluKHQsZSl9fX0pO2NsYXNzICRle2NvbnN0cnVjdG9yKCl7JGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fYXJlYUJhc2VQdD1udWxsLHRoaXMuX3RyaWFuZ2xlQ2VudDM9bmV3IG0sdGhpcy5fYXJlYXN1bTI9MCx0aGlzLl9jZzM9bmV3IG0sdGhpcy5fbGluZUNlbnRTdW09bmV3IG0sdGhpcy5fdG90YWxMZW5ndGg9MCx0aGlzLl9wdENvdW50PTAsdGhpcy5fcHRDZW50U3VtPW5ldyBtO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZWFCYXNlUHQ9bnVsbCx0aGlzLmFkZCh0KX1zdGF0aWMgYXJlYTIodCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKG4ueC10LngpKihlLnktdC55KX1zdGF0aWMgY2VudHJvaWQzKHQsZSxuLHMpe3JldHVybiBzLng9dC54K2UueCtuLngscy55PXQueStlLnkrbi55LG51bGx9c3RhdGljIGdldENlbnRyb2lkKHQpe3JldHVybiBuZXcgJGUodCkuZ2V0Q2VudHJvaWQoKX1zZXRBcmVhQmFzZVBvaW50KHQpe3RoaXMuX2FyZWFCYXNlUHQ9dH1hZGRQb2ludCh0KXt0aGlzLl9wdENvdW50Kz0xLHRoaXMuX3B0Q2VudFN1bS54Kz10LngsdGhpcy5fcHRDZW50U3VtLnkrPXQueX1hZGRMaW5lU2VnbWVudHModCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXtjb25zdCBzPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtpZigwPT09cyljb250aW51ZTtlKz1zO2NvbnN0IGk9KHRbbl0ueCt0W24rMV0ueCkvMjt0aGlzLl9saW5lQ2VudFN1bS54Kz1zKmk7Y29uc3Qgcj0odFtuXS55K3RbbisxXS55KS8yO3RoaXMuX2xpbmVDZW50U3VtLnkrPXMqcn10aGlzLl90b3RhbExlbmd0aCs9ZSwwPT09ZSYmdC5sZW5ndGg+MCYmdGhpcy5hZGRQb2ludCh0WzBdKX1hZGRIb2xlKHQpe2NvbnN0IGU9cS5pc0NDVyh0KTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5fYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX1nZXRDZW50cm9pZCgpe2NvbnN0IHQ9bmV3IG07aWYoTWF0aC5hYnModGhpcy5fYXJlYXN1bTIpPjApdC54PXRoaXMuX2NnMy54LzMvdGhpcy5fYXJlYXN1bTIsdC55PXRoaXMuX2NnMy55LzMvdGhpcy5fYXJlYXN1bTI7ZWxzZSBpZih0aGlzLl90b3RhbExlbmd0aD4wKXQueD10aGlzLl9saW5lQ2VudFN1bS54L3RoaXMuX3RvdGFsTGVuZ3RoLHQueT10aGlzLl9saW5lQ2VudFN1bS55L3RoaXMuX3RvdGFsTGVuZ3RoO2Vsc2V7aWYoISh0aGlzLl9wdENvdW50PjApKXJldHVybiBudWxsO3QueD10aGlzLl9wdENlbnRTdW0ueC90aGlzLl9wdENvdW50LHQueT10aGlzLl9wdENlbnRTdW0ueS90aGlzLl9wdENvdW50fXJldHVybiB0fWFkZFNoZWxsKHQpe3QubGVuZ3RoPjAmJnRoaXMuc2V0QXJlYUJhc2VQb2ludCh0WzBdKTtjb25zdCBlPSFxLmlzQ0NXKHQpO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLl9hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfWFkZFRyaWFuZ2xlKHQsZSxuLHMpe2NvbnN0IGk9cz8xOi0xOyRlLmNlbnRyb2lkMyh0LGUsbix0aGlzLl90cmlhbmdsZUNlbnQzKTtjb25zdCByPSRlLmFyZWEyKHQsZSxuKTt0aGlzLl9jZzMueCs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueCx0aGlzLl9jZzMueSs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueSx0aGlzLl9hcmVhc3VtMis9aSpyfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkU2hlbGwodC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuYWRkSG9sZSh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBldCl0aGlzLmFkZFBvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiAkKXRoaXMuYWRkTGluZVNlZ21lbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgcnQpe2NvbnN0IGU9dDt0aGlzLmFkZChlKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBodCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKHQpKX19fX1jbGFzcyB0biBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtFbXB0eVN0YWNrRXhjZXB0aW9uOnRufSlbMF19fWNsYXNzIGVuIGV4dGVuZHMgQ3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5hcnJheT1bXX1hZGQodCl7cmV0dXJuIHRoaXMuYXJyYXkucHVzaCh0KSwhMH1nZXQodCl7aWYodDwwfHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgdztyZXR1cm4gdGhpcy5hcnJheVt0XX1wdXNoKHQpe3JldHVybiB0aGlzLmFycmF5LnB1c2godCksdH1wb3AoKXtpZigwPT09dGhpcy5hcnJheS5sZW5ndGgpdGhyb3cgbmV3IHRuO3JldHVybiB0aGlzLmFycmF5LnBvcCgpfXBlZWsoKXtpZigwPT09dGhpcy5hcnJheS5sZW5ndGgpdGhyb3cgbmV3IHRuO3JldHVybiB0aGlzLmFycmF5W3RoaXMuYXJyYXkubGVuZ3RoLTFdfWVtcHR5KCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Lmxlbmd0aH1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuZW1wdHkoKX1zZWFyY2godCl7cmV0dXJuIHRoaXMuYXJyYXkuaW5kZXhPZih0KX1zaXplKCl7cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RofXRvQXJyYXkoKXtyZXR1cm4gdGhpcy5hcnJheS5zbGljZSgpfX1jbGFzcyBubntjb25zdHJ1Y3Rvcigpe25uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3JkU2V0PW5ldyBFdCx0aGlzLl9saXN0PW5ldyBMfXN0YXRpYyBmaWx0ZXJDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBubjtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllLmZpbHRlcih0W25dKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlcygpfWZpbHRlcih0KXt0aGlzLl9jb29yZFNldC5hZGQodCkmJnRoaXMuX2xpc3QuYWRkKHQpfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fbGlzdC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMuX2xpc3QudG9BcnJheSh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSF19fWNsYXNzIHNue2NvbnN0cnVjdG9yKCl7c24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9pbnB1dFB0cz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHNuLmV4dHJhY3RDb29yZGluYXRlcyh0KSx0LmdldEZhY3RvcnkoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRQdHM9bm4uZmlsdGVyQ29vcmRpbmF0ZXModCksdGhpcy5fZ2VvbUZhY3Rvcnk9ZX19c3RhdGljIGV4dHJhY3RDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBubjtyZXR1cm4gdC5hcHBseShlKSxlLmdldENvb3JkaW5hdGVzKCl9cHJlU29ydCh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKSh0W25dLnk8dFswXS55fHx0W25dLnk9PT10WzBdLnkmJnRbbl0ueDx0WzBdLngpJiYoZT10WzBdLHRbMF09dFtuXSx0W25dPWUpO3JldHVybiBzdC5zb3J0KHQsMSx0Lmxlbmd0aCxuZXcgcm4odFswXSkpLHR9Y29tcHV0ZU9jdFJpbmcodCl7Y29uc3QgZT10aGlzLmNvbXB1dGVPY3RQdHModCksbj1uZXcgUjtyZXR1cm4gbi5hZGQoZSwhMSksbi5zaXplKCk8Mz9udWxsOihuLmNsb3NlUmluZygpLG4udG9Db29yZGluYXRlQXJyYXkoKSl9bGluZU9yUG9seWdvbih0KXtpZigzPT09KHQ9dGhpcy5jbGVhblJpbmcodCkpLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdFswXSx0WzFdXSk7Y29uc3QgZT10aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVQb2x5Z29uKGUpfWNsZWFuUmluZyh0KXtnLmVxdWFscyh0WzBdLHRbdC5sZW5ndGgtMV0pO2NvbnN0IGU9bmV3IEw7bGV0IG49bnVsbDtmb3IobGV0IHM9MDtzPD10Lmxlbmd0aC0yO3MrKyl7Y29uc3QgaT10W3NdLHI9dFtzKzFdO2kuZXF1YWxzKHIpfHwobnVsbCE9PW4mJnRoaXMuaXNCZXR3ZWVuKG4saSxyKXx8KGUuYWRkKGkpLG49aSkpfWUuYWRkKHRbdC5sZW5ndGgtMV0pO2NvbnN0IHM9bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiBlLnRvQXJyYXkocyl9aXNCZXR3ZWVuKHQsZSxuKXtpZigwIT09cS5pbmRleCh0LGUsbikpcmV0dXJuITE7aWYodC54IT09bi54KXtpZih0Lng8PWUueCYmZS54PD1uLngpcmV0dXJuITA7aWYobi54PD1lLngmJmUueDw9dC54KXJldHVybiEwfWlmKHQueSE9PW4ueSl7aWYodC55PD1lLnkmJmUueTw9bi55KXJldHVybiEwO2lmKG4ueTw9ZS55JiZlLnk8PXQueSlyZXR1cm4hMH1yZXR1cm4hMX1yZWR1Y2UodCl7Y29uc3QgZT10aGlzLmNvbXB1dGVPY3RSaW5nKHQpO2lmKG51bGw9PT1lKXJldHVybiB0O2NvbnN0IG49bmV3IGF0O2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKW4uYWRkKGVbdF0pO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKVVlLmlzSW5SaW5nKHRbc10sZSl8fG4uYWRkKHRbc10pO2NvbnN0IHM9X3QudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHMubGVuZ3RoPDM/dGhpcy5wYWRBcnJheTMocyk6c31nZXRDb252ZXhIdWxsKCl7aWYoMD09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYoMT09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy5faW5wdXRQdHNbMF0pO2lmKDI9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5faW5wdXRQdHMpO2xldCB0PXRoaXMuX2lucHV0UHRzO3RoaXMuX2lucHV0UHRzLmxlbmd0aD41MCYmKHQ9dGhpcy5yZWR1Y2UodGhpcy5faW5wdXRQdHMpKTtjb25zdCBlPXRoaXMucHJlU29ydCh0KSxuPXRoaXMuZ3JhaGFtU2NhbihlKSxzPXRoaXMudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHRoaXMubGluZU9yUG9seWdvbihzKX1wYWRBcnJheTModCl7Y29uc3QgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyluPHQubGVuZ3RoP2Vbbl09dFtuXTplW25dPXRbMF07cmV0dXJuIGV9Y29tcHV0ZU9jdFB0cyh0KXtjb25zdCBlPW5ldyBBcnJheSg4KS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dFswXTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl0W25dLng8ZVswXS54JiYoZVswXT10W25dKSx0W25dLngtdFtuXS55PGVbMV0ueC1lWzFdLnkmJihlWzFdPXRbbl0pLHRbbl0ueT5lWzJdLnkmJihlWzJdPXRbbl0pLHRbbl0ueCt0W25dLnk+ZVszXS54K2VbM10ueSYmKGVbM109dFtuXSksdFtuXS54PmVbNF0ueCYmKGVbNF09dFtuXSksdFtuXS54LXRbbl0ueT5lWzVdLngtZVs1XS55JiYoZVs1XT10W25dKSx0W25dLnk8ZVs2XS55JiYoZVs2XT10W25dKSx0W25dLngrdFtuXS55PGVbN10ueCtlWzddLnkmJihlWzddPXRbbl0pO3JldHVybiBlfXRvQ29vcmRpbmF0ZUFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXQuZ2V0KG4pO2Vbbl09c31yZXR1cm4gZX1ncmFoYW1TY2FuKHQpe2xldCBlPW51bGw7Y29uc3Qgbj1uZXcgZW47bi5wdXNoKHRbMF0pLG4ucHVzaCh0WzFdKSxuLnB1c2godFsyXSk7Zm9yKGxldCBzPTM7czx0Lmxlbmd0aDtzKyspe2ZvcihlPW4ucG9wKCk7IW4uZW1wdHkoKSYmcS5pbmRleChuLnBlZWsoKSxlLHRbc10pPjA7KWU9bi5wb3AoKTtuLnB1c2goZSksbi5wdXNoKHRbc10pfXJldHVybiBuLnB1c2godFswXSksbn19Y2xhc3Mgcm57Y29uc3RydWN0b3IoKXtybi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vcmlnaW49bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9vcmlnaW49dH1zdGF0aWMgcG9sYXJDb21wYXJlKHQsZSxuKXtjb25zdCBzPWUueC10LngsaT1lLnktdC55LHI9bi54LXQueCxvPW4ueS10LnksbD1xLmluZGV4KHQsZSxuKTtpZihsPT09cS5DT1VOVEVSQ0xPQ0tXSVNFKXJldHVybiAxO2lmKGw9PT1xLkNMT0NLV0lTRSlyZXR1cm4tMTtjb25zdCBhPXMqcytpKmksYz1yKnIrbypvO3JldHVybiBhPGM/LTE6YT5jPzE6MH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtyZXR1cm4gcm4ucG9sYXJDb21wYXJlKHRoaXMuX29yaWdpbixuLHMpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19c24uUmFkaWFsQ29tcGFyYXRvcj1ybjtjbGFzcyBvbntjb25zdHJ1Y3Rvcigpe29uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbCx0aGlzLl9tYXhXaWR0aD0tMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnByb2Nlc3ModCl9c3RhdGljIGdldEludGVyaW9yUG9pbnQodCl7cmV0dXJuIG5ldyBvbih0KS5nZXRJbnRlcmlvclBvaW50KCl9c3RhdGljIGF2Zyh0LGUpe3JldHVybih0K2UpLzJ9Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fXByb2Nlc3ModCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIHJ0KXRoaXMucHJvY2Vzc1BvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLnByb2Nlc3MoZS5nZXRHZW9tZXRyeU4odCkpfX1wcm9jZXNzUG9seWdvbih0KXtjb25zdCBlPW5ldyBsbih0KTtlLnByb2Nlc3MoKTtjb25zdCBuPWUuZ2V0V2lkdGgoKTtuPnRoaXMuX21heFdpZHRoJiYodGhpcy5fbWF4V2lkdGg9bix0aGlzLl9pbnRlcmlvclBvaW50PWUuZ2V0SW50ZXJpb3JQb2ludCgpKX19Y2xhc3MgbG57Y29uc3RydWN0b3IoKXtsbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wb2x5Z29uPW51bGwsdGhpcy5faW50ZXJpb3JQb2ludFk9bnVsbCx0aGlzLl9pbnRlcmlvclNlY3Rpb25XaWR0aD0wLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wb2x5Z29uPXQsdGhpcy5faW50ZXJpb3JQb2ludFk9Y24uZ2V0U2NhbkxpbmVZKHQpfXN0YXRpYyBpc0VkZ2VDcm9zc2luZ0NvdW50ZWQodCxlLG4pe2NvbnN0IHM9dC5nZXRZKCksaT1lLmdldFkoKTtyZXR1cm4gcyE9PWkmJighKHM9PT1uJiZpPG4pJiYhKGk9PT1uJiZzPG4pKX1zdGF0aWMgaW50ZXJzZWN0c0hvcml6b250YWxMaW5lKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEoZTx0LmdldE1pblkoKSkmJiEoZT50LmdldE1heFkoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiEodC5nZXRZKCk+biYmZS5nZXRZKCk+bikmJiEodC5nZXRZKCk8biYmZS5nZXRZKCk8bil9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4pe2NvbnN0IHM9dC5nZXRYKCksaT1lLmdldFgoKTtpZihzPT09aSlyZXR1cm4gcztjb25zdCByPWktcyxvPShlLmdldFkoKS10LmdldFkoKSkvcjtyZXR1cm4gcysobi10LmdldFkoKSkvb31maW5kQmVzdE1pZHBvaW50KHQpe2lmKDA9PT10LnNpemUoKSlyZXR1cm4gbnVsbDtnLmlzVHJ1ZSgwPT10LnNpemUoKSUyLFwiSW50ZXJpb3IgUG9pbnQgcm9idXN0bmVzcyBmYWlsdXJlOiBvZGQgbnVtYmVyIG9mIHNjYW5saW5lIGNyb3NzaW5nc1wiKSx0LnNvcnQobmV3IGFuKTtmb3IobGV0IGU9MDtlPHQuc2l6ZSgpO2UrPTIpe2NvbnN0IG49dC5nZXQoZSkscz10LmdldChlKzEpLGk9cy1uO2lmKGk+dGhpcy5faW50ZXJpb3JTZWN0aW9uV2lkdGgpe3RoaXMuX2ludGVyaW9yU2VjdGlvbldpZHRoPWk7Y29uc3QgdD1vbi5hdmcobixzKTt0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHQsdGhpcy5faW50ZXJpb3JQb2ludFkpfX19cHJvY2Vzcygpe2lmKHRoaXMuX3BvbHlnb24uaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuX2ludGVyaW9yUG9pbnQ9bmV3IG0odGhpcy5fcG9seWdvbi5nZXRDb29yZGluYXRlKCkpO2NvbnN0IHQ9bmV3IEw7dGhpcy5zY2FuUmluZyh0aGlzLl9wb2x5Z29uLmdldEV4dGVyaW9yUmluZygpLHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9seWdvbi5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspdGhpcy5zY2FuUmluZyh0aGlzLl9wb2x5Z29uLmdldEludGVyaW9yUmluZ04oZSksdCk7dGhpcy5maW5kQmVzdE1pZHBvaW50KHQpfXNjYW5SaW5nKHQsZSl7aWYoIWxuLmludGVyc2VjdHNIb3Jpem9udGFsTGluZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSx0aGlzLl9pbnRlcmlvclBvaW50WSkpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2ZvcihsZXQgdD0xO3Q8bi5zaXplKCk7dCsrKXtjb25zdCBzPW4uZ2V0Q29vcmRpbmF0ZSh0LTEpLGk9bi5nZXRDb29yZGluYXRlKHQpO3RoaXMuYWRkRWRnZUNyb3NzaW5nKHMsaSx0aGlzLl9pbnRlcmlvclBvaW50WSxlKX19Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JTZWN0aW9uV2lkdGh9Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fWFkZEVkZ2VDcm9zc2luZyh0LGUsbixzKXtpZighbG4uaW50ZXJzZWN0c0hvcml6b250YWxMaW5lKHQsZSxuKSlyZXR1cm4gbnVsbDtpZighbG4uaXNFZGdlQ3Jvc3NpbmdDb3VudGVkKHQsZSxuKSlyZXR1cm4gbnVsbDtjb25zdCBpPWxuLmludGVyc2VjdGlvbih0LGUsbik7cy5hZGQoaSl9fWNsYXNzIGFue2NvbXBhcmUodCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1sbi5Eb3VibGVDb21wYXJhdG9yPWFuO2NsYXNzIGNue2NvbnN0cnVjdG9yKCl7Y24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcG9seT1udWxsLHRoaXMuX2NlbnRyZVk9bnVsbCx0aGlzLl9oaVk9ci5NQVhfVkFMVUUsdGhpcy5fbG9ZPS1yLk1BWF9WQUxVRTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wb2x5PXQsdGhpcy5faGlZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1heFkoKSx0aGlzLl9sb1k9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWluWSgpLHRoaXMuX2NlbnRyZVk9b24uYXZnKHRoaXMuX2xvWSx0aGlzLl9oaVkpfXN0YXRpYyBnZXRTY2FuTGluZVkodCl7cmV0dXJuIG5ldyBjbih0KS5nZXRTY2FuTGluZVkoKX11cGRhdGVJbnRlcnZhbCh0KXt0PD10aGlzLl9jZW50cmVZP3Q+dGhpcy5fbG9ZJiYodGhpcy5fbG9ZPXQpOnQ+dGhpcy5fY2VudHJlWSYmdDx0aGlzLl9oaVkmJih0aGlzLl9oaVk9dCl9Z2V0U2NhbkxpbmVZKCl7dGhpcy5wcm9jZXNzKHRoaXMuX3BvbHkuZ2V0RXh0ZXJpb3JSaW5nKCkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTt0KyspdGhpcy5wcm9jZXNzKHRoaXMuX3BvbHkuZ2V0SW50ZXJpb3JSaW5nTih0KSk7cmV0dXJuIG9uLmF2Zyh0aGlzLl9oaVksdGhpcy5fbG9ZKX1wcm9jZXNzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgbj1lLmdldFkodCk7dGhpcy51cGRhdGVJbnRlcnZhbChuKX19fW9uLkludGVyaW9yUG9pbnRQb2x5Z29uPWxuLG9uLlNjYW5MaW5lWU9yZGluYXRlRmluZGVyPWNuO2NsYXNzIGhue2NvbnN0cnVjdG9yKCl7aG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY2VudHJvaWQ9bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5pc0VtcHR5KCk/dGhpcy5fY2VudHJvaWQ9bnVsbDoodGhpcy5fY2VudHJvaWQ9JGUuZ2V0Q2VudHJvaWQodCksdC5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHRoaXMuX2NlbnRyb2lkKSksdGhpcy5hZGRJbnRlcmlvcih0KSxudWxsPT09dGhpcy5faW50ZXJpb3JQb2ludCYmdGhpcy5hZGRFbmRwb2ludHModCl9c3RhdGljIGdldEludGVyaW9yUG9pbnQodCl7cmV0dXJuIG5ldyBobih0KS5nZXRJbnRlcmlvclBvaW50KCl9YWRkRW5kcG9pbnRzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgJCl0aGlzLmFkZEVuZHBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGRFbmRwb2ludHMoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHRbMF0pLHRoaXMuYWRkKHRbdC5sZW5ndGgtMV0pfX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9YWRkSW50ZXJpb3IoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiAkKXRoaXMuYWRkSW50ZXJpb3IodC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBodCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkSW50ZXJpb3IoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGgtMTtlKyspdGhpcy5hZGQodFtlXSl9fWFkZCh0KXtjb25zdCBlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfX1jbGFzcyB1bntjb25zdHJ1Y3Rvcigpe3VuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NlbnRyb2lkPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NlbnRyb2lkPSRlLmdldENlbnRyb2lkKHQpLHRoaXMuYWRkKHQpfXN0YXRpYyBnZXRJbnRlcmlvclBvaW50KHQpe3JldHVybiBuZXcgdW4odCkuZ2V0SW50ZXJpb3JQb2ludCgpfWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBldCl0aGlzLmFkZCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfX19Y2xhc3MgZ257aXNJbkJvdW5kYXJ5KHQpe319Y2xhc3MgZG57aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0JTI9PTF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Y2xhc3MgX257aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0PjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Y2xhc3MgcG57aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0PjF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Y2xhc3MgbW57aXNJbkJvdW5kYXJ5KHQpe3JldHVybiAxPT09dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ25dfX1nbi5Nb2QyQm91bmRhcnlOb2RlUnVsZT1kbixnbi5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9X24sZ24uTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9cG4sZ24uTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1tbixnbi5NT0QyX0JPVU5EQVJZX1JVTEU9bmV3IGRuLGduLkVORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IF9uLGduLk1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IHBuLGduLk1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgbW4sZ24uT0dDX1NGU19CT1VOREFSWV9SVUxFPWduLk1PRDJfQk9VTkRBUllfUlVMRTtjbGFzcyBmbntjb25zdHJ1Y3Rvcigpe2ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2JvdW5kYXJ5UnVsZT1nbi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUsdGhpcy5faXNJbj1udWxsLHRoaXMuX251bUJvdW5kYXJpZXM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpdGhyb3cgbmV3IHMoXCJSdWxlIG11c3QgYmUgbm9uLW51bGxcIik7dGhpcy5fYm91bmRhcnlSdWxlPXR9fWxvY2F0ZUluUG9seWdvblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9VZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOlF0LkVYVEVSSU9SfWludGVyc2VjdHModCxlKXtyZXR1cm4gdGhpcy5sb2NhdGUodCxlKSE9PVF0LkVYVEVSSU9SfXVwZGF0ZUxvY2F0aW9uSW5mbyh0KXt0PT09UXQuSU5URVJJT1ImJih0aGlzLl9pc0luPSEwKSx0PT09UXQuQk9VTkRBUlkmJnRoaXMuX251bUJvdW5kYXJpZXMrK31jb21wdXRlTG9jYXRpb24odCxlKXtpZihlIGluc3RhbmNlb2YgZXQmJnRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25Qb2ludCh0LGUpKSxlIGluc3RhbmNlb2YgJCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBydCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUluUG9seWdvbih0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBTdCl7Y29uc3Qgbj1lO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKGUpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQscykpfX1lbHNlIGlmKGUgaW5zdGFuY2VvZiB5dCl7Y29uc3Qgbj1lO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKGUpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW5Qb2x5Z29uKHQscykpfX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBodCl7Y29uc3Qgbj1uZXcgV2UoZSk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cyE9PWUmJnRoaXMuY29tcHV0ZUxvY2F0aW9uKHQscyl9fX1sb2NhdGVPblBvaW50KHQsZSl7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQpP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SfWxvY2F0ZU9uTGluZVN0cmluZyh0LGUpe2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpKXJldHVybiBRdC5FWFRFUklPUjtjb25zdCBuPWUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7cmV0dXJuIGUuaXNDbG9zZWQoKXx8IXQuZXF1YWxzKG4uZ2V0Q29vcmRpbmF0ZSgwKSkmJiF0LmVxdWFscyhuLmdldENvb3JkaW5hdGUobi5zaXplKCktMSkpP1VlLmlzT25MaW5lKHQsbik/UXQuSU5URVJJT1I6UXQuRVhURVJJT1I6UXQuQk9VTkRBUll9bG9jYXRlSW5Qb2x5Z29uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIFF0LkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRFeHRlcmlvclJpbmcoKSxzPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LG4pO2lmKHM9PT1RdC5FWFRFUklPUilyZXR1cm4gUXQuRVhURVJJT1I7aWYocz09PVF0LkJPVU5EQVJZKXJldHVybiBRdC5CT1VOREFSWTtmb3IobGV0IG49MDtuPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bisrKXtjb25zdCBzPWUuZ2V0SW50ZXJpb3JSaW5nTihuKSxpPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LHMpO2lmKGk9PT1RdC5JTlRFUklPUilyZXR1cm4gUXQuRVhURVJJT1I7aWYoaT09PVF0LkJPVU5EQVJZKXJldHVybiBRdC5CT1VOREFSWX1yZXR1cm4gUXQuSU5URVJJT1J9bG9jYXRlKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP1F0LkVYVEVSSU9SOmUgaW5zdGFuY2VvZiAkP3RoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQsZSk6ZSBpbnN0YW5jZW9mIHJ0P3RoaXMubG9jYXRlSW5Qb2x5Z29uKHQsZSk6KHRoaXMuX2lzSW49ITEsdGhpcy5fbnVtQm91bmRhcmllcz0wLHRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsZSksdGhpcy5fYm91bmRhcnlSdWxlLmlzSW5Cb3VuZGFyeSh0aGlzLl9udW1Cb3VuZGFyaWVzKT9RdC5CT1VOREFSWTp0aGlzLl9udW1Cb3VuZGFyaWVzPjB8fHRoaXMuX2lzSW4/UXQuSU5URVJJT1I6UXQuRVhURVJJT1IpfX1jbGFzcyB5bntjb25zdHJ1Y3Rvcigpe3luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0PW51bGwsdGhpcy5fZXh0cmVtYWxQdHM9bnVsbCx0aGlzLl9jZW50cmU9bnVsbCx0aGlzLl9yYWRpdXM9MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dD10fXN0YXRpYyBmYXJ0aGVzdFBvaW50cyh0KXtjb25zdCBlPXRbMF0uZGlzdGFuY2UodFsxXSksbj10WzFdLmRpc3RhbmNlKHRbMl0pLHM9dFsyXS5kaXN0YW5jZSh0WzBdKTtyZXR1cm4gZT49biYmZT49cz9bdFswXSx0WzFdXTpuPj1lJiZuPj1zP1t0WzFdLHRbMl1dOlt0WzJdLHRbMF1dfXN0YXRpYyBwb2ludFdpdE1pbkFuZ2xlV2l0aFgodCxlKXtsZXQgbj1yLk1BWF9WQUxVRSxzPW51bGw7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IHI9dFtpXTtpZihyPT09ZSljb250aW51ZTtjb25zdCBvPXIueC1lLng7bGV0IGw9ci55LWUueTtsPDAmJihsPS1sKTtjb25zdCBhPWwvTWF0aC5zcXJ0KG8qbytsKmwpO2E8biYmKG49YSxzPXIpfXJldHVybiBzfXN0YXRpYyBsb3dlc3RQb2ludCh0KXtsZXQgZT10WzBdO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueTxlLnkmJihlPXRbbl0pO3JldHVybiBlfXN0YXRpYyBwb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50KHQsZSxuKXtsZXQgcz1yLk1BWF9WQUxVRSxpPW51bGw7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IG89dFtyXTtpZihvPT09ZSljb250aW51ZTtpZihvPT09biljb250aW51ZTtjb25zdCBsPSR0LmFuZ2xlQmV0d2VlbihlLG8sbik7bDxzJiYocz1sLGk9byl9cmV0dXJuIGl9Z2V0UmFkaXVzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX3JhZGl1c31nZXREaWFtZXRlcigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpfWNvbnN0IHQ9dGhpcy5fZXh0cmVtYWxQdHNbMF0sZT10aGlzLl9leHRyZW1hbFB0c1sxXTtyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsZV0pfWdldEV4dHJlbWFsUG9pbnRzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX2V4dHJlbWFsUHRzfWNvbXB1dGVDaXJjbGVQb2ludHMoKXtpZih0aGlzLl9pbnB1dC5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7aWYoMT09PXRoaXMuX2lucHV0LmdldE51bVBvaW50cygpKXtjb25zdCB0PXRoaXMuX2lucHV0LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgbSh0WzBdKV0sbnVsbH1jb25zdCB0PXRoaXMuX2lucHV0LmNvbnZleEh1bGwoKS5nZXRDb29yZGluYXRlcygpO2xldCBlPXQ7aWYodFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKSYmKGU9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCksX3QuY29weURlZXAodCwwLGUsMCx0Lmxlbmd0aC0xKSksZS5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPV90LmNvcHlEZWVwKGUpLG51bGw7bGV0IG49eW4ubG93ZXN0UG9pbnQoZSkscz15bi5wb2ludFdpdE1pbkFuZ2xlV2l0aFgoZSxuKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgdD15bi5wb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50KGUsbixzKTtpZigkdC5pc09idHVzZShuLHQscykpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgbShuKSxuZXcgbShzKV0sbnVsbDtpZigkdC5pc09idHVzZSh0LG4scykpbj10O2Vsc2V7aWYoISR0LmlzT2J0dXNlKHQscyxuKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBtKG4pLG5ldyBtKHMpLG5ldyBtKHQpXSxudWxsO3M9dH19Zy5zaG91bGROZXZlclJlYWNoSGVyZShcIkxvZ2ljIGZhaWx1cmUgaW4gTWluaW11bSBCb3VuZGluZyBDaXJjbGUgYWxnb3JpdGhtIVwiKX1jb21wdXRlKCl7aWYobnVsbCE9PXRoaXMuX2V4dHJlbWFsUHRzKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUNpcmNsZVBvaW50cygpLHRoaXMuY29tcHV0ZUNlbnRyZSgpLG51bGwhPT10aGlzLl9jZW50cmUmJih0aGlzLl9yYWRpdXM9dGhpcy5fY2VudHJlLmRpc3RhbmNlKHRoaXMuX2V4dHJlbWFsUHRzWzBdKSl9Z2V0Q2lyY2xlKCl7aWYodGhpcy5jb21wdXRlKCksbnVsbD09PXRoaXMuX2NlbnRyZSlyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24oKTtjb25zdCB0PXRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpO3JldHVybiAwPT09dGhpcy5fcmFkaXVzP3Q6dC5idWZmZXIodGhpcy5fcmFkaXVzKX1nZXRDZW50cmUoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fY2VudHJlfWdldE1heGltdW1EaWFtZXRlcigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpO2Nhc2UgMjpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMuX2V4dHJlbWFsUHRzWzBdLHRoaXMuX2V4dHJlbWFsUHRzWzFdXSk7ZGVmYXVsdDpjb25zdCB0PXluLmZhcnRoZXN0UG9pbnRzKHRoaXMuX2V4dHJlbWFsUHRzKTtyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodCl9fWNvbXB1dGVDZW50cmUoKXtzd2l0Y2godGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6dGhpcy5fY2VudHJlPW51bGw7YnJlYWs7Y2FzZSAxOnRoaXMuX2NlbnRyZT10aGlzLl9leHRyZW1hbFB0c1swXTticmVhaztjYXNlIDI6dGhpcy5fY2VudHJlPW5ldyBtKCh0aGlzLl9leHRyZW1hbFB0c1swXS54K3RoaXMuX2V4dHJlbWFsUHRzWzFdLngpLzIsKHRoaXMuX2V4dHJlbWFsUHRzWzBdLnkrdGhpcy5fZXh0cmVtYWxQdHNbMV0ueSkvMik7YnJlYWs7Y2FzZSAzOnRoaXMuX2NlbnRyZT1uZS5jaXJjdW1jZW50cmUodGhpcy5fZXh0cmVtYWxQdHNbMF0sdGhpcy5fZXh0cmVtYWxQdHNbMV0sdGhpcy5fZXh0cmVtYWxQdHNbMl0pfX19Y2xhc3MgeG57Y29uc3RydWN0b3IoKXt4bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9pc0NvbnZleD1udWxsLHRoaXMuX2NvbnZleEh1bGxQdHM9bnVsbCx0aGlzLl9taW5CYXNlU2VnPW5ldyBLdCx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluUHRJbmRleD1udWxsLHRoaXMuX21pbldpZHRoPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3huLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwhMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5faXNDb252ZXg9ZX19c3RhdGljIG5leHRJbmRleCh0LGUpe3JldHVybisrZT49dC5sZW5ndGgmJihlPTApLGV9c3RhdGljIGNvbXB1dGVDKHQsZSxuKXtyZXR1cm4gdCpuLnktZSpuLnh9c3RhdGljIGdldE1pbmltdW1EaWFtZXRlcih0KXtyZXR1cm4gbmV3IHhuKHQpLmdldERpYW1ldGVyKCl9c3RhdGljIGdldE1pbmltdW1SZWN0YW5nbGUodCl7cmV0dXJuIG5ldyB4bih0KS5nZXRNaW5pbXVtUmVjdGFuZ2xlKCl9c3RhdGljIGNvbXB1dGVTZWdtZW50Rm9yTGluZSh0LGUsbil7bGV0IHM9bnVsbCxpPW51bGw7cmV0dXJuIE1hdGguYWJzKGUpPk1hdGguYWJzKHQpPyhzPW5ldyBtKDAsbi9lKSxpPW5ldyBtKDEsbi9lLXQvZSkpOihzPW5ldyBtKG4vdCwwKSxpPW5ldyBtKG4vdC1lL3QsMSkpLG5ldyBLdChzLGkpfWdldFdpZHRoQ29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9taW5XaWR0aFB0fWdldFN1cHBvcnRpbmdTZWdtZW50KCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5fbWluQmFzZVNlZy5wMCx0aGlzLl9taW5CYXNlU2VnLnAxXSl9Z2V0RGlhbWV0ZXIoKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSxudWxsPT09dGhpcy5fbWluV2lkdGhQdClyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y29uc3QgdD10aGlzLl9taW5CYXNlU2VnLnByb2plY3QodGhpcy5fbWluV2lkdGhQdCk7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCx0aGlzLl9taW5XaWR0aFB0XSl9Y29tcHV0ZVdpZHRoQ29udmV4KHQpe3RoaXMuX2NvbnZleEh1bGxQdHM9dCBpbnN0YW5jZW9mIHJ0P3QuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKTp0LmdldENvb3JkaW5hdGVzKCksMD09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9bnVsbCx0aGlzLl9taW5CYXNlU2VnPW51bGwpOjE9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDE9dGhpcy5fY29udmV4SHVsbFB0c1swXSk6Mj09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RofHwzPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDA9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAxPXRoaXMuX2NvbnZleEh1bGxQdHNbMV0pOnRoaXMuY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0aGlzLl9jb252ZXhIdWxsUHRzKX1jb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyKHQpe3RoaXMuX21pbldpZHRoPXIuTUFYX1ZBTFVFO2xldCBlPTE7Y29uc3Qgbj1uZXcgS3Q7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aC0xO3MrKyluLnAwPXRbc10sbi5wMT10W3MrMV0sZT10aGlzLmZpbmRNYXhQZXJwRGlzdGFuY2UodCxuLGUpfWNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKXtpZihudWxsIT09dGhpcy5fbWluV2lkdGhQdClyZXR1cm4gbnVsbDtpZih0aGlzLl9pc0NvbnZleCl0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0aGlzLl9pbnB1dEdlb20pO2Vsc2V7Y29uc3QgdD1uZXcgc24odGhpcy5faW5wdXRHZW9tKS5nZXRDb252ZXhIdWxsKCk7dGhpcy5jb21wdXRlV2lkdGhDb252ZXgodCl9fWdldExlbmd0aCgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9taW5XaWR0aH1maW5kTWF4UGVycERpc3RhbmNlKHQsZSxuKXtsZXQgcz1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W25dKSxpPXMscj1uLG89cjtmb3IoO2k+PXM7KXM9aSxyPW8sbz14bi5uZXh0SW5kZXgodCxyKSxpPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbb10pO3JldHVybiBzPHRoaXMuX21pbldpZHRoJiYodGhpcy5fbWluUHRJbmRleD1yLHRoaXMuX21pbldpZHRoPXMsdGhpcy5fbWluV2lkdGhQdD10W3RoaXMuX21pblB0SW5kZXhdLHRoaXMuX21pbkJhc2VTZWc9bmV3IEt0KGUpKSxyfWdldE1pbmltdW1SZWN0YW5nbGUoKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSwwPT09dGhpcy5fbWluV2lkdGgpcmV0dXJuIHRoaXMuX21pbkJhc2VTZWcucDAuZXF1YWxzMkQodGhpcy5fbWluQmFzZVNlZy5wMSk/dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9taW5CYXNlU2VnLnAwKTp0aGlzLl9taW5CYXNlU2VnLnRvR2VvbWV0cnkodGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKSk7Y29uc3QgdD10aGlzLl9taW5CYXNlU2VnLnAxLngtdGhpcy5fbWluQmFzZVNlZy5wMC54LGU9dGhpcy5fbWluQmFzZVNlZy5wMS55LXRoaXMuX21pbkJhc2VTZWcucDAueTtsZXQgbj1yLk1BWF9WQUxVRSxzPS1yLk1BWF9WQUxVRSxpPXIuTUFYX1ZBTFVFLG89LXIuTUFYX1ZBTFVFO2ZvcihsZXQgcj0wO3I8dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg7cisrKXtjb25zdCBsPXhuLmNvbXB1dGVDKHQsZSx0aGlzLl9jb252ZXhIdWxsUHRzW3JdKTtsPnMmJihzPWwpLGw8biYmKG49bCk7Y29uc3QgYT14bi5jb21wdXRlQygtZSx0LHRoaXMuX2NvbnZleEh1bGxQdHNbcl0pO2E+byYmKG89YSksYTxpJiYoaT1hKX1jb25zdCBsPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxvKSxhPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxpKSxjPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LHMpLGg9eG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQsbiksdT1jLmxpbmVJbnRlcnNlY3Rpb24obCksZz1oLmxpbmVJbnRlcnNlY3Rpb24obCksZD1oLmxpbmVJbnRlcnNlY3Rpb24oYSksXz1jLmxpbmVJbnRlcnNlY3Rpb24oYSkscD10aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoW3UsZyxkLF8sdV0pO3JldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24ocCl9fXZhciBFbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkaXN0YW5jZTpNZSxsb2NhdGU6amUsbWF0Y2g6SmUsQW5nbGU6JHQsQXJlYTpudCxDZW50cm9pZDokZSxDb252ZXhIdWxsOnNuLERpc3RhbmNlOnosSW50ZXJpb3JQb2ludEFyZWE6b24sSW50ZXJpb3JQb2ludExpbmU6aG4sSW50ZXJpb3JQb2ludFBvaW50OnVuLExlbmd0aDpXLE9yaWVudGF0aW9uOnEsUG9pbnRMb2NhdGlvbjpVZSxQb2ludExvY2F0b3I6Zm4sUm9idXN0TGluZUludGVyc2VjdG9yOmp0LE1pbmltdW1Cb3VuZGluZ0NpcmNsZTp5bixNaW5pbXVtRGlhbWV0ZXI6eG59KTtjbGFzcyBJbntjb25zdHJ1Y3Rvcigpe0luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIGRlbnNpZnlQb2ludHModCxlLG4pe2NvbnN0IHM9bmV3IEt0LGk9bmV3IFI7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aC0xO3IrKyl7cy5wMD10W3JdLHMucDE9dFtyKzFdLGkuYWRkKHMucDAsITEpO2NvbnN0IG89cy5nZXRMZW5ndGgoKSxsPU1hdGgudHJ1bmMoby9lKSsxO2lmKGw+MSl7Y29uc3QgdD1vL2w7Zm9yKGxldCBlPTE7ZTxsO2UrKyl7Y29uc3Qgcj1lKnQvbyxsPXMucG9pbnRBbG9uZyhyKTtuLm1ha2VQcmVjaXNlKGwpLGkuYWRkKGwsITEpfX19cmV0dXJuIGkuYWRkKHRbdC5sZW5ndGgtMV0sITEpLGkudG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgZGVuc2lmeSh0LGUpe2NvbnN0IG49bmV3IEluKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiBuZXcgTm4odGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8PTApdGhyb3cgbmV3IHMoXCJUb2xlcmFuY2UgbXVzdCBiZSBwb3NpdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fX1jbGFzcyBObiBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxObi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgeXQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPUluLmRlbnNpZnlQb2ludHMobix0aGlzLmRpc3RhbmNlVG9sZXJhbmNlLGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7cmV0dXJuIGUgaW5zdGFuY2VvZiAkJiYxPT09cy5sZW5ndGgmJihzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0LmJ1ZmZlcigwKX19SW4uRGVuc2lmeVRyYW5zZm9ybWVyPU5uO3ZhciB3bj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEZW5zaWZpZXI6SW59KTtjbGFzcyBDbntzdGF0aWMgaXNOb3J0aGVybih0KXtyZXR1cm4gdD09PUNuLk5FfHx0PT09Q24uTld9c3RhdGljIGlzT3Bwb3NpdGUodCxlKXtpZih0PT09ZSlyZXR1cm4hMTtyZXR1cm4gMj09PSh0LWUrNCklNH1zdGF0aWMgY29tbW9uSGFsZlBsYW5lKHQsZSl7aWYodD09PWUpcmV0dXJuIHQ7aWYoMj09PSh0LWUrNCklNClyZXR1cm4tMTtjb25zdCBuPXQ8ZT90OmU7cmV0dXJuIDA9PT1uJiYzPT09KHQ+ZT90OmUpPzM6bn1zdGF0aWMgaXNJbkhhbGZQbGFuZSh0LGUpe3JldHVybiBlPT09Q24uU0U/dD09PUNuLlNFfHx0PT09Q24uU1c6dD09PWV8fHQ9PT1lKzF9c3RhdGljIHF1YWRyYW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBzKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtyZXR1cm4gdD49MD9lPj0wP0NuLk5FOkNuLlNFOmU+PTA/Q24uTlc6Q24uU1d9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGUueD09PXQueCYmZS55PT09dC55KXRocm93IG5ldyBzKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIit0KTtyZXR1cm4gZS54Pj10Lng/ZS55Pj10Lnk/Q24uTkU6Q24uU0U6ZS55Pj10Lnk/Q24uTlc6Q24uU1d9fX1Dbi5ORT0wLENuLk5XPTEsQ24uU1c9MixDbi5TRT0zO2NsYXNzIFNue2NvbnN0cnVjdG9yKCl7U24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3JpZz1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9vcmlnPXR9c3RhdGljIGNyZWF0ZSh0LGUpe2NvbnN0IG49bmV3IFNuKHQpLHM9bmV3IFNuKGUpO3JldHVybiBuLmxpbmsocyksbn1maW5kKHQpe2xldCBlPXRoaXM7ZG97aWYobnVsbD09PWUpcmV0dXJuIG51bGw7aWYoZS5kZXN0KCkuZXF1YWxzMkQodCkpcmV0dXJuIGU7ZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiBudWxsfWRlc3QoKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnfWlzRWRnZXNTb3J0ZWQoKXtjb25zdCB0PXRoaXMuZmluZExvd2VzdCgpO2xldCBlPXQ7ZG97Y29uc3Qgbj1lLm9OZXh0KCk7aWYobj09PXQpYnJlYWs7aWYoIShuLmNvbXBhcmVUbyhlKT4wKSlyZXR1cm4hMTtlPW59d2hpbGUoZSE9PXQpO3JldHVybiEwfW9OZXh0KCl7cmV0dXJuIHRoaXMuX3N5bS5fbmV4dH1kaXJlY3Rpb25ZKCl7cmV0dXJuIHRoaXMuZGlyZWN0aW9uUHQoKS5nZXRZKCktdGhpcy5fb3JpZy5nZXRZKCl9aW5zZXJ0KHQpe2lmKHRoaXMub05leHQoKT09PXRoaXMpcmV0dXJuIHRoaXMuaW5zZXJ0QWZ0ZXIodCksbnVsbDt0aGlzLmluc2VydGlvbkVkZ2UodCkuaW5zZXJ0QWZ0ZXIodCl9aW5zZXJ0QWZ0ZXIodCl7Zy5lcXVhbHModGhpcy5fb3JpZyx0Lm9yaWcoKSk7Y29uc3QgZT10aGlzLm9OZXh0KCk7dGhpcy5fc3ltLnNldE5leHQodCksdC5zeW0oKS5zZXROZXh0KGUpfWRlZ3JlZSgpe2xldCB0PTAsZT10aGlzO2Rve3QrKyxlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIHR9ZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19ZmluZExvd2VzdCgpe2xldCB0PXRoaXMsZT10aGlzLm9OZXh0KCk7ZG97ZS5jb21wYXJlVG8odCk8MCYmKHQ9ZSksZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiB0fWRpcmVjdGlvblB0KCl7cmV0dXJuIHRoaXMuZGVzdCgpfXN5bSgpe3JldHVybiB0aGlzLl9zeW19cHJldigpe3JldHVybiB0aGlzLl9zeW0ubmV4dCgpLl9zeW19Y29tcGFyZUFuZ3VsYXJEaXJlY3Rpb24odCl7Y29uc3QgZT10aGlzLmRpcmVjdGlvblgoKSxuPXRoaXMuZGlyZWN0aW9uWSgpLHM9dC5kaXJlY3Rpb25YKCksaT10LmRpcmVjdGlvblkoKTtpZihlPT09cyYmbj09PWkpcmV0dXJuIDA7Y29uc3Qgcj1Dbi5xdWFkcmFudChlLG4pLG89Q24ucXVhZHJhbnQocyxpKTtpZihyPm8pcmV0dXJuIDE7aWYocjxvKXJldHVybi0xO2NvbnN0IGw9dGhpcy5kaXJlY3Rpb25QdCgpLGE9dC5kaXJlY3Rpb25QdCgpO3JldHVybiBxLmluZGV4KHQuX29yaWcsYSxsKX1wcmV2Tm9kZSgpe2xldCB0PXRoaXM7Zm9yKDsyPT09dC5kZWdyZWUoKTspaWYodD10LnByZXYoKSx0PT09dGhpcylyZXR1cm4gbnVsbDtyZXR1cm4gdH1kaXJlY3Rpb25YKCl7cmV0dXJuIHRoaXMuZGlyZWN0aW9uUHQoKS5nZXRYKCktdGhpcy5fb3JpZy5nZXRYKCl9aW5zZXJ0aW9uRWRnZSh0KXtsZXQgZT10aGlzO2Rve2NvbnN0IG49ZS5vTmV4dCgpO2lmKG4uY29tcGFyZVRvKGUpPjAmJnQuY29tcGFyZVRvKGUpPj0wJiZ0LmNvbXBhcmVUbyhuKTw9MClyZXR1cm4gZTtpZihuLmNvbXBhcmVUbyhlKTw9MCYmKHQuY29tcGFyZVRvKG4pPD0wfHx0LmNvbXBhcmVUbyhlKT49MCkpcmV0dXJuIGU7ZT1ufXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlQW5ndWxhckRpcmVjdGlvbihlKX10b1N0cmluZ05vZGUoKXtjb25zdCB0PXRoaXMub3JpZygpO3RoaXMuZGVzdCgpO2NvbnN0IGU9bmV3IHB0O2UuYXBwZW5kKFwiTm9kZSggXCIrV3QuZm9ybWF0KHQpK1wiIClcXG5cIik7bGV0IG49dGhpcztkb3tlLmFwcGVuZChcIiAgLT4gXCIrbiksZS5hcHBlbmQoXCJcXG5cIiksbj1uLm9OZXh0KCl9d2hpbGUobiE9PXRoaXMpO3JldHVybiBlLnRvU3RyaW5nKCl9bGluayh0KXt0aGlzLnNldFN5bSh0KSx0LnNldFN5bSh0aGlzKSx0aGlzLnNldE5leHQodCksdC5zZXROZXh0KHRoaXMpfW5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1zZXRTeW0odCl7dGhpcy5fc3ltPXR9b3JpZygpe3JldHVybiB0aGlzLl9vcmlnfXRvU3RyaW5nKCl7cmV0dXJuXCJIRShcIit0aGlzLl9vcmlnLngrXCIgXCIrdGhpcy5fb3JpZy55K1wiLCBcIit0aGlzLl9zeW0uX29yaWcueCtcIiBcIit0aGlzLl9zeW0uX29yaWcueStcIilcIn10b1N0cmluZ05vZGVFZGdlKCl7cmV0dXJuXCIgIC0+IChcIitXdC5mb3JtYXQodGhpcy5kZXN0KCkpfXNldE5leHQodCl7dGhpcy5fbmV4dD10fX1jbGFzcyBMbiBleHRlbmRzIFNue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxMbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc01hcmtlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTtTbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfXN0YXRpYyBzZXRNYXJrQm90aCh0LGUpe3Quc2V0TWFyayhlKSx0LnN5bSgpLnNldE1hcmsoZSl9c3RhdGljIGlzTWFya2VkKHQpe3JldHVybiB0LmlzTWFya2VkKCl9c3RhdGljIHNldE1hcmsodCxlKXt0LnNldE1hcmsoZSl9c3RhdGljIG1hcmtCb3RoKHQpe3QubWFyaygpLHQuc3ltKCkubWFyaygpfXN0YXRpYyBtYXJrKHQpe3QubWFyaygpfW1hcmsoKXt0aGlzLl9pc01hcmtlZD0hMH1zZXRNYXJrKHQpe3RoaXMuX2lzTWFya2VkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9fWNsYXNzIFRue2NvbnN0cnVjdG9yKCl7VG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdmVydGV4TWFwPW5ldyBOdH1zdGF0aWMgaXNWYWxpZEVkZ2UodCxlKXtyZXR1cm4gMCE9PWUuY29tcGFyZVRvKHQpfWluc2VydCh0LGUsbil7Y29uc3Qgcz10aGlzLmNyZWF0ZSh0LGUpO251bGwhPT1uP24uaW5zZXJ0KHMpOnRoaXMuX3ZlcnRleE1hcC5wdXQodCxzKTtjb25zdCBpPXRoaXMuX3ZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1pP2kuaW5zZXJ0KHMuc3ltKCkpOnRoaXMuX3ZlcnRleE1hcC5wdXQoZSxzLnN5bSgpKSxzfWNyZWF0ZSh0LGUpe2NvbnN0IG49dGhpcy5jcmVhdGVFZGdlKHQpLHM9dGhpcy5jcmVhdGVFZGdlKGUpO3JldHVybiBuLmxpbmsocyksbn1jcmVhdGVFZGdlKHQpe3JldHVybiBuZXcgU24odCl9YWRkRWRnZSh0LGUpe2lmKCFUbi5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5fdmVydGV4TWFwLmdldCh0KTtsZXQgcz1udWxsO2lmKG51bGwhPT1uJiYocz1uLmZpbmQoZSkpLG51bGwhPT1zKXJldHVybiBzO3JldHVybiB0aGlzLmluc2VydCh0LGUsbil9Z2V0VmVydGV4RWRnZXMoKXtyZXR1cm4gdGhpcy5fdmVydGV4TWFwLnZhbHVlcygpfWZpbmRFZGdlKHQsZSl7Y29uc3Qgbj10aGlzLl92ZXJ0ZXhNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09bj9udWxsOm4uZmluZChlKX19Y2xhc3MgUm4gZXh0ZW5kcyBMbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNTdGFydD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTtMbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfXNldFN0YXJ0KCl7dGhpcy5faXNTdGFydD0hMH1pc1N0YXJ0KCl7cmV0dXJuIHRoaXMuX2lzU3RhcnR9fWNsYXNzIFBuIGV4dGVuZHMgVG57Y29uc3RydWN0b3IoKXtzdXBlcigpfWNyZWF0ZUVkZ2UodCl7cmV0dXJuIG5ldyBSbih0KX19Y2xhc3MgT257Y29uc3RydWN0b3IoKXtPbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZXN1bHQ9bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9saW5lcz1uZXcgTCx0aGlzLl9ub2RlRWRnZVN0YWNrPW5ldyBlbix0aGlzLl9yaW5nU3RhcnRFZGdlPW51bGwsdGhpcy5fZ3JhcGg9bmV3IFBufXN0YXRpYyBkaXNzb2x2ZSh0KXtjb25zdCBlPW5ldyBPbjtyZXR1cm4gZS5hZGQodCksZS5nZXRSZXN1bHQoKX1hZGRMaW5lKHQpe3RoaXMuX2xpbmVzLmFkZCh0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC50b0Nvb3JkaW5hdGVBcnJheSgpKSl9dXBkYXRlUmluZ1N0YXJ0RWRnZSh0KXtyZXR1cm4gdC5pc1N0YXJ0KCl8fCh0PXQuc3ltKCkpLmlzU3RhcnQoKT9udWxsPT09dGhpcy5fcmluZ1N0YXJ0RWRnZT8odGhpcy5fcmluZ1N0YXJ0RWRnZT10LG51bGwpOnZvaWQodC5vcmlnKCkuY29tcGFyZVRvKHRoaXMuX3JpbmdTdGFydEVkZ2Uub3JpZygpKTwwJiYodGhpcy5fcmluZ1N0YXJ0RWRnZT10KSk6bnVsbH1nZXRSZXN1bHQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jlc3VsdCYmdGhpcy5jb21wdXRlUmVzdWx0KCksdGhpcy5fcmVzdWx0fXByb2Nlc3ModCl7bGV0IGU9dC5wcmV2Tm9kZSgpO251bGw9PT1lJiYoZT10KSx0aGlzLnN0YWNrRWRnZXMoZSksdGhpcy5idWlsZExpbmVzKCl9YnVpbGRSaW5nKHQpe2NvbnN0IGU9bmV3IFI7bGV0IG49dDtmb3IoZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocz09PXQpYnJlYWs7ZS5hZGQocy5vcmlnKCkuY29weSgpLCExKSxuPXN9ZS5hZGQobi5kZXN0KCkuY29weSgpLCExKSx0aGlzLmFkZExpbmUoZSl9YnVpbGRMaW5lKHQpe2NvbnN0IGU9bmV3IFI7bGV0IG49dDtmb3IodGhpcy5fcmluZ1N0YXJ0RWRnZT1udWxsLExuLm1hcmtCb3RoKG4pLGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt0aGlzLnVwZGF0ZVJpbmdTdGFydEVkZ2Uobik7Y29uc3Qgcz1uLm5leHQoKTtpZihzPT09dClyZXR1cm4gdGhpcy5idWlsZFJpbmcodGhpcy5fcmluZ1N0YXJ0RWRnZSksbnVsbDtlLmFkZChzLm9yaWcoKS5jb3B5KCksITEpLG49cyxMbi5tYXJrQm90aChuKX1lLmFkZChuLmRlc3QoKS5jbG9uZSgpLCExKSx0aGlzLnN0YWNrRWRnZXMobi5zeW0oKSksdGhpcy5hZGRMaW5lKGUpfXN0YWNrRWRnZXModCl7bGV0IGU9dDtkb3tMbi5pc01hcmtlZChlKXx8dGhpcy5fbm9kZUVkZ2VTdGFjay5hZGQoZSksZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXQpfWNvbXB1dGVSZXN1bHQoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0VmVydGV4RWRnZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtMbi5pc01hcmtlZChlKXx8dGhpcy5wcm9jZXNzKGUpfXRoaXMuX3Jlc3VsdD10aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpfWJ1aWxkTGluZXMoKXtmb3IoOyF0aGlzLl9ub2RlRWRnZVN0YWNrLmVtcHR5KCk7KXtjb25zdCB0PXRoaXMuX25vZGVFZGdlU3RhY2sucG9wKCk7TG4uaXNNYXJrZWQodCl8fHRoaXMuYnVpbGRMaW5lKHQpfX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2FyZ3VtZW50c1swXS5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgJCYmdGhpcy5hZGQodCl9fSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2xldCBuPSExO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPXRoaXMuX2dyYXBoLmFkZEVkZ2UoZS5nZXRDb29yZGluYXRlKHQtMSksZS5nZXRDb29yZGluYXRlKHQpKTtudWxsIT09cyYmKG58fChzLnNldFN0YXJ0KCksbj0hMCkpfX19fXZhciB2bj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMaW5lRGlzc29sdmVyOk9ufSk7Y2xhc3MgYm57c3RhdGljIG9wcG9zaXRlKHQpe3JldHVybiB0PT09Ym4uTEVGVD9ibi5SSUdIVDp0PT09Ym4uUklHSFQ/Ym4uTEVGVDp0fX1ibi5PTj0wLGJuLkxFRlQ9MSxibi5SSUdIVD0yO2xldCBNbj1jbGFzc3tjb25zdHJ1Y3Rvcigpe01uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMubWNlPW51bGwsdGhpcy5jaGFpbkluZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY2U9dCx0aGlzLmNoYWluSW5kZXg9ZX1jb21wdXRlSW50ZXJzZWN0aW9ucyh0LGUpe3RoaXMubWNlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5jaGFpbkluZGV4LHQubWNlLHQuY2hhaW5JbmRleCxlKX19O2NsYXNzIERue2NvbnN0cnVjdG9yKCl7RG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGFiZWw9bnVsbCx0aGlzLl94VmFsdWU9bnVsbCx0aGlzLl9ldmVudFR5cGU9bnVsbCx0aGlzLl9pbnNlcnRFdmVudD1udWxsLHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXg9bnVsbCx0aGlzLl9vYmo9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZXZlbnRUeXBlPURuLkRFTEVURSx0aGlzLl94VmFsdWU9dCx0aGlzLl9pbnNlcnRFdmVudD1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2V2ZW50VHlwZT1Ebi5JTlNFUlQsdGhpcy5fbGFiZWw9dCx0aGlzLl94VmFsdWU9ZSx0aGlzLl9vYmo9bn19aXNEZWxldGUoKXtyZXR1cm4gdGhpcy5fZXZlbnRUeXBlPT09RG4uREVMRVRFfXNldERlbGV0ZUV2ZW50SW5kZXgodCl7dGhpcy5fZGVsZXRlRXZlbnRJbmRleD10fWdldE9iamVjdCgpe3JldHVybiB0aGlzLl9vYmp9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5feFZhbHVlPGUuX3hWYWx1ZT8tMTp0aGlzLl94VmFsdWU+ZS5feFZhbHVlPzE6dGhpcy5fZXZlbnRUeXBlPGUuX2V2ZW50VHlwZT8tMTp0aGlzLl9ldmVudFR5cGU+ZS5fZXZlbnRUeXBlPzE6MH1nZXRJbnNlcnRFdmVudCgpe3JldHVybiB0aGlzLl9pbnNlcnRFdmVudH1pc0luc2VydCgpe3JldHVybiB0aGlzLl9ldmVudFR5cGU9PT1Ebi5JTlNFUlR9aXNTYW1lTGFiZWwodCl7cmV0dXJuIG51bGwhPT10aGlzLl9sYWJlbCYmdGhpcy5fbGFiZWw9PT10Ll9sYWJlbH1nZXREZWxldGVFdmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXh9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1Ebi5JTlNFUlQ9MSxEbi5ERUxFVEU9MjtjbGFzcyBBbnt9bGV0IEZuPWNsYXNze2NvbnN0cnVjdG9yKCl7Rm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX2hhc1Byb3Blcj0hMSx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5faW5jbHVkZVByb3Blcj1udWxsLHRoaXMuX3JlY29yZElzb2xhdGVkPW51bGwsdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5fbnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtVGVzdHM9MCx0aGlzLl9iZHlOb2Rlcz1udWxsLHRoaXMuX2lzRG9uZT0hMSx0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2xpPXQsdGhpcy5faW5jbHVkZVByb3Blcj1lLHRoaXMuX3JlY29yZElzb2xhdGVkPW59c3RhdGljIGlzQWRqYWNlbnRTZWdtZW50cyh0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX1pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl7aWYodD09PW4mJjE9PT10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoRm4uaXNBZGphY2VudFNlZ21lbnRzKGUscykpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXtjb25zdCBuPXQuZ2V0TnVtUG9pbnRzKCktMTtpZigwPT09ZSYmcz09PW58fDA9PT1zJiZlPT09bilyZXR1cm4hMH19cmV0dXJuITF9Z2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKXtyZXR1cm4gdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9c2V0SXNEb25lSWZQcm9wZXJJbnQodCl7dGhpcy5faXNEb25lV2hlblByb3BlckludD10fWhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yfWlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpO2lmKHQuaXNJbnRlcnNlY3Rpb24oZSkpcmV0dXJuITB9cmV0dXJuITF9aGFzUHJvcGVySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3Blcn1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiB0aGlzLl9pc0RvbmV9aXNCb3VuZGFyeVBvaW50KHQsZSl7cmV0dXJuIG51bGwhPT1lJiYoISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVswXSl8fCEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMV0pKX1zZXRCb3VuZGFyeU5vZGVzKHQsZSl7dGhpcy5fYmR5Tm9kZXM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fYmR5Tm9kZXNbMF09dCx0aGlzLl9iZHlOb2Rlc1sxXT1lfWFkZEludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKztjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX3JlY29yZElzb2xhdGVkJiYodC5zZXRJc29sYXRlZCghMSksbi5zZXRJc29sYXRlZCghMSkpLHRoaXMuX251bUludGVyc2VjdGlvbnMrKyx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCwhdGhpcy5faW5jbHVkZVByb3BlciYmdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpKSx0aGlzLl9saS5pc1Byb3BlcigpJiYodGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApLmNvcHkoKSx0aGlzLl9oYXNQcm9wZXI9ITAsdGhpcy5faXNEb25lV2hlblByb3BlckludCYmKHRoaXMuX2lzRG9uZT0hMCksdGhpcy5pc0JvdW5kYXJ5UG9pbnQodGhpcy5fbGksdGhpcy5fYmR5Tm9kZXMpfHwodGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITApKSkpfX07Y2xhc3MgR24gZXh0ZW5kcyBBbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksR24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5ldmVudHM9bmV3IEwsdGhpcy5uT3ZlcmxhcHM9bnVsbH1wcmVwYXJlRXZlbnRzKCl7eGUuc29ydCh0aGlzLmV2ZW50cyk7Zm9yKGxldCB0PTA7dDx0aGlzLmV2ZW50cy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuZXZlbnRzLmdldCh0KTtlLmlzRGVsZXRlKCkmJmUuZ2V0SW5zZXJ0RXZlbnQoKS5zZXREZWxldGVFdmVudEluZGV4KHQpfX1jb21wdXRlSW50ZXJzZWN0aW9ucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm5PdmVybGFwcz0wLHRoaXMucHJlcGFyZUV2ZW50cygpO2ZvcihsZXQgZT0wO2U8dGhpcy5ldmVudHMuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10aGlzLmV2ZW50cy5nZXQoZSk7aWYobi5pc0luc2VydCgpJiZ0aGlzLnByb2Nlc3NPdmVybGFwcyhlLG4uZ2V0RGVsZXRlRXZlbnRJbmRleCgpLG4sdCksdC5pc0RvbmUoKSlicmVha319ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEZuJiZJKGFyZ3VtZW50c1swXSxDKSYmSShhcmd1bWVudHNbMV0sQykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuYWRkRWRnZXModCx0KSx0aGlzLmFkZEVkZ2VzKGUsZSksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhuKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZJKGFyZ3VtZW50c1swXSxDKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBGbil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdP3RoaXMuYWRkRWRnZXModCxudWxsKTp0aGlzLmFkZEVkZ2VzKHQpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoZSl9fWFkZEVkZ2UodCxlKXtjb25zdCBuPXQuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UoKSxzPW4uZ2V0U3RhcnRJbmRleGVzKCk7Zm9yKGxldCB0PTA7dDxzLmxlbmd0aC0xO3QrKyl7Y29uc3Qgcz1uZXcgTW4obix0KSxpPW5ldyBEbihlLG4uZ2V0TWluWCh0KSxzKTt0aGlzLmV2ZW50cy5hZGQoaSksdGhpcy5ldmVudHMuYWRkKG5ldyBEbihuLmdldE1heFgodCksaSkpfX1wcm9jZXNzT3ZlcmxhcHModCxlLG4scyl7Y29uc3QgaT1uLmdldE9iamVjdCgpO2ZvcihsZXQgcj10O3I8ZTtyKyspe2NvbnN0IHQ9dGhpcy5ldmVudHMuZ2V0KHIpO2lmKHQuaXNJbnNlcnQoKSl7Y29uc3QgZT10LmdldE9iamVjdCgpO24uaXNTYW1lTGFiZWwodCl8fChpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKGUscyksdGhpcy5uT3ZlcmxhcHMrKyl9fX1hZGRFZGdlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkRWRnZShlLGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtmb3IobGV0IGU9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuYWRkRWRnZShuLHQpfX19fWNsYXNzIHFue2NvbnN0cnVjdG9yKCl7cW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5sb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5sZW5ndGgpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQoMSksdGhpcy5sb2NhdGlvbltibi5PTl09dH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcW4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaW5pdCh0LmxvY2F0aW9uLmxlbmd0aCksbnVsbCE9PXQpZm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10LmxvY2F0aW9uW2VdfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmluaXQoMyksdGhpcy5sb2NhdGlvbltibi5PTl09dCx0aGlzLmxvY2F0aW9uW2JuLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltibi5SSUdIVF09bn19c2V0QWxsTG9jYXRpb25zKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09dH1pc051bGwoKXtmb3IobGV0IHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdIT09UXQuTk9ORSlyZXR1cm4hMTtyZXR1cm4hMH1zZXRBbGxMb2NhdGlvbnNJZk51bGwodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PVF0Lk5PTkUmJih0aGlzLmxvY2F0aW9uW2VdPXQpfWlzTGluZSgpe3JldHVybiAxPT09dGhpcy5sb2NhdGlvbi5sZW5ndGh9bWVyZ2UodCl7aWYodC5sb2NhdGlvbi5sZW5ndGg+dGhpcy5sb2NhdGlvbi5sZW5ndGgpe2NvbnN0IHQ9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7dFtibi5PTl09dGhpcy5sb2NhdGlvbltibi5PTl0sdFtibi5MRUZUXT1RdC5OT05FLHRbYm4uUklHSFRdPVF0Lk5PTkUsdGhpcy5sb2NhdGlvbj10fWZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09PT1RdC5OT05FJiZlPHQubG9jYXRpb24ubGVuZ3RoJiYodGhpcy5sb2NhdGlvbltlXT10LmxvY2F0aW9uW2VdKX1nZXRMb2NhdGlvbnMoKXtyZXR1cm4gdGhpcy5sb2NhdGlvbn1mbGlwKCl7aWYodGhpcy5sb2NhdGlvbi5sZW5ndGg8PTEpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLmxvY2F0aW9uW2JuLkxFRlRdO3RoaXMubG9jYXRpb25bYm4uTEVGVF09dGhpcy5sb2NhdGlvbltibi5SSUdIVF0sdGhpcy5sb2NhdGlvbltibi5SSUdIVF09dH10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHY7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKFF0LnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltibi5MRUZUXSkpLHQuYXBwZW5kKFF0LnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltibi5PTl0pKSx0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChRdC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bYm4uUklHSFRdKSksdC50b1N0cmluZygpfXNldExvY2F0aW9ucyh0LGUsbil7dGhpcy5sb2NhdGlvbltibi5PTl09dCx0aGlzLmxvY2F0aW9uW2JuLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltibi5SSUdIVF09bn1nZXQodCl7cmV0dXJuIHQ8dGhpcy5sb2NhdGlvbi5sZW5ndGg/dGhpcy5sb2NhdGlvblt0XTpRdC5OT05FfWlzQXJlYSgpe3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xfWlzQW55TnVsbCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF09PT1RdC5OT05FKXJldHVybiEwO3JldHVybiExfXNldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TG9jYXRpb24oYm4uT04sdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5sb2NhdGlvblt0XT1lfX1pbml0KHQpe3RoaXMubG9jYXRpb249bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5zZXRBbGxMb2NhdGlvbnMoUXQuTk9ORSl9aXNFcXVhbE9uU2lkZSh0LGUpe3JldHVybiB0aGlzLmxvY2F0aW9uW2VdPT09dC5sb2NhdGlvbltlXX1hbGxQb3NpdGlvbnNFcXVhbCh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKylpZih0aGlzLmxvY2F0aW9uW2VdIT09dClyZXR1cm4hMTtyZXR1cm4hMH19Y2xhc3MgQm57Y29uc3RydWN0b3IoKXtCbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLmVsdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgcW4odCksdGhpcy5lbHRbMV09bmV3IHFuKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCbil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IHFuKHQuZWx0WzBdKSx0aGlzLmVsdFsxXT1uZXcgcW4odC5lbHRbMV0pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFswXT1uZXcgcW4oUXQuTk9ORSksdGhpcy5lbHRbMV09bmV3IHFuKFF0Lk5PTkUpLHRoaXMuZWx0W3RdLnNldExvY2F0aW9uKGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuZWx0WzBdPW5ldyBxbih0LGUsbiksdGhpcy5lbHRbMV09bmV3IHFuKHQsZSxuKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmVsdFswXT1uZXcgcW4oUXQuTk9ORSxRdC5OT05FLFF0Lk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBxbihRdC5OT05FLFF0Lk5PTkUsUXQuTk9ORSksdGhpcy5lbHRbdF0uc2V0TG9jYXRpb25zKGUsbixzKX19c3RhdGljIHRvTGluZUxhYmVsKHQpe2NvbnN0IGU9bmV3IEJuKFF0Lk5PTkUpO2ZvcihsZXQgbj0wO248MjtuKyspZS5zZXRMb2NhdGlvbihuLHQuZ2V0TG9jYXRpb24obikpO3JldHVybiBlfWdldEdlb21ldHJ5Q291bnQoKXtsZXQgdD0wO3JldHVybiB0aGlzLmVsdFswXS5pc051bGwoKXx8dCsrLHRoaXMuZWx0WzFdLmlzTnVsbCgpfHx0KyssdH1zZXRBbGxMb2NhdGlvbnModCxlKXt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnMoZSl9aXNOdWxsKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc051bGwoKX1zZXRBbGxMb2NhdGlvbnNJZk51bGwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0KSx0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldEFsbExvY2F0aW9uc0lmTnVsbChlKX19aXNMaW5lKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0xpbmUoKX1tZXJnZSh0KXtmb3IobGV0IGU9MDtlPDI7ZSsrKW51bGw9PT10aGlzLmVsdFtlXSYmbnVsbCE9PXQuZWx0W2VdP3RoaXMuZWx0W2VdPW5ldyBxbih0LmVsdFtlXSk6dGhpcy5lbHRbZV0ubWVyZ2UodC5lbHRbZV0pfWZsaXAoKXt0aGlzLmVsdFswXS5mbGlwKCksdGhpcy5lbHRbMV0uZmxpcCgpfWdldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoYm4uT04pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KGUpfX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHY7cmV0dXJuIG51bGwhPT10aGlzLmVsdFswXSYmKHQuYXBwZW5kKFwiQTpcIiksdC5hcHBlbmQodGhpcy5lbHRbMF0udG9TdHJpbmcoKSkpLG51bGwhPT10aGlzLmVsdFsxXSYmKHQuYXBwZW5kKFwiIEI6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzFdLnRvU3RyaW5nKCkpKSx0LnRvU3RyaW5nKCl9aXNBcmVhKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuZWx0WzBdLmlzQXJlYSgpfHx0aGlzLmVsdFsxXS5pc0FyZWEoKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmlzQXJlYSgpfX1pc0FueU51bGwodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzQW55TnVsbCgpfXNldExvY2F0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKGJuLk9OLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKGUsbil9fWlzRXF1YWxPblNpZGUodCxlKXtyZXR1cm4gdGhpcy5lbHRbMF0uaXNFcXVhbE9uU2lkZSh0LmVsdFswXSxlKSYmdGhpcy5lbHRbMV0uaXNFcXVhbE9uU2lkZSh0LmVsdFsxXSxlKX1hbGxQb3NpdGlvbnNFcXVhbCh0LGUpe3JldHVybiB0aGlzLmVsdFt0XS5hbGxQb3NpdGlvbnNFcXVhbChlKX10b0xpbmUodCl7dGhpcy5lbHRbdF0uaXNBcmVhKCkmJih0aGlzLmVsdFt0XT1uZXcgcW4odGhpcy5lbHRbdF0ubG9jYXRpb25bMF0pKX19Y2xhc3MgWW57Y29uc3RydWN0b3IoKXtZbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLmRpc3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmNvb3JkPW5ldyBtKHQpLHRoaXMuc2VnbWVudEluZGV4PWUsdGhpcy5kaXN0PW59Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb29yZH1wcmludCh0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCksdC5wcmludGxuKFwiIGRpc3QgPSBcIit0aGlzLmRpc3QpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZShlLnNlZ21lbnRJbmRleCxlLmRpc3QpfWlzRW5kUG9pbnQodCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmMD09PXRoaXMuZGlzdHx8dGhpcy5zZWdtZW50SW5kZXg9PT10fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY29vcmQrXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCtcIiBkaXN0ID0gXCIrdGhpcy5kaXN0fWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuZGlzdH1jb21wYXJlKHQsZSl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PHQ/LTE6dGhpcy5zZWdtZW50SW5kZXg+dD8xOnRoaXMuZGlzdDxlPy0xOnRoaXMuZGlzdD5lPzE6MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIFZuIGV4dGVuZHMgeHR7fWZ1bmN0aW9uIHpuKHQpe3JldHVybiBudWxsPT10PzA6dC5jb2xvcn1mdW5jdGlvbiBYbih0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucGFyZW50fWZ1bmN0aW9uIGtuKHQsZSl7bnVsbCE9PXQmJih0LmNvbG9yPWUpfWZ1bmN0aW9uIFVuKHQpe3JldHVybiBudWxsPT10P251bGw6dC5sZWZ0fWZ1bmN0aW9uIEhuKHQpe3JldHVybiBudWxsPT10P251bGw6dC5yaWdodH1jbGFzcyBXbiBleHRlbmRzIFZue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnJvb3RfPW51bGwsdGhpcy5zaXplXz0wfWdldCh0KXtsZXQgZT10aGlzLnJvb3RfO2Zvcig7bnVsbCE9PWU7KXtjb25zdCBuPXQuY29tcGFyZVRvKGUua2V5KTtpZihuPDApZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuIGUudmFsdWU7ZT1lLnJpZ2h0fX1yZXR1cm4gbnVsbH1wdXQodCxlKXtpZihudWxsPT09dGhpcy5yb290XylyZXR1cm4gdGhpcy5yb290Xz17a2V5OnQsdmFsdWU6ZSxsZWZ0Om51bGwscmlnaHQ6bnVsbCxwYXJlbnQ6bnVsbCxjb2xvcjowLGdldFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleSgpe3JldHVybiB0aGlzLmtleX19LHRoaXMuc2l6ZV89MSxudWxsO2xldCBuLHMsaT10aGlzLnJvb3RfO2Rve2lmKG49aSxzPXQuY29tcGFyZVRvKGkua2V5KSxzPDApaT1pLmxlZnQ7ZWxzZXtpZighKHM+MCkpe2NvbnN0IHQ9aS52YWx1ZTtyZXR1cm4gaS52YWx1ZT1lLHR9aT1pLnJpZ2h0fX13aGlsZShudWxsIT09aSk7Y29uc3Qgcj17a2V5OnQsbGVmdDpudWxsLHJpZ2h0Om51bGwsdmFsdWU6ZSxwYXJlbnQ6bixjb2xvcjowLGdldFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleSgpe3JldHVybiB0aGlzLmtleX19O3JldHVybiBzPDA/bi5sZWZ0PXI6bi5yaWdodD1yLHRoaXMuZml4QWZ0ZXJJbnNlcnRpb24ociksdGhpcy5zaXplXysrLG51bGx9Zml4QWZ0ZXJJbnNlcnRpb24odCl7bGV0IGU7Zm9yKHQuY29sb3I9MTtudWxsIT10JiZ0IT09dGhpcy5yb290XyYmMT09PXQucGFyZW50LmNvbG9yOylYbih0KT09PVVuKFhuKFhuKHQpKSk/KGU9SG4oWG4oWG4odCkpKSwxPT09em4oZSk/KGtuKFhuKHQpLDApLGtuKGUsMCksa24oWG4oWG4odCkpLDEpLHQ9WG4oWG4odCkpKToodD09PUhuKFhuKHQpKSYmKHQ9WG4odCksdGhpcy5yb3RhdGVMZWZ0KHQpKSxrbihYbih0KSwwKSxrbihYbihYbih0KSksMSksdGhpcy5yb3RhdGVSaWdodChYbihYbih0KSkpKSk6KGU9VW4oWG4oWG4odCkpKSwxPT09em4oZSk/KGtuKFhuKHQpLDApLGtuKGUsMCksa24oWG4oWG4odCkpLDEpLHQ9WG4oWG4odCkpKToodD09PVVuKFhuKHQpKSYmKHQ9WG4odCksdGhpcy5yb3RhdGVSaWdodCh0KSksa24oWG4odCksMCksa24oWG4oWG4odCkpLDEpLHRoaXMucm90YXRlTGVmdChYbihYbih0KSkpKSk7dGhpcy5yb290Xy5jb2xvcj0wfXZhbHVlcygpe2NvbnN0IHQ9bmV3IEw7bGV0IGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUudmFsdWUpO251bGwhPT0oZT1Xbi5zdWNjZXNzb3IoZSkpOyl0LmFkZChlLnZhbHVlKTtyZXR1cm4gdH1lbnRyeVNldCgpe2NvbnN0IHQ9bmV3IEV0O2xldCBlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlKTtudWxsIT09KGU9V24uc3VjY2Vzc29yKGUpKTspdC5hZGQoZSk7cmV0dXJuIHR9cm90YXRlTGVmdCh0KXtpZihudWxsIT10KXtjb25zdCBlPXQucmlnaHQ7dC5yaWdodD1lLmxlZnQsbnVsbCE9ZS5sZWZ0JiYoZS5sZWZ0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQubGVmdD09PXQ/dC5wYXJlbnQubGVmdD1lOnQucGFyZW50LnJpZ2h0PWUsZS5sZWZ0PXQsdC5wYXJlbnQ9ZX19cm90YXRlUmlnaHQodCl7aWYobnVsbCE9dCl7Y29uc3QgZT10LmxlZnQ7dC5sZWZ0PWUucmlnaHQsbnVsbCE9ZS5yaWdodCYmKGUucmlnaHQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5yaWdodD09PXQ/dC5wYXJlbnQucmlnaHQ9ZTp0LnBhcmVudC5sZWZ0PWUsZS5yaWdodD10LHQucGFyZW50PWV9fWdldEZpcnN0RW50cnkoKXtsZXQgdD10aGlzLnJvb3RfO2lmKG51bGwhPXQpZm9yKDtudWxsIT10LmxlZnQ7KXQ9dC5sZWZ0O3JldHVybiB0fXN0YXRpYyBzdWNjZXNzb3IodCl7bGV0IGU7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7aWYobnVsbCE9PXQucmlnaHQpe2ZvcihlPXQucmlnaHQ7bnVsbCE9PWUubGVmdDspZT1lLmxlZnQ7cmV0dXJuIGV9e2U9dC5wYXJlbnQ7bGV0IG49dDtmb3IoO251bGwhPT1lJiZuPT09ZS5yaWdodDspbj1lLGU9ZS5wYXJlbnQ7cmV0dXJuIGV9fXNpemUoKXtyZXR1cm4gdGhpcy5zaXplX31jb250YWluc0tleSh0KXtsZXQgZT10aGlzLnJvb3RfO2Zvcig7bnVsbCE9PWU7KXtjb25zdCBuPXQuY29tcGFyZVRvKGUua2V5KTtpZihuPDApZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuITA7ZT1lLnJpZ2h0fX1yZXR1cm4hMX19Y2xhc3MgWm57Y29uc3RydWN0b3IoKXtabi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2RlTWFwPW5ldyBXbix0aGlzLmVkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1hZGRTcGxpdEVkZ2VzKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLHMpO3QuYWRkKGkpLG49c319YWRkRW5kcG9pbnRzKCl7Y29uc3QgdD10aGlzLmVkZ2UucHRzLmxlbmd0aC0xO3RoaXMuYWRkKHRoaXMuZWRnZS5wdHNbMF0sMCwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW3RdLHQsMCl9Y3JlYXRlU3BsaXRFZGdlKHQsZSl7bGV0IG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMjtjb25zdCBzPXRoaXMuZWRnZS5wdHNbZS5zZWdtZW50SW5kZXhdLGk9ZS5kaXN0PjB8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBtKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5lZGdlLnB0c1tuXTtyZXR1cm4gaSYmKHJbb109ZS5jb29yZCksbmV3IHRzKHIsbmV3IEJuKHRoaXMuZWRnZS5fbGFiZWwpKX1hZGQodCxlLG4pe2NvbnN0IHM9bmV3IFluKHQsZSxuKSxpPXRoaXMuX25vZGVNYXAuZ2V0KHMpO3JldHVybiBudWxsIT09aT9pOih0aGlzLl9ub2RlTWFwLnB1dChzLHMpLHMpfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtpZihlLm5leHQoKS5jb29yZC5lcXVhbHModCkpcmV0dXJuITB9cmV0dXJuITF9fWNsYXNzIGpue2NvbnN0cnVjdG9yKCl7am4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGF0YT1udWxsLHRoaXMuX3NpemU9MCwwPT09YXJndW1lbnRzLmxlbmd0aClqbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDEwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9kYXRhPW5ldyBBcnJheSh0KS5maWxsKG51bGwpfX1zaXplKCl7cmV0dXJuIHRoaXMuX3NpemV9YWRkQWxsKHQpe3JldHVybiBudWxsPT09dHx8MD09PXQubGVuZ3RoP251bGw6KHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSt0Lmxlbmd0aCksWS5hcnJheWNvcHkodCwwLHRoaXMuX2RhdGEsdGhpcy5fc2l6ZSx0Lmxlbmd0aCksdm9pZCh0aGlzLl9zaXplKz10Lmxlbmd0aCkpfWVuc3VyZUNhcGFjaXR5KHQpe2lmKHQ8PXRoaXMuX2RhdGEubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IGU9TWF0aC5tYXgodCwyKnRoaXMuX2RhdGEubGVuZ3RoKTt0aGlzLl9kYXRhPXN0LmNvcHlPZih0aGlzLl9kYXRhLGUpfXRvQXJyYXkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9zaXplKS5maWxsKG51bGwpO3JldHVybiBZLmFycmF5Y29weSh0aGlzLl9kYXRhLDAsdCwwLHRoaXMuX3NpemUpLHR9YWRkKHQpe3RoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSsxKSx0aGlzLl9kYXRhW3RoaXMuX3NpemVdPXQsKyt0aGlzLl9zaXplfX1jbGFzcyBLbntzdGF0aWMgdG9JbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXQuZ2V0KG4pLmludFZhbHVlKCk7cmV0dXJuIGV9Z2V0Q2hhaW5TdGFydEluZGljZXModCl7bGV0IGU9MDtjb25zdCBuPW5ldyBqbihNYXRoLnRydW5jKHQubGVuZ3RoLzIpKTtuLmFkZChlKTtkb3tjb25zdCBzPXRoaXMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQocyksZT1zfXdoaWxlKGU8dC5sZW5ndGgtMSk7cmV0dXJuIG4udG9BcnJheSgpfWZpbmRDaGFpbkVuZCh0LGUpe2NvbnN0IG49Q24ucXVhZHJhbnQodFtlXSx0W2UrMV0pO2xldCBzPWUrMTtmb3IoO3M8dC5sZW5ndGg7KXtpZihDbi5xdWFkcmFudCh0W3MtMV0sdFtzXSkhPT1uKWJyZWFrO3MrK31yZXR1cm4gcy0xfU9MRGdldENoYWluU3RhcnRJbmRpY2VzKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgTDtuLmFkZChlKTtkb3tjb25zdCBzPXRoaXMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQocyksZT1zfXdoaWxlKGU8dC5sZW5ndGgtMSk7cmV0dXJuIEtuLnRvSW50QXJyYXkobil9fWNsYXNzIFFue2NvbnN0cnVjdG9yKCl7UW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5lPW51bGwsdGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0SW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmU9dCx0aGlzLnB0cz10LmdldENvb3JkaW5hdGVzKCk7Y29uc3QgZT1uZXcgS247dGhpcy5zdGFydEluZGV4PWUuZ2V0Q2hhaW5TdGFydEluZGljZXModGhpcy5wdHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfWdldE1heFgodCl7Y29uc3QgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZT5uP2U6bn1nZXRNaW5YKHQpe2NvbnN0IGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU8bj9lOm59Y29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbigpe2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5zdGFydEluZGV4W3RdLHRoaXMuc3RhcnRJbmRleFt0KzFdLGUsZS5zdGFydEluZGV4W25dLGUuc3RhcnRJbmRleFtuKzFdLHMpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO2lmKGUtdD09MSYmaS1zPT0xKXJldHVybiByLmFkZEludGVyc2VjdGlvbnModGhpcy5lLHQsbi5lLHMpLG51bGw7aWYoIXRoaXMub3ZlcmxhcHModCxlLG4scyxpKSlyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGgudHJ1bmMoKHQrZSkvMiksbD1NYXRoLnRydW5jKChzK2kpLzIpO3Q8byYmKHM8bCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHQsbyxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0LG8sbixsLGkscikpLG88ZSYmKHM8bCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG8sZSxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihvLGUsbixsLGkscikpfX1vdmVybGFwcyh0LGUsbixzLGkpe3JldHVybiBPLmludGVyc2VjdHModGhpcy5wdHNbdF0sdGhpcy5wdHNbZV0sbi5wdHNbc10sbi5wdHNbaV0pfWdldFN0YXJ0SW5kZXhlcygpe3JldHVybiB0aGlzLnN0YXJ0SW5kZXh9Y29tcHV0ZUludGVyc2VjdHModCxlKXtmb3IobGV0IG49MDtuPHRoaXMuc3RhcnRJbmRleC5sZW5ndGgtMTtuKyspZm9yKGxldCBzPTA7czx0LnN0YXJ0SW5kZXgubGVuZ3RoLTE7cysrKXRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihuLHQscyxlKX19Y2xhc3MgSm57Y29uc3RydWN0b3IoKXtKbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9kZXB0aD1BcnJheSgyKS5maWxsKCkubWFwKCgoKT0+QXJyYXkoMykpKTtmb3IobGV0IHQ9MDt0PDI7dCsrKWZvcihsZXQgZT0wO2U8MztlKyspdGhpcy5fZGVwdGhbdF1bZV09Sm4uTlVMTF9WQUxVRX1zdGF0aWMgZGVwdGhBdExvY2F0aW9uKHQpe3JldHVybiB0PT09UXQuRVhURVJJT1I/MDp0PT09UXQuSU5URVJJT1I/MTpKbi5OVUxMX1ZBTFVFfWdldERlcHRoKHQsZSl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdfXNldERlcHRoKHQsZSxuKXt0aGlzLl9kZXB0aFt0XVtlXT1ufWlzTnVsbCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWZvcihsZXQgZT0wO2U8MztlKyspaWYodGhpcy5fZGVwdGhbdF1bZV0hPT1Kbi5OVUxMX1ZBTFVFKXJldHVybiExO3JldHVybiEwfWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bMV09PT1Kbi5OVUxMX1ZBTFVFfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV09PT1Kbi5OVUxMX1ZBTFVFfX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWlmKCF0aGlzLmlzTnVsbCh0KSl7bGV0IGU9dGhpcy5fZGVwdGhbdF1bMV07dGhpcy5fZGVwdGhbdF1bMl08ZSYmKGU9dGhpcy5fZGVwdGhbdF1bMl0pLGU8MCYmKGU9MCk7Zm9yKGxldCBuPTE7bjwzO24rKyl7bGV0IHM9MDt0aGlzLl9kZXB0aFt0XVtuXT5lJiYocz0xKSx0aGlzLl9kZXB0aFt0XVtuXT1zfX19Z2V0RGVsdGEodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2JuLlJJR0hUXS10aGlzLl9kZXB0aFt0XVtibi5MRUZUXX1nZXRMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXTw9MD9RdC5FWFRFUklPUjpRdC5JTlRFUklPUn10b1N0cmluZygpe3JldHVyblwiQTogXCIrdGhpcy5fZGVwdGhbMF1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMF1bMl0rXCIgQjogXCIrdGhpcy5fZGVwdGhbMV1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMV1bMl19YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8MjtlKyspZm9yKGxldCBuPTE7bjwzO24rKyl7Y29uc3Qgcz10LmdldExvY2F0aW9uKGUsbik7cyE9PVF0LkVYVEVSSU9SJiZzIT09UXQuSU5URVJJT1J8fCh0aGlzLmlzTnVsbChlLG4pP3RoaXMuX2RlcHRoW2VdW25dPUpuLmRlcHRoQXRMb2NhdGlvbihzKTp0aGlzLl9kZXB0aFtlXVtuXSs9Sm4uZGVwdGhBdExvY2F0aW9uKHMpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdPT09UXQuSU5URVJJT1ImJnRoaXMuX2RlcHRoW3RdW2VdKyt9fX1Kbi5OVUxMX1ZBTFVFPS0xO2xldCAkbj1jbGFzc3tjb25zdHJ1Y3RvcigpeyRuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xhYmVsPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc0NvdmVyZWQ9ITEsdGhpcy5faXNDb3ZlcmVkU2V0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGFiZWw9dH19c2V0VmlzaXRlZCh0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH1zZXRJblJlc3VsdCh0KXt0aGlzLl9pc0luUmVzdWx0PXR9aXNDb3ZlcmVkKCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZH1pc0NvdmVyZWRTZXQoKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkU2V0fXNldExhYmVsKHQpe3RoaXMuX2xhYmVsPXR9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9c2V0Q292ZXJlZCh0KXt0aGlzLl9pc0NvdmVyZWQ9dCx0aGlzLl9pc0NvdmVyZWRTZXQ9ITB9dXBkYXRlSU0odCl7Zy5pc1RydWUodGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpPj0yLFwiZm91bmQgcGFydGlhbCBsYWJlbFwiKSx0aGlzLmNvbXB1dGVJTSh0KX1pc0luUmVzdWx0KCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH19LHRzPWNsYXNzIGV4dGVuZHMgJG57Y29uc3RydWN0b3IoKXtzdXBlcigpLHRzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMucHRzPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5laUxpc3Q9bmV3IFpuKHRoaXMpLHRoaXMuX25hbWU9bnVsbCx0aGlzLl9tY2U9bnVsbCx0aGlzLl9pc0lzb2xhdGVkPSEwLHRoaXMuX2RlcHRoPW5ldyBKbix0aGlzLl9kZXB0aERlbHRhPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuX2xhYmVsPWV9fXN0YXRpYyB1cGRhdGVJTSgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSnQmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQm4pKXJldHVybiBzdXBlci51cGRhdGVJTS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Uuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGJuLk9OKSx0LmdldExvY2F0aW9uKDEsYm4uT04pLDEpLHQuaXNBcmVhKCkmJihlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxibi5MRUZUKSx0LmdldExvY2F0aW9uKDEsYm4uTEVGVCksMiksZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsYm4uUklHSFQpLHQuZ2V0TG9jYXRpb24oMSxibi5SSUdIVCksMikpfX1nZXREZXB0aCgpe3JldHVybiB0aGlzLl9kZXB0aH1nZXRDb2xsYXBzZWRFZGdlKCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTt0WzBdPXRoaXMucHRzWzBdLHRbMV09dGhpcy5wdHNbMV07cmV0dXJuIG5ldyB0cyh0LEJuLnRvTGluZUxhYmVsKHRoaXMuX2xhYmVsKSl9aXNJc29sYXRlZCgpe3JldHVybiB0aGlzLl9pc0lzb2xhdGVkfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfXNldElzb2xhdGVkKHQpe3RoaXMuX2lzSXNvbGF0ZWQ9dH1zZXROYW1lKHQpe3RoaXMuX25hbWU9dH1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgdHMpKXJldHVybiExO2NvbnN0IGU9dDtpZih0aGlzLnB0cy5sZW5ndGghPT1lLnB0cy5sZW5ndGgpcmV0dXJuITE7bGV0IG49ITAscz0hMCxpPXRoaXMucHRzLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspaWYodGhpcy5wdHNbdF0uZXF1YWxzMkQoZS5wdHNbdF0pfHwobj0hMSksdGhpcy5wdHNbdF0uZXF1YWxzMkQoZS5wdHNbLS1pXSl8fChzPSExKSwhbiYmIXMpcmV0dXJuITE7cmV0dXJuITB9Z2V0Q29vcmRpbmF0ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnB0cy5sZW5ndGg+MD90aGlzLnB0c1swXTpudWxsO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5wdHNbdF19fXByaW50KHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKSx0LnByaW50KFwiTElORVNUUklORyAoXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTt0LnByaW50KFwiKSAgXCIrdGhpcy5fbGFiZWwrXCIgXCIrdGhpcy5fZGVwdGhEZWx0YSl9Y29tcHV0ZUlNKHQpe3RzLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLHQpfWlzQ29sbGFwc2VkKCl7cmV0dXJuISF0aGlzLl9sYWJlbC5pc0FyZWEoKSYmKDM9PT10aGlzLnB0cy5sZW5ndGgmJiEhdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzWzJdKSl9aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9Z2V0TWF4aW11bVNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLnB0cy5sZW5ndGgtMX1nZXREZXB0aERlbHRhKCl7cmV0dXJuIHRoaXMuX2RlcHRoRGVsdGF9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH1wcmludFJldmVyc2UodCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpO2ZvcihsZXQgZT10aGlzLnB0cy5sZW5ndGgtMTtlPj0wO2UtLSl0LnByaW50KHRoaXMucHRzW2VdK1wiIFwiKTt0LnByaW50bG4oXCJcIil9Z2V0TW9ub3RvbmVDaGFpbkVkZ2UoKXtyZXR1cm4gbnVsbD09PXRoaXMuX21jZSYmKHRoaXMuX21jZT1uZXcgUW4odGhpcykpLHRoaXMuX21jZX1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe3RoaXMuX2Vudj1uZXcgTztmb3IobGV0IHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy5fZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLnB0c1t0XSl9cmV0dXJuIHRoaXMuX2Vudn1hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1uZXcgbSh0LmdldEludGVyc2VjdGlvbihzKSk7bGV0IHI9ZSxvPXQuZ2V0RWRnZURpc3RhbmNlKG4scyk7Y29uc3QgbD1yKzE7aWYobDx0aGlzLnB0cy5sZW5ndGgpe2NvbnN0IHQ9dGhpcy5wdHNbbF07aS5lcXVhbHMyRCh0KSYmKHI9bCxvPTApfXRoaXMuZWlMaXN0LmFkZChpLHIsbyl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyBwdDt0LmFwcGVuZChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpLHQuYXBwZW5kKFwiTElORVNUUklORyAoXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQuYXBwZW5kKFwiLFwiKSx0LmFwcGVuZCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3JldHVybiB0LmFwcGVuZChcIikgIFwiK3RoaXMuX2xhYmVsK1wiIFwiK3RoaXMuX2RlcHRoRGVsdGEpLHQudG9TdHJpbmcoKX1pc1BvaW50d2lzZUVxdWFsKHQpe2lmKHRoaXMucHRzLmxlbmd0aCE9PXQucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspaWYoIXRoaXMucHRzW2VdLmVxdWFsczJEKHQucHRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH1zZXREZXB0aERlbHRhKHQpe3RoaXMuX2RlcHRoRGVsdGE9dH1nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpe3JldHVybiB0aGlzLmVpTGlzdH1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpfX0sZXM9Y2xhc3MgZXh0ZW5kcyAkbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmQ9bnVsbCx0aGlzLl9lZGdlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Nvb3JkPXQsdGhpcy5fZWRnZXM9ZSx0aGlzLl9sYWJlbD1uZXcgQm4oMCxRdC5OT05FKX1pc0luY2lkZW50RWRnZUluUmVzdWx0KCl7Zm9yKGxldCB0PXRoaXMuZ2V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtpZih0Lm5leHQoKS5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKXJldHVybiEwfXJldHVybiExfWlzSXNvbGF0ZWQoKXtyZXR1cm4gMT09PXRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Nvb3JkfXByaW50KHQpe3QucHJpbnRsbihcIm5vZGUgXCIrdGhpcy5fY29vcmQrXCIgbGJsOiBcIit0aGlzLl9sYWJlbCl9Y29tcHV0ZUlNKHQpe31jb21wdXRlTWVyZ2VkTG9jYXRpb24odCxlKXtsZXQgbj1RdC5OT05FO2lmKG49dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSksIXQuaXNOdWxsKGUpKXtjb25zdCBzPXQuZ2V0TG9jYXRpb24oZSk7biE9PVF0LkJPVU5EQVJZJiYobj1zKX1yZXR1cm4gbn1zZXRMYWJlbCgpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pfHwhTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXJldHVybiBzdXBlci5zZXRMYWJlbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLl9sYWJlbD90aGlzLl9sYWJlbD1uZXcgQm4odCxlKTp0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUpfX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31tZXJnZUxhYmVsKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlcyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQuX2xhYmVsKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQm4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8MjtlKyspe2NvbnN0IG49dGhpcy5jb21wdXRlTWVyZ2VkTG9jYXRpb24odCxlKTt0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKT09PVF0Lk5PTkUmJnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGUsbil9fX1hZGQodCl7dGhpcy5fZWRnZXMuaW5zZXJ0KHQpLHQuc2V0Tm9kZSh0aGlzKX1zZXRMYWJlbEJvdW5kYXJ5KHQpe2lmKG51bGw9PT10aGlzLl9sYWJlbClyZXR1cm4gbnVsbDtsZXQgZT1RdC5OT05FO251bGwhPT10aGlzLl9sYWJlbCYmKGU9dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24odCkpO2xldCBuPW51bGw7c3dpdGNoKGUpe2Nhc2UgUXQuQk9VTkRBUlk6bj1RdC5JTlRFUklPUjticmVhaztjYXNlIFF0LklOVEVSSU9SOmRlZmF1bHQ6bj1RdC5CT1VOREFSWX10aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LG4pfX0sbnM9Y2xhc3N7Y29uc3RydWN0b3IoKXtucy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLm5vZGVNYXA9bmV3IFduLHRoaXMubm9kZUZhY3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVGYWN0PXR9ZmluZCh0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLmdldCh0KX1hZGROb2RlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT10aGlzLm5vZGVNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09ZSYmKGU9dGhpcy5ub2RlRmFjdC5jcmVhdGVOb2RlKHQpLHRoaXMubm9kZU1hcC5wdXQodCxlKSksZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQodC5nZXRDb29yZGluYXRlKCkpO3JldHVybiBudWxsPT09ZT8odGhpcy5ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0KTooZS5tZXJnZUxhYmVsKHQpLGUpfX1wcmludCh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfXZhbHVlcygpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9Z2V0Qm91bmRhcnlOb2Rlcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KT09PVF0LkJPVU5EQVJZJiZlLmFkZChzKX1yZXR1cm4gZX1hZGQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoKTt0aGlzLmFkZE5vZGUoZSkuYWRkKHQpfX07Y2xhc3Mgc3N7Y29uc3RydWN0b3IoKXtzcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9lZGdlPW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9ub2RlPW51bGwsdGhpcy5fcDA9bnVsbCx0aGlzLl9wMT1udWxsLHRoaXMuX2R4PW51bGwsdGhpcy5fZHk9bnVsbCx0aGlzLl9xdWFkcmFudD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlPXR9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07c3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixudWxsKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtzcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuaW5pdChlLG4pLHRoaXMuX2xhYmVsPXN9fWNvbXBhcmVEaXJlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2R4PT09dC5fZHgmJnRoaXMuX2R5PT09dC5fZHk/MDp0aGlzLl9xdWFkcmFudD50Ll9xdWFkcmFudD8xOnRoaXMuX3F1YWRyYW50PHQuX3F1YWRyYW50Py0xOnEuaW5kZXgodC5fcDAsdC5fcDEsdGhpcy5fcDEpfWdldER5KCl7cmV0dXJuIHRoaXMuX2R5fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDB9c2V0Tm9kZSh0KXt0aGlzLl9ub2RlPXR9cHJpbnQodCl7Y29uc3QgZT1NYXRoLmF0YW4yKHRoaXMuX2R5LHRoaXMuX2R4KSxuPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkscz1uLmxhc3RJbmRleE9mKFwiLlwiKSxpPW4uc3Vic3RyaW5nKHMrMSk7dC5wcmludChcIiAgXCIraStcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIitlK1wiICAgXCIrdGhpcy5fbGFiZWwpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX1nZXREaXJlY3RlZENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDF9Z2V0RHgoKXtyZXR1cm4gdGhpcy5fZHh9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWdldFF1YWRyYW50KCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50fWdldE5vZGUoKXtyZXR1cm4gdGhpcy5fbm9kZX10b1N0cmluZygpe2NvbnN0IHQ9TWF0aC5hdGFuMih0aGlzLl9keSx0aGlzLl9keCksZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIik7cmV0dXJuXCIgIFwiK2Uuc3Vic3RyaW5nKG4rMSkrXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrdCtcIiAgIFwiK3RoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbCh0KXt9aW5pdCh0LGUpe3RoaXMuX3AwPXQsdGhpcy5fcDE9ZSx0aGlzLl9keD1lLngtdC54LHRoaXMuX2R5PWUueS10LnksdGhpcy5fcXVhZHJhbnQ9Q24ucXVhZHJhbnQodGhpcy5fZHgsdGhpcy5fZHkpLGcuaXNUcnVlKCEoMD09PXRoaXMuX2R4JiYwPT09dGhpcy5fZHkpLFwiRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmRcIil9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBpcyBleHRlbmRzIGh7Y29uc3RydWN0b3IodCxlKXtzdXBlcihlP3QrXCIgWyBcIitlK1wiIF1cIjp0KSx0aGlzLnB0PWU/bmV3IG0oZSk6dm9pZCAwLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7VG9wb2xvZ3lFeGNlcHRpb246aXN9KVswXX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMucHR9fWxldCBycz1jbGFzcyBleHRlbmRzIHNze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxycy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0ZvcndhcmQ9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fbmV4dE1pbj1udWxsLHRoaXMuX2VkZ2VSaW5nPW51bGwsdGhpcy5fbWluRWRnZVJpbmc9bnVsbCx0aGlzLl9kZXB0aD1bMCwtOTk5LC05OTldO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHNzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCksdGhpcy5faXNGb3J3YXJkPWUsZSl0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKDApLHQuZ2V0Q29vcmRpbmF0ZSgxKSk7ZWxzZXtjb25zdCBlPXQuZ2V0TnVtUG9pbnRzKCktMTt0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKGUpLHQuZ2V0Q29vcmRpbmF0ZShlLTEpKX10aGlzLmNvbXB1dGVEaXJlY3RlZExhYmVsKCl9c3RhdGljIGRlcHRoRmFjdG9yKHQsZSl7cmV0dXJuIHQ9PT1RdC5FWFRFUklPUiYmZT09PVF0LklOVEVSSU9SPzE6dD09PVF0LklOVEVSSU9SJiZlPT09UXQuRVhURVJJT1I/LTE6MH1nZXROZXh0TWluKCl7cmV0dXJuIHRoaXMuX25leHRNaW59Z2V0RGVwdGgodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdfXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9Y29tcHV0ZURpcmVjdGVkTGFiZWwoKXt0aGlzLl9sYWJlbD1uZXcgQm4odGhpcy5fZWRnZS5nZXRMYWJlbCgpKSx0aGlzLl9pc0ZvcndhcmR8fHRoaXMuX2xhYmVsLmZsaXAoKX1nZXROZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9c2V0RGVwdGgodCxlKXtpZigtOTk5IT09dGhpcy5fZGVwdGhbdF0mJnRoaXMuX2RlcHRoW3RdIT09ZSl0aHJvdyBuZXcgaXMoXCJhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3RoaXMuX2RlcHRoW3RdPWV9aXNJbnRlcmlvckFyZWFFZGdlKCl7bGV0IHQ9ITA7Zm9yKGxldCBlPTA7ZTwyO2UrKyl0aGlzLl9sYWJlbC5pc0FyZWEoZSkmJnRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUsYm4uTEVGVCk9PT1RdC5JTlRFUklPUiYmdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSxibi5SSUdIVCk9PT1RdC5JTlRFUklPUnx8KHQ9ITEpO3JldHVybiB0fXNldE5leHRNaW4odCl7dGhpcy5fbmV4dE1pbj10fXByaW50KHQpe3N1cGVyLnByaW50LmNhbGwodGhpcyx0KSx0LnByaW50KFwiIFwiK3RoaXMuX2RlcHRoW2JuLkxFRlRdK1wiL1wiK3RoaXMuX2RlcHRoW2JuLlJJR0hUXSksdC5wcmludChcIiAoXCIrdGhpcy5nZXREZXB0aERlbHRhKCkrXCIpXCIpLHRoaXMuX2lzSW5SZXN1bHQmJnQucHJpbnQoXCIgaW5SZXN1bHRcIil9c2V0TWluRWRnZVJpbmcodCl7dGhpcy5fbWluRWRnZVJpbmc9dH1pc0xpbmVFZGdlKCl7Y29uc3QgdD10aGlzLl9sYWJlbC5pc0xpbmUoMCl8fHRoaXMuX2xhYmVsLmlzTGluZSgxKSxlPSF0aGlzLl9sYWJlbC5pc0FyZWEoMCl8fHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsUXQuRVhURVJJT1IpLG49IXRoaXMuX2xhYmVsLmlzQXJlYSgxKXx8dGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMSxRdC5FWFRFUklPUik7cmV0dXJuIHQmJmUmJm59c2V0RWRnZVJpbmcodCl7dGhpcy5fZWRnZVJpbmc9dH1nZXRNaW5FZGdlUmluZygpe3JldHVybiB0aGlzLl9taW5FZGdlUmluZ31nZXREZXB0aERlbHRhKCl7bGV0IHQ9dGhpcy5fZWRnZS5nZXREZXB0aERlbHRhKCk7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZHx8KHQ9LXQpLHR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWdldFN5bSgpe3JldHVybiB0aGlzLl9zeW19aXNGb3J3YXJkKCl7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9cHJpbnRFZGdlKHQpe3RoaXMucHJpbnQodCksdC5wcmludChcIiBcIiksdGhpcy5faXNGb3J3YXJkP3RoaXMuX2VkZ2UucHJpbnQodCk6dGhpcy5fZWRnZS5wcmludFJldmVyc2UodCl9c2V0U3ltKHQpe3RoaXMuX3N5bT10fXNldFZpc2l0ZWRFZGdlKHQpe3RoaXMuc2V0VmlzaXRlZCh0KSx0aGlzLl9zeW0uc2V0VmlzaXRlZCh0KX1zZXRFZGdlRGVwdGhzKHQsZSl7bGV0IG49dGhpcy5nZXRFZGdlKCkuZ2V0RGVwdGhEZWx0YSgpO3RoaXMuX2lzRm9yd2FyZHx8KG49LW4pO2xldCBzPTE7dD09PWJuLkxFRlQmJihzPS0xKTtjb25zdCBpPWJuLm9wcG9zaXRlKHQpLHI9ZStuKnM7dGhpcy5zZXREZXB0aCh0LGUpLHRoaXMuc2V0RGVwdGgoaSxyKX1nZXRFZGdlUmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ31pc0luUmVzdWx0KCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH19O2NsYXNzIG9ze2NyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyBlcyh0LG51bGwpfX1sZXQgbHM9Y2xhc3N7Y29uc3RydWN0b3IoKXtscy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9lZGdlcz1uZXcgTCx0aGlzLl9ub2Rlcz1udWxsLHRoaXMuX2VkZ2VFbmRMaXN0PW5ldyBMLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX25vZGVzPW5ldyBucyhuZXcgb3MpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25vZGVzPW5ldyBucyh0KX19c3RhdGljIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fXByaW50RWRnZXModCl7dC5wcmludGxuKFwiRWRnZXM6XCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKyl7dC5wcmludGxuKFwiZWRnZSBcIitlK1wiOlwiKTtjb25zdCBuPXRoaXMuX2VkZ2VzLmdldChlKTtuLnByaW50KHQpLG4uZWlMaXN0LnByaW50KHQpfX1maW5kKHQpe3JldHVybiB0aGlzLl9ub2Rlcy5maW5kKHQpfWFkZE5vZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVzKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKHQpfX1nZXROb2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKX1saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX1kZWJ1Z1ByaW50bG4odCl7WS5vdXQucHJpbnRsbih0KX1pc0JvdW5kYXJ5Tm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fbm9kZXMuZmluZChlKTtpZihudWxsPT09bilyZXR1cm4hMTtjb25zdCBzPW4uZ2V0TGFiZWwoKTtyZXR1cm4gbnVsbCE9PXMmJnMuZ2V0TG9jYXRpb24odCk9PT1RdC5CT1VOREFSWX1saW5rQWxsRGlyZWN0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rQWxsRGlyZWN0ZWRFZGdlcygpfX1tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsbixzKXtyZXR1cm4hIXQuZXF1YWxzKG4pJiYocS5pbmRleCh0LGUscyk9PT1xLkNPTExJTkVBUiYmQ24ucXVhZHJhbnQodCxlKT09PUNuLnF1YWRyYW50KG4scykpfWdldEVkZ2VFbmRzKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRMaXN0fWRlYnVnUHJpbnQodCl7WS5vdXQucHJpbnQodCl9Z2V0RWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9ZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24odCxlKXtmb3IobGV0IG49MDtuPHRoaXMuX2VkZ2VzLnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5fZWRnZXMuZ2V0KG4pLGk9cy5nZXRDb29yZGluYXRlcygpO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLGlbMF0saVsxXSkpcmV0dXJuIHM7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsaVtpLmxlbmd0aC0xXSxpW2kubGVuZ3RoLTJdKSlyZXR1cm4gc31yZXR1cm4gbnVsbH1pbnNlcnRFZGdlKHQpe3RoaXMuX2VkZ2VzLmFkZCh0KX1maW5kRWRnZUVuZCh0KXtmb3IobGV0IGU9dGhpcy5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4uZ2V0RWRnZSgpPT09dClyZXR1cm4gbn1yZXR1cm4gbnVsbH1hZGRFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9lZGdlcy5hZGQodCk7Y29uc3Qgbj1uZXcgcnModCwhMCkscz1uZXcgcnModCwhMSk7bi5zZXRTeW0ocykscy5zZXRTeW0obiksdGhpcy5hZGQobiksdGhpcy5hZGQocyl9fWFkZCh0KXt0aGlzLl9ub2Rlcy5hZGQodCksdGhpcy5fZWRnZUVuZExpc3QuYWRkKHQpfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzLnZhbHVlcygpfWZpbmRFZGdlKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLl9lZGdlcy5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuX2VkZ2VzLmdldChuKSxpPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0LmVxdWFscyhpWzBdKSYmZS5lcXVhbHMoaVsxXSkpcmV0dXJuIHN9cmV0dXJuIG51bGx9fTtjbGFzcyBhcyBleHRlbmRzIGxze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxhcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wYXJlbnRHZW9tPW51bGwsdGhpcy5fbGluZUVkZ2VNYXA9bmV3IE50LHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGU9bnVsbCx0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSEwLHRoaXMuX2FyZ0luZGV4PW51bGwsdGhpcy5fYm91bmRhcnlOb2Rlcz1udWxsLHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMSx0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbCx0aGlzLl9hcmVhUHRMb2NhdG9yPW51bGwsdGhpcy5fcHRMb2NhdG9yPW5ldyBmbiwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsZ24uT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9hcmdJbmRleD10LHRoaXMuX3BhcmVudEdlb209ZSx0aGlzLl9ib3VuZGFyeU5vZGVSdWxlPW4sbnVsbCE9PWUmJnRoaXMuYWRkKGUpfX1zdGF0aWMgZGV0ZXJtaW5lQm91bmRhcnkodCxlKXtyZXR1cm4gdC5pc0luQm91bmRhcnkoZSk/UXQuQk9VTkRBUlk6UXQuSU5URVJJT1J9aW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpe2NvbnN0IG49dGhpcy5fbm9kZXMuYWRkTm9kZShlKS5nZXRMYWJlbCgpO2xldCBzPTEsaT1RdC5OT05FO2k9bi5nZXRMb2NhdGlvbih0LGJuLk9OKSxpPT09UXQuQk9VTkRBUlkmJnMrKztjb25zdCByPWFzLmRldGVybWluZUJvdW5kYXJ5KHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUscyk7bi5zZXRMb2NhdGlvbih0LHIpfWNvbXB1dGVTZWxmTm9kZXMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcHV0ZVNlbGZOb2Rlcyh0LGUsITEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPW5ldyBGbihhcmd1bWVudHNbMF0sITAsITEpO24uc2V0SXNEb25lSWZQcm9wZXJJbnQoZSk7Y29uc3Qgcz10aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLGk9dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIGd0fHx0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgcnR8fHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiB5dCxyPXR8fCFpO3JldHVybiBzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLG4sciksdGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModGhpcy5fYXJnSW5kZXgpLG59fWNvbXB1dGVTcGxpdEVkZ2VzKHQpe2ZvcihsZXQgZT10aGlzLl9lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZWlMaXN0LmFkZFNwbGl0RWRnZXModCl9fWNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0LGUsbil7Y29uc3Qgcz1uZXcgRm4oZSxuLCEwKTtzLnNldEJvdW5kYXJ5Tm9kZXModGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksdC5nZXRCb3VuZGFyeU5vZGVzKCkpO3JldHVybiB0aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLHQuX2VkZ2VzLHMpLHN9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5fcGFyZW50R2VvbX1nZXRCb3VuZGFyeU5vZGVSdWxlKCl7cmV0dXJuIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGV9aGFzVG9vRmV3UG9pbnRzKCl7cmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c31hZGRQb2ludCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGUoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHQsUXQuSU5URVJJT1IpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHQsUXQuSU5URVJJT1IpfX1hZGRQb2x5Z29uKHQpe3RoaXMuYWRkUG9seWdvblJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSxRdC5FWFRFUklPUixRdC5JTlRFUklPUik7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgbj10LmdldEludGVyaW9yUmluZ04oZSk7dGhpcy5hZGRQb2x5Z29uUmluZyhuLFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SKX19YWRkRWRnZSh0KXt0aGlzLmluc2VydEVkZ2UodCk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxlWzBdLFF0LkJPVU5EQVJZKSx0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LGVbZS5sZW5ndGgtMV0sUXQuQk9VTkRBUlkpfWFkZExpbmVTdHJpbmcodCl7Y29uc3QgZT1fdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLl9pbnZhbGlkUG9pbnQ9ZVswXSxudWxsO2NvbnN0IG49bmV3IHRzKGUsbmV3IEJuKHRoaXMuX2FyZ0luZGV4LFF0LklOVEVSSU9SKSk7dGhpcy5fbGluZUVkZ2VNYXAucHV0KHQsbiksdGhpcy5pbnNlcnRFZGdlKG4pLGcuaXNUcnVlKGUubGVuZ3RoPj0yLFwiZm91bmQgTGluZVN0cmluZyB3aXRoIHNpbmdsZSBwb2ludFwiKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsZVswXSksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LGVbZS5sZW5ndGgtMV0pfWdldEludmFsaWRQb2ludCgpe3JldHVybiB0aGlzLl9pbnZhbGlkUG9pbnR9Z2V0Qm91bmRhcnlQb2ludHMoKXtjb25zdCB0PXRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBuPTA7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7ZVtuKytdPXQuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKX1yZXR1cm4gZX1nZXRCb3VuZGFyeU5vZGVzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9ib3VuZGFyeU5vZGVzJiYodGhpcy5fYm91bmRhcnlOb2Rlcz10aGlzLl9ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuX2FyZ0luZGV4KSksdGhpcy5fYm91bmRhcnlOb2Rlc31hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSh0LGUsbil7aWYodGhpcy5pc0JvdW5kYXJ5Tm9kZSh0LGUpKXJldHVybiBudWxsO249PT1RdC5CT1VOREFSWSYmdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT90aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodCxlKTp0aGlzLmluc2VydFBvaW50KHQsZSxuKX1hZGRQb2x5Z29uUmluZyh0LGUsbil7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgcz1fdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKHMubGVuZ3RoPDQpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLl9pbnZhbGlkUG9pbnQ9c1swXSxudWxsO2xldCBpPWUscj1uO3EuaXNDQ1cocykmJihpPW4scj1lKTtjb25zdCBvPW5ldyB0cyhzLG5ldyBCbih0aGlzLl9hcmdJbmRleCxRdC5CT1VOREFSWSxpLHIpKTt0aGlzLl9saW5lRWRnZU1hcC5wdXQodCxvKSx0aGlzLmluc2VydEVkZ2UobyksdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxzWzBdLFF0LkJPVU5EQVJZKX1pbnNlcnRQb2ludCh0LGUsbil7Y29uc3Qgcz10aGlzLl9ub2Rlcy5hZGROb2RlKGUpLGk9cy5nZXRMYWJlbCgpO251bGw9PT1pP3MuX2xhYmVsPW5ldyBCbih0LG4pOmkuc2V0TG9jYXRpb24odCxuKX1jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKXtyZXR1cm4gbmV3IEdufWFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZWlMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxuLmNvb3JkLHMpfX19YWRkKCl7aWYoISgxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKSlyZXR1cm4gc3VwZXIuYWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIHl0JiYodGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMSksdCBpbnN0YW5jZW9mIHJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiAkKXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBldCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHV0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgeXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgaHQpKXRocm93IG5ldyBLKHQuZ2V0R2VvbWV0cnlUeXBlKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19fWFkZENvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fWxvY2F0ZSh0KXtyZXR1cm4gSSh0aGlzLl9wYXJlbnRHZW9tLGl0KSYmdGhpcy5fcGFyZW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk+NTA/KG51bGw9PT10aGlzLl9hcmVhUHRMb2NhdG9yJiYodGhpcy5fYXJlYVB0TG9jYXRvcj1uZXcgemUodGhpcy5fcGFyZW50R2VvbSkpLHRoaXMuX2FyZWFQdExvY2F0b3IubG9jYXRlKHQpKTp0aGlzLl9wdExvY2F0b3IubG9jYXRlKHQsdGhpcy5fcGFyZW50R2VvbSl9ZmluZEVkZ2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbGluZUVkZ2VNYXAuZ2V0KHQpfXJldHVybiBzdXBlci5maW5kRWRnZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBjcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9tZXRyeUdyYXBoOmFzfSk7Y2xhc3MgaHN7dmlzaXQodCl7fX1jbGFzcyB1c3tjb25zdHJ1Y3Rvcigpe3VzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3A9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD1uZXcgbSh0KSx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD0xLHRoaXMuX2RhdGE9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wPW5ldyBtKHQsZSksdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9MSx0aGlzLl9kYXRhPW59fWlzUmVwZWF0ZWQoKXtyZXR1cm4gdGhpcy5fY291bnQ+MX1nZXRSaWdodCgpe3JldHVybiB0aGlzLl9yaWdodH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B9c2V0TGVmdCh0KXt0aGlzLl9sZWZ0PXR9Z2V0WCgpe3JldHVybiB0aGlzLl9wLnh9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWdldENvdW50KCl7cmV0dXJuIHRoaXMuX2NvdW50fWdldExlZnQoKXtyZXR1cm4gdGhpcy5fbGVmdH1nZXRZKCl7cmV0dXJuIHRoaXMuX3AueX1pbmNyZW1lbnQoKXt0aGlzLl9jb3VudD10aGlzLl9jb3VudCsxfXNldFJpZ2h0KHQpe3RoaXMuX3JpZ2h0PXR9fWNsYXNzIGdze2NvbnN0cnVjdG9yKCl7Z3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcm9vdD1udWxsLHRoaXMuX251bWJlck9mTm9kZXM9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClncy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3RvbGVyYW5jZT10fX1zdGF0aWMgdG9Db29yZGluYXRlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gZ3MudG9Db29yZGluYXRlcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgUjtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPWU/dC5nZXRDb3VudCgpOjE7Zm9yKGxldCBlPTA7ZTxpO2UrKyluLmFkZCh0LmdldENvb3JkaW5hdGUoKSwhMCl9cmV0dXJuIG4udG9Db29yZGluYXRlQXJyYXkoKX19aW5zZXJ0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluc2VydCh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihudWxsPT09dGhpcy5fcm9vdClyZXR1cm4gdGhpcy5fcm9vdD1uZXcgdXModCxlKSx0aGlzLl9yb290O2lmKHRoaXMuX3RvbGVyYW5jZT4wKXtjb25zdCBlPXRoaXMuZmluZEJlc3RNYXRjaE5vZGUodCk7aWYobnVsbCE9PWUpcmV0dXJuIGUuaW5jcmVtZW50KCksZX1yZXR1cm4gdGhpcy5pbnNlcnRFeGFjdCh0LGUpfX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8mJkkoYXJndW1lbnRzWzFdLEMpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLl9yb290LHQsITAsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltoc119dmlzaXQodCl7ZS5hZGQodCl9fSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8mJkkoYXJndW1lbnRzWzFdLGhzKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5xdWVyeU5vZGUodGhpcy5fcm9vdCx0LCEwLGUpfX1xdWVyeU5vZGUodCxlLG4scyl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7bGV0IGk9bnVsbCxyPW51bGwsbz1udWxsO24/KGk9ZS5nZXRNaW5YKCkscj1lLmdldE1heFgoKSxvPXQuZ2V0WCgpKTooaT1lLmdldE1pblkoKSxyPWUuZ2V0TWF4WSgpLG89dC5nZXRZKCkpO2NvbnN0IGw9bzw9cjtpPG8mJnRoaXMucXVlcnlOb2RlKHQuZ2V0TGVmdCgpLGUsIW4scyksZS5jb250YWlucyh0LmdldENvb3JkaW5hdGUoKSkmJnMudmlzaXQodCksbCYmdGhpcy5xdWVyeU5vZGUodC5nZXRSaWdodCgpLGUsIW4scyl9ZmluZEJlc3RNYXRjaE5vZGUodCl7Y29uc3QgZT1uZXcgZHModCx0aGlzLl90b2xlcmFuY2UpO3JldHVybiB0aGlzLnF1ZXJ5KGUucXVlcnlFbnZlbG9wZSgpLGUpLGUuZ2V0Tm9kZSgpfWlzRW1wdHkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jvb3R9aW5zZXJ0RXhhY3QodCxlKXtsZXQgbj10aGlzLl9yb290LHM9dGhpcy5fcm9vdCxpPSEwLHI9ITA7Zm9yKDtudWxsIT09bjspe2lmKG51bGwhPT1uKXtpZih0LmRpc3RhbmNlKG4uZ2V0Q29vcmRpbmF0ZSgpKTw9dGhpcy5fdG9sZXJhbmNlKXJldHVybiBuLmluY3JlbWVudCgpLG59cj1pP3QueDxuLmdldFgoKTp0Lnk8bi5nZXRZKCkscz1uLG49cj9uLmdldExlZnQoKTpuLmdldFJpZ2h0KCksaT0haX10aGlzLl9udW1iZXJPZk5vZGVzPXRoaXMuX251bWJlck9mTm9kZXMrMTtjb25zdCBvPW5ldyB1cyh0LGUpO3JldHVybiByP3Muc2V0TGVmdChvKTpzLnNldFJpZ2h0KG8pLG99fWNsYXNzIGRze2NvbnN0cnVjdG9yKCl7ZHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdG9sZXJhbmNlPW51bGwsdGhpcy5fbWF0Y2hOb2RlPW51bGwsdGhpcy5fbWF0Y2hEaXN0PTAsdGhpcy5fcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9dCx0aGlzLl90b2xlcmFuY2U9ZX12aXNpdCh0KXtjb25zdCBlPXRoaXMuX3AuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpO2lmKCEoZTw9dGhpcy5fdG9sZXJhbmNlKSlyZXR1cm4gbnVsbDtsZXQgbj0hMTsobnVsbD09PXRoaXMuX21hdGNoTm9kZXx8ZTx0aGlzLl9tYXRjaERpc3R8fG51bGwhPT10aGlzLl9tYXRjaE5vZGUmJmU9PT10aGlzLl9tYXRjaERpc3QmJnQuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLl9tYXRjaE5vZGUuZ2V0Q29vcmRpbmF0ZSgpKTwxKSYmKG49ITApLG4mJih0aGlzLl9tYXRjaE5vZGU9dCx0aGlzLl9tYXRjaERpc3Q9ZSl9cXVlcnlFbnZlbG9wZSgpe2NvbnN0IHQ9bmV3IE8odGhpcy5fcCk7cmV0dXJuIHQuZXhwYW5kQnkodGhpcy5fdG9sZXJhbmNlKSx0fWdldE5vZGUoKXtyZXR1cm4gdGhpcy5fbWF0Y2hOb2RlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltoc119fWdzLkJlc3RNYXRjaFZpc2l0b3I9ZHM7dmFyIF9zPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEtkVHJlZTpnc30pO2NsYXNzIHBze2NvbnN0cnVjdG9yKCl7cHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXRlbXM9bmV3IEwsdGhpcy5fc3Vibm9kZT1uZXcgQXJyYXkoNCkuZmlsbChudWxsKX1zdGF0aWMgZ2V0U3Vibm9kZUluZGV4KHQsZSxuKXtsZXQgcz0tMTtyZXR1cm4gdC5nZXRNaW5YKCk+PWUmJih0LmdldE1pblkoKT49biYmKHM9MyksdC5nZXRNYXhZKCk8PW4mJihzPTEpKSx0LmdldE1heFgoKTw9ZSYmKHQuZ2V0TWluWSgpPj1uJiYocz0yKSx0LmdldE1heFkoKTw9biYmKHM9MCkpLHN9aGFzQ2hpbGRyZW4oKXtmb3IobGV0IHQ9MDt0PDQ7dCsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfWlzUHJ1bmFibGUoKXtyZXR1cm4hKHRoaXMuaGFzQ2hpbGRyZW4oKXx8dGhpcy5oYXNJdGVtcygpKX1hZGRBbGxJdGVtcyh0KXt0LmFkZEFsbCh0aGlzLl9pdGVtcyk7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmdGhpcy5fc3Vibm9kZVtlXS5hZGRBbGxJdGVtcyh0KTtyZXR1cm4gdH1nZXROb2RlQ291bnQoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJih0Kz10aGlzLl9zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrMX1zaXplKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYodCs9dGhpcy5fc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0K3RoaXMuX2l0ZW1zLnNpemUoKX1hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7ZS5hZGRBbGwodGhpcy5faXRlbXMpO2ZvcihsZXQgbj0wO248NDtuKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbbl0mJnRoaXMuX3N1Ym5vZGVbbl0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKX12aXNpdEl0ZW1zKHQsZSl7Zm9yKGxldCB0PXRoaXMuX2l0ZW1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWUudmlzaXRJdGVtKHQubmV4dCgpKX1oYXNJdGVtcygpe3JldHVybiF0aGlzLl9pdGVtcy5pc0VtcHR5KCl9cmVtb3ZlKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4hMTtsZXQgbj0hMTtmb3IobGV0IHM9MDtzPDQ7cysrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW3NdJiYobj10aGlzLl9zdWJub2RlW3NdLnJlbW92ZSh0LGUpLG4pKXt0aGlzLl9zdWJub2RlW3NdLmlzUHJ1bmFibGUoKSYmKHRoaXMuX3N1Ym5vZGVbc109bnVsbCk7YnJlYWt9cmV0dXJuIG58fChuPXRoaXMuX2l0ZW1zLnJlbW92ZShlKSxuKX12aXNpdCh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7dGhpcy52aXNpdEl0ZW1zKHQsZSk7Zm9yKGxldCBuPTA7bjw0O24rKyludWxsIT09dGhpcy5fc3Vibm9kZVtuXSYmdGhpcy5fc3Vibm9kZVtuXS52aXNpdCh0LGUpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWRlcHRoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdKXtjb25zdCBuPXRoaXMuX3N1Ym5vZGVbZV0uZGVwdGgoKTtuPnQmJih0PW4pfXJldHVybiB0KzF9aXNFbXB0eSgpe2xldCB0PSEwO2lmKHRoaXMuX2l0ZW1zLmlzRW1wdHkoKSl7Zm9yKGxldCBlPTA7ZTw0O2UrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmIXRoaXMuX3N1Ym5vZGVbZV0uaXNFbXB0eSgpKXt0PSExO2JyZWFrfX1lbHNlIHQ9ITE7cmV0dXJuIHR9YWRkKHQpe3RoaXMuX2l0ZW1zLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bY119fWZ1bmN0aW9uIG1zKCl7fW1zLmV4cG9uZW50PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe2xldCBuLHMsaSxyO2NvbnN0IG89ezMyOntkOjEyNyxjOjEyOCxiOjAsYTowfSw2NDp7ZDozMjc1MixjOjAsYjowLGE6MH19LGw9ezMyOjgsNjQ6MTF9W3RdO3J8fChuPWU8MHx8MS9lPDAsaXNGaW5pdGUoZSl8fChyPW9bdF0sbiYmKHIuZCs9MTw8dC80LTEpLHM9TWF0aC5wb3coMixsKS0xLGk9MCkpO2lmKCFyKXtmb3Iocz17MzI6MTI3LDY0OjEwMjN9W3RdLGk9TWF0aC5hYnMoZSk7aT49MjspcysrLGkvPTI7Zm9yKDtpPDEmJnM+MDspcy0tLGkqPTI7czw9MCYmKGkvPTIpLDMyPT09dCYmcz4yNTQmJihyPXtkOm4/MjU1OjEyNyxjOjEyOCxiOjAsYTowfSxzPU1hdGgucG93KDIsbCktMSxpPTApfXJldHVybiBzfSg2NCx0KS0xMDIzfSxtcy5wb3dlck9mMj1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0KX07Y2xhc3MgZnN7Y29uc3RydWN0b3IoKXtmcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdD1uZXcgbSx0aGlzLl9sZXZlbD0wLHRoaXMuX2Vudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcHV0ZUtleSh0KX1zdGF0aWMgY29tcHV0ZVF1YWRMZXZlbCh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCkscz1lPm4/ZTpuO3JldHVybiBtcy5leHBvbmVudChzKSsxfWdldExldmVsKCl7cmV0dXJuIHRoaXMuX2xldmVsfWNvbXB1dGVLZXkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKHRoaXMuX2xldmVsPWZzLmNvbXB1dGVRdWFkTGV2ZWwodCksdGhpcy5fZW52PW5ldyBPLHRoaXMuY29tcHV0ZUtleSh0aGlzLl9sZXZlbCx0KTshdGhpcy5fZW52LmNvbnRhaW5zKHQpOyl0aGlzLl9sZXZlbCs9MSx0aGlzLmNvbXB1dGVLZXkodGhpcy5fbGV2ZWwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1tcy5wb3dlck9mMih0KTt0aGlzLl9wdC54PU1hdGguZmxvb3IoZS5nZXRNaW5YKCkvbikqbix0aGlzLl9wdC55PU1hdGguZmxvb3IoZS5nZXRNaW5ZKCkvbikqbix0aGlzLl9lbnYuaW5pdCh0aGlzLl9wdC54LHRoaXMuX3B0Lngrbix0aGlzLl9wdC55LHRoaXMuX3B0Lnkrbil9fWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuX2Vudn1nZXRDZW50cmUoKXtyZXR1cm4gbmV3IG0oKHRoaXMuX2Vudi5nZXRNaW5YKCkrdGhpcy5fZW52LmdldE1heFgoKSkvMiwodGhpcy5fZW52LmdldE1pblkoKSt0aGlzLl9lbnYuZ2V0TWF4WSgpKS8yKX1nZXRQb2ludCgpe3JldHVybiB0aGlzLl9wdH19bGV0IHlzPWNsYXNzIGV4dGVuZHMgcHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHlzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Vudj1udWxsLHRoaXMuX2NlbnRyZXg9bnVsbCx0aGlzLl9jZW50cmV5PW51bGwsdGhpcy5fbGV2ZWw9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9lbnY9dCx0aGlzLl9sZXZlbD1lLHRoaXMuX2NlbnRyZXg9KHQuZ2V0TWluWCgpK3QuZ2V0TWF4WCgpKS8yLHRoaXMuX2NlbnRyZXk9KHQuZ2V0TWluWSgpK3QuZ2V0TWF4WSgpKS8yfXN0YXRpYyBjcmVhdGVOb2RlKHQpe2NvbnN0IGU9bmV3IGZzKHQpO3JldHVybiBuZXcgeXMoZS5nZXRFbnZlbG9wZSgpLGUuZ2V0TGV2ZWwoKSl9c3RhdGljIGNyZWF0ZUV4cGFuZGVkKHQsZSl7Y29uc3Qgbj1uZXcgTyhlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5fZW52KTtjb25zdCBzPXlzLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZzLmluc2VydE5vZGUodCksc31maW5kKHQpe2NvbnN0IGU9cHMuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZigtMT09PWUpcmV0dXJuIHRoaXM7aWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0pe3JldHVybiB0aGlzLl9zdWJub2RlW2VdLmZpbmQodCl9cmV0dXJuIHRoaXN9aXNTZWFyY2hNYXRjaCh0KXtyZXR1cm4gbnVsbCE9PXQmJnRoaXMuX2Vudi5pbnRlcnNlY3RzKHQpfWdldFN1Ym5vZGUodCl7cmV0dXJuIG51bGw9PT10aGlzLl9zdWJub2RlW3RdJiYodGhpcy5fc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuX3N1Ym5vZGVbdF19Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5fZW52fWdldE5vZGUodCl7Y29uc3QgZT1wcy5nZXRTdWJub2RlSW5kZXgodCx0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKC0xIT09ZSl7cmV0dXJuIHRoaXMuZ2V0U3Vibm9kZShlKS5nZXROb2RlKHQpfXJldHVybiB0aGlzfWNyZWF0ZVN1Ym5vZGUodCl7bGV0IGU9MCxuPTAscz0wLGk9MDtzd2l0Y2godCl7Y2FzZSAwOmU9dGhpcy5fZW52LmdldE1pblgoKSxuPXRoaXMuX2NlbnRyZXgscz10aGlzLl9lbnYuZ2V0TWluWSgpLGk9dGhpcy5fY2VudHJleTticmVhaztjYXNlIDE6ZT10aGlzLl9jZW50cmV4LG49dGhpcy5fZW52LmdldE1heFgoKSxzPXRoaXMuX2Vudi5nZXRNaW5ZKCksaT10aGlzLl9jZW50cmV5O2JyZWFrO2Nhc2UgMjplPXRoaXMuX2Vudi5nZXRNaW5YKCksbj10aGlzLl9jZW50cmV4LHM9dGhpcy5fY2VudHJleSxpPXRoaXMuX2Vudi5nZXRNYXhZKCk7YnJlYWs7Y2FzZSAzOmU9dGhpcy5fY2VudHJleCxuPXRoaXMuX2Vudi5nZXRNYXhYKCkscz10aGlzLl9jZW50cmV5LGk9dGhpcy5fZW52LmdldE1heFkoKX1jb25zdCByPW5ldyBPKGUsbixzLGkpO3JldHVybiBuZXcgeXMocix0aGlzLl9sZXZlbC0xKX1pbnNlcnROb2RlKHQpe2cuaXNUcnVlKG51bGw9PT10aGlzLl9lbnZ8fHRoaXMuX2Vudi5jb250YWlucyh0Ll9lbnYpKTtjb25zdCBlPXBzLmdldFN1Ym5vZGVJbmRleCh0Ll9lbnYsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZih0Ll9sZXZlbD09PXRoaXMuX2xldmVsLTEpdGhpcy5fc3Vibm9kZVtlXT10O2Vsc2V7Y29uc3Qgbj10aGlzLmNyZWF0ZVN1Ym5vZGUoZSk7bi5pbnNlcnROb2RlKHQpLHRoaXMuX3N1Ym5vZGVbZV09bn19fTtjbGFzcyB4c3tzdGF0aWMgaXNaZXJvV2lkdGgodCxlKXtjb25zdCBuPWUtdDtpZigwPT09bilyZXR1cm4hMDtjb25zdCBzPW4vTWF0aC5tYXgoTWF0aC5hYnModCksTWF0aC5hYnMoZSkpO3JldHVybiBtcy5leHBvbmVudChzKTw9eHMuTUlOX0JJTkFSWV9FWFBPTkVOVH19eHMuTUlOX0JJTkFSWV9FWFBPTkVOVD0tNTA7Y2xhc3MgRXMgZXh0ZW5kcyBwc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9aW5zZXJ0KHQsZSl7Y29uc3Qgbj1wcy5nZXRTdWJub2RlSW5kZXgodCxFcy5vcmlnaW4ueCxFcy5vcmlnaW4ueSk7aWYoLTE9PT1uKXJldHVybiB0aGlzLmFkZChlKSxudWxsO2NvbnN0IHM9dGhpcy5fc3Vibm9kZVtuXTtpZihudWxsPT09c3x8IXMuZ2V0RW52ZWxvcGUoKS5jb250YWlucyh0KSl7Y29uc3QgZT15cy5jcmVhdGVFeHBhbmRlZChzLHQpO3RoaXMuX3N1Ym5vZGVbbl09ZX10aGlzLmluc2VydENvbnRhaW5lZCh0aGlzLl9zdWJub2RlW25dLHQsZSl9aXNTZWFyY2hNYXRjaCh0KXtyZXR1cm4hMH1pbnNlcnRDb250YWluZWQodCxlLG4pe2cuaXNUcnVlKHQuZ2V0RW52ZWxvcGUoKS5jb250YWlucyhlKSk7Y29uc3Qgcz14cy5pc1plcm9XaWR0aChlLmdldE1pblgoKSxlLmdldE1heFgoKSksaT14cy5pc1plcm9XaWR0aChlLmdldE1pblkoKSxlLmdldE1heFkoKSk7bGV0IHI9bnVsbDtyPXN8fGk/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxyLmFkZChuKX19RXMub3JpZ2luPW5ldyBtKDAsMCk7Y2xhc3MgSXN7aW5zZXJ0KHQsZSl7fXJlbW92ZSh0LGUpe31xdWVyeSgpe319Y2xhc3MgTnN7Y29uc3RydWN0b3IoKXtOcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yb290PW51bGwsdGhpcy5fbWluRXh0ZW50PTEsdGhpcy5fcm9vdD1uZXcgRXN9c3RhdGljIGVuc3VyZUV4dGVudCh0LGUpe2xldCBuPXQuZ2V0TWluWCgpLHM9dC5nZXRNYXhYKCksaT10LmdldE1pblkoKSxyPXQuZ2V0TWF4WSgpO3JldHVybiBuIT09cyYmaSE9PXI/dDoobj09PXMmJihuLT1lLzIscys9ZS8yKSxpPT09ciYmKGktPWUvMixyKz1lLzIpLG5ldyBPKG4scyxpLHIpKX1zaXplKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb290P3RoaXMuX3Jvb3Quc2l6ZSgpOjB9aW5zZXJ0KHQsZSl7dGhpcy5jb2xsZWN0U3RhdHModCk7Y29uc3Qgbj1Ocy5lbnN1cmVFeHRlbnQodCx0aGlzLl9taW5FeHRlbnQpO3RoaXMuX3Jvb3QuaW5zZXJ0KG4sZSl9cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgWWU7cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlLmdldEl0ZW1zKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3Jvb3QudmlzaXQodCxlKX19cXVlcnlBbGwoKXtjb25zdCB0PW5ldyBMO3JldHVybiB0aGlzLl9yb290LmFkZEFsbEl0ZW1zKHQpLHR9cmVtb3ZlKHQsZSl7Y29uc3Qgbj1Ocy5lbnN1cmVFeHRlbnQodCx0aGlzLl9taW5FeHRlbnQpO3JldHVybiB0aGlzLl9yb290LnJlbW92ZShuLGUpfWNvbGxlY3RTdGF0cyh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKTtlPHRoaXMuX21pbkV4dGVudCYmZT4wJiYodGhpcy5fbWluRXh0ZW50PWUpO2NvbnN0IG49dC5nZXRIZWlnaHQoKTtuPHRoaXMuX21pbkV4dGVudCYmbj4wJiYodGhpcy5fbWluRXh0ZW50PW4pfWRlcHRoKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb290P3RoaXMuX3Jvb3QuZGVwdGgoKTowfWlzRW1wdHkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jvb3R8fHRoaXMuX3Jvb3QuaXNFbXB0eSgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltJcyxjXX19dmFyIHdzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFF1YWR0cmVlOk5zfSk7Y2xhc3MgQ3N7Z2V0Qm91bmRzKCl7fX1jbGFzcyBTc3tjb25zdHJ1Y3Rvcigpe1NzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2JvdW5kcz1udWxsLHRoaXMuX2l0ZW09bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ib3VuZHM9dCx0aGlzLl9pdGVtPWV9Z2V0SXRlbSgpe3JldHVybiB0aGlzLl9pdGVtfWdldEJvdW5kcygpe3JldHVybiB0aGlzLl9ib3VuZHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NzLGNdfX1jbGFzcyBMc3tjb25zdHJ1Y3Rvcigpe0xzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpemU9bnVsbCx0aGlzLl9pdGVtcz1udWxsLHRoaXMuX3NpemU9MCx0aGlzLl9pdGVtcz1uZXcgTCx0aGlzLl9pdGVtcy5hZGQobnVsbCl9cG9sbCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5faXRlbXMuZ2V0KDEpO3JldHVybiB0aGlzLl9pdGVtcy5zZXQoMSx0aGlzLl9pdGVtcy5nZXQodGhpcy5fc2l6ZSkpLHRoaXMuX3NpemUtPTEsdGhpcy5yZW9yZGVyKDEpLHR9c2l6ZSgpe3JldHVybiB0aGlzLl9zaXplfXJlb3JkZXIodCl7bGV0IGU9bnVsbDtjb25zdCBuPXRoaXMuX2l0ZW1zLmdldCh0KTtmb3IoOzIqdDw9dGhpcy5fc2l6ZSYmKGU9Mip0LGUhPT10aGlzLl9zaXplJiZ0aGlzLl9pdGVtcy5nZXQoZSsxKS5jb21wYXJlVG8odGhpcy5faXRlbXMuZ2V0KGUpKTwwJiZlKyssdGhpcy5faXRlbXMuZ2V0KGUpLmNvbXBhcmVUbyhuKTwwKTt0PWUpdGhpcy5faXRlbXMuc2V0KHQsdGhpcy5faXRlbXMuZ2V0KGUpKTt0aGlzLl9pdGVtcy5zZXQodCxuKX1jbGVhcigpe3RoaXMuX3NpemU9MCx0aGlzLl9pdGVtcy5jbGVhcigpfXBlZWsoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtyZXR1cm4gdGhpcy5faXRlbXMuZ2V0KDEpfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX3NpemV9YWRkKHQpe3RoaXMuX2l0ZW1zLmFkZChudWxsKSx0aGlzLl9zaXplKz0xO2xldCBlPXRoaXMuX3NpemU7Zm9yKHRoaXMuX2l0ZW1zLnNldCgwLHQpO3QuY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTwwO2UvPTIpdGhpcy5faXRlbXMuc2V0KGUsdGhpcy5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoZS8yKSkpO3RoaXMuX2l0ZW1zLnNldChlLHQpfX1jbGFzcyBUc3tjb25zdHJ1Y3Rvcigpe1RzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2NoaWxkQm91bmRhYmxlcz1uZXcgTCx0aGlzLl9ib3VuZHM9bnVsbCx0aGlzLl9sZXZlbD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sZXZlbD10fX1nZXRMZXZlbCgpe3JldHVybiB0aGlzLl9sZXZlbH1zaXplKCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5zaXplKCl9Z2V0Q2hpbGRCb3VuZGFibGVzKCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlc31hZGRDaGlsZEJvdW5kYWJsZSh0KXtnLmlzVHJ1ZShudWxsPT09dGhpcy5fYm91bmRzKSx0aGlzLl9jaGlsZEJvdW5kYWJsZXMuYWRkKHQpfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKX1nZXRCb3VuZHMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2JvdW5kcyYmKHRoaXMuX2JvdW5kcz10aGlzLmNvbXB1dGVCb3VuZHMoKSksdGhpcy5fYm91bmRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDcyxjXX19Y2xhc3MgUnN7c3RhdGljIG1heERpc3RhbmNlKHQsZSxuLHMsaSxyLG8sbCl7bGV0IGE9UnMuZGlzdGFuY2UodCxlLGkscik7cmV0dXJuIGE9TWF0aC5tYXgoYSxScy5kaXN0YW5jZSh0LGUsbyxsKSksYT1NYXRoLm1heChhLFJzLmRpc3RhbmNlKG4scyxpLHIpKSxhPU1hdGgubWF4KGEsUnMuZGlzdGFuY2UobixzLG8sbCkpLGF9c3RhdGljIGRpc3RhbmNlKHQsZSxuLHMpe2NvbnN0IGk9bi10LHI9cy1lO3JldHVybiBNYXRoLnNxcnQoaSppK3Iqcil9c3RhdGljIG1heGltdW1EaXN0YW5jZSh0LGUpe2NvbnN0IG49TWF0aC5taW4odC5nZXRNaW5YKCksZS5nZXRNaW5YKCkpLHM9TWF0aC5taW4odC5nZXRNaW5ZKCksZS5nZXRNaW5ZKCkpLGk9TWF0aC5tYXgodC5nZXRNYXhYKCksZS5nZXRNYXhYKCkpLHI9TWF0aC5tYXgodC5nZXRNYXhZKCksZS5nZXRNYXhZKCkpO3JldHVybiBScy5kaXN0YW5jZShuLHMsaSxyKX1zdGF0aWMgbWluTWF4RGlzdGFuY2UodCxlKXtjb25zdCBuPXQuZ2V0TWluWCgpLHM9dC5nZXRNaW5ZKCksaT10LmdldE1heFgoKSxyPXQuZ2V0TWF4WSgpLG89ZS5nZXRNaW5YKCksbD1lLmdldE1pblkoKSxhPWUuZ2V0TWF4WCgpLGM9ZS5nZXRNYXhZKCk7bGV0IGg9UnMubWF4RGlzdGFuY2UobixzLG4scixvLGwsbyxjKTtyZXR1cm4gaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKG4scyxuLHIsbyxsLGEsbCkpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShuLHMsbixyLGEsYyxvLGMpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UobixzLG4scixhLGMsYSxsKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKG4scyxpLHMsbyxsLG8sYykpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShuLHMsaSxzLG8sbCxhLGwpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UobixzLGkscyxhLGMsbyxjKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKG4scyxpLHMsYSxjLGEsbCkpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsbixyLG8sbCxvLGMpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLG4scixvLGwsYSxsKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixuLHIsYSxjLG8sYykpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsbixyLGEsYyxhLGwpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLGkscyxvLGwsbyxjKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixpLHMsbyxsLGEsbCkpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsaSxzLGEsYyxvLGMpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLGkscyxhLGMsYSxsKSksaH19Y2xhc3MgUHN7Y29uc3RydWN0b3IoKXtQcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ib3VuZGFibGUxPW51bGwsdGhpcy5fYm91bmRhYmxlMj1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5faXRlbURpc3RhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fYm91bmRhYmxlMT10LHRoaXMuX2JvdW5kYWJsZTI9ZSx0aGlzLl9pdGVtRGlzdGFuY2U9bix0aGlzLl9kaXN0YW5jZT10aGlzLmRpc3RhbmNlKCl9c3RhdGljIGFyZWEodCl7cmV0dXJuIHQuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpfXN0YXRpYyBpc0NvbXBvc2l0ZSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFRzfW1heGltdW1EaXN0YW5jZSgpe3JldHVybiBScy5tYXhpbXVtRGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMS5nZXRCb3VuZHMoKSx0aGlzLl9ib3VuZGFibGUyLmdldEJvdW5kcygpKX1leHBhbmRUb1F1ZXVlKHQsZSl7Y29uc3Qgbj1Qcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKSxpPVBzLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpO2lmKG4mJmkpcmV0dXJuIFBzLmFyZWEodGhpcy5fYm91bmRhYmxlMSk+UHMuYXJlYSh0aGlzLl9ib3VuZGFibGUyKT8odGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyLCExLHQsZSksbnVsbCk6KHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsdGhpcy5fYm91bmRhYmxlMSwhMCx0LGUpLG51bGwpO2lmKG4pcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMiwhMSx0LGUpLG51bGw7aWYoaSlyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMix0aGlzLl9ib3VuZGFibGUxLCEwLHQsZSksbnVsbDt0aHJvdyBuZXcgcyhcIm5laXRoZXIgYm91bmRhYmxlIGlzIGNvbXBvc2l0ZVwiKX1pc0xlYXZlcygpe3JldHVybiEoUHMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSl8fFBzLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9kaXN0YW5jZTxlLl9kaXN0YW5jZT8tMTp0aGlzLl9kaXN0YW5jZT5lLl9kaXN0YW5jZT8xOjB9ZXhwYW5kKHQsZSxuLHMsaSl7Zm9yKGxldCByPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe2NvbnN0IHQ9ci5uZXh0KCk7bGV0IG89bnVsbDtvPW4/bmV3IFBzKGUsdCx0aGlzLl9pdGVtRGlzdGFuY2UpOm5ldyBQcyh0LGUsdGhpcy5faXRlbURpc3RhbmNlKSxvLmdldERpc3RhbmNlKCk8aSYmcy5hZGQobyl9fWdldEJvdW5kYWJsZSh0KXtyZXR1cm4gMD09PXQ/dGhpcy5fYm91bmRhYmxlMTp0aGlzLl9ib3VuZGFibGUyfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuaXNMZWF2ZXMoKT90aGlzLl9pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyKTp0aGlzLl9ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgT3N7Y29uc3RydWN0b3IoKXtPcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9yb290PW51bGwsdGhpcy5fYnVpbHQ9ITEsdGhpcy5faXRlbUJvdW5kYWJsZXM9bmV3IEwsdGhpcy5fbm9kZUNhcGFjaXR5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpT3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyxPcy5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2cuaXNUcnVlKHQ+MSxcIk5vZGUgY2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSx0aGlzLl9ub2RlQ2FwYWNpdHk9dH19c3RhdGljIGNvbXBhcmVEb3VibGVzKHQsZSl7cmV0dXJuIHQ+ZT8xOnQ8ZT8tMTowfXF1ZXJ5SW50ZXJuYWwoKXtpZihJKGFyZ3VtZW50c1syXSxEZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFRzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1sxXS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtmb3IobGV0IHM9MDtzPG4uc2l6ZSgpO3MrKyl7Y29uc3QgaT1uLmdldChzKTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoaS5nZXRCb3VuZHMoKSx0KSYmKGkgaW5zdGFuY2VvZiBUcz90aGlzLnF1ZXJ5SW50ZXJuYWwodCxpLGUpOmkgaW5zdGFuY2VvZiBTcz9lLnZpc2l0SXRlbShpLmdldEl0ZW0oKSk6Zy5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19ZWxzZSBpZihJKGFyZ3VtZW50c1syXSxDKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzFdLmdldENoaWxkQm91bmRhYmxlcygpO2ZvcihsZXQgcz0wO3M8bi5zaXplKCk7cysrKXtjb25zdCBpPW4uZ2V0KHMpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhpLmdldEJvdW5kcygpLHQpJiYoaSBpbnN0YW5jZW9mIFRzP3RoaXMucXVlcnlJbnRlcm5hbCh0LGksZSk6aSBpbnN0YW5jZW9mIFNzP2UuYWRkKGkuZ2V0SXRlbSgpKTpnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCkpfX19Z2V0Tm9kZUNhcGFjaXR5KCl7cmV0dXJuIHRoaXMuX25vZGVDYXBhY2l0eX1sYXN0Tm9kZSh0KXtyZXR1cm4gdC5nZXQodC5zaXplKCktMSl9c2l6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5zaXplKHRoaXMuX3Jvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9YXJndW1lbnRzWzBdLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24gaW5zdGFuY2VvZiBUcz90Kz10aGlzLnNpemUobik6biBpbnN0YW5jZW9mIFNzJiYodCs9MSl9cmV0dXJuIHR9fXJlbW92ZUl0ZW0odCxlKXtsZXQgbj1udWxsO2ZvcihsZXQgcz10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QgaW5zdGFuY2VvZiBTcyYmdC5nZXRJdGVtKCk9PT1lJiYobj10KX1yZXR1cm4gbnVsbCE9PW4mJih0LmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShuKSwhMCl9aXRlbXNUcmVlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMuYnVpbGQoKTtjb25zdCB0PXRoaXMuaXRlbXNUcmVlKHRoaXMuX3Jvb3QpO3JldHVybiBudWxsPT09dD9uZXcgTDp0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO2ZvcihsZXQgbj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQgaW5zdGFuY2VvZiBUcyl7Y29uc3Qgbj10aGlzLml0ZW1zVHJlZSh0KTtudWxsIT09biYmZS5hZGQobil9ZWxzZSB0IGluc3RhbmNlb2YgU3M/ZS5hZGQodC5nZXRJdGVtKCkpOmcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gZS5zaXplKCk8PTA/bnVsbDplfX1pbnNlcnQodCxlKXtnLmlzVHJ1ZSghdGhpcy5fYnVpbHQsXCJDYW5ub3QgaW5zZXJ0IGl0ZW1zIGludG8gYW4gU1RSIHBhY2tlZCBSLXRyZWUgYWZ0ZXIgaXQgaGFzIGJlZW4gYnVpbHQuXCIpLHRoaXMuX2l0ZW1Cb3VuZGFibGVzLmFkZChuZXcgU3ModCxlKSl9Ym91bmRhYmxlc0F0TGV2ZWwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtyZXR1cm4gdGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LHRoaXMuX3Jvb3QsZSksZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZy5pc1RydWUodD4tMiksZS5nZXRMZXZlbCgpPT09dClyZXR1cm4gbi5hZGQoZSksbnVsbDtmb3IobGV0IHM9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgZT1zLm5leHQoKTtlIGluc3RhbmNlb2YgVHM/dGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LGUsbik6KGcuaXNUcnVlKGUgaW5zdGFuY2VvZiBTcyksLTE9PT10JiZuLmFkZChlKSl9cmV0dXJuIG51bGx9fXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVpbGQoKTtjb25zdCBlPW5ldyBMO3JldHVybiB0aGlzLmlzRW1wdHkoKXx8dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnlJbnRlcm5hbCh0LHRoaXMuX3Jvb3QsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5idWlsZCgpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnF1ZXJ5SW50ZXJuYWwodCx0aGlzLl9yb290LGUpfX1idWlsZCgpe2lmKHRoaXMuX2J1aWx0KXJldHVybiBudWxsO3RoaXMuX3Jvb3Q9dGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpP3RoaXMuY3JlYXRlTm9kZSgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyh0aGlzLl9pdGVtQm91bmRhYmxlcywtMSksdGhpcy5faXRlbUJvdW5kYWJsZXM9bnVsbCx0aGlzLl9idWlsdD0hMH1nZXRSb290KCl7cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLl9yb290fXJlbW92ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5idWlsZCgpLCEhdGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucmVtb3ZlKHQsdGhpcy5fcm9vdCxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bGV0IHM9dGhpcy5yZW1vdmVJdGVtKGUsbik7aWYocylyZXR1cm4hMDtsZXQgaT1udWxsO2ZvcihsZXQgcj1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXtjb25zdCBlPXIubmV4dCgpO2lmKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhlLmdldEJvdW5kcygpLHQpJiYoZSBpbnN0YW5jZW9mIFRzJiYocz10aGlzLnJlbW92ZSh0LGUsbikscykpKXtpPWU7YnJlYWt9fXJldHVybiBudWxsIT09aSYmaS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pc0VtcHR5KCkmJmUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKGkpLHN9fWNyZWF0ZUhpZ2hlckxldmVscyh0LGUpe2cuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj10aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKzEpO3JldHVybiAxPT09bi5zaXplKCk/bi5nZXQoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHMobixlKzEpfWRlcHRoKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLmRlcHRoKHRoaXMuX3Jvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9YXJndW1lbnRzWzBdLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4gaW5zdGFuY2VvZiBUcyl7Y29uc3QgZT10aGlzLmRlcHRoKG4pO2U+dCYmKHQ9ZSl9fXJldHVybiB0KzF9fWNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKXtnLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49bmV3IEw7bi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKTtjb25zdCBzPW5ldyBMKHQpO3hlLnNvcnQocyx0aGlzLmdldENvbXBhcmF0b3IoKSk7Zm9yKGxldCB0PXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IHM9dC5uZXh0KCk7dGhpcy5sYXN0Tm9kZShuKS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5zaXplKCk9PT10aGlzLmdldE5vZGVDYXBhY2l0eSgpJiZuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpLHRoaXMubGFzdE5vZGUobikuYWRkQ2hpbGRCb3VuZGFibGUocyl9cmV0dXJuIG59aXNFbXB0eSgpe3JldHVybiB0aGlzLl9idWlsdD90aGlzLl9yb290LmlzRW1wdHkoKTp0aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NdfX1Pcy5JbnRlcnNlY3RzT3A9ZnVuY3Rpb24oKXt9LE9zLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMDtjbGFzcyB2c3tkaXN0YW5jZSh0LGUpe319Y2xhc3MgYnMgZXh0ZW5kcyBPc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksYnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpYnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyxicy5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO09zLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fXN0YXRpYyBjZW50cmVYKHQpe3JldHVybiBicy5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfXN0YXRpYyBnZXRJdGVtcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtsZXQgbj0wO2Zvcig7IXQuaXNFbXB0eSgpOyl7Y29uc3Qgcz10LnBvbGwoKTtlW25dPXMuZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSxuKyt9cmV0dXJuIGV9c3RhdGljIGNlbnRyZVkodCl7cmV0dXJuIGJzLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSl9Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyh0LGUpe2cuaXNUcnVlKHQubGVuZ3RoPjApO2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspbi5hZGRBbGwodGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodFtzXSxlKSk7cmV0dXJuIG59bmVhcmVzdE5laWdoYm91cksoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cksodCxyLlBPU0lUSVZFX0lORklOSVRZLGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXTtsZXQgbj1hcmd1bWVudHNbMV07Y29uc3Qgcz1uZXcgTHM7cy5hZGQodCk7Y29uc3QgaT1uZXcgTHM7Zm9yKDshcy5pc0VtcHR5KCkmJm4+PTA7KXtjb25zdCB0PXMucG9sbCgpLHI9dC5nZXREaXN0YW5jZSgpO2lmKHI+PW4pYnJlYWs7aWYodC5pc0xlYXZlcygpKWlmKGkuc2l6ZSgpPGUpaS5hZGQodCk7ZWxzZXtpLnBlZWsoKS5nZXREaXN0YW5jZSgpPnImJihpLnBvbGwoKSxpLmFkZCh0KSk7bj1pLnBlZWsoKS5nZXREaXN0YW5jZSgpfWVsc2UgdC5leHBhbmRUb1F1ZXVlKHMsbil9cmV0dXJuIGJzLmdldEl0ZW1zKGkpfX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgTXModCl9c2l6ZSgpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9zdXBlci5zaXplLmNhbGwodGhpcyk6c3VwZXIuc2l6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0KCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTykpcmV0dXJuIHN1cGVyLmluc2VydC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQuaXNOdWxsKCkpcmV0dXJuIG51bGw7c3VwZXIuaW5zZXJ0LmNhbGwodGhpcyx0LGUpfX1nZXRJbnRlcnNlY3RzT3AoKXtyZXR1cm4gYnMuaW50ZXJzZWN0c09wfXZlcnRpY2FsU2xpY2VzKHQsZSl7Y29uc3Qgbj1NYXRoLnRydW5jKE1hdGguY2VpbCh0LnNpemUoKS9lKSkscz1uZXcgQXJyYXkoZSkuZmlsbChudWxsKSxpPXQuaXRlcmF0b3IoKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXtzW3RdPW5ldyBMO2xldCBlPTA7Zm9yKDtpLmhhc05leHQoKSYmZTxuOyl7Y29uc3Qgbj1pLm5leHQoKTtzW3RdLmFkZChuKSxlKyt9fXJldHVybiBzfXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBzdXBlci5xdWVyeS5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3N1cGVyLnF1ZXJ5LmNhbGwodGhpcyx0LGUpfX1nZXRDb21wYXJhdG9yKCl7cmV0dXJuIGJzLnlDb21wYXJhdG9yfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSh0LGUpe3JldHVybiBzdXBlci5jcmVhdGVQYXJlbnRCb3VuZGFibGVzLmNhbGwodGhpcyx0LGUpfXJlbW92ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gc3VwZXIucmVtb3ZlLmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5yZW1vdmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWRlcHRoKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP3N1cGVyLmRlcHRoLmNhbGwodGhpcyk6c3VwZXIuZGVwdGguYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKXtnLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvdGhpcy5nZXROb2RlQ2FwYWNpdHkoKSkpLHM9bmV3IEwodCk7eGUuc29ydChzLGJzLnhDb21wYXJhdG9yKTtjb25zdCBpPXRoaXMudmVydGljYWxTbGljZXMocyxNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLnNxcnQobikpKSk7cmV0dXJuIHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyhpLGUpfW5lYXJlc3ROZWlnaGJvdXIoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sdnMpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBQcyh0aGlzLmdldFJvb3QoKSx0aGlzLmdldFJvb3QoKSx0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUHMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPXIuUE9TSVRJVkVfSU5GSU5JVFksbj1udWxsO2NvbnN0IHM9bmV3IExzO2ZvcihzLmFkZCh0KTshcy5pc0VtcHR5KCkmJmU+MDspe2NvbnN0IHQ9cy5wb2xsKCksaT10LmdldERpc3RhbmNlKCk7aWYoaT49ZSlicmVhazt0LmlzTGVhdmVzKCk/KGU9aSxuPXQpOnQuZXhwYW5kVG9RdWV1ZShzLGUpfXJldHVybiBudWxsPT09bj9udWxsOltuLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbi5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXX19ZWxzZXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5pc0VtcHR5KCl8fHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49bmV3IFBzKHRoaXMuZ2V0Um9vdCgpLHQuZ2V0Um9vdCgpLGUpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIobil9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzJdLGU9bmV3IFNzKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLG49bmV3IFBzKHRoaXMuZ2V0Um9vdCgpLGUsdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuKVswXX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMl0sZT1hcmd1bWVudHNbM10sbj1uZXcgU3MoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkscz1uZXcgUHModGhpcy5nZXRSb290KCksbix0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VySyhzLGUpfX19aXNXaXRoaW5EaXN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1yLlBPU0lUSVZFX0lORklOSVRZO2NvbnN0IHM9bmV3IExzO2ZvcihzLmFkZCh0KTshcy5pc0VtcHR5KCk7KXtjb25zdCB0PXMucG9sbCgpLGk9dC5nZXREaXN0YW5jZSgpO2lmKGk+ZSlyZXR1cm4hMTtpZih0Lm1heGltdW1EaXN0YW5jZSgpPD1lKXJldHVybiEwO2lmKHQuaXNMZWF2ZXMoKSl7aWYobj1pLG48PWUpcmV0dXJuITB9ZWxzZSB0LmV4cGFuZFRvUXVldWUocyxuKX1yZXR1cm4hMX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgUHModGhpcy5nZXRSb290KCksdC5nZXRSb290KCksZSk7cmV0dXJuIHRoaXMuaXNXaXRoaW5EaXN0YW5jZShzLG4pfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSXMsY119fWNsYXNzIE1zIGV4dGVuZHMgVHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLE1zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1RzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9Y29tcHV0ZUJvdW5kcygpe2xldCB0PW51bGw7Zm9yKGxldCBlPXRoaXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bnVsbD09PXQ/dD1uZXcgTyhuLmdldEJvdW5kcygpKTp0LmV4cGFuZFRvSW5jbHVkZShuLmdldEJvdW5kcygpKX1yZXR1cm4gdH19YnMuU1RSdHJlZU5vZGU9TXMsYnMueENvbXBhcmF0b3I9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX1jb21wYXJlKHQsZSl7cmV0dXJuIE9zLmNvbXBhcmVEb3VibGVzKGJzLmNlbnRyZVgodC5nZXRCb3VuZHMoKSksYnMuY2VudHJlWChlLmdldEJvdW5kcygpKSl9fSxicy55Q29tcGFyYXRvcj1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfWNvbXBhcmUodCxlKXtyZXR1cm4gT3MuY29tcGFyZURvdWJsZXMoYnMuY2VudHJlWSh0LmdldEJvdW5kcygpKSxicy5jZW50cmVZKGUuZ2V0Qm91bmRzKCkpKX19LGJzLmludGVyc2VjdHNPcD1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ludGVyc2VjdHNPcF19aW50ZXJzZWN0cyh0LGUpe3JldHVybiB0LmludGVyc2VjdHMoZSl9fSxicy5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTA7dmFyIERzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFNUUnRyZWU6YnN9KSxBcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxrZHRyZWU6X3MscXVhZHRyZWU6d3Msc3RydHJlZTpEc30pO2NvbnN0IEZzPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtjbGFzcyBHc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgTHR9cmVhZCh0KXtsZXQgZTtlPVwic3RyaW5nXCI9PXR5cGVvZiB0P0pTT04ucGFyc2UodCk6dDtjb25zdCBuPWUudHlwZTtpZighcXNbbl0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK2UudHlwZSk7cmV0dXJuLTEhPT1Gcy5pbmRleE9mKG4pP3FzW25dLmNhbGwodGhpcyxlLmNvb3JkaW5hdGVzKTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09bj9xc1tuXS5jYWxsKHRoaXMsZS5nZW9tZXRyaWVzKTpxc1tuXS5jYWxsKHRoaXMsZSl9d3JpdGUodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5VHlwZSgpO2lmKCFCc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJHZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBCc1tlXS5jYWxsKHRoaXMsdCl9fWNvbnN0IHFzPXtGZWF0dXJlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9e307Zm9yKGNvbnN0IG4gaW4gdCllW25dPXRbbl07aWYodC5nZW9tZXRyeSl7Y29uc3Qgbj10Lmdlb21ldHJ5LnR5cGU7aWYoIXFzW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIit0LnR5cGUpO2UuZ2VvbWV0cnk9dGhpcy5yZWFkKHQuZ2VvbWV0cnkpfXJldHVybiB0LmJib3gmJihlLmJib3g9cXMuYmJveC5jYWxsKHRoaXMsdC5iYm94KSksZX0sRmVhdHVyZUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT17fTtpZih0LmZlYXR1cmVzKXtlLmZlYXR1cmVzPVtdO2ZvcihsZXQgbj0wO248dC5mZWF0dXJlcy5sZW5ndGg7KytuKWUuZmVhdHVyZXMucHVzaCh0aGlzLnJlYWQodC5mZWF0dXJlc1tuXSkpfXJldHVybiB0LmJib3gmJihlLmJib3g9dGhpcy5wYXJzZS5iYm94LmNhbGwodGhpcyx0LmJib3gpKSxlfSxjb29yZGluYXRlczpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKG5ldyBtKC4uLnMpKX1yZXR1cm4gZX0sYmJveDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhbbmV3IG0odFswXSx0WzFdKSxuZXcgbSh0WzJdLHRbMV0pLG5ldyBtKHRbMl0sdFszXSksbmV3IG0odFswXSx0WzNdKSxuZXcgbSh0WzBdLHRbMV0pXSl9LFBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IG0oLi4udCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpfSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKHFzLlBvaW50LmNhbGwodGhpcyx0W25dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1xcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsdCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZSl9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChxcy5MaW5lU3RyaW5nLmNhbGwodGhpcyx0W25dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPXFzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyx0WzBdKSxuPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoZSkscz1bXTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoOysrZSl7Y29uc3Qgbj10W2VdLGk9cXMuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLG4pLHI9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhpKTtzLnB1c2gocil9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixzKX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2gocXMuUG9seWdvbi5jYWxsKHRoaXMscykpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKHRoaXMucmVhZChzKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX19LEJzPXtjb29yZGluYXRlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W3QueCx0LnldO3JldHVybiB0LnomJmUucHVzaCh0LnopLHQubSYmZS5wdXNoKHQubSksZX0sUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJue3R5cGU6XCJQb2ludFwiLGNvb3JkaW5hdGVzOkJzLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZSgpKX19LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9QnMuUG9pbnQuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9pbnRcIixjb29yZGluYXRlczplfX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdLG49dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7Kyt0KXtjb25zdCBzPW5bdF07ZS5wdXNoKEJzLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHMpKX1yZXR1cm57dHlwZTpcIkxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPUJzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W10sbj1Ccy5MaW5lU3RyaW5nLmNhbGwodGhpcyx0Ll9zaGVsbCk7ZS5wdXNoKG4uY29vcmRpbmF0ZXMpO2ZvcihsZXQgbj0wO248dC5faG9sZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9ob2xlc1tuXSxpPUJzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIlBvbHlnb25cIixjb29yZGluYXRlczplfX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPUJzLlBvbHlnb24uY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9cy5nZXRHZW9tZXRyeVR5cGUoKTtlLnB1c2goQnNbaV0uY2FsbCh0aGlzLHMpKX1yZXR1cm57dHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLGdlb21ldHJpZXM6ZX19fTtmdW5jdGlvbiBZcyh0KXtyZXR1cm5bdC54LHQueV19dmFyIFZzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb0pTT05SZWFkZXI6Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEdzKHR8fG5ldyBMdCl9cmVhZCh0KXtyZXR1cm4gdGhpcy5wYXJzZXIucmVhZCh0KX19LEdlb0pTT05Xcml0ZXI6Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnBhcnNlcj1uZXcgR3ModGhpcy5nZW9tZXRyeUZhY3RvcnkpfXdyaXRlKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19LE9MM1BhcnNlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBMdCx0aGlzLm9sPWV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBvbCYmb2x9aW5qZWN0KHQsZSxuLHMsaSxyLG8sbCl7dGhpcy5vbD17Z2VvbTp7UG9pbnQ6dCxMaW5lU3RyaW5nOmUsTGluZWFyUmluZzpuLFBvbHlnb246cyxNdWx0aVBvaW50OmksTXVsdGlMaW5lU3RyaW5nOnIsTXVsdGlQb2x5Z29uOm8sR2VvbWV0cnlDb2xsZWN0aW9uOmx9fX1yZWFkKHQpe2NvbnN0IGU9dGhpcy5vbDtyZXR1cm4gdCBpbnN0YW5jZW9mIGUuZ2VvbS5Qb2ludD90aGlzLmNvbnZlcnRGcm9tUG9pbnQodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5MaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTGluZWFyUmluZz90aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLlBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aVBvaW50P3RoaXMuY29udmVydEZyb21NdWx0aVBvaW50KHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlMaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aVBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbj90aGlzLmNvbnZlcnRGcm9tQ29sbGVjdGlvbih0KTp2b2lkIDB9Y29udmVydEZyb21Qb2ludCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IG0oZVswXSxlWzFdKSl9Y29udmVydEZyb21MaW5lU3RyaW5nKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbSh0WzBdLHRbMV0pfSkpKX1jb252ZXJ0RnJvbUxpbmVhclJpbmcodCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBtKHRbMF0sdFsxXSl9KSkpfWNvbnZlcnRGcm9tUG9seWdvbih0KXtjb25zdCBlPXQuZ2V0TGluZWFyUmluZ3MoKTtsZXQgbj1udWxsO2NvbnN0IHM9W107Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IGk9dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcoZVt0XSk7MD09PXQ/bj1pOnMucHVzaChpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLHMpfWNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KXtjb25zdCBlPXQuZ2V0UG9pbnRzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9Y29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCl7Y29uc3QgZT10LmdldExpbmVTdHJpbmdzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfWNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpe2NvbnN0IGU9dC5nZXRQb2x5Z29ucygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX1jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCl7Y29uc3QgZT10LmdldEdlb21ldHJpZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWQodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfXdyaXRlKHQpe3JldHVyblwiUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2ludCh0LmdldENvb3JkaW5hdGUoKSk6XCJMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZVN0cmluZyh0KTpcIkxpbmVhclJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lYXJSaW5nKHQpOlwiUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvbHlnb24odCk6XCJNdWx0aVBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2ludCh0KTpcIk11bHRpTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KTpcIk11bHRpUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9seWdvbih0KTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0NvbGxlY3Rpb24odCk6dm9pZCAwfWNvbnZlcnRUb1BvaW50KHQpe3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLlBvaW50KFt0LngsdC55XSl9Y29udmVydFRvTGluZVN0cmluZyh0KXtjb25zdCBlPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFlzKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5MaW5lU3RyaW5nKGUpfWNvbnZlcnRUb0xpbmVhclJpbmcodCl7Y29uc3QgZT10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChZcyk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTGluZWFyUmluZyhlKX1jb252ZXJ0VG9Qb2x5Z29uKHQpe2NvbnN0IGU9W3QuX3NoZWxsLl9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChZcyldO2ZvcihsZXQgbj0wO248dC5faG9sZXMubGVuZ3RoO24rKyllLnB1c2godC5faG9sZXNbbl0uX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFlzKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uUG9seWdvbihlKX1jb252ZXJ0VG9NdWx0aVBvaW50KHQpe3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9pbnQodC5nZXRDb29yZGluYXRlcygpLm1hcChZcykpfWNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodC5fZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlMaW5lU3RyaW5nKGUpfWNvbnZlcnRUb011bHRpUG9seWdvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb1BvbHlnb24odC5fZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlQb2x5Z29uKGUpfWNvbnZlcnRUb0NvbGxlY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dO2UucHVzaCh0aGlzLndyaXRlKHMpKX1yZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSxXS1RSZWFkZXI6Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEh0KHR8fG5ldyBMdCl9cmVhZCh0KXtyZXR1cm4gdGhpcy5wYXJzZXIucmVhZCh0KX19LFdLVFdyaXRlcjpXdH0pO2NsYXNzIHpze3N0YXRpYyByZWxhdGl2ZVNpZ24odCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9c3RhdGljIGNvbXBhcmUodCxlLG4pe2lmKGUuZXF1YWxzMkQobikpcmV0dXJuIDA7Y29uc3Qgcz16cy5yZWxhdGl2ZVNpZ24oZS54LG4ueCksaT16cy5yZWxhdGl2ZVNpZ24oZS55LG4ueSk7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4genMuY29tcGFyZVZhbHVlKHMsaSk7Y2FzZSAxOnJldHVybiB6cy5jb21wYXJlVmFsdWUoaSxzKTtjYXNlIDI6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZShpLC1zKTtjYXNlIDM6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZSgtcyxpKTtjYXNlIDQ6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZSgtcywtaSk7Y2FzZSA1OnJldHVybiB6cy5jb21wYXJlVmFsdWUoLWksLXMpO2Nhc2UgNjpyZXR1cm4genMuY29tcGFyZVZhbHVlKC1pLHMpO2Nhc2UgNzpyZXR1cm4genMuY29tcGFyZVZhbHVlKHMsLWkpfXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiaW52YWxpZCBvY3RhbnQgdmFsdWVcIiksMH1zdGF0aWMgY29tcGFyZVZhbHVlKHQsZSl7cmV0dXJuIHQ8MD8tMTp0PjA/MTplPDA/LTE6ZT4wPzE6MH19Y2xhc3MgWHN7Y29uc3RydWN0b3IoKXtYcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zZWdTdHJpbmc9bnVsbCx0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLl9zZWdtZW50T2N0YW50PW51bGwsdGhpcy5faXNJbnRlcmlvcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX3NlZ1N0cmluZz10LHRoaXMuY29vcmQ9bmV3IG0oZSksdGhpcy5zZWdtZW50SW5kZXg9bix0aGlzLl9zZWdtZW50T2N0YW50PXMsdGhpcy5faXNJbnRlcmlvcj0hZS5lcXVhbHMyRCh0LmdldENvb3JkaW5hdGUobikpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb29yZH1wcmludCh0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8ZS5zZWdtZW50SW5kZXg/LTE6dGhpcy5zZWdtZW50SW5kZXg+ZS5zZWdtZW50SW5kZXg/MTp0aGlzLmNvb3JkLmVxdWFsczJEKGUuY29vcmQpPzA6dGhpcy5faXNJbnRlcmlvcj9lLl9pc0ludGVyaW9yP3pzLmNvbXBhcmUodGhpcy5fc2VnbWVudE9jdGFudCx0aGlzLmNvb3JkLGUuY29vcmQpOjE6LTF9aXNFbmRQb2ludCh0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYhdGhpcy5faXNJbnRlcmlvcnx8dGhpcy5zZWdtZW50SW5kZXg9PT10fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4K1wiOlwiK3RoaXMuY29vcmQudG9TdHJpbmcoKX1pc0ludGVyaW9yKCl7cmV0dXJuIHRoaXMuX2lzSW50ZXJpb3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBrc3tjb25zdHJ1Y3Rvcigpe2tzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVNYXA9bmV3IFduLHRoaXMuX2VkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlPXR9Z2V0U3BsaXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IFI7dGhpcy5hZGRFbmRwb2ludHMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKTt0aGlzLmFkZEVkZ2VDb29yZGluYXRlcyhuLHMsdCksbj1zfXJldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9YWRkQ29sbGFwc2VkTm9kZXMoKXtjb25zdCB0PW5ldyBMO3RoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpLHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmludFZhbHVlKCk7dGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfX1jcmVhdGVTcGxpdEVkZ2VQdHModCxlKXtsZXQgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyO2lmKDI9PT1uKXJldHVybltuZXcgbSh0LmNvb3JkKSxuZXcgbShlLmNvb3JkKV07Y29uc3Qgcz10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLGk9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBtKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKG4pO3JldHVybiBpJiYocltvXT1uZXcgbShlLmNvb3JkKSkscn1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2Uuc2l6ZSgpLTI7ZSsrKXtjb25zdCBuPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKTt0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsxKTtjb25zdCBzPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKzIpO24uZXF1YWxzMkQocykmJnQuYWRkKGIudmFsdWVPZihlKzEpKX19YWRkRWRnZUNvb3JkaW5hdGVzKHQsZSxuKXtjb25zdCBzPXRoaXMuY3JlYXRlU3BsaXRFZGdlUHRzKHQsZSk7bi5hZGQocywhMSl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfWFkZFNwbGl0RWRnZXModCl7dGhpcy5hZGRFbmRwb2ludHMoKSx0aGlzLmFkZENvbGxhcHNlZE5vZGVzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLHMpO3QuYWRkKGkpLG49c319ZmluZENvbGxhcHNlSW5kZXgodCxlLG4pe2lmKCF0LmNvb3JkLmVxdWFsczJEKGUuY29vcmQpKXJldHVybiExO2xldCBzPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4O3JldHVybiBlLmlzSW50ZXJpb3IoKXx8cy0tLDE9PT1zJiYoblswXT10LnNlZ21lbnRJbmRleCsxLCEwKX1maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXModCl7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuaXRlcmF0b3IoKTtsZXQgcz1uLm5leHQoKTtmb3IoO24uaGFzTmV4dCgpOyl7Y29uc3QgaT1uLm5leHQoKTt0aGlzLmZpbmRDb2xsYXBzZUluZGV4KHMsaSxlKSYmdC5hZGQoYi52YWx1ZU9mKGVbMF0pKSxzPWl9fWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1hZGRFbmRwb2ludHMoKXtjb25zdCB0PXRoaXMuX2VkZ2Uuc2l6ZSgpLTE7dGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKDApLDApLHRoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSh0KSx0KX1jcmVhdGVTcGxpdEVkZ2UodCxlKXtjb25zdCBuPXRoaXMuY3JlYXRlU3BsaXRFZGdlUHRzKHQsZSk7cmV0dXJuIG5ldyBacyhuLHRoaXMuX2VkZ2UuZ2V0RGF0YSgpKX1hZGQodCxlKXtjb25zdCBuPW5ldyBYcyh0aGlzLl9lZGdlLHQsZSx0aGlzLl9lZGdlLmdldFNlZ21lbnRPY3RhbnQoZSkpLHM9dGhpcy5fbm9kZU1hcC5nZXQobik7cmV0dXJuIG51bGwhPT1zPyhnLmlzVHJ1ZShzLmNvb3JkLmVxdWFsczJEKHQpLFwiRm91bmQgZXF1YWwgbm9kZXMgd2l0aCBkaWZmZXJlbnQgY29vcmRpbmF0ZXNcIikscyk6KHRoaXMuX25vZGVNYXAucHV0KG4sbiksbil9Y2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3ModCl7Y29uc3QgZT10aGlzLl9lZGdlLmdldENvb3JkaW5hdGVzKCksbj10LmdldCgwKS5nZXRDb29yZGluYXRlKDApO2lmKCFuLmVxdWFsczJEKGVbMF0pKXRocm93IG5ldyBoKFwiYmFkIHNwbGl0IGVkZ2Ugc3RhcnQgcG9pbnQgYXQgXCIrbik7Y29uc3Qgcz10LmdldCh0LnNpemUoKS0xKS5nZXRDb29yZGluYXRlcygpLGk9c1tzLmxlbmd0aC0xXTtpZighaS5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSl0aHJvdyBuZXcgaChcImJhZCBzcGxpdCBlZGdlIGVuZCBwb2ludCBhdCBcIitpKX19Y2xhc3MgVXN7c3RhdGljIG9jdGFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgcyhcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO2NvbnN0IG49TWF0aC5hYnModCksaT1NYXRoLmFicyhlKTtyZXR1cm4gdD49MD9lPj0wP24+PWk/MDoxOm4+PWk/Nzo2OmU+PTA/bj49aT8zOjI6bj49aT80OjV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxpPWUueS10Lnk7aWYoMD09PW4mJjA9PT1pKXRocm93IG5ldyBzKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrdCk7cmV0dXJuIFVzLm9jdGFudChuLGkpfX19Y2xhc3MgSHN7Z2V0Q29vcmRpbmF0ZXMoKXt9c2l6ZSgpe31nZXRDb29yZGluYXRlKHQpe31pc0Nsb3NlZCgpe31zZXREYXRhKHQpe31nZXREYXRhKCl7fX1jbGFzcyBXc3thZGRJbnRlcnNlY3Rpb24odCxlKXt9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hzXX19Y2xhc3MgWnN7Y29uc3RydWN0b3IoKXtacy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2RlTGlzdD1uZXcga3ModGhpcyksdGhpcy5fcHRzPW51bGwsdGhpcy5fZGF0YT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX2RhdGE9ZX1zdGF0aWMgZ2V0Tm9kZWRTdWJzdHJpbmdzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7cmV0dXJuIFpzLmdldE5vZGVkU3Vic3RyaW5ncyh0LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmdldE5vZGVMaXN0KCkuYWRkU3BsaXRFZGdlcyh0KX19fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0c31zaXplKCl7cmV0dXJuIHRoaXMuX3B0cy5sZW5ndGh9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzW3RdfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGgtMV0pfWdldFNlZ21lbnRPY3RhbnQodCl7cmV0dXJuIHQ9PT10aGlzLl9wdHMubGVuZ3RoLTE/LTE6dGhpcy5zYWZlT2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9c2FmZU9jdGFudCh0LGUpe3JldHVybiB0LmVxdWFsczJEKGUpPzA6VXMub2N0YW50KHQsZSl9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWFkZEludGVyc2VjdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmFkZEludGVyc2VjdGlvbk5vZGUodCxlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1szXSxuPW5ldyBtKGFyZ3VtZW50c1swXS5nZXRJbnRlcnNlY3Rpb24oZSkpO3RoaXMuYWRkSW50ZXJzZWN0aW9uKG4sdCl9fXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyhuZXcgbXQodGhpcy5fcHRzKSl9Z2V0Tm9kZUxpc3QoKXtyZXR1cm4gdGhpcy5fbm9kZUxpc3R9YWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpe2xldCBuPWU7Y29uc3Qgcz1uKzE7aWYoczx0aGlzLl9wdHMubGVuZ3RoKXtjb25zdCBlPXRoaXMuX3B0c1tzXTt0LmVxdWFsczJEKGUpJiYobj1zKX1yZXR1cm4gdGhpcy5fbm9kZUxpc3QuYWRkKHQsbil9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixzKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bV3NdfX1jbGFzcyBqc3tjb25zdHJ1Y3Rvcigpe2pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX292ZXJsYXBTZWcxPW5ldyBLdCx0aGlzLl9vdmVybGFwU2VnMj1uZXcgS3R9b3ZlcmxhcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXTthcmd1bWVudHNbMF0uZ2V0TGluZVNlZ21lbnQodCx0aGlzLl9vdmVybGFwU2VnMSksZS5nZXRMaW5lU2VnbWVudChuLHRoaXMuX292ZXJsYXBTZWcyKSx0aGlzLm92ZXJsYXAodGhpcy5fb3ZlcmxhcFNlZzEsdGhpcy5fb3ZlcmxhcFNlZzIpfX19Y2xhc3MgS3N7Y29uc3RydWN0b3IoKXtLcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9zdGFydD1udWxsLHRoaXMuX2VuZD1udWxsLHRoaXMuX2Vudj1udWxsLHRoaXMuX2NvbnRleHQ9bnVsbCx0aGlzLl9pZD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX3B0cz10LHRoaXMuX3N0YXJ0PWUsdGhpcy5fZW5kPW4sdGhpcy5fY29udGV4dD1zfWdldExpbmVTZWdtZW50KHQsZSl7ZS5wMD10aGlzLl9wdHNbdF0sZS5wMT10aGlzLl9wdHNbdCsxXX1jb21wdXRlU2VsZWN0KHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5fcHRzW2VdLHI9dGhpcy5fcHRzW25dO2lmKG4tZT09MSlyZXR1cm4gcy5zZWxlY3QodGhpcyxlKSxudWxsO2lmKCF0LmludGVyc2VjdHMoaSxyKSlyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGgudHJ1bmMoKGUrbikvMik7ZTxvJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxlLG8scyksbzxuJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxvLG4scyl9Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9lbmQtdGhpcy5fc3RhcnQrMSkuZmlsbChudWxsKTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLl9zdGFydDtuPD10aGlzLl9lbmQ7bisrKXRbZSsrXT10aGlzLl9wdHNbbl07cmV0dXJuIHR9Y29tcHV0ZU92ZXJsYXBzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuY29tcHV0ZU92ZXJsYXBzKHRoaXMuX3N0YXJ0LHRoaXMuX2VuZCx0LHQuX3N0YXJ0LHQuX2VuZCxlKX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtpZihlLXQ9PTEmJmktcz09MSlyZXR1cm4gci5vdmVybGFwKHRoaXMsdCxuLHMpLG51bGw7aWYoIXRoaXMub3ZlcmxhcHModCxlLG4scyxpKSlyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGgudHJ1bmMoKHQrZSkvMiksbD1NYXRoLnRydW5jKChzK2kpLzIpO3Q8byYmKHM8bCYmdGhpcy5jb21wdXRlT3ZlcmxhcHModCxvLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHModCxvLG4sbCxpLHIpKSxvPGUmJihzPGwmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKG8sZSxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKG8sZSxuLGwsaSxyKSl9fXNldElkKHQpe3RoaXMuX2lkPXR9c2VsZWN0KHQsZSl7dGhpcy5jb21wdXRlU2VsZWN0KHQsdGhpcy5fc3RhcnQsdGhpcy5fZW5kLGUpfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7Y29uc3QgdD10aGlzLl9wdHNbdGhpcy5fc3RhcnRdLGU9dGhpcy5fcHRzW3RoaXMuX2VuZF07dGhpcy5fZW52PW5ldyBPKHQsZSl9cmV0dXJuIHRoaXMuX2Vudn1vdmVybGFwcyh0LGUsbixzLGkpe3JldHVybiBPLmludGVyc2VjdHModGhpcy5fcHRzW3RdLHRoaXMuX3B0c1tlXSxuLl9wdHNbc10sbi5fcHRzW2ldKX1nZXRFbmRJbmRleCgpe3JldHVybiB0aGlzLl9lbmR9Z2V0U3RhcnRJbmRleCgpe3JldHVybiB0aGlzLl9zdGFydH1nZXRDb250ZXh0KCl7cmV0dXJuIHRoaXMuX2NvbnRleHR9Z2V0SWQoKXtyZXR1cm4gdGhpcy5faWR9fWNsYXNzIFFze3N0YXRpYyBmaW5kQ2hhaW5FbmQodCxlKXtsZXQgbj1lO2Zvcig7bjx0Lmxlbmd0aC0xJiZ0W25dLmVxdWFsczJEKHRbbisxXSk7KW4rKztpZihuPj10Lmxlbmd0aC0xKXJldHVybiB0Lmxlbmd0aC0xO2NvbnN0IHM9Q24ucXVhZHJhbnQodFtuXSx0W24rMV0pO2xldCBpPWUrMTtmb3IoO2k8dC5sZW5ndGg7KXtpZighdFtpLTFdLmVxdWFsczJEKHRbaV0pKXtpZihDbi5xdWFkcmFudCh0W2ktMV0sdFtpXSkhPT1zKWJyZWFrfWkrK31yZXR1cm4gaS0xfXN0YXRpYyBnZXRDaGFpbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFFzLmdldENoYWlucyh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO2xldCBzPTA7ZG97Y29uc3QgaT1Rcy5maW5kQ2hhaW5FbmQodCxzKSxyPW5ldyBLcyh0LHMsaSxlKTtuLmFkZChyKSxzPWl9d2hpbGUoczx0Lmxlbmd0aC0xKTtyZXR1cm4gbn19fWNsYXNzIEpze2NvbXB1dGVOb2Rlcyh0KXt9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7fX1jbGFzcyAkc3tjb25zdHJ1Y3RvcigpeyRzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3NlZ0ludD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KX19c2V0U2VnbWVudEludGVyc2VjdG9yKHQpe3RoaXMuX3NlZ0ludD10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKc119fWNsYXNzIHRpIGV4dGVuZHMgJHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX21vbm9DaGFpbnM9bmV3IEwsdGhpcy5faW5kZXg9bmV3IGJzLHRoaXMuX2lkQ291bnRlcj0wLHRoaXMuX25vZGVkU2VnU3RyaW5ncz1udWxsLHRoaXMuX25PdmVybGFwcz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTskcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX1nZXRNb25vdG9uZUNoYWlucygpe3JldHVybiB0aGlzLl9tb25vQ2hhaW5zfWdldE5vZGVkU3Vic3RyaW5ncygpe3JldHVybiBacy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKX1nZXRJbmRleCgpe3JldHVybiB0aGlzLl9pbmRleH1hZGQodCl7Zm9yKGxldCBlPVFzLmdldENoYWlucyh0LmdldENvb3JkaW5hdGVzKCksdCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRJZCh0aGlzLl9pZENvdW50ZXIrKyksdGhpcy5faW5kZXguaW5zZXJ0KHQuZ2V0RW52ZWxvcGUoKSx0KSx0aGlzLl9tb25vQ2hhaW5zLmFkZCh0KX19Y29tcHV0ZU5vZGVzKHQpe3RoaXMuX25vZGVkU2VnU3RyaW5ncz10O2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTt0aGlzLmludGVyc2VjdENoYWlucygpfWludGVyc2VjdENoYWlucygpe2NvbnN0IHQ9bmV3IGVpKHRoaXMuX3NlZ0ludCk7Zm9yKGxldCBlPXRoaXMuX21vbm9DaGFpbnMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7Zm9yKGxldCBlPXRoaXMuX2luZGV4LnF1ZXJ5KG4uZ2V0RW52ZWxvcGUoKSkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCk7aWYocy5nZXRJZCgpPm4uZ2V0SWQoKSYmKG4uY29tcHV0ZU92ZXJsYXBzKHMsdCksdGhpcy5fbk92ZXJsYXBzKyspLHRoaXMuX3NlZ0ludC5pc0RvbmUoKSlyZXR1cm4gbnVsbH19fX1jbGFzcyBlaSBleHRlbmRzIGpze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxlaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpPXR9b3ZlcmxhcCgpe2lmKDQhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBzdXBlci5vdmVybGFwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM10scz1hcmd1bWVudHNbMF0uZ2V0Q29udGV4dCgpLGk9ZS5nZXRDb250ZXh0KCk7dGhpcy5fc2kucHJvY2Vzc0ludGVyc2VjdGlvbnMocyx0LGksbil9fX10aS5TZWdtZW50T3ZlcmxhcEFjdGlvbj1laTtjbGFzcyBuaXtjb25zdHJ1Y3Rvcigpe25pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX25vZGVyPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9vZmZzZXRYPW51bGwsdGhpcy5fb2Zmc2V0WT1udWxsLHRoaXMuX2lzU2NhbGVkPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtuaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSwwLDApfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX25vZGVyPXQsdGhpcy5fc2NhbGVGYWN0b3I9ZSx0aGlzLl9pc1NjYWxlZD0hdGhpcy5pc0ludGVnZXJQcmVjaXNpb24oKX19cmVzY2FsZSgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMucmVzY2FsZShlLmdldENvb3JkaW5hdGVzKCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV0ueD10W2VdLngvdGhpcy5fc2NhbGVGYWN0b3IrdGhpcy5fb2Zmc2V0WCx0W2VdLnk9dFtlXS55L3RoaXMuX3NjYWxlRmFjdG9yK3RoaXMuX29mZnNldFk7Mj09PXQubGVuZ3RoJiZ0WzBdLmVxdWFsczJEKHRbMV0pJiZZLm91dC5wcmludGxuKHQpfX1zY2FsZSgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMKHQuc2l6ZSgpKTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgWnModGhpcy5zY2FsZSh0LmdldENvb3JkaW5hdGVzKCkpLHQuZ2V0RGF0YSgpKSl9cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT1uZXcgbShNYXRoLnJvdW5kKCh0W25dLngtdGhpcy5fb2Zmc2V0WCkqdGhpcy5fc2NhbGVGYWN0b3IpLE1hdGgucm91bmQoKHRbbl0ueS10aGlzLl9vZmZzZXRZKSp0aGlzLl9zY2FsZUZhY3RvciksdFtuXS5nZXRaKCkpO3JldHVybiBfdC5yZW1vdmVSZXBlYXRlZFBvaW50cyhlKX19aXNJbnRlZ2VyUHJlY2lzaW9uKCl7cmV0dXJuIDE9PT10aGlzLl9zY2FsZUZhY3Rvcn1nZXROb2RlZFN1YnN0cmluZ3MoKXtjb25zdCB0PXRoaXMuX25vZGVyLmdldE5vZGVkU3Vic3RyaW5ncygpO3JldHVybiB0aGlzLl9pc1NjYWxlZCYmdGhpcy5yZXNjYWxlKHQpLHR9Y29tcHV0ZU5vZGVzKHQpe2xldCBlPXQ7dGhpcy5faXNTY2FsZWQmJihlPXRoaXMuc2NhbGUodCkpLHRoaXMuX25vZGVyLmNvbXB1dGVOb2RlcyhlKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSnNdfX12YXIgc2k9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTUNJbmRleE5vZGVyOnRpLFNjYWxlZE5vZGVyOm5pLFNlZ21lbnRTdHJpbmc6SHN9KTtjbGFzcyBpaXtjb25zdHJ1Y3Rvcigpe2lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb209bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2JuUnVsZT1udWxsLHRoaXMuX2VuZHBvaW50TWFwPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxnbi5NT0QyX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb209dCx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKSx0aGlzLl9iblJ1bGU9ZX19c3RhdGljIGdldEJvdW5kYXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgaWkoYXJndW1lbnRzWzBdKS5nZXRCb3VuZGFyeSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IGlpKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLmdldEJvdW5kYXJ5KCl9fWJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2dlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO2NvbnN0IGU9dGhpcy5jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyh0KTtyZXR1cm4gMT09PWUubGVuZ3RoP3RoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KGVbMF0pOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGUpfWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuX2dlb20gaW5zdGFuY2VvZiAkP3RoaXMuYm91bmRhcnlMaW5lU3RyaW5nKHRoaXMuX2dlb20pOnRoaXMuX2dlb20gaW5zdGFuY2VvZiBTdD90aGlzLmJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHRoaXMuX2dlb20pOnRoaXMuX2dlb20uZ2V0Qm91bmRhcnkoKX1ib3VuZGFyeUxpbmVTdHJpbmcodCl7aWYodGhpcy5fZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7aWYodC5pc0Nsb3NlZCgpKXtyZXR1cm4gdGhpcy5fYm5SdWxlLmlzSW5Cb3VuZGFyeSgyKT90LmdldFN0YXJ0UG9pbnQoKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoW3QuZ2V0U3RhcnRQb2ludCgpLHQuZ2V0RW5kUG9pbnQoKV0pfWdldEVtcHR5TXVsdGlQb2ludCgpe3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9Y29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgTDt0aGlzLl9lbmRwb2ludE1hcD1uZXcgV247Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7MCE9PW4uZ2V0TnVtUG9pbnRzKCkmJih0aGlzLmFkZEVuZHBvaW50KG4uZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuYWRkRW5kcG9pbnQobi5nZXRDb29yZGluYXRlTihuLmdldE51bVBvaW50cygpLTEpKSl9Zm9yKGxldCB0PXRoaXMuX2VuZHBvaW50TWFwLmVudHJ5U2V0KCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldFZhbHVlKCkuY291bnQ7dGhpcy5fYm5SdWxlLmlzSW5Cb3VuZGFyeShzKSYmZS5hZGQobi5nZXRLZXkoKSl9cmV0dXJuIF90LnRvQ29vcmRpbmF0ZUFycmF5KGUpfWFkZEVuZHBvaW50KHQpe2xldCBlPXRoaXMuX2VuZHBvaW50TWFwLmdldCh0KTtudWxsPT09ZSYmKGU9bmV3IHJpLHRoaXMuX2VuZHBvaW50TWFwLnB1dCh0LGUpKSxlLmNvdW50Kyt9fWxldCByaT1jbGFzc3tjb25zdHJ1Y3Rvcigpe3JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuY291bnQ9bnVsbH19O2NsYXNzIG9pe2NvbnN0cnVjdG9yKCl7b2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSEwLHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hZS5pc0luQm91bmRhcnkoMil9fXN0YXRpYyBpc1NpbXBsZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IG9pKGFyZ3VtZW50c1swXSkuaXNTaW1wbGUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBvaShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5pc1NpbXBsZSgpfX1pc1NpbXBsZU11bHRpUG9pbnQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Y29uc3QgZT1uZXcgYXQ7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obikuZ2V0Q29vcmRpbmF0ZSgpO2lmKGUuY29udGFpbnMocykpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXMsITE7ZS5hZGQocyl9cmV0dXJuITB9aXNTaW1wbGVQb2x5Z29uYWwodCl7Zm9yKGxldCBlPXllLmdldExpbmVzKHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKCF0aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCkpcmV0dXJuITF9cmV0dXJuITB9aGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24odCl7Y29uc3QgZT1uZXcgV247Zm9yKGxldCBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLHM9dC5pc0Nsb3NlZCgpLGk9dC5nZXRDb29yZGluYXRlKDApO3RoaXMuYWRkRW5kcG9pbnQoZSxpLHMpO2NvbnN0IHI9dC5nZXRDb29yZGluYXRlKHQuZ2V0TnVtUG9pbnRzKCktMSk7dGhpcy5hZGRFbmRwb2ludChlLHIscyl9Zm9yKGxldCB0PWUudmFsdWVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7aWYoZS5pc0Nsb3NlZCYmMiE9PWUuZGVncmVlKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1lLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX1nZXROb25TaW1wbGVMb2NhdGlvbigpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbn1pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO2NvbnN0IGU9bmV3IGFzKDAsdCksbj1uZXcganQscz1lLmNvbXB1dGVTZWxmTm9kZXMobiwhMCk7cmV0dXJuIXMuaGFzSW50ZXJzZWN0aW9uKCl8fChzLmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1zLmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOiF0aGlzLmhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKGUpJiYoIXRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcnx8IXRoaXMuaGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSkpKX1oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldE1heGltdW1TZWdtZW50SW5kZXgoKTtmb3IobGV0IGU9dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKCF0LmlzRW5kUG9pbnQobikpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXQuZ2V0Q29vcmRpbmF0ZSgpLCEwfX1yZXR1cm4hMX1hZGRFbmRwb2ludCh0LGUsbil7bGV0IHM9dC5nZXQoZSk7bnVsbD09PXMmJihzPW5ldyBsaShlKSx0LnB1dChlLHMpKSxzLmFkZEVuZHBvaW50KG4pfWNvbXB1dGVTaW1wbGUodCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsISF0LmlzRW1wdHkoKXx8KHQgaW5zdGFuY2VvZiAkfHx0IGluc3RhbmNlb2YgU3Q/dGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpOnQgaW5zdGFuY2VvZiB1dD90aGlzLmlzU2ltcGxlTXVsdGlQb2ludCh0KTpJKHQsaXQpP3RoaXMuaXNTaW1wbGVQb2x5Z29uYWwodCk6ISh0IGluc3RhbmNlb2YgaHQpfHx0aGlzLmlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpKX1pc1NpbXBsZSgpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLHRoaXMuY29tcHV0ZVNpbXBsZSh0aGlzLl9pbnB1dEdlb20pfWlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmNvbXB1dGVTaW1wbGUobikpcmV0dXJuITF9cmV0dXJuITB9fWNsYXNzIGxpe2NvbnN0cnVjdG9yKCl7bGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5wdD1udWxsLHRoaXMuaXNDbG9zZWQ9bnVsbCx0aGlzLmRlZ3JlZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucHQ9dCx0aGlzLmlzQ2xvc2VkPSExLHRoaXMuZGVncmVlPTB9YWRkRW5kcG9pbnQodCl7dGhpcy5kZWdyZWUrKyx0aGlzLmlzQ2xvc2VkfD10fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5wdH19b2kuRW5kcG9pbnRJbmZvPWxpO2NsYXNzIGFpe2NvbnN0cnVjdG9yKCl7YWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz1haS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTLHRoaXMuX2VuZENhcFN0eWxlPWFpLkNBUF9ST1VORCx0aGlzLl9qb2luU3R5bGU9YWkuSk9JTl9ST1VORCx0aGlzLl9taXRyZUxpbWl0PWFpLkRFRkFVTFRfTUlUUkVfTElNSVQsdGhpcy5faXNTaW5nbGVTaWRlZD0hMSx0aGlzLl9zaW1wbGlmeUZhY3Rvcj1haS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUiwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KSx0aGlzLnNldEVuZENhcFN0eWxlKGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KSx0aGlzLnNldEVuZENhcFN0eWxlKGUpLHRoaXMuc2V0Sm9pblN0eWxlKG4pLHRoaXMuc2V0TWl0cmVMaW1pdChzKX19c3RhdGljIGJ1ZmZlckRpc3RhbmNlRXJyb3IodCl7Y29uc3QgZT1NYXRoLlBJLzIvdDtyZXR1cm4gMS1NYXRoLmNvcyhlLzIpfWdldEVuZENhcFN0eWxlKCl7cmV0dXJuIHRoaXMuX2VuZENhcFN0eWxlfWlzU2luZ2xlU2lkZWQoKXtyZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZH1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX3F1YWRyYW50U2VnbWVudHM9dCwwPT09dGhpcy5fcXVhZHJhbnRTZWdtZW50cyYmKHRoaXMuX2pvaW5TdHlsZT1haS5KT0lOX0JFVkVMKSx0aGlzLl9xdWFkcmFudFNlZ21lbnRzPDAmJih0aGlzLl9qb2luU3R5bGU9YWkuSk9JTl9NSVRSRSx0aGlzLl9taXRyZUxpbWl0PU1hdGguYWJzKHRoaXMuX3F1YWRyYW50U2VnbWVudHMpKSx0PD0wJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz0xKSx0aGlzLl9qb2luU3R5bGUhPT1haS5KT0lOX1JPVU5EJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz1haS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTKX1nZXRKb2luU3R5bGUoKXtyZXR1cm4gdGhpcy5fam9pblN0eWxlfXNldEpvaW5TdHlsZSh0KXt0aGlzLl9qb2luU3R5bGU9dH1zZXRTaW1wbGlmeUZhY3Rvcih0KXt0aGlzLl9zaW1wbGlmeUZhY3Rvcj10PDA/MDp0fWdldFNpbXBsaWZ5RmFjdG9yKCl7cmV0dXJuIHRoaXMuX3NpbXBsaWZ5RmFjdG9yfWdldFF1YWRyYW50U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnRTZWdtZW50c31zZXRFbmRDYXBTdHlsZSh0KXt0aGlzLl9lbmRDYXBTdHlsZT10fWdldE1pdHJlTGltaXQoKXtyZXR1cm4gdGhpcy5fbWl0cmVMaW1pdH1zZXRNaXRyZUxpbWl0KHQpe3RoaXMuX21pdHJlTGltaXQ9dH1zZXRTaW5nbGVTaWRlZCh0KXt0aGlzLl9pc1NpbmdsZVNpZGVkPXR9fWFpLkNBUF9ST1VORD0xLGFpLkNBUF9GTEFUPTIsYWkuQ0FQX1NRVUFSRT0zLGFpLkpPSU5fUk9VTkQ9MSxhaS5KT0lOX01JVFJFPTIsYWkuSk9JTl9CRVZFTD0zLGFpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM9OCxhaS5ERUZBVUxUX01JVFJFX0xJTUlUPTUsYWkuREVGQVVMVF9TSU1QTElGWV9GQUNUT1I9LjAxO2NsYXNzIGNpe2NvbnN0cnVjdG9yKCl7Y2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWluSW5kZXg9LTEsdGhpcy5fbWluQ29vcmQ9bnVsbCx0aGlzLl9taW5EZT1udWxsLHRoaXMuX29yaWVudGVkRGU9bnVsbH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX21pbkNvb3JkfWdldFJpZ2h0bW9zdFNpZGUodCxlKXtsZXQgbj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKTtyZXR1cm4gbjwwJiYobj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlLTEpKSxuPDAmJih0aGlzLl9taW5Db29yZD1udWxsLHRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpKSxufWZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKXtjb25zdCB0PXRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2cuaXNUcnVlKHRoaXMuX21pbkluZGV4PjAmJnRoaXMuX21pbkluZGV4PHQubGVuZ3RoLFwicmlnaHRtb3N0IHBvaW50IGV4cGVjdGVkIHRvIGJlIGludGVyaW9yIHZlcnRleCBvZiBlZGdlXCIpO2NvbnN0IGU9dFt0aGlzLl9taW5JbmRleC0xXSxuPXRbdGhpcy5fbWluSW5kZXgrMV0scz1xLmluZGV4KHRoaXMuX21pbkNvb3JkLG4sZSk7bGV0IGk9ITE7KGUueTx0aGlzLl9taW5Db29yZC55JiZuLnk8dGhpcy5fbWluQ29vcmQueSYmcz09PXEuQ09VTlRFUkNMT0NLV0lTRXx8ZS55PnRoaXMuX21pbkNvb3JkLnkmJm4ueT50aGlzLl9taW5Db29yZC55JiZzPT09cS5DTE9DS1dJU0UpJiYoaT0hMCksaSYmKHRoaXMuX21pbkluZGV4PXRoaXMuX21pbkluZGV4LTEpfWdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKXtjb25zdCBuPXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7aWYoZTwwfHxlKzE+PW4ubGVuZ3RoKXJldHVybi0xO2lmKG5bZV0ueT09PW5bZSsxXS55KXJldHVybi0xO2xldCBzPWJuLkxFRlQ7cmV0dXJuIG5bZV0ueTxuW2UrMV0ueSYmKHM9Ym4uUklHSFQpLHN9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9vcmllbnRlZERlfWNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KXtjb25zdCBlPXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aC0xO24rKykobnVsbD09PXRoaXMuX21pbkNvb3JkfHxlW25dLng+dGhpcy5fbWluQ29vcmQueCkmJih0aGlzLl9taW5EZT10LHRoaXMuX21pbkluZGV4PW4sdGhpcy5fbWluQ29vcmQ9ZVtuXSl9ZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKXtjb25zdCB0PXRoaXMuX21pbkRlLmdldE5vZGUoKS5nZXRFZGdlcygpO3RoaXMuX21pbkRlPXQuZ2V0UmlnaHRtb3N0RWRnZSgpLHRoaXMuX21pbkRlLmlzRm9yd2FyZCgpfHwodGhpcy5fbWluRGU9dGhpcy5fbWluRGUuZ2V0U3ltKCksdGhpcy5fbWluSW5kZXg9dGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpfWZpbmRFZGdlKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuaXNGb3J3YXJkKCkmJnRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpfWcuaXNUcnVlKDAhPT10aGlzLl9taW5JbmRleHx8dGhpcy5fbWluQ29vcmQuZXF1YWxzKHRoaXMuX21pbkRlLmdldENvb3JkaW5hdGUoKSksXCJpbmNvbnNpc3RlbmN5IGluIHJpZ2h0bW9zdCBwcm9jZXNzaW5nXCIpLDA9PT10aGlzLl9taW5JbmRleD90aGlzLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCk6dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCksdGhpcy5fb3JpZW50ZWREZT10aGlzLl9taW5EZTt0aGlzLmdldFJpZ2h0bW9zdFNpZGUodGhpcy5fbWluRGUsdGhpcy5fbWluSW5kZXgpPT09Ym4uTEVGVCYmKHRoaXMuX29yaWVudGVkRGU9dGhpcy5fbWluRGUuZ2V0U3ltKCkpfX1jbGFzcyBoaXtjb25zdHJ1Y3Rvcigpe3RoaXMuYXJyYXk9W119YWRkTGFzdCh0KXt0aGlzLmFycmF5LnB1c2godCl9cmVtb3ZlRmlyc3QoKXtyZXR1cm4gdGhpcy5hcnJheS5zaGlmdCgpfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuYXJyYXkubGVuZ3RofX1jbGFzcyB1aXtjb25zdHJ1Y3Rvcigpe3VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZpbmRlcj1udWxsLHRoaXMuX2RpckVkZ2VMaXN0PW5ldyBMLHRoaXMuX25vZGVzPW5ldyBMLHRoaXMuX3JpZ2h0TW9zdENvb3JkPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5fZmluZGVyPW5ldyBjaX1jbGVhclZpc2l0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0VmlzaXRlZCghMSl9fWdldFJpZ2h0bW9zdENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcmlnaHRNb3N0Q29vcmR9Y29tcHV0ZU5vZGVEZXB0aCh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc1Zpc2l0ZWQoKXx8dC5nZXRTeW0oKS5pc1Zpc2l0ZWQoKSl7ZT10O2JyZWFrfX1pZihudWxsPT09ZSl0aHJvdyBuZXcgaXMoXCJ1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKTt0LmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhlKTtmb3IobGV0IGU9dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0VmlzaXRlZCghMCksdGhpcy5jb3B5U3ltRGVwdGhzKHQpfX1jb21wdXRlRGVwdGgodCl7dGhpcy5jbGVhclZpc2l0ZWRFZGdlcygpO2NvbnN0IGU9dGhpcy5fZmluZGVyLmdldEVkZ2UoKTtlLmdldE5vZGUoKSxlLmdldExhYmVsKCksZS5zZXRFZGdlRGVwdGhzKGJuLlJJR0hULHQpLHRoaXMuY29weVN5bURlcHRocyhlKSx0aGlzLmNvbXB1dGVEZXB0aHMoZSl9Y3JlYXRlKHQpe3RoaXMuYWRkUmVhY2hhYmxlKHQpLHRoaXMuX2ZpbmRlci5maW5kRWRnZSh0aGlzLl9kaXJFZGdlTGlzdCksdGhpcy5fcmlnaHRNb3N0Q29vcmQ9dGhpcy5fZmluZGVyLmdldENvb3JkaW5hdGUoKX1maW5kUmVzdWx0RWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5nZXREZXB0aChibi5SSUdIVCk+PTEmJmUuZ2V0RGVwdGgoYm4uTEVGVCk8PTAmJiFlLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZlLnNldEluUmVzdWx0KCEwKX19Y29tcHV0ZURlcHRocyh0KXtjb25zdCBlPW5ldyBFdCxuPW5ldyBoaSxzPXQuZ2V0Tm9kZSgpO2ZvcihuLmFkZExhc3QocyksZS5hZGQocyksdC5zZXRWaXNpdGVkKCEwKTshbi5pc0VtcHR5KCk7KXtjb25zdCB0PW4ucmVtb3ZlRmlyc3QoKTtlLmFkZCh0KSx0aGlzLmNvbXB1dGVOb2RlRGVwdGgodCk7Zm9yKGxldCBzPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKS5nZXRTeW0oKTtpZih0LmlzVmlzaXRlZCgpKWNvbnRpbnVlO2NvbnN0IGk9dC5nZXROb2RlKCk7ZS5jb250YWlucyhpKXx8KG4uYWRkTGFzdChpKSxlLmFkZChpKSl9fX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZC54PGUuX3JpZ2h0TW9zdENvb3JkLng/LTE6dGhpcy5fcmlnaHRNb3N0Q29vcmQueD5lLl9yaWdodE1vc3RDb29yZC54PzE6MH1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe2NvbnN0IHQ9bmV3IE87Zm9yKGxldCBlPXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGgtMTtlKyspdC5leHBhbmRUb0luY2x1ZGUobltlXSl9dGhpcy5fZW52PXR9cmV0dXJuIHRoaXMuX2Vudn1hZGRSZWFjaGFibGUodCl7Y29uc3QgZT1uZXcgZW47Zm9yKGUuYWRkKHQpOyFlLmVtcHR5KCk7KXtjb25zdCB0PWUucG9wKCk7dGhpcy5hZGQodCxlKX19Y29weVN5bURlcHRocyh0KXtjb25zdCBlPXQuZ2V0U3ltKCk7ZS5zZXREZXB0aChibi5MRUZULHQuZ2V0RGVwdGgoYm4uUklHSFQpKSxlLnNldERlcHRoKGJuLlJJR0hULHQuZ2V0RGVwdGgoYm4uTEVGVCkpfWFkZCh0LGUpe3Quc2V0VmlzaXRlZCghMCksdGhpcy5fbm9kZXMuYWRkKHQpO2ZvcihsZXQgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fZGlyRWRnZUxpc3QuYWRkKHQpO2NvbnN0IHM9dC5nZXRTeW0oKS5nZXROb2RlKCk7cy5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKHMpfX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2Rlc31nZXREaXJlY3RlZEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VMaXN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19bGV0IGdpPWNsYXNze2NvbnN0cnVjdG9yKCl7Z2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc3RhcnREZT1udWxsLHRoaXMuX21heE5vZGVEZWdyZWU9LTEsdGhpcy5fZWRnZXM9bmV3IEwsdGhpcy5fcHRzPW5ldyBMLHRoaXMuX2xhYmVsPW5ldyBCbihRdC5OT05FKSx0aGlzLl9yaW5nPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9ob2xlcz1uZXcgTCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5jb21wdXRlUG9pbnRzKHQpLHRoaXMuY29tcHV0ZVJpbmcoKX19Y29tcHV0ZVJpbmcoKXtpZihudWxsIT09dGhpcy5fcmluZylyZXR1cm4gbnVsbDtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9wdHMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fcHRzLnNpemUoKTtlKyspdFtlXT10aGlzLl9wdHMuZ2V0KGUpO3RoaXMuX3Jpbmc9dGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodCksdGhpcy5faXNIb2xlPXEuaXNDQ1codGhpcy5fcmluZy5nZXRDb29yZGluYXRlcygpKX1pc0lzb2xhdGVkKCl7cmV0dXJuIDE9PT10aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9Y29tcHV0ZVBvaW50cyh0KXt0aGlzLl9zdGFydERlPXQ7bGV0IGU9dCxuPSEwO2Rve2lmKG51bGw9PT1lKXRocm93IG5ldyBpcyhcIkZvdW5kIG51bGwgRGlyZWN0ZWRFZGdlXCIpO2lmKGUuZ2V0RWRnZVJpbmcoKT09PXRoaXMpdGhyb3cgbmV3IGlzKFwiRGlyZWN0ZWQgRWRnZSB2aXNpdGVkIHR3aWNlIGR1cmluZyByaW5nLWJ1aWxkaW5nIGF0IFwiK2UuZ2V0Q29vcmRpbmF0ZSgpKTt0aGlzLl9lZGdlcy5hZGQoZSk7Y29uc3QgdD1lLmdldExhYmVsKCk7Zy5pc1RydWUodC5pc0FyZWEoKSksdGhpcy5tZXJnZUxhYmVsKHQpLHRoaXMuYWRkUG9pbnRzKGUuZ2V0RWRnZSgpLGUuaXNGb3J3YXJkKCksbiksbj0hMSx0aGlzLnNldEVkZ2VSaW5nKGUsdGhpcyksZT10aGlzLmdldE5leHQoZSl9d2hpbGUoZSE9PXRoaXMuX3N0YXJ0RGUpfWdldExpbmVhclJpbmcoKXtyZXR1cm4gdGhpcy5fcmluZ31nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHMuZ2V0KHQpfWNvbXB1dGVNYXhOb2RlRGVncmVlKCl7dGhpcy5fbWF4Tm9kZURlZ3JlZT0wO2xldCB0PXRoaXMuX3N0YXJ0RGU7ZG97Y29uc3QgZT10LmdldE5vZGUoKS5nZXRFZGdlcygpLmdldE91dGdvaW5nRGVncmVlKHRoaXMpO2U+dGhpcy5fbWF4Tm9kZURlZ3JlZSYmKHRoaXMuX21heE5vZGVEZWdyZWU9ZSksdD10aGlzLmdldE5leHQodCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpO3RoaXMuX21heE5vZGVEZWdyZWUqPTJ9YWRkUG9pbnRzKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlKXtsZXQgdD0xO24mJih0PTApO2ZvcihsZXQgZT10O2U8cy5sZW5ndGg7ZSsrKXRoaXMuX3B0cy5hZGQoc1tlXSl9ZWxzZXtsZXQgdD1zLmxlbmd0aC0yO24mJih0PXMubGVuZ3RoLTEpO2ZvcihsZXQgZT10O2U+PTA7ZS0tKXRoaXMuX3B0cy5hZGQoc1tlXSl9fWlzSG9sZSgpe3JldHVybiB0aGlzLl9pc0hvbGV9c2V0SW5SZXN1bHQoKXtsZXQgdD10aGlzLl9zdGFydERlO2Rve3QuZ2V0RWRnZSgpLnNldEluUmVzdWx0KCEwKSx0PXQuZ2V0TmV4dCgpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKX1jb250YWluc1BvaW50KHQpe2NvbnN0IGU9dGhpcy5nZXRMaW5lYXJSaW5nKCk7aWYoIWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvbnRhaW5zKHQpKXJldHVybiExO2lmKCFVZS5pc0luUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSkpcmV0dXJuITE7Zm9yKGxldCBlPXRoaXMuX2hvbGVzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtpZihlLm5leHQoKS5jb250YWluc1BvaW50KHQpKXJldHVybiExfXJldHVybiEwfWFkZEhvbGUodCl7dGhpcy5faG9sZXMuYWRkKHQpfWlzU2hlbGwoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3NoZWxsfWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfWdldE1heE5vZGVEZWdyZWUoKXtyZXR1cm4gdGhpcy5fbWF4Tm9kZURlZ3JlZTwwJiZ0aGlzLmNvbXB1dGVNYXhOb2RlRGVncmVlKCksdGhpcy5fbWF4Tm9kZURlZ3JlZX1nZXRTaGVsbCgpe3JldHVybiB0aGlzLl9zaGVsbH1tZXJnZUxhYmVsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VMYWJlbCh0LDApLHRoaXMubWVyZ2VMYWJlbCh0LDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLmdldExvY2F0aW9uKHQsYm4uUklHSFQpO2lmKGU9PT1RdC5OT05FKXJldHVybiBudWxsO2lmKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKHQpPT09UXQuTk9ORSlyZXR1cm4gdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlKSxudWxsfX1zZXRTaGVsbCh0KXt0aGlzLl9zaGVsbD10LG51bGwhPT10JiZ0LmFkZEhvbGUodGhpcyl9dG9Qb2x5Z29uKHQpe2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuX2hvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLnNpemUoKTt0KyspZVt0XT10aGlzLl9ob2xlcy5nZXQodCkuZ2V0TGluZWFyUmluZygpO3JldHVybiB0LmNyZWF0ZVBvbHlnb24odGhpcy5nZXRMaW5lYXJSaW5nKCksZSl9fTtjbGFzcyBkaSBleHRlbmRzIGdpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxkaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtnaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9c2V0RWRnZVJpbmcodCxlKXt0LnNldE1pbkVkZ2VSaW5nKGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dE1pbigpfX1jbGFzcyBfaSBleHRlbmRzIGdpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxfaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtnaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9YnVpbGRNaW5pbWFsUmluZ3MoKXtjb25zdCB0PW5ldyBMO2xldCBlPXRoaXMuX3N0YXJ0RGU7ZG97aWYobnVsbD09PWUuZ2V0TWluRWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgZGkoZSx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO3QuYWRkKG4pfWU9ZS5nZXROZXh0KCl9d2hpbGUoZSE9PXRoaXMuX3N0YXJ0RGUpO3JldHVybiB0fXNldEVkZ2VSaW5nKHQsZSl7dC5zZXRFZGdlUmluZyhlKX1saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKXtsZXQgdD10aGlzLl9zdGFydERlO2Rve3QuZ2V0Tm9kZSgpLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMpLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dCgpfX1jbGFzcyBwaXtjb25zdHJ1Y3Rvcigpe3BpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3NoZWxsTGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9dH1zdGF0aWMgZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpe2NvbnN0IG49dC5nZXRMaW5lYXJSaW5nKCkscz1uLmdldEVudmVsb3BlSW50ZXJuYWwoKTtsZXQgaT1uLmdldENvb3JkaW5hdGVOKDApLHI9bnVsbCxvPW51bGw7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbD1lLmdldExpbmVhclJpbmcoKSxhPWwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKGEuZXF1YWxzKHMpKWNvbnRpbnVlO2lmKCFhLmNvbnRhaW5zKHMpKWNvbnRpbnVlO2k9X3QucHROb3RJbkxpc3Qobi5nZXRDb29yZGluYXRlcygpLGwuZ2V0Q29vcmRpbmF0ZXMoKSk7bGV0IGM9ITE7VWUuaXNJblJpbmcoaSxsLmdldENvb3JkaW5hdGVzKCkpJiYoYz0hMCksYyYmKG51bGw9PT1yfHxvLmNvbnRhaW5zKGEpKSYmKHI9ZSxvPXIuZ2V0TGluZWFyUmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9cmV0dXJuIHJ9c29ydFNoZWxsc0FuZEhvbGVzKHQsZSxuKXtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzSG9sZSgpP24uYWRkKHQpOmUuYWRkKHQpfX1jb21wdXRlUG9seWdvbnModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKS50b1BvbHlnb24odGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZCh0KX1yZXR1cm4gZX1wbGFjZUZyZWVIb2xlcyh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2lmKG51bGw9PT1lLmdldFNoZWxsKCkpe2NvbnN0IG49cGkuZmluZEVkZ2VSaW5nQ29udGFpbmluZyhlLHQpO2lmKG51bGw9PT1uKXRocm93IG5ldyBpcyhcInVuYWJsZSB0byBhc3NpZ24gaG9sZSB0byBhIHNoZWxsXCIsZS5nZXRDb29yZGluYXRlKDApKTtlLnNldFNoZWxsKG4pfX19YnVpbGRNaW5pbWFsRWRnZVJpbmdzKHQsZSxuKXtjb25zdCBzPW5ldyBMO2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpO2lmKHQuZ2V0TWF4Tm9kZURlZ3JlZSgpPjIpe3QubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7Y29uc3Qgcz10LmJ1aWxkTWluaW1hbFJpbmdzKCksaT10aGlzLmZpbmRTaGVsbChzKTtudWxsIT09aT8odGhpcy5wbGFjZVBvbHlnb25Ib2xlcyhpLHMpLGUuYWRkKGkpKTpuLmFkZEFsbChzKX1lbHNlIHMuYWRkKHQpfXJldHVybiBzfWJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQuaXNJblJlc3VsdCgpJiZ0LmdldExhYmVsKCkuaXNBcmVhKCkmJm51bGw9PT10LmdldEVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IF9pKHQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChuKSxuLnNldEluUmVzdWx0KCl9fXJldHVybiBlfXBsYWNlUG9seWdvbkhvbGVzKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7ZS5pc0hvbGUoKSYmZS5zZXRTaGVsbCh0KX19Z2V0UG9seWdvbnMoKXtyZXR1cm4gdGhpcy5jb21wdXRlUG9seWdvbnModGhpcy5fc2hlbGxMaXN0KX1maW5kU2hlbGwodCl7bGV0IGU9MCxuPW51bGw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc0hvbGUoKXx8KG49dCxlKyspfXJldHVybiBnLmlzVHJ1ZShlPD0xLFwiZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdFwiKSxufWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LmdldEVkZ2VFbmRzKCksdC5nZXROb2RlcygpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtscy5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhlKTtjb25zdCBuPXRoaXMuYnVpbGRNYXhpbWFsRWRnZVJpbmdzKHQpLHM9bmV3IEwsaT10aGlzLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyhuLHRoaXMuX3NoZWxsTGlzdCxzKTt0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhpLHRoaXMuX3NoZWxsTGlzdCxzKSx0aGlzLnBsYWNlRnJlZUhvbGVzKHRoaXMuX3NoZWxsTGlzdCxzKX19fWNsYXNzIG1pe2NvbnN0cnVjdG9yKCl7bWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRMaW5lPW51bGwsdGhpcy5fZGlzdGFuY2VUb2w9bnVsbCx0aGlzLl9pc0RlbGV0ZWQ9bnVsbCx0aGlzLl9hbmdsZU9yaWVudGF0aW9uPXEuQ09VTlRFUkNMT0NLV0lTRTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dExpbmU9dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtyZXR1cm4gbmV3IG1pKHQpLnNpbXBsaWZ5KGUpfWlzRGVsZXRhYmxlKHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5faW5wdXRMaW5lW3RdLHI9dGhpcy5faW5wdXRMaW5lW2VdLG89dGhpcy5faW5wdXRMaW5lW25dO3JldHVybiEhdGhpcy5pc0NvbmNhdmUoaSxyLG8pJiYoISF0aGlzLmlzU2hhbGxvdyhpLHIsbyxzKSYmdGhpcy5pc1NoYWxsb3dTYW1wbGVkKGkscix0LG4scykpfWRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpe2xldCB0PTEsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKSxzPSExO2Zvcig7bjx0aGlzLl9pbnB1dExpbmUubGVuZ3RoOyl7bGV0IGk9ITE7dGhpcy5pc0RlbGV0YWJsZSh0LGUsbix0aGlzLl9kaXN0YW5jZVRvbCkmJih0aGlzLl9pc0RlbGV0ZWRbZV09bWkuREVMRVRFLGk9ITAscz0hMCksdD1pP246ZSxlPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpfXJldHVybiBzfWlzU2hhbGxvd0NvbmNhdml0eSh0LGUsbixzKXtpZighKHEuaW5kZXgodCxlLG4pPT09dGhpcy5fYW5nbGVPcmllbnRhdGlvbikpcmV0dXJuITE7cmV0dXJuIHoucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9aXNTaGFsbG93U2FtcGxlZCh0LGUsbixzLGkpe2xldCByPU1hdGgudHJ1bmMoKHMtbikvbWkuTlVNX1BUU19UT19DSEVDSyk7cjw9MCYmKHI9MSk7Zm9yKGxldCBvPW47bzxzO28rPXIpaWYoIXRoaXMuaXNTaGFsbG93KHQsZSx0aGlzLl9pbnB1dExpbmVbb10saSkpcmV0dXJuITE7cmV0dXJuITB9aXNDb25jYXZlKHQsZSxuKXtyZXR1cm4gcS5pbmRleCh0LGUsbik9PT10aGlzLl9hbmdsZU9yaWVudGF0aW9ufXNpbXBsaWZ5KHQpe3RoaXMuX2Rpc3RhbmNlVG9sPU1hdGguYWJzKHQpLHQ8MCYmKHRoaXMuX2FuZ2xlT3JpZW50YXRpb249cS5DTE9DS1dJU0UpLHRoaXMuX2lzRGVsZXRlZD1uZXcgQXJyYXkodGhpcy5faW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTtsZXQgZT0hMTtkb3tlPXRoaXMuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCl9d2hpbGUoZSk7cmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKCl9ZmluZE5leHROb25EZWxldGVkSW5kZXgodCl7bGV0IGU9dCsxO2Zvcig7ZTx0aGlzLl9pbnB1dExpbmUubGVuZ3RoJiZ0aGlzLl9pc0RlbGV0ZWRbZV09PT1taS5ERUxFVEU7KWUrKztyZXR1cm4gZX1pc1NoYWxsb3codCxlLG4scyl7cmV0dXJuIHoucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9Y29sbGFwc2VMaW5lKCl7Y29uc3QgdD1uZXcgUjtmb3IobGV0IGU9MDtlPHRoaXMuX2lucHV0TGluZS5sZW5ndGg7ZSsrKXRoaXMuX2lzRGVsZXRlZFtlXSE9PW1pLkRFTEVURSYmdC5hZGQodGhpcy5faW5wdXRMaW5lW2VdKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfX1taS5JTklUPTAsbWkuREVMRVRFPTEsbWkuS0VFUD0xLG1pLk5VTV9QVFNfVE9fQ0hFQ0s9MTA7Y2xhc3MgZml7Y29uc3RydWN0b3IoKXtmaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdExpc3Q9bnVsbCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZT0wLHRoaXMuX3B0TGlzdD1uZXcgTH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdExpc3QudG9BcnJheShmaS5DT09SRElOQVRFX0FSUkFZX1RZUEUpfXNldFByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3ByZWNpc2lvbk1vZGVsPXR9YWRkUHQodCl7Y29uc3QgZT1uZXcgbSh0KTtpZih0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShlKSx0aGlzLmlzUmVkdW5kYW50KGUpKXJldHVybiBudWxsO3RoaXMuX3B0TGlzdC5hZGQoZSl9cmV2ZXJzZSgpe31hZGRQdHModCxlKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMuYWRkUHQodFtlXSk7ZWxzZSBmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl0aGlzLmFkZFB0KHRbZV0pfWlzUmVkdW5kYW50KHQpe2lmKHRoaXMuX3B0TGlzdC5zaXplKCk8MSlyZXR1cm4hMTtjb25zdCBlPXRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKS0xKTtyZXR1cm4gdC5kaXN0YW5jZShlKTx0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2V9dG9TdHJpbmcoKXtyZXR1cm4obmV3IEx0KS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkudG9TdHJpbmcoKX1jbG9zZVJpbmcoKXtpZih0aGlzLl9wdExpc3Quc2l6ZSgpPDEpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgbSh0aGlzLl9wdExpc3QuZ2V0KDApKSxlPXRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKS0xKTtpZih0LmVxdWFscyhlKSlyZXR1cm4gbnVsbDt0aGlzLl9wdExpc3QuYWRkKHQpfXNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KXt0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2U9dH19ZmkuQ09PUkRJTkFURV9BUlJBWV9UWVBFPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIHlpe2NvbnN0cnVjdG9yKCl7eWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3I9MCx0aGlzLl9maWxsZXRBbmdsZVF1YW50dW09bnVsbCx0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPTEsdGhpcy5fc2VnTGlzdD1udWxsLHRoaXMuX2Rpc3RhbmNlPTAsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9idWZQYXJhbXM9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX3MwPW51bGwsdGhpcy5fczE9bnVsbCx0aGlzLl9zMj1udWxsLHRoaXMuX3NlZzA9bmV3IEt0LHRoaXMuX3NlZzE9bmV3IEt0LHRoaXMuX29mZnNldDA9bmV3IEt0LHRoaXMuX29mZnNldDE9bmV3IEt0LHRoaXMuX3NpZGU9MCx0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9idWZQYXJhbXM9ZSx0aGlzLl9saT1uZXcganQsdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtPU1hdGguUEkvMi9lLmdldFF1YWRyYW50U2VnbWVudHMoKSxlLmdldFF1YWRyYW50U2VnbWVudHMoKT49OCYmZS5nZXRKb2luU3R5bGUoKT09PWFpLkpPSU5fUk9VTkQmJih0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPXlpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SKSx0aGlzLmluaXQobil9YWRkTmV4dFNlZ21lbnQodCxlKXtpZih0aGlzLl9zMD10aGlzLl9zMSx0aGlzLl9zMT10aGlzLl9zMix0aGlzLl9zMj10LHRoaXMuX3NlZzAuc2V0Q29vcmRpbmF0ZXModGhpcy5fczAsdGhpcy5fczEpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMCx0aGlzLl9zaWRlLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDApLHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModGhpcy5fczEsdGhpcy5fczIpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSx0aGlzLl9zaWRlLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDEpLHRoaXMuX3MxLmVxdWFscyh0aGlzLl9zMikpcmV0dXJuIG51bGw7Y29uc3Qgbj1xLmluZGV4KHRoaXMuX3MwLHRoaXMuX3MxLHRoaXMuX3MyKSxzPW49PT1xLkNMT0NLV0lTRSYmdGhpcy5fc2lkZT09PWJuLkxFRlR8fG49PT1xLkNPVU5URVJDTE9DS1dJU0UmJnRoaXMuX3NpZGU9PT1ibi5SSUdIVDswPT09bj90aGlzLmFkZENvbGxpbmVhcihlKTpzP3RoaXMuYWRkT3V0c2lkZVR1cm4obixlKTp0aGlzLmFkZEluc2lkZVR1cm4obixlKX1hZGRMaW5lRW5kQ2FwKHQsZSl7Y29uc3Qgbj1uZXcgS3QodCxlKSxzPW5ldyBLdDt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sYm4uTEVGVCx0aGlzLl9kaXN0YW5jZSxzKTtjb25zdCBpPW5ldyBLdDt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sYm4uUklHSFQsdGhpcy5fZGlzdGFuY2UsaSk7Y29uc3Qgcj1lLngtdC54LG89ZS55LXQueSxsPU1hdGguYXRhbjIobyxyKTtzd2l0Y2godGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgYWkuQ0FQX1JPVU5EOnRoaXMuX3NlZ0xpc3QuYWRkUHQocy5wMSksdGhpcy5hZGREaXJlY3RlZEZpbGxldChlLGwrTWF0aC5QSS8yLGwtTWF0aC5QSS8yLHEuQ0xPQ0tXSVNFLHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGkucDEpO2JyZWFrO2Nhc2UgYWkuQ0FQX0ZMQVQ6dGhpcy5fc2VnTGlzdC5hZGRQdChzLnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGkucDEpO2JyZWFrO2Nhc2UgYWkuQ0FQX1NRVUFSRTpjb25zdCB0PW5ldyBtO3QueD1NYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkqTWF0aC5jb3MobCksdC55PU1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSpNYXRoLnNpbihsKTtjb25zdCBuPW5ldyBtKHMucDEueCt0Lngscy5wMS55K3QueSkscj1uZXcgbShpLnAxLngrdC54LGkucDEueSt0LnkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQobiksdGhpcy5fc2VnTGlzdC5hZGRQdChyKX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fc2VnTGlzdC5nZXRDb29yZGluYXRlcygpfWFkZE1pdHJlSm9pbih0LGUsbixzKXtjb25zdCBpPUIuaW50ZXJzZWN0aW9uKGUucDAsZS5wMSxuLnAwLG4ucDEpO2lmKG51bGwhPT1pKXtpZigoczw9MD8xOmkuZGlzdGFuY2UodCkvTWF0aC5hYnMocykpPD10aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKXJldHVybiB0aGlzLl9zZWdMaXN0LmFkZFB0KGkpLG51bGx9dGhpcy5hZGRMaW1pdGVkTWl0cmVKb2luKGUsbixzLHRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpfWFkZE91dHNpZGVUdXJuKHQsZSl7aWYodGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKTx0aGlzLl9kaXN0YW5jZSp5aS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUilyZXR1cm4gdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSxudWxsO3RoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWFpLkpPSU5fTUlUUkU/dGhpcy5hZGRNaXRyZUpvaW4odGhpcy5fczEsdGhpcy5fb2Zmc2V0MCx0aGlzLl9vZmZzZXQxLHRoaXMuX2Rpc3RhbmNlKTp0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1haS5KT0lOX0JFVkVMP3RoaXMuYWRkQmV2ZWxKb2luKHRoaXMuX29mZnNldDAsdGhpcy5fb2Zmc2V0MSk6KGUmJnRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5hZGRDb3JuZXJGaWxsZXQodGhpcy5fczEsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHQsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCkpfWNyZWF0ZVNxdWFyZSh0KXt0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueCt0aGlzLl9kaXN0YW5jZSx0LnkrdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueCt0aGlzLl9kaXN0YW5jZSx0LnktdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueC10aGlzLl9kaXN0YW5jZSx0LnktdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueC10aGlzLl9kaXN0YW5jZSx0LnkrdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWFkZFNlZ21lbnRzKHQsZSl7dGhpcy5fc2VnTGlzdC5hZGRQdHModCxlKX1hZGRGaXJzdFNlZ21lbnQoKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApfWFkZENvcm5lckZpbGxldCh0LGUsbixzLGkpe2NvbnN0IHI9ZS54LXQueCxvPWUueS10Lnk7bGV0IGw9TWF0aC5hdGFuMihvLHIpO2NvbnN0IGE9bi54LXQueCxjPW4ueS10LnksaD1NYXRoLmF0YW4yKGMsYSk7cz09PXEuQ0xPQ0tXSVNFP2w8PWgmJihsKz0yKk1hdGguUEkpOmw+PWgmJihsLT0yKk1hdGguUEkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGREaXJlY3RlZEZpbGxldCh0LGwsaCxzLGkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobil9YWRkTGFzdFNlZ21lbnQoKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDEpfWluaXRTaWRlU2VnbWVudHModCxlLG4pe3RoaXMuX3MxPXQsdGhpcy5fczI9ZSx0aGlzLl9zaWRlPW4sdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyh0LGUpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSxuLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDEpfWFkZExpbWl0ZWRNaXRyZUpvaW4odCxlLG4scyl7Y29uc3QgaT10aGlzLl9zZWcwLnAxLHI9JHQuYW5nbGUoaSx0aGlzLl9zZWcwLnAwKSxvPSR0LmFuZ2xlQmV0d2Vlbk9yaWVudGVkKHRoaXMuX3NlZzAucDAsaSx0aGlzLl9zZWcxLnAxKS8yLGw9JHQubm9ybWFsaXplKHIrbyksYT0kdC5ub3JtYWxpemUobCtNYXRoLlBJKSxjPXMqbixoPW4tYypNYXRoLmFicyhNYXRoLnNpbihvKSksdT1pLngrYypNYXRoLmNvcyhhKSxnPWkueStjKk1hdGguc2luKGEpLGQ9bmV3IG0odSxnKSxfPW5ldyBLdChpLGQpLHA9Xy5wb2ludEFsb25nT2Zmc2V0KDEsaCksZj1fLnBvaW50QWxvbmdPZmZzZXQoMSwtaCk7dGhpcy5fc2lkZT09PWJuLkxFRlQ/KHRoaXMuX3NlZ0xpc3QuYWRkUHQocCksdGhpcy5fc2VnTGlzdC5hZGRQdChmKSk6KHRoaXMuX3NlZ0xpc3QuYWRkUHQoZiksdGhpcy5fc2VnTGlzdC5hZGRQdChwKSl9YWRkRGlyZWN0ZWRGaWxsZXQodCxlLG4scyxpKXtjb25zdCByPXM9PT1xLkNMT0NLV0lTRT8tMToxLG89TWF0aC5hYnMoZS1uKSxsPU1hdGgudHJ1bmMoby90aGlzLl9maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKGw8MSlyZXR1cm4gbnVsbDtjb25zdCBhPW8vbCxjPW5ldyBtO2ZvcihsZXQgbj0wO248bDtuKyspe2NvbnN0IHM9ZStyKm4qYTtjLng9dC54K2kqTWF0aC5jb3MocyksYy55PXQueStpKk1hdGguc2luKHMpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoYyl9fWNvbXB1dGVPZmZzZXRTZWdtZW50KHQsZSxuLHMpe2NvbnN0IGk9ZT09PWJuLkxFRlQ/MTotMSxyPXQucDEueC10LnAwLngsbz10LnAxLnktdC5wMC55LGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9aSpuKnIvbCxjPWkqbipvL2w7cy5wMC54PXQucDAueC1jLHMucDAueT10LnAwLnkrYSxzLnAxLng9dC5wMS54LWMscy5wMS55PXQucDEueSthfWFkZEluc2lkZVR1cm4odCxlKXtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX29mZnNldDAucDAsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHRoaXMuX29mZnNldDEucDEpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKXRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtlbHNlIGlmKHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMCx0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApPHRoaXMuX2Rpc3RhbmNlKnlpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpO2Vsc2V7aWYodGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPjApe2NvbnN0IHQ9bmV3IG0oKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MC5wMS54K3RoaXMuX3MxLngpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDAucDEueSt0aGlzLl9zMS55KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5fc2VnTGlzdC5hZGRQdCh0KTtjb25zdCBlPW5ldyBtKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDEucDAueCt0aGlzLl9zMS54KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQxLnAwLnkrdGhpcy5fczEueSkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQoZSl9ZWxzZSB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX3MxKTt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApfX1jcmVhdGVDaXJjbGUodCl7Y29uc3QgZT1uZXcgbSh0LngrdGhpcy5fZGlzdGFuY2UsdC55KTt0aGlzLl9zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQodCwwLDIqTWF0aC5QSSwtMSx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1hZGRCZXZlbEpvaW4odCxlKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHQucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZS5wMCl9aW5pdCh0KXt0aGlzLl9kaXN0YW5jZT10LHRoaXMuX21heEN1cnZlU2VnbWVudEVycm9yPXQqKDEtTWF0aC5jb3ModGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtLzIpKSx0aGlzLl9zZWdMaXN0PW5ldyBmaSx0aGlzLl9zZWdMaXN0LnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3ByZWNpc2lvbk1vZGVsKSx0aGlzLl9zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KnlpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil9YWRkQ29sbGluZWFyKHQpe3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fczAsdGhpcy5fczEsdGhpcy5fczEsdGhpcy5fczIpO3RoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpPj0yJiYodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09YWkuSk9JTl9CRVZFTHx8dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09YWkuSk9JTl9NSVRSRT8odCYmdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApKTp0aGlzLmFkZENvcm5lckZpbGxldCh0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAscS5DTE9DS1dJU0UsdGhpcy5fZGlzdGFuY2UpKX1jbG9zZVJpbmcoKXt0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWhhc05hcnJvd0NvbmNhdmVBbmdsZSgpe3JldHVybiB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGV9fXlpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SPS4wMDEseWkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPS4wMDEseWkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPTFlLTYseWkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1I9ODA7Y2xhc3MgeGl7Y29uc3RydWN0b3IoKXt4aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9kaXN0YW5jZT0wLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYnVmUGFyYW1zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9idWZQYXJhbXM9ZX1zdGF0aWMgY29weUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09bmV3IG0odFtuXSk7cmV0dXJuIGV9Z2V0T2Zmc2V0Q3VydmUodCxlKXtpZih0aGlzLl9kaXN0YW5jZT1lLDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49ZTwwLHM9TWF0aC5hYnMoZSksaT10aGlzLmdldFNlZ0dlbihzKTt0Lmxlbmd0aDw9MT90aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0saSk6dGhpcy5jb21wdXRlT2Zmc2V0Q3VydmUodCxuLGkpO2NvbnN0IHI9aS5nZXRDb29yZGluYXRlcygpO3JldHVybiBuJiZfdC5yZXZlcnNlKHIpLHJ9Y29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxlLG4pe2NvbnN0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7aWYoZSl7bi5hZGRTZWdtZW50cyh0LCEwKTtjb25zdCBlPW1pLnNpbXBsaWZ5KHQsLXMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVtpXSxlW2ktMV0sYm4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9aS0yO3Q+PTA7dC0tKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9ZWxzZXtuLmFkZFNlZ21lbnRzKHQsITEpO2NvbnN0IGU9bWkuc2ltcGxpZnkodCxzKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbMF0sZVsxXSxibi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpLG4uY2xvc2VSaW5nKCl9Y29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSh0LGUsbil7bGV0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7ZT09PWJuLlJJR0hUJiYocz0tcyk7Y29uc3QgaT1taS5zaW1wbGlmeSh0LHMpLHI9aS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoaVtyLTFdLGlbMF0sZSk7Zm9yKGxldCB0PTE7dDw9cjt0Kyspe2NvbnN0IGU9MSE9PXQ7bi5hZGROZXh0U2VnbWVudChpW3RdLGUpfW4uY2xvc2VSaW5nKCl9Y29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LGUpe2NvbnN0IG49dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSkscz1taS5zaW1wbGlmeSh0LG4pLGk9cy5sZW5ndGgtMTtlLmluaXRTaWRlU2VnbWVudHMoc1swXSxzWzFdLGJuLkxFRlQpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKWUuYWRkTmV4dFNlZ21lbnQoc1t0XSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChzW2ktMV0sc1tpXSk7Y29uc3Qgcj1taS5zaW1wbGlmeSh0LC1uKSxvPXIubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKHJbb10scltvLTFdLGJuLkxFRlQpO2ZvcihsZXQgdD1vLTI7dD49MDt0LS0pZS5hZGROZXh0U2VnbWVudChyW3RdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKHJbMV0sclswXSksZS5jbG9zZVJpbmcoKX1jb21wdXRlUG9pbnRDdXJ2ZSh0LGUpe3N3aXRjaCh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBhaS5DQVBfUk9VTkQ6ZS5jcmVhdGVDaXJjbGUodCk7YnJlYWs7Y2FzZSBhaS5DQVBfU1FVQVJFOmUuY3JlYXRlU3F1YXJlKHQpfX1nZXRMaW5lQ3VydmUodCxlKXtpZih0aGlzLl9kaXN0YW5jZT1lLHRoaXMuaXNMaW5lT2Zmc2V0RW1wdHkoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj1NYXRoLmFicyhlKSxzPXRoaXMuZ2V0U2VnR2VuKG4pO2lmKHQubGVuZ3RoPD0xKXRoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxzKTtlbHNlIGlmKHRoaXMuX2J1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpe2NvbnN0IG49ZTwwO3RoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxuLHMpfWVsc2UgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQscyk7cmV0dXJuIHMuZ2V0Q29vcmRpbmF0ZXMoKX1nZXRCdWZmZXJQYXJhbWV0ZXJzKCl7cmV0dXJuIHRoaXMuX2J1ZlBhcmFtc31zaW1wbGlmeVRvbGVyYW5jZSh0KXtyZXR1cm4gdCp0aGlzLl9idWZQYXJhbXMuZ2V0U2ltcGxpZnlGYWN0b3IoKX1nZXRSaW5nQ3VydmUodCxlLG4pe2lmKHRoaXMuX2Rpc3RhbmNlPW4sdC5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuZ2V0TGluZUN1cnZlKHQsbik7aWYoMD09PW4pcmV0dXJuIHhpLmNvcHlDb29yZGluYXRlcyh0KTtjb25zdCBzPXRoaXMuZ2V0U2VnR2VuKG4pO3JldHVybiB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLHMpLHMuZ2V0Q29vcmRpbmF0ZXMoKX1jb21wdXRlT2Zmc2V0Q3VydmUodCxlLG4pe2NvbnN0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7aWYoZSl7Y29uc3QgZT1taS5zaW1wbGlmeSh0LC1zKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbaV0sZVtpLTFdLGJuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PWktMjt0Pj0wO3QtLSluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfWVsc2V7Y29uc3QgZT1taS5zaW1wbGlmeSh0LHMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVswXSxlWzFdLGJuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PTI7dDw9aTt0Kyspbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1uLmFkZExhc3RTZWdtZW50KCl9aXNMaW5lT2Zmc2V0RW1wdHkodCl7cmV0dXJuIDA9PT10fHx0PDAmJiF0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpfWdldFNlZ0dlbih0KXtyZXR1cm4gbmV3IHlpKHRoaXMuX3ByZWNpc2lvbk1vZGVsLHRoaXMuX2J1ZlBhcmFtcyx0KX19Y2xhc3MgRWl7Y29uc3RydWN0b3IoKXtFaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zdWJncmFwaHM9bnVsbCx0aGlzLl9zZWc9bmV3IEt0O2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmdyYXBocz10fWZpbmRTdGFiYmVkU2VnbWVudHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtmb3IobGV0IG49dGhpcy5fc3ViZ3JhcGhzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5nZXRFbnZlbG9wZSgpO3QueTxpLmdldE1pblkoKXx8dC55PmkuZ2V0TWF4WSgpfHx0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCxzLmdldERpcmVjdGVkRWRnZXMoKSxlKX1yZXR1cm4gZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihJKGFyZ3VtZW50c1syXSxDKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHJzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBpPTA7aTxzLmxlbmd0aC0xO2krKyl7dGhpcy5fc2VnLnAwPXNbaV0sdGhpcy5fc2VnLnAxPXNbaSsxXSx0aGlzLl9zZWcucDAueT50aGlzLl9zZWcucDEueSYmdGhpcy5fc2VnLnJldmVyc2UoKTtpZihNYXRoLm1heCh0aGlzLl9zZWcucDAueCx0aGlzLl9zZWcucDEueCk8dC54KWNvbnRpbnVlO2lmKHRoaXMuX3NlZy5pc0hvcml6b250YWwoKSljb250aW51ZTtpZih0Lnk8dGhpcy5fc2VnLnAwLnl8fHQueT50aGlzLl9zZWcucDEueSljb250aW51ZTtpZihxLmluZGV4KHRoaXMuX3NlZy5wMCx0aGlzLl9zZWcucDEsdCk9PT1xLlJJR0hUKWNvbnRpbnVlO2xldCByPWUuZ2V0RGVwdGgoYm4uTEVGVCk7dGhpcy5fc2VnLnAwLmVxdWFscyhzW2ldKXx8KHI9ZS5nZXREZXB0aChibi5SSUdIVCkpO2NvbnN0IG89bmV3IElpKHRoaXMuX3NlZyxyKTtuLmFkZChvKX19ZWxzZSBpZihJKGFyZ3VtZW50c1syXSxDKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZJKGFyZ3VtZW50c1sxXSxDKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl07Zm9yKGxldCBuPWFyZ3VtZW50c1sxXS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmlzRm9yd2FyZCgpJiZ0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCxzLGUpfX19Z2V0RGVwdGgodCl7Y29uc3QgZT10aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCk7aWYoMD09PWUuc2l6ZSgpKXJldHVybiAwO3JldHVybiB4ZS5taW4oZSkuX2xlZnREZXB0aH19Y2xhc3MgSWl7Y29uc3RydWN0b3IoKXtJaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl91cHdhcmRTZWc9bnVsbCx0aGlzLl9sZWZ0RGVwdGg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl91cHdhcmRTZWc9bmV3IEt0KHQpLHRoaXMuX2xlZnREZXB0aD1lfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7aWYodGhpcy5fdXB3YXJkU2VnLm1pblgoKT49ZS5fdXB3YXJkU2VnLm1heFgoKSlyZXR1cm4gMTtpZih0aGlzLl91cHdhcmRTZWcubWF4WCgpPD1lLl91cHdhcmRTZWcubWluWCgpKXJldHVybi0xO2xldCBuPXRoaXMuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KGUuX3Vwd2FyZFNlZyk7cmV0dXJuIDAhPT1uP246KG49LTEqZS5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy5fdXB3YXJkU2VnKSwwIT09bj9uOnRoaXMuX3Vwd2FyZFNlZy5jb21wYXJlVG8oZS5fdXB3YXJkU2VnKSl9Y29tcGFyZVgodCxlKXtjb25zdCBuPXQucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnQucDEuY29tcGFyZVRvKGUucDEpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX3Vwd2FyZFNlZy50b1N0cmluZygpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19RWkuRGVwdGhTZWdtZW50PUlpO2NsYXNzIE5pe2NvbnN0cnVjdG9yKCl7TmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bnVsbCx0aGlzLl9jdXJ2ZUxpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5fZGlzdGFuY2U9ZSx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bn1hZGRSaW5nU2lkZSh0LGUsbixzLGkpe2lmKDA9PT1lJiZ0Lmxlbmd0aDxndC5NSU5JTVVNX1ZBTElEX1NJWkUpcmV0dXJuIG51bGw7bGV0IHI9cyxvPWk7dC5sZW5ndGg+PWd0Lk1JTklNVU1fVkFMSURfU0laRSYmcS5pc0NDVyh0KSYmKHI9aSxvPXMsbj1ibi5vcHBvc2l0ZShuKSk7Y29uc3QgbD10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0UmluZ0N1cnZlKHQsbixlKTt0aGlzLmFkZEN1cnZlKGwscixvKX1hZGRSaW5nQm90aFNpZGVzKHQsZSl7dGhpcy5hZGRSaW5nU2lkZSh0LGUsYm4uTEVGVCxRdC5FWFRFUklPUixRdC5JTlRFUklPUiksdGhpcy5hZGRSaW5nU2lkZSh0LGUsYm4uUklHSFQsUXQuSU5URVJJT1IsUXQuRVhURVJJT1IpfWFkZFBvaW50KHQpe2lmKHRoaXMuX2Rpc3RhbmNlPD0wKXJldHVybiBudWxsO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLG49dGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuX2Rpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpfWFkZFBvbHlnb24odCl7bGV0IGU9dGhpcy5fZGlzdGFuY2Usbj1ibi5MRUZUO3RoaXMuX2Rpc3RhbmNlPDAmJihlPS10aGlzLl9kaXN0YW5jZSxuPWJuLlJJR0hUKTtjb25zdCBzPXQuZ2V0RXh0ZXJpb3JSaW5nKCksaT1fdC5yZW1vdmVSZXBlYXRlZFBvaW50cyhzLmdldENvb3JkaW5hdGVzKCkpO2lmKHRoaXMuX2Rpc3RhbmNlPDAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KHMsdGhpcy5fZGlzdGFuY2UpKXJldHVybiBudWxsO2lmKHRoaXMuX2Rpc3RhbmNlPD0wJiZpLmxlbmd0aDwzKXJldHVybiBudWxsO3RoaXMuYWRkUmluZ1NpZGUoaSxlLG4sUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe2NvbnN0IGk9dC5nZXRJbnRlcmlvclJpbmdOKHMpLHI9X3QucmVtb3ZlUmVwZWF0ZWRQb2ludHMoaS5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9kaXN0YW5jZT4wJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShpLC10aGlzLl9kaXN0YW5jZSl8fHRoaXMuYWRkUmluZ1NpZGUocixlLGJuLm9wcG9zaXRlKG4pLFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SKX19aXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkodCxlKXtjb25zdCBuPW5ldyBuZSh0WzBdLHRbMV0sdFsyXSkscz1uLmluQ2VudHJlKCk7cmV0dXJuIHoucG9pbnRUb1NlZ21lbnQocyxuLnAwLG4ucDEpPE1hdGguYWJzKGUpfWFkZExpbmVTdHJpbmcodCl7aWYodGhpcy5fY3VydmVCdWlsZGVyLmlzTGluZU9mZnNldEVtcHR5KHRoaXMuX2Rpc3RhbmNlKSlyZXR1cm4gbnVsbDtjb25zdCBlPV90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoX3QuaXNSaW5nKGUpJiYhdGhpcy5fY3VydmVCdWlsZGVyLmdldEJ1ZmZlclBhcmFtZXRlcnMoKS5pc1NpbmdsZVNpZGVkKCkpdGhpcy5hZGRSaW5nQm90aFNpZGVzKGUsdGhpcy5fZGlzdGFuY2UpO2Vsc2V7Y29uc3QgdD10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5fZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUodCxRdC5FWFRFUklPUixRdC5JTlRFUklPUil9fWFkZEN1cnZlKHQsZSxuKXtpZihudWxsPT09dHx8dC5sZW5ndGg8MilyZXR1cm4gbnVsbDtjb25zdCBzPW5ldyBacyh0LG5ldyBCbigwLFF0LkJPVU5EQVJZLGUsbikpO3RoaXMuX2N1cnZlTGlzdC5hZGQocyl9Z2V0Q3VydmVzKCl7cmV0dXJuIHRoaXMuYWRkKHRoaXMuX2lucHV0R2VvbSksdGhpcy5fY3VydmVMaXN0fWFkZCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgcnQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mICQpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGV0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgdXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB5dCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBodCkpdGhyb3cgbmV3IEsodC5nZXRHZW9tZXRyeVR5cGUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX1pc0Vyb2RlZENvbXBsZXRlbHkodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihuLmxlbmd0aDw0KXJldHVybiBlPDA7aWYoND09PW4ubGVuZ3RoKXJldHVybiB0aGlzLmlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KG4sZSk7Y29uc3Qgcz10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPU1hdGgubWluKHMuZ2V0SGVpZ2h0KCkscy5nZXRXaWR0aCgpKTtyZXR1cm4gZTwwJiYyKk1hdGguYWJzKGUpPml9YWRkQ29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19fWNsYXNzIHdpe2NvbnN0cnVjdG9yKCl7d2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZWRnZU1hcD1uZXcgV24sdGhpcy5fZWRnZUxpc3Q9bnVsbCx0aGlzLl9wdEluQXJlYUxvY2F0aW9uPVtRdC5OT05FLFF0Lk5PTkVdfWdldE5leHRDVyh0KXt0aGlzLmdldEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5pbmRleE9mKHQpO2xldCBuPWUtMTtyZXR1cm4gMD09PWUmJihuPXRoaXMuX2VkZ2VMaXN0LnNpemUoKS0xKSx0aGlzLl9lZGdlTGlzdC5nZXQobil9cHJvcGFnYXRlU2lkZUxhYmVscyh0KXtsZXQgZT1RdC5OT05FO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLmdldExhYmVsKCk7cy5pc0FyZWEodCkmJnMuZ2V0TG9jYXRpb24odCxibi5MRUZUKSE9PVF0Lk5PTkUmJihlPXMuZ2V0TG9jYXRpb24odCxibi5MRUZUKSl9aWYoZT09PVF0Lk5PTkUpcmV0dXJuIG51bGw7bGV0IG49ZTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtpZihpLmdldExvY2F0aW9uKHQsYm4uT04pPT09UXQuTk9ORSYmaS5zZXRMb2NhdGlvbih0LGJuLk9OLG4pLGkuaXNBcmVhKHQpKXtjb25zdCBlPWkuZ2V0TG9jYXRpb24odCxibi5MRUZUKSxyPWkuZ2V0TG9jYXRpb24odCxibi5SSUdIVCk7aWYociE9PVF0Lk5PTkUpe2lmKHIhPT1uKXRocm93IG5ldyBpcyhcInNpZGUgbG9jYXRpb24gY29uZmxpY3RcIixzLmdldENvb3JkaW5hdGUoKSk7ZT09PVF0Lk5PTkUmJmcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlIChhdCBcIitzLmdldENvb3JkaW5hdGUoKStcIilcIiksbj1lfWVsc2UgZy5pc1RydWUoaS5nZXRMb2NhdGlvbih0LGJuLkxFRlQpPT09UXQuTk9ORSxcImZvdW5kIHNpbmdsZSBudWxsIHNpZGVcIiksaS5zZXRMb2NhdGlvbih0LGJuLlJJR0hULG4pLGkuc2V0TG9jYXRpb24odCxibi5MRUZULG4pfX19Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9dGhpcy5pdGVyYXRvcigpO2lmKCF0Lmhhc05leHQoKSlyZXR1cm4gbnVsbDtyZXR1cm4gdC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpfXByaW50KHQpe1kub3V0LnByaW50bG4oXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHQpe3JldHVybiB0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHQuZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLmNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQoMCl9Y2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCh0KXtjb25zdCBlPXRoaXMuZ2V0RWRnZXMoKTtpZihlLnNpemUoKTw9MClyZXR1cm4hMDtjb25zdCBuPWUuc2l6ZSgpLTEscz1lLmdldChuKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQsYm4uTEVGVCk7Zy5pc1RydWUocyE9PVF0Lk5PTkUsXCJGb3VuZCB1bmxhYmVsbGVkIGFyZWEgZWRnZVwiKTtsZXQgaT1zO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldExhYmVsKCk7Zy5pc1RydWUobi5pc0FyZWEodCksXCJGb3VuZCBub24tYXJlYSBlZGdlXCIpO2NvbnN0IHM9bi5nZXRMb2NhdGlvbih0LGJuLkxFRlQpLHI9bi5nZXRMb2NhdGlvbih0LGJuLlJJR0hUKTtpZihzPT09cilyZXR1cm4hMTtpZihyIT09aSlyZXR1cm4hMTtpPXN9cmV0dXJuITB9ZmluZEluZGV4KHQpe3RoaXMuaXRlcmF0b3IoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VMaXN0LnNpemUoKTtlKyspe2lmKHRoaXMuX2VkZ2VMaXN0LmdldChlKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKCl9Z2V0RWRnZXMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2VkZ2VMaXN0JiYodGhpcy5fZWRnZUxpc3Q9bmV3IEwodGhpcy5fZWRnZU1hcC52YWx1ZXMoKSkpLHRoaXMuX2VkZ2VMaXN0fWdldExvY2F0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XT09PVF0Lk5PTkUmJih0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdPVplLmxvY2F0ZShlLG5bdF0uZ2V0R2VvbWV0cnkoKSkpLHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF19dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB2O3QuYXBwZW5kKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpLHQuYXBwZW5kKFwiXFxuXCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QuYXBwZW5kKG4pLHQuYXBwZW5kKFwiXFxuXCIpfXJldHVybiB0LnRvU3RyaW5nKCl9Y29tcHV0ZUVkZ2VFbmRMYWJlbHModCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmNvbXB1dGVMYWJlbCh0KX19Y29tcHV0ZUxhYmVsbGluZyh0KXt0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHRbMF0uZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMCksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDEpO2NvbnN0IGU9WyExLCExXTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKS5nZXRMYWJlbCgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspbi5pc0xpbmUodCkmJm4uZ2V0TG9jYXRpb24odCk9PT1RdC5CT1VOREFSWSYmKGVbdF09ITApfWZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5nZXRMYWJlbCgpO2ZvcihsZXQgbj0wO248MjtuKyspaWYoaS5pc0FueU51bGwobikpe2xldCByPVF0Lk5PTkU7aWYoZVtuXSlyPVF0LkVYVEVSSU9SO2Vsc2V7Y29uc3QgZT1zLmdldENvb3JkaW5hdGUoKTtyPXRoaXMuZ2V0TG9jYXRpb24obixlLHQpfWkuc2V0QWxsTG9jYXRpb25zSWZOdWxsKG4scil9fX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fZWRnZU1hcC5zaXplKCl9aW5zZXJ0RWRnZUVuZCh0LGUpe3RoaXMuX2VkZ2VNYXAucHV0KHQsZSksdGhpcy5fZWRnZUxpc3Q9bnVsbH19bGV0IENpPWNsYXNzIGV4dGVuZHMgd2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLENpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdD1udWxsLHRoaXMuX2xhYmVsPW51bGwsdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HPTEsdGhpcy5fTElOS0lOR19UT19PVVRHT0lORz0yfWxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl7dGhpcy5nZXRSZXN1bHRBcmVhRWRnZXMoKTtsZXQgdD1udWxsLGU9bnVsbCxuPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztmb3IobGV0IHM9MDtzPHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCk7cysrKXtjb25zdCBpPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQocykscj1pLmdldFN5bSgpO2lmKGkuZ2V0TGFiZWwoKS5pc0FyZWEoKSlzd2l0Y2gobnVsbD09PXQmJmkuaXNJblJlc3VsdCgpJiYodD1pKSxuKXtjYXNlIHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORzppZighci5pc0luUmVzdWx0KCkpY29udGludWU7ZT1yLG49dGhpcy5fTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc6aWYoIWkuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2Uuc2V0TmV4dChpKSxuPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlOR319aWYobj09PXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcpe2lmKG51bGw9PT10KXRocm93IG5ldyBpcyhcIm5vIG91dGdvaW5nIGRpckVkZ2UgZm91bmRcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7Zy5pc1RydWUodC5pc0luUmVzdWx0KCksXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksZS5zZXROZXh0KHQpfX1pbnNlcnQodCl7Y29uc3QgZT10O3RoaXMuaW5zZXJ0RWRnZUVuZChlLGUpfWdldFJpZ2h0bW9zdEVkZ2UoKXtjb25zdCB0PXRoaXMuZ2V0RWRnZXMoKSxlPXQuc2l6ZSgpO2lmKGU8MSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0KDApO2lmKDE9PT1lKXJldHVybiBuO2NvbnN0IHM9dC5nZXQoZS0xKSxpPW4uZ2V0UXVhZHJhbnQoKSxyPXMuZ2V0UXVhZHJhbnQoKTtyZXR1cm4gQ24uaXNOb3J0aGVybihpKSYmQ24uaXNOb3J0aGVybihyKT9uOkNuLmlzTm9ydGhlcm4oaSl8fENuLmlzTm9ydGhlcm4ocik/MCE9PW4uZ2V0RHkoKT9uOjAhPT1zLmdldER5KCk/czooZy5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHR3byBob3Jpem9udGFsIGVkZ2VzIGluY2lkZW50IG9uIG5vZGVcIiksbnVsbCk6c31wcmludCh0KXtZLm91dC5wcmludGxuKFwiRGlyZWN0ZWRFZGdlU3RhcjogXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QucHJpbnQoXCJvdXQgXCIpLG4ucHJpbnQodCksdC5wcmludGxuKCksdC5wcmludChcImluIFwiKSxuLmdldFN5bSgpLnByaW50KHQpLHQucHJpbnRsbigpfX1nZXRSZXN1bHRBcmVhRWRnZXMoKXtpZihudWxsIT09dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0KXJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q7dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0PW5ldyBMO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpOyhlLmlzSW5SZXN1bHQoKXx8ZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpJiZ0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuYWRkKGUpfXJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3R9dXBkYXRlTGFiZWxsaW5nKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldExhYmVsKCk7bi5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0LmdldExvY2F0aW9uKDApKSxuLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQuZ2V0TG9jYXRpb24oMSkpfX1saW5rQWxsRGlyZWN0ZWRFZGdlcygpe3RoaXMuZ2V0RWRnZXMoKTtsZXQgdD1udWxsLGU9bnVsbDtmb3IobGV0IG49dGhpcy5fZWRnZUxpc3Quc2l6ZSgpLTE7bj49MDtuLS0pe2NvbnN0IHM9dGhpcy5fZWRnZUxpc3QuZ2V0KG4pLGk9cy5nZXRTeW0oKTtudWxsPT09ZSYmKGU9aSksbnVsbCE9PXQmJmkuc2V0TmV4dCh0KSx0PXN9ZS5zZXROZXh0KHQpfWNvbXB1dGVEZXB0aHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLmZpbmRJbmRleCh0KSxuPXQuZ2V0RGVwdGgoYm4uTEVGVCkscz10LmdldERlcHRoKGJuLlJJR0hUKSxpPXRoaXMuY29tcHV0ZURlcHRocyhlKzEsdGhpcy5fZWRnZUxpc3Quc2l6ZSgpLG4pO2lmKHRoaXMuY29tcHV0ZURlcHRocygwLGUsaSkhPT1zKXRocm93IG5ldyBpcyhcImRlcHRoIG1pc21hdGNoIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtsZXQgZT1hcmd1bWVudHNbMl07Zm9yKGxldCBuPWFyZ3VtZW50c1swXTtuPHQ7bisrKXtjb25zdCB0PXRoaXMuX2VkZ2VMaXN0LmdldChuKTt0LnNldEVkZ2VEZXB0aHMoYm4uUklHSFQsZSksZT10LmdldERlcHRoKGJuLkxFRlQpfXJldHVybiBlfX1tZXJnZVN5bUxhYmVscygpe2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuZ2V0TGFiZWwoKS5tZXJnZShlLmdldFN5bSgpLmdldExhYmVsKCkpfX1saW5rTWluaW1hbERpcmVjdGVkRWRnZXModCl7bGV0IGU9bnVsbCxuPW51bGwscz10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7Zm9yKGxldCBpPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCktMTtpPj0wO2ktLSl7Y29uc3Qgcj10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KGkpLG89ci5nZXRTeW0oKTtzd2l0Y2gobnVsbD09PWUmJnIuZ2V0RWRnZVJpbmcoKT09PXQmJihlPXIpLHMpe2Nhc2UgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKG8uZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bj1vLHM9dGhpcy5fTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc6aWYoci5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuLnNldE5leHRNaW4ocikscz10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkd9fXM9PT10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HJiYoZy5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIGZvciBmaXJzdCBvdXRnb2luZyBkaXJFZGdlXCIpLGcuaXNUcnVlKGUuZ2V0RWRnZVJpbmcoKT09PXQsXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksbi5zZXROZXh0TWluKGUpKX1nZXRPdXRnb2luZ0RlZ3JlZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5pc0luUmVzdWx0KCkmJnQrK31yZXR1cm4gdH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9MDtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0RWRnZVJpbmcoKT09PXQmJmUrK31yZXR1cm4gZX19Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9ZmluZENvdmVyZWRMaW5lRWRnZXMoKXtsZXQgdD1RdC5OT05FO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRTeW0oKTtpZighbi5pc0xpbmVFZGdlKCkpe2lmKG4uaXNJblJlc3VsdCgpKXt0PVF0LklOVEVSSU9SO2JyZWFrfWlmKHMuaXNJblJlc3VsdCgpKXt0PVF0LkVYVEVSSU9SO2JyZWFrfX19aWYodD09PVF0Lk5PTkUpcmV0dXJuIG51bGw7bGV0IGU9dDtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0U3ltKCk7bi5pc0xpbmVFZGdlKCk/bi5nZXRFZGdlKCkuc2V0Q292ZXJlZChlPT09UXQuSU5URVJJT1IpOihuLmlzSW5SZXN1bHQoKSYmKGU9UXQuRVhURVJJT1IpLHMuaXNJblJlc3VsdCgpJiYoZT1RdC5JTlRFUklPUikpfX1jb21wdXRlTGFiZWxsaW5nKHQpe3N1cGVyLmNvbXB1dGVMYWJlbGxpbmcuY2FsbCh0aGlzLHQpLHRoaXMuX2xhYmVsPW5ldyBCbihRdC5OT05FKTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKS5nZXRFZGdlKCkuZ2V0TGFiZWwoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKXtjb25zdCBuPWUuZ2V0TG9jYXRpb24odCk7biE9PVF0LklOVEVSSU9SJiZuIT09UXQuQk9VTkRBUll8fHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsUXQuSU5URVJJT1IpfX19fTtjbGFzcyBTaSBleHRlbmRzIG9ze2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgZXModCxuZXcgQ2kpfX1jbGFzcyBMaXtjb25zdHJ1Y3Rvcigpe0xpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsLHRoaXMuX29yaWVudGF0aW9uPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXQsdGhpcy5fb3JpZW50YXRpb249TGkub3JpZW50YXRpb24odCl9c3RhdGljIG9yaWVudGF0aW9uKHQpe3JldHVybiAxPT09X3QuaW5jcmVhc2luZ0RpcmVjdGlvbih0KX1zdGF0aWMgY29tcGFyZU9yaWVudGVkKHQsZSxuLHMpe2NvbnN0IGk9ZT8xOi0xLHI9cz8xOi0xLG89ZT90Lmxlbmd0aDotMSxsPXM/bi5sZW5ndGg6LTE7bGV0IGE9ZT8wOnQubGVuZ3RoLTEsYz1zPzA6bi5sZW5ndGgtMTtmb3IoOzspe2NvbnN0IGU9dFthXS5jb21wYXJlVG8obltjXSk7aWYoMCE9PWUpcmV0dXJuIGU7YSs9aSxjKz1yO2NvbnN0IHM9YT09PW8saD1jPT09bDtpZihzJiYhaClyZXR1cm4tMTtpZighcyYmaClyZXR1cm4gMTtpZihzJiZoKXJldHVybiAwfX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiBMaS5jb21wYXJlT3JpZW50ZWQodGhpcy5fcHRzLHRoaXMuX29yaWVudGF0aW9uLGUuX3B0cyxlLl9vcmllbnRhdGlvbil9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBUaXtjb25zdHJ1Y3Rvcigpe1RpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2VkZ2VzPW5ldyBMLHRoaXMuX29jYU1hcD1uZXcgV259cHJpbnQodCl7dC5wcmludChcIk1VTFRJTElORVNUUklORyAoIFwiKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspe2NvbnN0IG49dGhpcy5fZWRnZXMuZ2V0KGUpO2U+MCYmdC5wcmludChcIixcIiksdC5wcmludChcIihcIik7Y29uc3Qgcz1uLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTxzLmxlbmd0aDtlKyspZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KHNbZV0ueCtcIiBcIitzW2VdLnkpO3QucHJpbnRsbihcIilcIil9dC5wcmludChcIikgIFwiKX1hZGRBbGwodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpfWZpbmRFZGdlSW5kZXgodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlcy5zaXplKCk7ZSsrKWlmKHRoaXMuX2VkZ2VzLmdldChlKS5lcXVhbHModCkpcmV0dXJuIGU7cmV0dXJuLTF9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31nZXQodCl7cmV0dXJuIHRoaXMuX2VkZ2VzLmdldCh0KX1maW5kRXF1YWxFZGdlKHQpe2NvbnN0IGU9bmV3IExpKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIHRoaXMuX29jYU1hcC5nZXQoZSl9YWRkKHQpe3RoaXMuX2VkZ2VzLmFkZCh0KTtjb25zdCBlPW5ldyBMaSh0LmdldENvb3JkaW5hdGVzKCkpO3RoaXMuX29jYU1hcC5wdXQoZSx0KX19Y2xhc3MgUml7cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7fWlzRG9uZSgpe319Y2xhc3MgUGl7Y29uc3RydWN0b3IoKXtQaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5faGFzUHJvcGVyPSExLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSExLHRoaXMuX2hhc0ludGVyaW9yPSExLHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb249bnVsbCx0aGlzLm51bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtVGVzdHM9MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saT10fXN0YXRpYyBpc0FkamFjZW50U2VnbWVudHModCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9aXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2lmKHQ9PT1uJiYxPT09dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKFBpLmlzQWRqYWNlbnRTZWdtZW50cyhlLHMpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7Y29uc3Qgbj10LnNpemUoKS0xO2lmKDA9PT1lJiZzPT09bnx8MD09PXMmJmU9PT1uKXJldHVybiEwfX1yZXR1cm4hMX1nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpe3JldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH1oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcn1nZXRMaW5lSW50ZXJzZWN0b3IoKXtyZXR1cm4gdGhpcy5fbGl9aGFzUHJvcGVySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3Blcn1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnMrKyx0aGlzLl9oYXNJbnRlcmlvcj0hMCksdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsdC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSksdGhpcy5fbGkuaXNQcm9wZXIoKSYmKHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucysrLHRoaXMuX2hhc1Byb3Blcj0hMCx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKX1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiExfWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyaW9yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltSaV19fWNsYXNzIE9pe2NvbnN0cnVjdG9yKCl7T2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fYnVmUGFyYW1zPW51bGwsdGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fd29ya2luZ05vZGVyPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2VkZ2VMaXN0PW5ldyBUaTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9idWZQYXJhbXM9dH1zdGF0aWMgZGVwdGhEZWx0YSh0KXtjb25zdCBlPXQuZ2V0TG9jYXRpb24oMCxibi5MRUZUKSxuPXQuZ2V0TG9jYXRpb24oMCxibi5SSUdIVCk7cmV0dXJuIGU9PT1RdC5JTlRFUklPUiYmbj09PVF0LkVYVEVSSU9SPzE6ZT09PVF0LkVYVEVSSU9SJiZuPT09UXQuSU5URVJJT1I/LTE6MH1zdGF0aWMgY29udmVydFNlZ1N0cmluZ3ModCl7Y29uc3QgZT1uZXcgTHQsbj1uZXcgTDtmb3IoO3QuaGFzTmV4dCgpOyl7Y29uc3Qgcz10Lm5leHQoKSxpPWUuY3JlYXRlTGluZVN0cmluZyhzLmdldENvb3JkaW5hdGVzKCkpO24uYWRkKGkpfXJldHVybiBlLmJ1aWxkR2VvbWV0cnkobil9c2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbD10fWluc2VydFVuaXF1ZUVkZ2UodCl7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXtjb25zdCBuPWUuZ2V0TGFiZWwoKTtsZXQgcz10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwocz1uZXcgQm4odC5nZXRMYWJlbCgpKSxzLmZsaXAoKSksbi5tZXJnZShzKTtjb25zdCBpPU9pLmRlcHRoRGVsdGEocykscj1lLmdldERlcHRoRGVsdGEoKStpO2Uuc2V0RGVwdGhEZWx0YShyKX1lbHNlIHRoaXMuX2VkZ2VMaXN0LmFkZCh0KSx0LnNldERlcHRoRGVsdGEoT2kuZGVwdGhEZWx0YSh0LmdldExhYmVsKCkpKX1idWlsZFN1YmdyYXBocyh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCksaT10LmdldFJpZ2h0bW9zdENvb3JkaW5hdGUoKSxyPW5ldyBFaShuKS5nZXREZXB0aChpKTt0LmNvbXB1dGVEZXB0aChyKSx0LmZpbmRSZXN1bHRFZGdlcygpLG4uYWRkKHQpLGUuYWRkKHQuZ2V0RGlyZWN0ZWRFZGdlcygpLHQuZ2V0Tm9kZXMoKSl9fWNyZWF0ZVN1YmdyYXBocyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10LmdldE5vZGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYoIXQuaXNWaXNpdGVkKCkpe2NvbnN0IG49bmV3IHVpO24uY3JlYXRlKHQpLGUuYWRkKG4pfX1yZXR1cm4geGUuc29ydChlLHhlLnJldmVyc2VPcmRlcigpKSxlfWNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbigpfWdldE5vZGVyKHQpe2lmKG51bGwhPT10aGlzLl93b3JraW5nTm9kZXIpcmV0dXJuIHRoaXMuX3dvcmtpbmdOb2Rlcjtjb25zdCBlPW5ldyB0aSxuPW5ldyBqdDtyZXR1cm4gbi5zZXRQcmVjaXNpb25Nb2RlbCh0KSxlLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuZXcgUGkobikpLGV9YnVmZmVyKHQsZSl7bGV0IG49dGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsO251bGw9PT1uJiYobj10LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpO2NvbnN0IHM9bmV3IHhpKG4sdGhpcy5fYnVmUGFyYW1zKSxpPW5ldyBOaSh0LGUscykuZ2V0Q3VydmVzKCk7aWYoaS5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3RoaXMuY29tcHV0ZU5vZGVkRWRnZXMoaSxuKSx0aGlzLl9ncmFwaD1uZXcgbHMobmV3IFNpKSx0aGlzLl9ncmFwaC5hZGRFZGdlcyh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKTtjb25zdCByPXRoaXMuY3JlYXRlU3ViZ3JhcGhzKHRoaXMuX2dyYXBoKSxvPW5ldyBwaSh0aGlzLl9nZW9tRmFjdCk7dGhpcy5idWlsZFN1YmdyYXBocyhyLG8pO2NvbnN0IGw9by5nZXRQb2x5Z29ucygpO2lmKGwuc2l6ZSgpPD0wKXJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShsKX1jb21wdXRlTm9kZWRFZGdlcyh0LGUpe2NvbnN0IG49dGhpcy5nZXROb2RlcihlKTtuLmNvbXB1dGVOb2Rlcyh0KTtmb3IobGV0IHQ9bi5nZXROb2RlZFN1YnN0cmluZ3MoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKTtpZigyPT09bi5sZW5ndGgmJm5bMF0uZXF1YWxzMkQoblsxXSkpY29udGludWU7Y29uc3Qgcz1lLmdldERhdGEoKSxpPW5ldyB0cyhlLmdldENvb3JkaW5hdGVzKCksbmV3IEJuKHMpKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2UoaSl9fXNldE5vZGVyKHQpe3RoaXMuX3dvcmtpbmdOb2Rlcj10fX1jbGFzcyB2aXtjb25zdHJ1Y3Rvcigpe3ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9zZWdTdHJpbmdzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2VnU3RyaW5ncz10fWNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKGVbMF0sdGhpcy5fc2VnU3RyaW5ncyksdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhlW2UubGVuZ3RoLTFdLHRoaXMuX3NlZ1N0cmluZ3MpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT1hcmd1bWVudHNbMV0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MTtlPG4ubGVuZ3RoLTE7ZSsrKWlmKG5bZV0uZXF1YWxzKHQpKXRocm93IG5ldyBoKFwiZm91bmQgZW5kcHQvaW50ZXJpb3IgcHQgaW50ZXJzZWN0aW9uIGF0IGluZGV4IFwiK2UrXCIgOnB0IFwiK3QpfX19Y2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKTt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKGUsbil9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb29yZGluYXRlcygpLHM9ZS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGgtMTtpKyspZm9yKGxldCBuPTA7bjxzLmxlbmd0aC0xO24rKyl0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsaSxlLG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX2xpLmlzUHJvcGVyKCl8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksaSxyKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSxvLGwpKSl0aHJvdyBuZXcgaChcImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYXQgXCIraStcIi1cIityK1wiIGFuZCBcIitvK1wiLVwiK2wpfX1jaGVja1ZhbGlkKCl7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrQ29sbGFwc2VzKCl9Y2hlY2tDb2xsYXBzZXMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmNoZWNrQ29sbGFwc2VzKGUpfWVsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyl0aGlzLmNoZWNrQ29sbGFwc2UodFtlXSx0W2UrMV0sdFtlKzJdKX19aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspe2NvbnN0IGk9dC5nZXRJbnRlcnNlY3Rpb24ocyk7aWYoIWkuZXF1YWxzKGUpJiYhaS5lcXVhbHMobikpcmV0dXJuITB9cmV0dXJuITF9Y2hlY2tDb2xsYXBzZSh0LGUsbil7aWYodC5lcXVhbHMobikpdGhyb3cgbmV3IGgoXCJmb3VuZCBub24tbm9kZWQgY29sbGFwc2UgYXQgXCIrdmkuZmFjdC5jcmVhdGVMaW5lU3RyaW5nKFt0LGUsbl0pKX19dmkuZmFjdD1uZXcgTHQ7Y2xhc3MgYml7Y29uc3RydWN0b3IoKXtiaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1udWxsLHRoaXMuX3B0PW51bGwsdGhpcy5fb3JpZ2luYWxQdD1udWxsLHRoaXMuX3B0U2NhbGVkPW51bGwsdGhpcy5fcDBTY2FsZWQ9bnVsbCx0aGlzLl9wMVNjYWxlZD1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fbWlueD1udWxsLHRoaXMuX21heHg9bnVsbCx0aGlzLl9taW55PW51bGwsdGhpcy5fbWF4eT1udWxsLHRoaXMuX2Nvcm5lcj1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLl9zYWZlRW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodGhpcy5fb3JpZ2luYWxQdD10LHRoaXMuX3B0PXQsdGhpcy5fc2NhbGVGYWN0b3I9ZSx0aGlzLl9saT1uLGU8PTApdGhyb3cgbmV3IHMoXCJTY2FsZSBmYWN0b3IgbXVzdCBiZSBub24temVyb1wiKTsxIT09ZSYmKHRoaXMuX3B0PW5ldyBtKHRoaXMuc2NhbGUodC54KSx0aGlzLnNjYWxlKHQueSkpLHRoaXMuX3AwU2NhbGVkPW5ldyBtLHRoaXMuX3AxU2NhbGVkPW5ldyBtKSx0aGlzLmluaXRDb3JuZXJzKHRoaXMuX3B0KX1pbnRlcnNlY3RzU2NhbGVkKHQsZSl7Y29uc3Qgbj1NYXRoLm1pbih0LngsZS54KSxzPU1hdGgubWF4KHQueCxlLngpLGk9TWF0aC5taW4odC55LGUueSkscj1NYXRoLm1heCh0LnksZS55KSxvPXRoaXMuX21heHg8bnx8dGhpcy5fbWlueD5zfHx0aGlzLl9tYXh5PGl8fHRoaXMuX21pbnk+cjtpZihvKXJldHVybiExO2NvbnN0IGw9dGhpcy5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHQsZSk7cmV0dXJuIGcuaXNUcnVlKCEobyYmbCksXCJGb3VuZCBiYWQgZW52ZWxvcGUgdGVzdFwiKSxsfWluaXRDb3JuZXJzKHQpe2NvbnN0IGU9LjU7dGhpcy5fbWlueD10LngtZSx0aGlzLl9tYXh4PXQueCtlLHRoaXMuX21pbnk9dC55LWUsdGhpcy5fbWF4eT10LnkrZSx0aGlzLl9jb3JuZXJbMF09bmV3IG0odGhpcy5fbWF4eCx0aGlzLl9tYXh5KSx0aGlzLl9jb3JuZXJbMV09bmV3IG0odGhpcy5fbWlueCx0aGlzLl9tYXh5KSx0aGlzLl9jb3JuZXJbMl09bmV3IG0odGhpcy5fbWlueCx0aGlzLl9taW55KSx0aGlzLl9jb3JuZXJbM109bmV3IG0odGhpcy5fbWF4eCx0aGlzLl9taW55KX1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuIDE9PT10aGlzLl9zY2FsZUZhY3Rvcj90aGlzLmludGVyc2VjdHNTY2FsZWQodCxlKToodGhpcy5jb3B5U2NhbGVkKHQsdGhpcy5fcDBTY2FsZWQpLHRoaXMuY29weVNjYWxlZChlLHRoaXMuX3AxU2NhbGVkKSx0aGlzLmludGVyc2VjdHNTY2FsZWQodGhpcy5fcDBTY2FsZWQsdGhpcy5fcDFTY2FsZWQpKX1zY2FsZSh0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KnRoaXMuX3NjYWxlRmFjdG9yKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX29yaWdpbmFsUHR9Y29weVNjYWxlZCh0LGUpe2UueD10aGlzLnNjYWxlKHQueCksZS55PXRoaXMuc2NhbGUodC55KX1nZXRTYWZlRW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fc2FmZUVudil7Y29uc3QgdD1iaS5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SL3RoaXMuX3NjYWxlRmFjdG9yO3RoaXMuX3NhZmVFbnY9bmV3IE8odGhpcy5fb3JpZ2luYWxQdC54LXQsdGhpcy5fb3JpZ2luYWxQdC54K3QsdGhpcy5fb3JpZ2luYWxQdC55LXQsdGhpcy5fb3JpZ2luYWxQdC55K3QpfXJldHVybiB0aGlzLl9zYWZlRW52fWludGVyc2VjdHNQaXhlbENsb3N1cmUodCxlKXtyZXR1cm4gdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzBdLHRoaXMuX2Nvcm5lclsxXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsxXSx0aGlzLl9jb3JuZXJbMl0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMl0sdGhpcy5fY29ybmVyWzNdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzNdLHRoaXMuX2Nvcm5lclswXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkpKX1pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHQsZSl7bGV0IG49ITEscz0hMTtyZXR1cm4gdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzBdLHRoaXMuX2Nvcm5lclsxXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzFdLHRoaXMuX2Nvcm5lclsyXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJihuPSEwKSx0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMl0sdGhpcy5fY29ybmVyWzNdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHM9ITApLHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclszXSx0aGlzLl9jb3JuZXJbMF0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KCEoIW58fCFzKXx8KCEhdC5lcXVhbHModGhpcy5fcHQpfHwhIWUuZXF1YWxzKHRoaXMuX3B0KSkpKSkpfWFkZFNuYXBwZWROb2RlKHQsZSl7Y29uc3Qgbj10LmdldENvb3JkaW5hdGUoZSkscz10LmdldENvb3JkaW5hdGUoZSsxKTtyZXR1cm4hIXRoaXMuaW50ZXJzZWN0cyhuLHMpJiYodC5hZGRJbnRlcnNlY3Rpb24odGhpcy5nZXRDb29yZGluYXRlKCksZSksITApfX1iaS5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SPS43NTtjbGFzcyBNaXtjb25zdHJ1Y3Rvcigpe01pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuc2VsZWN0ZWRTZWdtZW50PW5ldyBLdH1zZWxlY3QoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07YXJndW1lbnRzWzBdLmdldExpbmVTZWdtZW50KHQsdGhpcy5zZWxlY3RlZFNlZ21lbnQpLHRoaXMuc2VsZWN0KHRoaXMuc2VsZWN0ZWRTZWdtZW50KX19fWNsYXNzIERpe2NvbnN0cnVjdG9yKCl7RGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbmRleD10fXNuYXAoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc25hcCh0LG51bGwsLTEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPXQuZ2V0U2FmZUVudmVsb3BlKCksaT1uZXcgQWkodCxlLG4pO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeShzLG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRGVdfXZpc2l0SXRlbSh0KXt0LnNlbGVjdChzLGkpfX0pLGkuaXNOb2RlQWRkZWQoKX19fWNsYXNzIEFpIGV4dGVuZHMgTWl7Y29uc3RydWN0b3IoKXtzdXBlcigpLEFpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2hvdFBpeGVsPW51bGwsdGhpcy5fcGFyZW50RWRnZT1udWxsLHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXg9bnVsbCx0aGlzLl9pc05vZGVBZGRlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ob3RQaXhlbD10LHRoaXMuX3BhcmVudEVkZ2U9ZSx0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4PW59aXNOb2RlQWRkZWQoKXtyZXR1cm4gdGhpcy5faXNOb2RlQWRkZWR9c2VsZWN0KCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEtzKSlyZXR1cm4gc3VwZXIuc2VsZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0uZ2V0Q29udGV4dCgpO2lmKHRoaXMuX3BhcmVudEVkZ2U9PT1lJiYodD09PXRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXh8fHQrMT09PXRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXgpKXJldHVybiBudWxsO3RoaXMuX2lzTm9kZUFkZGVkfD10aGlzLl9ob3RQaXhlbC5hZGRTbmFwcGVkTm9kZShlLHQpfX19RGkuSG90UGl4ZWxTbmFwQWN0aW9uPUFpO2NsYXNzIEZpe2NvbnN0cnVjdG9yKCl7RmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bnVsbCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saT10LHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucz1uZXcgTH1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSl7Zm9yKGxldCB0PTA7dDx0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTt0KyspdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24odCkpO3QuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpfX1pc0RvbmUoKXtyZXR1cm4hMX1nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltSaV19fWNsYXNzIEdpe2NvbnN0cnVjdG9yKCl7R2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcG09bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fbm9kZXI9bnVsbCx0aGlzLl9wb2ludFNuYXBwZXI9bnVsbCx0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wbT10LHRoaXMuX2xpPW5ldyBqdCx0aGlzLl9saS5zZXRQcmVjaXNpb25Nb2RlbCh0KSx0aGlzLl9zY2FsZUZhY3Rvcj10LmdldFNjYWxlKCl9Y2hlY2tDb3JyZWN0bmVzcyh0KXtjb25zdCBlPVpzLmdldE5vZGVkU3Vic3RyaW5ncyh0KSxzPW5ldyB2aShlKTt0cnl7cy5jaGVja1ZhbGlkKCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgdDt0LnByaW50U3RhY2tUcmFjZSgpfX1nZXROb2RlZFN1YnN0cmluZ3MoKXtyZXR1cm4gWnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncyl9c25hcFJvdW5kKHQsZSl7Y29uc3Qgbj10aGlzLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyhuKSx0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyh0KX1maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsZSl7Y29uc3Qgbj1uZXcgRmkoZSk7cmV0dXJuIHRoaXMuX25vZGVyLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuKSx0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXModCksbi5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKX1jb21wdXRlVmVydGV4U25hcHMoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyhlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFpzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcz1uZXcgYmkoZVtuXSx0aGlzLl9zY2FsZUZhY3Rvcix0aGlzLl9saSk7dGhpcy5fcG9pbnRTbmFwcGVyLnNuYXAocyx0LG4pJiZ0LmFkZEludGVyc2VjdGlvbihlW25dLG4pfX19Y29tcHV0ZU5vZGVzKHQpe3RoaXMuX25vZGVkU2VnU3RyaW5ncz10LHRoaXMuX25vZGVyPW5ldyB0aSx0aGlzLl9wb2ludFNuYXBwZXI9bmV3IERpKHRoaXMuX25vZGVyLmdldEluZGV4KCkpLHRoaXMuc25hcFJvdW5kKHQsdGhpcy5fbGkpfWNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPW5ldyBiaSh0LHRoaXMuX3NjYWxlRmFjdG9yLHRoaXMuX2xpKTt0aGlzLl9wb2ludFNuYXBwZXIuc25hcChuKX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pzXX19Y2xhc3MgcWl7Y29uc3RydWN0b3IoKXtxaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9hcmdHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9idWZQYXJhbXM9bmV3IGFpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5PW51bGwsdGhpcy5fc2F2ZUV4Y2VwdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmdHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fYXJnR2VvbT10LHRoaXMuX2J1ZlBhcmFtcz1lfX1zdGF0aWMgYnVmZmVyT3AoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBxaShhcmd1bWVudHNbMF0pLmdldFJlc3VsdEdlb21ldHJ5KHQpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1uZXcgcWkoYXJndW1lbnRzWzBdKTtuLnNldFF1YWRyYW50U2VnbWVudHMoZSk7cmV0dXJuIG4uZ2V0UmVzdWx0R2VvbWV0cnkodCl9aWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBhaSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHFpKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMl0pLmdldFJlc3VsdEdlb21ldHJ5KHQpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXSxzPW5ldyBxaShhcmd1bWVudHNbMF0pO3Muc2V0UXVhZHJhbnRTZWdtZW50cyhlKSxzLnNldEVuZENhcFN0eWxlKG4pO3JldHVybiBzLmdldFJlc3VsdEdlb21ldHJ5KHQpfX1zdGF0aWMgcHJlY2lzaW9uU2NhbGVGYWN0b3IodCxlLG4pe2NvbnN0IHM9dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1WLm1heChNYXRoLmFicyhzLmdldE1heFgoKSksTWF0aC5hYnMocy5nZXRNYXhZKCkpLE1hdGguYWJzKHMuZ2V0TWluWCgpKSxNYXRoLmFicyhzLmdldE1pblkoKSkpKzIqKGU+MD9lOjApLHI9bi1NYXRoLnRydW5jKE1hdGgubG9nKGkpL01hdGgubG9nKDEwKSsxKTtyZXR1cm4gTWF0aC5wb3coMTAscil9YnVmZmVyRml4ZWRQcmVjaXNpb24odCl7Y29uc3QgZT1uZXcgbmkobmV3IEdpKG5ldyB3dCgxKSksdC5nZXRTY2FsZSgpKSxuPW5ldyBPaSh0aGlzLl9idWZQYXJhbXMpO24uc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKHQpLG4uc2V0Tm9kZXIoZSksdGhpcy5fcmVzdWx0R2VvbWV0cnk9bi5idWZmZXIodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSl9YnVmZmVyUmVkdWNlZFByZWNpc2lvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9cWkuTUFYX1BSRUNJU0lPTl9ESUdJVFM7dD49MDt0LS0pe3RyeXt0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24odCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaXMpKXRocm93IHQ7dGhpcy5fc2F2ZUV4Y2VwdGlvbj10fWlmKG51bGwhPT10aGlzLl9yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbH10aHJvdyB0aGlzLl9zYXZlRXhjZXB0aW9ufWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXFpLnByZWNpc2lvblNjYWxlRmFjdG9yKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UsdCksbj1uZXcgd3QoZSk7dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihuKX19Y29tcHV0ZUdlb21ldHJ5KCl7aWYodGhpcy5idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpLG51bGwhPT10aGlzLl9yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMuX2FyZ0dlb20uZ2V0RmFjdG9yeSgpLmdldFByZWNpc2lvbk1vZGVsKCk7dC5nZXRUeXBlKCk9PT13dC5GSVhFRD90aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpOnRoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbigpfXNldFF1YWRyYW50U2VnbWVudHModCl7dGhpcy5fYnVmUGFyYW1zLnNldFF1YWRyYW50U2VnbWVudHModCl9YnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKXt0cnl7Y29uc3QgdD1uZXcgT2kodGhpcy5fYnVmUGFyYW1zKTt0aGlzLl9yZXN1bHRHZW9tZXRyeT10LmJ1ZmZlcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O3RoaXMuX3NhdmVFeGNlcHRpb249dH19Z2V0UmVzdWx0R2VvbWV0cnkodCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlPXQsdGhpcy5jb21wdXRlR2VvbWV0cnkoKSx0aGlzLl9yZXN1bHRHZW9tZXRyeX1zZXRFbmRDYXBTdHlsZSh0KXt0aGlzLl9idWZQYXJhbXMuc2V0RW5kQ2FwU3R5bGUodCl9fXFpLkNBUF9ST1VORD1haS5DQVBfUk9VTkQscWkuQ0FQX0JVVFQ9YWkuQ0FQX0ZMQVQscWkuQ0FQX0ZMQVQ9YWkuQ0FQX0ZMQVQscWkuQ0FQX1NRVUFSRT1haS5DQVBfU1FVQVJFLHFpLk1BWF9QUkVDSVNJT05fRElHSVRTPTEyO3ZhciBCaT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxCdWZmZXJPcDpxaSxCdWZmZXJQYXJhbWV0ZXJzOmFpfSk7Y2xhc3MgWWl7Y29uc3RydWN0b3IoKXtZaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9jb21wb25lbnQ9bnVsbCx0aGlzLl9zZWdJbmRleD1udWxsLHRoaXMuX3B0PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1lpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxZaS5JTlNJREVfQVJFQSxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9jb21wb25lbnQ9dCx0aGlzLl9zZWdJbmRleD1lLHRoaXMuX3B0PW59fWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLl9zZWdJbmRleH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fWlzSW5zaWRlQXJlYSgpe3JldHVybiB0aGlzLl9zZWdJbmRleD09PVlpLklOU0lERV9BUkVBfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudC5nZXRHZW9tZXRyeVR5cGUoKStcIltcIit0aGlzLl9zZWdJbmRleCtcIl0tXCIrV3QudG9Qb2ludCh0aGlzLl9wdCl9Z2V0R2VvbWV0cnlDb21wb25lbnQoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50fX1ZaS5JTlNJREVfQVJFQT0tMTtjbGFzcyBWaXtjb25zdHJ1Y3Rvcigpe1ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xvY2F0aW9ucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xvY2F0aW9ucz10fXN0YXRpYyBnZXRMb2NhdGlvbnModCl7Y29uc3QgZT1uZXcgTDtyZXR1cm4gdC5hcHBseShuZXcgVmkoZSkpLGV9ZmlsdGVyKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsOyh0IGluc3RhbmNlb2YgZXR8fHQgaW5zdGFuY2VvZiAkfHx0IGluc3RhbmNlb2YgcnQpJiZ0aGlzLl9sb2NhdGlvbnMuYWRkKG5ldyBZaSh0LDAsdC5nZXRDb29yZGluYXRlKCkpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSl19fWNsYXNzIHppe2NvbnN0cnVjdG9yKCl7emkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbT1udWxsLHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlPTAsdGhpcy5fcHRMb2NhdG9yPW5ldyBmbix0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3ppLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLDApfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZSx0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT1ufX1zdGF0aWMgZGlzdGFuY2UodCxlKXtyZXR1cm4gbmV3IHppKHQsZSkuZGlzdGFuY2UoKX1zdGF0aWMgaXNXaXRoaW5EaXN0YW5jZSh0LGUsbil7aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPm4pcmV0dXJuITE7cmV0dXJuIG5ldyB6aSh0LGUsbikuZGlzdGFuY2UoKTw9bn1zdGF0aWMgbmVhcmVzdFBvaW50cyh0LGUpe3JldHVybiBuZXcgemkodCxlKS5uZWFyZXN0UG9pbnRzKCl9Y29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDAsdCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX2dlb21bdF07aWYobi5nZXREaW1lbnNpb24oKTwyKXJldHVybiBudWxsO2NvbnN0IHM9MS10LGk9SWUuZ2V0UG9seWdvbnMobik7aWYoaS5zaXplKCk+MCl7Y29uc3Qgbj1WaS5nZXRMb2NhdGlvbnModGhpcy5fZ2VvbVtzXSk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShuLGksZSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3NdPWVbMF0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblt0XT1lWzFdLG51bGx9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmSShhcmd1bWVudHNbMF0sQykmJkkoYXJndW1lbnRzWzFdLEMpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKylpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKGksZS5nZXQodCksbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWWkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgcnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9dC5nZXRDb29yZGluYXRlKCk7aWYoUXQuRVhURVJJT1IhPT10aGlzLl9wdExvY2F0b3IubG9jYXRlKHMsZSkpcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlPTAsblswXT10LG5bMV09bmV3IFlpKGUscyksbnVsbH19Y29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKGkscyxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1jb21wdXRlRmFjZXREaXN0YW5jZSgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksZT15ZS5nZXRMaW5lcyh0aGlzLl9nZW9tWzBdKSxuPXllLmdldExpbmVzKHRoaXMuX2dlb21bMV0pLHM9RWUuZ2V0UG9pbnRzKHRoaXMuX2dlb21bMF0pLGk9RWUuZ2V0UG9pbnRzKHRoaXMuX2dlb21bMV0pO3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKGUsbix0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMoZSxpLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhuLHMsdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCEwKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyhzLGksdCksdm9pZCB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpKSkpfW5lYXJlc3RMb2NhdGlvbnMoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9ufXVwZGF0ZU1pbkRpc3RhbmNlKHQsZSl7aWYobnVsbD09PXRbMF0pcmV0dXJuIG51bGw7ZT8odGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXT10WzFdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV09dFswXSk6KHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF09dFswXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMV0pfW5lYXJlc3RQb2ludHMoKXt0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpO3JldHVyblt0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV19Y29tcHV0ZU1pbkRpc3RhbmNlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKG51bGwhPT10aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uKXJldHVybiBudWxsO2lmKHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb249bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVGYWNldERpc3RhbmNlKCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLl9taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZSgpO2ZvcihsZXQgcj0wO3I8cy5sZW5ndGgtMTtyKyspe2NvbnN0IG89ei5wb2ludFRvU2VnbWVudChpLHNbcl0sc1tyKzFdKTtpZihvPHRoaXMuX21pbkRpc3RhbmNlKXt0aGlzLl9taW5EaXN0YW5jZT1vO2NvbnN0IGw9bmV3IEt0KHNbcl0sc1tyKzFdKS5jbG9zZXN0UG9pbnQoaSk7blswXT1uZXcgWWkodCxyLGwpLG5bMV09bmV3IFlpKGUsMCxpKX1pZih0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mICQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLl9taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHI9MDtyPHMubGVuZ3RoLTE7cisrKXtjb25zdCBvPW5ldyBPKHNbcl0sc1tyKzFdKTtpZighKG8uZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMuX21pbkRpc3RhbmNlKSlmb3IobGV0IGw9MDtsPGkubGVuZ3RoLTE7bCsrKXtjb25zdCBhPW5ldyBPKGlbbF0saVtsKzFdKTtpZihvLmRpc3RhbmNlKGEpPnRoaXMuX21pbkRpc3RhbmNlKWNvbnRpbnVlO2NvbnN0IGM9ei5zZWdtZW50VG9TZWdtZW50KHNbcl0sc1tyKzFdLGlbbF0saVtsKzFdKTtpZihjPHRoaXMuX21pbkRpc3RhbmNlKXt0aGlzLl9taW5EaXN0YW5jZT1jO2NvbnN0IG89bmV3IEt0KHNbcl0sc1tyKzFdKSxhPW5ldyBLdChpW2xdLGlbbCsxXSksaD1vLmNsb3Nlc3RQb2ludHMoYSk7blswXT1uZXcgWWkodCxyLGhbMF0pLG5bMV09bmV3IFlpKGUsbCxoWzFdKX1pZih0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX19Y29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KSxyPWkuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHMuZ2V0Q29vcmRpbmF0ZSgpKTtpZihyPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5fbWluRGlzdGFuY2U9cixuWzBdPW5ldyBZaShpLDAsaS5nZXRDb29yZGluYXRlKCkpLG5bMV09bmV3IFlpKHMsMCxzLmdldENvb3JkaW5hdGUoKSkpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWRpc3RhbmNlKCl7aWYobnVsbD09PXRoaXMuX2dlb21bMF18fG51bGw9PT10aGlzLl9nZW9tWzFdKXRocm93IG5ldyBzKFwibnVsbCBnZW9tZXRyaWVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiB0aGlzLl9nZW9tWzBdLmlzRW1wdHkoKXx8dGhpcy5fZ2VvbVsxXS5pc0VtcHR5KCk/MDoodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLl9taW5EaXN0YW5jZSl9Y29tcHV0ZU1pbkRpc3RhbmNlTGluZXModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKGkscyxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX19dmFyIFhpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERpc3RhbmNlT3A6eml9KTtjbGFzcyBraXtjb25zdHJ1Y3Rvcigpe2tpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9kaXJlY3RlZEVkZ2VzPW5ldyBMLHRoaXMuX2Nvb3JkaW5hdGVzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fWdldENvb3JkaW5hdGVzKCl7aWYobnVsbD09PXRoaXMuX2Nvb3JkaW5hdGVzKXtsZXQgdD0wLGU9MDtjb25zdCBuPW5ldyBSO2ZvcihsZXQgcz10aGlzLl9kaXJlY3RlZEVkZ2VzLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpO2kuZ2V0RWRnZURpcmVjdGlvbigpP3QrKzplKyssbi5hZGQoaS5nZXRFZGdlKCkuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksITEsaS5nZXRFZGdlRGlyZWN0aW9uKCkpfXRoaXMuX2Nvb3JkaW5hdGVzPW4udG9Db29yZGluYXRlQXJyYXkoKSxlPnQmJl90LnJldmVyc2UodGhpcy5fY29vcmRpbmF0ZXMpfXJldHVybiB0aGlzLl9jb29yZGluYXRlc310b0xpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSl9YWRkKHQpe3RoaXMuX2RpcmVjdGVkRWRnZXMuYWRkKHQpfX1jbGFzcyBVaXtjb25zdHJ1Y3Rvcigpe1VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzTWFya2VkPSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLl9kYXRhPW51bGx9c3RhdGljIGdldENvbXBvbmVudFdpdGhWaXNpdGVkU3RhdGUodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKTtpZihuLmlzVmlzaXRlZCgpPT09ZSlyZXR1cm4gbn1yZXR1cm4gbnVsbH1zdGF0aWMgc2V0VmlzaXRlZCh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRWaXNpdGVkKGUpfX1zdGF0aWMgc2V0TWFya2VkKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3QubmV4dCgpLnNldE1hcmtlZChlKX19c2V0VmlzaXRlZCh0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH1pc01hcmtlZCgpe3JldHVybiB0aGlzLl9pc01hcmtlZH1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9c2V0TWFya2VkKHQpe3RoaXMuX2lzTWFya2VkPXR9Z2V0Q29udGV4dCgpe3JldHVybiB0aGlzLl9kYXRhfWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9c2V0Q29udGV4dCh0KXt0aGlzLl9kYXRhPXR9fWNsYXNzIEhpIGV4dGVuZHMgVWl7Y29uc3RydWN0b3IoKXtzdXBlcigpLEhpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BhcmVudEVkZ2U9bnVsbCx0aGlzLl9mcm9tPW51bGwsdGhpcy5fdG89bnVsbCx0aGlzLl9wMD1udWxsLHRoaXMuX3AxPW51bGwsdGhpcy5fc3ltPW51bGwsdGhpcy5fZWRnZURpcmVjdGlvbj1udWxsLHRoaXMuX3F1YWRyYW50PW51bGwsdGhpcy5fYW5nbGU9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fZnJvbT10LHRoaXMuX3RvPWUsdGhpcy5fZWRnZURpcmVjdGlvbj1zLHRoaXMuX3AwPXQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX3AxPW47Y29uc3QgaT10aGlzLl9wMS54LXRoaXMuX3AwLngscj10aGlzLl9wMS55LXRoaXMuX3AwLnk7dGhpcy5fcXVhZHJhbnQ9Q24ucXVhZHJhbnQoaSxyKSx0aGlzLl9hbmdsZT1NYXRoLmF0YW4yKHIsaSl9fXN0YXRpYyB0b0VkZ2VzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS5hZGQobi5uZXh0KCkuX3BhcmVudEVkZ2UpO3JldHVybiBlfWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fcGFyZW50RWRnZX1jb21wYXJlRGlyZWN0aW9uKHQpe3JldHVybiB0aGlzLl9xdWFkcmFudD50Ll9xdWFkcmFudD8xOnRoaXMuX3F1YWRyYW50PHQuX3F1YWRyYW50Py0xOnEuaW5kZXgodC5fcDAsdC5fcDEsdGhpcy5fcDEpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fZnJvbS5nZXRDb29yZGluYXRlKCl9cHJpbnQodCl7Y29uc3QgZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIikscz1lLnN1YnN0cmluZyhuKzEpO3QucHJpbnQoXCIgIFwiK3MrXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrdGhpcy5fYW5nbGUpfWdldERpcmVjdGlvblB0KCl7cmV0dXJuIHRoaXMuX3AxfWdldEFuZ2xlKCl7cmV0dXJuIHRoaXMuX2FuZ2xlfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX1nZXRGcm9tTm9kZSgpe3JldHVybiB0aGlzLl9mcm9tfWdldFN5bSgpe3JldHVybiB0aGlzLl9zeW19c2V0RWRnZSh0KXt0aGlzLl9wYXJlbnRFZGdlPXR9cmVtb3ZlKCl7dGhpcy5fc3ltPW51bGwsdGhpcy5fcGFyZW50RWRnZT1udWxsfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fcGFyZW50RWRnZX1nZXRRdWFkcmFudCgpe3JldHVybiB0aGlzLl9xdWFkcmFudH1zZXRTeW0odCl7dGhpcy5fc3ltPXR9Z2V0VG9Ob2RlKCl7cmV0dXJuIHRoaXMuX3RvfWdldEVkZ2VEaXJlY3Rpb24oKXtyZXR1cm4gdGhpcy5fZWRnZURpcmVjdGlvbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIFdpIGV4dGVuZHMgSGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLFdpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO0hpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4scyl9Z2V0TmV4dCgpe3JldHVybiAyIT09dGhpcy5nZXRUb05vZGUoKS5nZXREZWdyZWUoKT9udWxsOnRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKT09PXRoaXMuZ2V0U3ltKCk/dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpOihnLmlzVHJ1ZSh0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk9PT10aGlzLmdldFN5bSgpKSx0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCkpfX1jbGFzcyBaaSBleHRlbmRzIFVpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxaaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9kaXJFZGdlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc2V0RGlyZWN0ZWRFZGdlcyh0LGUpfX1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2RpckVkZ2V9c2V0RGlyZWN0ZWRFZGdlcyh0LGUpe3RoaXMuX2RpckVkZ2U9W3QsZV0sdC5zZXRFZGdlKHRoaXMpLGUuc2V0RWRnZSh0aGlzKSx0LnNldFN5bShlKSxlLnNldFN5bSh0KSx0LmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZSh0KSxlLmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZShlKX1nZXREaXJFZGdlKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZVt0XX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEtpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzBdOnRoaXMuX2RpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVsxXTpudWxsfX1yZW1vdmUoKXt0aGlzLl9kaXJFZGdlPW51bGx9Z2V0T3Bwb3NpdGVOb2RlKHQpe3JldHVybiB0aGlzLl9kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMF0uZ2V0VG9Ob2RlKCk6dGhpcy5fZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzFdLmdldFRvTm9kZSgpOm51bGx9fWNsYXNzIGppe2NvbnN0cnVjdG9yKCl7amkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3V0RWRnZXM9bmV3IEwsdGhpcy5fc29ydGVkPSExfWdldE5leHRFZGdlKHQpe2NvbnN0IGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZSsxKSl9Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9dGhpcy5pdGVyYXRvcigpO2lmKCF0Lmhhc05leHQoKSlyZXR1cm4gbnVsbDtyZXR1cm4gdC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5fb3V0RWRnZXMuaXRlcmF0b3IoKX1zb3J0RWRnZXMoKXt0aGlzLl9zb3J0ZWR8fCh4ZS5zb3J0KHRoaXMuX291dEVkZ2VzKSx0aGlzLl9zb3J0ZWQ9ITApfXJlbW92ZSh0KXt0aGlzLl9vdXRFZGdlcy5yZW1vdmUodCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLl9vdXRFZGdlc31nZXROZXh0Q1dFZGdlKHQpe2NvbnN0IGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZS0xKSl9Z2V0SW5kZXgoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFppKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2ZvcihsZXQgZT0wO2U8dGhpcy5fb3V0RWRnZXMuc2l6ZSgpO2UrKyl7aWYodGhpcy5fb3V0RWRnZXMuZ2V0KGUpLmdldEVkZ2UoKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBIaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX291dEVkZ2VzLnNpemUoKTtlKyspe2lmKHRoaXMuX291dEVkZ2VzLmdldChlKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtsZXQgdD1hcmd1bWVudHNbMF0ldGhpcy5fb3V0RWRnZXMuc2l6ZSgpO3JldHVybiB0PDAmJih0Kz10aGlzLl9vdXRFZGdlcy5zaXplKCkpLHR9fWFkZCh0KXt0aGlzLl9vdXRFZGdlcy5hZGQodCksdGhpcy5fc29ydGVkPSExfWdldERlZ3JlZSgpe3JldHVybiB0aGlzLl9vdXRFZGdlcy5zaXplKCl9fWNsYXNzIEtpIGV4dGVuZHMgVWl7Y29uc3RydWN0b3IoKXtzdXBlcigpLEtpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3B0PW51bGwsdGhpcy5fZGVTdGFyPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0tpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxuZXcgamkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0PXQsdGhpcy5fZGVTdGFyPWV9fXN0YXRpYyBnZXRFZGdlc0JldHdlZW4odCxlKXtjb25zdCBuPUhpLnRvRWRnZXModC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpLHM9bmV3IEV0KG4pLGk9SGkudG9FZGdlcyhlLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSk7cmV0dXJuIHMucmV0YWluQWxsKGkpLHN9aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9wdH1hZGRPdXRFZGdlKHQpe3RoaXMuX2RlU3Rhci5hZGQodCl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH1nZXRPdXRFZGdlcygpe3JldHVybiB0aGlzLl9kZVN0YXJ9cmVtb3ZlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fcHQ9bnVsbDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9kZVN0YXIucmVtb3ZlKHQpfX1nZXRJbmRleCh0KXtyZXR1cm4gdGhpcy5fZGVTdGFyLmdldEluZGV4KHQpfWdldERlZ3JlZSgpe3JldHVybiB0aGlzLl9kZVN0YXIuZ2V0RGVncmVlKCl9fWNsYXNzIFFpIGV4dGVuZHMgWml7Y29uc3RydWN0b3IoKXtzdXBlcigpLFFpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9saW5lfX1jbGFzcyBKaXtjb25zdHJ1Y3Rvcigpe0ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVNYXA9bmV3IFdufWZpbmQodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuZ2V0KHQpfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1yZW1vdmUodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAucmVtb3ZlKHQpfXZhbHVlcygpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpfWFkZCh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5wdXQodC5nZXRDb29yZGluYXRlKCksdCksdH19Y2xhc3MgJGl7Y29uc3RydWN0b3IoKXskaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lZGdlcz1uZXcgRXQsdGhpcy5fZGlyRWRnZXM9bmV3IEV0LHRoaXMuX25vZGVNYXA9bmV3IEppfWZpbmROb2Rlc09mRGVncmVlKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXRoaXMubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MuZ2V0RGVncmVlKCk9PT10JiZlLmFkZChzKX1yZXR1cm4gZX1kaXJFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKX1lZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1yZW1vdmUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFppKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMCkpLHRoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5fZWRnZXMucmVtb3ZlKHQpLHQucmVtb3ZlKCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEhpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0U3ltKCk7bnVsbCE9PWUmJmUuc2V0U3ltKG51bGwpLHQuZ2V0RnJvbU5vZGUoKS5yZW1vdmUodCksdC5yZW1vdmUoKSx0aGlzLl9kaXJFZGdlcy5yZW1vdmUodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEtpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldFN5bSgpO251bGwhPT1uJiZ0aGlzLnJlbW92ZShuKSx0aGlzLl9kaXJFZGdlcy5yZW1vdmUodCk7Y29uc3Qgcz10LmdldEVkZ2UoKTtudWxsIT09cyYmdGhpcy5fZWRnZXMucmVtb3ZlKHMpfXRoaXMuX25vZGVNYXAucmVtb3ZlKHQuZ2V0Q29vcmRpbmF0ZSgpKSx0LnJlbW92ZSgpfX1maW5kTm9kZSh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5maW5kKHQpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfW5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLml0ZXJhdG9yKCl9Y29udGFpbnMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFppKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZWRnZXMuY29udGFpbnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBIaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VzLmNvbnRhaW5zKHQpfX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEtpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ub2RlTWFwLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2VzLmFkZCh0KSx0aGlzLmFkZCh0LmdldERpckVkZ2UoMCkpLHRoaXMuYWRkKHQuZ2V0RGlyRWRnZSgxKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEhpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9kaXJFZGdlcy5hZGQodCl9fWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCl9fWNsYXNzIHRyIGV4dGVuZHMgJGl7Y29uc3RydWN0b3IoKXtzdXBlcigpfWFkZEVkZ2UodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1fdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPD0xKXJldHVybiBudWxsO2NvbnN0IG49ZVswXSxzPWVbZS5sZW5ndGgtMV0saT10aGlzLmdldE5vZGUobikscj10aGlzLmdldE5vZGUocyksbz1uZXcgV2koaSxyLGVbMV0sITApLGw9bmV3IFdpKHIsaSxlW2UubGVuZ3RoLTJdLCExKSxhPW5ldyBRaSh0KTthLnNldERpcmVjdGVkRWRnZXMobyxsKSx0aGlzLmFkZChhKX1nZXROb2RlKHQpe2xldCBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgS2kodCksdGhpcy5hZGQoZSkpLGV9fWNsYXNzIGVye2NvbnN0cnVjdG9yKCl7ZXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ3JhcGg9bmV3IHRyLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzPW51bGwsdGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2VkZ2VTdHJpbmdzPW51bGx9YnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmlzTWFya2VkKCl8fChnLmlzVHJ1ZSgyPT09ZS5nZXREZWdyZWUoKSksdGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX1idWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7MiE9PWUuZ2V0RGVncmVlKCkmJih0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fWJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2Rlcygpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2RlcygpfWdldE1lcmdlZExpbmVTdHJpbmdzKCl7cmV0dXJuIHRoaXMubWVyZ2UoKSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5nc31idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdCh0KXtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuZ2V0RWRnZSgpLmlzTWFya2VkKCl8fHRoaXMuX2VkZ2VTdHJpbmdzLmFkZCh0aGlzLmJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aCh0KSl9fW1lcmdlKCl7aWYobnVsbCE9PXRoaXMuX21lcmdlZExpbmVTdHJpbmdzKXJldHVybiBudWxsO1VpLnNldE1hcmtlZCh0aGlzLl9ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSksVWkuc2V0TWFya2VkKHRoaXMuX2dyYXBoLmVkZ2VJdGVyYXRvcigpLCExKSx0aGlzLl9lZGdlU3RyaW5ncz1uZXcgTCx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2RlcygpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1uZXcgTDtmb3IobGV0IHQ9dGhpcy5fZWRnZVN0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3MuYWRkKGUudG9MaW5lU3RyaW5nKCkpfX1hZGRMaW5lU3RyaW5nKHQpe251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KX1idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgodCl7Y29uc3QgZT1uZXcga2kodGhpcy5fZmFjdG9yeSk7bGV0IG49dDtkb3tlLmFkZChuKSxuLmdldEVkZ2UoKS5zZXRNYXJrZWQoITApLG49bi5nZXROZXh0KCl9d2hpbGUobnVsbCE9PW4mJm4hPT10KTtyZXR1cm4gZX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO24gaW5zdGFuY2VvZiAkJiZ0aGlzLmFkZExpbmVTdHJpbmcobil9fWVsc2UgaWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21lcmdlZExpbmVTdHJpbmdzPW51bGw7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5hZGQodCl9fX1idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXMoKX19Y2xhc3MgbnJ7Y29uc3RydWN0b3IoKXtuci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wYXJlbnRHcmFwaD1udWxsLHRoaXMuX2VkZ2VzPW5ldyBFdCx0aGlzLl9kaXJFZGdlcz1uZXcgTCx0aGlzLl9ub2RlTWFwPW5ldyBKaTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnRHcmFwaD10fWRpckVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpfWVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnRHcmFwaH1ub2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5pdGVyYXRvcigpfWNvbnRhaW5zKHQpe3JldHVybiB0aGlzLl9lZGdlcy5jb250YWlucyh0KX1hZGQodCl7aWYodGhpcy5fZWRnZXMuY29udGFpbnModCkpcmV0dXJuIG51bGw7dGhpcy5fZWRnZXMuYWRkKHQpLHRoaXMuX2RpckVkZ2VzLmFkZCh0LmdldERpckVkZ2UoMCkpLHRoaXMuX2RpckVkZ2VzLmFkZCh0LmdldERpckVkZ2UoMSkpLHRoaXMuX25vZGVNYXAuYWRkKHQuZ2V0RGlyRWRnZSgwKS5nZXRGcm9tTm9kZSgpKSx0aGlzLl9ub2RlTWFwLmFkZCh0LmdldERpckVkZ2UoMSkuZ2V0RnJvbU5vZGUoKSl9fWNsYXNzIHNye2NvbnN0cnVjdG9yKCl7c3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ3JhcGg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ncmFwaD10fWFkZFJlYWNoYWJsZSh0LGUpe2NvbnN0IG49bmV3IGVuO2ZvcihuLmFkZCh0KTshbi5lbXB0eSgpOyl7Y29uc3QgdD1uLnBvcCgpO3RoaXMuYWRkRWRnZXModCxuLGUpfX1maW5kU3ViZ3JhcGgodCl7Y29uc3QgZT1uZXcgbnIodGhpcy5fZ3JhcGgpO3JldHVybiB0aGlzLmFkZFJlYWNoYWJsZSh0LGUpLGV9Z2V0Q29ubmVjdGVkU3ViZ3JhcGhzKCl7Y29uc3QgdD1uZXcgTDtVaS5zZXRWaXNpdGVkKHRoaXMuX2dyYXBoLm5vZGVJdGVyYXRvcigpLCExKTtmb3IobGV0IGU9dGhpcy5fZ3JhcGguZWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldERpckVkZ2UoMCkuZ2V0RnJvbU5vZGUoKTtuLmlzVmlzaXRlZCgpfHx0LmFkZCh0aGlzLmZpbmRTdWJncmFwaChuKSl9cmV0dXJuIHR9YWRkRWRnZXModCxlLG4pe3Quc2V0VmlzaXRlZCghMCk7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtuLmFkZCh0LmdldEVkZ2UoKSk7Y29uc3QgaT10LmdldFRvTm9kZSgpO2kuaXNWaXNpdGVkKCl8fGUucHVzaChpKX19fWNsYXNzIGlye2NvbnN0cnVjdG9yKCl7aXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ3JhcGg9bmV3IHRyLHRoaXMuX2ZhY3Rvcnk9bmV3IEx0LHRoaXMuX2xpbmVDb3VudD0wLHRoaXMuX2lzUnVuPSExLHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5PW51bGwsdGhpcy5faXNTZXF1ZW5jZWFibGU9ITF9c3RhdGljIGZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERSh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuZ2V0RWRnZSgpLmlzVmlzaXRlZCgpfHwobj10LHQuZ2V0RWRnZURpcmVjdGlvbigpJiYoZT10KSl9cmV0dXJuIG51bGwhPT1lP2U6bn1zdGF0aWMgZmluZExvd2VzdERlZ3JlZU5vZGUodCl7bGV0IGU9Yi5NQVhfVkFMVUUsbj1udWxsO2ZvcihsZXQgcz10Lm5vZGVJdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTsobnVsbD09PW58fHQuZ2V0RGVncmVlKCk8ZSkmJihlPXQuZ2V0RGVncmVlKCksbj10KX1yZXR1cm4gbn1zdGF0aWMgaXNTZXF1ZW5jZWQodCl7aWYoISh0IGluc3RhbmNlb2YgU3QpKXJldHVybiEwO2NvbnN0IGU9dCxuPW5ldyBhdDtsZXQgcz1udWxsO2NvbnN0IGk9bmV3IEw7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IHI9ZS5nZXRHZW9tZXRyeU4odCksbz1yLmdldENvb3JkaW5hdGVOKDApLGw9ci5nZXRDb29yZGluYXRlTihyLmdldE51bVBvaW50cygpLTEpO2lmKG4uY29udGFpbnMobykpcmV0dXJuITE7aWYobi5jb250YWlucyhsKSlyZXR1cm4hMTtudWxsIT09cyYmKG8uZXF1YWxzKHMpfHwobi5hZGRBbGwoaSksaS5jbGVhcigpKSksaS5hZGQobyksaS5hZGQobCkscz1sfXJldHVybiEwfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLG49bmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKG51bGwpLHM9ZS5sZW5ndGg7Zm9yKGxldCB0PTA7dDxzO3QrKyluW3MtMS10XT1uZXcgbShlW3RdKTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhuKX1zdGF0aWMgc2VxdWVuY2UodCl7Y29uc3QgZT1uZXcgaXI7cmV0dXJuIGUuYWRkKHQpLGUuZ2V0U2VxdWVuY2VkTGluZVN0cmluZ3MoKX1hZGRMaW5lKHQpe251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KSx0aGlzLl9saW5lQ291bnQrK31oYXNTZXF1ZW5jZSh0KXtsZXQgZT0wO2ZvcihsZXQgbj10Lm5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0RGVncmVlKCklMj09MSYmZSsrfXJldHVybiBlPD0yfWNvbXB1dGVTZXF1ZW5jZSgpe2lmKHRoaXMuX2lzUnVuKXJldHVybiBudWxsO3RoaXMuX2lzUnVuPSEwO2NvbnN0IHQ9dGhpcy5maW5kU2VxdWVuY2VzKCk7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnk9dGhpcy5idWlsZFNlcXVlbmNlZEdlb21ldHJ5KHQpLHRoaXMuX2lzU2VxdWVuY2VhYmxlPSEwO2NvbnN0IGU9dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkuZ2V0TnVtR2VvbWV0cmllcygpO2cuaXNUcnVlKHRoaXMuX2xpbmVDb3VudD09PWUsXCJMaW5lcyB3ZXJlIG1pc3NpbmcgZnJvbSByZXN1bHRcIiksZy5pc1RydWUodGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkgaW5zdGFuY2VvZiAkfHx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeSBpbnN0YW5jZW9mIFN0LFwiUmVzdWx0IGlzIG5vdCBsaW5lYWxcIil9ZmluZFNlcXVlbmNlcygpe2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPW5ldyBzcih0aGlzLl9ncmFwaCkuZ2V0Q29ubmVjdGVkU3ViZ3JhcGhzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYoIXRoaXMuaGFzU2VxdWVuY2UobikpcmV0dXJuIG51bGw7e2NvbnN0IGU9dGhpcy5maW5kU2VxdWVuY2Uobik7dC5hZGQoZSl9fXJldHVybiB0fWFkZFJldmVyc2VTdWJwYXRoKHQsZSxuKXtjb25zdCBzPXQuZ2V0VG9Ob2RlKCk7bGV0IGk9bnVsbDtmb3IoOzspe2UuYWRkKHQuZ2V0U3ltKCkpLHQuZ2V0RWRnZSgpLnNldFZpc2l0ZWQoITApLGk9dC5nZXRGcm9tTm9kZSgpO2NvbnN0IG49aXIuZmluZFVudmlzaXRlZEJlc3RPcmllbnRlZERFKGkpO2lmKG51bGw9PT1uKWJyZWFrO3Q9bi5nZXRTeW0oKX1uJiZnLmlzVHJ1ZShpPT09cyxcInBhdGggbm90IGNvbnRpZ3VvdXNcIil9ZmluZFNlcXVlbmNlKHQpe1VpLnNldFZpc2l0ZWQodC5lZGdlSXRlcmF0b3IoKSwhMSk7Y29uc3QgZT1pci5maW5kTG93ZXN0RGVncmVlTm9kZSh0KS5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCkubmV4dCgpLmdldFN5bSgpLG49bmV3IGhpLHM9bi5saXN0SXRlcmF0b3IoKTtmb3IodGhpcy5hZGRSZXZlcnNlU3VicGF0aChlLHMsITEpO3MuaGFzUHJldmlvdXMoKTspe2NvbnN0IHQ9cy5wcmV2aW91cygpLGU9aXIuZmluZFVudmlzaXRlZEJlc3RPcmllbnRlZERFKHQuZ2V0RnJvbU5vZGUoKSk7bnVsbCE9PWUmJnRoaXMuYWRkUmV2ZXJzZVN1YnBhdGgoZS5nZXRTeW0oKSxzLCEwKX1yZXR1cm4gdGhpcy5vcmllbnQobil9cmV2ZXJzZSh0KXtjb25zdCBlPW5ldyBoaTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZEZpcnN0KHQuZ2V0U3ltKCkpfXJldHVybiBlfW9yaWVudCh0KXtjb25zdCBlPXQuZ2V0KDApLG49dC5nZXQodC5zaXplKCktMSkscz1lLmdldEZyb21Ob2RlKCksaT1uLmdldFRvTm9kZSgpO2xldCByPSExO2lmKDE9PT1zLmdldERlZ3JlZSgpfHwxPT09aS5nZXREZWdyZWUoKSl7bGV0IHQ9ITE7MT09PW4uZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCkmJiExPT09bi5nZXRFZGdlRGlyZWN0aW9uKCkmJih0PSEwLHI9ITApLDE9PT1lLmdldEZyb21Ob2RlKCkuZ2V0RGVncmVlKCkmJiEwPT09ZS5nZXRFZGdlRGlyZWN0aW9uKCkmJih0PSEwLHI9ITEpLHR8fDE9PT1lLmdldEZyb21Ob2RlKCkuZ2V0RGVncmVlKCkmJihyPSEwKX1yZXR1cm4gcj90aGlzLnJldmVyc2UodCk6dH1idWlsZFNlcXVlbmNlZEdlb21ldHJ5KHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2ZvcihsZXQgdD1uLm5leHQoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0RWRnZSgpLmdldExpbmUoKTtsZXQgaT1zO24uZ2V0RWRnZURpcmVjdGlvbigpfHxzLmlzQ2xvc2VkKCl8fChpPWlyLnJldmVyc2UocykpLGUuYWRkKGkpfX1yZXR1cm4gMD09PWUuc2l6ZSgpP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTp0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkoZSl9Z2V0U2VxdWVuY2VkTGluZVN0cmluZ3MoKXtyZXR1cm4gdGhpcy5jb21wdXRlU2VxdWVuY2UoKSx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeX1pc1NlcXVlbmNlYWJsZSgpe3JldHVybiB0aGlzLmNvbXB1dGVTZXF1ZW5jZSgpLHRoaXMuX2lzU2VxdWVuY2VhYmxlfWFkZCgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7YXJndW1lbnRzWzBdLmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiAkJiZ0aGlzLmFkZExpbmUodCl9fSl9fX12YXIgcnI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGluZU1lcmdlcjplcixMaW5lU2VxdWVuY2VyOmlyfSk7Y2xhc3Mgb3J7Y29uc3RydWN0b3IoKXtvci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zbmFwVG9sZXJhbmNlPTAsdGhpcy5fc3JjUHRzPW51bGwsdGhpcy5fc2VnPW5ldyBLdCx0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz0hMSx0aGlzLl9pc0Nsb3NlZD0hMSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO29yLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC5nZXRDb29yZGluYXRlcygpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fc3JjUHRzPXQsdGhpcy5faXNDbG9zZWQ9b3IuaXNDbG9zZWQodCksdGhpcy5fc25hcFRvbGVyYW5jZT1lfX1zdGF0aWMgaXNDbG9zZWQodCl7cmV0dXJuISh0Lmxlbmd0aDw9MSkmJnRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9c25hcFZlcnRpY2VzKHQsZSl7Y29uc3Qgbj10aGlzLl9pc0Nsb3NlZD90LnNpemUoKS0xOnQuc2l6ZSgpO2ZvcihsZXQgcz0wO3M8bjtzKyspe2NvbnN0IG49dC5nZXQocyksaT10aGlzLmZpbmRTbmFwRm9yVmVydGV4KG4sZSk7bnVsbCE9PWkmJih0LnNldChzLG5ldyBtKGkpKSwwPT09cyYmdGhpcy5faXNDbG9zZWQmJnQuc2V0KHQuc2l6ZSgpLTEsbmV3IG0oaSkpKX19ZmluZFNuYXBGb3JWZXJ0ZXgodCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7aWYodC5lcXVhbHMyRChlW25dKSlyZXR1cm4gbnVsbDtpZih0LmRpc3RhbmNlKGVbbl0pPHRoaXMuX3NuYXBUb2xlcmFuY2UpcmV0dXJuIGVbbl19cmV0dXJuIG51bGx9c25hcFRvKHQpe2NvbnN0IGU9bmV3IFIodGhpcy5fc3JjUHRzKTt0aGlzLnNuYXBWZXJ0aWNlcyhlLHQpLHRoaXMuc25hcFNlZ21lbnRzKGUsdCk7cmV0dXJuIGUudG9Db29yZGluYXRlQXJyYXkoKX1zbmFwU2VnbWVudHModCxlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIG51bGw7bGV0IG49ZS5sZW5ndGg7ZVswXS5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSYmKG49ZS5sZW5ndGgtMSk7Zm9yKGxldCBzPTA7czxuO3MrKyl7Y29uc3Qgbj1lW3NdLGk9dGhpcy5maW5kU2VnbWVudEluZGV4VG9TbmFwKG4sdCk7aT49MCYmdC5hZGQoaSsxLG5ldyBtKG4pLCExKX19ZmluZFNlZ21lbnRJbmRleFRvU25hcCh0LGUpe2xldCBuPXIuTUFYX1ZBTFVFLHM9LTE7Zm9yKGxldCBpPTA7aTxlLnNpemUoKS0xO2krKyl7aWYodGhpcy5fc2VnLnAwPWUuZ2V0KGkpLHRoaXMuX3NlZy5wMT1lLmdldChpKzEpLHRoaXMuX3NlZy5wMC5lcXVhbHMyRCh0KXx8dGhpcy5fc2VnLnAxLmVxdWFsczJEKHQpKXtpZih0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyljb250aW51ZTtyZXR1cm4tMX1jb25zdCByPXRoaXMuX3NlZy5kaXN0YW5jZSh0KTtyPHRoaXMuX3NuYXBUb2xlcmFuY2UmJnI8biYmKG49cixzPWkpfXJldHVybiBzfXNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHQpe3RoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPXR9fWNsYXNzIGxye2NvbnN0cnVjdG9yKCl7bHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3JjR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NyY0dlb209dH1zdGF0aWMgc25hcCh0LGUsbil7Y29uc3Qgcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxpPW5ldyBscih0KTtzWzBdPWkuc25hcFRvKGUsbik7Y29uc3Qgcj1uZXcgbHIoZSk7cmV0dXJuIHNbMV09ci5zbmFwVG8oc1swXSxuKSxzfXN0YXRpYyBjb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bHIuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCk7Y29uc3Qgbj10LmdldFByZWNpc2lvbk1vZGVsKCk7aWYobi5nZXRUeXBlKCk9PT13dC5GSVhFRCl7Y29uc3QgdD0xL24uZ2V0U2NhbGUoKSoyLzEuNDE1O3Q+ZSYmKGU9dCl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBNYXRoLm1pbihsci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodCksbHIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKGUpKX19c3RhdGljIGNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIE1hdGgubWluKGUuZ2V0SGVpZ2h0KCksZS5nZXRXaWR0aCgpKSpsci5TTkFQX1BSRUNJU0lPTl9GQUNUT1J9c3RhdGljIHNuYXBUb1NlbGYodCxlLG4pe3JldHVybiBuZXcgbHIodCkuc25hcFRvU2VsZihlLG4pfXNuYXBUbyh0LGUpe2NvbnN0IG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModCk7cmV0dXJuIG5ldyBhcihlLG4pLnRyYW5zZm9ybSh0aGlzLl9zcmNHZW9tKX1zbmFwVG9TZWxmKHQsZSl7Y29uc3Qgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0aGlzLl9zcmNHZW9tKSxzPW5ldyBhcih0LG4sITApLnRyYW5zZm9ybSh0aGlzLl9zcmNHZW9tKTtsZXQgaT1zO3JldHVybiBlJiZJKGksaXQpJiYoaT1zLmJ1ZmZlcigwKSksaX1jb21wdXRlU25hcFRvbGVyYW5jZSh0KXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgodCkvMTB9ZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IGF0LG49dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuYWRkKG5bdF0pO3JldHVybiBlLnRvQXJyYXkobmV3IEFycmF5KDApLmZpbGwobnVsbCkpfWNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KXtsZXQgZT1yLk1BWF9WQUxVRTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXtjb25zdCBzPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtzPGUmJihlPXMpfXJldHVybiBlfX1sci5TTkFQX1BSRUNJU0lPTl9GQUNUT1I9MWUtOTtjbGFzcyBhciBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxhci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5fc25hcFB0cz1udWxsLHRoaXMuX2lzU2VsZlNuYXA9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3NuYXBUb2xlcmFuY2U9dCx0aGlzLl9zbmFwUHRzPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fc25hcFRvbGVyYW5jZT10LHRoaXMuX3NuYXBQdHM9ZSx0aGlzLl9pc1NlbGZTbmFwPW59fXNuYXBMaW5lKHQsZSl7Y29uc3Qgbj1uZXcgb3IodCx0aGlzLl9zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbi5zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0aGlzLl9pc1NlbGZTbmFwKSxuLnNuYXBUbyhlKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLHM9dGhpcy5zbmFwTGluZShuLHRoaXMuX3NuYXBQdHMpO3JldHVybiB0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9fXZhciBjcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9tZXRyeVNuYXBwZXI6bHIsTGluZVN0cmluZ1NuYXBwZXI6b3J9KTtjbGFzcyBocntjb25zdHJ1Y3Rvcigpe2hyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsLHRoaXMuX2RhdGE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl9kYXRhPWV9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRzfXNpemUoKXtyZXR1cm4gdGhpcy5fcHRzLmxlbmd0aH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHNbdF19aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aC0xXSl9Z2V0U2VnbWVudE9jdGFudCh0KXtyZXR1cm4gdD09PXRoaXMuX3B0cy5sZW5ndGgtMT8tMTpVcy5vY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKG5ldyBtdCh0aGlzLl9wdHMpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSHNdfX1jbGFzcyB1cntjb25zdHJ1Y3Rvcigpe3VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHk9ITEsdGhpcy5fa2VlcEludGVyc2VjdGlvbnM9ITAsdGhpcy5faXNJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5PSExLHRoaXMuX2xpPW51bGwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbCx0aGlzLl9pbnRTZWdtZW50cz1udWxsLHRoaXMuX2ludGVyc2VjdGlvbnM9bmV3IEwsdGhpcy5faW50ZXJzZWN0aW9uQ291bnQ9MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saT10LHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPW51bGx9c3RhdGljIGNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXIodCl7Y29uc3QgZT1uZXcgdXIodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGV9c3RhdGljIGlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24oKXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbM107cmV0dXJuKCFhcmd1bWVudHNbMl18fCFuKSYmISF0LmVxdWFsczJEKGUpfWlmKDg9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XSxvPWFyZ3VtZW50c1s2XSxsPWFyZ3VtZW50c1s3XTtyZXR1cm4hIXVyLmlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24odCxuLGksbyl8fCghIXVyLmlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24odCxzLGksbCl8fCghIXVyLmlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24oZSxuLHIsbyl8fCEhdXIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbihlLHMscixsKSkpfX1zdGF0aWMgY3JlYXRlSW50ZXJpb3JJbnRlcnNlY3Rpb25Db3VudGVyKHQpe2NvbnN0IGU9bmV3IHVyKHQpO3JldHVybiBlLnNldEludGVyaW9ySW50ZXJzZWN0aW9uc09ubHkoITApLGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuc2V0S2VlcEludGVyc2VjdGlvbnMoITEpLGV9c3RhdGljIGNyZWF0ZUludGVyc2VjdGlvbkNvdW50ZXIodCl7Y29uc3QgZT1uZXcgdXIodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuc2V0S2VlcEludGVyc2VjdGlvbnMoITEpLGV9c3RhdGljIGlzRW5kU2VnbWVudCh0LGUpe3JldHVybiAwPT09ZXx8ZT49dC5zaXplKCktMn1zdGF0aWMgY3JlYXRlQW55SW50ZXJzZWN0aW9uRmluZGVyKHQpe3JldHVybiBuZXcgdXIodCl9c3RhdGljIGNyZWF0ZUludGVyaW9ySW50ZXJzZWN0aW9uc0ZpbmRlcih0KXtjb25zdCBlPW5ldyB1cih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5KCEwKSxlfXNldENoZWNrRW5kU2VnbWVudHNPbmx5KHQpe3RoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHk9dH1nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpe3JldHVybiB0aGlzLl9pbnRTZWdtZW50c31jb3VudCgpe3JldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25Db3VudH1nZXRJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbnN9c2V0RmluZEFsbEludGVyc2VjdGlvbnModCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9dH1zZXRLZWVwSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucz10fWdldEludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZighdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMmJnRoaXMuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIG51bGw7Y29uc3QgaT10PT09bjtpZihpJiZlPT09cylyZXR1cm4gbnVsbDtpZih0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5KXtpZighKHVyLmlzRW5kU2VnbWVudCh0LGUpfHx1ci5pc0VuZFNlZ21lbnQobixzKSkpcmV0dXJuIG51bGx9Y29uc3Qgcj10LmdldENvb3JkaW5hdGUoZSksbz10LmdldENvb3JkaW5hdGUoZSsxKSxsPW4uZ2V0Q29vcmRpbmF0ZShzKSxhPW4uZ2V0Q29vcmRpbmF0ZShzKzEpLGM9MD09PWUsaD1lKzI9PT10LnNpemUoKSx1PTA9PT1zLGc9cysyPT09bi5zaXplKCk7dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihyLG8sbCxhKTtjb25zdCBkPXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCk7bGV0IF89ITE7aWYoIXRoaXMuX2lzSW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seSl7Xz0hKGkmJk1hdGguYWJzKHMtZSk8PTEpJiZ1ci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKHIsbyxsLGEsYyxoLHUsZyl9KGR8fF8pJiYodGhpcy5faW50U2VnbWVudHM9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5faW50U2VnbWVudHNbMF09cix0aGlzLl9pbnRTZWdtZW50c1sxXT1vLHRoaXMuX2ludFNlZ21lbnRzWzJdPWwsdGhpcy5faW50U2VnbWVudHNbM109YSx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCksdGhpcy5fa2VlcEludGVyc2VjdGlvbnMmJnRoaXMuX2ludGVyc2VjdGlvbnMuYWRkKHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uKSx0aGlzLl9pbnRlcnNlY3Rpb25Db3VudCsrKX1oYXNJbnRlcnNlY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiF0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyYmbnVsbCE9PXRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ufXNldEludGVyaW9ySW50ZXJzZWN0aW9uc09ubHkodCl7dGhpcy5faXNJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5PXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1JpXX19Y2xhc3MgZ3J7Y29uc3RydWN0b3IoKXtnci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fc2VnU3RyaW5ncz1udWxsLHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuX3NlZ0ludD1udWxsLHRoaXMuX2lzVmFsaWQ9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2VnU3RyaW5ncz10fXN0YXRpYyBjb21wdXRlSW50ZXJzZWN0aW9ucyh0KXtjb25zdCBlPW5ldyBncih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5pc1ZhbGlkKCksZS5nZXRJbnRlcnNlY3Rpb25zKCl9ZXhlY3V0ZSgpe2lmKG51bGwhPT10aGlzLl9zZWdJbnQpcmV0dXJuIG51bGw7dGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpfWdldEludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvbnMoKX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMuZXhlY3V0ZSgpLHRoaXMuX2lzVmFsaWR9c2V0RmluZEFsbEludGVyc2VjdGlvbnModCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9dH1jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpe3RoaXMuX2lzVmFsaWQ9ITAsdGhpcy5fc2VnSW50PW5ldyB1cih0aGlzLl9saSksdGhpcy5fc2VnSW50LnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zKTtjb25zdCB0PW5ldyB0aTtpZih0LnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0aGlzLl9zZWdJbnQpLHQuY29tcHV0ZU5vZGVzKHRoaXMuX3NlZ1N0cmluZ3MpLHRoaXMuX3NlZ0ludC5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4gdGhpcy5faXNWYWxpZD0hMSxudWxsfWNoZWNrVmFsaWQoKXtpZih0aGlzLmV4ZWN1dGUoKSwhdGhpcy5faXNWYWxpZCl0aHJvdyBuZXcgaXModGhpcy5nZXRFcnJvck1lc3NhZ2UoKSx0aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9uKCkpfWdldEVycm9yTWVzc2FnZSgpe2lmKHRoaXMuX2lzVmFsaWQpcmV0dXJuXCJubyBpbnRlcnNlY3Rpb25zIGZvdW5kXCI7Y29uc3QgdD10aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKTtyZXR1cm5cImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYmV0d2VlbiBcIitXdC50b0xpbmVTdHJpbmcodFswXSx0WzFdKStcIiBhbmQgXCIrV3QudG9MaW5lU3RyaW5nKHRbMl0sdFszXSl9fWNsYXNzIGRye2NvbnN0cnVjdG9yKCl7ZHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9udj1uZXcgZ3IoZHIudG9TZWdtZW50U3RyaW5ncyh0KSl9c3RhdGljIHRvU2VnbWVudFN0cmluZ3ModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgaHIodC5nZXRDb29yZGluYXRlcygpLHQpKX1yZXR1cm4gZX1zdGF0aWMgY2hlY2tWYWxpZCh0KXtuZXcgZHIodCkuY2hlY2tWYWxpZCgpfWNoZWNrVmFsaWQoKXt0aGlzLl9udi5jaGVja1ZhbGlkKCl9fWNsYXNzIF9ye2NvbnN0cnVjdG9yKCl7X3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3A9bnVsbCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9wdExvY2F0b3I9bnVsbCx0aGlzLl9saW5lRWRnZXNMaXN0PW5ldyBMLHRoaXMuX3Jlc3VsdExpbmVMaXN0PW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX29wPXQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5fcHRMb2NhdG9yPW59Y29sbGVjdExpbmVzKHQpe2ZvcihsZXQgZT10aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5jb2xsZWN0TGluZUVkZ2Uobix0LHRoaXMuX2xpbmVFZGdlc0xpc3QpLHRoaXMuY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKG4sdCx0aGlzLl9saW5lRWRnZXNMaXN0KX19bGFiZWxJc29sYXRlZExpbmUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fb3AuZ2V0QXJnR2VvbWV0cnkoZSkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfWJ1aWxkKHQpe3JldHVybiB0aGlzLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCksdGhpcy5jb2xsZWN0TGluZXModCksdGhpcy5idWlsZExpbmVzKHQpLHRoaXMuX3Jlc3VsdExpbmVMaXN0fWNvbGxlY3RMaW5lRWRnZSh0LGUsbil7Y29uc3Qgcz10LmdldExhYmVsKCksaT10LmdldEVkZ2UoKTt0LmlzTGluZUVkZ2UoKSYmKHQuaXNWaXNpdGVkKCl8fCF3ci5pc1Jlc3VsdE9mT3AocyxlKXx8aS5pc0NvdmVyZWQoKXx8KG4uYWRkKGkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSl9ZmluZENvdmVyZWRMaW5lRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl9Zm9yKGxldCB0PXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZSgpO2lmKGUuaXNMaW5lRWRnZSgpJiYhbi5pc0NvdmVyZWRTZXQoKSl7Y29uc3QgdD10aGlzLl9vcC5pc0NvdmVyZWRCeUEoZS5nZXRDb29yZGluYXRlKCkpO24uc2V0Q292ZXJlZCh0KX19fWxhYmVsSXNvbGF0ZWRMaW5lcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TGFiZWwoKTt0LmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZExpbmUodCwwKTp0aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKHQsMSkpfX1idWlsZExpbmVzKHQpe2ZvcihsZXQgdD10aGlzLl9saW5lRWRnZXNMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49dGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZS5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9yZXN1bHRMaW5lTGlzdC5hZGQobiksZS5zZXRJblJlc3VsdCghMCl9fWNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZSh0LGUsbil7Y29uc3Qgcz10LmdldExhYmVsKCk7cmV0dXJuIHQuaXNMaW5lRWRnZSgpfHx0LmlzVmlzaXRlZCgpfHx0LmlzSW50ZXJpb3JBcmVhRWRnZSgpfHx0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCk/bnVsbDooZy5pc1RydWUoISh0LmlzSW5SZXN1bHQoKXx8dC5nZXRTeW0oKS5pc0luUmVzdWx0KCkpfHwhdC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKSx2b2lkKHdyLmlzUmVzdWx0T2ZPcChzLGUpJiZlPT09d3IuSU5URVJTRUNUSU9OJiYobi5hZGQodC5nZXRFZGdlKCkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSkpfX1jbGFzcyBwcntjb25zdHJ1Y3Rvcigpe3ByLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX29wPW51bGwsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5fcmVzdWx0UG9pbnRMaXN0PW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX29wPXQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PWV9ZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKCk7aWYoIXRoaXMuX29wLmlzQ292ZXJlZEJ5TEEoZSkpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpO3RoaXMuX3Jlc3VsdFBvaW50TGlzdC5hZGQodCl9fWV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZighbi5pc0luUmVzdWx0KCkmJighbi5pc0luY2lkZW50RWRnZUluUmVzdWx0KCkmJigwPT09bi5nZXRFZGdlcygpLmdldERlZ3JlZSgpfHx0PT09d3IuSU5URVJTRUNUSU9OKSkpe2NvbnN0IGU9bi5nZXRMYWJlbCgpO3dyLmlzUmVzdWx0T2ZPcChlLHQpJiZ0aGlzLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludChuKX19fWJ1aWxkKHQpe3JldHVybiB0aGlzLmV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXModCksdGhpcy5fcmVzdWx0UG9pbnRMaXN0fX1jbGFzcyBtcntjb25zdHJ1Y3Rvcigpe3RoaXMuX2lzRmlyc3Q9ITAsdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9NTMsdGhpcy5fY29tbW9uQml0cz1uZXcgaSx0aGlzLl9jb21tb25TaWduRXhwPW51bGx9Z2V0Q29tbW9uKCl7cmV0dXJuIHIubG9uZ0JpdHNUb0RvdWJsZSh0aGlzLl9jb21tb25CaXRzKX1hZGQodCl7Y29uc3QgZT1yLmRvdWJsZVRvTG9uZ0JpdHModCk7aWYodGhpcy5faXNGaXJzdClyZXR1cm4gdGhpcy5fY29tbW9uQml0cz1lLHRoaXMuX2NvbW1vblNpZ25FeHA9bXIuc2lnbkV4cEJpdHModGhpcy5fY29tbW9uQml0cyksdGhpcy5faXNGaXJzdD0hMSxudWxsO2lmKG1yLnNpZ25FeHBCaXRzKGUpIT09dGhpcy5fY29tbW9uU2lnbkV4cClyZXR1cm4gdGhpcy5fY29tbW9uQml0cy5oaWdoPTAsdGhpcy5fY29tbW9uQml0cy5sb3c9MCxudWxsO3RoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50PW1yLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModGhpcy5fY29tbW9uQml0cyxlKSx0aGlzLl9jb21tb25CaXRzPW1yLnplcm9Mb3dlckJpdHModGhpcy5fY29tbW9uQml0cyw2NC0oMTIrdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQpKX10b1N0cmluZygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXIubG9uZ0JpdHNUb0RvdWJsZSh0KSxuPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiK2kudG9CaW5hcnlTdHJpbmcodCkscz1uLnN1YnN0cmluZyhuLmxlbmd0aC02NCk7cmV0dXJuIHMuc3Vic3RyaW5nKDAsMSkrXCIgIFwiK3Muc3Vic3RyaW5nKDEsMTIpK1wiKGV4cCkgXCIrcy5zdWJzdHJpbmcoMTIpK1wiIFsgXCIrZStcIiBdXCJ9fWdldENsYXNzKCl7cmV0dXJuIG1yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfXN0YXRpYyBnZXRCaXQodCxlKXtjb25zdCBuPTE8PGUlMzI7cmV0dXJuIGU8MzI/MCE9KHQubG93Jm4pPzE6MDowIT0odC5oaWdoJm4pPzE6MH1zdGF0aWMgc2lnbkV4cEJpdHModCl7cmV0dXJuIHQuaGlnaD4+PjIwfXN0YXRpYyB6ZXJvTG93ZXJCaXRzKHQsZSl7bGV0IG49XCJsb3dcIjtpZihlPjMyJiYodC5sb3c9MCxlJT0zMixuPVwiaGlnaFwiKSxlPjApe2NvbnN0IHM9ZTwzMj9+KCgxPDxlKS0xKTowO3Rbbl0mPXN9cmV0dXJuIHR9c3RhdGljIG51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModCxlKXtsZXQgbj0wO2ZvcihsZXQgcz01MjtzPj0wO3MtLSl7aWYobXIuZ2V0Qml0KHQscykhPT1tci5nZXRCaXQoZSxzKSlyZXR1cm4gbjtuKyt9cmV0dXJuIDUyfX1jbGFzcyBmcntjb25zdHJ1Y3Rvcigpe2ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvbW1vbkNvb3JkPW51bGwsdGhpcy5fY2NGaWx0ZXI9bmV3IHlyfWFkZENvbW1vbkJpdHModCl7Y29uc3QgZT1uZXcgeHIodGhpcy5fY29tbW9uQ29vcmQpO3QuYXBwbHkoZSksdC5nZW9tZXRyeUNoYW5nZWQoKX1yZW1vdmVDb21tb25CaXRzKHQpe2lmKDA9PT10aGlzLl9jb21tb25Db29yZC54JiYwPT09dGhpcy5fY29tbW9uQ29vcmQueSlyZXR1cm4gdDtjb25zdCBlPW5ldyBtKHRoaXMuX2NvbW1vbkNvb3JkKTtlLng9LWUueCxlLnk9LWUueTtjb25zdCBuPW5ldyB4cihlKTtyZXR1cm4gdC5hcHBseShuKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpLHR9Z2V0Q29tbW9uQ29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9jb21tb25Db29yZH1hZGQodCl7dC5hcHBseSh0aGlzLl9jY0ZpbHRlciksdGhpcy5fY29tbW9uQ29vcmQ9dGhpcy5fY2NGaWx0ZXIuZ2V0Q29tbW9uQ29vcmRpbmF0ZSgpfX1jbGFzcyB5cntjb25zdHJ1Y3Rvcigpe3lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvbW1vbkJpdHNYPW5ldyBtcix0aGlzLl9jb21tb25CaXRzWT1uZXcgbXJ9ZmlsdGVyKHQpe3RoaXMuX2NvbW1vbkJpdHNYLmFkZCh0LngpLHRoaXMuX2NvbW1vbkJpdHNZLmFkZCh0LnkpfWdldENvbW1vbkNvb3JkaW5hdGUoKXtyZXR1cm4gbmV3IG0odGhpcy5fY29tbW9uQml0c1guZ2V0Q29tbW9uKCksdGhpcy5fY29tbW9uQml0c1kuZ2V0Q29tbW9uKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIXX19Y2xhc3MgeHJ7Y29uc3RydWN0b3IoKXt4ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnRyYW5zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy50cmFucz10fWZpbHRlcih0LGUpe2NvbnN0IG49dC5nZXRPcmRpbmF0ZShlLDApK3RoaXMudHJhbnMueCxzPXQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLnRyYW5zLnk7dC5zZXRPcmRpbmF0ZShlLDAsbiksdC5zZXRPcmRpbmF0ZShlLDEscyl9aXNEb25lKCl7cmV0dXJuITF9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUF19fWZyLkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXI9eXIsZnIuVHJhbnNsYXRlcj14cjtjbGFzcyBFcntjb25zdHJ1Y3Rvcigpe0VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuX2Nicj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWUsdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgRXIodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSx3ci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe3JldHVybiBFci5vdmVybGF5T3AodCxlLHdyLklOVEVSU0VDVElPTil9c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSx3ci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe3JldHVybiBFci5vdmVybGF5T3AodCxlLHdyLkRJRkZFUkVOQ0UpfXNlbGZTbmFwKHQpe3JldHVybiBuZXcgbHIodCkuc25hcFRvKHQsdGhpcy5fc25hcFRvbGVyYW5jZSl9cmVtb3ZlQ29tbW9uQml0cyh0KXt0aGlzLl9jYnI9bmV3IGZyLHRoaXMuX2Nici5hZGQodFswXSksdGhpcy5fY2JyLmFkZCh0WzFdKTtjb25zdCBlPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiBlWzBdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHRbMF0uY29weSgpKSxlWzFdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHRbMV0uY29weSgpKSxlfXByZXBhcmVSZXN1bHQodCl7cmV0dXJuIHRoaXMuX2Nici5hZGRDb21tb25CaXRzKHQpLHR9Z2V0UmVzdWx0R2VvbWV0cnkodCl7Y29uc3QgZT10aGlzLnNuYXAodGhpcy5fZ2VvbSksbj13ci5vdmVybGF5T3AoZVswXSxlWzFdLHQpO3JldHVybiB0aGlzLnByZXBhcmVSZXN1bHQobil9Y2hlY2tWYWxpZCh0KXt0LmlzVmFsaWQoKXx8WS5vdXQucHJpbnRsbihcIlNuYXBwZWQgZ2VvbWV0cnkgaXMgaW52YWxpZFwiKX1jb21wdXRlU25hcFRvbGVyYW5jZSgpe3RoaXMuX3NuYXBUb2xlcmFuY2U9bHIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSl9c25hcCh0KXtjb25zdCBlPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0KTtyZXR1cm4gbHIuc25hcChlWzBdLGVbMV0sdGhpcy5fc25hcFRvbGVyYW5jZSl9fWNsYXNzIElye2NvbnN0cnVjdG9yKCl7SXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgSXIodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLklOVEVSU0VDVElPTil9c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLkRJRkZFUkVOQ0UpfWdldFJlc3VsdEdlb21ldHJ5KHQpe2xldCBlPW51bGwsbj0hMSxzPW51bGw7dHJ5e2U9d3Iub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSx0KTshMCYmKG49ITApfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7cz10fWlmKCFuKXRyeXtlPUVyLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0sdCl9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGg/czp0fXJldHVybiBlfX1jbGFzcyBOcntjb25zdHJ1Y3Rvcigpe05yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xpPW5ldyBqdCx0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2FyZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fYXJnPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLHRoaXMuX2FyZ1swXT1uZXcgYXMoMCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtOci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxnbi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3QuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oZS5nZXRQcmVjaXNpb25Nb2RlbCgpKT49MD90aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKSk6dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihlLmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuX2FyZz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9hcmdbMF09bmV3IGFzKDAsdCxuKSx0aGlzLl9hcmdbMV09bmV3IGFzKDEsZSxuKX19Z2V0QXJnR2VvbWV0cnkodCl7cmV0dXJuIHRoaXMuX2FyZ1t0XS5nZXRHZW9tZXRyeSgpfXNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHQpe3RoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsPXQsdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwpfX1jbGFzcyB3ciBleHRlbmRzIE5ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx3ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdExvY2F0b3I9bmV3IGZuLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fcmVzdWx0R2VvbT1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZWRnZUxpc3Q9bmV3IFRpLHRoaXMuX3Jlc3VsdFBvbHlMaXN0PW5ldyBMLHRoaXMuX3Jlc3VsdExpbmVMaXN0PW5ldyBMLHRoaXMuX3Jlc3VsdFBvaW50TGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtOci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fZ3JhcGg9bmV3IGxzKG5ldyBTaSksdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCl9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyB3cih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiB3ci5jcmVhdGVFbXB0eVJlc3VsdCh3ci5VTklPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpdGhyb3cgbmV3IHMoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIik7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpcmV0dXJuIHdyLmNyZWF0ZUVtcHR5UmVzdWx0KHdyLklOVEVSU0VDVElPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7Y29uc3Qgbj1lO3JldHVybiBjZS5tYXAodCxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW01hcE9wXX1tYXAodCl7cmV0dXJuIHdyLmludGVyc2VjdGlvbih0LG4pfX0pfXJldHVybiBJci5vdmVybGF5T3AodCxlLHdyLklOVEVSU0VDVElPTil9c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gd3IuY3JlYXRlRW1wdHlSZXN1bHQod3IuU1lNRElGRkVSRU5DRSx0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpdGhyb3cgbmV3IHMoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIik7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuU1lNRElGRkVSRU5DRSl9c3RhdGljIHJlc3VsdERpbWVuc2lvbih0LGUsbil7Y29uc3Qgcz1lLmdldERpbWVuc2lvbigpLGk9bi5nZXREaW1lbnNpb24oKTtsZXQgcj0tMTtzd2l0Y2godCl7Y2FzZSB3ci5JTlRFUlNFQ1RJT046cj1NYXRoLm1pbihzLGkpO2JyZWFrO2Nhc2Ugd3IuVU5JT046cj1NYXRoLm1heChzLGkpO2JyZWFrO2Nhc2Ugd3IuRElGRkVSRU5DRTpyPXM7YnJlYWs7Y2FzZSB3ci5TWU1ESUZGRVJFTkNFOnI9TWF0aC5tYXgocyxpKX1yZXR1cm4gcn1zdGF0aWMgY3JlYXRlRW1wdHlSZXN1bHQodCxlLG4scyl7Y29uc3QgaT13ci5yZXN1bHREaW1lbnNpb24odCxlLG4pO3JldHVybiBzLmNyZWF0ZUVtcHR5KGkpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIHdyLmNyZWF0ZUVtcHR5UmVzdWx0KHdyLkRJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpdGhyb3cgbmV3IHMoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIik7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuRElGRkVSRU5DRSl9c3RhdGljIGlzUmVzdWx0T2ZPcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0TG9jYXRpb24oMCkscz10LmdldExvY2F0aW9uKDEpO3JldHVybiB3ci5pc1Jlc3VsdE9mT3AobixzLGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07c3dpdGNoKHQ9PT1RdC5CT1VOREFSWSYmKHQ9UXQuSU5URVJJT1IpLGU9PT1RdC5CT1VOREFSWSYmKGU9UXQuSU5URVJJT1IpLG4pe2Nhc2Ugd3IuSU5URVJTRUNUSU9OOnJldHVybiB0PT09UXQuSU5URVJJT1ImJmU9PT1RdC5JTlRFUklPUjtjYXNlIHdyLlVOSU9OOnJldHVybiB0PT09UXQuSU5URVJJT1J8fGU9PT1RdC5JTlRFUklPUjtjYXNlIHdyLkRJRkZFUkVOQ0U6cmV0dXJuIHQ9PT1RdC5JTlRFUklPUiYmZSE9PVF0LklOVEVSSU9SO2Nhc2Ugd3IuU1lNRElGRkVSRU5DRTpyZXR1cm4gdD09PVF0LklOVEVSSU9SJiZlIT09UXQuSU5URVJJT1J8fHQhPT1RdC5JTlRFUklPUiYmZT09PVF0LklOVEVSSU9SfXJldHVybiExfX1pbnNlcnRVbmlxdWVFZGdlKHQpe2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7Y29uc3Qgbj1lLmdldExhYmVsKCk7bGV0IHM9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KHM9bmV3IEJuKHQuZ2V0TGFiZWwoKSkscy5mbGlwKCkpO2NvbnN0IGk9ZS5nZXREZXB0aCgpO2kuaXNOdWxsKCkmJmkuYWRkKG4pLGkuYWRkKHMpLG4ubWVyZ2Uocyl9ZWxzZSB0aGlzLl9lZGdlTGlzdC5hZGQodCl9Z2V0R3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Y2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0U3ltKCk7ZS5pc0luUmVzdWx0KCkmJm4uaXNJblJlc3VsdCgpJiYoZS5zZXRJblJlc3VsdCghMSksbi5zZXRJblJlc3VsdCghMSkpfX1pc0NvdmVyZWRCeUxBKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRMaW5lTGlzdCl8fCEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRQb2x5TGlzdCl9Y29tcHV0ZUdlb21ldHJ5KHQsZSxuLHMpe2NvbnN0IGk9bmV3IEw7cmV0dXJuIGkuYWRkQWxsKHQpLGkuYWRkQWxsKGUpLGkuYWRkQWxsKG4pLGkuaXNFbXB0eSgpP3dyLmNyZWF0ZUVtcHR5UmVzdWx0KHMsdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCksdGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCksdGhpcy5fZ2VvbUZhY3QpOnRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkoaSl9bWVyZ2VTeW1MYWJlbHMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5tZXJnZVN5bUxhYmVscygpfX1pc0NvdmVyZWQodCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtpZih0aGlzLl9wdExvY2F0b3IubG9jYXRlKHQsZSkhPT1RdC5FWFRFUklPUilyZXR1cm4hMH1yZXR1cm4hMX1yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKXtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT10aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuLmlzQ29sbGFwc2VkKCkmJihlLnJlbW92ZSgpLHQuYWRkKG4uZ2V0Q29sbGFwc2VkRWRnZSgpKSl9dGhpcy5fZWRnZUxpc3QuYWRkQWxsKHQpfXVwZGF0ZU5vZGVMYWJlbGxpbmcoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZXMoKS5nZXRMYWJlbCgpO2UuZ2V0TGFiZWwoKS5tZXJnZShuKX19Z2V0UmVzdWx0R2VvbWV0cnkodCl7cmV0dXJuIHRoaXMuY29tcHV0ZU92ZXJsYXkodCksdGhpcy5fcmVzdWx0R2VvbX1pbnNlcnRVbmlxdWVFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2UodCl9fWNvbXB1dGVPdmVybGF5KHQpe3RoaXMuY29weVBvaW50cygwKSx0aGlzLmNvcHlQb2ludHMoMSksdGhpcy5fYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSx0aGlzLl9saSwhMCk7Y29uc3QgZT1uZXcgTDt0aGlzLl9hcmdbMF0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuaW5zZXJ0VW5pcXVlRWRnZXMoZSksdGhpcy5jb21wdXRlTGFiZWxzRnJvbURlcHRocygpLHRoaXMucmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCksZHIuY2hlY2tWYWxpZCh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLl9ncmFwaC5hZGRFZGdlcyh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLmNvbXB1dGVMYWJlbGxpbmcoKSx0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGVzKCksdGhpcy5maW5kUmVzdWx0QXJlYUVkZ2VzKHQpLHRoaXMuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKTtjb25zdCBuPW5ldyBwaSh0aGlzLl9nZW9tRmFjdCk7bi5hZGQodGhpcy5fZ3JhcGgpLHRoaXMuX3Jlc3VsdFBvbHlMaXN0PW4uZ2V0UG9seWdvbnMoKTtjb25zdCBzPW5ldyBfcih0aGlzLHRoaXMuX2dlb21GYWN0LHRoaXMuX3B0TG9jYXRvcik7dGhpcy5fcmVzdWx0TGluZUxpc3Q9cy5idWlsZCh0KTtjb25zdCBpPW5ldyBwcih0aGlzLHRoaXMuX2dlb21GYWN0LHRoaXMuX3B0TG9jYXRvcik7dGhpcy5fcmVzdWx0UG9pbnRMaXN0PWkuYnVpbGQodCksdGhpcy5fcmVzdWx0R2VvbT10aGlzLmNvbXB1dGVHZW9tZXRyeSh0aGlzLl9yZXN1bHRQb2ludExpc3QsdGhpcy5fcmVzdWx0TGluZUxpc3QsdGhpcy5fcmVzdWx0UG9seUxpc3QsdCl9bGFiZWxJbmNvbXBsZXRlTm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9Y29weVBvaW50cyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLl9ncmFwaC5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fWZpbmRSZXN1bHRBcmVhRWRnZXModCl7Zm9yKGxldCBlPXRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCk7cy5pc0FyZWEoKSYmIW4uaXNJbnRlcmlvckFyZWFFZGdlKCkmJndyLmlzUmVzdWx0T2ZPcChzLmdldExvY2F0aW9uKDAsYm4uUklHSFQpLHMuZ2V0TG9jYXRpb24oMSxibi5SSUdIVCksdCkmJm4uc2V0SW5SZXN1bHQoITApfX1jb21wdXRlTGFiZWxzRnJvbURlcHRocygpe2ZvcihsZXQgdD10aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKSxzPWUuZ2V0RGVwdGgoKTtpZighcy5pc051bGwoKSl7cy5ub3JtYWxpemUoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKW4uaXNOdWxsKHQpfHwhbi5pc0FyZWEoKXx8cy5pc051bGwodCl8fCgwPT09cy5nZXREZWx0YSh0KT9uLnRvTGluZSh0KTooZy5pc1RydWUoIXMuaXNOdWxsKHQsYm4uTEVGVCksXCJkZXB0aCBvZiBMRUZUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24odCxibi5MRUZULHMuZ2V0TG9jYXRpb24odCxibi5MRUZUKSksZy5pc1RydWUoIXMuaXNOdWxsKHQsYm4uUklHSFQpLFwiZGVwdGggb2YgUklHSFQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbih0LGJuLlJJR0hULHMuZ2V0TG9jYXRpb24odCxibi5SSUdIVCkpKSl9fX1jb21wdXRlTGFiZWxsaW5nKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLl9hcmcpfXRoaXMubWVyZ2VTeW1MYWJlbHMoKSx0aGlzLnVwZGF0ZU5vZGVMYWJlbGxpbmcoKX1sYWJlbEluY29tcGxldGVOb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO2UuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKGUsMCk6dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKGUsMSkpLGUuZ2V0RWRnZXMoKS51cGRhdGVMYWJlbGxpbmcobil9fWlzQ292ZXJlZEJ5QSh0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0UG9seUxpc3QpfX13ci5JTlRFUlNFQ1RJT049MSx3ci5VTklPTj0yLHdyLkRJRkZFUkVOQ0U9Myx3ci5TWU1ESUZGRVJFTkNFPTQ7dmFyIENyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLHNuYXA6Y3IsT3ZlcmxheU9wOndyfSk7Y2xhc3MgU3IgZXh0ZW5kcyBIaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksU3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZWRnZVJpbmc9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fbGFiZWw9LTE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107SGkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixzKX1nZXROZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9aXNJblJpbmcoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX2VkZ2VSaW5nfXNldFJpbmcodCl7dGhpcy5fZWRnZVJpbmc9dH1zZXRMYWJlbCh0KXt0aGlzLl9sYWJlbD10fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfXNldE5leHQodCl7dGhpcy5fbmV4dD10fWdldFJpbmcoKXtyZXR1cm4gdGhpcy5fZWRnZVJpbmd9fWNsYXNzIExyIGV4dGVuZHMgWml7Y29uc3RydWN0b3IoKXtzdXBlcigpLExyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9saW5lfX1jbGFzcyBUcntjb25zdHJ1Y3Rvcigpe1RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1uZXcgTHQsdGhpcy5fZ2VvbUdyYXBoPW51bGwsdGhpcy5fZGlzY29ubmVjdGVkUmluZ2Nvb3JkPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUdyYXBoPXR9c3RhdGljIGZpbmREaWZmZXJlbnRQb2ludCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlKSlyZXR1cm4gdFtuXTtyZXR1cm4gbnVsbH12aXNpdEludGVyaW9yUmluZyh0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpLHM9blswXSxpPVRyLmZpbmREaWZmZXJlbnRQb2ludChuLHMpLHI9ZS5maW5kRWRnZUluU2FtZURpcmVjdGlvbihzLGkpLG89ZS5maW5kRWRnZUVuZChyKTtsZXQgbD1udWxsO28uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGJuLlJJR0hUKT09PVF0LklOVEVSSU9SP2w9bzpvLmdldFN5bSgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxibi5SSUdIVCk9PT1RdC5JTlRFUklPUiYmKGw9by5nZXRTeW0oKSksZy5pc1RydWUobnVsbCE9PWwsXCJ1bmFibGUgdG8gZmluZCBkaXJFZGdlIHdpdGggSW50ZXJpb3Igb24gUkhTXCIpLHRoaXMudmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzKGwpfXZpc2l0U2hlbGxJbnRlcmlvcnModCxlKXtpZih0IGluc3RhbmNlb2YgcnQpe2NvbnN0IG49dDt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSl9aWYodCBpbnN0YW5jZW9mIHl0KXtjb25zdCBuPXQ7Zm9yKGxldCB0PTA7dDxuLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IHM9bi5nZXRHZW9tZXRyeU4odCk7dGhpcy52aXNpdEludGVyaW9yUmluZyhzLmdldEV4dGVyaW9yUmluZygpLGUpfX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmR9c2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0KHQpe2ZvcihsZXQgZT10LmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsYm4uUklHSFQpPT09UXQuSU5URVJJT1ImJnQuc2V0SW5SZXN1bHQoITApfX12aXNpdExpbmtlZERpcmVjdGVkRWRnZXModCl7Y29uc3QgZT10O2xldCBuPXQ7ZG97Zy5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERpcmVjdGVkIEVkZ2VcIiksbi5zZXRWaXNpdGVkKCEwKSxuPW4uZ2V0TmV4dCgpfXdoaWxlKG4hPT1lKX1idWlsZEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQuaXNJblJlc3VsdCgpJiZudWxsPT09dC5nZXRFZGdlUmluZygpKXtjb25zdCBuPW5ldyBfaSh0LHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7bi5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTtjb25zdCBzPW4uYnVpbGRNaW5pbWFsUmluZ3MoKTtlLmFkZEFsbChzKX19cmV0dXJuIGV9aGFzVW52aXNpdGVkU2hlbGxFZGdlKHQpe2ZvcihsZXQgZT0wO2U8dC5zaXplKCk7ZSsrKXtjb25zdCBuPXQuZ2V0KGUpO2lmKG4uaXNIb2xlKCkpY29udGludWU7Y29uc3Qgcz1uLmdldEVkZ2VzKCk7bGV0IGk9cy5nZXQoMCk7aWYoaS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsYm4uUklHSFQpPT09UXQuSU5URVJJT1IpZm9yKGxldCB0PTA7dDxzLnNpemUoKTt0KyspaWYoaT1zLmdldCh0KSwhaS5pc1Zpc2l0ZWQoKSlyZXR1cm4gdGhpcy5fZGlzY29ubmVjdGVkUmluZ2Nvb3JkPWkuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfWlzSW50ZXJpb3JzQ29ubmVjdGVkKCl7Y29uc3QgdD1uZXcgTDt0aGlzLl9nZW9tR3JhcGguY29tcHV0ZVNwbGl0RWRnZXModCk7Y29uc3QgZT1uZXcgbHMobmV3IFNpKTtlLmFkZEVkZ2VzKHQpLHRoaXMuc2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0KGUpLGUubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTtjb25zdCBuPXRoaXMuYnVpbGRFZGdlUmluZ3MoZS5nZXRFZGdlRW5kcygpKTtyZXR1cm4gdGhpcy52aXNpdFNoZWxsSW50ZXJpb3JzKHRoaXMuX2dlb21HcmFwaC5nZXRHZW9tZXRyeSgpLGUpLCF0aGlzLmhhc1VudmlzaXRlZFNoZWxsRWRnZShuKX19Y2xhc3MgUnJ7Y3JlYXRlRWRnZUVuZEZvck5leHQodCxlLG4scyl7Y29uc3QgaT1uLnNlZ21lbnRJbmRleCsxO2lmKGk+PXQuZ2V0TnVtUG9pbnRzKCkmJm51bGw9PT1zKXJldHVybiBudWxsO2xldCByPXQuZ2V0Q29vcmRpbmF0ZShpKTtudWxsIT09cyYmcy5zZWdtZW50SW5kZXg9PT1uLnNlZ21lbnRJbmRleCYmKHI9cy5jb29yZCk7Y29uc3Qgbz1uZXcgc3ModCxuLmNvb3JkLHIsbmV3IEJuKHQuZ2V0TGFiZWwoKSkpO2UuYWRkKG8pfWNyZWF0ZUVkZ2VFbmRGb3JQcmV2KHQsZSxuLHMpe2xldCBpPW4uc2VnbWVudEluZGV4O2lmKDA9PT1uLmRpc3Qpe2lmKDA9PT1pKXJldHVybiBudWxsO2ktLX1sZXQgcj10LmdldENvb3JkaW5hdGUoaSk7bnVsbCE9PXMmJnMuc2VnbWVudEluZGV4Pj1pJiYocj1zLmNvb3JkKTtjb25zdCBvPW5ldyBCbih0LmdldExhYmVsKCkpO28uZmxpcCgpO2NvbnN0IGw9bmV3IHNzKHQsbi5jb29yZCxyLG8pO2UuYWRkKGwpfWNvbXB1dGVFZGdlRW5kcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO2ZvcihsZXQgbj10O24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLmNvbXB1dGVFZGdlRW5kcyh0LGUpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtuLmFkZEVuZHBvaW50cygpO2NvbnN0IHM9bi5pdGVyYXRvcigpO2xldCBpPW51bGwscj1udWxsO2lmKCFzLmhhc05leHQoKSlyZXR1cm4gbnVsbDtsZXQgbz1zLm5leHQoKTtkb3tpPXIscj1vLG89bnVsbCxzLmhhc05leHQoKSYmKG89cy5uZXh0KCkpLG51bGwhPT1yJiYodGhpcy5jcmVhdGVFZGdlRW5kRm9yUHJldih0LGUscixpKSx0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JOZXh0KHQsZSxyLG8pKX13aGlsZShudWxsIT09cil9fX1jbGFzcyBQciBleHRlbmRzIHNze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxQci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9lZGdlRW5kcz1uZXcgTCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07UHIuY29uc3RydWN0b3JfLmNhbGwodGhpcyxudWxsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3NzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC5nZXRFZGdlKCksdC5nZXRDb29yZGluYXRlKCksdC5nZXREaXJlY3RlZENvb3JkaW5hdGUoKSxuZXcgQm4odC5nZXRMYWJlbCgpKSksdGhpcy5pbnNlcnQodCl9fWluc2VydCh0KXt0aGlzLl9lZGdlRW5kcy5hZGQodCl9cHJpbnQodCl7dC5wcmludGxuKFwiRWRnZUVuZEJ1bmRsZS0tXFx4M2UgTGFiZWw6IFwiK3RoaXMuX2xhYmVsKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCksdC5wcmludGxuKCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRzLml0ZXJhdG9yKCl9Z2V0RWRnZUVuZHMoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZHN9Y29tcHV0ZUxhYmVsT24odCxlKXtsZXQgbj0wLHM9ITE7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IGk9ZS5uZXh0KCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtpPT09UXQuQk9VTkRBUlkmJm4rKyxpPT09UXQuSU5URVJJT1ImJihzPSEwKX1sZXQgaT1RdC5OT05FO3MmJihpPVF0LklOVEVSSU9SKSxuPjAmJihpPWFzLmRldGVybWluZUJvdW5kYXJ5KGUsbikpLHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsaSl9Y29tcHV0ZUxhYmVsU2lkZSh0LGUpe2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHMuZ2V0TGFiZWwoKS5pc0FyZWEoKSl7Y29uc3Qgbj1zLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCxlKTtpZihuPT09UXQuSU5URVJJT1IpcmV0dXJuIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSxRdC5JTlRFUklPUiksbnVsbDtuPT09UXQuRVhURVJJT1ImJnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSxRdC5FWFRFUklPUil9fX1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1jb21wdXRlTGFiZWxTaWRlcyh0KXt0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxibi5MRUZUKSx0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxibi5SSUdIVCl9dXBkYXRlSU0odCl7dHMudXBkYXRlSU0odGhpcy5fbGFiZWwsdCl9Y29tcHV0ZUxhYmVsKHQpe2xldCBlPSExO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRMYWJlbCgpLmlzQXJlYSgpJiYoZT0hMCl9dGhpcy5fbGFiZWw9ZT9uZXcgQm4oUXQuTk9ORSxRdC5OT05FLFF0Lk5PTkUpOm5ldyBCbihRdC5OT05FKTtmb3IobGV0IG49MDtuPDI7bisrKXRoaXMuY29tcHV0ZUxhYmVsT24obix0KSxlJiZ0aGlzLmNvbXB1dGVMYWJlbFNpZGVzKG4pfX1jbGFzcyBPciBleHRlbmRzIHdpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKX11cGRhdGVJTSh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkudXBkYXRlSU0odCl9fWluc2VydCh0KXtsZXQgZT10aGlzLl9lZGdlTWFwLmdldCh0KTtudWxsPT09ZT8oZT1uZXcgUHIodCksdGhpcy5pbnNlcnRFZGdlRW5kKHQsZSkpOmUuaW5zZXJ0KHQpfX1jbGFzcyB2ciBleHRlbmRzIGVze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx2ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtlcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9dXBkYXRlSU1Gcm9tRWRnZXModCl7dGhpcy5fZWRnZXMudXBkYXRlSU0odCl9Y29tcHV0ZUlNKHQpe3Quc2V0QXRMZWFzdElmVmFsaWQodGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oMCksdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oMSksMCl9fWNsYXNzIGJyIGV4dGVuZHMgb3N7Y29uc3RydWN0b3IoKXtzdXBlcigpfWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyB2cih0LG5ldyBPcil9fWNsYXNzIE1ye2NvbnN0cnVjdG9yKCl7TXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZXM9bmV3IG5zKG5ldyBicil9aW5zZXJ0RWRnZUVuZHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkKHQpfX1nZXROb2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKX1jb3B5Tm9kZXNBbmRMYWJlbHModCxlKXtmb3IobGV0IG49dC5nZXROb2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkTm9kZSh0LmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwoZSx0LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSkpfX1idWlsZCh0KXt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKHQsMCk7Y29uc3QgZT0obmV3IFJyKS5jb21wdXRlRWRnZUVuZHModC5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhlKX1jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCxlKXtmb3IobGV0IG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkscz10LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSk7Zm9yKGxldCBuPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxpPXRoaXMuX25vZGVzLmFkZE5vZGUodC5jb29yZCk7cz09PVF0LkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeShlKTppLmdldExhYmVsKCkuaXNOdWxsKGUpJiZpLnNldExhYmVsKGUsUXQuSU5URVJJT1IpfX19fWNsYXNzIERye2NvbnN0cnVjdG9yKCl7RHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX2dlb21HcmFwaD1udWxsLHRoaXMuX25vZGVHcmFwaD1uZXcgTXIsdGhpcy5faW52YWxpZFBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUdyYXBoPXR9aXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50KCl7Zm9yKGxldCB0PXRoaXMuX25vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7aWYoIWUuZ2V0RWRnZXMoKS5pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHRoaXMuX2dlb21HcmFwaCkpcmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludD1lLmdldENvb3JkaW5hdGUoKS5jb3B5KCksITF9cmV0dXJuITB9Z2V0SW52YWxpZFBvaW50KCl7cmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludH1oYXNEdXBsaWNhdGVSaW5ncygpe2ZvcihsZXQgdD10aGlzLl9ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtmb3IobGV0IGU9dC5uZXh0KCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0LmdldEVkZ2VFbmRzKCkuc2l6ZSgpPjEpcmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludD10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlKDApLCEwfX1yZXR1cm4hMX1pc05vZGVDb25zaXN0ZW50QXJlYSgpe2NvbnN0IHQ9dGhpcy5fZ2VvbUdyYXBoLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITAsITApO3JldHVybiB0Lmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLl9pbnZhbGlkUG9pbnQ9dC5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKToodGhpcy5fbm9kZUdyYXBoLmJ1aWxkKHRoaXMuX2dlb21HcmFwaCksdGhpcy5pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKSl9fWNsYXNzIEFye2NvbnN0cnVjdG9yKCl7QXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9yaW5ncz1uZXcgTCx0aGlzLl90b3RhbEVudj1uZXcgTyx0aGlzLl9pbmRleD1udWxsLHRoaXMuX25lc3RlZFB0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ3JhcGg9dH1idWlsZEluZGV4KCl7dGhpcy5faW5kZXg9bmV3IGJzO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcmluZ3Muc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9yaW5ncy5nZXQodCksbj1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTt0aGlzLl9pbmRleC5pbnNlcnQobixlKX19Z2V0TmVzdGVkUG9pbnQoKXtyZXR1cm4gdGhpcy5fbmVzdGVkUHR9aXNOb25OZXN0ZWQoKXt0aGlzLmJ1aWxkSW5kZXgoKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3JpbmdzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fcmluZ3MuZ2V0KHQpLG49ZS5nZXRDb29yZGluYXRlcygpLHM9dGhpcy5faW5kZXgucXVlcnkoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpO2ZvcihsZXQgdD0wO3Q8cy5zaXplKCk7dCsrKXtjb25zdCBpPXMuZ2V0KHQpLHI9aS5nZXRDb29yZGluYXRlcygpO2lmKGU9PT1pKWNvbnRpbnVlO2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSljb250aW51ZTtjb25zdCBvPUdyLmZpbmRQdE5vdE5vZGUobixpLHRoaXMuX2dyYXBoKTtpZihudWxsPT09byljb250aW51ZTtpZihVZS5pc0luUmluZyhvLHIpKXJldHVybiB0aGlzLl9uZXN0ZWRQdD1vLCExfX1yZXR1cm4hMH1hZGQodCl7dGhpcy5fcmluZ3MuYWRkKHQpLHRoaXMuX3RvdGFsRW52LmV4cGFuZFRvSW5jbHVkZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSl9fWNsYXNzIEZye2NvbnN0cnVjdG9yKCl7RnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZXJyb3JUeXBlPW51bGwsdGhpcy5fcHQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07RnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Vycm9yVHlwZT10LG51bGwhPT1lJiYodGhpcy5fcHQ9ZS5jb3B5KCkpfX1nZXRFcnJvclR5cGUoKXtyZXR1cm4gdGhpcy5fZXJyb3JUeXBlfWdldE1lc3NhZ2UoKXtyZXR1cm4gRnIuZXJyTXNnW3RoaXMuX2Vycm9yVHlwZV19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH10b1N0cmluZygpe2xldCB0PVwiXCI7cmV0dXJuIG51bGwhPT10aGlzLl9wdCYmKHQ9XCIgYXQgb3IgbmVhciBwb2ludCBcIit0aGlzLl9wdCksdGhpcy5nZXRNZXNzYWdlKCkrdH19RnIuRVJST1I9MCxGci5SRVBFQVRFRF9QT0lOVD0xLEZyLkhPTEVfT1VUU0lERV9TSEVMTD0yLEZyLk5FU1RFRF9IT0xFUz0zLEZyLkRJU0NPTk5FQ1RFRF9JTlRFUklPUj00LEZyLlNFTEZfSU5URVJTRUNUSU9OPTUsRnIuUklOR19TRUxGX0lOVEVSU0VDVElPTj02LEZyLk5FU1RFRF9TSEVMTFM9NyxGci5EVVBMSUNBVEVfUklOR1M9OCxGci5UT09fRkVXX1BPSU5UUz05LEZyLklOVkFMSURfQ09PUkRJTkFURT0xMCxGci5SSU5HX05PVF9DTE9TRUQ9MTEsRnIuZXJyTXNnPVtcIlRvcG9sb2d5IFZhbGlkYXRpb24gRXJyb3JcIixcIlJlcGVhdGVkIFBvaW50XCIsXCJIb2xlIGxpZXMgb3V0c2lkZSBzaGVsbFwiLFwiSG9sZXMgYXJlIG5lc3RlZFwiLFwiSW50ZXJpb3IgaXMgZGlzY29ubmVjdGVkXCIsXCJTZWxmLWludGVyc2VjdGlvblwiLFwiUmluZyBTZWxmLWludGVyc2VjdGlvblwiLFwiTmVzdGVkIHNoZWxsc1wiLFwiRHVwbGljYXRlIFJpbmdzXCIsXCJUb28gZmV3IGRpc3RpbmN0IHBvaW50cyBpbiBnZW9tZXRyeSBjb21wb25lbnRcIixcIkludmFsaWQgQ29vcmRpbmF0ZVwiLFwiUmluZyBpcyBub3QgY2xvc2VkXCJdO2NsYXNzIEdye2NvbnN0cnVjdG9yKCl7R3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcGFyZW50R2VvbWV0cnk9bnVsbCx0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPSExLHRoaXMuX3ZhbGlkRXJyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50R2VvbWV0cnk9dH1zdGF0aWMgZmluZFB0Tm90Tm9kZSh0LGUsbil7Y29uc3Qgcz1uLmZpbmRFZGdlKGUpLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49dFtlXTtpZighcy5pc0ludGVyc2VjdGlvbihuKSlyZXR1cm4gbn1yZXR1cm4gbnVsbH1zdGF0aWMgaXNWYWxpZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7cmV0dXJuIG5ldyBHcihhcmd1bWVudHNbMF0pLmlzVmFsaWQoKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiFyLmlzTmFOKHQueCkmJighci5pc0luZmluaXRlKHQueCkmJighci5pc05hTih0LnkpJiYhci5pc0luZmluaXRlKHQueSkpKX19Y2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZighR3IuaXNWYWxpZCh0W2VdKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLklOVkFMSURfQ09PUkRJTkFURSx0W2VdKSxudWxsfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBydCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19Y2hlY2tIb2xlc05vdE5lc3RlZCh0LGUpe2lmKHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk8PTApcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgQXIoZSk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgcz10LmdldEludGVyaW9yUmluZ04oZSk7cy5pc0VtcHR5KCl8fG4uYWRkKHMpfW4uaXNOb25OZXN0ZWQoKXx8KHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5ORVNURURfSE9MRVMsbi5nZXROZXN0ZWRQb2ludCgpKSl9Y2hlY2tDb25zaXN0ZW50QXJlYSh0KXtjb25zdCBlPW5ldyBEcih0KTtpZighZS5pc05vZGVDb25zaXN0ZW50QXJlYSgpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuU0VMRl9JTlRFUlNFQ1RJT04sZS5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbDtlLmhhc0R1cGxpY2F0ZVJpbmdzKCkmJih0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuRFVQTElDQVRFX1JJTkdTLGUuZ2V0SW52YWxpZFBvaW50KCkpKX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLl9wYXJlbnRHZW9tZXRyeSksbnVsbD09PXRoaXMuX3ZhbGlkRXJyfWNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZXMoKSxyPUdyLmZpbmRQdE5vdE5vZGUocyxlLG4pO2lmKG51bGwhPT1yKXtpZighVWUuaXNJblJpbmcocixpKSlyZXR1cm4gcn1jb25zdCBvPUdyLmZpbmRQdE5vdE5vZGUoaSx0LG4pO2lmKG51bGwhPT1vKXtyZXR1cm4gVWUuaXNJblJpbmcobyxzKT9vOm51bGx9cmV0dXJuIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJwb2ludHMgaW4gc2hlbGwgYW5kIGhvbGUgYXBwZWFyIHRvIGJlIGVxdWFsXCIpLG51bGx9Y2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyh0KXtmb3IobGV0IGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmcodC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKHQpe2NvbnN0IGU9bmV3IFRyKHQpO2UuaXNJbnRlcmlvcnNDb25uZWN0ZWQoKXx8KHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5ESVNDT05ORUNURURfSU5URVJJT1IsZS5nZXRDb29yZGluYXRlKCkpKX1jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmcodCl7Y29uc3QgZT1uZXcgYXQ7bGV0IG49ITA7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYobiluPSExO2Vsc2V7aWYoZS5jb250YWlucyh0LmNvb3JkKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT04sdC5jb29yZCksbnVsbDtlLmFkZCh0LmNvb3JkKX19fWNoZWNrSG9sZXNJblNoZWxsKHQsZSl7aWYodC5nZXROdW1JbnRlcmlvclJpbmcoKTw9MClyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0RXh0ZXJpb3JSaW5nKCkscz1uLmlzRW1wdHkoKSxpPW5ldyB6ZShuKTtmb3IobGV0IHI9MDtyPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cisrKXtjb25zdCBvPXQuZ2V0SW50ZXJpb3JSaW5nTihyKTtsZXQgbD1udWxsO2lmKG8uaXNFbXB0eSgpKWNvbnRpbnVlO2lmKGw9R3IuZmluZFB0Tm90Tm9kZShvLmdldENvb3JkaW5hdGVzKCksbixlKSxudWxsPT09bClyZXR1cm4gbnVsbDtpZihzfHxRdC5FWFRFUklPUj09PWkubG9jYXRlKGwpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuSE9MRV9PVVRTSURFX1NIRUxMLGwpLG51bGx9fWNoZWNrVG9vRmV3UG9pbnRzKHQpe2lmKHQuaGFzVG9vRmV3UG9pbnRzKCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5UT09fRkVXX1BPSU5UUyx0LmdldEludmFsaWRQb2ludCgpKSxudWxsfWdldFZhbGlkYXRpb25FcnJvcigpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5fcGFyZW50R2VvbWV0cnkpLHRoaXMuX3ZhbGlkRXJyfWNoZWNrVmFsaWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGV0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHV0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGd0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBhcygwLHQpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IG49bmV3IGp0O2UuY29tcHV0ZVNlbGZOb2RlcyhuLCEwLCEwKSx0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgYXMoMCx0KTt0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBydCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmdzKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBhcygwLHQpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQmJih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKSlyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKHQsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc05vdE5lc3RlZCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB5dCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmdzKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1jb25zdCBlPW5ldyBhcygwLHQpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQmJih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKSlyZXR1cm4gbnVsbDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKHMsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO2lmKHRoaXMuY2hlY2tIb2xlc05vdE5lc3RlZChzLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1pZih0aGlzLmNoZWNrU2hlbGxzTm90TmVzdGVkKHQsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGh0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZih0aGlzLmNoZWNrVmFsaWQobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fdmFsaWRFcnI9bnVsbCx0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgZXQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHV0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBndCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgJCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgcnQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHl0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIGh0KSl0aHJvdyBuZXcgSyh0LmdldEdlb21ldHJ5VHlwZSgpKTt0aGlzLmNoZWNrVmFsaWQodCl9fX1zZXRTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCh0KXt0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPXR9Y2hlY2tTaGVsbE5vdE5lc3RlZCh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldEV4dGVyaW9yUmluZygpO2lmKGkuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHI9aS5nZXRDb29yZGluYXRlcygpLG89R3IuZmluZFB0Tm90Tm9kZShzLGksbik7aWYobnVsbD09PW8pcmV0dXJuIG51bGw7aWYoIVVlLmlzSW5SaW5nKG8scikpcmV0dXJuIG51bGw7aWYoZS5nZXROdW1JbnRlcmlvclJpbmcoKTw9MClyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLk5FU1RFRF9TSEVMTFMsbyksbnVsbDtsZXQgbD1udWxsO2ZvcihsZXQgcz0wO3M8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe2NvbnN0IGk9ZS5nZXRJbnRlcmlvclJpbmdOKHMpO2lmKGw9dGhpcy5jaGVja1NoZWxsSW5zaWRlSG9sZSh0LGksbiksbnVsbD09PWwpcmV0dXJuIG51bGx9dGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLk5FU1RFRF9TSEVMTFMsbCl9Y2hlY2tDbG9zZWRSaW5ncyh0KXtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEV4dGVyaW9yUmluZygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEludGVyaW9yUmluZ04oZSkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1jaGVja0Nsb3NlZFJpbmcodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYoIXQuaXNDbG9zZWQoKSl7bGV0IGU9bnVsbDt0LmdldE51bVBvaW50cygpPj0xJiYoZT10LmdldENvb3JkaW5hdGVOKDApKSx0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuUklOR19OT1RfQ0xPU0VELGUpfX1jaGVja1NoZWxsc05vdE5lc3RlZCh0LGUpe2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pLmdldEV4dGVyaW9yUmluZygpO2ZvcihsZXQgaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtpZihuPT09aSljb250aW51ZTtjb25zdCByPXQuZ2V0R2VvbWV0cnlOKGkpO2lmKHRoaXMuY2hlY2tTaGVsbE5vdE5lc3RlZChzLHIsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX19fWNsYXNzIHFye2NvbnN0cnVjdG9yKCl7cXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2RlTGlzdD1uZXcgTCx0aGlzLl9sb3dlc3RFZGdlPW51bGwsdGhpcy5fcmluZz1udWxsLHRoaXMuX2xvY2F0b3I9bnVsbCx0aGlzLl9yaW5nUHRzPW51bGwsdGhpcy5faG9sZXM9bnVsbCx0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuX2lzUHJvY2Vzc2VkPSExLHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITEsdGhpcy5faXNJbmNsdWRlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9c3RhdGljIGZpbmREaXJFZGdlc0luUmluZyh0KXtsZXQgZT10O2NvbnN0IG49bmV3IEw7ZG97bi5hZGQoZSksZT1lLmdldE5leHQoKSxnLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxnLmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShlIT09dCk7cmV0dXJuIG59c3RhdGljIGFkZEVkZ2UodCxlLG4pe2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspbi5hZGQodFtlXSwhMSk7ZWxzZSBmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSluLmFkZCh0W2VdLCExKX1zdGF0aWMgZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpe2NvbnN0IG49dC5nZXRSaW5nKCkscz1uLmdldEVudmVsb3BlSW50ZXJuYWwoKTtsZXQgaT1uLmdldENvb3JkaW5hdGVOKDApLHI9bnVsbCxvPW51bGw7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbD1lLmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYobC5lcXVhbHMocykpY29udGludWU7aWYoIWwuY29udGFpbnMocykpY29udGludWU7aT1fdC5wdE5vdEluTGlzdChuLmdldENvb3JkaW5hdGVzKCksZS5nZXRDb29yZGluYXRlcygpKTtlLmlzSW5SaW5nKGkpJiYobnVsbD09PXJ8fG8uY29udGFpbnMobCkpJiYocj1lLG89ci5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1yZXR1cm4gcn1pc0luY2x1ZGVkKCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWR9Z2V0Q29vcmRpbmF0ZXMoKXtpZihudWxsPT09dGhpcy5fcmluZ1B0cyl7Y29uc3QgdD1uZXcgUjtmb3IobGV0IGU9dGhpcy5fZGVMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRFZGdlKCk7cXIuYWRkRWRnZShzLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLG4uZ2V0RWRnZURpcmVjdGlvbigpLHQpfXRoaXMuX3JpbmdQdHM9dC50b0Nvb3JkaW5hdGVBcnJheSgpfXJldHVybiB0aGlzLl9yaW5nUHRzfWlzSW5jbHVkZWRTZXQoKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZFNldH1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSwhKHRoaXMuX3JpbmdQdHMubGVuZ3RoPD0zKSYmKHRoaXMuZ2V0UmluZygpLEdyLmlzVmFsaWQodGhpcy5fcmluZykpfWJ1aWxkKHQpe2xldCBlPXQ7ZG97dGhpcy5hZGQoZSksZS5zZXRSaW5nKHRoaXMpLGU9ZS5nZXROZXh0KCksZy5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZy5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUoZSE9PXQpfWlzSW5SaW5nKHQpe3JldHVybiBRdC5FWFRFUklPUiE9PXRoaXMuZ2V0TG9jYXRvcigpLmxvY2F0ZSh0KX1pc091dGVySG9sZSgpe3JldHVybiEhdGhpcy5faXNIb2xlJiYhdGhpcy5oYXNTaGVsbCgpfWdldFBvbHlnb24oKXtsZXQgdD1udWxsO2lmKG51bGwhPT10aGlzLl9ob2xlcyl7dD1uZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuX2hvbGVzLmdldChlKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHRoaXMuX3JpbmcsdCl9aXNIb2xlKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX1pc1Byb2Nlc3NlZCgpe3JldHVybiB0aGlzLl9pc1Byb2Nlc3NlZH1hZGRIb2xlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBndCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2hvbGVzJiYodGhpcy5faG9sZXM9bmV3IEwpLHRoaXMuX2hvbGVzLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcXIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3Quc2V0U2hlbGwodGhpcyk7Y29uc3QgZT10LmdldFJpbmcoKTtudWxsPT09dGhpcy5faG9sZXMmJih0aGlzLl9ob2xlcz1uZXcgTCksdGhpcy5faG9sZXMuYWRkKGUpfX1zZXRJbmNsdWRlZCh0KXt0aGlzLl9pc0luY2x1ZGVkPXQsdGhpcy5faXNJbmNsdWRlZFNldD0hMH1nZXRPdXRlckhvbGUoKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZGVMaXN0LnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fZGVMaXN0LmdldCh0KS5nZXRTeW0oKS5nZXRSaW5nKCk7aWYoZS5pc091dGVySG9sZSgpKXJldHVybiBlfXJldHVybiBudWxsfWNvbXB1dGVIb2xlKCl7Y29uc3QgdD10aGlzLmdldFJpbmcoKTt0aGlzLl9pc0hvbGU9cS5pc0NDVyh0LmdldENvb3JkaW5hdGVzKCkpfWhhc1NoZWxsKCl7cmV0dXJuIG51bGwhPT10aGlzLl9zaGVsbH1pc091dGVyU2hlbGwoKXtyZXR1cm4gbnVsbCE9PXRoaXMuZ2V0T3V0ZXJIb2xlKCl9Z2V0TGluZVN0cmluZygpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX3JpbmdQdHMpfXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyhuZXcgbXQodGhpcy5nZXRDb29yZGluYXRlcygpKSl9Z2V0TG9jYXRvcigpe3JldHVybiBudWxsPT09dGhpcy5fbG9jYXRvciYmKHRoaXMuX2xvY2F0b3I9bmV3IHplKHRoaXMuZ2V0UmluZygpKSksdGhpcy5fbG9jYXRvcn1nZXRTaGVsbCgpe3JldHVybiB0aGlzLmlzSG9sZSgpP3RoaXMuX3NoZWxsOnRoaXN9YWRkKHQpe3RoaXMuX2RlTGlzdC5hZGQodCl9Z2V0UmluZygpe2lmKG51bGwhPT10aGlzLl9yaW5nKXJldHVybiB0aGlzLl9yaW5nO3RoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLl9yaW5nUHRzLmxlbmd0aDwzJiZZLm91dC5wcmludGxuKHRoaXMuX3JpbmdQdHMpO3RyeXt0aGlzLl9yaW5nPXRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0aGlzLl9yaW5nUHRzKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBuKSl0aHJvdyB0O1kub3V0LnByaW50bG4odGhpcy5fcmluZ1B0cyl9cmV0dXJuIHRoaXMuX3Jpbmd9dXBkYXRlSW5jbHVkZWQoKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZGVMaXN0LnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fZGVMaXN0LmdldCh0KS5nZXRTeW0oKS5nZXRSaW5nKCkuZ2V0U2hlbGwoKTtpZihudWxsIT09ZSYmZS5pc0luY2x1ZGVkU2V0KCkpcmV0dXJuIHRoaXMuc2V0SW5jbHVkZWQoIWUuaXNJbmNsdWRlZCgpKSxudWxsfX1zZXRTaGVsbCh0KXt0aGlzLl9zaGVsbD10fXNldFByb2Nlc3NlZCh0KXt0aGlzLl9pc1Byb2Nlc3NlZD10fX1xci5FbnZlbG9wZUNvbXBhcmF0b3I9Y2xhc3N7Y29tcGFyZSh0LGUpe2NvbnN0IG49ZTtyZXR1cm4gdC5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKS5jb21wYXJlVG8obi5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX07Y2xhc3MgQnIgZXh0ZW5kcyAkaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH1zdGF0aWMgZmluZExhYmVsZWRFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgTDtsZXQgbj0xO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKHQuaXNNYXJrZWQoKSljb250aW51ZTtpZih0LmdldExhYmVsKCk+PTApY29udGludWU7ZS5hZGQodCk7Y29uc3QgaT1xci5maW5kRGlyRWRnZXNJblJpbmcodCk7QnIubGFiZWwoaSxuKSxuKyt9cmV0dXJuIGV9c3RhdGljIGdldERlZ3JlZU5vbkRlbGV0ZWQodCl7bGV0IGU9MDtmb3IobGV0IG49dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmlzTWFya2VkKCl8fGUrK31yZXR1cm4gZX1zdGF0aWMgZGVsZXRlQWxsRWRnZXModCl7Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0TWFya2VkKCEwKTtjb25zdCBuPXQuZ2V0U3ltKCk7bnVsbCE9PW4mJm4uc2V0TWFya2VkKCEwKX19c3RhdGljIGxhYmVsKHQsZSl7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLnNldExhYmVsKGUpfX1zdGF0aWMgY29tcHV0ZU5leHRDV0VkZ2VzKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZighdC5pc01hcmtlZCgpKXtpZihudWxsPT09ZSYmKGU9dCksbnVsbCE9PW4pe24uZ2V0U3ltKCkuc2V0TmV4dCh0KX1uPXR9fWlmKG51bGwhPT1uKXtuLmdldFN5bSgpLnNldE5leHQoZSl9fXN0YXRpYyBjb21wdXRlTmV4dENDV0VkZ2VzKHQsZSl7bGV0IG49bnVsbCxzPW51bGw7Y29uc3QgaT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKTtmb3IobGV0IHQ9aS5zaXplKCktMTt0Pj0wO3QtLSl7Y29uc3Qgcj1pLmdldCh0KSxvPXIuZ2V0U3ltKCk7bGV0IGw9bnVsbDtyLmdldExhYmVsKCk9PT1lJiYobD1yKTtsZXQgYT1udWxsO28uZ2V0TGFiZWwoKT09PWUmJihhPW8pLG51bGw9PT1sJiZudWxsPT09YXx8KG51bGwhPT1hJiYocz1hKSxudWxsIT09bCYmKG51bGwhPT1zJiYocy5zZXROZXh0KGwpLHM9bnVsbCksbnVsbD09PW4mJihuPWwpKSl9bnVsbCE9PXMmJihnLmlzVHJ1ZShudWxsIT09bikscy5zZXROZXh0KG4pKX1zdGF0aWMgZ2V0RGVncmVlKHQsZSl7bGV0IG49MDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3MubmV4dCgpLmdldExhYmVsKCk9PT1lJiZuKyt9cmV0dXJuIG59c3RhdGljIGZpbmRJbnRlcnNlY3Rpb25Ob2Rlcyh0LGUpe2xldCBuPXQscz1udWxsO2Rve2NvbnN0IGk9bi5nZXRGcm9tTm9kZSgpO0JyLmdldERlZ3JlZShpLGUpPjEmJihudWxsPT09cyYmKHM9bmV3IEwpLHMuYWRkKGkpKSxuPW4uZ2V0TmV4dCgpLGcuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGcuaXNUcnVlKG49PT10fHwhbi5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKG4hPT10KTtyZXR1cm4gc31maW5kRWRnZVJpbmcodCl7Y29uc3QgZT1uZXcgcXIodGhpcy5fZmFjdG9yeSk7cmV0dXJuIGUuYnVpbGQodCksZX1jb21wdXRlRGVwdGhQYXJpdHkoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IoOzspcmV0dXJuIG51bGx9Y29tcHV0ZU5leHRDV0VkZ2VzKCl7Zm9yKGxldCB0PXRoaXMubm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0JyLmNvbXB1dGVOZXh0Q1dFZGdlcyhlKX19YWRkRWRnZSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPV90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gbnVsbDtjb25zdCBuPWVbMF0scz1lW2UubGVuZ3RoLTFdLGk9dGhpcy5nZXROb2RlKG4pLHI9dGhpcy5nZXROb2RlKHMpLG89bmV3IFNyKGkscixlWzFdLCEwKSxsPW5ldyBTcihyLGksZVtlLmxlbmd0aC0yXSwhMSksYT1uZXcgTHIodCk7YS5zZXREaXJlY3RlZEVkZ2VzKG8sbCksdGhpcy5hZGQoYSl9ZGVsZXRlQ3V0RWRnZXMoKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLEJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuX2RpckVkZ2VzKTtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT10aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuLmlzTWFya2VkKCkpY29udGludWU7Y29uc3Qgcz1uLmdldFN5bSgpO2lmKG4uZ2V0TGFiZWwoKT09PXMuZ2V0TGFiZWwoKSl7bi5zZXRNYXJrZWQoITApLHMuc2V0TWFya2VkKCEwKTtjb25zdCBlPW4uZ2V0RWRnZSgpO3QuYWRkKGUuZ2V0TGluZSgpKX19cmV0dXJuIHR9Z2V0RWRnZVJpbmdzKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxCci5sYWJlbCh0aGlzLl9kaXJFZGdlcywtMSk7Y29uc3QgdD1Cci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLl9kaXJFZGdlcyk7dGhpcy5jb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5ncyh0KTtjb25zdCBlPW5ldyBMO2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKTtpZihuLmlzTWFya2VkKCkpY29udGludWU7aWYobi5pc0luUmluZygpKWNvbnRpbnVlO2NvbnN0IHM9dGhpcy5maW5kRWRnZVJpbmcobik7ZS5hZGQocyl9cmV0dXJuIGV9Z2V0Tm9kZSh0KXtsZXQgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IEtpKHQpLHRoaXMuYWRkKGUpKSxlfWNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRMYWJlbCgpLHM9QnIuZmluZEludGVyc2VjdGlvbk5vZGVzKHQsbik7aWYobnVsbCE9PXMpZm9yKGxldCB0PXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7QnIuY29tcHV0ZU5leHRDQ1dFZGdlcyhlLG4pfX19ZGVsZXRlRGFuZ2xlcygpe2NvbnN0IHQ9dGhpcy5maW5kTm9kZXNPZkRlZ3JlZSgxKSxlPW5ldyBFdCxuPW5ldyBlbjtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyluLnB1c2goZS5uZXh0KCkpO2Zvcig7IW4uaXNFbXB0eSgpOyl7Y29uc3QgdD1uLnBvcCgpO0JyLmRlbGV0ZUFsbEVkZ2VzKHQpO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LnNldE1hcmtlZCghMCk7Y29uc3QgaT10LmdldFN5bSgpO251bGwhPT1pJiZpLnNldE1hcmtlZCghMCk7Y29uc3Qgcj10LmdldEVkZ2UoKTtlLmFkZChyLmdldExpbmUoKSk7Y29uc3Qgbz10LmdldFRvTm9kZSgpOzE9PT1Cci5nZXREZWdyZWVOb25EZWxldGVkKG8pJiZuLnB1c2gobyl9fXJldHVybiBlfX1jbGFzcyBZcntjb25zdHJ1Y3Rvcigpe1lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NoZWxscz1udWxsLHRoaXMuX3NoZWxsSW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaGVsbHM9dCx0aGlzLmJ1aWxkSW5kZXgoKX1zdGF0aWMgYXNzaWduSG9sZXNUb1NoZWxscyh0LGUpe25ldyBZcihlKS5hc3NpZ25Ib2xlc1RvU2hlbGxzKHQpfWFzc2lnbkhvbGVzVG9TaGVsbHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5hc3NpZ25Ib2xlVG9TaGVsbCh0KX19YnVpbGRJbmRleCgpe3RoaXMuX3NoZWxsSW5kZXg9bmV3IGJzO2Zvcihjb25zdCB0IG9mIHRoaXMuX3NoZWxscyl0aGlzLl9zaGVsbEluZGV4Lmluc2VydCh0LmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCksdCl9cXVlcnlPdmVybGFwcGluZ1NoZWxscyh0KXtyZXR1cm4gdGhpcy5fc2hlbGxJbmRleC5xdWVyeSh0KX1maW5kU2hlbGxDb250YWluaW5nKHQpe2NvbnN0IGU9dC5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49dGhpcy5xdWVyeU92ZXJsYXBwaW5nU2hlbGxzKGUpO3JldHVybiBxci5maW5kRWRnZVJpbmdDb250YWluaW5nKHQsbil9YXNzaWduSG9sZVRvU2hlbGwodCl7Y29uc3QgZT10aGlzLmZpbmRTaGVsbENvbnRhaW5pbmcodCk7bnVsbCE9PWUmJmUuYWRkSG9sZSh0KX19Y2xhc3MgVnJ7Y29uc3RydWN0b3IoKXtWci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9saW5lU3RyaW5nQWRkZXI9bmV3IHpyKHRoaXMpLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZGFuZ2xlcz1uZXcgTCx0aGlzLl9jdXRFZGdlcz1uZXcgTCx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzPW5ldyBMLHRoaXMuX2hvbGVMaXN0PW51bGwsdGhpcy5fc2hlbGxMaXN0PW51bGwsdGhpcy5fcG9seUxpc3Q9bnVsbCx0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD0hMCx0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD1udWxsLHRoaXMuX2dlb21GYWN0b3J5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpVnIuY29uc3RydWN0b3JfLmNhbGwodGhpcywhMSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw9dH19c3RhdGljIGV4dHJhY3RQb2x5Z29ucyh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7KGV8fHQuaXNJbmNsdWRlZCgpKSYmbi5hZGQodC5nZXRQb2x5Z29uKCkpfXJldHVybiBufXN0YXRpYyBmaW5kT3V0ZXJTaGVsbHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldE91dGVySG9sZSgpO251bGw9PT1ufHxuLmlzUHJvY2Vzc2VkKCl8fCh0LnNldEluY2x1ZGVkKCEwKSxuLnNldFByb2Nlc3NlZCghMCkpfX1zdGF0aWMgZmluZERpc2pvaW50U2hlbGxzKHQpe1ZyLmZpbmRPdXRlclNoZWxscyh0KTtsZXQgZT1udWxsO2Rve2U9ITE7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dC5pc0luY2x1ZGVkU2V0KCl8fCh0LnVwZGF0ZUluY2x1ZGVkKCksdC5pc0luY2x1ZGVkU2V0KCl8fChlPSEwKSl9fXdoaWxlKGUpfWdldEdlb21ldHJ5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9nZW9tRmFjdG9yeSYmKHRoaXMuX2dlb21GYWN0b3J5PW5ldyBMdCksdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw/dGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLl9wb2x5TGlzdCk6dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEx0LnRvR2VvbWV0cnlBcnJheSh0aGlzLl9wb2x5TGlzdCkpfWdldEludmFsaWRSaW5nTGluZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5faW52YWxpZFJpbmdMaW5lc31maW5kVmFsaWRSaW5ncyh0LGUsbil7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc1ZhbGlkKCk/ZS5hZGQodCk6bi5hZGQodC5nZXRMaW5lU3RyaW5nKCkpfX1wb2x5Z29uaXplKCl7aWYobnVsbCE9PXRoaXMuX3BvbHlMaXN0KXJldHVybiBudWxsO2lmKHRoaXMuX3BvbHlMaXN0PW5ldyBMLG51bGw9PT10aGlzLl9ncmFwaClyZXR1cm4gbnVsbDt0aGlzLl9kYW5nbGVzPXRoaXMuX2dyYXBoLmRlbGV0ZURhbmdsZXMoKSx0aGlzLl9jdXRFZGdlcz10aGlzLl9ncmFwaC5kZWxldGVDdXRFZGdlcygpO2NvbnN0IHQ9dGhpcy5fZ3JhcGguZ2V0RWRnZVJpbmdzKCk7bGV0IGU9bmV3IEw7dGhpcy5faW52YWxpZFJpbmdMaW5lcz1uZXcgTCx0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD90aGlzLmZpbmRWYWxpZFJpbmdzKHQsZSx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzKTplPXQsdGhpcy5maW5kU2hlbGxzQW5kSG9sZXMoZSksWXIuYXNzaWduSG9sZXNUb1NoZWxscyh0aGlzLl9ob2xlTGlzdCx0aGlzLl9zaGVsbExpc3QpLHhlLnNvcnQodGhpcy5fc2hlbGxMaXN0LG5ldyBxci5FbnZlbG9wZUNvbXBhcmF0b3IpO2xldCBuPSEwO3RoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsJiYoVnIuZmluZERpc2pvaW50U2hlbGxzKHRoaXMuX3NoZWxsTGlzdCksbj0hMSksdGhpcy5fcG9seUxpc3Q9VnIuZXh0cmFjdFBvbHlnb25zKHRoaXMuX3NoZWxsTGlzdCxuKX1nZXREYW5nbGVzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2RhbmdsZXN9Z2V0Q3V0RWRnZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fY3V0RWRnZXN9Z2V0UG9seWdvbnMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fcG9seUxpc3R9YWRkKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGQoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiAkKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdG9yeT10LmdldEZhY3RvcnkoKSxudWxsPT09dGhpcy5fZ3JhcGgmJih0aGlzLl9ncmFwaD1uZXcgQnIodGhpcy5fZ2VvbUZhY3RvcnkpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXthcmd1bWVudHNbMF0uYXBwbHkodGhpcy5fbGluZVN0cmluZ0FkZGVyKX19c2V0Q2hlY2tSaW5nc1ZhbGlkKHQpe3RoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkPXR9ZmluZFNoZWxsc0FuZEhvbGVzKHQpe3RoaXMuX2hvbGVMaXN0PW5ldyBMLHRoaXMuX3NoZWxsTGlzdD1uZXcgTDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmNvbXB1dGVIb2xlKCksdC5pc0hvbGUoKT90aGlzLl9ob2xlTGlzdC5hZGQodCk6dGhpcy5fc2hlbGxMaXN0LmFkZCh0KX19fWNsYXNzIHpye2NvbnN0cnVjdG9yKCl7enIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wPXR9ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiAkJiZ0aGlzLnAuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX19VnIuTGluZVN0cmluZ0FkZGVyPXpyO3ZhciBYcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxQb2x5Z29uaXplcjpWcn0pO2NsYXNzIGtye2NvbnN0cnVjdG9yKCl7a3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX3B0TG9jYXRvcj1uZXcgZm4sdGhpcy5fYXJnPW51bGwsdGhpcy5fbm9kZXM9bmV3IG5zKG5ldyBiciksdGhpcy5faW09bnVsbCx0aGlzLl9pc29sYXRlZEVkZ2VzPW5ldyBMLHRoaXMuX2ludmFsaWRQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZz10fWluc2VydEVkZ2VFbmRzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuX25vZGVzLmFkZCh0KX19Y29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNKHQsZSl7Y29uc3Qgbj10aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxzPXRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLGk9dC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKSxyPXQuaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKTsyPT09biYmMj09PXM/aSYmZS5zZXRBdExlYXN0KFwiMjEyMTAxMjEyXCIpOjI9PT1uJiYxPT09cz8oaSYmZS5zZXRBdExlYXN0KFwiRkZGMEZGRkYyXCIpLHImJmUuc2V0QXRMZWFzdChcIjFGRkZGRjFGRlwiKSk6MT09PW4mJjI9PT1zPyhpJiZlLnNldEF0TGVhc3QoXCJGMEZGRkZGRjJcIiksciYmZS5zZXRBdExlYXN0KFwiMUYxRkZGRkZGXCIpKToxPT09biYmMT09PXMmJnImJmUuc2V0QXRMZWFzdChcIjBGRkZGRkZGRlwiKX1sYWJlbElzb2xhdGVkRWRnZXModCxlKXtmb3IobGV0IG49dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0LmlzSXNvbGF0ZWQoKSYmKHRoaXMubGFiZWxJc29sYXRlZEVkZ2UodCxlLHRoaXMuX2FyZ1tlXS5nZXRHZW9tZXRyeSgpKSx0aGlzLl9pc29sYXRlZEVkZ2VzLmFkZCh0KSl9fWxhYmVsSXNvbGF0ZWRFZGdlKHQsZSxuKXtpZihuLmdldERpbWVuc2lvbigpPjApe2NvbnN0IHM9dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSxuKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUscyl9ZWxzZSB0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsUXQuRVhURVJJT1IpfWNvbXB1dGVJTSgpe2NvbnN0IHQ9bmV3IEp0O2lmKHQuc2V0KFF0LkVYVEVSSU9SLFF0LkVYVEVSSU9SLDIpLCF0aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiB0aGlzLmNvbXB1dGVEaXNqb2ludElNKHQpLHQ7dGhpcy5fYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKTtjb25zdCBlPXRoaXMuX2FyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5fYXJnWzFdLHRoaXMuX2xpLCExKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygwKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlcygxKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscygxKSx0aGlzLmxhYmVsSXNvbGF0ZWROb2RlcygpLHRoaXMuY29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNKGUsdCk7Y29uc3Qgbj1uZXcgUnIscz1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLl9hcmdbMF0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMocyk7Y29uc3QgaT1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLl9hcmdbMV0uZ2V0RWRnZUl0ZXJhdG9yKCkpO3JldHVybiB0aGlzLmluc2VydEVkZ2VFbmRzKGkpLHRoaXMubGFiZWxOb2RlRWRnZXMoKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygwLDEpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDEsMCksdGhpcy51cGRhdGVJTSh0KSx0fWxhYmVsTm9kZUVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5fYXJnKX19Y29weU5vZGVzQW5kTGFiZWxzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuX25vZGVzLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19bGFiZWxJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLGk9dGhpcy5fbm9kZXMuZmluZChuLmNvb3JkKTtpLmdldExhYmVsKCkuaXNOdWxsKHQpJiYocz09PVF0LkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeSh0KTppLnNldExhYmVsKHQsUXQuSU5URVJJT1IpKX19fWxhYmVsSXNvbGF0ZWROb2RlKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2FyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsbil9Y29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2ZvcihsZXQgZT1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCksaT10aGlzLl9ub2Rlcy5hZGROb2RlKG4uY29vcmQpO3M9PT1RdC5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkodCk6aS5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmaS5zZXRMYWJlbCh0LFF0LklOVEVSSU9SKX19fWxhYmVsSXNvbGF0ZWROb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTtnLmlzVHJ1ZShuLmdldEdlb21ldHJ5Q291bnQoKT4wLFwibm9kZSB3aXRoIGVtcHR5IGxhYmVsIGZvdW5kXCIpLGUuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDApOnRoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwxKSl9fXVwZGF0ZUlNKHQpe2ZvcihsZXQgZT10aGlzLl9pc29sYXRlZEVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS51cGRhdGVJTSh0KX1mb3IobGV0IGU9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bi51cGRhdGVJTSh0KSxuLnVwZGF0ZUlNRnJvbUVkZ2VzKHQpfX1jb21wdXRlRGlzam9pbnRJTSh0KXtjb25zdCBlPXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpO2UuaXNFbXB0eSgpfHwodC5zZXQoUXQuSU5URVJJT1IsUXQuRVhURVJJT1IsZS5nZXREaW1lbnNpb24oKSksdC5zZXQoUXQuQk9VTkRBUlksUXQuRVhURVJJT1IsZS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSk7Y29uc3Qgbj10aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKTtuLmlzRW1wdHkoKXx8KHQuc2V0KFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SLG4uZ2V0RGltZW5zaW9uKCkpLHQuc2V0KFF0LkVYVEVSSU9SLFF0LkJPVU5EQVJZLG4uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpfX1jbGFzcyBVcntjb25zdHJ1Y3Rvcigpe1VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfXN0YXRpYyBjb250YWlucyh0LGUpe3JldHVybiBuZXcgVXIodCkuY29udGFpbnMoZSl9aXNDb250YWluZWRJbkJvdW5kYXJ5KHQpe2lmKHQgaW5zdGFuY2VvZiBydClyZXR1cm4hMTtpZih0IGluc3RhbmNlb2YgZXQpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodCBpbnN0YW5jZW9mICQpcmV0dXJuIHRoaXMuaXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkobikpcmV0dXJuITF9cmV0dXJuITB9aXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkodCxlKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0Lng9PT1lLngpe2lmKHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLl9yZWN0RW52LmdldE1heFgoKSlyZXR1cm4hMH1lbHNlIGlmKHQueT09PWUueSYmKHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1heFkoKSkpcmV0dXJuITA7cmV0dXJuITF9aXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj1uZXcgbSxzPW5ldyBtO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCktMTt0KyspaWYoZS5nZXRDb29yZGluYXRlKHQsbiksZS5nZXRDb29yZGluYXRlKHQrMSxzKSwhdGhpcy5pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeShuLHMpKXJldHVybiExO3JldHVybiEwfWlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBldCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodC5nZXRDb29yZGluYXRlKCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLl9yZWN0RW52LmdldE1heFgoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpfX1jb250YWlucyh0KXtyZXR1cm4hIXRoaXMuX3JlY3RFbnYuY29udGFpbnModC5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYhdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkodCl9fWNsYXNzIEhye2NvbnN0cnVjdG9yKCl7SHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9kaWFnVXAwPW51bGwsdGhpcy5fZGlhZ1VwMT1udWxsLHRoaXMuX2RpYWdEb3duMD1udWxsLHRoaXMuX2RpYWdEb3duMT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dCx0aGlzLl9kaWFnVXAwPW5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLl9kaWFnVXAxPW5ldyBtKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSx0aGlzLl9kaWFnRG93bjA9bmV3IG0odC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLHRoaXMuX2RpYWdEb3duMT1uZXcgbSh0LmdldE1heFgoKSx0LmdldE1pblkoKSl9aW50ZXJzZWN0cyh0LGUpe2NvbnN0IG49bmV3IE8odCxlKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKG4pKXJldHVybiExO2lmKHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyh0KSlyZXR1cm4hMDtpZih0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuITA7aWYodC5jb21wYXJlVG8oZSk+MCl7Y29uc3Qgbj10O3Q9ZSxlPW59bGV0IHM9ITE7cmV0dXJuIGUueT50LnkmJihzPSEwKSxzP3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2RpYWdEb3duMCx0aGlzLl9kaWFnRG93bjEpOnRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2RpYWdVcDAsdGhpcy5fZGlhZ1VwMSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKX19Y2xhc3MgV3J7Y29uc3RydWN0b3IoKXtXci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0YW5nbGU9bnVsbCx0aGlzLl9yZWN0RW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdGFuZ2xlPXQsdGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUpe3JldHVybiBuZXcgV3IodCkuaW50ZXJzZWN0cyhlKX1pbnRlcnNlY3RzKHQpe2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiExO2NvbnN0IGU9bmV3IFpyKHRoaXMuX3JlY3RFbnYpO2lmKGUuYXBwbHlUbyh0KSxlLmludGVyc2VjdHMoKSlyZXR1cm4hMDtjb25zdCBuPW5ldyBqcih0aGlzLl9yZWN0YW5nbGUpO2lmKG4uYXBwbHlUbyh0KSxuLmNvbnRhaW5zUG9pbnQoKSlyZXR1cm4hMDtjb25zdCBzPW5ldyBLcih0aGlzLl9yZWN0YW5nbGUpO3JldHVybiBzLmFwcGx5VG8odCksISFzLmludGVyc2VjdHMoKX19Y2xhc3MgWnIgZXh0ZW5kcyBOZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksWnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2ludGVyc2VjdHM9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10fWlzRG9uZSgpe3JldHVybiEwPT09dGhpcy5faW50ZXJzZWN0c312aXNpdCh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiB0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSk/dGhpcy5fcmVjdEVudi5jb250YWlucyhlKXx8ZS5nZXRNaW5YKCk+PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpJiZlLmdldE1heFgoKTw9dGhpcy5fcmVjdEVudi5nZXRNYXhYKCl8fGUuZ2V0TWluWSgpPj10aGlzLl9yZWN0RW52LmdldE1pblkoKSYmZS5nZXRNYXhZKCk8PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOnZvaWQgMDpudWxsfWludGVyc2VjdHMoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0c319Y2xhc3MganIgZXh0ZW5kcyBOZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksanIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdFNlcT1udWxsLHRoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9jb250YWluc1BvaW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RTZXE9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWlzRG9uZSgpe3JldHVybiEwPT09dGhpcy5fY29udGFpbnNQb2ludH12aXNpdCh0KXtpZighKHQgaW5zdGFuY2VvZiBydCkpcmV0dXJuIG51bGw7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO2NvbnN0IG49bmV3IG07Zm9yKGxldCBzPTA7czw0O3MrKylpZih0aGlzLl9yZWN0U2VxLmdldENvb3JkaW5hdGUocyxuKSxlLmNvbnRhaW5zKG4pJiZaZS5jb250YWluc1BvaW50SW5Qb2x5Z29uKG4sdCkpcmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITAsbnVsbH1jb250YWluc1BvaW50KCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnR9fWNsYXNzIEtyIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLEtyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9yZWN0SW50ZXJzZWN0b3I9bnVsbCx0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5fcDA9bmV3IG0sdGhpcy5fcDE9bmV3IG07Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSx0aGlzLl9yZWN0SW50ZXJzZWN0b3I9bmV3IEhyKHRoaXMuX3JlY3RFbnYpfWludGVyc2VjdHMoKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiEwPT09dGhpcy5faGFzSW50ZXJzZWN0aW9ufXZpc2l0KHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtjb25zdCBuPXllLmdldExpbmVzKHQpO3RoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3Mobil9Y2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3ModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyh0KSx0aGlzLl9oYXNJbnRlcnNlY3Rpb24pcmV0dXJuIG51bGx9fWNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MTt0PGUuc2l6ZSgpO3QrKylpZihlLmdldENvb3JkaW5hdGUodC0xLHRoaXMuX3AwKSxlLmdldENvb3JkaW5hdGUodCx0aGlzLl9wMSksdGhpcy5fcmVjdEludGVyc2VjdG9yLmludGVyc2VjdHModGhpcy5fcDAsdGhpcy5fcDEpKXJldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsbnVsbH19Y2xhc3MgUXIgZXh0ZW5kcyBOcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcmVsYXRlPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO05yLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9yZWxhdGU9bmV3IGtyKHRoaXMuX2FyZyl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07TnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbiksdGhpcy5fcmVsYXRlPW5ldyBrcih0aGlzLl9hcmcpfX1zdGF0aWMgY292ZXJzKHQsZSl7cmV0dXJuISgyPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwyKSYmKCEoMT09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MSYmZS5nZXRMZW5ndGgoKT4wKSYmKCEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY292ZXJzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKCEhdC5pc1JlY3RhbmdsZSgpfHxuZXcgUXIodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0NvdmVycygpKSkpfXN0YXRpYyBpbnRlcnNlY3RzKHQsZSl7aWYoIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiExO2lmKHQuaXNSZWN0YW5nbGUoKSlyZXR1cm4gV3IuaW50ZXJzZWN0cyh0LGUpO2lmKGUuaXNSZWN0YW5nbGUoKSlyZXR1cm4gV3IuaW50ZXJzZWN0cyhlLHQpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKylmb3IobGV0IHM9MDtzPGUuZ2V0TnVtR2VvbWV0cmllcygpO3MrKylpZih0LmdldEdlb21ldHJ5TihuKS5pbnRlcnNlY3RzKGUuZ2V0R2VvbWV0cnlOKHMpKSlyZXR1cm4hMDtyZXR1cm4hMX1yZXR1cm4gbmV3IFFyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNJbnRlcnNlY3RzKCl9c3RhdGljIHRvdWNoZXModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgUXIodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc1RvdWNoZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgZXF1YWxzVG9wbyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuZXF1YWxzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmUXIucmVsYXRlKHQsZSkuaXNFcXVhbHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgcmVsYXRlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgUXIoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgUXIoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pLmdldEludGVyc2VjdGlvbk1hdHJpeCgpfX1zdGF0aWMgb3ZlcmxhcHModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgUXIodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc092ZXJsYXBzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGNyb3NzZXModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgUXIodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0Nyb3NzZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgY29udGFpbnModCxlKXtyZXR1cm4hKDI9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDIpJiYoISgxPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwxJiZlLmdldExlbmd0aCgpPjApJiYoISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJih0LmlzUmVjdGFuZ2xlKCk/VXIuY29udGFpbnModCxlKTpuZXcgUXIodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0NvbnRhaW5zKCkpKSl9Z2V0SW50ZXJzZWN0aW9uTWF0cml4KCl7cmV0dXJuIHRoaXMuX3JlbGF0ZS5jb21wdXRlSU0oKX19dmFyIEpyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFJlbGF0ZU9wOlFyfSk7Y2xhc3MgJHJ7Y29uc3RydWN0b3IoKXskci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wb2ludEdlb209bnVsbCx0aGlzLl9vdGhlckdlb209bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3BvaW50R2VvbT10LHRoaXMuX290aGVyR2VvbT1lLHRoaXMuX2dlb21GYWN0PWUuZ2V0RmFjdG9yeSgpfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBuZXcgJHIodCxlKS51bmlvbigpfXVuaW9uKCl7Y29uc3QgdD1uZXcgZm4sZT1uZXcgYXQ7Zm9yKGxldCBuPTA7bjx0aGlzLl9wb2ludEdlb20uZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10aGlzLl9wb2ludEdlb20uZ2V0R2VvbWV0cnlOKG4pLmdldENvb3JkaW5hdGUoKTt0LmxvY2F0ZShzLHRoaXMuX290aGVyR2VvbSk9PT1RdC5FWFRFUklPUiYmZS5hZGQocyl9aWYoMD09PWUuc2l6ZSgpKXJldHVybiB0aGlzLl9vdGhlckdlb207bGV0IG49bnVsbDtjb25zdCBzPV90LnRvQ29vcmRpbmF0ZUFycmF5KGUpO3JldHVybiBuPTE9PT1zLmxlbmd0aD90aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludChzWzBdKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhzKSxoZS5jb21iaW5lKG4sdGhpcy5fb3RoZXJHZW9tKX19Y2xhc3MgdG97Y29uc3RydWN0b3IoKXt0by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX3BvbHlnb25zPW5ldyBMLHRoaXMuX2xpbmVzPW5ldyBMLHRoaXMuX3BvaW50cz1uZXcgTCx0aGlzLl9kaW1lbnNpb249US5GQUxTRX1zdGF0aWMgZXh0cmFjdCgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB0bztyZXR1cm4gZS5hZGQodCksZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHRvO3JldHVybiBlLmFkZCh0KSxlfX1nZXRGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5fXJlY29yZERpbWVuc2lvbih0KXt0PnRoaXMuX2RpbWVuc2lvbiYmKHRoaXMuX2RpbWVuc2lvbj10KX1nZXREaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5fZGltZW5zaW9ufWZpbHRlcih0KXtyZXR1cm4gdGhpcy5yZWNvcmREaW1lbnNpb24odC5nZXREaW1lbnNpb24oKSksdCBpbnN0YW5jZW9mIGh0fHx0LmlzRW1wdHkoKT9udWxsOnQgaW5zdGFuY2VvZiBydD8odGhpcy5fcG9seWdvbnMuYWRkKHQpLG51bGwpOnQgaW5zdGFuY2VvZiAkPyh0aGlzLl9saW5lcy5hZGQodCksbnVsbCk6dCBpbnN0YW5jZW9mIGV0Pyh0aGlzLl9wb2ludHMuYWRkKHQpLG51bGwpOnZvaWQgZy5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuaGFuZGxlZCBnZW9tZXRyeSB0eXBlOiBcIit0LmdldEdlb21ldHJ5VHlwZSgpKX1nZXRFeHRyYWN0KHQpe3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIHRoaXMuX3BvaW50cztjYXNlIDE6cmV0dXJuIHRoaXMuX2xpbmVzO2Nhc2UgMjpyZXR1cm4gdGhpcy5fcG9seWdvbnN9cmV0dXJuIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJJbnZhbGlkIGRpbWVuc2lvbjogXCIrdCksbnVsbH1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX3BvbHlnb25zLmlzRW1wdHkoKSYmdGhpcy5fbGluZXMuaXNFbXB0eSgpJiZ0aGlzLl9wb2ludHMuaXNFbXB0eSgpfWFkZCgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IoY29uc3QgZSBvZiB0KXRoaXMuYWRkKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5fZ2VvbUZhY3RvcnkmJih0aGlzLl9nZW9tRmFjdG9yeT10LmdldEZhY3RvcnkoKSksdC5hcHBseSh0aGlzKX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pdfX1jbGFzcyBlb3tzdGF0aWMgdW5pb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gd3IuY3JlYXRlRW1wdHlSZXN1bHQod3IuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiBVLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLFUuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksSXIub3ZlcmxheU9wKHQsZSx3ci5VTklPTil9fWNsYXNzIG5ve2NvbnN0cnVjdG9yKCl7bm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9nMD1udWxsLHRoaXMuX2cxPW51bGwsdGhpcy5faXNVbmlvblNhZmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nMD10LHRoaXMuX2cxPWUsdGhpcy5fZ2VvbUZhY3Rvcnk9dC5nZXRGYWN0b3J5KCl9c3RhdGljIGNvbnRhaW5zUHJvcGVybHkoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXQuaXNOdWxsKCkmJihlLmdldFgoKT50LmdldE1pblgoKSYmZS5nZXRYKCk8dC5nZXRNYXhYKCkmJmUuZ2V0WSgpPnQuZ2V0TWluWSgpJiZlLmdldFkoKTx0LmdldE1heFkoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuby5jb250YWluc1Byb3Blcmx5KHQsZSkmJm5vLmNvbnRhaW5zUHJvcGVybHkodCxuKX19c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIG5ldyBubyh0LGUpLnVuaW9uKCl9c3RhdGljIGludGVyc2VjdHModCxlLG4pe3JldHVybiB0LmludGVyc2VjdHMoZSl8fHQuaW50ZXJzZWN0cyhuKX1zdGF0aWMgb3ZlcmxhcEVudmVsb3BlKHQsZSl7Y29uc3Qgbj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxzPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiBuLmludGVyc2VjdGlvbihzKX1zdGF0aWMgZXh0cmFjdEJvcmRlclNlZ21lbnRzKHQsZSxuKXt0LmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUF19ZmlsdGVyKHQscyl7aWYoczw9MClyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZShzLTEpLHI9dC5nZXRDb29yZGluYXRlKHMpO2lmKG5vLmludGVyc2VjdHMoZSxpLHIpJiYhbm8uY29udGFpbnNQcm9wZXJseShlLGkscikpe2NvbnN0IHQ9bmV3IEt0KGkscik7bi5hZGQodCl9fWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITF9fSl9c3RhdGljIHVuaW9uQnVmZmVyKHQsZSl7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbdCxlXSkuYnVmZmVyKDApfWlzQm9yZGVyU2VnbWVudHNTYW1lKHQsZSl7Y29uc3Qgbj10aGlzLmV4dHJhY3RCb3JkZXJTZWdtZW50cyh0aGlzLl9nMCx0aGlzLl9nMSxlKSxzPW5ldyBMO3JldHVybiBuby5leHRyYWN0Qm9yZGVyU2VnbWVudHModCxlLHMpLHRoaXMuaXNFcXVhbChuLHMpfWV4dHJhY3RCeUVudmVsb3BlKHQsZSxuKXtjb25zdCBzPW5ldyBMO2ZvcihsZXQgaT0wO2k8ZS5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtjb25zdCByPWUuZ2V0R2VvbWV0cnlOKGkpO2lmKHIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCkpcy5hZGQocik7ZWxzZXtjb25zdCB0PXIuY29weSgpO24uYWRkKHQpfX1yZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShzKX1pc0VxdWFsKHQsZSl7aWYodC5zaXplKCkhPT1lLnNpemUoKSlyZXR1cm4hMTtjb25zdCBuPW5ldyBFdCh0KTtmb3IoY29uc3QgdCBvZiBlKWlmKCFuLmNvbnRhaW5zKHQpKXJldHVybiExO3JldHVybiEwfXVuaW9uKCl7Y29uc3QgdD1uby5vdmVybGFwRW52ZWxvcGUodGhpcy5fZzAsdGhpcy5fZzEpO2lmKHQuaXNOdWxsKCkpe2NvbnN0IHQ9dGhpcy5fZzAuY29weSgpLGU9dGhpcy5fZzEuY29weSgpO3JldHVybiBoZS5jb21iaW5lKHQsZSl9Y29uc3QgZT1uZXcgTCxuPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUodCx0aGlzLl9nMCxlKSxzPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUodCx0aGlzLl9nMSxlKSxpPXRoaXMudW5pb25GdWxsKG4scyk7bGV0IHI9bnVsbDtyZXR1cm4gdGhpcy5faXNVbmlvblNhZmU9dGhpcy5pc0JvcmRlclNlZ21lbnRzU2FtZShpLHQpLHI9dGhpcy5faXNVbmlvblNhZmU/dGhpcy5jb21iaW5lKGksZSk6dGhpcy51bmlvbkZ1bGwodGhpcy5fZzAsdGhpcy5fZzEpLHJ9Y29tYmluZSh0LGUpe2lmKGUuc2l6ZSgpPD0wKXJldHVybiB0O2UuYWRkKHQpO3JldHVybiBoZS5jb21iaW5lKGUpfXVuaW9uRnVsbCh0LGUpe3RyeXtyZXR1cm4gZW8udW5pb24odCxlKX1jYXRjaChuKXtpZihuIGluc3RhbmNlb2YgaXMpcmV0dXJuIG5vLnVuaW9uQnVmZmVyKHQsZSk7dGhyb3cgbn19ZXh0cmFjdEJvcmRlclNlZ21lbnRzKHQsZSxuKXtjb25zdCBzPW5ldyBMO3JldHVybiBuby5leHRyYWN0Qm9yZGVyU2VnbWVudHModCxuLHMpLG51bGwhPT1lJiZuby5leHRyYWN0Qm9yZGVyU2VnbWVudHMoZSxuLHMpLHN9aXNVbmlvbk9wdGltaXplZCgpe3JldHVybiB0aGlzLl9pc1VuaW9uU2FmZX19Y2xhc3Mgc297Y29uc3RydWN0b3IoKXtzby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dFBvbHlzPW51bGwsdGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dFBvbHlzPXQsbnVsbD09PXRoaXMuX2lucHV0UG9seXMmJih0aGlzLl9pbnB1dFBvbHlzPW5ldyBMKX1zdGF0aWMgcmVzdHJpY3RUb1BvbHlnb25zKHQpe2lmKEkodCxpdCkpcmV0dXJuIHQ7Y29uc3QgZT1JZS5nZXRQb2x5Z29ucyh0KTtyZXR1cm4gMT09PWUuc2l6ZSgpP2UuZ2V0KDApOnQuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihMdC50b1BvbHlnb25BcnJheShlKSl9c3RhdGljIGdldEdlb21ldHJ5KHQsZSl7cmV0dXJuIGU+PXQuc2l6ZSgpP251bGw6dC5nZXQoZSl9c3RhdGljIHVuaW9uKHQpe3JldHVybiBuZXcgc28odCkudW5pb24oKX1yZWR1Y2VUb0dlb21ldHJpZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtsZXQgcz1udWxsO0kodCxDKT9zPXRoaXMudW5pb25UcmVlKHQpOnQgaW5zdGFuY2VvZiBVJiYocz10KSxlLmFkZChzKX1yZXR1cm4gZX11bmlvbigpe2lmKG51bGw9PT10aGlzLl9pbnB1dFBvbHlzKXRocm93IG5ldyBEKFwidW5pb24oKSBtZXRob2QgY2Fubm90IGJlIGNhbGxlZCB0d2ljZVwiKTtpZih0aGlzLl9pbnB1dFBvbHlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLl9nZW9tRmFjdG9yeT10aGlzLl9pbnB1dFBvbHlzLml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKTtjb25zdCB0PW5ldyBicyhzby5TVFJUUkVFX05PREVfQ0FQQUNJVFkpO2ZvcihsZXQgZT10aGlzLl9pbnB1dFBvbHlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QuaW5zZXJ0KG4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG4pfXRoaXMuX2lucHV0UG9seXM9bnVsbDtjb25zdCBlPXQuaXRlbXNUcmVlKCk7cmV0dXJuIHRoaXMudW5pb25UcmVlKGUpfWJpbmFyeVVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKHQsMCx0LnNpemUoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKG4tZTw9MSl7Y29uc3Qgbj1zby5nZXRHZW9tZXRyeSh0LGUpO3JldHVybiB0aGlzLnVuaW9uU2FmZShuLG51bGwpfWlmKG4tZT09MilyZXR1cm4gdGhpcy51bmlvblNhZmUoc28uZ2V0R2VvbWV0cnkodCxlKSxzby5nZXRHZW9tZXRyeSh0LGUrMSkpO3tjb25zdCBzPU1hdGgudHJ1bmMoKG4rZSkvMiksaT10aGlzLmJpbmFyeVVuaW9uKHQsZSxzKSxyPXRoaXMuYmluYXJ5VW5pb24odCxzLG4pO3JldHVybiB0aGlzLnVuaW9uU2FmZShpLHIpfX19cmVwZWF0ZWRVbmlvbih0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2U9bnVsbD09PWU/dC5jb3B5KCk6ZS51bmlvbih0KX1yZXR1cm4gZX11bmlvblNhZmUodCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PXQ/ZS5jb3B5KCk6bnVsbD09PWU/dC5jb3B5KCk6dGhpcy51bmlvbkFjdHVhbCh0LGUpfXVuaW9uQWN0dWFsKHQsZSl7Y29uc3Qgbj1uby51bmlvbih0LGUpO3JldHVybiBzby5yZXN0cmljdFRvUG9seWdvbnMobil9dW5pb25UcmVlKHQpe2NvbnN0IGU9dGhpcy5yZWR1Y2VUb0dlb21ldHJpZXModCk7cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24oZSl9YnVmZmVyVW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuZ2V0KDApLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHQpLmJ1ZmZlcigwKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbdCxlXSkuYnVmZmVyKDApfX19c28uU1RSVFJFRV9OT0RFX0NBUEFDSVRZPTQ7Y2xhc3MgaW97Y29uc3RydWN0b3IoKXtpby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2V4dHJhY3Rlcj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21GYWN0PWUsdGhpcy5leHRyYWN0KHQpfX1zdGF0aWMgdW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sTikpe3JldHVybiBuZXcgaW8oYXJndW1lbnRzWzBdKS51bmlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7cmV0dXJuIG5ldyBpbyhhcmd1bWVudHNbMF0pLnVuaW9uKCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgaW8oYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkudW5pb24oKX19dW5pb25Ob09wdCh0KXtjb25zdCBlPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KCk7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuVU5JT04pfXVuaW9uV2l0aE51bGwodCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PWU/dDpudWxsPT09dD9lOndyLnVuaW9uKHQsZSl9ZXh0cmFjdCgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9leHRyYWN0ZXI9dG8uZXh0cmFjdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZXh0cmFjdGVyPXRvLmV4dHJhY3QodCl9fXVuaW9uKCl7aWYobnVsbD09PXRoaXMuX2dlb21GYWN0JiYodGhpcy5fZ2VvbUZhY3Q9dGhpcy5fZXh0cmFjdGVyLmdldEZhY3RvcnkoKSksbnVsbD09PXRoaXMuX2dlb21GYWN0KXJldHVybiBudWxsO2lmKHRoaXMuX2V4dHJhY3Rlci5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZUVtcHR5KHRoaXMuX2V4dHJhY3Rlci5nZXREaW1lbnNpb24oKSk7Y29uc3QgdD10aGlzLl9leHRyYWN0ZXIuZ2V0RXh0cmFjdCgwKSxlPXRoaXMuX2V4dHJhY3Rlci5nZXRFeHRyYWN0KDEpLG49dGhpcy5fZXh0cmFjdGVyLmdldEV4dHJhY3QoMik7bGV0IHM9bnVsbDtpZih0LnNpemUoKT4wKXtjb25zdCBlPXRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkodCk7cz10aGlzLnVuaW9uTm9PcHQoZSl9bGV0IGk9bnVsbDtpZihlLnNpemUoKT4wKXtjb25zdCB0PXRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkoZSk7aT10aGlzLnVuaW9uTm9PcHQodCl9bGV0IHI9bnVsbDtuLnNpemUoKT4wJiYocj1zby51bmlvbihuKSk7Y29uc3Qgbz10aGlzLnVuaW9uV2l0aE51bGwoaSxyKTtsZXQgbD1udWxsO3JldHVybiBsPW51bGw9PT1zP286bnVsbD09PW8/czokci51bmlvbihzLG8pLG51bGw9PT1sP3RoaXMuX2dlb21GYWN0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpOmx9fXZhciBybz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxVbmFyeVVuaW9uT3A6aW99KSxvbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxJc1ZhbGlkT3A6R3IsQ29uc2lzdGVudEFyZWFUZXN0ZXI6RHJ9KSxsbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxCb3VuZGFyeU9wOmlpLElzU2ltcGxlT3A6b2ksYnVmZmVyOkJpLGRpc3RhbmNlOlhpLGxpbmVtZXJnZTpycixvdmVybGF5OkNyLHBvbHlnb25pemU6WHIscmVsYXRlOkpyLHVuaW9uOnJvLHZhbGlkOm9vfSk7Y2xhc3MgYW97Y29uc3RydWN0b3IoKXthby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9yZXR1cm5Ub09yaWdpbmFsUHJlY2lzaW9uPSEwLHRoaXMuX2Nicj1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWFvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsITApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JldHVyblRvT3JpZ2luYWxQcmVjaXNpb249dH19Y29tcHV0ZVJlc3VsdFByZWNpc2lvbih0KXtyZXR1cm4gdGhpcy5fcmV0dXJuVG9PcmlnaW5hbFByZWNpc2lvbiYmdGhpcy5fY2JyLmFkZENvbW1vbkJpdHModCksdH11bmlvbih0LGUpe2NvbnN0IG49dGhpcy5yZW1vdmVDb21tb25CaXRzKHQsZSk7cmV0dXJuIHRoaXMuY29tcHV0ZVJlc3VsdFByZWNpc2lvbihuWzBdLnVuaW9uKG5bMV0pKX1pbnRlcnNlY3Rpb24odCxlKXtjb25zdCBuPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0LGUpO3JldHVybiB0aGlzLmNvbXB1dGVSZXN1bHRQcmVjaXNpb24oblswXS5pbnRlcnNlY3Rpb24oblsxXSkpfXJlbW92ZUNvbW1vbkJpdHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY2JyPW5ldyBmcix0aGlzLl9jYnIuYWRkKHQpO3JldHVybiB0aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0LmNvcHkoKSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Nicj1uZXcgZnIsdGhpcy5fY2JyLmFkZCh0KSx0aGlzLl9jYnIuYWRkKGUpO2NvbnN0IG49bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIG5bMF09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModC5jb3B5KCkpLG5bMV09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHMoZS5jb3B5KCkpLG59fWJ1ZmZlcih0LGUpe2NvbnN0IG49dGhpcy5yZW1vdmVDb21tb25CaXRzKHQpO3JldHVybiB0aGlzLmNvbXB1dGVSZXN1bHRQcmVjaXNpb24obi5idWZmZXIoZSkpfXN5bURpZmZlcmVuY2UodCxlKXtjb25zdCBuPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0LGUpO3JldHVybiB0aGlzLmNvbXB1dGVSZXN1bHRQcmVjaXNpb24oblswXS5zeW1EaWZmZXJlbmNlKG5bMV0pKX1kaWZmZXJlbmNlKHQsZSl7Y29uc3Qgbj10aGlzLnJlbW92ZUNvbW1vbkJpdHModCxlKTtyZXR1cm4gdGhpcy5jb21wdXRlUmVzdWx0UHJlY2lzaW9uKG5bMF0uZGlmZmVyZW5jZShuWzFdKSl9fWNsYXNzIGNvIGV4dGVuZHMgdWUuQ29vcmRpbmF0ZU9wZXJhdGlvbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksY28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdGFyZ2V0UE09bnVsbCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdGFyZ2V0UE09dCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ZX1lZGl0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBzPW5ldyBtKHRbZV0pO3RoaXMuX3RhcmdldFBNLm1ha2VQcmVjaXNlKHMpLG5bZV09c31jb25zdCBzPW5ldyBSKG4sITEpLnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IGk9MDtlIGluc3RhbmNlb2YgJCYmKGk9MiksZSBpbnN0YW5jZW9mIGd0JiYoaT00KTtsZXQgcj1uO3JldHVybiB0aGlzLl9yZW1vdmVDb2xsYXBzZWQmJihyPW51bGwpLHMubGVuZ3RoPGk/cjpzfXJldHVybiBzdXBlci5lZGl0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19Y2xhc3MgaG97Y29uc3RydWN0b3IoKXtoby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90YXJnZXRQTT1udWxsLHRoaXMuX3JlbW92ZUNvbGxhcHNlZD0hMCx0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD0hMSx0aGlzLl9pc1BvaW50d2lzZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl90YXJnZXRQTT10fXN0YXRpYyByZWR1Y2UodCxlKXtyZXR1cm4gbmV3IGhvKGUpLnJlZHVjZSh0KX1zdGF0aWMgcmVkdWNlUG9pbnR3aXNlKHQsZSl7Y29uc3Qgbj1uZXcgaG8oZSk7cmV0dXJuIG4uc2V0UG9pbnR3aXNlKCEwKSxuLnJlZHVjZSh0KX1maXhQb2x5Z29uYWxUb3BvbG9neSh0KXtsZXQgZT10O3RoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsfHwoZT10aGlzLmNoYW5nZVBNKHQsdGhpcy5fdGFyZ2V0UE0pKTtyZXR1cm4gcWkuYnVmZmVyT3AoZSwwKX1yZWR1Y2VQb2ludHdpc2UodCl7bGV0IGU9bnVsbDtpZih0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbCl7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodC5nZXRGYWN0b3J5KCksdGhpcy5fdGFyZ2V0UE0pO2U9bmV3IHVlKG4pfWVsc2UgZT1uZXcgdWU7bGV0IG49dGhpcy5fcmVtb3ZlQ29sbGFwc2VkO3QuZ2V0RGltZW5zaW9uKCk+PTImJihuPSEwKTtyZXR1cm4gZS5lZGl0KHQsbmV3IGNvKHRoaXMuX3RhcmdldFBNLG4pKX1jaGFuZ2VQTSh0LGUpe3JldHVybiB0aGlzLmNyZWF0ZUVkaXRvcih0LmdldEZhY3RvcnkoKSxlKS5lZGl0KHQsbmV3IHVlLk5vT3BHZW9tZXRyeU9wZXJhdGlvbil9c2V0UmVtb3ZlQ29sbGFwc2VkQ29tcG9uZW50cyh0KXt0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9dH1jcmVhdGVGYWN0b3J5KHQsZSl7cmV0dXJuIG5ldyBMdChlLHQuZ2V0U1JJRCgpLHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1zZXRDaGFuZ2VQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD10fXJlZHVjZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlUG9pbnR3aXNlKHQpO3JldHVybiB0aGlzLl9pc1BvaW50d2lzZT9lOkkoZSxpdCk/R3IuaXNWYWxpZChlKT9lOnRoaXMuZml4UG9seWdvbmFsVG9wb2xvZ3koZSk6ZX1zZXRQb2ludHdpc2UodCl7dGhpcy5faXNQb2ludHdpc2U9dH1jcmVhdGVFZGl0b3IodCxlKXtpZih0LmdldFByZWNpc2lvbk1vZGVsKCk9PT1lKXJldHVybiBuZXcgdWU7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodCxlKTtyZXR1cm4gbmV3IHVlKG4pfX1jbGFzcyB1b3tjb25zdHJ1Y3Rvcigpe3VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb209bnVsbCx0aGlzLl9wdHM9bnVsbCx0aGlzLl9zdGFydD1udWxsLHRoaXMuX2VuZD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl9zdGFydD1lLHRoaXMuX2VuZD1lKzF9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHRzPXQsdGhpcy5fc3RhcnQ9ZSx0aGlzLl9lbmQ9bn1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9nZW9tPXQsdGhpcy5fcHRzPWUsdGhpcy5fc3RhcnQ9bix0aGlzLl9lbmQ9c319Y29tcHV0ZURpc3RhbmNlTGluZUxpbmUodCxlKXtsZXQgbj1yLk1BWF9WQUxVRTtmb3IobGV0IHM9dGhpcy5fc3RhcnQ7czx0aGlzLl9lbmQtMTtzKyspe2NvbnN0IGk9dGhpcy5fcHRzLmdldENvb3JkaW5hdGUocykscj10aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZShzKzEpO2ZvcihsZXQgbz10Ll9zdGFydDtvPHQuX2VuZC0xO28rKyl7Y29uc3QgbD10Ll9wdHMuZ2V0Q29vcmRpbmF0ZShvKSxhPXQuX3B0cy5nZXRDb29yZGluYXRlKG8rMSksYz16LnNlZ21lbnRUb1NlZ21lbnQoaSxyLGwsYSk7aWYoYzxuJiYobj1jLG51bGwhPT1lJiZ0aGlzLnVwZGF0ZU5lYXJlc3RMb2NhdGlvbnNMaW5lTGluZShzLGkscix0LG8sbCxhLGUpLG48PTApKXJldHVybiBufX1yZXR1cm4gbn11cGRhdGVOZWFyZXN0TG9jYXRpb25zUG9pbnRMaW5lKHQsZSxuLHMsaSxyKXtyWzBdPW5ldyBZaSh0aGlzLl9nZW9tLHRoaXMuX3N0YXJ0LG5ldyBtKHQpKTtjb25zdCBvPW5ldyBLdChzLGkpLmNsb3Nlc3RQb2ludCh0KTtyWzFdPW5ldyBZaShlLl9nZW9tLG4sbmV3IG0obykpfXNpemUoKXtyZXR1cm4gdGhpcy5fZW5kLXRoaXMuX3N0YXJ0fWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0cy5nZXRDb29yZGluYXRlKHRoaXMuX3N0YXJ0K3QpfW5lYXJlc3RMb2NhdGlvbnModCl7Y29uc3QgZT10aGlzLmlzUG9pbnQoKSxuPXQuaXNQb2ludCgpLHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYoZSYmbil7Y29uc3QgZT10aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9zdGFydCksbj10Ll9wdHMuZ2V0Q29vcmRpbmF0ZSh0Ll9zdGFydCk7c1swXT1uZXcgWWkodGhpcy5fZ2VvbSx0aGlzLl9zdGFydCxuZXcgbShlKSksc1sxXT1uZXcgWWkodC5fZ2VvbSx0Ll9zdGFydCxuZXcgbShuKSl9ZWxzZSBpZihlKXtjb25zdCBlPXRoaXMuX3B0cy5nZXRDb29yZGluYXRlKHRoaXMuX3N0YXJ0KTt0aGlzLmNvbXB1dGVEaXN0YW5jZVBvaW50TGluZShlLHQscyl9ZWxzZSBpZihuKXtjb25zdCBlPXQuX3B0cy5nZXRDb29yZGluYXRlKHQuX3N0YXJ0KTt0aGlzLmNvbXB1dGVEaXN0YW5jZVBvaW50TGluZShlLHRoaXMscyk7Y29uc3Qgbj1zWzBdO3NbMF09c1sxXSxzWzFdPW59ZWxzZSB0aGlzLmNvbXB1dGVEaXN0YW5jZUxpbmVMaW5lKHQscyk7cmV0dXJuIHN9Z2V0RW52ZWxvcGUoKXtjb25zdCB0PW5ldyBPO2ZvcihsZXQgZT10aGlzLl9zdGFydDtlPHRoaXMuX2VuZDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fcHRzLmdldFgoZSksdGhpcy5fcHRzLmdldFkoZSkpO3JldHVybiB0fXVwZGF0ZU5lYXJlc3RMb2NhdGlvbnNMaW5lTGluZSh0LGUsbixzLGkscixvLGwpe2NvbnN0IGE9bmV3IEt0KGUsbiksYz1uZXcgS3QocixvKSxoPWEuY2xvc2VzdFBvaW50cyhjKTtsWzBdPW5ldyBZaSh0aGlzLl9nZW9tLHQsbmV3IG0oaFswXSkpLGxbMV09bmV3IFlpKHMuX2dlb20saSxuZXcgbShoWzFdKSl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB2O3QuYXBwZW5kKFwiTElORVNUUklORyAoIFwiKTtjb25zdCBlPW5ldyBtO2ZvcihsZXQgbj10aGlzLl9zdGFydDtuPHRoaXMuX2VuZDtuKyspbj50aGlzLl9zdGFydCYmdC5hcHBlbmQoXCIsIFwiKSx0aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZShuLGUpLHQuYXBwZW5kKGUueCtcIiBcIitlLnkpO3JldHVybiB0LmFwcGVuZChcIiApXCIpLHQudG9TdHJpbmcoKX1jb21wdXRlRGlzdGFuY2VQb2ludExpbmUodCxlLG4pe2xldCBzPXIuTUFYX1ZBTFVFO2ZvcihsZXQgaT1lLl9zdGFydDtpPGUuX2VuZC0xO2krKyl7Y29uc3Qgcj1lLl9wdHMuZ2V0Q29vcmRpbmF0ZShpKSxvPWUuX3B0cy5nZXRDb29yZGluYXRlKGkrMSksbD16LnBvaW50VG9TZWdtZW50KHQscixvKTtpZihsPHMmJihzPWwsbnVsbCE9PW4mJnRoaXMudXBkYXRlTmVhcmVzdExvY2F0aW9uc1BvaW50TGluZSh0LGUsaSxyLG8sbiksczw9MCkpcmV0dXJuIHN9cmV0dXJuIHN9aXNQb2ludCgpe3JldHVybiB0aGlzLl9lbmQtdGhpcy5fc3RhcnQ9PTF9ZGlzdGFuY2UodCl7Y29uc3QgZT10aGlzLmlzUG9pbnQoKSxuPXQuaXNQb2ludCgpO2xldCBzPW51bGw7aWYoZSYmbil7Y29uc3QgZT10aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9zdGFydCksbj10Ll9wdHMuZ2V0Q29vcmRpbmF0ZSh0Ll9zdGFydCk7cz1lLmRpc3RhbmNlKG4pfWVsc2UgaWYoZSl7Y29uc3QgZT10aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9zdGFydCk7cz10aGlzLmNvbXB1dGVEaXN0YW5jZVBvaW50TGluZShlLHQsbnVsbCl9ZWxzZSBpZihuKXtjb25zdCBlPXQuX3B0cy5nZXRDb29yZGluYXRlKHQuX3N0YXJ0KTtzPXRoaXMuY29tcHV0ZURpc3RhbmNlUG9pbnRMaW5lKGUsdGhpcyxudWxsKX1lbHNlIHM9dGhpcy5jb21wdXRlRGlzdGFuY2VMaW5lTGluZSh0LG51bGwpO3JldHVybiBzfX1jbGFzcyBnb3tzdGF0aWMgYWRkRmFjZXRTZXF1ZW5jZXModCxlLG4pe2xldCBzPTA7Y29uc3QgaT1lLnNpemUoKTtmb3IoO3M8PWktMTspe2xldCByPXMrZ28uRkFDRVRfU0VRVUVOQ0VfU0laRSsxO3I+PWktMSYmKHI9aSk7Y29uc3Qgbz1uZXcgdW8odCxlLHMscik7bi5hZGQobykscys9Z28uRkFDRVRfU0VRVUVOQ0VfU0laRX19c3RhdGljIGNvbXB1dGVGYWNldFNlcXVlbmNlcyh0KXtjb25zdCBlPW5ldyBMO3JldHVybiB0LmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119ZmlsdGVyKHQpe2xldCBuPW51bGw7KHQgaW5zdGFuY2VvZiAkfHx0IGluc3RhbmNlb2YgZXQpJiYobj10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLGdvLmFkZEZhY2V0U2VxdWVuY2VzKHQsbixlKSl9fSksZX1zdGF0aWMgYnVpbGQodCl7Y29uc3QgZT1uZXcgYnMoZ28uU1RSX1RSRUVfTk9ERV9DQVBBQ0lUWSk7Zm9yKGxldCBuPWdvLmNvbXB1dGVGYWNldFNlcXVlbmNlcyh0KS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmluc2VydCh0LmdldEVudmVsb3BlKCksdCl9cmV0dXJuIGUuYnVpbGQoKSxlfX1nby5GQUNFVF9TRVFVRU5DRV9TSVpFPTYsZ28uU1RSX1RSRUVfTk9ERV9DQVBBQ0lUWT00O2NsYXNzIF9ve2NvbnN0cnVjdG9yKCl7X28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fbWluQ2xlYXJhbmNlPW51bGwsdGhpcy5fbWluQ2xlYXJhbmNlUHRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIGdldExpbmUodCl7cmV0dXJuIG5ldyBfbyh0KS5nZXRMaW5lKCl9c3RhdGljIGdldERpc3RhbmNlKHQpe3JldHVybiBuZXcgX28odCkuZ2V0RGlzdGFuY2UoKX1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLG51bGw9PT10aGlzLl9taW5DbGVhcmFuY2VQdHN8fG51bGw9PT10aGlzLl9taW5DbGVhcmFuY2VQdHNbMF0/dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk6dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX21pbkNsZWFyYW5jZVB0cyl9Y29tcHV0ZSgpe2lmKG51bGwhPT10aGlzLl9taW5DbGVhcmFuY2VQdHMpcmV0dXJuIG51bGw7aWYodGhpcy5fbWluQ2xlYXJhbmNlUHRzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX21pbkNsZWFyYW5jZT1yLk1BWF9WQUxVRSx0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHQ9Z28uYnVpbGQodGhpcy5faW5wdXRHZW9tKS5uZWFyZXN0TmVpZ2hib3VyKG5ldyBwbyksZT1uZXcgcG87dGhpcy5fbWluQ2xlYXJhbmNlPWUuZGlzdGFuY2UodFswXSx0WzFdKSx0aGlzLl9taW5DbGVhcmFuY2VQdHM9ZS5nZXRDb29yZGluYXRlcygpfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX21pbkNsZWFyYW5jZX19Y2xhc3MgcG97Y29uc3RydWN0b3IoKXtwby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9taW5EaXN0PXIuTUFYX1ZBTFVFLHRoaXMuX21pblB0cz1uZXcgQXJyYXkoMikuZmlsbChudWxsKX12ZXJ0ZXhEaXN0YW5jZSh0LGUpe2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKWZvcihsZXQgcz0wO3M8ZS5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZShuKSxyPWUuZ2V0Q29vcmRpbmF0ZShzKTtpZighaS5lcXVhbHMyRChyKSl7Y29uc3QgdD1pLmRpc3RhbmNlKHIpO2lmKHQ8dGhpcy5fbWluRGlzdCYmKHRoaXMuX21pbkRpc3Q9dCx0aGlzLl9taW5QdHNbMF09aSx0aGlzLl9taW5QdHNbMV09ciwwPT09dCkpcmV0dXJuIHR9fXJldHVybiB0aGlzLl9taW5EaXN0fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX21pblB0c31zZWdtZW50RGlzdGFuY2UodCxlKXtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKylmb3IobGV0IHM9MTtzPGUuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldENvb3JkaW5hdGUobikscj1lLmdldENvb3JkaW5hdGUocy0xKSxvPWUuZ2V0Q29vcmRpbmF0ZShzKTtpZighaS5lcXVhbHMyRChyKSYmIWkuZXF1YWxzMkQobykpe2NvbnN0IHQ9ei5wb2ludFRvU2VnbWVudChpLHIsbyk7aWYodDx0aGlzLl9taW5EaXN0JiYodGhpcy5fbWluRGlzdD10LHRoaXMudXBkYXRlUHRzKGkscixvKSwwPT09dCkpcmV0dXJuIHR9fXJldHVybiB0aGlzLl9taW5EaXN0fWRpc3RhbmNlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTcyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBTcyl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0uZ2V0SXRlbSgpLG49dC5nZXRJdGVtKCk7cmV0dXJuIHRoaXMuX21pbkRpc3Q9ci5NQVhfVkFMVUUsdGhpcy5kaXN0YW5jZShlLG4pfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdW8mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgdW8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLnZlcnRleERpc3RhbmNlKHQsZSksMT09PXQuc2l6ZSgpJiYxPT09ZS5zaXplKCk/dGhpcy5fbWluRGlzdDp0aGlzLl9taW5EaXN0PD0wP3RoaXMuX21pbkRpc3Q6KHRoaXMuc2VnbWVudERpc3RhbmNlKHQsZSksdGhpcy5fbWluRGlzdDw9MHx8dGhpcy5zZWdtZW50RGlzdGFuY2UoZSx0KSx0aGlzLl9taW5EaXN0KX19dXBkYXRlUHRzKHQsZSxuKXt0aGlzLl9taW5QdHNbMF09dDtjb25zdCBzPW5ldyBLdChlLG4pO3RoaXMuX21pblB0c1sxXT1uZXcgbShzLmNsb3Nlc3RQb2ludCh0KSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3ZzXX19X28uTWluQ2xlYXJhbmNlRGlzdGFuY2U9cG87Y2xhc3MgbW97Y29uc3RydWN0b3IoKXttby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9taW5DbGVhcmFuY2U9bnVsbCx0aGlzLl9taW5DbGVhcmFuY2VQdHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgZ2V0TGluZSh0KXtyZXR1cm4gbmV3IG1vKHQpLmdldExpbmUoKX1zdGF0aWMgZ2V0RGlzdGFuY2UodCl7cmV0dXJuIG5ldyBtbyh0KS5nZXREaXN0YW5jZSgpfWdldExpbmUoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX21pbkNsZWFyYW5jZVB0cyl9dXBkYXRlQ2xlYXJhbmNlKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3Q8dGhpcy5fbWluQ2xlYXJhbmNlJiYodGhpcy5fbWluQ2xlYXJhbmNlPXQsdGhpcy5fbWluQ2xlYXJhbmNlUHRzWzBdPW5ldyBtKGUpLHRoaXMuX21pbkNsZWFyYW5jZVB0c1sxXT1uZXcgbShuKSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107aWYodDx0aGlzLl9taW5DbGVhcmFuY2Upe3RoaXMuX21pbkNsZWFyYW5jZT10LHRoaXMuX21pbkNsZWFyYW5jZVB0c1swXT1uZXcgbShlKTtjb25zdCBpPW5ldyBLdChuLHMpO3RoaXMuX21pbkNsZWFyYW5jZVB0c1sxXT1uZXcgbShpLmNsb3Nlc3RQb2ludChlKSl9fX1jb21wdXRlKCl7aWYobnVsbCE9PXRoaXMuX21pbkNsZWFyYW5jZVB0cylyZXR1cm4gbnVsbDt0aGlzLl9taW5DbGVhcmFuY2VQdHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fbWluQ2xlYXJhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuX2lucHV0R2VvbS5hcHBseShuZXcgZm8odGhpcykpfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX21pbkNsZWFyYW5jZX19Y2xhc3MgZm97Y29uc3RydWN0b3IoKXtmby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnNtYz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc21jPXR9ZmlsdGVyKHQpe3RoaXMuc21jLl9pbnB1dEdlb20uYXBwbHkobmV3IHlvKHRoaXMuc21jLHQpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSF19fWNsYXNzIHlve2NvbnN0cnVjdG9yKCl7eW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5zbWM9bnVsbCx0aGlzLl9xdWVyeVB0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zbWM9dCx0aGlzLl9xdWVyeVB0PWV9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMX1jaGVja1ZlcnRleERpc3RhbmNlKHQpe2NvbnN0IGU9dC5kaXN0YW5jZSh0aGlzLl9xdWVyeVB0KTtlPjAmJnRoaXMuc21jLnVwZGF0ZUNsZWFyYW5jZShlLHRoaXMuX3F1ZXJ5UHQsdCl9ZmlsdGVyKHQsZSl7dGhpcy5jaGVja1ZlcnRleERpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZShlKSksZT4wJiZ0aGlzLmNoZWNrU2VnbWVudERpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZShlLTEpLHQuZ2V0Q29vcmRpbmF0ZShlKSl9Y2hlY2tTZWdtZW50RGlzdGFuY2UodCxlKXtpZih0aGlzLl9xdWVyeVB0LmVxdWFsczJEKHQpfHx0aGlzLl9xdWVyeVB0LmVxdWFsczJEKGUpKXJldHVybiBudWxsO2NvbnN0IG49ei5wb2ludFRvU2VnbWVudCh0aGlzLl9xdWVyeVB0LGUsdCk7bj4wJiZ0aGlzLnNtYy51cGRhdGVDbGVhcmFuY2Uobix0aGlzLl9xdWVyeVB0LGUsdCl9aXNEb25lKCl7cmV0dXJuITF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1BdfX1tby5WZXJ0ZXhDb29yZGluYXRlRmlsdGVyPWZvLG1vLkNvbXB1dGVNQ0Nvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcj15bzt2YXIgeG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29tbW9uQml0czptcixDb21tb25CaXRzT3A6YW8sQ29tbW9uQml0c1JlbW92ZXI6ZnIsRW5oYW5jZWRQcmVjaXNpb25PcDpjbGFzc3tzdGF0aWMgdW5pb24odCxlKXtsZXQgbj1udWxsO3RyeXtyZXR1cm4gdC51bmlvbihlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O249dH10cnl7Y29uc3Qgcz1uZXcgYW8oITApLnVuaW9uKHQsZSk7aWYoIXMuaXNWYWxpZCgpKXRocm93IG47cmV0dXJuIHN9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGg/bjp0fX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7bGV0IG49bnVsbDt0cnl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKGUpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7bj10fXRyeXtjb25zdCBzPW5ldyBhbyghMCkuaW50ZXJzZWN0aW9uKHQsZSk7aWYoIXMuaXNWYWxpZCgpKXRocm93IG47cmV0dXJuIHN9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGg/bjp0fX1zdGF0aWMgYnVmZmVyKHQsZSl7bGV0IG49bnVsbDt0cnl7cmV0dXJuIHQuYnVmZmVyKGUpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7bj10fXRyeXtjb25zdCBzPW5ldyBhbyghMCkuYnVmZmVyKHQsZSk7aWYoIXMuaXNWYWxpZCgpKXRocm93IG47cmV0dXJuIHN9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGg/bjp0fX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe2xldCBuPW51bGw7dHJ5e3JldHVybiB0LnN5bURpZmZlcmVuY2UoZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDtuPXR9dHJ5e2NvbnN0IHM9bmV3IGFvKCEwKS5zeW1EaWZmZXJlbmNlKHQsZSk7aWYoIXMuaXNWYWxpZCgpKXRocm93IG47cmV0dXJuIHN9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGg/bjp0fX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe2xldCBuPW51bGw7dHJ5e3JldHVybiB0LmRpZmZlcmVuY2UoZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDtuPXR9dHJ5e2NvbnN0IHM9bmV3IGFvKCEwKS5kaWZmZXJlbmNlKHQsZSk7aWYoIXMuaXNWYWxpZCgpKXRocm93IG47cmV0dXJuIHN9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGg/bjp0fX19LEdlb21ldHJ5UHJlY2lzaW9uUmVkdWNlcjpobyxNaW5pbXVtQ2xlYXJhbmNlOl9vLFNpbXBsZU1pbmltdW1DbGVhcmFuY2U6bW99KTtjbGFzcyBFb3tjb25zdHJ1Y3Rvcigpe0VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3VzZVB0PW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9zZWc9bmV3IEt0O2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10fXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IEVvKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uc2ltcGxpZnkoKX1zaW1wbGlmeVNlY3Rpb24odCxlKXtpZih0KzE9PT1lKXJldHVybiBudWxsO3RoaXMuX3NlZy5wMD10aGlzLl9wdHNbdF0sdGhpcy5fc2VnLnAxPXRoaXMuX3B0c1tlXTtsZXQgbj0tMSxzPXQ7Zm9yKGxldCBpPXQrMTtpPGU7aSsrKXtjb25zdCB0PXRoaXMuX3NlZy5kaXN0YW5jZSh0aGlzLl9wdHNbaV0pO3Q+biYmKG49dCxzPWkpfWlmKG48PXRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKWZvcihsZXQgbj10KzE7bjxlO24rKyl0aGlzLl91c2VQdFtuXT0hMTtlbHNlIHRoaXMuc2ltcGxpZnlTZWN0aW9uKHQscyksdGhpcy5zaW1wbGlmeVNlY3Rpb24ocyxlKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5KCl7dGhpcy5fdXNlUHQ9bmV3IEFycmF5KHRoaXMuX3B0cy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9wdHMubGVuZ3RoO3QrKyl0aGlzLl91c2VQdFt0XT0hMDt0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMuX3B0cy5sZW5ndGgtMSk7Y29uc3QgdD1uZXcgUjtmb3IobGV0IGU9MDtlPHRoaXMuX3B0cy5sZW5ndGg7ZSsrKXRoaXMuX3VzZVB0W2VdJiZ0LmFkZChuZXcgbSh0aGlzLl9wdHNbZV0pKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfX1jbGFzcyBJb3tjb25zdHJ1Y3Rvcigpe0lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IElvKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1zZXRFbnN1cmVWYWxpZCh0KXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuX2lucHV0R2VvbS5jb3B5KCk6bmV3IE5vKHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neSx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBzKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9fWNsYXNzIE5vIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLE5vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPWV9dHJhbnNmb3JtUG9seWdvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIHl0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPW51bGw7cmV0dXJuIHM9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOkVvLnNpbXBsaWZ5KG4sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49ZSBpbnN0YW5jZW9mIHJ0LHM9c3VwZXIudHJhbnNmb3JtTGluZWFyUmluZy5jYWxsKHRoaXMsdCxlKTtyZXR1cm4hbnx8cyBpbnN0YW5jZW9mIGd0P3M6bnVsbH19SW8uRFBUcmFuc2Zvcm1lcj1ObztjbGFzcyB3byBleHRlbmRzIEt0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx3by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl9pbmRleD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt3by5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxudWxsLC0xKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtLdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fcGFyZW50PW4sdGhpcy5faW5kZXg9c319Z2V0SW5kZXgoKXtyZXR1cm4gdGhpcy5faW5kZXh9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudH19Y2xhc3MgQ297Y29uc3RydWN0b3IoKXtDby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wYXJlbnRMaW5lPW51bGwsdGhpcy5fc2Vncz1udWxsLHRoaXMuX3Jlc3VsdFNlZ3M9bmV3IEwsdGhpcy5fbWluaW11bVNpemU9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Q28uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDIpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3BhcmVudExpbmU9dCx0aGlzLl9taW5pbXVtU2l6ZT1lLHRoaXMuaW5pdCgpfX1zdGF0aWMgZXh0cmFjdENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKzEpLmZpbGwobnVsbCk7bGV0IG49bnVsbDtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyluPXQuZ2V0KHMpLGVbc109bi5wMDtyZXR1cm4gZVtlLmxlbmd0aC0xXT1uLnAxLGV9YWRkVG9SZXN1bHQodCl7dGhpcy5fcmVzdWx0U2Vncy5hZGQodCl9YXNMaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoQ28uZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpKX1nZXRSZXN1bHRTaXplKCl7Y29uc3QgdD10aGlzLl9yZXN1bHRTZWdzLnNpemUoKTtyZXR1cm4gMD09PXQ/MDp0KzF9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmV9Z2V0U2VnbWVudCh0KXtyZXR1cm4gdGhpcy5fc2Vnc1t0XX1nZXRQYXJlbnRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCl9Z2V0TWluaW11bVNpemUoKXtyZXR1cm4gdGhpcy5fbWluaW11bVNpemV9YXNMaW5lYXJSaW5nKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoQ28uZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpKX1nZXRTZWdtZW50cygpe3JldHVybiB0aGlzLl9zZWdzfWluaXQoKXtjb25zdCB0PXRoaXMuX3BhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLl9zZWdzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMTtlKyspe2NvbnN0IG49bmV3IHdvKHRbZV0sdFtlKzFdLHRoaXMuX3BhcmVudExpbmUsZSk7dGhpcy5fc2Vnc1tlXT1ufX1nZXRSZXN1bHRDb29yZGluYXRlcygpe3JldHVybiBDby5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2Vncyl9fWNsYXNzIFNve2NvbnN0cnVjdG9yKCl7U28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5kZXg9bmV3IE5zfXJlbW92ZSh0KXt0aGlzLl9pbmRleC5yZW1vdmUobmV3IE8odC5wMCx0LnAxKSx0KX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIENvKXtjb25zdCB0PWFyZ3VtZW50c1swXS5nZXRTZWdtZW50cygpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPXRbZV07dGhpcy5hZGQobil9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5kZXguaW5zZXJ0KG5ldyBPKHQucDAsdC5wMSksdCl9fXF1ZXJ5KHQpe2NvbnN0IGU9bmV3IE8odC5wMCx0LnAxKSxuPW5ldyBMbyh0KTt0aGlzLl9pbmRleC5xdWVyeShlLG4pO3JldHVybiBuLmdldEl0ZW1zKCl9fWNsYXNzIExve2NvbnN0cnVjdG9yKCl7TG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcXVlcnlTZWc9bnVsbCx0aGlzLl9pdGVtcz1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9xdWVyeVNlZz10fXZpc2l0SXRlbSh0KXtjb25zdCBlPXQ7Ty5pbnRlcnNlY3RzKGUucDAsZS5wMSx0aGlzLl9xdWVyeVNlZy5wMCx0aGlzLl9xdWVyeVNlZy5wMSkmJnRoaXMuX2l0ZW1zLmFkZCh0KX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRGVdfX1jbGFzcyBUb3tjb25zdHJ1Y3Rvcigpe1RvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9pbnB1dEluZGV4PW5ldyBTbyx0aGlzLl9vdXRwdXRJbmRleD1uZXcgU28sdGhpcy5fbGluZT1udWxsLHRoaXMuX2xpbmVQdHM9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0SW5kZXg9dCx0aGlzLl9vdXRwdXRJbmRleD1lfXN0YXRpYyBpc0luTGluZVNlY3Rpb24odCxlLG4pe2lmKG4uZ2V0UGFyZW50KCkhPT10LmdldFBhcmVudCgpKXJldHVybiExO2NvbnN0IHM9bi5nZXRJbmRleCgpO3JldHVybiBzPj1lWzBdJiZzPGVbMV19ZmxhdHRlbih0LGUpe2NvbnN0IG49dGhpcy5fbGluZVB0c1t0XSxzPXRoaXMuX2xpbmVQdHNbZV0saT1uZXcgS3QobixzKTtyZXR1cm4gdGhpcy5yZW1vdmUodGhpcy5fbGluZSx0LGUpLHRoaXMuX291dHB1dEluZGV4LmFkZChpKSxpfWhhc0JhZEludGVyc2VjdGlvbih0LGUsbil7cmV0dXJuISF0aGlzLmhhc0JhZE91dHB1dEludGVyc2VjdGlvbihuKXx8ISF0aGlzLmhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5U2VjdGlvbih0LGUsbil7bis9MTtjb25zdCBzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHQrMT09PWUpe2NvbnN0IGU9dGhpcy5fbGluZS5nZXRTZWdtZW50KHQpO3JldHVybiB0aGlzLl9saW5lLmFkZFRvUmVzdWx0KGUpLG51bGx9bGV0IGk9ITA7aWYodGhpcy5fbGluZS5nZXRSZXN1bHRTaXplKCk8dGhpcy5fbGluZS5nZXRNaW5pbXVtU2l6ZSgpKXtuKzE8dGhpcy5fbGluZS5nZXRNaW5pbXVtU2l6ZSgpJiYoaT0hMSl9Y29uc3Qgcj1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxvPXRoaXMuZmluZEZ1cnRoZXN0UG9pbnQodGhpcy5fbGluZVB0cyx0LGUscik7clswXT50aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSYmKGk9ITEpO2NvbnN0IGw9bmV3IEt0O2lmKGwucDA9dGhpcy5fbGluZVB0c1t0XSxsLnAxPXRoaXMuX2xpbmVQdHNbZV0sc1swXT10LHNbMV09ZSx0aGlzLmhhc0JhZEludGVyc2VjdGlvbih0aGlzLl9saW5lLHMsbCkmJihpPSExKSxpKXtjb25zdCBuPXRoaXMuZmxhdHRlbih0LGUpO3JldHVybiB0aGlzLl9saW5lLmFkZFRvUmVzdWx0KG4pLG51bGx9dGhpcy5zaW1wbGlmeVNlY3Rpb24odCxvLG4pLHRoaXMuc2ltcGxpZnlTZWN0aW9uKG8sZSxuKX1oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXRoaXMuX291dHB1dEluZGV4LnF1ZXJ5KHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24obix0KSlyZXR1cm4hMH1yZXR1cm4hMX1maW5kRnVydGhlc3RQb2ludCh0LGUsbixzKXtjb25zdCBpPW5ldyBLdDtpLnAwPXRbZV0saS5wMT10W25dO2xldCByPS0xLG89ZTtmb3IobGV0IHM9ZSsxO3M8bjtzKyspe2NvbnN0IGU9dFtzXSxuPWkuZGlzdGFuY2UoZSk7bj5yJiYocj1uLG89cyl9cmV0dXJuIHNbMF09cixvfXNpbXBsaWZ5KHQpe3RoaXMuX2xpbmU9dCx0aGlzLl9saW5lUHRzPXQuZ2V0UGFyZW50Q29vcmRpbmF0ZXMoKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMuX2xpbmVQdHMubGVuZ3RoLTEsMCl9cmVtb3ZlKHQsZSxuKXtmb3IobGV0IHM9ZTtzPG47cysrKXtjb25zdCBlPXQuZ2V0U2VnbWVudChzKTt0aGlzLl9pbnB1dEluZGV4LnJlbW92ZShlKX19aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LnAwLHQucDEsZS5wMCxlLnAxKSx0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl9aGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pe2ZvcihsZXQgcz10aGlzLl9pbnB1dEluZGV4LnF1ZXJ5KG4pLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oaSxuKSl7aWYoVG8uaXNJbkxpbmVTZWN0aW9uKHQsZSxpKSljb250aW51ZTtyZXR1cm4hMH19cmV0dXJuITF9fWNsYXNzIFJve2NvbnN0cnVjdG9yKCl7Um8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRJbmRleD1uZXcgU28sdGhpcy5fb3V0cHV0SW5kZXg9bmV3IFNvLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPTB9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeSh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLl9pbnB1dEluZGV4LmFkZChlLm5leHQoKSk7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9bmV3IFRvKHRoaXMuX2lucHV0SW5kZXgsdGhpcy5fb3V0cHV0SW5kZXgpO3Quc2V0RGlzdGFuY2VUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHQuc2ltcGxpZnkoZS5uZXh0KCkpfX19Y2xhc3MgUG97Y29uc3RydWN0b3IoKXtQby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9saW5lU2ltcGxpZmllcj1uZXcgUm8sdGhpcy5fbGluZXN0cmluZ01hcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IFBvKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1nZXRSZXN1bHRHZW9tZXRyeSgpe2lmKHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2lucHV0R2VvbS5jb3B5KCk7dGhpcy5fbGluZXN0cmluZ01hcD1uZXcgTnQsdGhpcy5faW5wdXRHZW9tLmFwcGx5KG5ldyB2byh0aGlzKSksdGhpcy5fbGluZVNpbXBsaWZpZXIuc2ltcGxpZnkodGhpcy5fbGluZXN0cmluZ01hcC52YWx1ZXMoKSk7cmV0dXJuIG5ldyBPbyh0aGlzLl9saW5lc3RyaW5nTWFwKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PDApdGhyb3cgbmV3IHMoXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5fbGluZVNpbXBsaWZpZXIuc2V0RGlzdGFuY2VUb2xlcmFuY2UodCl9fWNsYXNzIE9vIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLE9vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVzdHJpbmdNYXA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lc3RyaW5nTWFwPXR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtpZigwPT09dC5zaXplKCkpcmV0dXJuIG51bGw7aWYoZSBpbnN0YW5jZW9mICQpe2NvbnN0IHQ9dGhpcy5fbGluZXN0cmluZ01hcC5nZXQoZSk7cmV0dXJuIHRoaXMuY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlKHQuZ2V0UmVzdWx0Q29vcmRpbmF0ZXMoKSl9cmV0dXJuIHN1cGVyLnRyYW5zZm9ybUNvb3JkaW5hdGVzLmNhbGwodGhpcyx0LGUpfX1jbGFzcyB2b3tjb25zdHJ1Y3Rvcigpe3ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMudHBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy50cHM9dH1maWx0ZXIodCl7aWYodCBpbnN0YW5jZW9mICQpe2NvbnN0IGU9dDtpZihlLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPWUuaXNDbG9zZWQoKT80OjIscz1uZXcgQ28oZSxuKTt0aGlzLnRwcy5fbGluZXN0cmluZ01hcC5wdXQoZSxzKX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfX1Qby5MaW5lU3RyaW5nVHJhbnNmb3JtZXI9T28sUG8uTGluZVN0cmluZ01hcEJ1aWxkZXJGaWx0ZXI9dm87Y2xhc3MgYm97Y29uc3RydWN0b3IoKXtiby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl90b2xlcmFuY2U9ZSplfXN0YXRpYyBzaW1wbGlmeSh0LGUpe3JldHVybiBuZXcgYm8odCxlKS5zaW1wbGlmeSgpfXNpbXBsaWZ5VmVydGV4KHQpe2xldCBlPXQsbj1lLmdldEFyZWEoKSxzPW51bGw7Zm9yKDtudWxsIT09ZTspe2NvbnN0IHQ9ZS5nZXRBcmVhKCk7dDxuJiYobj10LHM9ZSksZT1lLl9uZXh0fXJldHVybiBudWxsIT09cyYmbjx0aGlzLl90b2xlcmFuY2UmJnMucmVtb3ZlKCksdC5pc0xpdmUoKT9uOi0xfXNpbXBsaWZ5KCl7Y29uc3QgdD1Nby5idWlsZExpbmUodGhpcy5fcHRzKTtsZXQgZT10aGlzLl90b2xlcmFuY2U7ZG97ZT10aGlzLnNpbXBsaWZ5VmVydGV4KHQpfXdoaWxlKGU8dGhpcy5fdG9sZXJhbmNlKTtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gbi5sZW5ndGg8Mj9bblswXSxuZXcgbShuWzBdKV06bn19Y2xhc3MgTW97Y29uc3RydWN0b3IoKXtNby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdD1udWxsLHRoaXMuX3ByZXY9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fYXJlYT1Nby5NQVhfQVJFQSx0aGlzLl9pc0xpdmU9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHQ9dH1zdGF0aWMgYnVpbGRMaW5lKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKXtjb25zdCBpPW5ldyBNbyh0W3NdKTtudWxsPT09ZSYmKGU9aSksaS5zZXRQcmV2KG4pLG51bGwhPT1uJiYobi5zZXROZXh0KGkpLG4udXBkYXRlQXJlYSgpKSxuPWl9cmV0dXJuIGV9Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBSO2xldCBlPXRoaXM7ZG97dC5hZGQoZS5fcHQsITEpLGU9ZS5fbmV4dH13aGlsZShudWxsIT09ZSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX1nZXRBcmVhKCl7cmV0dXJuIHRoaXMuX2FyZWF9dXBkYXRlQXJlYSgpe2lmKG51bGw9PT10aGlzLl9wcmV2fHxudWxsPT09dGhpcy5fbmV4dClyZXR1cm4gdGhpcy5fYXJlYT1Nby5NQVhfQVJFQSxudWxsO3RoaXMuX2FyZWE9TWF0aC5hYnMobmUuYXJlYSh0aGlzLl9wcmV2Ll9wdCx0aGlzLl9wdCx0aGlzLl9uZXh0Ll9wdCkpfXJlbW92ZSgpe2NvbnN0IHQ9dGhpcy5fcHJldixlPXRoaXMuX25leHQ7bGV0IG49bnVsbDtyZXR1cm4gbnVsbCE9PXRoaXMuX3ByZXYmJih0aGlzLl9wcmV2LnNldE5leHQoZSksdGhpcy5fcHJldi51cGRhdGVBcmVhKCksbj10aGlzLl9wcmV2KSxudWxsIT09dGhpcy5fbmV4dCYmKHRoaXMuX25leHQuc2V0UHJldih0KSx0aGlzLl9uZXh0LnVwZGF0ZUFyZWEoKSxudWxsPT09biYmKG49dGhpcy5fbmV4dCkpLHRoaXMuX2lzTGl2ZT0hMSxufWlzTGl2ZSgpe3JldHVybiB0aGlzLl9pc0xpdmV9c2V0UHJldih0KXt0aGlzLl9wcmV2PXR9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9fU1vLk1BWF9BUkVBPXIuTUFYX1ZBTFVFLGJvLlZXVmVydGV4PU1vO2NsYXNzIERve2NvbnN0cnVjdG9yKCl7RG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgRG8odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfXNldEVuc3VyZVZhbGlkKHQpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10fWdldFJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCk/dGhpcy5faW5wdXRHZW9tLmNvcHkoKTpuZXcgQW8odGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PDApdGhyb3cgbmV3IHMoXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH19Y2xhc3MgQW8gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9ZX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgeXQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IHM9bnVsbDtyZXR1cm4gcz0wPT09bi5sZW5ndGg/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6Ym8uc2ltcGxpZnkobix0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj1lIGluc3RhbmNlb2YgcnQscz1zdXBlci50cmFuc2Zvcm1MaW5lYXJSaW5nLmNhbGwodGhpcyx0LGUpO3JldHVybiFufHxzIGluc3RhbmNlb2YgZ3Q/czpudWxsfX1Eby5WV1RyYW5zZm9ybWVyPUFvO3ZhciBGbz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEb3VnbGFzUGV1Y2tlclNpbXBsaWZpZXI6SW8sVG9wb2xvZ3lQcmVzZXJ2aW5nU2ltcGxpZmllcjpQbyxWV1NpbXBsaWZpZXI6RG99KTtjbGFzcyBHb3tjb25zdHJ1Y3Rvcigpe0dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NlZz1udWxsLHRoaXMuX3NlZ0xlbj1udWxsLHRoaXMuX3NwbGl0UHQ9bnVsbCx0aGlzLl9taW5pbXVtTGVuPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2VnPXQsdGhpcy5fc2VnTGVuPXQuZ2V0TGVuZ3RoKCl9c3RhdGljIHBvaW50QWxvbmdSZXZlcnNlKHQsZSl7Y29uc3Qgbj1uZXcgbTtyZXR1cm4gbi54PXQucDEueC1lKih0LnAxLngtdC5wMC54KSxuLnk9dC5wMS55LWUqKHQucDEueS10LnAwLnkpLG59c3BsaXRBdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX21pbmltdW1MZW4vdGhpcy5fc2VnTGVuO2lmKHQuZGlzdGFuY2UodGhpcy5fc2VnLnAwKTx0aGlzLl9taW5pbXVtTGVuKXJldHVybiB0aGlzLl9zcGxpdFB0PXRoaXMuX3NlZy5wb2ludEFsb25nKGUpLG51bGw7aWYodC5kaXN0YW5jZSh0aGlzLl9zZWcucDEpPHRoaXMuX21pbmltdW1MZW4pcmV0dXJuIHRoaXMuX3NwbGl0UHQ9R28ucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5fc2VnLGUpLG51bGw7dGhpcy5fc3BsaXRQdD10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5nZXRDb25zdHJhaW5lZExlbmd0aCh0KS90aGlzLl9zZWdMZW47ZS5lcXVhbHMyRCh0aGlzLl9zZWcucDApP3RoaXMuX3NwbGl0UHQ9dGhpcy5fc2VnLnBvaW50QWxvbmcobik6dGhpcy5fc3BsaXRQdD1Hby5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLl9zZWcsbil9fXNldE1pbmltdW1MZW5ndGgodCl7dGhpcy5fbWluaW11bUxlbj10fWdldENvbnN0cmFpbmVkTGVuZ3RoKHQpe3JldHVybiB0PHRoaXMuX21pbmltdW1MZW4/dGhpcy5fbWluaW11bUxlbjp0fWdldFNwbGl0UG9pbnQoKXtyZXR1cm4gdGhpcy5fc3BsaXRQdH19Y2xhc3MgcW97ZmluZFNwbGl0UG9pbnQodCxlKXt9fWNsYXNzIEJve3N0YXRpYyBwcm9qZWN0ZWRTcGxpdFBvaW50KHQsZSl7cmV0dXJuIHQuZ2V0TGluZVNlZ21lbnQoKS5wcm9qZWN0KGUpfWZpbmRTcGxpdFBvaW50KHQsZSl7Y29uc3Qgbj10LmdldExpbmVTZWdtZW50KCkscz1uLmdldExlbmd0aCgpLzIsaT1uZXcgR28obikscj1Cby5wcm9qZWN0ZWRTcGxpdFBvaW50KHQsZSk7bGV0IG89MipyLmRpc3RhbmNlKGUpKi44O3JldHVybiBvPnMmJihvPXMpLGkuc2V0TWluaW11bUxlbmd0aChvKSxpLnNwbGl0QXQociksaS5nZXRTcGxpdFBvaW50KCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3FvXX19Y2xhc3MgWW97c3RhdGljIHRyaUFyZWEodCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKGUueS10LnkpKihuLngtdC54KX1zdGF0aWMgaXNJbkNpcmNsZURETm9ybWFsaXplZCh0LGUsbixzKXtjb25zdCBpPUEudmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChzLngpLHI9QS52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KHMueSksbz1BLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3Qocy54KSxsPUEudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdChzLnkpLGE9QS52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KHMueCksYz1BLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3Qocy55KSxoPWkubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KG8ubXVsdGlwbHkocikpLHU9by5tdWx0aXBseShjKS5zZWxmU3VidHJhY3QoYS5tdWx0aXBseShsKSksZz1hLm11bHRpcGx5KHIpLnNlbGZTdWJ0cmFjdChpLm11bHRpcGx5KGMpKSxkPWkubXVsdGlwbHkoaSkuc2VsZkFkZChyLm11bHRpcGx5KHIpKSxfPW8ubXVsdGlwbHkobykuc2VsZkFkZChsLm11bHRpcGx5KGwpKSxwPWEubXVsdGlwbHkoYSkuc2VsZkFkZChjLm11bHRpcGx5KGMpKTtyZXR1cm4gZC5zZWxmTXVsdGlwbHkodSkuc2VsZkFkZChfLnNlbGZNdWx0aXBseShnKSkuc2VsZkFkZChwLnNlbGZNdWx0aXBseShoKSkuZG91YmxlVmFsdWUoKT4wfXN0YXRpYyBjaGVja1JvYnVzdEluQ2lyY2xlKHQsZSxuLHMpe2NvbnN0IGk9WW8uaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixzKSxyPVlvLmlzSW5DaXJjbGVERFNsb3codCxlLG4scyksbz1Zby5pc0luQ2lyY2xlQ0ModCxlLG4scyksbD1uZS5jaXJjdW1jZW50cmUodCxlLG4pO1kub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpLXQuZGlzdGFuY2UobCkpL3QuZGlzdGFuY2UobCkpLGk9PT1yJiZpPT09b3x8KFkub3V0LnByaW50bG4oXCJpbkNpcmNsZSByb2J1c3RuZXNzIGZhaWx1cmUgKGRvdWJsZSByZXN1bHQgPSBcIitpK1wiLCBERCByZXN1bHQgPSBcIityK1wiLCBDQyByZXN1bHQgPSBcIitvK1wiKVwiKSxZLm91dC5wcmludGxuKFd0LnRvTGluZVN0cmluZyhuZXcgbXQoW3QsZSxuLHNdKSkpLFkub3V0LnByaW50bG4oXCJDaXJjdW1jZW50cmUgPSBcIitXdC50b1BvaW50KGwpK1wiIHJhZGl1cyA9IFwiK3QuZGlzdGFuY2UobCkpLFkub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpL3QuZGlzdGFuY2UobCktMSkpLFkub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGIgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpL2UuZGlzdGFuY2UobCktMSkpLFkub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGMgPSBcIitNYXRoLmFicyhzLmRpc3RhbmNlKGwpL24uZGlzdGFuY2UobCktMSkpLFkub3V0LnByaW50bG4oKSl9c3RhdGljIGlzSW5DaXJjbGVEREZhc3QodCxlLG4scyl7Y29uc3QgaT1BLnNxcih0LngpLnNlbGZBZGQoQS5zcXIodC55KSkuc2VsZk11bHRpcGx5KFlvLnRyaUFyZWFEREZhc3QoZSxuLHMpKSxyPUEuc3FyKGUueCkuc2VsZkFkZChBLnNxcihlLnkpKS5zZWxmTXVsdGlwbHkoWW8udHJpQXJlYURERmFzdCh0LG4scykpLG89QS5zcXIobi54KS5zZWxmQWRkKEEuc3FyKG4ueSkpLnNlbGZNdWx0aXBseShZby50cmlBcmVhRERGYXN0KHQsZSxzKSksbD1BLnNxcihzLngpLnNlbGZBZGQoQS5zcXIocy55KSkuc2VsZk11bHRpcGx5KFlvLnRyaUFyZWFEREZhc3QodCxlLG4pKTtyZXR1cm4gaS5zZWxmU3VidHJhY3Qocikuc2VsZkFkZChvKS5zZWxmU3VidHJhY3QobCkuZG91YmxlVmFsdWUoKT4wfXN0YXRpYyBpc0luQ2lyY2xlQ0ModCxlLG4scyl7Y29uc3QgaT1uZS5jaXJjdW1jZW50cmUodCxlLG4pLHI9dC5kaXN0YW5jZShpKTtyZXR1cm4gcy5kaXN0YW5jZShpKS1yPD0wfXN0YXRpYyBpc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixzKXtjb25zdCBpPXQueC1zLngscj10Lnktcy55LG89ZS54LXMueCxsPWUueS1zLnksYT1uLngtcy54LGM9bi55LXMueTtyZXR1cm4oaSppK3IqcikqKG8qYy1hKmwpKyhvKm8rbCpsKSooYSpyLWkqYykrKGEqYStjKmMpKihpKmwtbypyKT4wfXN0YXRpYyBpc0luQ2lyY2xlRERTbG93KHQsZSxuLHMpe2NvbnN0IGk9QS52YWx1ZU9mKHMueCkscj1BLnZhbHVlT2Yocy55KSxvPUEudmFsdWVPZih0LngpLGw9QS52YWx1ZU9mKHQueSksYT1BLnZhbHVlT2YoZS54KSxjPUEudmFsdWVPZihlLnkpLGg9QS52YWx1ZU9mKG4ueCksdT1BLnZhbHVlT2Yobi55KSxnPW8ubXVsdGlwbHkobykuYWRkKGwubXVsdGlwbHkobCkpLm11bHRpcGx5KFlvLnRyaUFyZWFERFNsb3coYSxjLGgsdSxpLHIpKSxkPWEubXVsdGlwbHkoYSkuYWRkKGMubXVsdGlwbHkoYykpLm11bHRpcGx5KFlvLnRyaUFyZWFERFNsb3cobyxsLGgsdSxpLHIpKSxfPWgubXVsdGlwbHkoaCkuYWRkKHUubXVsdGlwbHkodSkpLm11bHRpcGx5KFlvLnRyaUFyZWFERFNsb3cobyxsLGEsYyxpLHIpKSxwPWkubXVsdGlwbHkoaSkuYWRkKHIubXVsdGlwbHkocikpLm11bHRpcGx5KFlvLnRyaUFyZWFERFNsb3cobyxsLGEsYyxoLHUpKTtyZXR1cm4gZy5zdWJ0cmFjdChkKS5hZGQoXykuc3VidHJhY3QocCkuZG91YmxlVmFsdWUoKT4wfXN0YXRpYyBpc0luQ2lyY2xlTm9uUm9idXN0KHQsZSxuLHMpe3JldHVybih0LngqdC54K3QueSp0LnkpKllvLnRyaUFyZWEoZSxuLHMpLShlLngqZS54K2UueSplLnkpKllvLnRyaUFyZWEodCxuLHMpKyhuLngqbi54K24ueSpuLnkpKllvLnRyaUFyZWEodCxlLHMpLShzLngqcy54K3MueSpzLnkpKllvLnRyaUFyZWEodCxlLG4pPjB9c3RhdGljIGlzSW5DaXJjbGVSb2J1c3QodCxlLG4scyl7cmV0dXJuIFlvLmlzSW5DaXJjbGVOb3JtYWxpemVkKHQsZSxuLHMpfXN0YXRpYyB0cmlBcmVhRERTbG93KHQsZSxuLHMsaSxyKXtyZXR1cm4gbi5zdWJ0cmFjdCh0KS5tdWx0aXBseShyLnN1YnRyYWN0KGUpKS5zdWJ0cmFjdChzLnN1YnRyYWN0KGUpLm11bHRpcGx5KGkuc3VidHJhY3QodCkpKX1zdGF0aWMgdHJpQXJlYURERmFzdCh0LGUsbil7Y29uc3Qgcz1BLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoQS52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHQueSkpLGk9QS52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KEEudmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdCh0LngpKTtyZXR1cm4gcy5zZWxmU3VidHJhY3QoaSl9fWNsYXNzIFZve2NvbnN0cnVjdG9yKCl7Vm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wPW5ldyBtKHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9bmV3IG0odCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wPW5ldyBtKHQsZSxuKX19c3RhdGljIGludGVycG9sYXRlWigpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZGlzdGFuY2UobiksaT10LmRpc3RhbmNlKGUpLHI9bi5nZXRaKCktZS5nZXRaKCk7cmV0dXJuIGUuZ2V0WigpK3IqKGkvcyl9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9ZS54LHI9ZS55LG89bi54LWksbD1zLngtaSxhPW4ueS1yLGM9cy55LXIsaD1vKmMtbCphLHU9dC54LWksZz10LnktcixkPShjKnUtbCpnKS9oLF89KC1hKnUrbypnKS9oO3JldHVybiBlLmdldFooKStkKihuLmdldFooKS1lLmdldFooKSkrXyoocy5nZXRaKCktZS5nZXRaKCkpfX1jaXJjbGVDZW50ZXIodCxlKXtjb25zdCBuPW5ldyBWbyh0aGlzLmdldFgoKSx0aGlzLmdldFkoKSkscz10aGlzLmJpc2VjdG9yKG4sdCksaT10aGlzLmJpc2VjdG9yKHQsZSkscj1uZXcgZWUocyxpKTtsZXQgbz1udWxsO3RyeXtvPW5ldyBWbyhyLmdldFgoKSxyLmdldFkoKSl9Y2F0Y2gocyl7aWYoIShzIGluc3RhbmNlb2YgdGUpKXRocm93IHM7WS5lcnIucHJpbnRsbihcImE6IFwiK24rXCIgIGI6IFwiK3QrXCIgIGM6IFwiK2UpLFkuZXJyLnByaW50bG4ocyl9cmV0dXJuIG99ZG90KHQpe3JldHVybiB0aGlzLl9wLngqdC5nZXRYKCkrdGhpcy5fcC55KnQuZ2V0WSgpfW1hZ24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3AueCp0aGlzLl9wLngrdGhpcy5fcC55KnRoaXMuX3AueSl9Z2V0Wigpe3JldHVybiB0aGlzLl9wLmdldFooKX1iaXNlY3Rvcih0LGUpe2NvbnN0IG49ZS5nZXRYKCktdC5nZXRYKCkscz1lLmdldFkoKS10LmdldFkoKSxpPW5ldyBlZSh0LmdldFgoKStuLzIsdC5nZXRZKCkrcy8yLDEpLHI9bmV3IGVlKHQuZ2V0WCgpLXMrbi8yLHQuZ2V0WSgpK24rcy8yLDEpO3JldHVybiBuZXcgZWUoaSxyKX1lcXVhbHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX3AueD09PXQuZ2V0WCgpJiZ0aGlzLl9wLnk9PT10LmdldFkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX3AuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpPGV9fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcH1pc0luQ2lyY2xlKHQsZSxuKXtyZXR1cm4gWW8uaXNJbkNpcmNsZVJvYnVzdCh0Ll9wLGUuX3Asbi5fcCx0aGlzLl9wKX1pbnRlcnBvbGF0ZVpWYWx1ZSh0LGUsbil7Y29uc3Qgcz10LmdldFgoKSxpPXQuZ2V0WSgpLHI9ZS5nZXRYKCktcyxvPW4uZ2V0WCgpLXMsbD1lLmdldFkoKS1pLGE9bi5nZXRZKCktaSxjPXIqYS1vKmwsaD10aGlzLmdldFgoKS1zLHU9dGhpcy5nZXRZKCktaSxnPShhKmgtbyp1KS9jLGQ9KC1sKmgrcip1KS9jO3JldHVybiB0LmdldFooKStnKihlLmdldFooKS10LmdldFooKSkrZCoobi5nZXRaKCktdC5nZXRaKCkpfW1pZFBvaW50KHQpe2NvbnN0IGU9KHRoaXMuX3AueCt0LmdldFgoKSkvMixuPSh0aGlzLl9wLnkrdC5nZXRZKCkpLzIscz0odGhpcy5fcC5nZXRaKCkrdC5nZXRaKCkpLzI7cmV0dXJuIG5ldyBWbyhlLG4scyl9cmlnaHRPZih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0LmRlc3QoKSx0Lm9yaWcoKSl9aXNDQ1codCxlKXtyZXR1cm4odC5fcC54LXRoaXMuX3AueCkqKGUuX3AueS10aGlzLl9wLnkpLSh0Ll9wLnktdGhpcy5fcC55KSooZS5fcC54LXRoaXMuX3AueCk+MH1nZXRYKCl7cmV0dXJuIHRoaXMuX3AueH1jcm9zc1Byb2R1Y3QodCl7cmV0dXJuIHRoaXMuX3AueCp0LmdldFkoKS10aGlzLl9wLnkqdC5nZXRYKCl9c2V0Wih0KXt0aGlzLl9wLnNldFoodCl9dGltZXModCl7cmV0dXJuIG5ldyBWbyh0KnRoaXMuX3AueCx0KnRoaXMuX3AueSl9Y3Jvc3MoKXtyZXR1cm4gbmV3IFZvKHRoaXMuX3AueSwtdGhpcy5fcC54KX1sZWZ0T2YodCl7cmV0dXJuIHRoaXMuaXNDQ1codC5vcmlnKCksdC5kZXN0KCkpfXRvU3RyaW5nKCl7cmV0dXJuXCJQT0lOVCAoXCIrdGhpcy5fcC54K1wiIFwiK3RoaXMuX3AueStcIilcIn1zdWIodCl7cmV0dXJuIG5ldyBWbyh0aGlzLl9wLngtdC5nZXRYKCksdGhpcy5fcC55LXQuZ2V0WSgpKX1nZXRZKCl7cmV0dXJuIHRoaXMuX3AueX1jbGFzc2lmeSh0LGUpe2NvbnN0IG49dGhpcyxzPWUuc3ViKHQpLGk9bi5zdWIodCkscj1zLmNyb3NzUHJvZHVjdChpKTtyZXR1cm4gcj4wP1ZvLkxFRlQ6cjwwP1ZvLlJJR0hUOnMuZ2V0WCgpKmkuZ2V0WCgpPDB8fHMuZ2V0WSgpKmkuZ2V0WSgpPDA/Vm8uQkVISU5EOnMubWFnbigpPGkubWFnbigpP1ZvLkJFWU9ORDp0LmVxdWFscyhuKT9Wby5PUklHSU46ZS5lcXVhbHMobik/Vm8uREVTVElOQVRJT046Vm8uQkVUV0VFTn1zdW0odCl7cmV0dXJuIG5ldyBWbyh0aGlzLl9wLngrdC5nZXRYKCksdGhpcy5fcC55K3QuZ2V0WSgpKX1kaXN0YW5jZSh0LGUpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZS5nZXRYKCktdC5nZXRYKCksMikrTWF0aC5wb3coZS5nZXRZKCktdC5nZXRZKCksMikpfWNpcmN1bVJhZGl1c1JhdGlvKHQsZSl7Y29uc3Qgbj10aGlzLmNpcmNsZUNlbnRlcih0LGUpLHM9dGhpcy5kaXN0YW5jZShuLHQpO2xldCBpPXRoaXMuZGlzdGFuY2UodGhpcyx0KSxyPXRoaXMuZGlzdGFuY2UodCxlKTtyZXR1cm4gcjxpJiYoaT1yKSxyPXRoaXMuZGlzdGFuY2UoZSx0aGlzKSxyPGkmJihpPXIpLHMvaX19Vm8uTEVGVD0wLFZvLlJJR0hUPTEsVm8uQkVZT05EPTIsVm8uQkVISU5EPTMsVm8uQkVUV0VFTj00LFZvLk9SSUdJTj01LFZvLkRFU1RJTkFUSU9OPTY7Y2xhc3Mgem8gZXh0ZW5kcyBWb3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksem8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9bnVsbCx0aGlzLl9jb25zdHJhaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07Vm8uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1nZXRDb25zdHJhaW50KCl7cmV0dXJuIHRoaXMuX2NvbnN0cmFpbnR9c2V0T25Db25zdHJhaW50KHQpe3RoaXMuX2lzT25Db25zdHJhaW50PXR9bWVyZ2UodCl7dC5faXNPbkNvbnN0cmFpbnQmJih0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLl9jb25zdHJhaW50PXQuX2NvbnN0cmFpbnQpfWlzT25Db25zdHJhaW50KCl7cmV0dXJuIHRoaXMuX2lzT25Db25zdHJhaW50fXNldENvbnN0cmFpbnQodCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5fY29uc3RyYWludD10fX1jbGFzcyBYb3tjb25zdHJ1Y3Rvcigpe1hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JvdD1udWxsLHRoaXMuX3ZlcnRleD1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9c3RhdGljIG1ha2VFZGdlKHQsZSl7Y29uc3Qgbj1uZXcgWG8scz1uZXcgWG8saT1uZXcgWG8scj1uZXcgWG87bi5fcm90PXMscy5fcm90PWksaS5fcm90PXIsci5fcm90PW4sbi5zZXROZXh0KG4pLHMuc2V0TmV4dChyKSxpLnNldE5leHQoaSksci5zZXROZXh0KHMpO2NvbnN0IG89bjtyZXR1cm4gby5zZXRPcmlnKHQpLG8uc2V0RGVzdChlKSxvfXN0YXRpYyBzd2FwKHQpe2NvbnN0IGU9dC5vUHJldigpLG49dC5zeW0oKS5vUHJldigpO1hvLnNwbGljZSh0LGUpLFhvLnNwbGljZSh0LnN5bSgpLG4pLFhvLnNwbGljZSh0LGUubE5leHQoKSksWG8uc3BsaWNlKHQuc3ltKCksbi5sTmV4dCgpKSx0LnNldE9yaWcoZS5kZXN0KCkpLHQuc2V0RGVzdChuLmRlc3QoKSl9c3RhdGljIHNwbGljZSh0LGUpe2NvbnN0IG49dC5vTmV4dCgpLnJvdCgpLHM9ZS5vTmV4dCgpLnJvdCgpLGk9ZS5vTmV4dCgpLHI9dC5vTmV4dCgpLG89cy5vTmV4dCgpLGw9bi5vTmV4dCgpO3Quc2V0TmV4dChpKSxlLnNldE5leHQociksbi5zZXROZXh0KG8pLHMuc2V0TmV4dChsKX1zdGF0aWMgY29ubmVjdCh0LGUpe2NvbnN0IG49WG8ubWFrZUVkZ2UodC5kZXN0KCksZS5vcmlnKCkpO3JldHVybiBYby5zcGxpY2Uobix0LmxOZXh0KCkpLFhvLnNwbGljZShuLnN5bSgpLGUpLG59ZXF1YWxzTm9uT3JpZW50ZWQodCl7cmV0dXJuISF0aGlzLmVxdWFsc09yaWVudGVkKHQpfHwhIXRoaXMuZXF1YWxzT3JpZW50ZWQodC5zeW0oKSl9dG9MaW5lU2VnbWVudCgpe3JldHVybiBuZXcgS3QodGhpcy5fdmVydGV4LmdldENvb3JkaW5hdGUoKSx0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfWRlc3QoKXtyZXR1cm4gdGhpcy5zeW0oKS5vcmlnKCl9b05leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1lcXVhbHNPcmllbnRlZCh0KXtyZXR1cm4hKCF0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpKXx8IXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpKX1kTmV4dCgpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCkuc3ltKCl9bFByZXYoKXtyZXR1cm4gdGhpcy5fbmV4dC5zeW0oKX1yUHJldigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCl9cm90KCl7cmV0dXJuIHRoaXMuX3JvdH1vUHJldigpe3JldHVybiB0aGlzLl9yb3QuX25leHQuX3JvdH1zeW0oKXtyZXR1cm4gdGhpcy5fcm90Ll9yb3R9c2V0T3JpZyh0KXt0aGlzLl92ZXJ0ZXg9dH1sTmV4dCgpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkucm90KCl9Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZSh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfWludlJvdCgpe3JldHVybiB0aGlzLl9yb3Quc3ltKCl9c2V0RGVzdCh0KXt0aGlzLnN5bSgpLnNldE9yaWcodCl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWRlbGV0ZSgpe3RoaXMuX3JvdD1udWxsfW9yaWcoKXtyZXR1cm4gdGhpcy5fdmVydGV4fXJOZXh0KCl7cmV0dXJuIHRoaXMuX3JvdC5fbmV4dC5pbnZSb3QoKX10b1N0cmluZygpe2NvbnN0IHQ9dGhpcy5fdmVydGV4LmdldENvb3JkaW5hdGUoKSxlPXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKHQsZSl9aXNMaXZlKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb3R9Z2V0UHJpbWFyeSgpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk8PTA/dGhpczp0aGlzLnN5bSgpfWRQcmV2KCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5pbnZSb3QoKX1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH19Y2xhc3Mga297Y29uc3RydWN0b3IoKXtrby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9pc1VzaW5nVG9sZXJhbmNlPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmRpdj10LHRoaXMuX2lzVXNpbmdUb2xlcmFuY2U9dC5nZXRUb2xlcmFuY2UoKT4wfWluc2VydFNpdGUodCl7bGV0IGU9dGhpcy5fc3ViZGl2LmxvY2F0ZSh0KTtpZih0aGlzLl9zdWJkaXYuaXNWZXJ0ZXhPZkVkZ2UoZSx0KSlyZXR1cm4gZTt0aGlzLl9zdWJkaXYuaXNPbkVkZ2UoZSx0LmdldENvb3JkaW5hdGUoKSkmJihlPWUub1ByZXYoKSx0aGlzLl9zdWJkaXYuZGVsZXRlKGUub05leHQoKSkpO2xldCBuPXRoaXMuX3N1YmRpdi5tYWtlRWRnZShlLm9yaWcoKSx0KTtYby5zcGxpY2UobixlKTtjb25zdCBzPW47ZG97bj10aGlzLl9zdWJkaXYuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpfXdoaWxlKGUubE5leHQoKSE9PXMpO2Zvcig7Oyl7Y29uc3QgaT1lLm9QcmV2KCk7aWYoaS5kZXN0KCkucmlnaHRPZihlKSYmdC5pc0luQ2lyY2xlKGUub3JpZygpLGkuZGVzdCgpLGUuZGVzdCgpKSlYby5zd2FwKGUpLGU9ZS5vUHJldigpO2Vsc2V7aWYoZS5vTmV4dCgpPT09cylyZXR1cm4gbjtlPWUub05leHQoKS5sUHJldigpfX19aW5zZXJ0U2l0ZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKHQpfX19Y2xhc3MgVW97bG9jYXRlKHQpe319Y2xhc3MgSG97Y29uc3RydWN0b3IoKXtIby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9sYXN0RWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmRpdj10LHRoaXMuaW5pdCgpfWluaXQoKXt0aGlzLl9sYXN0RWRnZT10aGlzLmZpbmRFZGdlKCl9bG9jYXRlKHQpe3RoaXMuX2xhc3RFZGdlLmlzTGl2ZSgpfHx0aGlzLmluaXQoKTtjb25zdCBlPXRoaXMuX3N1YmRpdi5sb2NhdGVGcm9tRWRnZSh0LHRoaXMuX2xhc3RFZGdlKTtyZXR1cm4gdGhpcy5fbGFzdEVkZ2U9ZSxlfWZpbmRFZGdlKCl7cmV0dXJuIHRoaXMuX3N1YmRpdi5nZXRFZGdlcygpLml0ZXJhdG9yKCkubmV4dCgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltVb119fWNsYXNzIFdvIGV4dGVuZHMgaHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksV28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc2VnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyxcIkxvY2F0ZSBmYWlsZWQgdG8gY29udmVyZ2UgKGF0IGVkZ2U6IFwiK3QrXCIpLiAgUG9zc2libGUgY2F1c2VzIGluY2x1ZGUgaW52YWxpZCBTdWJkaXZpc2lvbiB0b3BvbG9neSBvciB2ZXJ5IGNsb3NlIHNpdGVzXCIpLHRoaXMuX3NlZz1uZXcgS3QodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyxXby5tc2dXaXRoU3BhdGlhbCh0LGUpKSx0aGlzLl9zZWc9bmV3IEt0KGUpfX1zdGF0aWMgbXNnV2l0aFNwYXRpYWwodCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9Z2V0U2VnbWVudCgpe3JldHVybiB0aGlzLl9zZWd9fWNsYXNzIFpve3Zpc2l0KHQpe319Y2xhc3Mgam97Y29uc3RydWN0b3IoKXtqby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl92aXNpdGVkS2V5PTAsdGhpcy5fcXVhZEVkZ2VzPW5ldyBMLHRoaXMuX3N0YXJ0aW5nRWRnZT1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsLHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2ZyYW1lVmVydGV4PW5ldyBBcnJheSgzKS5maWxsKG51bGwpLHRoaXMuX2ZyYW1lRW52PW51bGwsdGhpcy5fbG9jYXRvcj1udWxsLHRoaXMuX3NlZz1uZXcgS3QsdGhpcy5fdHJpRWRnZXM9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdG9sZXJhbmNlPWUsdGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPWUvam8uRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SLHRoaXMuY3JlYXRlRnJhbWUodCksdGhpcy5fc3RhcnRpbmdFZGdlPXRoaXMuaW5pdFN1YmRpdigpLHRoaXMuX2xvY2F0b3I9bmV3IEhvKHRoaXMpfXN0YXRpYyBnZXRUcmlhbmdsZUVkZ2VzKHQsZSl7aWYoZVswXT10LGVbMV09ZVswXS5sTmV4dCgpLGVbMl09ZVsxXS5sTmV4dCgpLGVbMl0ubE5leHQoKSE9PWVbMF0pdGhyb3cgbmV3IHMoXCJFZGdlcyBkbyBub3QgZm9ybSBhIHRyaWFuZ2xlXCIpfWdldFRyaWFuZ2xlVmVydGljZXModCl7Y29uc3QgZT1uZXcgSm87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlVmVydGljZXMoKX1pc0ZyYW1lVmVydGV4KHQpe3JldHVybiEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMF0pfHwoISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFsxXSl8fCEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMl0pKX1pc1ZlcnRleE9mRWRnZSh0LGUpe3JldHVybiEoIWUuZXF1YWxzKHQub3JpZygpLHRoaXMuX3RvbGVyYW5jZSkmJiFlLmVxdWFscyh0LmRlc3QoKSx0aGlzLl90b2xlcmFuY2UpKX1jb25uZWN0KHQsZSl7Y29uc3Qgbj1Yby5jb25uZWN0KHQsZSk7cmV0dXJuIHRoaXMuX3F1YWRFZGdlcy5hZGQobiksbn1nZXRWb3Jvbm9pQ2VsbFBvbHlnb24odCxlKXtjb25zdCBuPW5ldyBMLHM9dDtkb3tjb25zdCBlPXQucm90KCkub3JpZygpLmdldENvb3JkaW5hdGUoKTtuLmFkZChlKSx0PXQub1ByZXYoKX13aGlsZSh0IT09cyk7Y29uc3QgaT1uZXcgUjtpLmFkZEFsbChuLCExKSxpLmNsb3NlUmluZygpLGkuc2l6ZSgpPDQmJihZLm91dC5wcmludGxuKGkpLGkuYWRkKGkuZ2V0KGkuc2l6ZSgpLTEpLCEwKSk7Y29uc3Qgcj1pLnRvQ29vcmRpbmF0ZUFycmF5KCksbz1lLmNyZWF0ZVBvbHlnb24oZS5jcmVhdGVMaW5lYXJSaW5nKHIpKSxsPXMub3JpZygpO3JldHVybiBvLnNldFVzZXJEYXRhKGwuZ2V0Q29vcmRpbmF0ZSgpKSxvfXNldExvY2F0b3IodCl7dGhpcy5fbG9jYXRvcj10fWluaXRTdWJkaXYoKXtjb25zdCB0PXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMF0sdGhpcy5fZnJhbWVWZXJ0ZXhbMV0pLGU9dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFsxXSx0aGlzLl9mcmFtZVZlcnRleFsyXSk7WG8uc3BsaWNlKHQuc3ltKCksZSk7Y29uc3Qgbj10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzJdLHRoaXMuX2ZyYW1lVmVydGV4WzBdKTtyZXR1cm4gWG8uc3BsaWNlKGUuc3ltKCksbiksWG8uc3BsaWNlKG4uc3ltKCksdCksdH1pc0ZyYW1lQm9yZGVyRWRnZSh0KXtjb25zdCBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2pvLmdldFRyaWFuZ2xlRWRnZXModCxlKTtjb25zdCBuPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2pvLmdldFRyaWFuZ2xlRWRnZXModC5zeW0oKSxuKTtjb25zdCBzPXQubE5leHQoKS5kZXN0KCk7aWYodGhpcy5pc0ZyYW1lVmVydGV4KHMpKXJldHVybiEwO2NvbnN0IGk9dC5zeW0oKS5sTmV4dCgpLmRlc3QoKTtyZXR1cm4hIXRoaXMuaXNGcmFtZVZlcnRleChpKX1tYWtlRWRnZSh0LGUpe2NvbnN0IG49WG8ubWFrZUVkZ2UodCxlKTtyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzLmFkZChuKSxufXZpc2l0VHJpYW5nbGVzKHQsZSl7dGhpcy5fdmlzaXRlZEtleSsrO2NvbnN0IG49bmV3IGVuO24ucHVzaCh0aGlzLl9zdGFydGluZ0VkZ2UpO2NvbnN0IHM9bmV3IEV0O2Zvcig7IW4uZW1wdHkoKTspe2NvbnN0IGk9bi5wb3AoKTtpZighcy5jb250YWlucyhpKSl7Y29uc3Qgcj10aGlzLmZldGNoVHJpYW5nbGVUb1Zpc2l0KGksbixlLHMpO251bGwhPT1yJiZ0LnZpc2l0KHIpfX19aXNGcmFtZUVkZ2UodCl7cmV0dXJuISghdGhpcy5pc0ZyYW1lVmVydGV4KHQub3JpZygpKSYmIXRoaXMuaXNGcmFtZVZlcnRleCh0LmRlc3QoKSkpfWlzT25FZGdlKHQsZSl7dGhpcy5fc2VnLnNldENvb3JkaW5hdGVzKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSx0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpO3JldHVybiB0aGlzLl9zZWcuZGlzdGFuY2UoZSk8dGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlfWdldEVudmVsb3BlKCl7cmV0dXJuIG5ldyBPKHRoaXMuX2ZyYW1lRW52KX1jcmVhdGVGcmFtZSh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCk7bGV0IHM9MDtzPWU+bj8xMCplOjEwKm4sdGhpcy5fZnJhbWVWZXJ0ZXhbMF09bmV3IFZvKCh0LmdldE1heFgoKSt0LmdldE1pblgoKSkvMix0LmdldE1heFkoKStzKSx0aGlzLl9mcmFtZVZlcnRleFsxXT1uZXcgVm8odC5nZXRNaW5YKCktcyx0LmdldE1pblkoKS1zKSx0aGlzLl9mcmFtZVZlcnRleFsyXT1uZXcgVm8odC5nZXRNYXhYKCkrcyx0LmdldE1pblkoKS1zKSx0aGlzLl9mcmFtZUVudj1uZXcgTyh0aGlzLl9mcmFtZVZlcnRleFswXS5nZXRDb29yZGluYXRlKCksdGhpcy5fZnJhbWVWZXJ0ZXhbMV0uZ2V0Q29vcmRpbmF0ZSgpKSx0aGlzLl9mcmFtZUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5fZnJhbWVWZXJ0ZXhbMl0uZ2V0Q29vcmRpbmF0ZSgpKX1nZXRUcmlhbmdsZUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3ICRvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZXMoKX1nZXRWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBFdDtmb3IobGV0IG49dGhpcy5fcXVhZEVkZ2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5vcmlnKCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChpKXx8ZS5hZGQoaSk7Y29uc3Qgcj1zLmRlc3QoKTshdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHIpfHxlLmFkZChyKX1yZXR1cm4gZX1mZXRjaFRyaWFuZ2xlVG9WaXNpdCh0LGUsbixzKXtsZXQgaT10LHI9MCxvPSExO2Rve3RoaXMuX3RyaUVkZ2VzW3JdPWksdGhpcy5pc0ZyYW1lRWRnZShpKSYmKG89ITApO2NvbnN0IHQ9aS5zeW0oKTtzLmNvbnRhaW5zKHQpfHxlLnB1c2godCkscy5hZGQoaSkscisrLGk9aS5sTmV4dCgpfXdoaWxlKGkhPT10KTtyZXR1cm4gbyYmIW4/bnVsbDp0aGlzLl90cmlFZGdlc31nZXRFZGdlcygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9xdWFkRWRnZXM7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5nZXRQcmltYXJ5RWRnZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBzPTA7Zm9yKGxldCBpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IGU9aS5uZXh0KCk7bltzKytdPXQuY3JlYXRlTGluZVN0cmluZyhbZS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGUuZGVzdCgpLmdldENvb3JkaW5hdGUoKV0pfXJldHVybiB0LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuKX19Z2V0VmVydGV4VW5pcXVlRWRnZXModCl7Y29uc3QgZT1uZXcgTCxuPW5ldyBFdDtmb3IobGV0IHM9dGhpcy5fcXVhZEVkZ2VzLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpLHI9aS5vcmlnKCk7bi5jb250YWlucyhyKXx8KG4uYWRkKHIpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKGkpKTtjb25zdCBvPWkuc3ltKCksbD1vLm9yaWcoKTtuLmNvbnRhaW5zKGwpfHwobi5hZGQobCksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChsKXx8ZS5hZGQobykpfXJldHVybiBlfWdldFRyaWFuZ2xlRWRnZXModCl7Y29uc3QgZT1uZXcgUW87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlRWRnZXMoKX1nZXRQcmltYXJ5RWRnZXModCl7dGhpcy5fdmlzaXRlZEtleSsrO2NvbnN0IGU9bmV3IEwsbj1uZXcgZW47bi5wdXNoKHRoaXMuX3N0YXJ0aW5nRWRnZSk7Y29uc3Qgcz1uZXcgRXQ7Zm9yKDshbi5lbXB0eSgpOyl7Y29uc3QgaT1uLnBvcCgpO2lmKCFzLmNvbnRhaW5zKGkpKXtjb25zdCByPWkuZ2V0UHJpbWFyeSgpOyF0JiZ0aGlzLmlzRnJhbWVFZGdlKHIpfHxlLmFkZChyKSxuLnB1c2goaS5vTmV4dCgpKSxuLnB1c2goaS5zeW0oKS5vTmV4dCgpKSxzLmFkZChpKSxzLmFkZChpLnN5bSgpKX19cmV0dXJuIGV9ZGVsZXRlKHQpe1hvLnNwbGljZSh0LHQub1ByZXYoKSksWG8uc3BsaWNlKHQuc3ltKCksdC5zeW0oKS5vUHJldigpKTtjb25zdCBlPXQuc3ltKCksbj10LnJvdCgpLHM9dC5yb3QoKS5zeW0oKTt0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKHQpLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUoZSksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShuKSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKHMpLHQuZGVsZXRlKCksZS5kZWxldGUoKSxuLmRlbGV0ZSgpLHMuZGVsZXRlKCl9bG9jYXRlRnJvbUVkZ2UodCxlKXtsZXQgbj0wO2NvbnN0IHM9dGhpcy5fcXVhZEVkZ2VzLnNpemUoKTtsZXQgaT1lO2Zvcig7Oyl7aWYobisrLG4+cyl0aHJvdyBuZXcgV28oaS50b0xpbmVTZWdtZW50KCkpO2lmKHQuZXF1YWxzKGkub3JpZygpKXx8dC5lcXVhbHMoaS5kZXN0KCkpKWJyZWFrO2lmKHQucmlnaHRPZihpKSlpPWkuc3ltKCk7ZWxzZSBpZih0LnJpZ2h0T2YoaS5vTmV4dCgpKSl7aWYodC5yaWdodE9mKGkuZFByZXYoKSkpYnJlYWs7aT1pLmRQcmV2KCl9ZWxzZSBpPWkub05leHQoKX1yZXR1cm4gaX1nZXRUb2xlcmFuY2UoKXtyZXR1cm4gdGhpcy5fdG9sZXJhbmNlfWdldFZvcm9ub2lDZWxsUG9seWdvbnModCl7dGhpcy52aXNpdFRyaWFuZ2xlcyhuZXcgS28sITApO2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXRoaXMuZ2V0VmVydGV4VW5pcXVlRWRnZXMoITEpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2UuYWRkKHRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29uKHMsdCkpfXJldHVybiBlfWdldFZvcm9ub2lEaWFncmFtKHQpe2NvbnN0IGU9dGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb25zKHQpO3JldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihMdC50b0dlb21ldHJ5QXJyYXkoZSkpfWdldFRyaWFuZ2xlcyh0KXtjb25zdCBlPXRoaXMuZ2V0VHJpYW5nbGVDb29yZGluYXRlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7bGV0IHM9MDtmb3IobGV0IGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgZT1pLm5leHQoKTtuW3MrK109dC5jcmVhdGVQb2x5Z29uKHQuY3JlYXRlTGluZWFyUmluZyhlKSl9cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfWluc2VydFNpdGUodCl7bGV0IGU9dGhpcy5sb2NhdGUodCk7aWYodC5lcXVhbHMoZS5vcmlnKCksdGhpcy5fdG9sZXJhbmNlKXx8dC5lcXVhbHMoZS5kZXN0KCksdGhpcy5fdG9sZXJhbmNlKSlyZXR1cm4gZTtsZXQgbj10aGlzLm1ha2VFZGdlKGUub3JpZygpLHQpO1hvLnNwbGljZShuLGUpO2NvbnN0IHM9bjtkb3tuPXRoaXMuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpfXdoaWxlKGUubE5leHQoKSE9PXMpO3JldHVybiBzfWxvY2F0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFZvKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbG9jYXRvci5sb2NhdGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbG9jYXRvci5sb2NhdGUobmV3IFZvKHQpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9sb2NhdG9yLmxvY2F0ZShuZXcgVm8odCkpO2lmKG51bGw9PT1uKXJldHVybiBudWxsO2xldCBzPW47bi5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQpJiYocz1uLnN5bSgpKTtsZXQgaT1zO2Rve2lmKGkuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRChlKSlyZXR1cm4gaTtpPWkub05leHQoKX13aGlsZShpIT09cyk7cmV0dXJuIG51bGx9fX1jbGFzcyBLb3t2aXNpdCh0KXtjb25zdCBlPXRbMF0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxuPXRbMV0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxzPXRbMl0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxpPW5lLmNpcmN1bWNlbnRyZUREKGUsbixzKSxyPW5ldyBWbyhpKTtmb3IobGV0IGU9MDtlPDM7ZSsrKXRbZV0ucm90KCkuc2V0T3JpZyhyKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bWm9dfX1jbGFzcyBRb3tjb25zdHJ1Y3Rvcigpe1FvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3RyaUxpc3Q9bmV3IEx9Z2V0VHJpYW5nbGVFZGdlcygpe3JldHVybiB0aGlzLl90cmlMaXN0fXZpc2l0KHQpe3RoaXMuX3RyaUxpc3QuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltab119fWNsYXNzIEpve2NvbnN0cnVjdG9yKCl7Sm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdHJpTGlzdD1uZXcgTH12aXNpdCh0KXt0aGlzLl90cmlMaXN0LmFkZChbdFswXS5vcmlnKCksdFsxXS5vcmlnKCksdFsyXS5vcmlnKCldKX1nZXRUcmlhbmdsZVZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX3RyaUxpc3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1pvXX19Y2xhc3MgJG97Y29uc3RydWN0b3IoKXskby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZExpc3Q9bmV3IFIsdGhpcy5fdHJpQ29vcmRzPW5ldyBMfWNoZWNrVHJpYW5nbGVTaXplKHQpe3QubGVuZ3RoPj0yP1d0LnRvTGluZVN0cmluZyh0WzBdLHRbMV0pOnQubGVuZ3RoPj0xJiZXdC50b1BvaW50KHRbMF0pfXZpc2l0KHQpe3RoaXMuX2Nvb3JkTGlzdC5jbGVhcigpO2ZvcihsZXQgZT0wO2U8MztlKyspe2NvbnN0IG49dFtlXS5vcmlnKCk7dGhpcy5fY29vcmRMaXN0LmFkZChuLmdldENvb3JkaW5hdGUoKSl9aWYodGhpcy5fY29vcmRMaXN0LnNpemUoKT4wKXt0aGlzLl9jb29yZExpc3QuY2xvc2VSaW5nKCk7Y29uc3QgdD10aGlzLl9jb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtpZig0IT09dC5sZW5ndGgpcmV0dXJuIG51bGw7dGhpcy5fdHJpQ29vcmRzLmFkZCh0KX19Z2V0VHJpYW5nbGVzKCl7cmV0dXJuIHRoaXMuX3RyaUNvb3Jkc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bWm9dfX1qby5UcmlhbmdsZUNpcmN1bWNlbnRyZVZpc2l0b3I9S28sam8uVHJpYW5nbGVFZGdlc0xpc3RWaXNpdG9yPVFvLGpvLlRyaWFuZ2xlVmVydGV4TGlzdFZpc2l0b3I9Sm8sam8uVHJpYW5nbGVDb29yZGluYXRlc1Zpc2l0b3I9JG8sam8uRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SPTFlMztjbGFzcyB0bHtjb25zdHJ1Y3Rvcigpe3RsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xzPW51bGwsdGhpcy5fZGF0YT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9scz1uZXcgS3QodCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9scz1uZXcgS3QodCxlKSx0aGlzLl9kYXRhPW59ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07dGwuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSh0LGUsbiksbmV3IG0ocyxpLHIpKX1lbHNlIGlmKDc9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XSxvPWFyZ3VtZW50c1s2XTt0bC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBtKHQsZSxuKSxuZXcgbShzLGksciksbyl9fWdldExpbmVTZWdtZW50KCl7cmV0dXJuIHRoaXMuX2xzfWdldEVuZFooKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKS5nZXRaKCl9Z2V0U3RhcnRaKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkuZ2V0WigpfWludGVyc2VjdGlvbih0KXtyZXR1cm4gdGhpcy5fbHMuaW50ZXJzZWN0aW9uKHQuZ2V0TGluZVNlZ21lbnQoKSl9Z2V0U3RhcnQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKX1nZXRFbmQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKX1nZXRFbmRZKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueX1nZXRTdGFydFgoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS54fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMuX2xzLmVxdWFsc1RvcG8odC5nZXRMaW5lU2VnbWVudCgpKX1nZXRTdGFydFkoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS55fXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1nZXRFbmRYKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueH10b1N0cmluZygpe3JldHVybiB0aGlzLl9scy50b1N0cmluZygpfX1jbGFzcyBlbCBleHRlbmRzIGh7Y29uc3RydWN0b3IoKXtzdXBlcigpLGVsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3B0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZWwubXNnV2l0aENvb3JkKHQsZSkpLHRoaXMuX3B0PW5ldyBtKGUpfX1zdGF0aWMgbXNnV2l0aENvb3JkKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitXdC50b1BvaW50KGUpK1wiIF1cIjp0fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9fWNsYXNzIG5se2NvbnN0cnVjdG9yKCl7bmwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5pdGlhbFZlcnRpY2VzPW51bGwsdGhpcy5fc2VnVmVydGljZXM9bnVsbCx0aGlzLl9zZWdtZW50cz1uZXcgTCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9pbmNEZWw9bnVsbCx0aGlzLl9jb252ZXhIdWxsPW51bGwsdGhpcy5fc3BsaXRGaW5kZXI9bmV3IEJvLHRoaXMuX2tkdD1udWxsLHRoaXMuX3ZlcnRleEZhY3Rvcnk9bnVsbCx0aGlzLl9jb21wdXRlQXJlYUVudj1udWxsLHRoaXMuX3NwbGl0UHQ9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbml0aWFsVmVydGljZXM9bmV3IEwodCksdGhpcy5fdG9sZXJhbmNlPWUsdGhpcy5fa2R0PW5ldyBncyhlKX1zdGF0aWMgY29tcHV0ZVZlcnRleEVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE87Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUodC5nZXRDb29yZGluYXRlKCkpfXJldHVybiBlfWdldEluaXRpYWxWZXJ0aWNlcygpe3JldHVybiB0aGlzLl9pbml0aWFsVmVydGljZXN9Z2V0S0RUKCl7cmV0dXJuIHRoaXMuX2tkdH1lbmZvcmNlQ29uc3RyYWludHMoKXt0aGlzLmFkZENvbnN0cmFpbnRWZXJ0aWNlcygpO2xldCB0PTAsZT0wO2Rve2U9dGhpcy5lbmZvcmNlR2FicmllbCh0aGlzLl9zZWdtZW50cyksdCsrfXdoaWxlKGU+MCYmdDxubC5NQVhfU1BMSVRfSVRFUik7aWYodD09PW5sLk1BWF9TUExJVF9JVEVSKXRocm93IG5ldyBlbChcIlRvbyBtYW55IHNwbGl0dGluZyBpdGVyYXRpb25zIHdoaWxlIGVuZm9yY2luZyBjb25zdHJhaW50cy4gIExhc3Qgc3BsaXQgcG9pbnQgd2FzIGF0OiBcIix0aGlzLl9zcGxpdFB0KX1pbnNlcnRTaXRlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUodCl9fWdldFZlcnRleEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fdmVydGV4RmFjdG9yeX1nZXRQb2ludEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5faW5pdGlhbFZlcnRpY2VzLnNpemUoKSt0aGlzLl9zZWdWZXJ0aWNlcy5zaXplKCkpLmZpbGwobnVsbCk7bGV0IGU9MDtmb3IobGV0IG49dGhpcy5faW5pdGlhbFZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3RbZSsrXT1zLmdldENvb3JkaW5hdGUoKX1mb3IobGV0IG49dGhpcy5fc2VnVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7dFtlKytdPXMuZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiB0fXNldENvbnN0cmFpbnRzKHQsZSl7dGhpcy5fc2VnbWVudHM9dCx0aGlzLl9zZWdWZXJ0aWNlcz1lfWNvbXB1dGVDb252ZXhIdWxsKCl7Y29uc3QgdD1uZXcgTHQsZT10aGlzLmdldFBvaW50QXJyYXkoKSxuPW5ldyBzbihlLHQpO3RoaXMuX2NvbnZleEh1bGw9bi5nZXRDb252ZXhIdWxsKCl9YWRkQ29uc3RyYWludFZlcnRpY2VzKCl7dGhpcy5jb21wdXRlQ29udmV4SHVsbCgpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5fc2VnVmVydGljZXMpfWZpbmROb25HYWJyaWVsUG9pbnQodCl7Y29uc3QgZT10LmdldFN0YXJ0KCksbj10LmdldEVuZCgpLHM9bmV3IG0oKGUueCtuLngpLzIsKGUueStuLnkpLzIpLGk9ZS5kaXN0YW5jZShzKSxvPW5ldyBPKHMpO28uZXhwYW5kQnkoaSk7Y29uc3QgbD10aGlzLl9rZHQucXVlcnkobyk7bGV0IGE9bnVsbCxjPXIuTUFYX1ZBTFVFO2ZvcihsZXQgdD1sLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCByPXQubmV4dCgpLmdldENvb3JkaW5hdGUoKTtpZihyLmVxdWFsczJEKGUpfHxyLmVxdWFsczJEKG4pKWNvbnRpbnVlO2NvbnN0IG89cy5kaXN0YW5jZShyKTtpZihvPGkpe2NvbnN0IHQ9bzsobnVsbD09PWF8fHQ8YykmJihhPXIsYz10KX19cmV0dXJuIGF9Z2V0Q29uc3RyYWludFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRzfXNldFNwbGl0UG9pbnRGaW5kZXIodCl7dGhpcy5fc3BsaXRGaW5kZXI9dH1nZXRDb252ZXhIdWxsKCl7cmV0dXJuIHRoaXMuX2NvbnZleEh1bGx9Z2V0VG9sZXJhbmNlKCl7cmV0dXJuIHRoaXMuX3RvbGVyYW5jZX1lbmZvcmNlR2FicmllbCh0KXtjb25zdCBlPW5ldyBMO2xldCBuPTA7Y29uc3Qgcz1uZXcgTDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPXRoaXMuZmluZE5vbkdhYnJpZWxQb2ludCh0KTtpZihudWxsPT09ciljb250aW51ZTt0aGlzLl9zcGxpdFB0PXRoaXMuX3NwbGl0RmluZGVyLmZpbmRTcGxpdFBvaW50KHQscik7Y29uc3Qgbz10aGlzLmNyZWF0ZVZlcnRleCh0aGlzLl9zcGxpdFB0LHQpO3RoaXMuaW5zZXJ0U2l0ZShvKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodGhpcy5fc3BsaXRQdCk7Y29uc3QgbD1uZXcgdGwodC5nZXRTdGFydFgoKSx0LmdldFN0YXJ0WSgpLHQuZ2V0U3RhcnRaKCksby5nZXRYKCksby5nZXRZKCksby5nZXRaKCksdC5nZXREYXRhKCkpLGE9bmV3IHRsKG8uZ2V0WCgpLG8uZ2V0WSgpLG8uZ2V0WigpLHQuZ2V0RW5kWCgpLHQuZ2V0RW5kWSgpLHQuZ2V0RW5kWigpLHQuZ2V0RGF0YSgpKTtlLmFkZChsKSxlLmFkZChhKSxzLmFkZCh0KSxuKz0xfXJldHVybiB0LnJlbW92ZUFsbChzKSx0LmFkZEFsbChlKSxufWNyZWF0ZVZlcnRleCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLl92ZXJ0ZXhGYWN0b3J5P3RoaXMuX3ZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsbnVsbCk6bmV3IHpvKHQpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGw7cmV0dXJuIG49bnVsbCE9PXRoaXMuX3ZlcnRleEZhY3Rvcnk/dGhpcy5fdmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxlKTpuZXcgem8odCksbi5zZXRPbkNvbnN0cmFpbnQoITApLG59fWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuX3N1YmRpdn1jb21wdXRlQm91bmRpbmdCb3goKXtjb25zdCB0PW5sLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLl9pbml0aWFsVmVydGljZXMpLGU9bmwuY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuX3NlZ1ZlcnRpY2VzKSxuPW5ldyBPKHQpO24uZXhwYW5kVG9JbmNsdWRlKGUpO2NvbnN0IHM9LjIqbi5nZXRXaWR0aCgpLGk9LjIqbi5nZXRIZWlnaHQoKSxyPU1hdGgubWF4KHMsaSk7dGhpcy5fY29tcHV0ZUFyZWFFbnY9bmV3IE8obiksdGhpcy5fY29tcHV0ZUFyZWFFbnYuZXhwYW5kQnkocil9c2V0VmVydGV4RmFjdG9yeSh0KXt0aGlzLl92ZXJ0ZXhGYWN0b3J5PXR9Zm9ybUluaXRpYWxEZWxhdW5heSgpe3RoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5fc3ViZGl2PW5ldyBqbyh0aGlzLl9jb21wdXRlQXJlYUVudix0aGlzLl90b2xlcmFuY2UpLHRoaXMuX3N1YmRpdi5zZXRMb2NhdG9yKG5ldyBIbyh0aGlzLl9zdWJkaXYpKSx0aGlzLl9pbmNEZWw9bmV3IGtvKHRoaXMuX3N1YmRpdiksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLl9pbml0aWFsVmVydGljZXMpfWluc2VydFNpdGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHpvKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX2tkdC5pbnNlcnQodC5nZXRDb29yZGluYXRlKCksdCk7aWYoZS5pc1JlcGVhdGVkKCkpe2NvbnN0IG49ZS5nZXREYXRhKCk7cmV0dXJuIG4ubWVyZ2UodCksbn1yZXR1cm4gdGhpcy5faW5jRGVsLmluc2VydFNpdGUodCksdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0U2l0ZSh0aGlzLmNyZWF0ZVZlcnRleCh0KSl9fX1ubC5NQVhfU1BMSVRfSVRFUj05OTtjbGFzcyBzbHtjb25zdHJ1Y3Rvcigpe3NsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbH1zdGF0aWMgZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpe2lmKG51bGw9PT10KXJldHVybiBuZXcgUjtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gc2wudW5pcXVlKGUpfXN0YXRpYyBlbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBPO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKHQpfXJldHVybiBlfXN0YXRpYyB1bmlxdWUodCl7Y29uc3QgZT1fdC5jb3B5RGVlcCh0KTtzdC5zb3J0KGUpO3JldHVybiBuZXcgUihlLCExKX1zdGF0aWMgdG9WZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBWbyh0KSl9cmV0dXJuIGV9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PXNsLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpLGU9c2wudG9WZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9zdWJkaXY9bmV3IGpvKHQsdGhpcy5fdG9sZXJhbmNlKTtuZXcga28odGhpcy5fc3ViZGl2KS5pbnNlcnRTaXRlcyhlKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0U2l0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9c2wuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9c2wudW5pcXVlKF90LnRvQ29vcmRpbmF0ZUFycmF5KHQpKX19Z2V0RWRnZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldEVkZ2VzKHQpfWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldFRyaWFuZ2xlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfX1jbGFzcyBpbHtjb25zdHJ1Y3Rvcigpe2lsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl9jb25zdHJhaW50TGluZXM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwPW5ldyBXbn1zdGF0aWMgY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9eWUuZ2V0TGluZXModCksbj1uZXcgTDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtpbC5jcmVhdGVDb25zdHJhaW50U2VnbWVudHMoZSxuKX1yZXR1cm4gbn1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MTtuPGUubGVuZ3RoO24rKyl0LmFkZChuZXcgdGwoZVtuLTFdLGVbbl0pKX19Y3JlYXRlU2l0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fY29uc3RyYWludFZlcnRleE1hcC5jb250YWluc0tleSh0KXx8ZS5hZGQobmV3IHpvKHQpKX1yZXR1cm4gZX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9c2wuZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3Jkcyk7bGV0IGU9bmV3IEw7bnVsbCE9PXRoaXMuX2NvbnN0cmFpbnRMaW5lcyYmKHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2NvbnN0cmFpbnRMaW5lcy5nZXRFbnZlbG9wZUludGVybmFsKCkpLHRoaXMuY3JlYXRlVmVydGljZXModGhpcy5fY29uc3RyYWludExpbmVzKSxlPWlsLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyh0aGlzLl9jb25zdHJhaW50TGluZXMpKTtjb25zdCBuPXRoaXMuY3JlYXRlU2l0ZVZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpLHM9bmV3IG5sKG4sdGhpcy5fdG9sZXJhbmNlKTtzLnNldENvbnN0cmFpbnRzKGUsbmV3IEwodGhpcy5fY29uc3RyYWludFZlcnRleE1hcC52YWx1ZXMoKSkpLHMuZm9ybUluaXRpYWxEZWxhdW5heSgpLHMuZW5mb3JjZUNvbnN0cmFpbnRzKCksdGhpcy5fc3ViZGl2PXMuZ2V0U3ViZGl2aXNpb24oKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0Q29uc3RyYWludHModCl7dGhpcy5fY29uc3RyYWludExpbmVzPXR9c2V0U2l0ZXModCl7dGhpcy5fc2l0ZUNvb3Jkcz1zbC5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9Z2V0RWRnZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldEVkZ2VzKHQpfWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldFRyaWFuZ2xlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfWNyZWF0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBuPW5ldyB6byhlW3RdKTt0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLnB1dChlW3RdLG4pfX19Y2xhc3Mgcmx7Y29uc3RydWN0b3IoKXtybC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fY2xpcEVudj1udWxsLHRoaXMuX2RpYWdyYW1FbnY9bnVsbH1zdGF0aWMgY2xpcEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49dC5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeShlKSxzPW5ldyBMO2ZvcihsZXQgaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtjb25zdCByPXQuZ2V0R2VvbWV0cnlOKGkpO2xldCBvPW51bGw7ZS5jb250YWlucyhyLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/bz1yOmUuaW50ZXJzZWN0cyhyLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJihvPXdyLmludGVyc2VjdGlvbihuLHIpLG8uc2V0VXNlckRhdGEoci5nZXRVc2VyRGF0YSgpKSksbnVsbD09PW98fG8uaXNFbXB0eSgpfHxzLmFkZChvKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEx0LnRvR2VvbWV0cnlBcnJheShzKSl9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PXNsLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpO2lmKHRoaXMuX2RpYWdyYW1FbnY9dGhpcy5fY2xpcEVudixudWxsPT09dGhpcy5fZGlhZ3JhbUVudil7dGhpcy5fZGlhZ3JhbUVudj10O2NvbnN0IGU9dGhpcy5fZGlhZ3JhbUVudi5nZXREaWFtZXRlcigpO3RoaXMuX2RpYWdyYW1FbnYuZXhwYW5kQnkoZSl9Y29uc3QgZT1zbC50b1ZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpO3RoaXMuX3N1YmRpdj1uZXcgam8odCx0aGlzLl90b2xlcmFuY2UpO25ldyBrbyh0aGlzLl9zdWJkaXYpLmluc2VydFNpdGVzKGUpfWdldERpYWdyYW0odCl7dGhpcy5jcmVhdGUoKTtjb25zdCBlPXRoaXMuX3N1YmRpdi5nZXRWb3Jvbm9pRGlhZ3JhbSh0KTtyZXR1cm4gcmwuY2xpcEdlb21ldHJ5Q29sbGVjdGlvbihlLHRoaXMuX2RpYWdyYW1FbnYpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRTaXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1zbC5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1zbC51bmlxdWUoX3QudG9Db29yZGluYXRlQXJyYXkodCkpfX1zZXRDbGlwRW52ZWxvcGUodCl7dGhpcy5fY2xpcEVudj10fWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fX12YXIgbGw9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVmVydGV4OlZvfSksYWw9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29uZm9ybWluZ0RlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6aWwsRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpzbCxWb3Jvbm9pRGlhZ3JhbUJ1aWxkZXI6cmwscXVhZGVkZ2U6bGx9KTtjbGFzcyBjbHtjb25zdHJ1Y3Rvcigpe2NsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xpbmVhckdlb209bnVsbCx0aGlzLl9udW1MaW5lcz1udWxsLHRoaXMuX2N1cnJlbnRMaW5lPW51bGwsdGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl92ZXJ0ZXhJbmRleD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtjbC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMCwwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtjbC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZS5nZXRDb21wb25lbnRJbmRleCgpLGNsLnNlZ21lbnRFbmRWZXJ0ZXhJbmRleChlKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoIUkodCxaKSl0aHJvdyBuZXcgcyhcIkxpbmVhbCBnZW9tZXRyeSBpcyByZXF1aXJlZFwiKTt0aGlzLl9saW5lYXJHZW9tPXQsdGhpcy5fbnVtTGluZXM9dC5nZXROdW1HZW9tZXRyaWVzKCksdGhpcy5fY29tcG9uZW50SW5kZXg9ZSx0aGlzLl92ZXJ0ZXhJbmRleD1uLHRoaXMubG9hZEN1cnJlbnRMaW5lKCl9fXN0YXRpYyBzZWdtZW50RW5kVmVydGV4SW5kZXgodCl7cmV0dXJuIHQuZ2V0U2VnbWVudEZyYWN0aW9uKCk+MD90LmdldFNlZ21lbnRJbmRleCgpKzE6dC5nZXRTZWdtZW50SW5kZXgoKX1nZXRDb21wb25lbnRJbmRleCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleH1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lfWdldFZlcnRleEluZGV4KCl7cmV0dXJuIHRoaXMuX3ZlcnRleEluZGV4fWdldFNlZ21lbnRFbmQoKXtyZXR1cm4gdGhpcy5fdmVydGV4SW5kZXg8dGhpcy5nZXRMaW5lKCkuZ2V0TnVtUG9pbnRzKCktMT90aGlzLl9jdXJyZW50TGluZS5nZXRDb29yZGluYXRlTih0aGlzLl92ZXJ0ZXhJbmRleCsxKTpudWxsfW5leHQoKXtpZighdGhpcy5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dGhpcy5fdmVydGV4SW5kZXgrKyx0aGlzLl92ZXJ0ZXhJbmRleD49dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCkmJih0aGlzLl9jb21wb25lbnRJbmRleCsrLHRoaXMubG9hZEN1cnJlbnRMaW5lKCksdGhpcy5fdmVydGV4SW5kZXg9MCl9bG9hZEN1cnJlbnRMaW5lKCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKXJldHVybiB0aGlzLl9jdXJyZW50TGluZT1udWxsLG51bGw7dGhpcy5fY3VycmVudExpbmU9dGhpcy5fbGluZWFyR2VvbS5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpfWdldFNlZ21lbnRTdGFydCgpe3JldHVybiB0aGlzLl9jdXJyZW50TGluZS5nZXRDb29yZGluYXRlTih0aGlzLl92ZXJ0ZXhJbmRleCl9aXNFbmRPZkxpbmUoKXtyZXR1cm4hKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcykmJiEodGhpcy5fdmVydGV4SW5kZXg8dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCktMSl9aGFzTmV4dCgpe3JldHVybiEodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKSYmISh0aGlzLl9jb21wb25lbnRJbmRleD09PXRoaXMuX251bUxpbmVzLTEmJnRoaXMuX3ZlcnRleEluZGV4Pj10aGlzLl9jdXJyZW50TGluZS5nZXROdW1Qb2ludHMoKSl9fWNsYXNzIGhse2NvbnN0cnVjdG9yKCl7aGwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgaW5kZXhPZih0LGUpe3JldHVybiBuZXcgaGwodCkuaW5kZXhPZihlKX1zdGF0aWMgaW5kZXhPZkFmdGVyKHQsZSxuKXtyZXR1cm4gbmV3IGhsKHQpLmluZGV4T2ZBZnRlcihlLG4pfWluZGV4T2YodCl7cmV0dXJuIHRoaXMuaW5kZXhPZkZyb21TdGFydCh0LC0xKX1pbmRleE9mRnJvbVN0YXJ0KHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz1lLGk9MDtjb25zdCBvPW5ldyBLdCxsPW5ldyBjbCh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO2wuaGFzTmV4dCgpOyl7aWYoIWwuaXNFbmRPZkxpbmUoKSl7by5wMD1sLmdldFNlZ21lbnRTdGFydCgpLG8ucDE9bC5nZXRTZWdtZW50RW5kKCk7Y29uc3Qgcj1vLmRpc3RhbmNlKHQpLGE9dGhpcy5zZWdtZW50TmVhcmVzdE1lYXN1cmUobyx0LGkpO3I8biYmYT5lJiYocz1hLG49ciksaSs9by5nZXRMZW5ndGgoKX1sLm5leHQoKX1yZXR1cm4gc31pbmRleE9mQWZ0ZXIodCxlKXtpZihlPDApcmV0dXJuIHRoaXMuaW5kZXhPZih0KTtjb25zdCBuPXRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCk7aWYobjxlKXJldHVybiBuO2NvbnN0IHM9dGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsZSk7cmV0dXJuIGcuaXNUcnVlKHM+PWUsXCJjb21wdXRlZCBpbmRleCBpcyBiZWZvcmUgc3BlY2lmaWVkIG1pbmltdW0gaW5kZXhcIiksc31zZWdtZW50TmVhcmVzdE1lYXN1cmUodCxlLG4pe2NvbnN0IHM9dC5wcm9qZWN0aW9uRmFjdG9yKGUpO3JldHVybiBzPD0wP246czw9MT9uK3MqdC5nZXRMZW5ndGgoKTpuK3QuZ2V0TGVuZ3RoKCl9fWNsYXNzIHVse2NvbnN0cnVjdG9yKCl7dWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcG9uZW50SW5kZXg9dC5fY29tcG9uZW50SW5kZXgsdGhpcy5fc2VnbWVudEluZGV4PXQuX3NlZ21lbnRJbmRleCx0aGlzLl9zZWdtZW50RnJhY3Rpb249dC5fc2VnbWVudEZyYWN0aW9ufWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3VsLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCx0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQsdGhpcy5fc2VnbWVudEluZGV4PWUsdGhpcy5fc2VnbWVudEZyYWN0aW9uPW4sdGhpcy5ub3JtYWxpemUoKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9jb21wb25lbnRJbmRleD10LHRoaXMuX3NlZ21lbnRJbmRleD1lLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj1uLHMmJnRoaXMubm9ybWFsaXplKCl9fXN0YXRpYyBnZXRFbmRMb2NhdGlvbih0KXtjb25zdCBlPW5ldyB1bDtyZXR1cm4gZS5zZXRUb0VuZCh0KSxlfXN0YXRpYyBwb2ludEFsb25nU2VnbWVudEJ5RnJhY3Rpb24odCxlLG4pe2lmKG48PTApcmV0dXJuIHQ7aWYobj49MSlyZXR1cm4gZTtjb25zdCBzPShlLngtdC54KSpuK3QueCxpPShlLnktdC55KSpuK3QueSxyPShlLmdldFooKS10LmdldFooKSkqbit0LmdldFooKTtyZXR1cm4gbmV3IG0ocyxpLHIpfXN0YXRpYyBjb21wYXJlTG9jYXRpb25WYWx1ZXModCxlLG4scyxpLHIpe3JldHVybiB0PHM/LTE6dD5zPzE6ZTxpPy0xOmU+aT8xOm48cj8tMTpuPnI/MTowfXN0YXRpYyBudW1TZWdtZW50cyh0KXtjb25zdCBlPXQuZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIGU8PTE/MDplLTF9Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleH1nZXRDb21wb25lbnRJbmRleCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleH1pc0VuZHBvaW50KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49dWwubnVtU2VnbWVudHMoZSk7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleD49bnx8dGhpcy5fc2VnbWVudEluZGV4PT09bi0xJiZ0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTF9aXNWYWxpZCh0KXtpZih0aGlzLl9jb21wb25lbnRJbmRleDwwfHx0aGlzLl9jb21wb25lbnRJbmRleD49dC5nZXROdW1HZW9tZXRyaWVzKCkpcmV0dXJuITE7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7cmV0dXJuISh0aGlzLl9zZWdtZW50SW5kZXg8MHx8dGhpcy5fc2VnbWVudEluZGV4PmUuZ2V0TnVtUG9pbnRzKCkpJiYoKHRoaXMuX3NlZ21lbnRJbmRleCE9PWUuZ2V0TnVtUG9pbnRzKCl8fDA9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24pJiYhKHRoaXMuX3NlZ21lbnRGcmFjdGlvbjwwfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+MSkpfW5vcm1hbGl6ZSgpe3RoaXMuX3NlZ21lbnRGcmFjdGlvbjwwJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTApLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj4xJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTEpLHRoaXMuX2NvbXBvbmVudEluZGV4PDAmJih0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSx0aGlzLl9zZWdtZW50SW5kZXg8MCYmKHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSwxPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTAsdGhpcy5fc2VnbWVudEluZGV4Kz0xKX10b0xvd2VzdCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPXVsLm51bVNlZ21lbnRzKGUpO3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXg8bj90aGlzOm5ldyB1bCh0aGlzLl9jb21wb25lbnRJbmRleCxuLTEsMSwhMSl9Z2V0Q29vcmRpbmF0ZSh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KTtpZih0aGlzLl9zZWdtZW50SW5kZXg+PXVsLm51bVNlZ21lbnRzKGUpKXJldHVybiBuO2NvbnN0IHM9ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgrMSk7cmV0dXJuIHVsLnBvaW50QWxvbmdTZWdtZW50QnlGcmFjdGlvbihuLHMsdGhpcy5fc2VnbWVudEZyYWN0aW9uKX1nZXRTZWdtZW50RnJhY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9ufWdldFNlZ21lbnQodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCk7aWYodGhpcy5fc2VnbWVudEluZGV4Pj11bC5udW1TZWdtZW50cyhlKSl7Y29uc3QgdD1lLmdldENvb3JkaW5hdGVOKGUuZ2V0TnVtUG9pbnRzKCktMik7cmV0dXJuIG5ldyBLdCh0LG4pfWNvbnN0IHM9ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgrMSk7cmV0dXJuIG5ldyBLdChuLHMpfWNsYW1wKHQpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10LmdldE51bUdlb21ldHJpZXMoKSlyZXR1cm4gdGhpcy5zZXRUb0VuZCh0KSxudWxsO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49dC5nZXROdW1Qb2ludHMoKSl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7dGhpcy5fc2VnbWVudEluZGV4PXVsLm51bVNlZ21lbnRzKGUpLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xfX1zZXRUb0VuZCh0KXt0aGlzLl9jb21wb25lbnRJbmRleD10LmdldE51bUdlb21ldHJpZXMoKS0xO2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3RoaXMuX3NlZ21lbnRJbmRleD11bC5udW1TZWdtZW50cyhlKSx0aGlzLl9zZWdtZW50RnJhY3Rpb249MH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDxlLl9jb21wb25lbnRJbmRleD8tMTp0aGlzLl9jb21wb25lbnRJbmRleD5lLl9jb21wb25lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRJbmRleDxlLl9zZWdtZW50SW5kZXg/LTE6dGhpcy5fc2VnbWVudEluZGV4PmUuX3NlZ21lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxlLl9zZWdtZW50RnJhY3Rpb24/LTE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPmUuX3NlZ21lbnRGcmFjdGlvbj8xOjB9Y29weSgpe3JldHVybiBuZXcgdWwodGhpcy5fY29tcG9uZW50SW5kZXgsdGhpcy5fc2VnbWVudEluZGV4LHRoaXMuX3NlZ21lbnRGcmFjdGlvbil9dG9TdHJpbmcoKXtyZXR1cm5cIkxpbmVhckxvY1tcIit0aGlzLl9jb21wb25lbnRJbmRleCtcIiwgXCIrdGhpcy5fc2VnbWVudEluZGV4K1wiLCBcIit0aGlzLl9zZWdtZW50RnJhY3Rpb24rXCJdXCJ9aXNPblNhbWVTZWdtZW50KHQpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleD09PXQuX2NvbXBvbmVudEluZGV4JiYodGhpcy5fc2VnbWVudEluZGV4PT09dC5fc2VnbWVudEluZGV4fHwodC5fc2VnbWVudEluZGV4LXRoaXMuX3NlZ21lbnRJbmRleD09MSYmMD09PXQuX3NlZ21lbnRGcmFjdGlvbnx8dGhpcy5fc2VnbWVudEluZGV4LXQuX3NlZ21lbnRJbmRleD09MSYmMD09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbikpfXNuYXBUb1ZlcnRleCh0LGUpe2lmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbjw9MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5nZXRTZWdtZW50TGVuZ3RoKHQpLHM9dGhpcy5fc2VnbWVudEZyYWN0aW9uKm4saT1uLXM7czw9aSYmczxlP3RoaXMuX3NlZ21lbnRGcmFjdGlvbj0wOmk8PXMmJmk8ZSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKX1jb21wYXJlTG9jYXRpb25WYWx1ZXModCxlLG4pe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDx0Py0xOnRoaXMuX2NvbXBvbmVudEluZGV4PnQ/MTp0aGlzLl9zZWdtZW50SW5kZXg8ZT8tMTp0aGlzLl9zZWdtZW50SW5kZXg+ZT8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxuPy0xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbj5uPzE6MH1nZXRTZWdtZW50TGVuZ3RoKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO2xldCBuPXRoaXMuX3NlZ21lbnRJbmRleDt0aGlzLl9zZWdtZW50SW5kZXg+PXVsLm51bVNlZ21lbnRzKGUpJiYobj1lLmdldE51bVBvaW50cygpLTIpO2NvbnN0IHM9ZS5nZXRDb29yZGluYXRlTihuKSxpPWUuZ2V0Q29vcmRpbmF0ZU4obisxKTtyZXR1cm4gcy5kaXN0YW5jZShpKX1pc1ZlcnRleCgpe3JldHVybiB0aGlzLl9zZWdtZW50RnJhY3Rpb248PTB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIGdse2NvbnN0cnVjdG9yKCl7Z2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgaW5kZXhPZih0LGUpe3JldHVybiBuZXcgZ2wodCkuaW5kZXhPZihlKX1zdGF0aWMgaW5kZXhPZkFmdGVyKHQsZSxuKXtyZXR1cm4gbmV3IGdsKHQpLmluZGV4T2ZBZnRlcihlLG4pfWluZGV4T2YodCl7cmV0dXJuIHRoaXMuaW5kZXhPZkZyb21TdGFydCh0LG51bGwpfWluZGV4T2ZGcm9tU3RhcnQodCxlKXtsZXQgbj1yLk1BWF9WQUxVRSxzPTAsaT0wLG89LTE7Y29uc3QgbD1uZXcgS3Q7Zm9yKGxldCByPW5ldyBjbCh0aGlzLl9saW5lYXJHZW9tKTtyLmhhc05leHQoKTtyLm5leHQoKSlpZighci5pc0VuZE9mTGluZSgpKXtsLnAwPXIuZ2V0U2VnbWVudFN0YXJ0KCksbC5wMT1yLmdldFNlZ21lbnRFbmQoKTtjb25zdCBhPWwuZGlzdGFuY2UodCksYz1sLnNlZ21lbnRGcmFjdGlvbih0KSxoPXIuZ2V0Q29tcG9uZW50SW5kZXgoKSx1PXIuZ2V0VmVydGV4SW5kZXgoKTthPG4mJihudWxsPT09ZXx8ZS5jb21wYXJlTG9jYXRpb25WYWx1ZXMoaCx1LGMpPDApJiYocz1oLGk9dSxvPWMsbj1hKX1pZihuPT09ci5NQVhfVkFMVUUpcmV0dXJuIG5ldyB1bChlKTtyZXR1cm4gbmV3IHVsKHMsaSxvKX1pbmRleE9mQWZ0ZXIodCxlKXtpZihudWxsPT09ZSlyZXR1cm4gdGhpcy5pbmRleE9mKHQpO2NvbnN0IG49dWwuZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSk7aWYobi5jb21wYXJlVG8oZSk8PTApcmV0dXJuIG47Y29uc3Qgcz10aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxlKTtyZXR1cm4gZy5pc1RydWUocy5jb21wYXJlVG8oZSk+PTAsXCJjb21wdXRlZCBsb2NhdGlvbiBpcyBiZWZvcmUgc3BlY2lmaWVkIG1pbmltdW0gbG9jYXRpb25cIiksc319Y2xhc3MgZGx7Y29uc3RydWN0b3IoKXtkbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fXN0YXRpYyBpbmRpY2VzT2YodCxlKXtyZXR1cm4gbmV3IGRsKHQpLmluZGljZXNPZihlKX1pbmRpY2VzT2YodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5TigwKS5nZXRDb29yZGluYXRlTigwKSxuPXQuZ2V0R2VvbWV0cnlOKHQuZ2V0TnVtR2VvbWV0cmllcygpLTEpLHM9bi5nZXRDb29yZGluYXRlTihuLmdldE51bVBvaW50cygpLTEpLGk9bmV3IGdsKHRoaXMuX2xpbmVhckdlb20pLHI9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIHJbMF09aS5pbmRleE9mKGUpLDA9PT10LmdldExlbmd0aCgpP3JbMV09clswXS5jb3B5KCk6clsxXT1pLmluZGV4T2ZBZnRlcihzLHJbMF0pLHJ9fWNsYXNzIF9se2NvbnN0cnVjdG9yKCl7X2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgZ2V0TGVuZ3RoKHQsZSl7cmV0dXJuIG5ldyBfbCh0KS5nZXRMZW5ndGgoZSl9c3RhdGljIGdldExvY2F0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgX2woYXJndW1lbnRzWzBdKS5nZXRMb2NhdGlvbih0KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBfbChhcmd1bWVudHNbMF0pLmdldExvY2F0aW9uKHQsZSl9fWdldExlbmd0aCh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IGNsKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bi5oYXNOZXh0KCk7KXtpZighbi5pc0VuZE9mTGluZSgpKXtjb25zdCBzPW4uZ2V0U2VnbWVudFN0YXJ0KCksaT1uLmdldFNlZ21lbnRFbmQoKS5kaXN0YW5jZShzKTtpZih0LmdldENvbXBvbmVudEluZGV4KCk9PT1uLmdldENvbXBvbmVudEluZGV4KCkmJnQuZ2V0U2VnbWVudEluZGV4KCk9PT1uLmdldFZlcnRleEluZGV4KCkpcmV0dXJuIGUraSp0LmdldFNlZ21lbnRGcmFjdGlvbigpO2UrPWl9bi5uZXh0KCl9cmV0dXJuIGV9cmVzb2x2ZUhpZ2hlcih0KXtpZighdC5pc0VuZHBvaW50KHRoaXMuX2xpbmVhckdlb20pKXJldHVybiB0O2xldCBlPXQuZ2V0Q29tcG9uZW50SW5kZXgoKTtpZihlPj10aGlzLl9saW5lYXJHZW9tLmdldE51bUdlb21ldHJpZXMoKS0xKXJldHVybiB0O2Rve2UrK313aGlsZShlPHRoaXMuX2xpbmVhckdlb20uZ2V0TnVtR2VvbWV0cmllcygpLTEmJjA9PT10aGlzLl9saW5lYXJHZW9tLmdldEdlb21ldHJ5TihlKS5nZXRMZW5ndGgoKSk7cmV0dXJuIG5ldyB1bChlLDAsMCl9Z2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24odCwhMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPXQ7aWYodDwwKXtuPXRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCkrdH1jb25zdCBzPXRoaXMuZ2V0TG9jYXRpb25Gb3J3YXJkKG4pO3JldHVybiBlP3M6dGhpcy5yZXNvbHZlSGlnaGVyKHMpfX1nZXRMb2NhdGlvbkZvcndhcmQodCl7aWYodDw9MClyZXR1cm4gbmV3IHVsO2xldCBlPTA7Y29uc3Qgbj1uZXcgY2wodGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtuLmhhc05leHQoKTspe2lmKG4uaXNFbmRPZkxpbmUoKSl7aWYoZT09PXQpe2NvbnN0IHQ9bi5nZXRDb21wb25lbnRJbmRleCgpLGU9bi5nZXRWZXJ0ZXhJbmRleCgpO3JldHVybiBuZXcgdWwodCxlLDApfX1lbHNle2NvbnN0IHM9bi5nZXRTZWdtZW50U3RhcnQoKSxpPW4uZ2V0U2VnbWVudEVuZCgpLmRpc3RhbmNlKHMpO2lmKGUraT50KXtjb25zdCBzPSh0LWUpL2kscj1uLmdldENvbXBvbmVudEluZGV4KCksbz1uLmdldFZlcnRleEluZGV4KCk7cmV0dXJuIG5ldyB1bChyLG8scyl9ZSs9aX1uLm5leHQoKX1yZXR1cm4gdWwuZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSl9fWNsYXNzIHBse2NvbnN0cnVjdG9yKCl7cGwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9saW5lcz1uZXcgTCx0aGlzLl9jb29yZExpc3Q9bnVsbCx0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXM9ITEsdGhpcy5fZml4SW52YWxpZExpbmVzPSExLHRoaXMuX2xhc3RQdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0PXR9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5lbmRMaW5lKCksdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyl9Z2V0TGFzdENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fbGFzdFB0fWVuZExpbmUoKXtpZihudWxsPT09dGhpcy5fY29vcmRMaXN0KXJldHVybiBudWxsO2lmKHRoaXMuX2lnbm9yZUludmFsaWRMaW5lcyYmdGhpcy5fY29vcmRMaXN0LnNpemUoKTwyKXJldHVybiB0aGlzLl9jb29yZExpc3Q9bnVsbCxudWxsO2NvbnN0IHQ9dGhpcy5fY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IGU9dDt0aGlzLl9maXhJbnZhbGlkTGluZXMmJihlPXRoaXMudmFsaWRDb29yZGluYXRlU2VxdWVuY2UodCkpLHRoaXMuX2Nvb3JkTGlzdD1udWxsO2xldCBuPW51bGw7dHJ5e249dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZVN0cmluZyhlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBzKSl0aHJvdyB0O2lmKCF0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXMpdGhyb3cgdH1udWxsIT09biYmdGhpcy5fbGluZXMuYWRkKG4pfXNldEZpeEludmFsaWRMaW5lcyh0KXt0aGlzLl9maXhJbnZhbGlkTGluZXM9dH1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMuX2Nvb3JkTGlzdCYmKHRoaXMuX2Nvb3JkTGlzdD1uZXcgUiksdGhpcy5fY29vcmRMaXN0LmFkZCh0LGUpLHRoaXMuX2xhc3RQdD10fX1zZXRJZ25vcmVJbnZhbGlkTGluZXModCl7dGhpcy5faWdub3JlSW52YWxpZExpbmVzPXR9dmFsaWRDb29yZGluYXRlU2VxdWVuY2UodCl7aWYodC5sZW5ndGg+PTIpcmV0dXJuIHQ7cmV0dXJuW3RbMF0sdFswXV19fWNsYXNzIG1se2NvbnN0cnVjdG9yKCl7bWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH1zdGF0aWMgZXh0cmFjdCh0LGUsbil7cmV0dXJuIG5ldyBtbCh0KS5leHRyYWN0KGUsbil9Y29tcHV0ZUxpbmVhcih0LGUpe2NvbnN0IG49bmV3IHBsKHRoaXMuX2xpbmUuZ2V0RmFjdG9yeSgpKTtuLnNldEZpeEludmFsaWRMaW5lcyghMCksdC5pc1ZlcnRleCgpfHxuLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2ZvcihsZXQgcz1uZXcgY2wodGhpcy5fbGluZSx0KTtzLmhhc05leHQoKSYmIShlLmNvbXBhcmVMb2NhdGlvblZhbHVlcyhzLmdldENvbXBvbmVudEluZGV4KCkscy5nZXRWZXJ0ZXhJbmRleCgpLDApPDApO3MubmV4dCgpKXtjb25zdCB0PXMuZ2V0U2VnbWVudFN0YXJ0KCk7bi5hZGQodCkscy5pc0VuZE9mTGluZSgpJiZuLmVuZExpbmUoKX1yZXR1cm4gZS5pc1ZlcnRleCgpfHxuLmFkZChlLmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpLG4uZ2V0R2VvbWV0cnkoKX1jb21wdXRlTGluZSh0LGUpe2NvbnN0IG49dGhpcy5fbGluZS5nZXRDb29yZGluYXRlcygpLHM9bmV3IFI7bGV0IGk9dC5nZXRTZWdtZW50SW5kZXgoKTt0LmdldFNlZ21lbnRGcmFjdGlvbigpPjAmJihpKz0xKTtsZXQgcj1lLmdldFNlZ21lbnRJbmRleCgpOzE9PT1lLmdldFNlZ21lbnRGcmFjdGlvbigpJiYocis9MSkscj49bi5sZW5ndGgmJihyPW4ubGVuZ3RoLTEpLHQuaXNWZXJ0ZXgoKXx8cy5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtmb3IobGV0IHQ9aTt0PD1yO3QrKylzLmFkZChuW3RdKTtlLmlzVmVydGV4KCl8fHMuYWRkKGUuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSkscy5zaXplKCk8PTAmJnMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7bGV0IG89cy50b0Nvb3JkaW5hdGVBcnJheSgpO3JldHVybiBvLmxlbmd0aDw9MSYmKG89W29bMF0sb1swXV0pLHRoaXMuX2xpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobyl9ZXh0cmFjdCh0LGUpe3JldHVybiBlLmNvbXBhcmVUbyh0KTwwP3RoaXMucmV2ZXJzZSh0aGlzLmNvbXB1dGVMaW5lYXIoZSx0KSk6dGhpcy5jb21wdXRlTGluZWFyKHQsZSl9cmV2ZXJzZSh0KXtyZXR1cm4gSSh0LFopP3QucmV2ZXJzZSgpOihnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwibm9uLWxpbmVhciBnZW9tZXRyeSBlbmNvdW50ZXJlZFwiKSxudWxsKX19Y2xhc3MgZmx7Y29uc3RydWN0b3IoKXtmbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fWNsYW1wSW5kZXgodCl7Y29uc3QgZT10aGlzLnBvc2l0aXZlSW5kZXgodCksbj10aGlzLmdldFN0YXJ0SW5kZXgoKTtpZihlPG4pcmV0dXJuIG47Y29uc3Qgcz10aGlzLmdldEVuZEluZGV4KCk7cmV0dXJuIGU+cz9zOmV9bG9jYXRpb25PZigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gX2wuZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIF9sLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCxlKX19cHJvamVjdCh0KXtyZXR1cm4gaGwuaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfXBvc2l0aXZlSW5kZXgodCl7cmV0dXJuIHQ+PTA/dDp0aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpK3R9ZXh0cmFjdFBvaW50KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBfbC5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQpLmdldENvb3JkaW5hdGUodGhpcy5fbGluZWFyR2VvbSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49X2wuZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KS50b0xvd2VzdCh0aGlzLl9saW5lYXJHZW9tKTtyZXR1cm4gbi5nZXRTZWdtZW50KHRoaXMuX2xpbmVhckdlb20pLnBvaW50QWxvbmdPZmZzZXQobi5nZXRTZWdtZW50RnJhY3Rpb24oKSxlKX19aXNWYWxpZEluZGV4KHQpe3JldHVybiB0Pj10aGlzLmdldFN0YXJ0SW5kZXgoKSYmdDw9dGhpcy5nZXRFbmRJbmRleCgpfWdldEVuZEluZGV4KCl7cmV0dXJuIHRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCl9Z2V0U3RhcnRJbmRleCgpe3JldHVybiAwfWluZGV4T2ZBZnRlcih0LGUpe3JldHVybiBobC5pbmRleE9mQWZ0ZXIodGhpcy5fbGluZWFyR2VvbSx0LGUpfWV4dHJhY3RMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLmNsYW1wSW5kZXgodCkscz10aGlzLmNsYW1wSW5kZXgoZSksaT1uPT09cyxyPXRoaXMubG9jYXRpb25PZihuLGkpLG89dGhpcy5sb2NhdGlvbk9mKHMpO3JldHVybiBtbC5leHRyYWN0KHRoaXMuX2xpbmVhckdlb20scixvKX1pbmRleE9mKHQpe3JldHVybiBobC5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9aW5kaWNlc09mKHQpe2NvbnN0IGU9ZGwuaW5kaWNlc09mKHRoaXMuX2xpbmVhckdlb20sdCk7cmV0dXJuW19sLmdldExlbmd0aCh0aGlzLl9saW5lYXJHZW9tLGVbMF0pLF9sLmdldExlbmd0aCh0aGlzLl9saW5lYXJHZW9tLGVbMV0pXX19Y2xhc3MgeWx7Y29uc3RydWN0b3IoKXt5bC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10LHRoaXMuY2hlY2tHZW9tZXRyeVR5cGUoKX1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dC5jb3B5KCk7cmV0dXJuIGUuY2xhbXAodGhpcy5fbGluZWFyR2VvbSksZX1wcm9qZWN0KHQpe3JldHVybiBnbC5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9Y2hlY2tHZW9tZXRyeVR5cGUoKXtpZighKHRoaXMuX2xpbmVhckdlb20gaW5zdGFuY2VvZiAkfHx0aGlzLl9saW5lYXJHZW9tIGluc3RhbmNlb2YgU3QpKXRocm93IG5ldyBzKFwiSW5wdXQgZ2VvbWV0cnkgbXVzdCBiZSBsaW5lYXJcIil9ZXh0cmFjdFBvaW50KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBhcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lYXJHZW9tKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0udG9Mb3dlc3QodGhpcy5fbGluZWFyR2VvbSk7cmV0dXJuIGUuZ2V0U2VnbWVudCh0aGlzLl9saW5lYXJHZW9tKS5wb2ludEFsb25nT2Zmc2V0KGUuZ2V0U2VnbWVudEZyYWN0aW9uKCksdCl9fWlzVmFsaWRJbmRleCh0KXtyZXR1cm4gdC5pc1ZhbGlkKHRoaXMuX2xpbmVhckdlb20pfWdldEVuZEluZGV4KCl7cmV0dXJuIHVsLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gbmV3IHVsfWluZGV4T2ZBZnRlcih0LGUpe3JldHVybiBnbC5pbmRleE9mQWZ0ZXIodGhpcy5fbGluZWFyR2VvbSx0LGUpfWV4dHJhY3RMaW5lKHQsZSl7cmV0dXJuIG1sLmV4dHJhY3QodGhpcy5fbGluZWFyR2VvbSx0LGUpfWluZGV4T2YodCl7cmV0dXJuIGdsLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1pbmRpY2VzT2YodCl7cmV0dXJuIGRsLmluZGljZXNPZih0aGlzLl9saW5lYXJHZW9tLHQpfX12YXIgeGw9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGVuZ3RoSW5kZXhlZExpbmU6ZmwsTGVuZ3RoTG9jYXRpb25NYXA6X2wsTGluZWFyR2VvbWV0cnlCdWlsZGVyOnBsLExpbmVhckl0ZXJhdG9yOmNsLExpbmVhckxvY2F0aW9uOnVsLExvY2F0aW9uSW5kZXhlZExpbmU6eWx9KTtjbGFzcyBFbHtzdGF0aWMgdHJhbnNmb3JtKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyluLmFkZChlLmV4ZWN1dGUocy5uZXh0KCkpKTtyZXR1cm4gbn1zdGF0aWMgc2VsZWN0KHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtCb29sZWFuLlRSVUUuZXF1YWxzKGUuZXhlY3V0ZSh0KSkmJm4uYWRkKHQpfXJldHVybiBufXN0YXRpYyBhcHBseSh0LGUpe2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuZXhlY3V0ZShuLm5leHQoKSl9fUVsLkZ1bmN0aW9uPWZ1bmN0aW9uKCl7fTtjbGFzcyBJbHtjb25zdHJ1Y3Rvcigpe0lsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMucHRzPW51bGwsdGhpcy5uPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCl9ZmlsdGVyKHQpe3RoaXMucHRzW3RoaXMubisrXT10fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIXX19Y2xhc3MgTmx7Y29uc3RydWN0b3IoKXtObC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9uPTB9ZmlsdGVyKHQpe3RoaXMuX24rK31nZXRDb3VudCgpe3JldHVybiB0aGlzLl9ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIXX19Y2xhc3Mgd2x7Y29uc3RydWN0b3IoKXt3bC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb3VudHM9bmV3IE50fWNvdW50KHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtyZXR1cm4gbnVsbD09PWU/MDplLmNvdW50KCl9YWRkKHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtudWxsPT09ZT90aGlzLl9jb3VudHMucHV0KHQsbmV3IENsKDEpKTplLmluY3JlbWVudCgpfX1jbGFzcyBDbHtjb25zdHJ1Y3Rvcigpe0NsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuY291bnQ9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb3VudD10fX1jb3VudCgpe3JldHVybiB0aGlzLmNvdW50fWluY3JlbWVudCgpe3RoaXMuY291bnQrK319ZnVuY3Rpb24gU2woKXt9ZnVuY3Rpb24gTGwoKXt9ZnVuY3Rpb24gVGwoKXt9d2wuQ291bnRlcj1DbDtjbGFzcyBSbCBleHRlbmRzIG57fWZ1bmN0aW9uIFBsKCl7fWNsYXNzIE9se3N0YXRpYyBjaGFycyh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7Zm9yKGxldCBzPTA7czxlO3MrKyluW3NdPXQ7cmV0dXJuIG5ldyBTdHJpbmcobil9c3RhdGljIGdldFN0YWNrVHJhY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgVGwsbj1uZXcgU2w7cmV0dXJuIHQucHJpbnRTdGFja1RyYWNlKG4pLGUudG9TdHJpbmcoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49XCJcIjtuZXcgTGwoT2wuZ2V0U3RhY2tUcmFjZSh0KSk7Y29uc3Qgcz1uZXcgUGw7Zm9yKGxldCB0PTA7dDxlO3QrKyl0cnl7bis9cy5yZWFkTGluZSgpK09sLk5FV0xJTkV9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgUmwpKXRocm93IHQ7Zy5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBufX1zdGF0aWMgc3BhY2VzKHQpe3JldHVybiBPbC5jaGFycyhcIiBcIix0KX1zdGF0aWMgc3BsaXQodCxlKXtjb25zdCBuPWUubGVuZ3RoLHM9bmV3IEw7bGV0IGk9XCJcIit0LHI9aS5pbmRleE9mKGUpO2Zvcig7cj49MDspe2NvbnN0IHQ9aS5zdWJzdHJpbmcoMCxyKTtzLmFkZCh0KSxpPWkuc3Vic3RyaW5nKHIrbikscj1pLmluZGV4T2YoZSl9aS5sZW5ndGg+MCYmcy5hZGQoaSk7Y29uc3Qgbz1uZXcgQXJyYXkocy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0Kyspb1t0XT1zLmdldCh0KTtyZXR1cm4gb319T2wuTkVXTElORT1ZLmdldFByb3BlcnR5KFwibGluZS5zZXBhcmF0b3JcIik7dmFyIHZsPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvbGxlY3Rpb25VdGlsOkVsLENvb3JkaW5hdGVBcnJheUZpbHRlcjpJbCxDb29yZGluYXRlQ291bnRGaWx0ZXI6TmwsR2VvbWV0cmljU2hhcGVGYWN0b3J5OndlLE51bWJlclV0aWw6ZSxPYmplY3RDb3VudGVyOndsLFByaW9yaXR5UXVldWU6THMsU3RyaW5nVXRpbDpPbCxVbmlxdWVDb29yZGluYXRlQXJyYXlGaWx0ZXI6bm59KTskLnByb3RvdHlwZS5nZXRCb3VuZGFyeT1mdW5jdGlvbigpe3JldHVybiBpaS5nZXRCb3VuZGFyeSh0aGlzKX0sU3QucHJvdG90eXBlLmdldEJvdW5kYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIGlpLmdldEJvdW5kYXJ5KHRoaXMpfSxVLnByb3RvdHlwZS5lcXVhbHNUb3BvPWZ1bmN0aW9uKHQpe3JldHVybiBRci5lcXVhbHNUb3BvKHRoaXMsdCl9LFUucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXQmJlFyLmVxdWFsc1RvcG8odGhpcyx0KX0sVS5wcm90b3R5cGUudW5pb249ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaW8udW5pb24odGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBlby51bmlvbih0aGlzLHQpfX0sVS5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiBHci5pc1ZhbGlkKHRoaXMpfSxVLnByb3RvdHlwZS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuIHdyLmludGVyc2VjdGlvbih0aGlzLHQpfSxVLnByb3RvdHlwZS5jb3ZlcnM9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmNvdmVycyh0aGlzLHQpfSxVLnByb3RvdHlwZS5jb3ZlcmVkQnk9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmNvdmVycyh0LHRoaXMpfSxVLnByb3RvdHlwZS50b3VjaGVzPWZ1bmN0aW9uKHQpe3JldHVybiBRci50b3VjaGVzKHRoaXMsdCl9LFUucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmludGVyc2VjdHModGhpcyx0KX0sVS5wcm90b3R5cGUud2l0aGluPWZ1bmN0aW9uKHQpe3JldHVybiBRci5jb250YWlucyh0LHRoaXMpfSxVLnByb3RvdHlwZS5vdmVybGFwcz1mdW5jdGlvbih0KXtyZXR1cm4gUXIub3ZlcmxhcHModGhpcyx0KX0sVS5wcm90b3R5cGUuZGlzam9pbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmRpc2pvaW50KHRoaXMsdCl9LFUucHJvdG90eXBlLmNyb3NzZXM9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmNyb3NzZXModGhpcyx0KX0sVS5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBxaS5idWZmZXJPcCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gcWkuYnVmZmVyT3AodGhpcyx0LGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gcWkuYnVmZmVyT3AodGhpcyx0LGUsbil9fSxVLnByb3RvdHlwZS5jb252ZXhIdWxsPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBzbih0aGlzKS5nZXRDb252ZXhIdWxsKCl9LFUucHJvdG90eXBlLnJlbGF0ZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gUXIucmVsYXRlKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBRci5yZWxhdGUodGhpcyx0KS5tYXRjaGVzKGUpfX0sVS5wcm90b3R5cGUuZ2V0Q2VudHJvaWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCgpO2NvbnN0IHQ9JGUuZ2V0Q2VudHJvaWQodGhpcyk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LHRoaXMpfSxVLnByb3RvdHlwZS5nZXRJbnRlcmlvclBvaW50PWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQoKTtsZXQgdD1udWxsO2NvbnN0IGU9dGhpcy5nZXREaW1lbnNpb24oKTt0PTA9PT1lP25ldyB1bih0aGlzKToxPT09ZT9uZXcgaG4odGhpcyk6bmV3IG9uKHRoaXMpO2NvbnN0IG49dC5nZXRJbnRlcmlvclBvaW50KCk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZChuLHRoaXMpfSxVLnByb3RvdHlwZS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiB3ci5zeW1EaWZmZXJlbmNlKHRoaXMsdCl9LFUucHJvdG90eXBlLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfSxVLnByb3RvdHlwZS50b1RleHQ9ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFd0KS53cml0ZSh0aGlzKX0sVS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b1RleHQoKX0sVS5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmNvbnRhaW5zKHRoaXMsdCl9LFUucHJvdG90eXBlLmRpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHdyLmRpZmZlcmVuY2UodGhpcyx0KX0sVS5wcm90b3R5cGUuaXNTaW1wbGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG9pKHRoaXMpLmlzU2ltcGxlKCl9LFUucHJvdG90eXBlLmlzV2l0aGluRGlzdGFuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT5lKSYmemkuaXNXaXRoaW5EaXN0YW5jZSh0aGlzLHQsZSl9LFUucHJvdG90eXBlLmRpc3RhbmNlPWZ1bmN0aW9uKHQpe3JldHVybiB6aS5kaXN0YW5jZSh0aGlzLHQpfTt0LmFsZ29yaXRobT1Fbix0LmRlbnNpZnk9d24sdC5kaXNzb2x2ZT12bix0Lmdlb209VGUsdC5nZW9tZ3JhcGg9Y3MsdC5pbmRleD1Bcyx0LmlvPVZzLHQubGluZWFycmVmPXhsLHQubm9kaW5nPXNpLHQub3BlcmF0aW9uPWxvLHQucHJlY2lzaW9uPXhvLHQuc2ltcGxpZnk9Rm8sdC50cmlhbmd1bGF0ZT1hbCx0LnV0aWw9dmwsdC52ZXJzaW9uPVwiMi45LjNcIn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzdHMubWluLmpzLm1hcFxuIiwiIWZ1bmN0aW9uKHQsaSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9aSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoaSk6KHQ9dHx8c2VsZikuUkJ1c2g9aSgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0LHIsZSxhLGgpeyFmdW5jdGlvbiB0KG4scixlLGEsaCl7Zm9yKDthPmU7KXtpZihhLWU+NjAwKXt2YXIgbz1hLWUrMSxzPXItZSsxLGw9TWF0aC5sb2cobyksZj0uNSpNYXRoLmV4cCgyKmwvMyksdT0uNSpNYXRoLnNxcnQobCpmKihvLWYpL28pKihzLW8vMjwwPy0xOjEpLG09TWF0aC5tYXgoZSxNYXRoLmZsb29yKHItcypmL28rdSkpLGM9TWF0aC5taW4oYSxNYXRoLmZsb29yKHIrKG8tcykqZi9vK3UpKTt0KG4scixtLGMsaCl9dmFyIHA9bltyXSxkPWUseD1hO2ZvcihpKG4sZSxyKSxoKG5bYV0scCk+MCYmaShuLGUsYSk7ZDx4Oyl7Zm9yKGkobixkLHgpLGQrKyx4LS07aChuW2RdLHApPDA7KWQrKztmb3IoO2goblt4XSxwKT4wOyl4LS19MD09PWgobltlXSxwKT9pKG4sZSx4KTppKG4sKyt4LGEpLHg8PXImJihlPXgrMSkscjw9eCYmKGE9eC0xKX19KHQscixlfHwwLGF8fHQubGVuZ3RoLTEsaHx8bil9ZnVuY3Rpb24gaSh0LGksbil7dmFyIHI9dFtpXTt0W2ldPXRbbl0sdFtuXT1yfWZ1bmN0aW9uIG4odCxpKXtyZXR1cm4gdDxpPy0xOnQ+aT8xOjB9dmFyIHI9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9OSksdGhpcy5fbWF4RW50cmllcz1NYXRoLm1heCg0LHQpLHRoaXMuX21pbkVudHJpZXM9TWF0aC5tYXgoMixNYXRoLmNlaWwoLjQqdGhpcy5fbWF4RW50cmllcykpLHRoaXMuY2xlYXIoKX07ZnVuY3Rpb24gZSh0LGksbil7aWYoIW4pcmV0dXJuIGkuaW5kZXhPZih0KTtmb3IodmFyIHI9MDtyPGkubGVuZ3RoO3IrKylpZihuKHQsaVtyXSkpcmV0dXJuIHI7cmV0dXJuLTF9ZnVuY3Rpb24gYSh0LGkpe2godCwwLHQuY2hpbGRyZW4ubGVuZ3RoLGksdCl9ZnVuY3Rpb24gaCh0LGksbixyLGUpe2V8fChlPXAobnVsbCkpLGUubWluWD0xLzAsZS5taW5ZPTEvMCxlLm1heFg9LTEvMCxlLm1heFk9LTEvMDtmb3IodmFyIGE9aTthPG47YSsrKXt2YXIgaD10LmNoaWxkcmVuW2FdO28oZSx0LmxlYWY/cihoKTpoKX1yZXR1cm4gZX1mdW5jdGlvbiBvKHQsaSl7cmV0dXJuIHQubWluWD1NYXRoLm1pbih0Lm1pblgsaS5taW5YKSx0Lm1pblk9TWF0aC5taW4odC5taW5ZLGkubWluWSksdC5tYXhYPU1hdGgubWF4KHQubWF4WCxpLm1heFgpLHQubWF4WT1NYXRoLm1heCh0Lm1heFksaS5tYXhZKSx0fWZ1bmN0aW9uIHModCxpKXtyZXR1cm4gdC5taW5YLWkubWluWH1mdW5jdGlvbiBsKHQsaSl7cmV0dXJuIHQubWluWS1pLm1pbll9ZnVuY3Rpb24gZih0KXtyZXR1cm4odC5tYXhYLXQubWluWCkqKHQubWF4WS10Lm1pblkpfWZ1bmN0aW9uIHUodCl7cmV0dXJuIHQubWF4WC10Lm1pblgrKHQubWF4WS10Lm1pblkpfWZ1bmN0aW9uIG0odCxpKXtyZXR1cm4gdC5taW5YPD1pLm1pblgmJnQubWluWTw9aS5taW5ZJiZpLm1heFg8PXQubWF4WCYmaS5tYXhZPD10Lm1heFl9ZnVuY3Rpb24gYyh0LGkpe3JldHVybiBpLm1pblg8PXQubWF4WCYmaS5taW5ZPD10Lm1heFkmJmkubWF4WD49dC5taW5YJiZpLm1heFk+PXQubWluWX1mdW5jdGlvbiBwKHQpe3JldHVybntjaGlsZHJlbjp0LGhlaWdodDoxLGxlYWY6ITAsbWluWDoxLzAsbWluWToxLzAsbWF4WDotMS8wLG1heFk6LTEvMH19ZnVuY3Rpb24gZChpLG4scixlLGEpe2Zvcih2YXIgaD1bbixyXTtoLmxlbmd0aDspaWYoISgocj1oLnBvcCgpKS0obj1oLnBvcCgpKTw9ZSkpe3ZhciBvPW4rTWF0aC5jZWlsKChyLW4pL2UvMikqZTt0KGksbyxuLHIsYSksaC5wdXNoKG4sbyxvLHIpfX1yZXR1cm4gci5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsW10pfSxyLnByb3RvdHlwZS5zZWFyY2g9ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5kYXRhLG49W107aWYoIWModCxpKSlyZXR1cm4gbjtmb3IodmFyIHI9dGhpcy50b0JCb3gsZT1bXTtpOyl7Zm9yKHZhciBhPTA7YTxpLmNoaWxkcmVuLmxlbmd0aDthKyspe3ZhciBoPWkuY2hpbGRyZW5bYV0sbz1pLmxlYWY/cihoKTpoO2ModCxvKSYmKGkubGVhZj9uLnB1c2goaCk6bSh0LG8pP3RoaXMuX2FsbChoLG4pOmUucHVzaChoKSl9aT1lLnBvcCgpfXJldHVybiBufSxyLnByb3RvdHlwZS5jb2xsaWRlcz1mdW5jdGlvbih0KXt2YXIgaT10aGlzLmRhdGE7aWYoIWModCxpKSlyZXR1cm4hMTtmb3IodmFyIG49W107aTspe2Zvcih2YXIgcj0wO3I8aS5jaGlsZHJlbi5sZW5ndGg7cisrKXt2YXIgZT1pLmNoaWxkcmVuW3JdLGE9aS5sZWFmP3RoaXMudG9CQm94KGUpOmU7aWYoYyh0LGEpKXtpZihpLmxlYWZ8fG0odCxhKSlyZXR1cm4hMDtuLnB1c2goZSl9fWk9bi5wb3AoKX1yZXR1cm4hMX0sci5wcm90b3R5cGUubG9hZD1mdW5jdGlvbih0KXtpZighdHx8IXQubGVuZ3RoKXJldHVybiB0aGlzO2lmKHQubGVuZ3RoPHRoaXMuX21pbkVudHJpZXMpe2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXRoaXMuaW5zZXJ0KHRbaV0pO3JldHVybiB0aGlzfXZhciBuPXRoaXMuX2J1aWxkKHQuc2xpY2UoKSwwLHQubGVuZ3RoLTEsMCk7aWYodGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aClpZih0aGlzLmRhdGEuaGVpZ2h0PT09bi5oZWlnaHQpdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSxuKTtlbHNle2lmKHRoaXMuZGF0YS5oZWlnaHQ8bi5oZWlnaHQpe3ZhciByPXRoaXMuZGF0YTt0aGlzLmRhdGE9bixuPXJ9dGhpcy5faW5zZXJ0KG4sdGhpcy5kYXRhLmhlaWdodC1uLmhlaWdodC0xLCEwKX1lbHNlIHRoaXMuZGF0YT1uO3JldHVybiB0aGlzfSxyLnByb3RvdHlwZS5pbnNlcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMuX2luc2VydCh0LHRoaXMuZGF0YS5oZWlnaHQtMSksdGhpc30sci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhPXAoW10pLHRoaXN9LHIucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0LGkpe2lmKCF0KXJldHVybiB0aGlzO2Zvcih2YXIgbixyLGEsaD10aGlzLmRhdGEsbz10aGlzLnRvQkJveCh0KSxzPVtdLGw9W107aHx8cy5sZW5ndGg7KXtpZihofHwoaD1zLnBvcCgpLHI9c1tzLmxlbmd0aC0xXSxuPWwucG9wKCksYT0hMCksaC5sZWFmKXt2YXIgZj1lKHQsaC5jaGlsZHJlbixpKTtpZigtMSE9PWYpcmV0dXJuIGguY2hpbGRyZW4uc3BsaWNlKGYsMSkscy5wdXNoKGgpLHRoaXMuX2NvbmRlbnNlKHMpLHRoaXN9YXx8aC5sZWFmfHwhbShoLG8pP3I/KG4rKyxoPXIuY2hpbGRyZW5bbl0sYT0hMSk6aD1udWxsOihzLnB1c2goaCksbC5wdXNoKG4pLG49MCxyPWgsaD1oLmNoaWxkcmVuWzBdKX1yZXR1cm4gdGhpc30sci5wcm90b3R5cGUudG9CQm94PWZ1bmN0aW9uKHQpe3JldHVybiB0fSxyLnByb3RvdHlwZS5jb21wYXJlTWluWD1mdW5jdGlvbih0LGkpe3JldHVybiB0Lm1pblgtaS5taW5YfSxyLnByb3RvdHlwZS5jb21wYXJlTWluWT1mdW5jdGlvbih0LGkpe3JldHVybiB0Lm1pblktaS5taW5ZfSxyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxyLnByb3RvdHlwZS5mcm9tSlNPTj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhPXQsdGhpc30sci5wcm90b3R5cGUuX2FsbD1mdW5jdGlvbih0LGkpe2Zvcih2YXIgbj1bXTt0Oyl0LmxlYWY/aS5wdXNoLmFwcGx5KGksdC5jaGlsZHJlbik6bi5wdXNoLmFwcGx5KG4sdC5jaGlsZHJlbiksdD1uLnBvcCgpO3JldHVybiBpfSxyLnByb3RvdHlwZS5fYnVpbGQ9ZnVuY3Rpb24odCxpLG4scil7dmFyIGUsaD1uLWkrMSxvPXRoaXMuX21heEVudHJpZXM7aWYoaDw9bylyZXR1cm4gYShlPXAodC5zbGljZShpLG4rMSkpLHRoaXMudG9CQm94KSxlO3J8fChyPU1hdGguY2VpbChNYXRoLmxvZyhoKS9NYXRoLmxvZyhvKSksbz1NYXRoLmNlaWwoaC9NYXRoLnBvdyhvLHItMSkpKSwoZT1wKFtdKSkubGVhZj0hMSxlLmhlaWdodD1yO3ZhciBzPU1hdGguY2VpbChoL28pLGw9cypNYXRoLmNlaWwoTWF0aC5zcXJ0KG8pKTtkKHQsaSxuLGwsdGhpcy5jb21wYXJlTWluWCk7Zm9yKHZhciBmPWk7Zjw9bjtmKz1sKXt2YXIgdT1NYXRoLm1pbihmK2wtMSxuKTtkKHQsZix1LHMsdGhpcy5jb21wYXJlTWluWSk7Zm9yKHZhciBtPWY7bTw9dTttKz1zKXt2YXIgYz1NYXRoLm1pbihtK3MtMSx1KTtlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQodCxtLGMsci0xKSl9fXJldHVybiBhKGUsdGhpcy50b0JCb3gpLGV9LHIucHJvdG90eXBlLl9jaG9vc2VTdWJ0cmVlPWZ1bmN0aW9uKHQsaSxuLHIpe2Zvcig7ci5wdXNoKGkpLCFpLmxlYWYmJnIubGVuZ3RoLTEhPT1uOyl7Zm9yKHZhciBlPTEvMCxhPTEvMCxoPXZvaWQgMCxvPTA7bzxpLmNoaWxkcmVuLmxlbmd0aDtvKyspe3ZhciBzPWkuY2hpbGRyZW5bb10sbD1mKHMpLHU9KG09dCxjPXMsKE1hdGgubWF4KGMubWF4WCxtLm1heFgpLU1hdGgubWluKGMubWluWCxtLm1pblgpKSooTWF0aC5tYXgoYy5tYXhZLG0ubWF4WSktTWF0aC5taW4oYy5taW5ZLG0ubWluWSkpLWwpO3U8YT8oYT11LGU9bDxlP2w6ZSxoPXMpOnU9PT1hJiZsPGUmJihlPWwsaD1zKX1pPWh8fGkuY2hpbGRyZW5bMF19dmFyIG0sYztyZXR1cm4gaX0sci5wcm90b3R5cGUuX2luc2VydD1mdW5jdGlvbih0LGksbil7dmFyIHI9bj90OnRoaXMudG9CQm94KHQpLGU9W10sYT10aGlzLl9jaG9vc2VTdWJ0cmVlKHIsdGhpcy5kYXRhLGksZSk7Zm9yKGEuY2hpbGRyZW4ucHVzaCh0KSxvKGEscik7aT49MCYmZVtpXS5jaGlsZHJlbi5sZW5ndGg+dGhpcy5fbWF4RW50cmllczspdGhpcy5fc3BsaXQoZSxpKSxpLS07dGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKHIsZSxpKX0sci5wcm90b3R5cGUuX3NwbGl0PWZ1bmN0aW9uKHQsaSl7dmFyIG49dFtpXSxyPW4uY2hpbGRyZW4ubGVuZ3RoLGU9dGhpcy5fbWluRW50cmllczt0aGlzLl9jaG9vc2VTcGxpdEF4aXMobixlLHIpO3ZhciBoPXRoaXMuX2Nob29zZVNwbGl0SW5kZXgobixlLHIpLG89cChuLmNoaWxkcmVuLnNwbGljZShoLG4uY2hpbGRyZW4ubGVuZ3RoLWgpKTtvLmhlaWdodD1uLmhlaWdodCxvLmxlYWY9bi5sZWFmLGEobix0aGlzLnRvQkJveCksYShvLHRoaXMudG9CQm94KSxpP3RbaS0xXS5jaGlsZHJlbi5wdXNoKG8pOnRoaXMuX3NwbGl0Um9vdChuLG8pfSxyLnByb3RvdHlwZS5fc3BsaXRSb290PWZ1bmN0aW9uKHQsaSl7dGhpcy5kYXRhPXAoW3QsaV0pLHRoaXMuZGF0YS5oZWlnaHQ9dC5oZWlnaHQrMSx0aGlzLmRhdGEubGVhZj0hMSxhKHRoaXMuZGF0YSx0aGlzLnRvQkJveCl9LHIucHJvdG90eXBlLl9jaG9vc2VTcGxpdEluZGV4PWZ1bmN0aW9uKHQsaSxuKXtmb3IodmFyIHIsZSxhLG8scyxsLHUsbT0xLzAsYz0xLzAscD1pO3A8PW4taTtwKyspe3ZhciBkPWgodCwwLHAsdGhpcy50b0JCb3gpLHg9aCh0LHAsbix0aGlzLnRvQkJveCksdj0oZT1kLGE9eCxvPXZvaWQgMCxzPXZvaWQgMCxsPXZvaWQgMCx1PXZvaWQgMCxvPU1hdGgubWF4KGUubWluWCxhLm1pblgpLHM9TWF0aC5tYXgoZS5taW5ZLGEubWluWSksbD1NYXRoLm1pbihlLm1heFgsYS5tYXhYKSx1PU1hdGgubWluKGUubWF4WSxhLm1heFkpLE1hdGgubWF4KDAsbC1vKSpNYXRoLm1heCgwLHUtcykpLE09ZihkKStmKHgpO3Y8bT8obT12LHI9cCxjPU08Yz9NOmMpOnY9PT1tJiZNPGMmJihjPU0scj1wKX1yZXR1cm4gcnx8bi1pfSxyLnByb3RvdHlwZS5fY2hvb3NlU3BsaXRBeGlzPWZ1bmN0aW9uKHQsaSxuKXt2YXIgcj10LmxlYWY/dGhpcy5jb21wYXJlTWluWDpzLGU9dC5sZWFmP3RoaXMuY29tcGFyZU1pblk6bDt0aGlzLl9hbGxEaXN0TWFyZ2luKHQsaSxuLHIpPHRoaXMuX2FsbERpc3RNYXJnaW4odCxpLG4sZSkmJnQuY2hpbGRyZW4uc29ydChyKX0sci5wcm90b3R5cGUuX2FsbERpc3RNYXJnaW49ZnVuY3Rpb24odCxpLG4scil7dC5jaGlsZHJlbi5zb3J0KHIpO2Zvcih2YXIgZT10aGlzLnRvQkJveCxhPWgodCwwLGksZSkscz1oKHQsbi1pLG4sZSksbD11KGEpK3UocyksZj1pO2Y8bi1pO2YrKyl7dmFyIG09dC5jaGlsZHJlbltmXTtvKGEsdC5sZWFmP2UobSk6bSksbCs9dShhKX1mb3IodmFyIGM9bi1pLTE7Yz49aTtjLS0pe3ZhciBwPXQuY2hpbGRyZW5bY107byhzLHQubGVhZj9lKHApOnApLGwrPXUocyl9cmV0dXJuIGx9LHIucHJvdG90eXBlLl9hZGp1c3RQYXJlbnRCQm94ZXM9ZnVuY3Rpb24odCxpLG4pe2Zvcih2YXIgcj1uO3I+PTA7ci0tKW8oaVtyXSx0KX0sci5wcm90b3R5cGUuX2NvbmRlbnNlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgaT10Lmxlbmd0aC0xLG49dm9pZCAwO2k+PTA7aS0tKTA9PT10W2ldLmNoaWxkcmVuLmxlbmd0aD9pPjA/KG49dFtpLTFdLmNoaWxkcmVuKS5zcGxpY2Uobi5pbmRleE9mKHRbaV0pLDEpOnRoaXMuY2xlYXIoKTphKHRbaV0sdGhpcy50b0JCb3gpfSxyfSk7XG4iLCIvL0B0cy1jaGVja1xuXG4vKiogKi9cbmV4cG9ydCBjbGFzcyBBZ2VudFBvaW50IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3kgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSwgc3g9MCwgc3k9MCkge1xuXG4gICAgICAgIC8vcG9zaXRpb25cblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geVxuXG4gICAgICAgIC8vc3BlZWRcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zeCA9IHN4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnN5ID0gc3lcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucyA9IHVuZGVmaW5lZFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zYSA9IHVuZGVmaW5lZFxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBZ2VudFBvaW50fSBhXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgYWdlbnQuXG4gICAgICovXG4gICAgZChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRQKGEueCwgYS55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgdG8gYSBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBkUCh4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmh5cG90KCh4IC0gdGhpcy54KSwgKHkgLSB0aGlzLnkpKTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgKiBTZXQgcmFuZG9tIHNwZWVkXG4gICAgKiBcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkXG4gICAgKi9cbiAgICBzZXRSYW5kb21TcGVlZChtaW5TcGVlZCA9IDAsIG1heFNwZWVkID0gMC4xKSB7XG4gICAgICAgIHRoaXMucyA9IG1pblNwZWVkICsgTWF0aC5yYW5kb20oKSAqIChtYXhTcGVlZCAtIG1pblNwZWVkKTtcbiAgICAgICAgdGhpcy5zYSA9IDIgKiBNYXRoLnJhbmRvbSgpICogTWF0aC5QSTtcbiAgICAgICAgdGhpcy5zeCA9IHRoaXMucyAqIE1hdGguY29zKHRoaXMuc2EpXG4gICAgICAgIHRoaXMuc3kgPSB0aGlzLnMgKiBNYXRoLnNpbih0aGlzLnNhKVxuICAgIH1cblxuICAgIC8qKiAqL1xuICAgIGNvbXB1dGVTcGVlZCgpIHtcbiAgICAgICAgdGhpcy5zID0gTWF0aC5oeXBvdCh0aGlzLnN4LCB0aGlzLnN5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc1xuICAgIH1cblxuICAgIC8qKiAqL1xuICAgIGNvbXB1dGVTcGVlZEFuZ2xlKCkge1xuICAgICAgICB0aGlzLnNhID0gTWF0aC5hdGFuMih0aGlzLnN5LCB0aGlzLnN4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG4vKiogQHR5cGVkZWYgeyB7eE1pbjogbnVtYmVyLCB4TWF4OiBudW1iZXIsIHlNaW46IG51bWJlciwgeU1heDogbnVtYmVyfSB9IEVudmVsb3BlICovXG5cbmltcG9ydCB7IHpvb20gYXMgZDN6b29tLCB6b29tSWRlbnRpdHkgfSBmcm9tIFwiZDMtem9vbVwiO1xuaW1wb3J0IHsgc2VsZWN0IGFzIGQzc2VsZWN0IH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG4vKipcbiAqIEEgSFRNTCBjYW52YXMgZm9yIGdlbyBkYXRhIGRpc3BsYXksIGVuaGFuY2VkIHdpdGggem9vbSBhbmQgcGFuIGNhcGFiaWxpdGllcy5cbiAqIFxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxuICovXG5leHBvcnQgY2xhc3MgR2VvQ2FudmFzIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYW52YXNJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjZW50ZXIgR2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gemYgVGhlIHpvb20gZmFjdG9yIChwaXhlbCBzaXplLCBpbiBncm91bmQgbSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYW52YXNJZCA9IFwidmFjYW52YXNcIiwgY2VudGVyID0gdW5kZWZpbmVkLCB6ZiA9IDEpIHtcblxuICAgICAgICAvKiogQHR5cGUge29iamVjdH0gKi9cbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IHRoaXMuY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53O1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmg7XG5cbiAgICAgICAgLyoqQHR5cGUge29iamVjdH0gKi9cbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgLy8gc2V0IGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyXG4gICAgICAgIHRoaXMuc2V0Q2VudGVyKGNlbnRlciB8fCB7IHg6IHRoaXMudyAqIDAuNSwgeTogdGhpcy5oICogMC41IH0pXG5cbiAgICAgICAgLy8gc2V0IHpvb20gZmFjdG9yOiBwaXhlbCBzaXplLCBpbiBtL3BpeFxuICAgICAgICB0aGlzLnNldFpmKHpmKTtcblxuICAgICAgICAvL2V4dGVudFxuICAgICAgICAvKiogQHR5cGUge0VudmVsb3BlfSAqL1xuICAgICAgICB0aGlzLmV4dEdlbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRHZW8oKVxuXG4gICAgICAgIC8vcmVseSBvbiBkMyB6b29tIGZvciBwYW4vem9vbVxuICAgICAgICBsZXQgdFAgPSB6b29tSWRlbnRpdHlcbiAgICAgICAgZDNzZWxlY3QodGhpcy5jYW52YXMpLmNhbGwoXG4gICAgICAgICAgICBkM3pvb20oKS5vbihcInpvb21cIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gZS50cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBjb25zdCBmID0gdFAuayAvIHQua1xuICAgICAgICAgICAgICAgIGlmIChmID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9wYW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHggPSB0UC54IC0gdC54XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gdFAueSAtIHQueVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhbihkeCAqIHRoaXMuZ2V0WmYoKSwgLWR5ICogdGhpcy5nZXRaZigpKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlID0gZS5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlIGluc3RhbmNlb2YgV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy96b29tIGF0IHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tKGYsIHRoaXMucGl4VG9HZW9YKGUuc291cmNlRXZlbnQub2Zmc2V0WCksIHRoaXMucGl4VG9HZW9ZKGUuc291cmNlRXZlbnQub2Zmc2V0WSkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2UgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgdG91Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR4ID0gMCwgdHkgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0dCBvZiBzZS50YXJnZXRUb3VjaGVzKSB7IHR4ICs9IHR0LmNsaWVudFg7IHR5ICs9IHR0LmNsaWVudFkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHggLz0gc2UudGFyZ2V0VG91Y2hlcy5sZW5ndGg7IHR5IC89IHNlLnRhcmdldFRvdWNoZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3pvb20gYXQgdGhpcyBhdmVyYWdlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20oZiwgdGhpcy5waXhUb0dlb1godHgpLCB0aGlzLnBpeFRvR2VvWSh0eSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdFAgPSB0XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gdiBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciAqL1xuICAgIHNldENlbnRlcih2KSB7IHRoaXMuY2VudGVyID0gdjsgfVxuICAgIC8qKiBAcmV0dXJucyB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gR2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXIgKi9cbiAgICBnZXRDZW50ZXIoKSB7IHJldHVybiB0aGlzLmNlbnRlcjsgfVxuXG4gICAgLyoqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pICovXG4gICAgc2V0WmYodikgeyB0aGlzLnpmID0gdjsgfVxuICAgIC8qKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgem9vbSBmYWN0b3IgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKSAqL1xuICAgIGdldFpmKCkgeyByZXR1cm4gdGhpcy56ZjsgfVxuXG5cblxuXG4gICAgLyoqIEluaXRpYWxpc2UgY2FudmFzIHRyYW5zZm9ybSB3aXRoIGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uLiAqL1xuICAgIGluaXRDYW52YXNUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvKiogSW5pdGlhbGlzZSBjYW52YXMgdHJhbnNmb3JtIHdpdGggZ2VvIHRvIHNjcmVlbiB0cmFuc2Zvcm1hdGlvbiwgc28gdGhhdCBnZW8gb2JqZWN0cyBjYW4gYmUgZHJhd24gZGlyZWN0bHkgaW4gZ2VvIGNvb3JkaW5hdGVzLiAqL1xuICAgIHNldENhbnZhc1RyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgayA9IDEgLyB0aGlzLmdldFpmKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gLXRoaXMuY2VudGVyLnggLyB0aGlzLmdldFpmKCkgKyB0aGlzLncgKiAwLjU7XG4gICAgICAgIGNvbnN0IHR5ID0gdGhpcy5jZW50ZXIueSAvIHRoaXMuZ2V0WmYoKSArIHRoaXMuaCAqIDAuNTtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKGssIDAsIDAsIC1rLCB0eCwgdHkpO1xuICAgIH1cblxuXG4gICAgLyoqIFRoZSBmdW5jdGlvbiBzcGVjaWZ5aW5nIGhvdyB0byBkcmF3IHRoZSBtYXAuICovXG4gICAgcmVkcmF3KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCByZWRyYXcgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBhcHAgc2NyZWVuLiBUbyBiZSB1c2VkIGJlZm9yZSBhIHJlZHJhdyBmb3IgZXhhbXBsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgXG4gICAgICovXG4gICAgY2xlYXIoY29sb3IgPSBcIndoaXRlXCIpIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcbiAgICB9XG5cbiAgICAvL2NvbnZlcnNpb24gZnVuY3Rpb25zXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhHZW8gR2VvIHggY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTY3JlZW4geCBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgKi9cbiAgICBnZW9Ub1BpeFgoeEdlbykgeyByZXR1cm4gKHhHZW8gLSB0aGlzLmNlbnRlci54KSAvIHRoaXMuZ2V0WmYoKSArIHRoaXMudyAqIDAuNTsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5R2VvIEdlbyB5IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2NyZWVuIHkgY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICovXG4gICAgZ2VvVG9QaXhZKHlHZW8pIHsgcmV0dXJuIC0oeUdlbyAtIHRoaXMuY2VudGVyLnkpIC8gdGhpcy5nZXRaZigpICsgdGhpcy5oICogMC41OyB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggU2NyZWVuIHggY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEdlbyB4IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgKi9cbiAgICBwaXhUb0dlb1goeCkgeyByZXR1cm4gKHggLSB0aGlzLncgKiAwLjUpICogdGhpcy5nZXRaZigpICsgdGhpcy5jZW50ZXIueDsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFNjcmVlbiB5IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBHZW8geSBjb29yZGluYXRlLCBpbiBtLlxuICAgICovXG4gICAgcGl4VG9HZW9ZKHkpIHsgcmV0dXJuIC0oeSAtIHRoaXMuaCAqIDAuNSkgKiB0aGlzLmdldFpmKCkgKyB0aGlzLmNlbnRlci55OyB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHhHZW9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHlHZW9cbiAgICAgKi9cbiAgICBwYW4oZHhHZW8sIGR5R2VvKSB7XG4gICAgICAgIC8vVE9ETyBmb3JjZSBleHRlbmQgdG8gcmVtYWluXG4gICAgICAgIHRoaXMuY2VudGVyLnggKz0gZHhHZW87XG4gICAgICAgIHRoaXMuY2VudGVyLnkgKz0gZHlHZW87XG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSB6b29tIGZhY3Rvciwgd2l0aGluIF0wLCBJbmZpbml0eV0uIDEgaXMgZm9yIG5vIGNoYW5nZS4gPDEgdG8gem9vbS1pbiwgPjEgdG8gem9vbS1vdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhHZW8gVGhlIHggZ2VvIHBvc2l0aW9uIGZpeGVkIGluIHRoZSBzY3JlZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlHZW8gVGhlIHkgZ2VvIHBvc2l0aW9uIGZpeGVkIGluIHRoZSBzY3JlZW4uXG4gICAgICovXG4gICAgem9vbShmID0gMSwgeEdlbyA9IHRoaXMuY2VudGVyLngsIHlHZW8gPSB0aGlzLmNlbnRlci55KSB7XG4gICAgICAgIC8vVE9ETyBmb3JjZSBleHRlbmQgdG8gcmVtYWluXG4gICAgICAgIHRoaXMuc2V0WmYoZiAqIHRoaXMuZ2V0WmYoKSk7XG4gICAgICAgIHRoaXMuY2VudGVyLnggKz0gKHhHZW8gLSB0aGlzLmNlbnRlci54KSAqICgxIC0gZilcbiAgICAgICAgdGhpcy5jZW50ZXIueSArPSAoeUdlbyAtIHRoaXMuY2VudGVyLnkpICogKDEgLSBmKVxuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcmdpblB4IFxuICAgICAqIEByZXR1cm5zIHtFbnZlbG9wZX0gVGhlIGVudmVsb3BlIG9mIHRoZSB2aWV3LCBpbiBnZW8gY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgdXBkYXRlRXh0ZW50R2VvKG1hcmdpblB4ID0gMjApIHtcbiAgICAgICAgdGhpcy5leHRHZW8gPSB7XG4gICAgICAgICAgICB4TWluOiB0aGlzLnBpeFRvR2VvWCgtbWFyZ2luUHgpLFxuICAgICAgICAgICAgeE1heDogdGhpcy5waXhUb0dlb1godGhpcy53ICsgbWFyZ2luUHgpLFxuICAgICAgICAgICAgeU1pbjogdGhpcy5waXhUb0dlb1kodGhpcy5oICsgbWFyZ2luUHgpLFxuICAgICAgICAgICAgeU1heDogdGhpcy5waXhUb0dlb1koLW1hcmdpblB4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4dEdlbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGhhcyB0byBiZSBkcmF3blxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gb2JqIFxuICAgICAqL1xuICAgIHRvRHJhdyhvYmopIHtcbiAgICAgICAgaWYgKG9iai54IDwgdGhpcy5leHRHZW8ueE1pbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob2JqLnggPiB0aGlzLmV4dEdlby54TWF4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvYmoueSA8IHRoaXMuZXh0R2VvLnlNaW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9iai55ID4gdGhpcy5leHRHZW8ueU1heCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcblxuLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2hcbmltcG9ydCBSQnVzaCBmcm9tICdyYnVzaCc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGNsYXNzIFNwYXRpYWxJbmRleCB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY2xhc3MgTXlSQnVzaCBleHRlbmRzIFJCdXNoIHtcbiAgICAgICAgICAgIC8qKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IG9iaiAgKi9cbiAgICAgICAgICAgIHRvQkJveChvYmopIHsgcmV0dXJuIHsgbWluWDogb2JqLngsIG1pblk6IG9iai55LCBtYXhYOiBvYmoueCwgbWF4WTogb2JqLnkgfTsgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IGEgXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IGIgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbXBhcmVNaW5YKGEsIGIpIHsgcmV0dXJuIGEueCAtIGIueDsgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IGEgXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IGIgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEueSAtIGIueTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtNeVJCdXNofSAqL1xuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgTXlSQnVzaCgpO1xuICAgIH1cblxuICAgIC8vVE9ETyBidWxrIHJlbW92ZSA/XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5bWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geW1heFxuICAgICAqIEByZXR1cm4ge0FycmF5LjxUPn1cbiAgICAgKi9cbiAgICBnZXQoeG1pbiwgeW1pbiwgeG1heCwgeW1heCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlYXJjaCh7XG4gICAgICAgICAgICBtaW5YOiB4bWluLFxuICAgICAgICAgICAgbWluWTogeW1pbixcbiAgICAgICAgICAgIG1heFg6IHhtYXgsXG4gICAgICAgICAgICBtYXhZOiB5bWF4XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VH0gb2JqXG4gICAgICovXG4gICAgaW5zZXJ0KG9iaikge1xuICAgICAgICB0aGlzLnRyZWUuaW5zZXJ0KG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVsayBpbnNlcnRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxUPn0gb2Jqc1xuICAgICAqL1xuICAgIGxvYWQob2Jqcykge1xuICAgICAgICB0aGlzLnRyZWUubG9hZChvYmpzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R9IG9ialxuICAgICAqL1xuICAgIHJlbW92ZShvYmopIHtcbiAgICAgICAgdGhpcy50cmVlLnJlbW92ZShvYmopXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudHJlZS5jbGVhcigpXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtPYmplY3QuPD8sIFQ+fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheS48VD59XG4gKi9cbmV4cG9ydCBjb25zdCBvYmpUb0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICBvdXQucHVzaChvYmpba2V5XSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnJcbiAqIEBwYXJhbSB7VH0gb2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1zZyBcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnIsIG9iaiwgbXNnID0gdHJ1ZSkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKG9iaik7XG4gICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGVsc2VcbiAgICAgICAgaWYgKG1zZykgY29uc29sZS5sb2coXCJJbXBvc3NpYmxlIHRvIHJlbW92ZSBlbGVtZW50IG5vdCBwcmVzZW50IGluIGFycmF5LlwiKTtcbn07XG5cbi8qKlxuICogXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheS48VD59IGFyclxuICogQHBhcmFtIHtBcnJheS48VD59IG9ianMgXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1zZyBcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUZyb21BcnJheVMgPSBmdW5jdGlvbiAoYXJyLCBvYmpzLCBtc2cgPSB0cnVlKSB7XG4gICAgZm9yIChsZXQgb2JqIG9mIG9ianMpXG4gICAgICAgIHJlbW92ZUZyb21BcnJheShhcnIsIG9iaiwgbXNnKVxufTtcbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBTZWEgfSBmcm9tIFwiLi9TZWFcIlxuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCJcbmltcG9ydCB7IEFnZW50UG9pbnQgfSBmcm9tIFwiLi4vYmFzZS9BZ2VudFBvaW50XCI7XG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tICcuLi9iYXNlL1NwYXRpYWxJbmRleCc7XG5cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIFNhcmRpbiBleHRlbmRzIEFnZW50UG9pbnQge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZWF9IHNlYSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN5IFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlYSwgeCA9IHNlYS53ICogTWF0aC5yYW5kb20oKSwgeSA9IHNlYS5oICogTWF0aC5yYW5kb20oKSwgc3ggPSB1bmRlZmluZWQsIHN5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy9cbiAgICAgICAgc3VwZXIoeCwgeSwgc3gsIHN5KVxuXG4gICAgICAgIC8qKiBAdHlwZSB7U2VhfSAqL1xuICAgICAgICB0aGlzLnNlYSA9IHNlYTtcblxuICAgICAgICAvL3Bvc2l0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4IDwgMCA/IDAgOiB4ID4gc2VhLncgPyBzZWEudyA6IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHkgPCAwID8gMCA6IHkgPiBzZWEuaCA/IHNlYS5oIDogeVxuXG4gICAgICAgIC8vc3BlZWRcbiAgICAgICAgaWYgKCFzeCAmJiAhc3kpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFuZG9tU3BlZWQoMCwgdGhpcy5zZWEuVl9NQVgpXG5cbiAgICAgICAgICAgIC8vYWNjZWxlcmF0aW9uXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIHRoaXMuYXggPSAwXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIHRoaXMuYXkgPSAwXG5cbiAgICAgICAgICAgIC8vbGlzdCBvZiBzYXJkaW5zIGluIHZpc2lvbiBmaWVsZFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgICAgIHRoaXMub2JzID0gW11cbiAgICAgICAgICAgIC8vbGlzdCBvZiBzYXJkaW5zIGluIGNvbGxpc2lvbiBmaWVsZFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgICAgIHRoaXMuY29sID0gW11cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPFNhcmRpbj59IHNpbmRleCBcbiAgICAgKi9cbiAgICBvYnNlcnZlKHNpbmRleCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U2VhfSAqL1xuICAgICAgICBjb25zdCBzID0gdGhpcy5zZWFcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGNvbnN0IGRPID0gcy5EX09CU1xuXG4gICAgICAgIC8vaW5pdGlhbGlzZSBsaXN0c1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICB0aGlzLm9icyA9IFtdO1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICB0aGlzLmNvbCA9IFtdO1xuXG4gICAgICAgIC8vZ2V0IHNhcmRpbnMgYXJvdW5kIHVzaW5nIHNwYXRpYWwgaW5kZXhcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgY29uc3Qgc3MgPSBzaW5kZXguZ2V0KHRoaXMueCAtIGRPLCB0aGlzLnkgLSBkTywgdGhpcy54ICsgZE8sIHRoaXMueSArIGRPKTtcblxuICAgICAgICAvL2dldCBzYXJkaW5zIGluIG9ic2VydmF0aW9uIGFuZCBjb2xsaXNpb24gZmllbGRzXG4gICAgICAgIGZvciAobGV0IGYgb2Ygc3MpIHtcbiAgICAgICAgICAgIGlmIChmID09IHRoaXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZChmKSA8PSBzLkRfQ09MKVxuICAgICAgICAgICAgICAgIHRoaXMuY29sLnB1c2goZik7XG4gICAgICAgICAgICBpZiAodGhpcy5kKGYpIDw9IGRPKSB7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBhbmdsZVxuICAgICAgICAgICAgICAgIGxldCBkYSA9IE1hdGguYXRhbjIoZi55IC0gdGhpcy55LCBmLnggLSB0aGlzLngpIC0gdGhpcy5zYTtcbiAgICAgICAgICAgICAgICBpZiAoZGEgPiBNYXRoLlBJKSBkYSAtPSAyICogTWF0aC5QSTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkYSA8PSAtTWF0aC5QSSkgZGEgKz0gMiAqIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgZGEgPSBNYXRoLmFicyhkYSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhID4gcy5BX09CUyAqIDAuNSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnMucHVzaChmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vaW5pdGlhbGlzZSBhY2NlbGVyYXRpb25cbiAgICAgICAgdGhpcy5heCA9IDA7IHRoaXMuYXkgPSAwO1xuXG4gICAgICAgIC8vY29sbGlzaW9uOiByZXB1bHNpb25cbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmNvbCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuZChmKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSAxLjAgKiAoMSAvIChkICogZCkgLSAxIC8gKHMuRF9DT0wgKiBzLkRfQ09MKSk7XG4gICAgICAgICAgICB0aGlzLmF4ICs9IGEgKiAodGhpcy54IC0gZi54KSAvIGQ7XG4gICAgICAgICAgICB0aGlzLmF5ICs9IGEgKiAodGhpcy55IC0gZi55KSAvIGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b3dhcmQgdGFyZ2V0IHNwZWVkXG4gICAgICAgIGNvbnN0IGR2ID0gKHMuVl9UQVJHRVQgLSB0aGlzLnMpICogMC4wMTtcbiAgICAgICAgdGhpcy5heCArPSBkdiAqIHRoaXMuc3ggLyB0aGlzLnM7XG4gICAgICAgIHRoaXMuYXkgKz0gZHYgKiB0aGlzLnN5IC8gdGhpcy5zO1xuXG4gICAgICAgIC8vdG93YXJkIHRoZSBvYnNlcnZlZCBtZWFuIHBvc2l0aW9uXG4gICAgICAgIC8qaWYob2JzLnNpemUoKT4xKXtcbiAgICAgICAgICAgIGRvdWJsZSB4bj0wLHluPTA7XG4gICAgICAgICAgICBmb3IoU2FyZGluIHM6b2JzKXtcbiAgICAgICAgICAgICAgICB4bis9cy54O1xuICAgICAgICAgICAgICAgIHluKz1zLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bj14bi9vYnMuc2l6ZSgpO1xuICAgICAgICAgICAgeW49eW4vb2JzLnNpemUoKTtcbiAgICAgICAgICAgIGRvdWJsZSBkPU1hdGguaHlwb3QoeG4teCx5bi15KTtcbiAgICAgICAgICAgIGF4Kz0tMC4xKih4LXhuKS9kO1xuICAgICAgICAgICAgYXkrPS0wLjEqKHkteW4pL2Q7XG4gICAgICAgIH0qL1xuXG4gICAgICAgIC8vdG93YXJkIHRoZSBvYnNlcnZlZCBzcGVlZFxuICAgICAgICBjb25zdCB0ID0gMC45O1xuICAgICAgICBpZiAodGhpcy5vYnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGRzeCA9IDAsIGRzeSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzIG9mIHRoaXMub2JzKSB7XG4gICAgICAgICAgICAgICAgZHN4ICs9IHMuc3g7XG4gICAgICAgICAgICAgICAgZHN5ICs9IHMuc3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkc3ggPSAodCAtIDEpICogdGhpcy5zeCArICgxIC0gdCkgKiBkc3ggLyB0aGlzLm9icy5sZW5ndGg7XG4gICAgICAgICAgICBkc3kgPSAodCAtIDEpICogdGhpcy5zeSArICgxIC0gdCkgKiBkc3kgLyB0aGlzLm9icy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSAwLjE7XG4gICAgICAgICAgICB0aGlzLmF4ICs9IGEgKiBkc3g7XG4gICAgICAgICAgICB0aGlzLmF5ICs9IGEgKiBkc3k7XG4gICAgICAgIH1cblxuICAgICAgICAvL2F2b2lkIHNoYXJrXG4gICAgICAgIGNvbnN0IHNoID0gcy5zaGFyaztcbiAgICAgICAgaWYgKHNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KChzaC54IC0gdGhpcy54KSwgKHNoLnkgLSB0aGlzLnkpKTtcbiAgICAgICAgICAgIGlmIChkIDw9IHMuRF9PQlMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gNS4wICogKDEgLyAoZCAqIGQpIC0gMSAvIChkTyAqIGRPKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5heCArPSBhICogKHRoaXMueCAtIHNoLngpIC8gZDtcbiAgICAgICAgICAgICAgICB0aGlzLmF5ICs9IGEgKiAodGhpcy55IC0gc2gueSkgLyBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIG1vdmUodGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9jb21wdXRlIG5ldyBzcGVlZFxuICAgICAgICB0aGlzLnN4ICs9IHRoaXMuYXggKiB0aW1lU3RlcE1zICsgKDEgLSAyICogTWF0aC5yYW5kb20oKSkgKiAwLjAyO1xuICAgICAgICB0aGlzLnN5ICs9IHRoaXMuYXkgKiB0aW1lU3RlcE1zICsgKDEgLSAyICogTWF0aC5yYW5kb20oKSkgKiAwLjAyO1xuICAgICAgICB0aGlzLnMgPSB0aGlzLmNvbXB1dGVTcGVlZCgpXG4gICAgICAgIGlmICh0aGlzLnMgPiB0aGlzLnNlYS5WX01BWCkge1xuICAgICAgICAgICAgdGhpcy5zID0gdGhpcy5zZWEuVl9NQVg7XG4gICAgICAgICAgICB0aGlzLnN4ID0gdGhpcy5zZWEuVl9NQVggKiBNYXRoLmNvcyh0aGlzLnNhKTtcbiAgICAgICAgICAgIHRoaXMuc3kgPSB0aGlzLnNlYS5WX01BWCAqIE1hdGguc2luKHRoaXMuc2EpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIG5ldyBwb3NpdGlvblxuICAgICAgICB0aGlzLnggKz0gdGhpcy5zeCAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLnN5ICogdGltZVN0ZXBNcztcblxuICAgICAgICAvL2xpbWl0XG4gICAgICAgIGlmICh0aGlzLnggPCAwKSB0aGlzLnggPSB0aGlzLnNlYS53O1xuICAgICAgICBpZiAodGhpcy55IDwgMCkgdGhpcy55ID0gdGhpcy5zZWEuaDtcbiAgICAgICAgaWYgKHRoaXMueCA+IHRoaXMuc2VhLncpIHRoaXMueCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnkgPiB0aGlzLnNlYS5oKSB0aGlzLnkgPSAwO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBhIHNhcmRpbiBib2R5XG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggXG4gICAgICovXG4gICAgZGlzcGxheShjcCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmZsb29yKDI1NSAqIE1hdGguYWJzKHRoaXMuc2EpIC8gTWF0aC5QSSk7XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJyZ2IoMjU1LCAyNTUsIFwiICsgYyArIFwiKVwiXG4gICAgICAgIGNvbnN0IGEgPSBsZW5ndGggLyB0aGlzLnM7XG4gICAgICAgIGNvbnN0IGR4ID0gYSAqIHRoaXMuc3ggKiAwLjU7XG4gICAgICAgIGNvbnN0IGR5ID0gYSAqIHRoaXMuc3kgKiAwLjU7XG5cbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLm1vdmVUbyh0aGlzLnggLSBkeCwgdGhpcy55IC0gZHkpO1xuICAgICAgICBjMi5saW5lVG8odGhpcy54ICsgZHgsIHRoaXMueSArIGR5KTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLnN0cm9rZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgc2FyZGluIHZpc2lvbiBmaWVsZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsbFN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggXG4gICAgICovXG4gICAgZGlzcGxheVZpc2lvbkZpZWxkKGNwLCBmaWxsU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGMyLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIubW92ZVRvKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgYzIuYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnNlYS5EX09CUyAvIGNwLmdldFpmKCksXG4gICAgICAgICAgICB0aGlzLnNhIC0gdGhpcy5zZWEuQV9PQlMgKiAwLjUsXG4gICAgICAgICAgICB0aGlzLnNhICsgdGhpcy5zZWEuQV9PQlMgKiAwLjVcbiAgICAgICAgKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLmZpbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHNhcmRpbiB2aXNpb24gbGlua3NcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZVN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggXG4gICAgICovXG4gICAgZGlzcGxheVZpc2lvbkxpbmtzKGNwLCBzdHJva2VTdHlsZSwgbGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGMyLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgZm9yIChsZXQgc2EyIG9mIHRoaXMub2JzKSB7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLm1vdmVUbyh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBjMi5saW5lVG8oc2EyLngsIHNhMi55KTtcbiAgICAgICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHNhcmRpbiBjb2xsaXNpb24gZmllbGRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZVN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggXG4gICAgICovXG4gICAgZGlzcGxheUNvbGxpc2lvbkZpZWxkKGNwLCBzdHJva2VTdHlsZSwgbGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGMyLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5zZWEuRF9DT0wgKiAwLjUgLyBjcC5nZXRaZigpLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5zdHJva2UoKTtcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBTYXJkaW4gfSBmcm9tICcuL1NhcmRpbic7XG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tICcuLi9iYXNlL1NwYXRpYWxJbmRleCc7XG5pbXBvcnQgeyByZW1vdmVGcm9tQXJyYXkgfSBmcm9tICcuLi9iYXNlL2xpYic7XG5cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIFNlYSB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaCBcbiAgICAgKi8gICAgICAgIC8vZ2V0IDEwIHJhbmRvbSBsb2NhdGlvbnNcblxuICAgIGNvbnN0cnVjdG9yKHcsIGgpIHtcblxuICAgICAgICAvL1RPRE8gc2hvdWxkIGJlY29tZSBzdGF0aWMgYXR0cmlidXRlcyBvZiBTYXJkaW4gY2xhc3NcblxuICAgICAgICAvL29ic2VydmF0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkRfT0JTID0gNTBcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuQV9PQlMgPSAyMDAgKiBNYXRoLlBJIC8gMTgwXG5cbiAgICAgICAgLy9jb2xsaXNpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuRF9DT0wgPSAxMFxuXG4gICAgICAgIC8vc3BlZWRcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuVl9UQVJHRVQgPSAwLjNcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuVl9NQVggPSAwLjZcblxuICAgICAgICAvL3NoYXJrXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkRfU0hBUktfRUFUID0gMTJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuRUFURU5fU0FSRElOX05CID0gMFxuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBoO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMuZmlzaCA9IFtdXG5cbiAgICAgICAgLy9UT0RPXG4gICAgICAgIHRoaXMuc2hhcmsgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMua2lsbGVkID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgc3RlcCh0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL2luaVxuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuZmlzaCkge1xuICAgICAgICAgICAgZi5jb21wdXRlU3BlZWQoKVxuICAgICAgICAgICAgZi5jb21wdXRlU3BlZWRBbmdsZSgpXG4gICAgICAgIH1cblxuICAgICAgICAvL21ha2Ugc3BhdGlhbCBpbmRleFxuICAgICAgICAvKiogQHR5cGUge1NwYXRpYWxJbmRleC48U2FyZGluPn0gKi9cbiAgICAgICAgY29uc3Qgc2luZGV4ID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuICAgICAgICBzaW5kZXgubG9hZCh0aGlzLmZpc2gpXG5cbiAgICAgICAgLy9vYnNlcnZlXG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5maXNoKVxuICAgICAgICAgICAgZi5vYnNlcnZlKHNpbmRleCk7XG5cbiAgICAgICAgLy9zaGFyayBlYXQgZmlzaFxuICAgICAgICB0aGlzLnNoYXJrRWF0KHNpbmRleCk7XG5cbiAgICAgICAgLy9kaXNwb3NlIHNwYXRpYWwgaW5kZXhcbiAgICAgICAgLy9zaW5kZXguY2xlYXIoKVxuXG4gICAgICAgIC8vbW92ZVxuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuZmlzaClcbiAgICAgICAgICAgIGYubW92ZSh0aW1lU3RlcE1zKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3BhdGlhbEluZGV4LjxTYXJkaW4+fSBzaW5kZXggXG4gICAgICovXG4gICAgc2hhcmtFYXQoc2luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNoYXJrID09IG51bGwpIHJldHVybjtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICB0aGlzLmtpbGxlZCA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnNoYXJrLngsIHkgPSB0aGlzLnNoYXJrLnk7XG4gICAgICAgIGNvbnN0IHNzID0gc2luZGV4LmdldCh4IC0gdGhpcy5EX1NIQVJLX0VBVCwgeSAtIHRoaXMuRF9TSEFSS19FQVQsIHggKyB0aGlzLkRfU0hBUktfRUFULCB5ICsgdGhpcy5EX1NIQVJLX0VBVCk7XG4gICAgICAgIGZvciAobGV0IHMgb2Ygc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KCh4IC0gcy54KSwgKHkgLSBzLnkpKTtcbiAgICAgICAgICAgIGlmIChkID4gdGhpcy5EX1NIQVJLX0VBVCkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLmtpbGxlZC5wdXNoKHMpO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuZmlzaCwgcylcbiAgICAgICAgICAgIC8vc2luZGV4LnJlbW92ZShzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkVBVEVOX1NBUkRJTl9OQiArPSB0aGlzLmtpbGxlZC5sZW5ndGg7XG4gICAgICAgIC8vZWF0ZW5GaXNoTmIuc2V0VGV4dChcIkVhdGVuIGZpc2g6IFwiICsgRUFURU5fU0FSRElOX05CKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGZpc2hcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkRmlzaChuYiA9IDEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKVxuICAgICAgICAgICAgdGhpcy5maXNoLnB1c2gobmV3IFNhcmRpbih0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHJhbmRvbSBzcGVlZCBmb3IgYWxsIGZpc2hcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRSYW5kb21TcGVlZCgpIHtcbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmZpc2gpXG4gICAgICAgICAgICBmLnNldFJhbmRvbVNwZWVkKClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBTZWEgfSBmcm9tICcuL1NlYSc7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5cbmNsYXNzIEZpc2hTaW11bGF0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgb3B0cy5jYW52YXNJZCA9IG9wdHMuY2FudmFzSWQgfHwgXCJ2YWNhbnZhc1wiO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRzLmNhbnZhc0lkKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gb3B0cy53IHx8IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8vVE9ET1xuICAgICAgICAvL2FkZCBlYXRlbiBmaXNoIG5iIGxhYmVsXG5cbiAgICAgICAgLyoqIEB0eXBlIHtHZW9DYW52YXN9ICovXG4gICAgICAgIHRoaXMuY3BsdXMgPSBuZXcgR2VvQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zaG93RmlzaFZpc2lvbkZpZWxkID0gZmFsc2VcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dGaXNoVmlzaW9uTGlua3MgPSBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd0Zpc2hDb2xsaXNpb25GaWVsZCA9IGZhbHNlXG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aC5zZWFcblxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9jbGVhclxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJyZ2JhKDEyMCwxMjAsMjU1LDAuNilcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuXG4gICAgICAgICAgICB0aGlzLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgICAgIC8vc2hvdyB2aXNpb24gZmllbGRcbiAgICAgICAgICAgIGlmICh0aC5zaG93RmlzaFZpc2lvbkZpZWxkKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNhIG9mIHMuZmlzaClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KHNhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhLmRpc3BsYXlWaXNpb25GaWVsZCh0aGlzLCBcInJnYmEoMjAwLDIwMCwyMDAsMC4xNSlcIiwgMSlcbiAgICAgICAgICAgIC8vc2hvdyB2aXNpb24gbGlua3NcbiAgICAgICAgICAgIGlmICh0aC5zaG93RmlzaFZpc2lvbkxpbmtzKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNhIG9mIHMuZmlzaClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KHNhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhLmRpc3BsYXlWaXNpb25MaW5rcyh0aGlzLCBcInJnYmEoMjU1LDEwMCwxMDAsMC4zKVwiLCAxKVxuICAgICAgICAgICAgLy9zaG93IGNvbGxpc2lvbiBmaWVsZFxuICAgICAgICAgICAgaWYgKHRoLnNob3dGaXNoQ29sbGlzaW9uRmllbGQpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5maXNoKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoc2EpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2EuZGlzcGxheUNvbGxpc2lvbkZpZWxkKHRoaXMsIFwicHVycGxlXCIsIDEpXG5cblxuICAgICAgICAgICAgLy9kaXNwbGF5IHNhcmRpbnNcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDJcbiAgICAgICAgICAgIGNvbnN0IHNhcmRpbkxlbmd0aCA9IDdcbiAgICAgICAgICAgIGZvciAobGV0IHNhIG9mIHMuZmlzaClcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoc2EpKVxuICAgICAgICAgICAgICAgICAgICBzYS5kaXNwbGF5KHRoaXMsIHNhcmRpbkxlbmd0aClcblxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgc2hhcmtcbiAgICAgICAgICAgIGlmIChzLnNoYXJrICE9IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDRcbiAgICAgICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIlxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcmtMZW5ndGggPSAxMlxuICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gc2hhcmtMZW5ndGggKiBNYXRoLmNvcyhzLnNoYXJrLmFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeSA9IHNoYXJrTGVuZ3RoICogTWF0aC5zaW4ocy5zaGFyay5hbmdsZSk7XG5cbiAgICAgICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5tb3ZlVG8ocy5zaGFyay54LCBzLnNoYXJrLnkpO1xuICAgICAgICAgICAgICAgIGMyLmxpbmVUbyhzLnNoYXJrLnggLSBkeCwgcy5zaGFyay55ICsgZHkpO1xuICAgICAgICAgICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgYmxvb2Qgc3BvdFxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDFcbiAgICAgICAgICAgIGZvciAobGV0IHNhIG9mIHMua2lsbGVkKSB7XG4gICAgICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgYzIubW92ZVRvKHNhLngsIHNhLnkpO1xuICAgICAgICAgICAgICAgIGMyLmFyYyhzYS54LCBzYS55LCA0LCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgYzIuZmlsbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY3BsdXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgZSA9PiB7XG4gICAgICAgICAgICB0aC5zZWEuc2hhcmsgPSB7IHg6IHRoLmNwbHVzLnBpeFRvR2VvWChlLm9mZnNldFgpLCB5OiB0aC5jcGx1cy5waXhUb0dlb1koZS5vZmZzZXRZKSwgYW5nbGU6IDAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jcGx1cy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHhHID0gdGguY3BsdXMucGl4VG9HZW9YKGUub2Zmc2V0WCk7XG4gICAgICAgICAgICBjb25zdCB5RyA9IHRoLmNwbHVzLnBpeFRvR2VvWShlLm9mZnNldFkpO1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKC15RyArIHRoLnNlYS5zaGFyay55LCB4RyAtIHRoLnNlYS5zaGFyay54KTtcbiAgICAgICAgICAgIHRoLnNlYS5zaGFyayA9IHsgeDogeEcsIHk6IHlHLCBhbmdsZTogYW5nbGUgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jcGx1cy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIGUgPT4ge1xuICAgICAgICAgICAgdGguc2VhLnNoYXJrID0gbnVsbDtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKiogQHR5cGUge1NlYX0gKi9cbiAgICAgICAgdGhpcy5zZWEgPSBuZXcgU2VhKHRoaXMudywgdGhpcy5oKVxuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVuc2l0eSBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBpbml0UmFuZG9tKGRlbnNpdHkgPSAwLjAwMSkge1xuICAgICAgICB0aGlzLnNlYS5hZGRGaXNoKGRlbnNpdHkgKiB0aGlzLnNlYS53ICogdGhpcy5zZWEuaCk7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQuc2VhLnN0ZXAodGltZVN0ZXBNcyk7XG4gICAgICAgICAgICB0LmNwbHVzLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKG5iSXRlcmF0aW9ucyA+IDAgJiYgaSsrID4gbmJJdGVyYXRpb25zKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5naW5lLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW5naW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCBmaXNoID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IEZpc2hTaW11bGF0aW9uKG9wdHMpXG59XG4iLCIvL0B0cy1jaGVja1xuXG4vKipcbiAqIFxuICovXG5leHBvcnQgY2xhc3MgQ2VsbCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSwgbmI9MCkge1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5uYiA9IG5iXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgb2JqVG9BcnJheSB9IGZyb20gJy4uL2Jhc2UvbGliJztcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4uL2Jhc2UvR2VvQ2FudmFzJztcbmltcG9ydCB7IENlbGwgfSBmcm9tICcuL0NlbGwnO1xuXG4vKipcbiAqIFxuICovXG5leHBvcnQgY2xhc3MgVW5pdmVyc2Uge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHcsIGgpIHtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48Q2VsbD59ICovXG4gICAgICAgIHRoaXMucG9wdWxhdGlvbiA9IFtdO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLENlbGw+fSAqL1xuICAgICAgICB0aGlzLnBvcHVsYXRpb25JID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtDZWxsfG51bGx9XG4gICAgICovXG4gICAgYWRkKHgsIHkpIHtcblxuICAgICAgICAvL2ZpbmQgY2VsbCBhdCBsb2NhdGlvblxuICAgICAgICAvKipAdHlwZSB7c3RyaW5nfSovXG4gICAgICAgIGNvbnN0IGlkID0geCArIFwiX1wiICsgeTtcbiAgICAgICAgaWYgKHRoaXMucG9wdWxhdGlvbklbaWRdKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvL2NyZWF0ZSBuZXcgY2VsbFxuICAgICAgICAvKipAdHlwZSB7Q2VsbH0gKi9cbiAgICAgICAgY29uc3QgY2VsbCA9IG5ldyBDZWxsKHgsIHksIDApXG4gICAgICAgIHRoaXMucG9wdWxhdGlvbi5wdXNoKGNlbGwpXG4gICAgICAgIHRoaXMucG9wdWxhdGlvbklbaWRdID0gY2VsbFxuICAgICAgICByZXR1cm4gY2VsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0ZXAoKSB7XG5cbiAgICAgICAgLy9UT0RPIGRvdWJsZSBpbmRleGluZz8gYnkgcmF3IGFuZCB0aGVuIGNvbHVtbiA/XG4gICAgICAgIC8vcG9wdWxhdGUgY2VsbCBzdXJyb3VuZGluZ3NcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQ2VsbD59XG4gICAgICAgICAqIEBkaWN0ICovXG4gICAgICAgIGNvbnN0IHN1ckkgPSB7fTtcbiAgICAgICAgLy9nbyB0aHJvdWdoIGxpc3Qgb2YgY2VsbHNcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiB0aGlzLnBvcHVsYXRpb24pIHtcbiAgICAgICAgICAgIC8vICsxIHN1cnJvdW5kaW5nIGNlbGxzXG4gICAgICAgICAgICBjb25zdCBzcnMgPSBVbml2ZXJzZS5nZXRDZWxsU3Vycm91bmRpbmcoY2VsbCwgdGhpcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBzdXIgb2Ygc3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gc3VyLnggKyBcIl9cIiArIHN1ci55O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1cl8gPSBzdXJJW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHN1cl8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VyXy5uYisrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1ci5uYiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN1cklba2V5XSA9IHN1cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL0IzL1MyM1xuICAgICAgICAvL2tpbGwgY2VsbHNcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48Q2VsbD59ICovXG4gICAgICAgIGNvbnN0IGNlbGxzVG9LZWVwID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENlbGw+fVxuICAgICAgICAgKiBAZGljdCAqL1xuICAgICAgICBjb25zdCBjZWxsc1RvS2VlcEkgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiB0aGlzLnBvcHVsYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGNlbGwueCArIFwiX1wiICsgY2VsbC55O1xuICAgICAgICAgICAgY29uc3QgY2VsbF8gPSBzdXJJW2tleV07XG4gICAgICAgICAgICBpZiAoIWNlbGxfKSBjb250aW51ZTtcbiAgICAgICAgICAgIC8vaWYgKG5iPDIgb3IgbmI+MykgLT4ga2lsbFxuICAgICAgICAgICAgaWYgKGNlbGxfLm5iIDwgMiB8fCBjZWxsXy5uYiA+IDMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2VsbHNUb0tlZXAucHVzaChjZWxsKTtcbiAgICAgICAgICAgIGNlbGxzVG9LZWVwSVtrZXldID0gY2VsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcHVsYXRpb24gPSBjZWxsc1RvS2VlcDtcbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uSSA9IGNlbGxzVG9LZWVwSTtcblxuICAgICAgICAvL2NyZWF0ZSBuZXcgY2VsbHNcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48Q2VsbD59ICovXG4gICAgICAgIGNvbnN0IHN1cnMgPSBvYmpUb0FycmF5KHN1ckkpO1xuICAgICAgICBmb3IgKGxldCBzdXIgb2Ygc3Vycykge1xuXG4gICAgICAgICAgICBpZiAoc3VyLm5iICE9PSAzKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy9jaGVjayBpZiBhbHJlYWR5IGFsaXZlXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBzdXIueCArIFwiX1wiICsgc3VyLnk7XG4gICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMucG9wdWxhdGlvbklba2V5XTtcbiAgICAgICAgICAgIGlmIChjZWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy9jcmVhdGUgbmV3IGNlbGxcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGlvbi5wdXNoKHN1cik7XG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRpb25JW2tleV0gPSBzdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1TXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwbHVzXG4gICAgICogQHJldHVybiB7VW5pdmVyc2V9XG4gICAgICovXG4gICAgc3RhcnQobmIsIHRpbWVvdXRNUywgY3BsdXMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCB1bmkgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGkpO1xuICAgICAgICAgICAgdW5pLnN0ZXAoKTtcbiAgICAgICAgICAgIGNwbHVzLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKG5iID4gMCAmJiBpKysgPiBuYikgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIHRpbWVvdXRNUyk7XG4gICAgICAgIH07XG4gICAgICAgIGVuZ2luZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NlbGx9IGNlbGxcbiAgICAgKiBAcGFyYW0ge1VuaXZlcnNlfSB1bmlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48Q2VsbD59XG4gICAgICovXG4gICAgc3RhdGljIGdldENlbGxTdXJyb3VuZGluZyhjZWxsLCB1bmkpIHtcbiAgICAgICAgY29uc3QgeDEgPSBjZWxsLnggPT09IDAgPyB1bmkudyAtIDEgOiBjZWxsLnggLSAxO1xuICAgICAgICBjb25zdCB4MiA9IGNlbGwueCA9PT0gdW5pLncgLSAxID8gMCA6IGNlbGwueCArIDE7XG4gICAgICAgIGNvbnN0IHkxID0gY2VsbC55ID09PSAwID8gdW5pLmggLSAxIDogY2VsbC55IC0gMTtcbiAgICAgICAgY29uc3QgeTIgPSBjZWxsLnkgPT09IHVuaS5oIC0gMSA/IDAgOiBjZWxsLnkgKyAxO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IENlbGwoeDEsIHkxKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgxLCBjZWxsLnkpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDEsIHkyKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKGNlbGwueCwgeTEpLFxuICAgICAgICAgICAgbmV3IENlbGwoY2VsbC54LCB5MiksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MiwgeTEpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDIsIGNlbGwueSksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MiwgeTIpLFxuICAgICAgICBdO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4uL2Jhc2UvR2VvQ2FudmFzJztcbmltcG9ydCB7IFVuaXZlcnNlIH0gZnJvbSAnLi9Vbml2ZXJzZSc7XG5pbXBvcnQgeyBDZWxsIH0gZnJvbSAnLi9DZWxsJztcblxuLy9UT0RPIHpvb20vcGFuLCB3aXRoIGNhbnZhcyB0cmFuc2Zvcm06IGJldHRlciB1bml2ZXJzZSBsaW1pdHNcbi8vVE9ETyBidXR0b25zIChwbGF5LCBzdG9wLCBzcGVlZCwgZHJhdywgcGFuKVxuLy9UT0RPIGNoZWNrIGNhbnZhcyBhbmltYXRpb25cblxuXG5jbGFzcyBHb0xTaW11bGF0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgb3B0cy5jYW52YXNJZCA9IG9wdHMuY2FudmFzSWQgfHwgXCJ2YWNhbnZhc1wiO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRzLmNhbnZhc0lkKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gb3B0cy53IHx8IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuXG4gICAgICAgIGNvbnN0IHRoID0gdGhpcztcbiAgICAgICAgdGhpcy5jcGx1cy5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuY3R4XG5cbiAgICAgICAgICAgIC8vY2xlYXJcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcblxuICAgICAgICAgICAgLy9kcmF3IGNlbGxzXG4gICAgICAgICAgICB0aGlzLnNldENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcImJsdWVcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2YgdGgudW5pLnBvcHVsYXRpb24pXG4gICAgICAgICAgICAgICAgYzIuZmlsbFJlY3QoKGNlbGwueCksIChjZWxsLnkpLCAxLCAxKTtcblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudW5pID0gbmV3IFVuaXZlcnNlKHRoaXMudywgdGhpcy5oKTtcbiAgICB9XG5cblxuICAgIC8vXG4gICAgaW5pdFJhbmRvbShkZW5zaXR5ID0gMC4wNSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBjb25zdCBuYiA9IHRoaXMudW5pLncgKiB0aGlzLnVuaS5oICogZGVuc2l0eTtcbiAgICAgICAgd2hpbGUgKGkgPCBuYikge1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQodGhpcy51bmkudyAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodGhpcy51bmkuaCAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtDZWxsfSAqL1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMudW5pLmFkZCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChjZWxsKSBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnVuaS5zdGFydCgtMSwgMCwgdGhpcy5jcGx1cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufVxuXG5cbmV4cG9ydCBjb25zdCBnYW1lT2ZMaWZlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IEdvTFNpbXVsYXRpb24ob3B0cylcbn1cbiIsIi8vQHRzLWNoZWNrXG5cbmV4cG9ydCAqIGZyb20gXCIuL3BsYW5ldHMvaW5kZXhcIlxuZXhwb3J0ICogZnJvbSBcIi4vZ29sL2luZGV4XCJcbmV4cG9ydCAqIGZyb20gXCIuL2Zpc2gvaW5kZXhcIlxuZXhwb3J0ICogZnJvbSBcIi4vcHAvaW5kZXhcIlxuZXhwb3J0ICogZnJvbSBcIi4vdXJiYW4vaW5kZXhcIlxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFVuaXZlcnNlIH0gZnJvbSBcIi4vVW5pdmVyc2VcIjtcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gXCIuLi9iYXNlL0dlb0NhbnZhc1wiXG5pbXBvcnQgeyBBZ2VudFBvaW50IH0gZnJvbSBcIi4uL2Jhc2UvQWdlbnRQb2ludFwiO1xuXG5leHBvcnQgY2xhc3MgUGxhbmV0IGV4dGVuZHMgQWdlbnRQb2ludCB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1VuaXZlcnNlfSB1IFRoZSB1bml2ZXJzZSB0aGUgcGxhbmV0IGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG0gVGhlIG1hc3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzcGVlZCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN5IFRoZSBzcGVlZCB5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodSwgbSwgeCwgeSwgc3ggPSAwLCBzeSA9IDApIHtcblxuICAgICAgICAvL1xuICAgICAgICBzdXBlcih4LCB5LCBzeCwgc3kpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtVbml2ZXJzZX0gKi9cbiAgICAgICAgdGhpcy51ID0gdTtcbiAgICAgICAgdS5wcy5wdXNoKHRoaXMpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubSA9IG07XG5cbiAgICAgICAgLy9jb21wdXRlIHJhZGl1c1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3QgciA9IHRoaXMucigpO1xuXG4gICAgICAgIC8vc2V0IHBvc2l0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4IDwgciA/IHIgOiB4ID4gdS53IC0gciA/IHUudyAtIHIgOiB4O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geSA8IHIgPyByIDogeSA+IHUuaCAtIHIgPyB1LmggLSByIDogeTtcblxuICAgICAgICAvL2FjY2VsZXJhdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5heCA9IDA7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmF5ID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGZvcmNlLCBiYXNlZCBvbiB0aGUgZ3Jhdml0eSBvZiBvdGhlciBwbGFuZXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICAgICAqL1xuICAgIG9ic2VydmUoZXhwb25lbnQpIHtcblxuICAgICAgICAvL2NvbXB1dGUgZ3Jhdml0eSBmaWVsZCBhdCBwbGFuZXQgbG9jYXRpb25cbiAgICAgICAgY29uc3QgZyA9IHRoaXMudS5nZXRHcmF2aXR5RmllbGQodGhpcy54LCB0aGlzLnksIHRoaXMsIGV4cG9uZW50KTtcblxuICAgICAgICAvL3NldCBhY2NlbGVyYXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXggPSBnLmd4O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5heSA9IGcuZ3k7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIHBsYW5ldCwgZGVwZW5kaW5nIG9uIGl0cyBtYXNzLlxuICAgICAqL1xuICAgIHIoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyh0aGlzLm0gLyBNYXRoLlBJLCAwLjUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtib29sZWFufSBib3VuY2UgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIGNoYW5nZShib3VuY2UgPSBmYWxzZSwgbWF4U3BlZWQgPSAwLjgsIHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBuZXcgc3BlZWRcbiAgICAgICAgdGhpcy5zeCArPSB0aGlzLmF4ICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy5zeSArPSB0aGlzLmF5ICogdGltZVN0ZXBNcztcblxuICAgICAgICAvL2NoZWNrIHZtYXhcbiAgICAgICAgaWYgKG1heFNwZWVkID4gMCkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICBjb25zdCB2ID0gTWF0aC5zcXJ0KHRoaXMuc3ggKiB0aGlzLnN4ICsgdGhpcy5zeSAqIHRoaXMuc3kpO1xuICAgICAgICAgICAgaWYgKHYgPiBtYXhTcGVlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ggPSBtYXhTcGVlZCAqIHRoaXMuc3ggLyB2O1xuICAgICAgICAgICAgICAgIHRoaXMuc3kgPSBtYXhTcGVlZCAqIHRoaXMuc3kgLyB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jb21wdXRlIG5ldyBwb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IG54ID0gdGhpcy54ICsgdGhpcy5zeCAqIHRpbWVTdGVwTXM7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgbnkgPSB0aGlzLnkgKyB0aGlzLnN5ICogdGltZVN0ZXBNcztcblxuICAgICAgICAvL2hhbmRsZSBwb3NpdGlvbiBsaW1pdFxuICAgICAgICBpZiAoYm91bmNlKSB7XG4gICAgICAgICAgICBjb25zdCByID0gdGhpcy5yKCk7XG4gICAgICAgICAgICBjb25zdCBlID0gMTtcbiAgICAgICAgICAgIGlmIChueCA8IHIpIHsgbnggPSByOyB0aGlzLnN4ID0gLXRoaXMuc3ggKiBlOyB9XG4gICAgICAgICAgICBpZiAobnkgPCByKSB7IG55ID0gcjsgdGhpcy5zeSA9IC10aGlzLnN5ICogZTsgfVxuICAgICAgICAgICAgaWYgKG54ID4gdGhpcy51LncgLSByKSB7IG54ID0gdGhpcy51LncgLSByOyB0aGlzLnN4ID0gLXRoaXMuc3ggKiBlOyB9XG4gICAgICAgICAgICBpZiAobnkgPiB0aGlzLnUuaCAtIHIpIHsgbnkgPSB0aGlzLnUuaCAtIHI7IHRoaXMuc3kgPSAtdGhpcy5zeSAqIGU7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChueCA8IDApIHsgbnggPSB0aGlzLnUudzsgfVxuICAgICAgICAgICAgaWYgKG55IDwgMCkgeyBueSA9IHRoaXMudS5oOyB9XG4gICAgICAgICAgICBpZiAobnggPiB0aGlzLnUudykgeyBueCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChueSA+IHRoaXMudS5oKSB7IG55ID0gMDsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9tb3ZlXG4gICAgICAgIHRoaXMueCA9IG54O1xuICAgICAgICB0aGlzLnkgPSBueTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgcGxhbmV0XG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxsU3R5bGUgXG4gICAgICovXG4gICAgZGlzcGxheShjcCwgZmlsbFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yKCkgLyBjcC5nZXRaZigpLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5maWxsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBwbGFuZXQgYWNjZWxlcmF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJva2VTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgXG4gICAgICovXG4gICAgZGlzcGxheUFjY2VsZXJhdGlvbihjcCwgc3Ryb2tlU3R5bGUgPSBcImN5YW5cIiwgbGluZVdpZHRoID0gMSwgZmFjdG9yID0gNTAwMCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLm1vdmVUbyh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGMyLmxpbmVUbyh0aGlzLnggKyBmYWN0b3IgKiB0aGlzLmF4LCB0aGlzLnkgKyBmYWN0b3IgKiB0aGlzLmF5KTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLnN0cm9rZSgpO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IHJlbW92ZUZyb21BcnJheSB9IGZyb20gJy4uL2Jhc2UvbGliJztcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcbmltcG9ydCB7IFBsYW5ldCB9IGZyb20gJy4vUGxhbmV0JztcblxuZXhwb3J0IGNsYXNzIFVuaXZlcnNlIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBoO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFBsYW5ldD59ICovXG4gICAgICAgIHRoaXMucHMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtYXNzIG9mIHRoZSB1bml2ZXJzZSwgYXMgdGhlIHN1bSBvZiB0aGUgbWFzcyBvZiBpdHMgcGxhbmV0cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG0oKSB7XG4gICAgICAgIGxldCBtID0gMDtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKVxuICAgICAgICAgICAgbSArPSBwLm07XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHBhcmFtIHtQbGFuZXR9IHBJZ25vcmUgQSBwbGFuZXQgdG8gaWdub3JlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAgICogQHJldHVybnMge3tneDpudW1iZXIsZ3k6bnVtYmVyfX1cbiAgICAgKi9cbiAgICBnZXRHcmF2aXR5RmllbGQoeCwgeSwgcElnbm9yZSA9IHVuZGVmaW5lZCwgZXhwb25lbnQgPSAyKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBneCA9IDBcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBneSA9IDBcblxuICAgICAgICAvL2dvdGhyb3VnaCBhbGwgcGxhbmV0cyBpbiB0aGUgdW5pdmVyc2VcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKSB7XG5cbiAgICAgICAgICAgIC8vaWdub3JlIHBsYW5ldFxuICAgICAgICAgICAgaWYgKHBJZ25vcmUgJiYgcCA9PSBwSWdub3JlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL2NvbXB1dGUgZGlzdGFuY2VcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgbGV0IGQgPSBwLmRQKHgsIHkpO1xuICAgICAgICAgICAgaWYgKGQgPT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBhbmQgYWRkIGNvbnRyaWJ1dGlvblxuICAgICAgICAgICAgZCA9IGQgKiBNYXRoLnBvdyhkLCBleHBvbmVudCk7XG4gICAgICAgICAgICBneCArPSAwLjAxICogKHAueCAtIHgpICogcC5tIC8gZDtcbiAgICAgICAgICAgIGd5ICs9IDAuMDEgKiAocC55IC0geSkgKiBwLm0gLyBkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGd4OiBneCwgZ3k6IGd5IH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZSB0d28gcGxhbmV0c1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7UGxhbmV0fSBwMVxuICAgICAqIEBwYXJhbSB7UGxhbmV0fSBwMlxuICAgICAqIEBwYXJhbSB7U3BhdGlhbEluZGV4LjxQbGFuZXQ+fSBzaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7UGxhbmV0fVxuICAgICAqL1xuICAgIGFnZ3JlZ2F0ZShwMSwgcDIsIHNpbmRleCkge1xuICAgICAgICBjb25zdCBtID0gcDEubSArIHAyLm07XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUGxhbmV0KFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAocDEueCAqIHAxLm0gKyBwMi54ICogcDIubSkgLyBtLFxuICAgICAgICAgICAgKHAxLnkgKiBwMS5tICsgcDIueSAqIHAyLm0pIC8gbSxcbiAgICAgICAgICAgIChwMS5zeCAqIHAxLm0gKyBwMi5zeCAqIHAyLm0pIC8gbSxcbiAgICAgICAgICAgIChwMS5zeSAqIHAxLm0gKyBwMi5zeSAqIHAyLm0pIC8gbVxuICAgICAgICApO1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5wcywgcDEpO1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5wcywgcDIpO1xuXG4gICAgICAgIGlmIChzaW5kZXgpIHtcbiAgICAgICAgICAgIHNpbmRleC5yZW1vdmUocDEpXG4gICAgICAgICAgICBzaW5kZXgucmVtb3ZlKHAyKVxuICAgICAgICAgICAgc2luZGV4Lmluc2VydChwKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3BhdGlhbEluZGV4LjxQbGFuZXQ+fSBzaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sbGlzaW9uRmFjdG9yXG4gICAgICogQHJldHVybnMge0FycmF5LjxQbGFuZXQ+fVxuICAgICAqL1xuICAgIGZpbmRDb2xsaXNpb24oc2luZGV4LCBjb2xsaXNpb25GYWN0b3IgPSAxKSB7XG4gICAgICAgIGZvciAobGV0IHBpIG9mIHRoaXMucHMpIHtcblxuICAgICAgICAgICAgY29uc3QgdyA9IDIgKiBwaS5yKCk7XG4gICAgICAgICAgICBjb25zdCBjYW5kID0gc2luZGV4LmdldChwaS54IC0gdywgcGkueSAtIHcsIHBpLnggKyB3LCBwaS55ICsgdyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHBqIG9mIGNhbmQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwaSA9PSBwaikgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBkMSA9IHBpLmQocGopO1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGQyID0gKHBpLnIoKSArIHBqLnIoKSkgKiBjb2xsaXNpb25GYWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKGQxID4gZDIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGksIHBqXTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQWRkIHBsYW5ldHMgd2l0aCByYW5kb20gc3BlZWRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGFkZFBsYW5ldHMobmIgPSAxLCBtaSA9IDAuNSwgbWluU3BlZWQgPSAwLCBtYXhTcGVlZCA9IDAuMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUGxhbmV0KHRoaXMsIG1pLCB0aGlzLncgKiBNYXRoLnJhbmRvbSgpLCB0aGlzLmggKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgIHAuc2V0UmFuZG9tU3BlZWQobWluU3BlZWQsIG1heFNwZWVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtib29sZWFufSBib3VuY2UgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZtYXggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xsaXNpb25GYWN0b3IgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RlcChib3VuY2UgPSBmYWxzZSwgdm1heCA9IDAuOCwgZXhwb25lbnQgPSAyLCBjb2xsaXNpb25GYWN0b3IgPSAxLCB0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL29ic2VydmF0aW9uXG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIHAub2JzZXJ2ZShleHBvbmVudCk7XG5cbiAgICAgICAgLy9hY3Rpb25cbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKVxuICAgICAgICAgICAgcC5jaGFuZ2UoYm91bmNlLCB2bWF4LCB0aW1lU3RlcE1zKTtcblxuXG4gICAgICAgIC8vY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgICB0aGlzLmRldGVjdENvbGxpc2lvbnMoY29sbGlzaW9uRmFjdG9yKVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xsaXNpb25GYWN0b3IgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgZGV0ZWN0Q29sbGlzaW9ucyhjb2xsaXNpb25GYWN0b3IgPSAxKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPFBsYW5ldD59ICovXG4gICAgICAgIGNvbnN0IHNpbmRleCA9IG5ldyBTcGF0aWFsSW5kZXgoKTtcbiAgICAgICAgc2luZGV4LmxvYWQodGhpcy5wcylcblxuICAgICAgICAvL2ZpbmQgZmlyc3QgY29sbGlzaW9uXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFBsYW5ldD59ICovXG4gICAgICAgIGxldCBwYWlyID0gdGhpcy5maW5kQ29sbGlzaW9uKHNpbmRleCwgY29sbGlzaW9uRmFjdG9yKTtcbiAgICAgICAgd2hpbGUgKHBhaXIgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgLy9hZ2dyZWdhdGVcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmFnZ3JlZ2F0ZShwYWlyWzBdLCBwYWlyWzFdLCBzaW5kZXgpXG5cbiAgICAgICAgICAgIC8vZmluZCBuZXh0IGNvbGxpc2lvblxuICAgICAgICAgICAgcGFpciA9IHRoaXMuZmluZENvbGxpc2lvbihzaW5kZXgsIGNvbGxpc2lvbkZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiByYW5kb20gc3BlZWQgdG8gYWxsIHBsYW5ldHNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFJhbmRvbVNwZWVkKG1pblNwZWVkID0gMCwgbWF4U3BlZWQgPSAwLjEpIHtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKVxuICAgICAgICAgICAgcC5zZXRSYW5kb21TcGVlZChtaW5TcGVlZCwgbWF4U3BlZWQpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BsYW5ldH0gVGhlIGxhcmdlc3QgcGxhbmV0IG9mIHRoZSB1bml2ZXJzZSwgdXN1YWxseSB0aGUgc3Rhci5cbiAgICAgKi9cbiAgICBnZXRMYXJnZXN0UGxhbmV0KCkge1xuICAgICAgICBsZXQgcE0gPSBudWxsLCBtTSA9IDA7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIGlmIChwLm0gPiBtTSkgeyBwTSA9IHA7IG1NID0gcC5tIH1cbiAgICAgICAgcmV0dXJuIHBNXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhcmdlc3QgcGxhbmV0IGFuZCBleHBsb2RlIGl0LlxuICAgICAqL1xuICAgIGV4cGxvZGVMYXJnZXN0UGxhbmV0KCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRMYXJnZXN0UGxhbmV0KClcbiAgICAgICAgdGhpcy5leHBsb2RlKHApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwbG9kZSBhIHBsYW5ldCBpbnRvIHBpZWNlc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7UGxhbmV0fSBwIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWQgXG4gICAgICovXG4gICAgZXhwbG9kZShwLCBuYiA9IC0xLCBtaW5TcGVlZCA9IDAuOCwgbWF4U3BlZWQgPSAxLjUsIHJhZCA9IC0xKSB7XG4gICAgICAgIGlmIChuYiA8PSAwKSBuYiA9IE1hdGguZmxvb3IocC5tKTtcbiAgICAgICAgaWYgKG5iIDw9IDApIHJldHVybjtcbiAgICAgICAgY29uc3QgYW5nbGVTdGVwID0gMiAqIE1hdGguUEkgLyBuYjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XG4gICAgICAgICAgICAvL2NyZWF0ZSBwbGFuZXRcblxuICAgICAgICAgICAgLy9wb3NpdGlvblxuICAgICAgICAgICAgaWYgKHJhZCA8IDApIHJhZCA9IDIgKiBwLnIoKVxuICAgICAgICAgICAgY29uc3QgZCA9IHJhZCAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICBjb25zdCBhID0gaSAqIGFuZ2xlU3RlcDtcbiAgICAgICAgICAgIGNvbnN0IHggPSBkICogTWF0aC5jb3MoYSksIHkgPSBkICogTWF0aC5zaW4oYSk7XG5cbiAgICAgICAgICAgIC8vc3BlZWRcbiAgICAgICAgICAgIGNvbnN0IHNwZWVkID0gbWluU3BlZWQgKyBNYXRoLnJhbmRvbSgpICogKG1heFNwZWVkIC0gbWluU3BlZWQpO1xuICAgICAgICAgICAgY29uc3QgYVMgPSBhICsgMiAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIgKiBNYXRoLlBJIC8gMztcbiAgICAgICAgICAgIGNvbnN0IHN4ID0gc3BlZWQgKiBNYXRoLmNvcyhhUyksIHN5ID0gc3BlZWQgKiBNYXRoLnNpbihhUyk7XG5cbiAgICAgICAgICAgIG5ldyBQbGFuZXQodGhpcywgcC5tIC8gbmIsIHAueCArIHgsIHAueSArIHksIHAuc3ggKyBzeCwgcC5zeSArIHN5KVxuICAgICAgICB9XG4gICAgICAgIC8vcmVtb3ZlIHAgZnJvbSB1bml2ZXJzZVxuICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5wcywgcCk7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgVW5pdmVyc2UgfSBmcm9tICcuL1VuaXZlcnNlJztcbmltcG9ydCB7IFBsYW5ldCB9IGZyb20gJy4vUGxhbmV0JztcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4uL2Jhc2UvR2VvQ2FudmFzJztcblxuLyoqICAqL1xuY2xhc3MgUGxhbmV0U2ltdWxhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG4gICAgICAgIGlmIChjYW52YXMgPT0gbnVsbCkgdGhyb3cgXCJObyBjYW52YXMgXCIgKyBvcHRzLmNhbnZhc0lkO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubWF4U3BlZWQgPSBvcHRzLm1heFNwZWVkIHx8IDAuODtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLmJvdW5jZSA9IG9wdHMuYm91bmNlIHx8IGZhbHNlXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmV4cG9uZW50ID0gb3B0cy5leHBvbmVudCB8fCAyO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5jb2xsaXNpb25GYWN0b3IgPSBvcHRzLmNvbGxpc2lvbkZhY3RvciB8fCAxO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zaG93UGxhbmV0QWNjZWxlcmF0aW9uID0gZmFsc2VcblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgIHRoaXMuc2hvd0ZpZWxkID0gdW5kZWZpbmVkXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmZpZWxkUmVzID0gMjBcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZmllbGRGYWN0b3IgPSAxMDAwXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICB0aGlzLmZpZWxkU3Ryb2tlU3R5bGUgPSBcIiM5OWJiZmZcIjtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy50YWlsaW5ncyA9IG9wdHMudGFpbGluZ3MgfHwgMC4xO1xuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtHZW9DYW52YXN9ICovXG4gICAgICAgIHRoaXMuY3BsdXMgPSBuZXcgR2VvQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpO1xuXG4gICAgICAgIGNvbnN0IHRoID0gdGhpcztcbiAgICAgICAgdGhpcy5jcGx1cy5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuY3R4XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAvL2NsZWFyLCB3aXRoIHRyYW5zcGFyZW5jeVxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLFwiICsgdGgudGFpbGluZ3MgKyBcIilcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgLy9jMi5maWxsUmVjdCgtMWUyMCwgLTFlMjAsIDJlMjAsIDJlMjApOyAvL3RvZG9cblxuICAgICAgICAgICAgLy9kaXNwbGF5IGdyYXZpdHkgZmllbGRcbiAgICAgICAgICAgIGlmICh0aC5zaG93RmllbGQgPT09IFwiZlwiKVxuICAgICAgICAgICAgICAgIHRoLmRpc3BsYXlHcmF2aXR5RmllbGQodGhpcywgdHJ1ZSlcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoLnNob3dGaWVsZCA9PT0gXCJpXCIpXG4gICAgICAgICAgICAgICAgdGguZGlzcGxheUdyYXZpdHlGaWVsZCh0aGlzLCBmYWxzZSlcblxuXG4gICAgICAgICAgICB0aGlzLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBwbGFuZXRzXG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoLnVuaS5wcykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50b0RyYXcocCkpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHAubSAvIHRoLnVuaS5tKCk7XG4gICAgICAgICAgICAgICAgcC5kaXNwbGF5KHRoaXMsIFwicmdiKDI1NSwyNTUsXCIgKyBNYXRoLmZsb29yKDI1NSAqICgxIC0gdCkpICsgXCIpXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBwbGFuZXRzIGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgaWYgKHRoLnNob3dQbGFuZXRBY2NlbGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoLnVuaS5wcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudG9EcmF3KHApKSBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBwLmRpc3BsYXlBY2NlbGVyYXRpb24odGhpcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZnJhbWVcbiAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJkYXJrZ3JheVwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMSAqIHRoLmNwbHVzLmdldFpmKCk7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLnJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqIEB0eXBlIHtVbml2ZXJzZX0gKi9cbiAgICAgICAgdGhpcy51bmkgPSBuZXcgVW5pdmVyc2UodGhpcy53LCB0aGlzLmgpXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWVsZCBcbiAgICAgKi9cbiAgICBkaXNwbGF5R3Jhdml0eUZpZWxkKGNwLCBmaWVsZCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5maWVsZFJlc1xuICAgICAgICBjb25zdCBmID0gdGhpcy5maWVsZEZhY3RvclxuICAgICAgICBjb25zdCBmXyA9IGZpZWxkID8gMC4zICogcmVzIDogMC42ICogcmVzO1xuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHRoaXMuZmllbGRTdHJva2VTdHlsZVxuICAgICAgICBmb3IgKGxldCB4ID0gcmVzICogMC41OyB4IDwgdGhpcy53OyB4ICs9IHJlcykge1xuICAgICAgICAgICAgY29uc3QgeEcgPSBjcC5waXhUb0dlb1goeCk7XG4gICAgICAgICAgICBpZiAoeEcgPiB0aGlzLnVuaS53IHx8IHhHIDwgMCkgY29udGludWVcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSByZXMgLyAyOyB5IDwgdGhpcy5oOyB5ICs9IHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHlHID0gY3AucGl4VG9HZW9ZKHkpO1xuICAgICAgICAgICAgICAgIGlmICh5RyA+IHRoaXMudW5pLmggfHwgeUcgPCAwKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIC8vZ2V0IGdyYXZpdHkgZmllbGRcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gdGhpcy51bmkuZ2V0R3Jhdml0eUZpZWxkKHhHLCB5RywgdW5kZWZpbmVkLCB0aGlzLmV4cG9uZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBnXyA9IE1hdGguaHlwb3QoZy5neCwgZy5neSlcblxuICAgICAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IE1hdGgubWluKGYgKiBnXywgMC4zICogcmVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeCA9IGZfICogZy5neCAvIGdfLCBkeSA9IGZfICogZy5neSAvIGdfXG5cbiAgICAgICAgICAgICAgICAvL2RyYXdcbiAgICAgICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ncmF2aXR5IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGMyLm1vdmVUbyh4IC0gZHgsIHkgKyBkeSk7XG4gICAgICAgICAgICAgICAgICAgIGMyLmxpbmVUbyh4ICsgZHgsIHkgLSBkeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pc29wb3RlbnRpYWwgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgYzIubW92ZVRvKHggKyBkeSwgeSArIGR4KTtcbiAgICAgICAgICAgICAgICAgICAgYzIubGluZVRvKHggLSBkeSwgeSAtIGR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2Ugd2l0aCByYW5kb20gcGxhbmV0c1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBpbml0UmFuZG9tKG5iID0gMTAwMCwgbWkgPSAwLjUsIG1pblNwZWVkID0gMCwgbWF4U3BlZWQgPSAwLjEpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48UGxhbmV0Pn0gKi9cbiAgICAgICAgdGhpcy51bmkucHMgPSBbXTtcbiAgICAgICAgdGhpcy51bmkuYWRkUGxhbmV0cyhuYiwgbWksIG1pblNwZWVkLCBtYXhTcGVlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2Ugd2l0aCBiaWcgYmFuZyBzZXR1cFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGluaXRCaWdCYW5nKG5iID0gMTAwMCwgbWkgPSAxLCBtaW5TcGVlZCA9IDAuMzUsIG1heFNwZWVkID0gMC43LCByYWQgPSAxMDApIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48UGxhbmV0Pn0gKi9cbiAgICAgICAgdGhpcy51bmkucHMgPSBbXTtcbiAgICAgICAgLy9jcmVhdGUgYmlnIHBsYW5ldCBpbiB0aGUgbWlkZGxlXG4gICAgICAgIGNvbnN0IGN4ID0gdGhpcy53ICogMC41LCBjeSA9IHRoaXMuaCAqIDAuNTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQbGFuZXQodGhpcy51bmksIG5iICogbWksIGN4LCBjeSwgMCwgMCk7XG4gICAgICAgIC8vZXhwbG9kZSBpdFxuICAgICAgICB0aGlzLnVuaS5leHBsb2RlKHAsIG5iLCBtaW5TcGVlZCwgbWF4U3BlZWQsIHJhZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgc2ltdWxhdGlvblxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYkl0ZXJhdGlvbnMgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RhcnQodGltZVN0ZXBNcyA9IDEwLCBuYkl0ZXJhdGlvbnMgPSAtMSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0LnVuaS5zdGVwKHQuYm91bmNlLCB0Lm1heFNwZWVkLCB0LmV4cG9uZW50LCB0LmNvbGxpc2lvbkZhY3RvciwgdGltZVN0ZXBNcyk7XG4gICAgICAgICAgICB0LmNwbHVzLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKG5iSXRlcmF0aW9ucyA+IDAgJiYgaSsrID4gbmJJdGVyYXRpb25zKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5naW5lLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW5naW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vc3RvcFxuICAgIHN0b3AoKSB7XG4gICAgICAgIC8vVE9ET1xuICAgIH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICovXG5leHBvcnQgY29uc3QgcGxhbmV0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBQbGFuZXRTaW11bGF0aW9uKG9wdHMpXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgTGFuZCB9IGZyb20gXCIuL0xhbmRcIlxuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCJcbmltcG9ydCB7IEFnZW50UG9pbnQgfSBmcm9tIFwiLi4vYmFzZS9BZ2VudFBvaW50XCJcblxuLyoqICovXG5leHBvcnQgY2xhc3MgQW5pbWFsIGV4dGVuZHMgQWdlbnRQb2ludCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZSBcbiAgICAgKiBAcGFyYW0ge0xhbmR9IGwgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSwgbCwgeCA9IDAsIHkgPSAwKSB7XG5cbiAgICAgICAgc3VwZXIoeCwgeSlcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLyoqIEB0eXBlIHtMYW5kfSAqL1xuICAgICAgICB0aGlzLmwgPSBsO1xuXG4gICAgICAgIC8vcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHggPCAwID8gMCA6IHggPiBsLncgPyBsLncgOiB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5IDwgMCA/IDAgOiB5ID4gbC5oID8gbC5oIDogeVxuXG4gICAgICAgIC8vdGhlIG90aGVyIGFuaW1hbHMgYXJvdW5kXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMucHJlZGF0b3JzID0gW11cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5wcmV5cyA9IFtdXG5cbiAgICAgICAgLy9hZGQgdG8gdGhlIHNwYXRpYWwgaW5kZXhcbiAgICAgICAgbC5ncmlkLmluc2VydCh0aGlzKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBtb3ZlKHRpbWVTdGVwTXMgPSAxMCkge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sXG4gICAgICAgIGwuZ3JpZC5yZW1vdmUodGhpcyk7XG5cbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHIgPSAwLjAxICogTWF0aC5yYW5kb20oKTtcblxuICAgICAgICB0aGlzLnN4ICs9IHIgKiBNYXRoLmNvcyhhbmdsZSkgKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnN4ID0gdGhpcy5zeCA+IGwuVl9NQVggPyBsLlZfTUFYIDogdGhpcy5zeCA8IC1sLlZfTUFYID8gLWwuVl9NQVggOiB0aGlzLnN4XG5cbiAgICAgICAgdGhpcy5zeSArPSByICogTWF0aC5zaW4oYW5nbGUpICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy5zeSA9IHRoaXMuc3kgPiBsLlZfTUFYID8gbC5WX01BWCA6IHRoaXMuc3kgPCAtbC5WX01BWCA/IC1sLlZfTUFYIDogdGhpcy5zeVxuXG4gICAgICAgIHRoaXMueCArPSB0aGlzLnN4ICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy54ID0gdGhpcy54IDwgMCA/IGwudyA6IHRoaXMueCA+IGwudyA/IDAgOiB0aGlzLnhcblxuICAgICAgICB0aGlzLnkgKz0gdGhpcy5zeSAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueSA8IDAgPyBsLmggOiB0aGlzLnkgPiBsLmggPyAwIDogdGhpcy55XG5cbiAgICAgICAgbC5ncmlkLmluc2VydCh0aGlzKTtcbiAgICB9XG5cblxuICAgIC8qKiBPYnNlcnZlICovXG4gICAgb2JzZXJ2ZSgpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMubFxuXG4gICAgICAgIC8vZ2V0IGFuaW1hbHMgYXJvdW5kXG4gICAgICAgIGNvbnN0IGFzID0gbC5ncmlkLmdldCh0aGlzLnggLSBsLmQsIHRoaXMueSAtIGwuZCwgdGhpcy54ICsgbC5kLCB0aGlzLnkgKyBsLmQpO1xuXG4gICAgICAgIHRoaXMucHJleXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcmVkYXRvcnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBhIG9mIGFzKSB7XG4gICAgICAgICAgICBpZiAoYSA9PSB0aGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmQoYSkgPiBsLmQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGEudHlwZSA9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMucHJleXMucHVzaChhKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnByZWRhdG9ycy5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEByZXR1cm5zIHtBbmltYWx9ICovXG4gICAgbWFrZUNoaWxkKCkge1xuICAgICAgICAvL2RvIGJldHRlcjogbWFrZSBjaGlsZCBhcm91bmRcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYWwodGhpcy50eXBlLCB0aGlzLmwsIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBhbmltYWxcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGxTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBcbiAgICAgKi9cbiAgICBkaXNwbGF5KGNwLCBmaWxsU3R5bGUgPSBcImJsdWVcIiwgc2l6ZSA9IDIpIHtcbiAgICAgICAgY3AuY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgY3AuY3R4LmZpbGxSZWN0KHRoaXMueCwgdGhpcy55LCBzaXplLCBzaXplKTtcbiAgICAgICAgLypjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIuYXJjKGEueCwgYS55LCAwLjUsIDAsIDIqTWF0aC5QSSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5maWxsKCk7Ki9cbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tICcuLi9iYXNlL1NwYXRpYWxJbmRleCc7XG5pbXBvcnQgeyByZW1vdmVGcm9tQXJyYXlTIH0gZnJvbSAnLi4vYmFzZS9saWInO1xuaW1wb3J0IHtBbmltYWx9IGZyb20gXCIuL0FuaW1hbFwiXG5cbmV4cG9ydCBjbGFzcyBMYW5kIHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHcsIGgpIHtcblxuICAgICAgICAvL3RoZSBtYXggc3BlZWRcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuVl9NQVggPSAwLjFcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5wID0gMC4wMiAvL3ByZWRhdG9yIGRlYXRoIHByb2JhYmlsaXR5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnEgPSAwLjEgLy9wcmV5IHJlcHJvZHVjdGlvbiBwcm9iYWJpbGl0eVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5yID0gMC41IC8vZWF0ZW4gcHJleSB0cmFuc2Zvcm1hdGlvbiBwcm9iYWJpbGl0eVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5uYiA9IDMgLy9uZWlnaGJvcnMgbnVtYmVyXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IHdcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGhcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLnByZWRhdG9ycyA9IFtdXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMucHJleXMgPSBbXVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmQgPSAxMFxuICAgICAgICAvKiogQHR5cGUge1NwYXRpYWxJbmRleC48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuXG4gICAgICAgIC8qaW50W11bXSBoaXN0bztcbiAgICAgICAgaW50IGluZGV4PTA7XG4gICAgICAgIHRoaXMuYzJDaGFydD1jMkNoYXJ0O1xuICAgICAgICB0aGlzLmhDaGFydD1oQ2hhcnQ7XG4gICAgICAgIHRoaXMuaGlzdG89bmV3IGludFt3Q2hhcnRdW107XG4gICAgICAgIGZvcihpbnQgaT0wO2k8d0NoYXJ0O2krKylcbiAgICAgICAgICAgIGhpc3RvW2ldPW5ldyBpbnRbXXswLDB9OyovXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBzdGVwKHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vb2JzZXJ2ZVxuICAgICAgICBmb3IgKGxldCBhIG9mIHRoaXMucHJleXMpIGEub2JzZXJ2ZSgpO1xuICAgICAgICBmb3IgKGxldCBhIG9mIHRoaXMucHJlZGF0b3JzKSBhLm9ic2VydmUoKTtcblxuICAgICAgICBjb25zdCBwcmV5c1RvQm9ybiA9IFtdXG4gICAgICAgIGNvbnN0IHByZXlzVG9EaWUgPSBbXVxuICAgICAgICBjb25zdCBwcmVkc1RvQm9ybiA9IFtdXG4gICAgICAgIGNvbnN0IHByZWRzVG9EaWUgPSBbXVxuXG4gICAgICAgIC8vcHJleVxuICAgICAgICBmb3IgKGxldCBwcmV5IG9mIHRoaXMucHJleXMpIHtcbiAgICAgICAgICAgIC8vcmVwcm9kdWN0aW9uIGlmIG5vIHByZWRhdG9yIGFyb3VuZFxuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiB0aGlzLnEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByZXkucHJlZGF0b3JzLmxlbmd0aCAhPSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwcmV5LnByZXlzLmxlbmd0aCA+PSB0aGlzLm5iKSBjb250aW51ZTtcbiAgICAgICAgICAgIHByZXlzVG9Cb3JuLnB1c2gocHJleS5tYWtlQ2hpbGQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3ByZWRhdG9yXG4gICAgICAgIGZvciAobGV0IHByZWQgb2YgdGhpcy5wcmVkYXRvcnMpIHtcbiAgICAgICAgICAgIC8vbm8gcHJleSBhcm91bmQ6IHByZWRhdG9yIGRpZXMgd2l0aCBwcm9iYWJpbGl0eSBwXG4gICAgICAgICAgICBpZiAocHJlZC5wcmV5cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgdGhpcy5wKSBwcmVkc1RvRGllLnB1c2gocHJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3ByZXkgYXJvdW5kXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2VhdCBwcmV5XG4gICAgICAgICAgICAgICAgLy9jaG9vc2UgcmFuZG9tbHlcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV5VG9FYXQgPSBwcmVkLnByZXlzW01hdGguZmxvb3IocHJlZC5wcmV5cy5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKV07XG4gICAgICAgICAgICAgICAgcHJleXNUb0RpZS5wdXNoKHByZXlUb0VhdCk7XG5cbiAgICAgICAgICAgICAgICAvL3ByZWRhdG9yIHJlcHJvZHVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gdGhpcy5yKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZC5wcmVkYXRvcnMubGVuZ3RoID49IHRoaXMubmIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHByZWRzVG9Cb3JuLnB1c2gocHJlZC5tYWtlQ2hpbGQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXlzLnB1c2goLi4ucHJleXNUb0Jvcm4pO1xuICAgICAgICB0aGlzLnByZWRhdG9ycy5wdXNoKC4uLnByZWRzVG9Cb3JuKTtcblxuICAgICAgICByZW1vdmVGcm9tQXJyYXlTKHRoaXMucHJleXMsIHByZXlzVG9EaWUsIGZhbHNlKVxuICAgICAgICBmb3IgKGxldCBhIG9mIHByZXlzVG9EaWUpIHRoaXMuZ3JpZC5yZW1vdmUoYSk7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheVModGhpcy5wcmVkYXRvcnMsIHByZWRzVG9EaWUsIGZhbHNlKVxuICAgICAgICBmb3IgKGxldCBhIG9mIHByZWRzVG9EaWUpIHRoaXMuZ3JpZC5yZW1vdmUoYSk7XG5cbiAgICAgICAgLy9tb3ZlXG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5wcmV5cylcbiAgICAgICAgICAgIGEubW92ZSh0aW1lU3RlcE1zKTtcbiAgICAgICAgZm9yIChsZXQgYSBvZiB0aGlzLnByZWRhdG9ycylcbiAgICAgICAgICAgIGEubW92ZSh0aW1lU3RlcE1zKTtcblxuICAgICAgICAvKi9oaXN0b1xuICAgICAgICBoaXN0b1tpbmRleF0gPSBuZXcgaW50W117IHByZXlzLnNpemUoKSwgcHJlZGF0b3JzLnNpemUoKSB9O1xuICAgICAgICBpZiAoaW5kZXggPT0gaGlzdG8ubGVuZ3RoIC0gMSkgaW5kZXggPSAwO1xuICAgICAgICBlbHNlIGluZGV4Kys7Ki9cblxuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBMYW5kIH0gZnJvbSAnLi9MYW5kJztcbmltcG9ydCB7IEFuaW1hbCB9IGZyb20gJy4vQW5pbWFsJztcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4uL2Jhc2UvR2VvQ2FudmFzJztcblxuLyoqICovXG5jbGFzcyBQcmV5UHJlZGF0b3JTaW11bGF0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgb3B0cy5jYW52YXNJZCA9IG9wdHMuY2FudmFzSWQgfHwgXCJ2YWNhbnZhc1wiO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRzLmNhbnZhc0lkKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gb3B0cy53IHx8IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcblxuXG4gICAgICAgIGNvbnN0IHRoID0gdGhpcztcbiAgICAgICAgdGhpcy5jcGx1cy5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuY3R4XG5cbiAgICAgICAgICAgIC8vdHJhbnNwYXJlbmN5XG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgYW5pbWFsc1xuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgZm9yIChsZXQgYSBvZiB0aC5sYW5kLnByZXlzKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhhKSlcbiAgICAgICAgICAgICAgICAgICAgYS5kaXNwbGF5KHRoaXMsIFwiYmx1ZVwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGEgb2YgdGgubGFuZC5wcmVkYXRvcnMpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KGEpKVxuICAgICAgICAgICAgICAgICAgICBhLmRpc3BsYXkodGhpcywgXCJyZWRcIik7XG5cbiAgICAgICAgICAgIC8qL2xhYmVsXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcImxpZ2h0Z3JheVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgNjUsIDEzKTtcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgIGMyLmZpbGxUZXh0KHByZXlzLmxlbmd0aCArIFwiL1wiICsgcHJlZGF0b3JzLmxlbmd0aCwgMiwgMTApOyovXG5cbiAgICAgICAgICAgIC8vY2hhcnRcbiAgICAgICAgICAgIC8vYzJDaGFydC5zZXRGaWxsU3R5bGUoYmFja0NvbG9yMik7XG4gICAgICAgICAgICAvL2MyQ2hhcnQuZmlsbFJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgICAgIC8vZG91YmxlIG1heCA9IGdldE1heEhpc3RvKCk7XG4gICAgICAgICAgICAvKnB1YmxpYyBpbnQgZ2V0TWF4SGlzdG8oKSB7XG4gICAgICAgICAgICAgICAgaW50IG1heD0wO1xuICAgICAgICAgICAgICAgIGZvcihpbnQgaT0wO2k8aGlzdG8ubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhpc3RvW2ldWzBdPm1heCkgbWF4PWhpc3RvW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZihoaXN0b1tpXVsxXT5tYXgpIG1heD1oaXN0b1tpXVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZSBoMSwgaDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBoaXN0by5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMSA9IGhDaGFydCAqIGhpc3RvW2ldWzBdIC8gbWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMiA9IGhDaGFydCAqIGhpc3RvW2ldWzFdIC8gbWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LnNldEZpbGxTdHlsZShwcmV5Q29sb3IyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5maWxsUmVjdChpLCBoQ2hhcnQgLSBoMSwgMSwgaDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LnNldEZpbGxTdHlsZShwcmVkYXRvckNvbG9yMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuZmlsbFJlY3QoaSwgaENoYXJ0IC0gaDIsIDEsIGgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LnNldEZpbGxTdHlsZShDc3NDb2xvci5tYWtlKDI1NSwgMjU1LCAyNTUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuZmlsbFJlY3QoaW5kZXgsIDAsIDEsIGhDaGFydCk7XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH07XG5cblxuICAgICAgICAvKiogQHR5cGUge0xhbmR9ICovXG4gICAgICAgIHRoaXMubGFuZCA9IG5ldyBMYW5kKHRoaXMudywgdGhpcy5oKVxuXG4gICAgfVxuXG5cblxuICAgIC8vVE9ETyB0ZXN0IGluaXQgaW4gYSBidWJibGUgP1xuICAgIC8vVE9ETyB1c2UgZGVuc2l0eSBhcyBpbnB1dCBwYXJhbWV0ZXJzIGluc3RlYWQgb2YgbmJcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmV5RGVuc2l0eSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJlZGF0b3JEZW5zaXR5IFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGluaXRSYW5kb20ocHJleURlbnNpdHkgPSAwLjAwMywgcHJlZGF0b3JEZW5zaXR5ID0gMC4wMDMpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMubGFuZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXlEZW5zaXR5ICogbC53ICogbC5oOyBpKyspXG4gICAgICAgICAgICBsLnByZXlzLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEFuaW1hbCgwLCBsLCBsLncgKiBNYXRoLnJhbmRvbSgpLCBsLmggKiBNYXRoLnJhbmRvbSgpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVkYXRvckRlbnNpdHkgKiBsLncgKiBsLmg7IGkrKylcbiAgICAgICAgICAgIGwucHJlZGF0b3JzLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEFuaW1hbCgxLCBsLCBsLncgKiBNYXRoLnJhbmRvbSgpLCBsLmggKiBNYXRoLnJhbmRvbSgpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmJJdGVyYXRpb25zIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0YXJ0KHRpbWVTdGVwTXMgPSAxMCwgbmJJdGVyYXRpb25zID0gLTEpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCB0ID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdC5sYW5kLnN0ZXAodGltZVN0ZXBNcyk7XG4gICAgICAgICAgICB0LmNwbHVzLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKG5iSXRlcmF0aW9ucyA+IDAgJiYgaSsrID4gbmJJdGVyYXRpb25zKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5naW5lLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW5naW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCBwcmV5UHJlZGF0b3IgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgUHJleVByZWRhdG9yU2ltdWxhdGlvbihvcHRzKVxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gXCIuLi9iYXNlL0dlb0NhbnZhc1wiXG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tIFwiLi4vYmFzZS9TcGF0aWFsSW5kZXhcIlxuXG5leHBvcnQgY2xhc3MgQnVpbGRpbmcge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhIFRoZSBhcmVhXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSwgYXJlYSkge1xuXG4gICAgICAgIC8vc2V0IHBvc2l0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmFyZWEgPSBhcmVhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyBudW1iZXIgfVxuICAgICAqL1xuICAgIHIoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5hcmVhIC8gTWF0aC5QSSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0J1aWxkaW5nfSBiIFxuICAgICAqL1xuICAgIG92ZXJsYXAoYikge1xuICAgICAgICBjb25zdCBkMSA9IGIucigpICsgdGhpcy5yKClcbiAgICAgICAgY29uc3QgZDIgPSBNYXRoLmh5cG90KChiLnggLSB0aGlzLngpLCAoYi55IC0gdGhpcy55KSk7XG4gICAgICAgIHJldHVybiBkMiA8IGQxXG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3BhdGlhbEluZGV4LjxCdWlsZGluZz59IHNpbmRleCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc0Rpc3RhbmNlIFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNoZWNrQ29sbGlzaW9uKHNpbmRleCwgc0Rpc3RhbmNlKSB7XG5cbiAgICAgICAgLy9nZXQgYnVpbGRpbmdzIGFyb3VuZCB1c2luZyBzcGF0aWFsIGluZGV4XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPEJ1aWxkaW5nPn0gKi9cbiAgICAgICAgY29uc3Qgc3MgPSBzaW5kZXguZ2V0KHRoaXMueCAtIHNEaXN0YW5jZSwgdGhpcy55IC0gc0Rpc3RhbmNlLCB0aGlzLnggKyBzRGlzdGFuY2UsIHRoaXMueSArIHNEaXN0YW5jZSk7XG5cbiAgICAgICAgZm9yIChsZXQgYiBvZiBzcykge1xuICAgICAgICAgICAgaWYgKGIgPT0gdGhpcykgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGFwKGIpKSByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5XG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxsU3R5bGUgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cm9rZVN0eWxlIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGMyLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yKCksIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLmZpbGwoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tICcuLi9iYXNlL1NwYXRpYWxJbmRleCc7XG5pbXBvcnQgeyBCdWlsZGluZyB9IGZyb20gJy4vQnVpbGRpbmcnO1xuaW1wb3J0IHsgUm9hZE5ldHdvcmsgfSBmcm9tICcuL1JvYWROZXR3b3JrJztcblxuZXhwb3J0IGNsYXNzIE1hcCB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxCdWlsZGluZz59ICovXG4gICAgICAgIHRoaXMuYnMgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPEJ1aWxkaW5nPn0gKi9cbiAgICAgICAgdGhpcy5idUluZGV4ID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Um9hZE5ldHdvcmt9ICovXG4gICAgICAgIHRoaXMucm4gPSBuZXcgUm9hZE5ldHdvcmsoKTtcblxuICAgICAgICAvKlxuICAgICAgICAvL3Rlc3QgdHVyZlxuICAgICAgICAgICAgICAgIHZhciBscyA9IHR1cmYubGluZVN0cmluZyhbWzEwMDAsIDBdLCBbMTAwMCwgMTAwMF1dKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhscylcbiAgICAgICAgICAgICAgICAvL3ZhciBwdCA9IHR1cmYucG9pbnQoWzEwMDAsIDEwMDBdKTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZiA9IHR1cmYuYnVmZmVyKGxzLCAxMCwgJ2RlZ3JlZXMnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhidWZmKVxuICAgICAgICAqL1xuXG4gICAgICAgIC8vdGVzdCBqc3RzXG4gICAgICAgIC8vaHR0cHM6Ly9iam9ybmhhcnJ0ZWxsLmdpdGh1Yi5pby9qc3RzL1xuICAgICAgICAvKnZhciByZWFkZXIgPSBuZXcganN0cy5pby5XS1RSZWFkZXIoKVxuICAgICAgICB2YXIgYSA9IHJlYWRlci5yZWFkKCdQT0lOVCAoLTIwIDApJylcbiAgICAgICAgY29uc29sZS5sb2cocmVhZGVyKVxuICAgICAgICBjb25zb2xlLmxvZyhhKVxuICAgICAgICBhID0gYS5idWZmZXIoNDApXG4gICAgICAgIGNvbnNvbGUubG9nKGEpXG4gICAgICAgIHZhciB3ID0gbmV3IGpzdHMuaW8uV0tUV3JpdGVyKClcbiAgICAgICAgY29uc29sZS5sb2cody53cml0ZShhKSkqL1xuICAgIH1cblxuICAgIC8qKiAqL1xuICAgIGFkZEJ1aWxkaW5nKCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBjYW5kaWRhdGUgbG9jYXRpb24sIHNpemUgYW5kIHR5cGUgZm9yIG5leHQgYnVpbGRpbmdcbiAgICAgICAgLy9UT0RPIGxvdyBsb2NhbCBjb25nZXN0aW9uIEFORCBnbyB0byBoaWdoIGRlbnNpdHkgKHdpdGggZ29vZCBhY2Nlc3MgdG8gb3RoZXIgc3R1ZmYpXG5cbiAgICAgICAgLy9tYWtlIHJhbmRvbSBidWlsZGluZ1xuICAgICAgICBjb25zdCBtYWtlUmFuZG9tQnVpbGRpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy53ICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmggKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IDQwICsgMjAwICogTWF0aC5yYW5kb20oKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWlsZGluZyh4LCB5LCBhcmVhKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPIHNob3VsZCBub3Qgb3ZlcmxhcCB3aXRoIG90aGVyIGVudGl0aWVzIChyb2FkcywgYnVpbGRpbmcpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGNvbnN0IHNEaXN0YW5jZSA9IDEwMDtcbiAgICAgICAgLyoqIEB0eXBlIHtCdWlsZGluZ30gKi9cbiAgICAgICAgbGV0IGJ1ID0gbWFrZVJhbmRvbUJ1aWxkaW5nKCk7XG4gICAgICAgIHdoaWxlIChidS5jaGVja0NvbGxpc2lvbih0aGlzLmJ1SW5kZXgsIHNEaXN0YW5jZSkpIHtcbiAgICAgICAgICAgIGJ1ID0gbWFrZVJhbmRvbUJ1aWxkaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2FkZCBidWlsZGluZ1xuICAgICAgICB0aGlzLmJzLnB1c2goYnUpO1xuICAgICAgICB0aGlzLmJ1SW5kZXgubG9hZChbYnVdKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0ZXAoKSB7XG5cbiAgICAgICAgLy9jb21wdXRlIGJ1aWxkaW5nIG5lZWRcbiAgICAgICAgY29uc3QgYnVOZWVkID0gMTA7XG5cbiAgICAgICAgLy91cmJhbmlzZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1TmVlZDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEJ1aWxkaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2V4dGVuZCByb2FkIG5ldHdvcmtcbiAgICAgICAgLy9UT0RPXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuXG5leHBvcnQgY2xhc3MgUm9hZCB7XG5cbiAgICBjb25zdHJ1Y3RvcihnZW9tKSB7XG5cbiAgICAgICAgdGhpcy5nZW9tID0gZ2VvbVxuXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgUm9hZCB9IGZyb20gXCIuL1JvYWRcIlxuaW1wb3J0IGpzdHMgZnJvbSAnanN0cyc7XG5cbmV4cG9ydCBjbGFzcyBSb2FkTmV0d29yayB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxSb2FkPn0gKi9cbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IFtdXG5cblxuICAgICAgICAvL2FkZCB0ZXN0IHJvYWRcblxuICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbiAgICAgICAgLy9odHRwOi8vYmpvcm5oYXJydGVsbC5naXRodWIuaW8vanN0cy9cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLldLVFJlYWRlcigpXG4gICAgICAgIHZhciBnID0gcmVhZGVyLnJlYWQoJ0xJTkVTVFJJTkcgKDMwIDEwLCAxMCAzMDAsIDQwMCA0MCknKVxuICAgICAgICAvL2EgPSBhLmJ1ZmZlcig0MClcbiAgICAgICAgLy92YXIgdyA9IG5ldyBqc3RzLmlvLldLVFdyaXRlcigpXG4gICAgICAgIC8vY29uc29sZS5sb2cody53cml0ZShhKSlcblxuICAgICAgICB0aGlzLnNlY3Rpb25zLnB1c2gobmV3IFJvYWQoZykpO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4uL2Jhc2UvR2VvQ2FudmFzJztcbmltcG9ydCB7IE1hcCB9IGZyb20gXCIuL01hcFwiO1xuXG4vKiogICovXG5jbGFzcyBVcmJhblNpbXVsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuICAgICAgICBpZiAoY2FudmFzID09IG51bGwpIHRocm93IFwiTm8gY2FudmFzIFwiICsgb3B0cy5jYW52YXNJZDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gb3B0cy53IHx8IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtHZW9DYW52YXN9ICovXG4gICAgICAgIHRoaXMuY3BsdXMgPSBuZXcgR2VvQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpO1xuXG4gICAgICAgIGNvbnN0IHRoID0gdGhpcztcbiAgICAgICAgdGhpcy5jcGx1cy5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuY3R4XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAvL2NsZWFyXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcblxuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgYnVpbGRpbmdzXG4gICAgICAgICAgICBmb3IgKGxldCBiIG9mIHRoLm1hcC5icykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50b0RyYXcoYikpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgYi5kaXNwbGF5KHRoaXMsIFwibGlnaHRncmF5XCIsIFwiYmxhY2tcIiwgMilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogQHR5cGUge01hcH0gKi9cbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKHRoaXMudywgdGhpcy5oKVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgc2ltdWxhdGlvblxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYkl0ZXJhdGlvbnMgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RhcnQodGltZVN0ZXBNcyA9IDEwLCBuYkl0ZXJhdGlvbnMgPSAtMSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0Lm1hcC5zdGVwKCk7XG4gICAgICAgICAgICB0LmNwbHVzLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKG5iSXRlcmF0aW9ucyA+IDAgJiYgaSsrID4gbmJJdGVyYXRpb25zKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5naW5lLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW5naW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vc3RvcFxuICAgIHN0b3AoKSB7XG4gICAgICAgIC8vVE9ET1xuICAgIH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICovXG5leHBvcnQgY29uc3QgdXJiYW4gPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgVXJiYW5TaW11bGF0aW9uKG9wdHMpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9