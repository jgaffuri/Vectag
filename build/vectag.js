(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vectag"] = factory();
	else
		root["vectag"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/index.js ***!
  \********************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: radians, degrees */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "./node_modules/d3-dispatch/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-dispatch/src/index.js ***!
  \***********************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassive"])
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view)
      .on("mousemove.drag", mousemoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"])
      .on("mouseup.drag", mouseupped, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"]);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(event.view, mousemoving);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"]("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-drag/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/index.js ***!
  \*******************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _drag_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });





/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nonpassive, nonpassivecapture, nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassive", function() { return nonpassive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassivecapture", function() { return nonpassivecapture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-(--t)) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-t) * Math.sin((s - t) / p)
        : 2 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


function expIn(t) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - +t);
}

function expOut(t) {
  return 1 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - t) : 2 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t - 1)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/index.js ***!
  \*******************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _linear_js__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _cubic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic.js */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _poly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./poly.js */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _sin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sin.js */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _exp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exp.js */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circle.js */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _bounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bounce.js */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _back_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./back.js */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _elastic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elastic.js */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });






















/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
const linear = t => +t;


/***/ }),

/***/ "./node_modules/d3-ease/src/math.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/math.js ***!
  \******************************************/
/*! exports provided: tpmt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tpmt", function() { return tpmt; });
// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default, genericArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genericArray", function() { return genericArray; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return (Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_1__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/discrete.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/discrete.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hue.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hue.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["hue"])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/index.js ***!
  \**************************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateNumberArray, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _value_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _array_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _date_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "./node_modules/d3-interpolate/src/discrete.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return _discrete_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "./node_modules/d3-interpolate/src/hue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return _hue_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _number_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _object_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _round_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _string_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformSvg"]; });

/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasisClosed"]; });

/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["hslLong"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["hclLong"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["cubehelixLong"]; });

/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _piecewise_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _quantize_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });
























/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/*! exports provided: default, isNumberArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumberArray", function() { return isNumberArray; });
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"] : Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_6__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_8__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__["genericArray"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ __webpack_exports__["default"] = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return array; });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return Object(_select_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/index.js ***!
  \************************************************/
/*! exports provided: create, creator, local, matcher, namespace, namespaces, pointer, pointers, select, selectAll, selection, selector, selectorAll, style, window */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create.js */ "./node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _creator_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local.js */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _local_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _namespace_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _namespaces_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointer", function() { return _pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _pointers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pointers.js */ "./node_modules/d3-selection/src/pointers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointers", function() { return _pointers_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _select_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _selectAll_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _selection_index_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector.js */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _selector_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _selection_style_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _selection_style_js__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./window.js */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _window_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });


















/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default, childMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "childMatcher", function() { return childMatcher; });
/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
});


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(event, node) {
  event = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointers.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/pointers.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(events, node) {
  if (events.target) { // i.e., instanceof Event, not TouchList or iterable
    events = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(events);
    if (node === undefined) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, event => Object(_pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event, node));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ __webpack_exports__["default"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return !this.node();
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function*() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(lower);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Array.from(this);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(raise);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(remove);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = Object(_selectorAll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(update) {
  return new Array(update.length);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),

/***/ "./node_modules/d3-timer/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/index.js ***!
  \********************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timeout.js */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _timeout_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _interval_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });








/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? Object(_timer_js__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"];
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return this.each(function() {
    Object(_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]
      : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");



var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["default"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        string1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["set"])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_3__["tweenValue"])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(_tween_js__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity, ZoomTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["Transform"]; });





/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved(event) {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(event.view, g.moved);
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
});


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/jsts/dist/jsts.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * @license
 */
!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class n extends Error{constructor(t){super(t),this.name=Object.keys({Exception:n})[0]}toString(){return this.message}}class s extends n{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:s})[0]}}class i{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function r(){}function o(){}function l(){}function a(){}function c(){}r.NaN=NaN,r.isNaN=t=>Number.isNaN(t),r.isInfinite=t=>!Number.isFinite(t),r.MAX_VALUE=Number.MAX_VALUE,r.POSITIVE_INFINITY=Number.POSITIVE_INFINITY,r.NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,e=new Float64Array(1),n=new Int32Array(e.buffer);r.doubleToLongBits=function(s){e[0]=s;let r=0|n[0],o=0|n[1];return(o&t)===t&&0!=(1048575&o)&&0!==r&&(r=0,o=2146959360),new i(o,r)},r.longBitsToDouble=function(t){return n[0]=t.low,n[1]=t.high,e[0]}}():function(){const t=1023,e=Math.log2,n=Math.floor,s=Math.pow,o=function(){for(let t=53;t>0;t--){const i=s(2,t)-1;if(n(e(i))+1===t)return i}return 0}();r.doubleToLongBits=function(r){let l,a,c,h,u,g,d,_,p;if(r<0||1/r===Number.NEGATIVE_INFINITY?(g=1<<31,r=-r):g=0,0===r)return p=0,_=g,new i(_,p);if(r===1/0)return p=0,_=2146435072|g,new i(_,p);if(r!=r)return p=0,_=2146959360,new i(_,p);if(h=0,p=0,l=n(r),l>1)if(l<=o)h=n(e(l)),h<=20?(p=0,_=l<<20-h&1048575):(c=h-20,a=s(2,c),p=l%a<<32-c,_=l/a&1048575);else for(c=l,p=0;a=c/2,c=n(a),0!==c;)h++,p>>>=1,p|=(1&_)<<31,_>>>=1,a!==c&&(_|=524288);if(d=h+t,u=0===l,l=r-l,h<52&&0!==l)for(c=0;;){if(a=2*l,a>=1?(l=a-1,u?(d--,u=!1):(c<<=1,c|=1,h++)):(l=a,u?0==--d&&(h++,u=!1):(c<<=1,h++)),20===h)_|=c,c=0;else if(52===h){p|=c;break}if(1===a){h<20?_|=c<<20-h:h<52&&(p|=c<<52-h);break}}return _|=d<<20,_|=g,new i(_,p)},r.longBitsToDouble=function(e){let n,i,r,o;const l=e.high,a=e.low,c=l&1<<31?-1:1;for(r=((2146435072&l)>>20)-t,o=0,i=1<<19,n=1;n<=20;n++)l&i&&(o+=s(2,-n)),i>>>=1;for(i=1<<31,n=21;n<=52;n++)a&i&&(o+=s(2,-n)),i>>>=1;if(-1023===r){if(0===o)return 0*c;r=-1022}else{if(1024===r)return 0===o?c/0:NaN;o+=1}return c*o*s(2,r)}}();class h extends n{constructor(t){super(t),this.name=Object.keys({RuntimeException:h})[0]}}class u extends h{constructor(){super(),u.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)h.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}}}class g{static shouldNeverReachHere(){if(0===arguments.length)g.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new u("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];g.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new u:new u(t)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];g.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new u("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}const d=new ArrayBuffer(8),_=new Float64Array(d),p=new Int32Array(d);class m{constructor(){m.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)m.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];m.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return _[0]=t,p[0]^p[1]}getM(){return r.NaN}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.setZ(e);break;default:throw new s("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}setM(t){throw new s("Invalid ordinate index: "+m.M)}getZ(){return this.z}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ()}throw new s("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||r.isNaN(this.getZ())&&r.isNaN(t.getZ()))}equals(t){return t instanceof m&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.getZ(),t.getZ(),n)}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return g.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new m(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+s*s)}getY(){return this.y}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this.x),t=37*t+m.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[o,l,c]}}class f{constructor(){f.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)f.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new s("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0}compare(t,e){const n=f.compare(t.x,e.x);if(0!==n)return n;const s=f.compare(t.y,e.y);if(0!==s)return s;if(this._dimensionsToTest<=2)return 0;return f.compare(t.getZ(),e.getZ())}get interfaces_(){return[a]}}m.DimensionalComparator=f,m.NULL_ORDINATE=r.NaN,m.X=0,m.Y=1,m.Z=2,m.M=3;class y extends m{constructor(){super(),y.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)m.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof y){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case y.X:this.x=e;break;case y.Y:this.y=e;break;default:throw new s("Invalid ordinate index: "+t)}}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case y.X:return this.x;case y.Y:return this.y}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new y(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}}y.X=0,y.Y=1,y.Z=-1,y.M=-1;class x extends m{constructor(){super(),x.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof x){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];m.constructor_.call(this,t,e,m.NULL_ORDINATE),this._m=n}}getM(){return this._m}setOrdinate(t,e){switch(t){case x.X:this.x=e;break;case x.Y:this.y=e;break;case x.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case x.X:return this.x;case x.Y:return this.y;case x.M:return this._m}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new x(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}x.X=0,x.Y=1,x.Z=-1,x.M=2;class E extends m{constructor(){super(),E.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof E){const t=arguments[0];m.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];m.constructor_.call(this,t,e,n),this._m=s}}getM(){return this._m}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.z=e;break;case m.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ();case m.M:return this.getM()}throw new s("Invalid ordinate index: "+t)}copy(){return new E(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}function I(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}class N{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class w extends n{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:w})[0]}}class C extends N{get(){}set(){}isEmpty(){}}class S extends n{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:S})[0]}}class L extends C{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}get interfaces_(){return[C,N]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new T(this)}get(t){if(t<0||t>=this.size())throw new w;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort(((e,n)=>t.compare(e,n))):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}let T=class{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new S;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}};class R extends L{constructor(){super(),R.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&I(arguments[0],N)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){if(0===arguments.length)return this.toArray(R.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(R.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof m&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}}R.coordArrayType=new Array(0).fill(null);class P{filter(t,e){}isDone(){}isGeometryChanged(){}}class O{constructor(){O.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof O))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new O;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new O(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof m){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new O(this)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new m((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this._minx),t=37*t+m.hashCode(this._maxx),t=37*t+m.hashCode(this._miny),t=37*t+m.hashCode(this._maxy),t}get interfaces_(){return[o,c]}}class v{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class b{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new b(t)}}class M{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class D extends n{constructor(t){super(t),this.name=Object.keys({IllegalStateException:D})[0]}}class A{constructor(){A.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof A){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];A.constructor_.call(this,A.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return A.determinant(A.valueOf(t),A.valueOf(e),A.valueOf(n),A.valueOf(s))}if(arguments[3]instanceof A&&arguments[2]instanceof A&&arguments[0]instanceof A&&arguments[1]instanceof A){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return A.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return A.parse(t)}if("number"==typeof arguments[0]){return new A(arguments[0])}}static sqrt(t){return A.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;M.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new A;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,M.isDigit(n)){const t=n-"0";i.selfMultiply(A.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=b.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=i;a||(o=r);const h=r-o-l;if(0===h)c=i;else if(h>0){const t=A.TEN.pow(h);c=i.divide(t)}else if(h<0){const t=A.TEN.pow(-h);c=i.multiply(t)}return s?c.negate():c}static createNaN(){return new A(r.NaN,r.NaN)}static copy(t){return new A(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new v;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=A.magnitude(n._hi);const i=A.TEN.pow(s);n=n.divide(i),n.gt(A.TEN)?(n=n.divide(A.TEN),s+=1):n.lt(A.ONE)&&(n=n.multiply(A.TEN),s-=1);const r=s+1,o=new v,l=A.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(A.valueOf(s)).multiply(A.TEN),i&&n.selfAdd(A.TEN);let c=!0;const h=A.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof A){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof A){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof A){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=A.SPLIT*o,n=l-o,c=A.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof A){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=A.SPLIT*r,e=o-r,a=A.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new A(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?A.createNaN():A.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return A.valueOf(1);let e=new A(this),n=A.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return A.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new A(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof A){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return A.valueOf(0);if(this.isNegative())return A.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=A.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof A){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=A.SPLIT*this._hi,n=o-this._hi,l=A.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return A.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new A(t,e)}negate(){return this.isNaN()?this:new A(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof A){const t=arguments[0];return t.isNaN()?A.createNaN():A.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?A.createNaN():A.copy(this).selfMultiply(t,0)}}isNaN(){return r.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=A.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+A.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+A.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=A.SPLIT*i,t=r-i,l=A.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new A(a,i-a+r)}toSciNotation(){if(this.isZero())return A.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=A.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new D("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?A.NaN:this.isNegative()?this.negate():new A(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof A){const t=arguments[0];return A.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return A.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof A){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?A.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[c,o,l]}}A.PI=new A(3.141592653589793,12246467991473532e-32),A.TWO_PI=new A(6.283185307179586,24492935982947064e-32),A.PI_2=new A(1.5707963267948966,6123233995736766e-32),A.E=new A(2.718281828459045,14456468917292502e-32),A.NaN=new A(r.NaN,r.NaN),A.EPS=123259516440783e-46,A.SPLIT=134217729,A.MAX_PRINT_DIGITS=32,A.TEN=A.valueOf(10),A.ONE=A.valueOf(1),A.SCI_NOT_EXPONENT_CHAR="E",A.SCI_NOT_ZERO="0.0E0";class F{static orientationIndex(t,e,n){const s=F.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=A.valueOf(e.x).selfAdd(-t.x),r=A.valueOf(e.y).selfAdd(-t.y),o=A.valueOf(n.x).selfAdd(-e.x),l=A.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof A&&arguments[2]instanceof A&&arguments[0]instanceof A&&arguments[1]instanceof A){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=A.valueOf(t),r=A.valueOf(e),o=A.valueOf(n),l=A.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=new A(t.y).selfSubtract(e.y),o=new A(e.x).selfSubtract(t.x),l=new A(t.x).selfMultiply(e.y).selfSubtract(new A(e.x).selfMultiply(t.y)),a=new A(n.y).selfSubtract(s.y),c=new A(s.x).selfSubtract(n.x),h=new A(n.x).selfMultiply(s.y).selfSubtract(new A(s.x).selfMultiply(n.y)),u=o.multiply(h).selfSubtract(c.multiply(l)),g=a.multiply(l).selfSubtract(i.multiply(h)),d=i.multiply(c).selfSubtract(a.multiply(o)),_=u.selfDivide(d).doubleValue(),p=g.selfDivide(d).doubleValue();return r.isNaN(_)||r.isInfinite(_)||r.isNaN(p)||r.isInfinite(p)?null:new m(_,p)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return F.signum(o);s=i+r}else{if(!(i<0))return F.signum(o);if(r>=0)return F.signum(o);s=-i-r}const l=F.DP_SAFE_EPSILON*s;return o>=l||-o>=l?F.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}F.DP_SAFE_EPSILON=1e-15;class G{getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return r.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):r.NaN}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}get interfaces_(){return[l]}}G.X=0,G.Y=1,G.Z=2,G.M=3;class q{static index(t,e,n){return F.orientationIndex(t,e,n)}static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(n)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(n)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(n)||a.equals2D(n)||l.equals2D(a))return!1;const c=q.index(l,n,a);let h=null;return h=0===c?l.x>a.x:c>0,h}if(I(arguments[0],G)){const t=arguments[0],e=t.size()-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let r=null,o=i;do{o-=1,o<0&&(o=e),r=t.getCoordinate(o)}while(r.equals2D(n)&&o!==i);let l=null,a=i;do{a=(a+1)%e,l=t.getCoordinate(a)}while(l.equals2D(n)&&a!==i);if(r.equals2D(n)||l.equals2D(n)||r.equals2D(l))return!1;const c=q.index(r,n,l);let h=null;return h=0===c?r.x>l.x:c>0,h}}}q.CLOCKWISE=-1,q.RIGHT=q.CLOCKWISE,q.COUNTERCLOCKWISE=1,q.LEFT=q.COUNTERCLOCKWISE,q.COLLINEAR=0,q.STRAIGHT=q.COLLINEAR;class B{static intersection(t,e,n,s){const i=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((i>c?i:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2,p=t.x-d,f=t.y-_,y=e.x-d,x=e.y-_,E=n.x-d,I=n.y-_,N=s.x-d,w=s.y-_,C=f-x,S=y-p,L=p*x-y*f,T=I-w,R=N-E,P=E*w-N*I,O=C*R-T*S,v=(S*P-R*L)/O,b=(T*L-C*P)/O;return r.isNaN(v)||r.isInfinite(v)||r.isNaN(b)||r.isInfinite(b)?null:new m(v+d,b+_)}}class Y{static arraycopy(t,e,n,s,i){let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class V{static log10(t){const e=Math.log(t);return r.isInfinite(e)||r.isNaN(e)?e:e/V.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let s=arguments[0];return t>s&&(s=t),e>s&&(s=e),n>s&&(s=n),s}}static average(t,e){return(t+e)/2}}V.LOG_10=Math.log(10);class z{static segmentToSegment(t,e,n,s){if(t.equals(e))return z.pointToSegment(t,n,s);if(n.equals(s))return z.pointToSegment(s,t,e);let i=!1;if(O.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?V.min(z.pointToSegment(t,n,s),z.pointToSegment(e,n,s),z.pointToSegment(n,t,e),z.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new s("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let s=0;s<e.length-1;s++){const i=z.pointToSegment(t,e[s],e[s+1]);i<n&&(n=i)}return n}}class X{create(){if(1===arguments.length)arguments[0]instanceof Array||I(arguments[0],G);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class k{filter(t){}}class U{constructor(){U.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===U.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(U.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}static checkNotGeometryCollection(t){if(t.getTypeCode()===U.TYPECODE_GEOMETRYCOLLECTION)throw new s("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new O(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getTypeCode()==t.getTypeCode()}get interfaces_(){return[l,o,c]}getClass(){return U}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}U.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},U.TYPECODE_POINT=0,U.TYPECODE_MULTIPOINT=1,U.TYPECODE_LINESTRING=2,U.TYPECODE_LINEARRING=3,U.TYPECODE_MULTILINESTRING=4,U.TYPECODE_POLYGON=5,U.TYPECODE_MULTIPOLYGON=6,U.TYPECODE_GEOMETRYCOLLECTION=7,U.TYPENAME_POINT="Point",U.TYPENAME_MULTIPOINT="MultiPoint",U.TYPENAME_LINESTRING="LineString",U.TYPENAME_LINEARRING="LinearRing",U.TYPENAME_MULTILINESTRING="MultiLineString",U.TYPENAME_POLYGON="Polygon",U.TYPENAME_MULTIPOLYGON="MultiPolygon",U.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",U.geometryChangedFilter={get interfaces_(){return[k]},filter(t){t.geometryChangedAction()}};class H{filter(t){}}class W{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new m;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}}class Z{}class j{static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,G.X)===t.getOrdinate(e-1,G.X)&&t.getOrdinate(0,G.Y)===t.getOrdinate(e-1,G.Y))}static scroll(){if(2===arguments.length){if(I(arguments[0],G)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];j.scroll(t,e,j.isRing(t))}else if(I(arguments[0],G)&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=j.indexOf(e,t);if(n<=0)return null;j.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const s=t.copy(),i=n?t.size()-1:t.size();for(let n=0;n<i;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,s.getOrdinate((e+n)%i,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(i,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let i=0;i<n;i++)for(let n=0;n<s;n++){const s=t.getOrdinate(i,n),o=e.getOrdinate(i,n);if(t.getOrdinate(i,n)!==e.getOrdinate(i,n)&&(!r.isNaN(s)||!r.isNaN(o)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return j.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,s=null;for(let i=arguments[1];i<=e;i++){const e=t.getCoordinate(i);(null===s||s.compareTo(e)>0)&&(s=e,n=i)}return n}}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(j.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)j.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)j.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)j.copyCoord(t,e+r,n,s+r)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return j.createClosedRing(t,e,4);return e.getOrdinate(0,G.X)===e.getOrdinate(n-1,G.X)&&e.getOrdinate(0,G.Y)===e.getOrdinate(n-1,G.Y)?e:j.createClosedRing(t,e,n+1)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,G.X)&&t.y===e.getOrdinate(n,G.Y))return n;return-1}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();j.copy(e,0,s,0,i);for(let t=i;t<n;t++)j.copy(e,0,s,t,1);return s}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const s=t.getCoordinate(n);(null===e||e.compareTo(s)>0)&&(e=s)}return e}}class K extends n{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:K})[0]}}class Q{static toDimensionSymbol(t){switch(t){case Q.FALSE:return Q.SYM_FALSE;case Q.TRUE:return Q.SYM_TRUE;case Q.DONTCARE:return Q.SYM_DONTCARE;case Q.P:return Q.SYM_P;case Q.L:return Q.SYM_L;case Q.A:return Q.SYM_A}throw new s("Unknown dimension value: "+t)}static toDimensionValue(t){switch(M.toUpperCase(t)){case Q.SYM_FALSE:return Q.FALSE;case Q.SYM_TRUE:return Q.TRUE;case Q.SYM_DONTCARE:return Q.DONTCARE;case Q.SYM_P:return Q.P;case Q.SYM_L:return Q.L;case Q.SYM_A:return Q.A}throw new s("Unknown dimension symbol: "+t)}}Q.P=0,Q.L=1,Q.A=2,Q.FALSE=-1,Q.TRUE=-2,Q.DONTCARE=-3,Q.SYM_FALSE="F",Q.SYM_TRUE="T",Q.SYM_DONTCARE="*",Q.SYM_P="0",Q.SYM_L="1",Q.SYM_A="2";class J{filter(t){}}class $ extends U{constructor(){super(),$.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new O:this._points.expandEnvelope(new O)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new $(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();j.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?Q.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return j.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return U.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return W.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(I(arguments[0],H)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){throw new K}isEquivalentClass(t){return t instanceof $}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return U.TYPENAME_LINESTRING}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new s("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}get interfaces_(){return[Z]}}class tt{}class et extends U{constructor(){super(),et.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];U.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new O;const t=new O;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new et(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return Q.FALSE}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return U.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new D("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(I(arguments[0],H)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(I(arguments[0],P)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return U.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new D("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),g.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}get interfaces_(){return[tt]}}class nt{static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(nt.ofRingSigned(t))}if(I(arguments[0],G)){const t=arguments[0];return Math.abs(nt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(I(arguments[0],G)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new m,s=new m,i=new m;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}}class st{static sort(){const t=arguments[0];if(1===arguments.length)t.sort(((t,e)=>t.compareTo(e)));else if(2===arguments.length)t.sort(((t,e)=>arguments[1].compare(t,e)));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort(((t,e)=>arguments[3].compare(t,e)));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new L;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class it{}class rt extends U{constructor(){super(),rt.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(U.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),U.hasNullElements(e))throw new s("holes must not contain null elements");if(t.isEmpty()&&U.hasNonEmptyElements(e))throw new s("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=nt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=nt.ofRing(this._holes[e].getCoordinateSequence());return t}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new rt(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);st.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),s=j.minCoordinateIndex(n,0,n.size()-2);j.scroll(n,s,!0),q.isCCW(n)===e&&j.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return U.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,s=e._shell,i=n.compareToSameClass(s,t);if(0!==i)return i;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),s=e.getInteriorRingN(l),i=n.compareToSameClass(s,t);if(0!==i)return i;l++}return l<r?1:l<o?-1:0}}apply(){if(I(arguments[0],H)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){arguments[0].filter(this)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return U.TYPENAME_POLYGON}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[it]}}class ot extends N{contains(){}}class lt extends ot{}class at extends lt{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new K}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new ct(this.array)}}let ct=class{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new S;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new K}};class ht extends U{constructor(){super(),ht.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(U.constructor_.call(this,e),null===t&&(t=[]),U.hasNullElements(t))throw new s("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new O;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ht(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();st.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=Q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}reverseInternal(){const t=this._geometries.length,e=new L(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return U.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=Q.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new at(st.asList(this._geometries)),n=new at(st.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),s=e.getNumGeometries();let i=0;for(;i<n&&i<s;){const n=this.getGeometryN(i),s=e.getGeometryN(i),r=n.compareToSameClass(s,t);if(0!==r)return r;i++}return i<n?1:i<s?-1:0}}apply(){if(I(arguments[0],H)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],J)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return U.checkNotGeometryCollection(this),g.shouldNeverReachHere(),null}getGeometryType(){return U.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}}class ut extends ht{constructor(){super(),ut.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ut(t,this._factory)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return Q.FALSE}getTypeCode(){return U.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return U.TYPENAME_MULTIPOINT}get interfaces_(){return[tt]}}class gt extends ${constructor(){super(),gt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];$.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new gt(this._points.copy(),this._factory)}getBoundaryDimension(){return Q.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return j.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return U.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new s("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<gt.MINIMUM_VALID_SIZE)throw new s("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return U.TYPENAME_LINEARRING}}gt.MINIMUM_VALID_SIZE=4;class dt{static measures(t){return t instanceof y?0:t instanceof x||t instanceof E?1:0}static dimension(t){return t instanceof y?2:t instanceof x?3:t instanceof E?4:3}static create(){if(1===arguments.length){const t=arguments[0];return dt.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new y:3===t&&0===e?new m:3===t&&1===e?new x:4===t&&1===e?new E:new m}}}class _t{static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(_t.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=_t.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);Y.arraycopy(t,n,s,0,t.length-n),Y.arraycopy(t,0,s,t.length-n,n),Y.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new R;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,dt.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!_t.hasRepeatedPoints(t))return t;return new R(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new O;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(_t.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,dt.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=V.clamp(e,0,t.length);let s=(n=V.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}}_t.ForwardComparator=class{compare(t,e){const n=t,s=e;return _t.compare(n,s)}get interfaces_(){return[a]}},_t.BidirectionalComparator=class{compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=_t.compare(n,s);return _t.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=_t.increasingDirection(n),r=_t.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}get interfaces_(){return[a]}},_t.coordArrayType=new Array(0).fill(null);class pt{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class mt{constructor(){mt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];mt.constructor_.call(this,t,_t.dimension(t),_t.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new m}else if(I(arguments[0],G)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];mt.constructor_.call(this,t,e,_t.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=dt.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getM(t){return this.hasM()?this._coordinates[t].getM():r.NaN}setOrdinate(t,e,n){switch(e){case G.X:this._coordinates[t].x=n;break;case G.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():r.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case G.X:return this._coordinates[t].x;case G.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return dt.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new mt(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new pt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}get interfaces_(){return[G,c]}}class ft{static instance(){return ft.instanceObject}readResolve(){return ft.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new mt(arguments[0])}if(I(arguments[0],G)){return new mt(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new mt(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new mt(arguments[0],e+t,t)}}}get interfaces_(){return[X,c]}}ft.instanceObject=new ft;class yt extends ht{constructor(){super(),yt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new yt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return U.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new L;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return U.TYPENAME_MULTIPOLYGON}get interfaces_(){return[it]}}let xt=class{get(){}put(){}size(){}values(){}entrySet(){}};class Et extends ot{constructor(t){super(),this.map=new Map,t instanceof N&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new K}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new It(this.map)}[Symbol.iterator](){return this.map}}let It=class{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new S;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new K}};class Nt extends xt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new L,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new Et;return this.map.entries().forEach((e=>t.add(e))),t}size(){return this.map.size()}}class wt{constructor(){wt.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=wt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Ct){const t=arguments[0];this._modelType=t,t===wt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=wt.FIXED,this.setScale(t)}else if(arguments[0]instanceof wt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof wt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return b.compare(n,s)}getScale(){return this._scale}isFloating(){return this._modelType===wt.FLOATING||this._modelType===wt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===wt.FLOATING?t="Floating":this._modelType===wt.FLOATING_SINGLE?t="Floating-Single":this._modelType===wt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(r.isNaN(t))return t;if(this._modelType===wt.FLOATING_SINGLE){return t}return this._modelType===wt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof m){const t=arguments[0];if(this._modelType===wt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===wt.FLOATING?t=16:this._modelType===wt.FLOATING_SINGLE?t=6:this._modelType===wt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}get interfaces_(){return[c,o]}}class Ct{constructor(){Ct.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,Ct.nameToTypeMap.put(t,this)}readResolve(){return Ct.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[c]}}Ct.nameToTypeMap=new Nt,wt.Type=Ct,wt.FIXED=new Ct("FIXED"),wt.FLOATING=new Ct("FLOATING"),wt.FLOATING_SINGLE=new Ct("FLOATING SINGLE"),wt.maximumPreciseValue=9007199254740992;class St extends ht{constructor(){super(),St.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ht.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new St(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof U){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?Q.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return U.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new K}getGeometryType(){return U.TYPENAME_MULTILINESTRING}get interfaces_(){return[Z]}}class Lt{constructor(){Lt.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Lt.constructor_.call(this,new wt,0);else if(1===arguments.length){if(I(arguments[0],X)){const t=arguments[0];Lt.constructor_.call(this,new wt,0,t)}else if(arguments[0]instanceof wt){const t=arguments[0];Lt.constructor_.call(this,t,0,Lt.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Lt.constructor_.call(this,t,e,Lt.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return ft.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new s("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new m(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new m(t.getMinX(),t.getMinY()),new m(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new m(t.getMinX(),t.getMinY()),new m(t.getMinX(),t.getMaxY()),new m(t.getMaxX(),t.getMaxY()),new m(t.getMaxX(),t.getMinY()),new m(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],G)){return new $(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new St(null,this);if(1===arguments.length){return new St(arguments[0],this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof ht&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Lt.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof rt)return this.createMultiPolygon(Lt.toPolygonArray(t));if(i instanceof $)return this.createMultiLineString(Lt.toLineStringArray(t));if(i instanceof et)return this.createMultiPoint(Lt.toPointArray(t));g.shouldNeverReachHere("Unhandled geometry type: "+i.getGeometryType())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(I(arguments[0],G)){return new et(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(I(arguments[0],G)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof gt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new rt(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new ht(null,this);if(1===arguments.length){return new ht(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],G)){return new gt(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new yt(null,this);if(1===arguments.length){return new yt(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new ut(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new ut(arguments[0],this)}if(I(arguments[0],G)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());j.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}get interfaces_(){return[c]}}const Tt="XY",Rt="XYZ",Pt="XYM",Ot="XYZM",vt={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},bt="EMPTY",Mt=1,Dt=2,At=3,Ft=4,Gt=5,qt=6;for(const t in vt)vt[t].toUpperCase();class Bt{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,s=t;if("("==t)n=Dt;else if(","==t)n=Gt;else if(")"==t)n=At;else if(this.isNumeric_(t)||"-"==t)n=Ft,s=this.readNumber_();else if(this.isAlpha_(t))n=Mt,s=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=qt}return{position:e,value:s,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,s=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(s=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!s&&("e"==t||"E"==t)||s&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class Yt{constructor(t,e){this.lexer_=t,this.token_,this.layout_=Tt,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){this.consume_();return this.parseGeometry_()}parseGeometryLayout_(){let t=Tt;const e=this.token_;if(this.isTokenType(Mt)){const n=e.value;"Z"===n?t=Rt:"M"===n?t=Pt:"ZM"===n&&(t=Ot),t!==Tt&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(Dt)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(Gt));if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(Dt)){const t=this.parsePoint_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(Dt)){const t=this.parsePointList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(Dt)){const t=this.parseLineStringTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(Dt)){let t;if(t=this.token_.type==Dt?this.parsePointTextList_():this.parsePointList_(),this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(Dt)){const t=this.parseLineStringTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(Dt)){const t=this.parsePolygonTextList_();if(this.match(At))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(Ft))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(Gt);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(Gt);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(Gt);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(Gt);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(Mt)&&this.token_.value==bt;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>new m(...t),n=n=>{const s=n.map((n=>t.createLinearRing(n.map(e))));return s.length>1?t.createPolygon(s[0],s.slice(1)):t.createPolygon(s[0])},s=this.token_;if(this.match(Mt)){const i=s.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==i){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(i){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new m(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const s=n.map(e).map((e=>t.createPoint(e)));return t.createMultiPoint(s)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map((n=>t.createLineString(n.map(e))));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const s=e.map(n);return t.createMultiPolygon(s)}default:throw new Error("Invalid geometry type: "+i)}}throw new Error(this.formatErrorMessage_())}}function Vt(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return void 0===e.z||Number.isNaN(e.z)||n.push(e.z),void 0===e.m||Number.isNaN(e.m)||n.push(e.m),n.join(" ")}function zt(t){const e=t.getCoordinates().map((t=>{const e=[t.x,t.y];return void 0===t.z||Number.isNaN(t.z)||e.push(t.z),void 0===t.m||Number.isNaN(t.m)||e.push(t.m),e})),n=[];for(let t=0,s=e.length;t<s;++t)n.push(e[t].join(" "));return n.join(", ")}function Xt(t){const e=[];e.push("("+zt(t.getExteriorRing())+")");for(let n=0,s=t.getNumInteriorRing();n<s;++n)e.push("("+zt(t.getInteriorRingN(n))+")");return e.join(", ")}const kt={Point:Vt,LineString:zt,LinearRing:zt,Polygon:Xt,MultiPoint:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Vt(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+zt(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Xt(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push(Ut(t.getGeometryN(n)));return e.join(", ")}};function Ut(t){let e=t.getGeometryType();const n=kt[e];e=e.toUpperCase();const s=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return void 0===n.z||Number.isNaN(n.z)||(e+="Z"),void 0===n.m||Number.isNaN(n.m)||(e+="M"),e}(t);if(s.length>0&&(e+=" "+s),t.isEmpty())return e+" "+bt;return e+" ("+n(t)+")"}class Ht{constructor(t){this.geometryFactory=t||new Lt,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new Bt(t);return new Yt(e,this.geometryFactory).parse()}write(t){return Ut(t)}}class Wt{constructor(t){this.parser=new Ht(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class Zt{constructor(){Zt.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map((()=>Array(2))),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new m,this._intPt[1]=new m,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return g.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return g.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new pt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map((()=>Array(2))),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Zt.NO_INTERSECTION}getEdgeDistance(t,e){return Zt.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Zt.COLLINEAR_INTERSECTION}toString(){return Wt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Wt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Zt.DONT_INTERSECT=0,Zt.DO_INTERSECT=1,Zt.COLLINEAR=2,Zt.NO_INTERSECTION=0,Zt.POINT_INTERSECTION=1,Zt.COLLINEAR_INTERSECTION=2;class jt extends Zt{constructor(){super()}static nearestEndpoint(t,e,n,s){let i=t,r=z.pointToSegment(t,n,s),o=z.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=z.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=z.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new O(this._inputLines[0][0],this._inputLines[0][1]),n=new O(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,O.intersects(e,n,t)&&0===q.index(e,n,t)&&0===q.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Zt.POINT_INTERSECTION,null;this._result=Zt.NO_INTERSECTION}}intersection(t,e,n,s){let i=this.intersectionSafe(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new m(jt.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}checkDD(t,e,n,s,i){const r=F.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);Y.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&Y.out.println("Distance = "+i.distance(r))}intersectionSafe(t,e,n,s){let i=B.intersection(t,e,n,s);return null===i&&(i=jt.nearestEndpoint(t,e,n,s)),i}computeCollinearIntersection(t,e,n,s){const i=O.intersects(t,e,n),r=O.intersects(t,e,s),o=O.intersects(n,s,t),l=O.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,Zt.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Zt.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):Zt.NO_INTERSECTION}computeIntersect(t,e,n,s){if(this._isProper=!1,!O.intersects(t,e,n,s))return Zt.NO_INTERSECTION;const i=q.index(t,e,n),r=q.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return Zt.NO_INTERSECTION;const o=q.index(n,s,t),l=q.index(n,s,e);if(o>0&&l>0||o<0&&l<0)return Zt.NO_INTERSECTION;return 0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new m(n):0===r?this._intPt[0]=new m(s):0===o?this._intPt[0]=new m(t):0===l&&(this._intPt[0]=new m(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),Zt.POINT_INTERSECTION)}}class Kt{constructor(){Kt.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)Kt.constructor_.call(this,new m,new m);else if(1===arguments.length){const t=arguments[0];Kt.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,new m(t,e),new m(n,s))}}static midPoint(t,e){return new m((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof Kt){const t=arguments[0],e=q.index(this.p0,this.p1,t.p0),n=q.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof m){const t=arguments[0];return q.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof Kt))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new jt;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof m){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new m(t);const e=this.projectionFactor(t),n=new m;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof Kt){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new Kt(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return z.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return Kt.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;if(s<=0)return r.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=r.MAX_VALUE,i=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);i=l.distance(t.p1),i<s&&(s=i,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);i=a.distance(this.p0),i<s&&(s=i,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return i=c.distance(this.p1),i<s&&(s=i,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return B.intersection(this.p0,this.p1,t.p0,t.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new D("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new m(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||r.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),s=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),i=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new m((-r*o-2*e*n*l-2*e*s)/i,(r*l-2*e*n*o-2*n*s)/i)}distance(){if(arguments[0]instanceof Kt){const t=arguments[0];return z.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof m){const t=arguments[0];return z.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new m;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=r.doubleToLongBits(this.p0.x);t^=31*r.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=r.doubleToLongBits(this.p1.x);n^=31*r.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))}get interfaces_(){return[o,c]}}class Qt{static toLocationSymbol(t){switch(t){case Qt.EXTERIOR:return"e";case Qt.BOUNDARY:return"b";case Qt.INTERIOR:return"i";case Qt.NONE:return"-"}throw new s("Unknown location value: "+t)}}Qt.INTERIOR=0,Qt.BOUNDARY=1,Qt.EXTERIOR=2,Qt.NONE=-1;class Jt{constructor(){Jt.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map((()=>Array(3))),this.setAll(Q.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Jt.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Jt){const t=arguments[0];Jt.constructor_.call(this),this._matrix[Qt.INTERIOR][Qt.INTERIOR]=t._matrix[Qt.INTERIOR][Qt.INTERIOR],this._matrix[Qt.INTERIOR][Qt.BOUNDARY]=t._matrix[Qt.INTERIOR][Qt.BOUNDARY],this._matrix[Qt.INTERIOR][Qt.EXTERIOR]=t._matrix[Qt.INTERIOR][Qt.EXTERIOR],this._matrix[Qt.BOUNDARY][Qt.INTERIOR]=t._matrix[Qt.BOUNDARY][Qt.INTERIOR],this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]=t._matrix[Qt.BOUNDARY][Qt.BOUNDARY],this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]=t._matrix[Qt.BOUNDARY][Qt.EXTERIOR],this._matrix[Qt.EXTERIOR][Qt.INTERIOR]=t._matrix[Qt.EXTERIOR][Qt.INTERIOR],this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]=t._matrix[Qt.EXTERIOR][Qt.BOUNDARY],this._matrix[Qt.EXTERIOR][Qt.EXTERIOR]=t._matrix[Qt.EXTERIOR][Qt.EXTERIOR]}}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===Q.SYM_DONTCARE||(e===Q.SYM_TRUE&&(t>=0||t===Q.TRUE)||(e===Q.SYM_FALSE&&t===Q.FALSE||(e===Q.SYM_P&&t===Q.P||(e===Q.SYM_L&&t===Q.L||e===Q.SYM_A&&t===Q.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Jt(arguments[0]).matches(t)}}static isTrue(t){return t>=0||t===Q.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE}isCoveredBy(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=Q.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,Q.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===Q.A&&e===Q.A||t===Q.L&&e===Q.L||t===Q.L&&e===Q.A||t===Q.P&&e===Q.A||t===Q.P&&e===Q.L)&&(this._matrix[Qt.INTERIOR][Qt.INTERIOR]===Q.FALSE&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY])))}isOverlaps(t,e){return t===Q.P&&e===Q.P||t===Q.A&&e===Q.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===Q.L&&e===Q.L&&(1===this._matrix[Qt.INTERIOR][Qt.INTERIOR]&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]))}isEquals(t,e){return t===e&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===Q.FALSE)}toString(){const t=new pt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,Q.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new s("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Jt.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[Qt.INTERIOR][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.INTERIOR][Qt.BOUNDARY]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.INTERIOR]===Q.FALSE&&this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]===Q.FALSE}isCrosses(t,e){return t===Q.P&&e===Q.L||t===Q.P&&e===Q.A||t===Q.L&&e===Q.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR]):t===Q.L&&e===Q.P||t===Q.A&&e===Q.P||t===Q.A&&e===Q.L?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===Q.L&&e===Q.L&&0===this._matrix[Qt.INTERIOR][Qt.INTERIOR]}get interfaces_(){return[l]}}class $t{static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=$t.PI_TIMES_2;for(;t<=-Math.PI;)t+=$t.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=$t.PI_TIMES_2;t>=$t.PI_TIMES_2&&(t=0)}else{for(;t>=$t.PI_TIMES_2;)t-=$t.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return $t.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?$t.COUNTERCLOCKWISE:n<0?$t.CLOCKWISE:$t.NONE}static angleBetweenOriented(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n)-s;return i<=-Math.PI?i+$t.PI_TIMES_2:i>Math.PI?i-$t.PI_TIMES_2:i}}$t.PI_TIMES_2=2*Math.PI,$t.PI_OVER_2=Math.PI/2,$t.PI_OVER_4=Math.PI/4,$t.COUNTERCLOCKWISE=q.COUNTERCLOCKWISE,$t.CLOCKWISE=q.CLOCKWISE,$t.NONE=q.COLLINEAR;class te extends n{constructor(){super(),te.constructor_.apply(this,arguments)}static constructor_(){n.constructor_.call(this,"Projective point not representable on the Cartesian plane.")}}class ee{constructor(){ee.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof ee&&arguments[1]instanceof ee){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}}getY(){const t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getX(){const t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getCoordinate(){const t=new m;return t.x=this.getX(),t.y=this.getY(),t}}class ne{constructor(){ne.constructor_.apply(this,arguments)}static constructor_(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static circumcentreDD(t,e,n){const s=A.valueOf(t.x).subtract(n.x),i=A.valueOf(t.y).subtract(n.y),r=A.valueOf(e.x).subtract(n.x),o=A.valueOf(e.y).subtract(n.y),l=A.determinant(s,i,r,o).multiply(2),a=s.sqr().add(i.sqr()),c=r.sqr().add(o.sqr()),h=A.determinant(i,a,o,c),u=A.determinant(s,a,r,c),g=A.valueOf(n.x).subtract(h.divide(l)).doubleValue(),d=A.valueOf(n.y).add(u.divide(l)).doubleValue();return new m(g,d)}static isAcute(t,e,n){return!!$t.isAcute(t,e,n)&&(!!$t.isAcute(e,n,t)&&!!$t.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*ne.det(r,o,l,a),h=ne.det(o,r*r+o*o,a,l*l+a*a),u=ne.det(r,r*r+o*o,l,l*l+a*a);return new m(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new ee(t.x+n/2,t.y+s/2,1),r=new ee(t.x-s+n/2,t.y+n+s/2,1);return new ee(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new m(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.getZ()-t.getZ(),o=n.x-t.x,l=n.y-t.y,a=n.getZ()-t.getZ(),c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new m(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new m(l,a)}area(){return ne.area(this.p0,this.p1,this.p2)}signedArea(){return ne.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new s("Supplied point is null.");return ne.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return ne.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return ne.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return ne.circumcentre(this.p0,this.p1,this.p2)}area3D(){return ne.area3D(this.p0,this.p1,this.p2)}centroid(){return ne.centroid(this.p0,this.p1,this.p2)}inCentre(){return ne.inCentre(this.p0,this.p1,this.p2)}}class se extends n{constructor(){super(),se.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)n.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];n.constructor_.call(this,t)}}}class ie{constructor(){ie.constructor_.apply(this,arguments)}static constructor_(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof ie){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}}static translationInstance(t,e){const n=new ie;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new ie;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return ie.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return ie.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,n,i){if(t===n&&e===i)throw new s("Reflection line points must be distinct");const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new se("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new ie(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof ie))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(ie.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(ie.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(ie.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.rotationInstance(t,e,n,s)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof n))throw t;g.shouldNeverReachHere()}return null}translate(t,e){return this.compose(ie.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const n=Math.sqrt(t*t+e*e),i=e/n,r=t/n;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];if(t===n&&e===i)throw new s("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(ie.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(I(arguments[0],G)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.reflectionInstance(t,e,n,s)),this}}get interfaces_(){return[l,P]}}class re{static solve(t,e){const n=e.length;if(t.length!==n||t[0].length!==n)throw new s("Matrix A is incorrectly sized");for(let s=0;s<n;s++){let i=s;for(let e=s+1;e<n;e++)Math.abs(t[e][s])>Math.abs(t[i][s])&&(i=e);if(0===t[i][s])return null;re.swapRows(t,s,i),re.swapRows(e,s,i);for(let i=s+1;i<n;i++){const r=t[i][s]/t[s][s];for(let e=n-1;e>=s;e--)t[i][e]-=t[s][e]*r;e[i]-=e[s]*r}}const i=new Array(n).fill(null);for(let s=n-1;s>=0;s--){let r=0;for(let e=s+1;e<n;e++)r+=t[s][e]*i[e];i[s]=(e[s]-r)/t[s][s]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}}class oe{constructor(){oe.constructor_.apply(this,arguments)}static constructor_(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return re.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new ie(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}}class le{static createFromBaseLines(t,e,n,s){const i=new m(t.x+s.x-n.x,t.y+s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new ie;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return ie.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new s("Src and Dest arrays are not the same length");if(t.length<=0)throw new s("Too few control points");if(t.length>3)throw new s("Too many control points");return 1===t.length?le.createFromControlVectors(t[0],e[0]):2===t.length?le.createFromControlVectors(t[0],t[1],e[0],e[1]):le.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new m(s.x-n.x,s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){return new oe(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]).getTransformation()}}}}class ae{constructor(){ae.constructor_.apply(this,arguments)}static constructor_(){this._coords=null;const t=arguments[0];this._coords=t}static getCoordinates(t){const e=new L;return t.apply(new ae(e)),e}filter(t){(t instanceof $||t instanceof et)&&this._coords.add(t.getCoordinate())}get interfaces_(){return[k]}}class ce{constructor(){ce.constructor_.apply(this,arguments)}static constructor_(){this._mapOp=null;const t=arguments[0];this._mapOp=t}static map(t,e){return new ce(e).map(t)}map(t){const e=new L;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Lt.toGeometryArray(e))}}class he{constructor(){he.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=he.extractFactory(t),this._inputGeoms=t}static combine(){if(1===arguments.length){return new he(arguments[0]).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new he(he.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new he(he.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new L;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new L;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}}class ue{constructor(){ue.constructor_.apply(this,arguments)}static constructor_(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof ht?this.editGeometryCollection(t,e):t instanceof rt?this.editPolygon(t,e):t instanceof et||t instanceof $?e.edit(t,this._factory):(g.shouldNeverReachHere("Unsupported Geometry type: "+t.getGeometryType()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new L;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getGeometryType()===U.TYPENAME_MULTIPOINT?this._factory.createMultiPoint(s.toArray([])):n.getGeometryType()===U.TYPENAME_MULTILINESTRING?this._factory.createMultiLineString(s.toArray([])):n.getGeometryType()===U.TYPENAME_MULTIPOLYGON?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new L;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}}function ge(){}ue.GeometryEditorOperation=ge;ue.NoOpGeometryOperation=class{edit(t,e){return t}get interfaces_(){return[ge]}},ue.CoordinateOperation=class{edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof gt?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof $?null===n?e.createLineString():e.createLineString(n):t instanceof et?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}get interfaces_(){return[ge]}},ue.CoordinateSequenceOperation=class{edit(t,e){return t instanceof gt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof $?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof et?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}get interfaces_(){return[ge]}};class de{constructor(){de.constructor_.apply(this,arguments)}static constructor_(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e}static isOfType(t,e){return t.getGeometryType()===e||e===U.TYPENAME_LINESTRING&&t.getGeometryType()===U.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return de.extract(t,e,new L)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof ht&&t.apply(new de(e,n)),n}}filter(t){(null===this._geometryType||de.isOfType(t,this._geometryType))&&this._comps.add(t)}get interfaces_(){return[J]}}class _e{static map(){if(arguments[0]instanceof U&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(I(arguments[0],N)&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}}function pe(){}_e.MapOp=pe;class me{constructor(){me.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof gt&&!s.isEmpty()||(n=!1);const i=new L;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof gt||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new L;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Lt.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof et)return this.transformPoint(t,null);if(t instanceof ut)return this.transformMultiPoint(t,null);if(t instanceof gt)return this.transformLinearRing(t,null);if(t instanceof $)return this.transformLineString(t,null);if(t instanceof St)return this.transformMultiLineString(t,null);if(t instanceof rt)return this.transformPolygon(t,null);if(t instanceof yt)return this.transformMultiPolygon(t,null);if(t instanceof ht)return this.transformGeometryCollection(t,null);throw new s("Unknown Geometry subtype: "+t.getGeometryType())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}}class fe{constructor(){fe.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getGeometry(t){return t.getFactory().buildGeometry(fe.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return fe.getLines(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof $?e.add(t):t instanceof ht&&t.apply(new fe(e)),e}}filter(t){t instanceof $&&this._comps.add(t)}get interfaces_(){return[J]}}class ye{constructor(){ye.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(ye.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(ye.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,!1)}if(2===arguments.length){if(I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();ye.getLines(n,t)}return t}if(arguments[0]instanceof U&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new L;return t.apply(new ye(n,e)),n}if(arguments[0]instanceof U&&I(arguments[1],N)){const t=arguments[0],e=arguments[1];return t instanceof $?e.add(t):t.apply(new ye(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const s=n.next();ye.getLines(s,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof U&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new ye(t,e)),t}}}filter(t){if(this._isForcedToLineString&&t instanceof gt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof $&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[k]}}const xe={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return xe.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?st.sort(n,e):st.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new L;return e.add(t),e}};class Ee{constructor(){Ee.constructor_.apply(this,arguments)}static constructor_(){this._pts=null;const t=arguments[0];this._pts=t}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof et?xe.singletonList(t):Ee.getPoints(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof et?e.add(t):t instanceof ht&&t.apply(new Ee(e)),e}}filter(t){t instanceof et&&this._pts.add(t)}get interfaces_(){return[J]}}class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ie.getPolygons(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof rt?e.add(t):t instanceof ht&&t.apply(new Ie(e)),e}}filter(t){t instanceof rt&&this._comps.add(t)}get interfaces_(){return[J]}}class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof ht)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class we{constructor(){we.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._precModel=null,this._dim=new Ce,this._nPts=100,this._rotationAngle=0,0===arguments.length)we.constructor_.call(this,new Lt);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new m(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=ie.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new m(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}}class Ce{constructor(){Ce.constructor_.apply(this,arguments)}static constructor_(){this.base=null,this.centre=null,this.width=null,this.height=null}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new m(t.getMinX(),t.getMinY()),this.centre=new m(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new O(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new O(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new O(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new m(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}}we.Dimensions=Ce;class Se extends we{constructor(){super(),Se.constructor_.apply(this,arguments)}static constructor_(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)we.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];we.constructor_.call(this,t)}}static create(t,e,n,s,i){const r=new Se;r.setCentre(t),r.setSize(e),r.setNumPoints(n),r.setArmLengthRatio(i),r.setNumArms(s);return r.createSineStar()}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new m(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}}var Le=Object.freeze({__proto__:null,AffineTransformation:ie,AffineTransformationBuilder:oe,AffineTransformationFactory:le,ComponentCoordinateExtracter:ae,GeometryCollectionMapper:ce,GeometryCombiner:he,GeometryEditor:ue,GeometryExtracter:de,GeometryMapper:_e,GeometryTransformer:me,LineStringExtracter:fe,LinearComponentExtracter:ye,PointExtracter:Ee,PolygonExtracter:Ie,ShortCircuitedGeometryVisitor:Ne,SineStarFactory:Se}),Te=Object.freeze({__proto__:null,Coordinate:m,CoordinateXY:y,CoordinateXYM:x,CoordinateXYZM:E,CoordinateList:R,CoordinateSequenceFilter:P,Envelope:O,LineSegment:Kt,GeometryFactory:Lt,Geometry:U,Point:et,LineString:$,LinearRing:gt,Polygon:rt,GeometryCollection:ht,MultiPoint:ut,MultiLineString:St,MultiPolygon:yt,Dimension:Q,IntersectionMatrix:Jt,PrecisionModel:wt,Location:Qt,Triangle:ne,util:Le});class Re{constructor(){Re.constructor_.apply(this,arguments)}static constructor_(){this._pt=[new m,new m],this._distance=r.NaN,this._isNull=!0}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Wt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}}class Pe{static computeDistance(){if(arguments[2]instanceof Re&&arguments[0]instanceof $&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Kt,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Re&&arguments[0]instanceof rt&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];Pe.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)Pe.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Re&&arguments[0]instanceof U&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof $)Pe.computeDistance(t,e,n);else if(t instanceof rt)Pe.computeDistance(t,e,n);else if(t instanceof ht){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);Pe.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Re&&arguments[0]instanceof Kt&&arguments[1]instanceof m){const t=arguments[1],e=arguments[2],n=arguments[0].closestPoint(t);e.setMinimum(n,t)}}}class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static constructor_(){this._g0=null,this._g1=null,this._ptDist=new Re,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e}static distance(){if(2===arguments.length){return new Oe(arguments[0],arguments[1]).distance()}if(3===arguments.length){const t=arguments[2],e=new Oe(arguments[0],arguments[1]);return e.setDensifyFraction(t),e.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new s("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new ve(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new be(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}}class ve{constructor(){ve.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._euclideanDist=new Pe,this._geom=null;const t=arguments[0];this._geom=t}filter(t){this._minPtDist.initialize(),Pe.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[H]}}class be{constructor(){be.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new m(e,s);this._minPtDist.initialize(),Pe.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[P]}}Oe.MaxPointDistanceFilter=ve,Oe.MaxDensifiedByFractionDistanceFilter=be;var Me=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:Pe,PointPairDistance:Re});class De{visitItem(t){}}class Ae{locate(t){}}class Fe{constructor(){Fe.constructor_.apply(this,arguments)}static constructor_(){this._min=r.POSITIVE_INFINITY,this._max=r.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Wt.toLineString(new m(this._min,0),new m(this._max,0))}}Fe.NodeComparator=class{compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}get interfaces_(){return[a]}};class Ge extends Fe{constructor(){super(),Ge.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class qe extends Fe{constructor(){super(),qe.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class Be{constructor(){Be.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new L,this._root=null,this._level=0}buildTree(){xe.sort(this._leaves,new Fe.NodeComparator);let t=this._leaves,e=null,n=new L;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new D("Index cannot be added to once it has been queried");this._leaves.add(new Ge(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){Y.out.println(Wt.toLineString(new m(t._min,this._level),new m(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new qe(t.get(n),t.get(n+1));e.add(s)}}}}class Ye{constructor(){Ye.constructor_.apply(this,arguments)}static constructor_(){this._items=new L}visitItem(t){this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class Ve{constructor(){Ve.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof m&&I(arguments[1],G)){const t=arguments[1],e=new Ve(arguments[0]),n=new m,s=new m;for(let i=1;i<t.size();i++)if(t.getCoordinate(i,n),t.getCoordinate(i-1,s),e.countSegment(n,s),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[1],e=new Ve(arguments[0]);for(let n=1;n<t.length;n++){const s=t[n],i=t[n-1];if(e.countSegment(s,i),e.isOnSegment())return e.getLocation()}return e.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=q.index(t,e,this._p);if(n===q.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===q.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==Qt.EXTERIOR}getLocation(){return this._isPointOnSegment?Qt.BOUNDARY:this._crossingCount%2==1?Qt.INTERIOR:Qt.EXTERIOR}isOnSegment(){return this._isPointOnSegment}}class ze{constructor(){ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(I(t,it)||t instanceof gt))throw new s("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new ke(this._geom),this._geom=null);const e=new Ve(t),n=new Xe(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[Ae]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[De]}}class ke{constructor(){ke.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new Be;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new Kt(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new L;const n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}ze.SegmentVisitor=Xe,ze.IntervalIndexedGeometry=ke;class Ue{static isOnLine(){if(arguments[0]instanceof m&&I(arguments[1],G)){const t=arguments[0],e=arguments[1],n=new jt,s=new m,i=new m,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new jt;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ve.locatePointInRing(t,e)}static isInRing(t,e){return Ue.locateInRing(t,e)!==Qt.EXTERIOR}}class He{hasNext(){}next(){}remove(){}}class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof ht)}next(){if(this._atStart)return this._atStart=!1,We.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new S;const t=this._parent.getGeometryN(this._index++);return t instanceof ht?(this._subcollectionIterator=new We(t),this._subcollectionIterator.next()):t}remove(){throw new K(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}get interfaces_(){return[He]}}class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==Qt.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===Qt.BOUNDARY)return Qt.BOUNDARY;if(i===Qt.INTERIOR)return Qt.EXTERIOR}return Qt.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}static containsPointInPolygon(t,e){return Qt.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof rt)return Ze.locatePointInPolygon(t,e);if(e instanceof ht){const n=new We(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==Qt.EXTERIOR)return e}}}return Qt.EXTERIOR}static isContained(t,e){return Qt.EXTERIOR!==Ze.locate(t,e)}static locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e.getEnvelopeInternal().intersects(t)?Ze.locateInGeometry(t,e):Qt.EXTERIOR}locate(t){return Ze.locate(t,this._geom)}get interfaces_(){return[Ae]}}var je=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ze,PointOnGeometryLocator:Ae,SimplePointInAreaLocator:Ze});class Ke{measure(t,e){}}class Qe{static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,Qe.DENSIFY_FRACTION),s=new O(t.getEnvelopeInternal());s.expandToInclude(e.getEnvelopeInternal());return 1-n/Qe.diagonalSize(s)}get interfaces_(){return[Ke]}}Qe.DENSIFY_FRACTION=.25;var Je=Object.freeze({__proto__:null,AreaSimilarityMeasure:class{measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}get interfaces_(){return[Ke]}},HausdorffSimilarityMeasure:Qe,SimilarityMeasure:Ke,SimilarityMeasureCombiner:class{static combine(t,e){return Math.min(t,e)}}});class $e{constructor(){$e.constructor_.apply(this,arguments)}static constructor_(){this._areaBasePt=null,this._triangleCent3=new m,this._areasum2=0,this._cg3=new m,this._lineCentSum=new m,this._totalLength=0,this._ptCount=0,this._ptCentSum=new m;const t=arguments[0];this._areaBasePt=null,this.add(t)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new $e(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=q.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new m;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!q.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;$e.centroid3(t,e,n,this._triangleCent3);const r=$e.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof rt){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof U){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof et)this.addPoint(t.getCoordinate());else if(t instanceof $)this.addLineSegments(t.getCoordinates());else if(t instanceof rt){const e=t;this.add(e)}else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}}class tn extends n{constructor(t){super(t),this.name=Object.keys({EmptyStackException:tn})[0]}}class en extends C{constructor(){super(),this.array=[]}add(t){return this.array.push(t),!0}get(t){if(t<0||t>=this.size())throw new w;return this.array[t]}push(t){return this.array.push(t),t}pop(){if(0===this.array.length)throw new tn;return this.array.pop()}peek(){if(0===this.array.length)throw new tn;return this.array[this.array.length-1]}empty(){return 0===this.array.length}isEmpty(){return this.empty()}search(t){return this.array.indexOf(t)}size(){return this.array.length}toArray(){return this.array.slice()}}class nn{constructor(){nn.constructor_.apply(this,arguments)}static constructor_(){this._coordSet=new Et,this._list=new L}static filterCoordinates(t){const e=new nn;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this._coordSet.add(t)&&this._list.add(t)}getCoordinates(){const t=new Array(this._list.size()).fill(null);return this._list.toArray(t)}get interfaces_(){return[H]}}class sn{constructor(){sn.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];sn.constructor_.call(this,sn.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=nn.filterCoordinates(t),this._geomFactory=e}}static extractCoordinates(t){const e=new nn;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return st.sort(t,1,t.length,new rn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new R;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){g.equals(t[0],t[t.length-1]);const e=new L;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==q.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new at;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)Ue.isInRing(t[s],e)||n.add(t[s]);const s=_t.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new en;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&q.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}}class rn{constructor(){rn.constructor_.apply(this,arguments)}static constructor_(){this._origin=null;const t=arguments[0];this._origin=t}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=q.index(t,e,n);if(l===q.COUNTERCLOCKWISE)return 1;if(l===q.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return rn.polarCompare(this._origin,n,s)}get interfaces_(){return[a]}}sn.RadialComparator=rn;class on{constructor(){on.constructor_.apply(this,arguments)}static constructor_(){this._interiorPoint=null,this._maxWidth=-1;const t=arguments[0];this.process(t)}static getInteriorPoint(t){return new on(t).getInteriorPoint()}static avg(t,e){return(t+e)/2}getInteriorPoint(){return this._interiorPoint}process(t){if(t.isEmpty())return null;if(t instanceof rt)this.processPolygon(t);else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.process(e.getGeometryN(t))}}processPolygon(t){const e=new ln(t);e.process();const n=e.getWidth();n>this._maxWidth&&(this._maxWidth=n,this._interiorPoint=e.getInteriorPoint())}}class ln{constructor(){ln.constructor_.apply(this,arguments)}static constructor_(){this._polygon=null,this._interiorPointY=null,this._interiorSectionWidth=0,this._interiorPoint=null;const t=arguments[0];this._polygon=t,this._interiorPointY=cn.getScanLineY(t)}static isEdgeCrossingCounted(t,e,n){const s=t.getY(),i=e.getY();return s!==i&&(!(s===n&&i<n)&&!(i===n&&s<n))}static intersectsHorizontalLine(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!(e<t.getMinY())&&!(e>t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return!(t.getY()>n&&e.getY()>n)&&!(t.getY()<n&&e.getY()<n)}}static intersection(t,e,n){const s=t.getX(),i=e.getX();if(s===i)return s;const r=i-s,o=(e.getY()-t.getY())/r;return s+(n-t.getY())/o}findBestMidpoint(t){if(0===t.size())return null;g.isTrue(0==t.size()%2,"Interior Point robustness failure: odd number of scanline crossings"),t.sort(new an);for(let e=0;e<t.size();e+=2){const n=t.get(e),s=t.get(e+1),i=s-n;if(i>this._interiorSectionWidth){this._interiorSectionWidth=i;const t=on.avg(n,s);this._interiorPoint=new m(t,this._interiorPointY)}}}process(){if(this._polygon.isEmpty())return null;this._interiorPoint=new m(this._polygon.getCoordinate());const t=new L;this.scanRing(this._polygon.getExteriorRing(),t);for(let e=0;e<this._polygon.getNumInteriorRing();e++)this.scanRing(this._polygon.getInteriorRingN(e),t);this.findBestMidpoint(t)}scanRing(t,e){if(!ln.intersectsHorizontalLine(t.getEnvelopeInternal(),this._interiorPointY))return null;const n=t.getCoordinateSequence();for(let t=1;t<n.size();t++){const s=n.getCoordinate(t-1),i=n.getCoordinate(t);this.addEdgeCrossing(s,i,this._interiorPointY,e)}}getWidth(){return this._interiorSectionWidth}getInteriorPoint(){return this._interiorPoint}addEdgeCrossing(t,e,n,s){if(!ln.intersectsHorizontalLine(t,e,n))return null;if(!ln.isEdgeCrossingCounted(t,e,n))return null;const i=ln.intersection(t,e,n);s.add(i)}}class an{compare(t,e){return t<e?-1:t>e?1:0}get interfaces_(){return[a]}}ln.DoubleComparator=an;class cn{constructor(){cn.constructor_.apply(this,arguments)}static constructor_(){this._poly=null,this._centreY=null,this._hiY=r.MAX_VALUE,this._loY=-r.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=on.avg(this._loY,this._hiY)}static getScanLineY(t){return new cn(t).getScanLineY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getScanLineY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return on.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}}on.InteriorPointPolygon=ln,on.ScanLineYOrdinateFinder=cn;class hn{constructor(){hn.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=null:(this._centroid=$e.getCentroid(t),t.getPrecisionModel().makePrecise(this._centroid)),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)}static getInteriorPoint(t){return new hn(t).getInteriorPoint()}addEndpoints(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof $)this.addEndpoints(t.getCoordinates());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof $)this.addInterior(t.getCoordinates());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}class un{constructor(){un.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=$e.getCentroid(t),this.add(t)}static getInteriorPoint(t){return new un(t).getInteriorPoint()}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof U){const t=arguments[0];if(t instanceof et)this.add(t.getCoordinate());else if(t instanceof ht){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof m){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}}class gn{isInBoundary(t){}}class dn{isInBoundary(t){return t%2==1}get interfaces_(){return[gn]}}class _n{isInBoundary(t){return t>0}get interfaces_(){return[gn]}}class pn{isInBoundary(t){return t>1}get interfaces_(){return[gn]}}class mn{isInBoundary(t){return 1===t}get interfaces_(){return[gn]}}gn.Mod2BoundaryNodeRule=dn,gn.EndPointBoundaryNodeRule=_n,gn.MultiValentEndPointBoundaryNodeRule=pn,gn.MonoValentEndPointBoundaryNodeRule=mn,gn.MOD2_BOUNDARY_RULE=new dn,gn.ENDPOINT_BOUNDARY_RULE=new _n,gn.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new pn,gn.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new mn,gn.OGC_SFS_BOUNDARY_RULE=gn.MOD2_BOUNDARY_RULE;class fn{constructor(){fn.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=gn.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new s("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}intersects(t,e){return this.locate(t,e)!==Qt.EXTERIOR}updateLocationInfo(t){t===Qt.INTERIOR&&(this._isIn=!0),t===Qt.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof et&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof $)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof rt)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof St){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof yt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof ht){const n=new We(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?Qt.INTERIOR:Qt.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return Qt.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?Ue.isOnLine(t,n)?Qt.INTERIOR:Qt.EXTERIOR:Qt.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===Qt.EXTERIOR)return Qt.EXTERIOR;if(s===Qt.BOUNDARY)return Qt.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===Qt.INTERIOR)return Qt.EXTERIOR;if(i===Qt.BOUNDARY)return Qt.BOUNDARY}return Qt.INTERIOR}locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e instanceof $?this.locateOnLineString(t,e):e instanceof rt?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?Qt.BOUNDARY:this._numBoundaries>0||this._isIn?Qt.INTERIOR:Qt.EXTERIOR)}}class yn{constructor(){yn.constructor_.apply(this,arguments)}static constructor_(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t}static farthestPoints(t){const e=t[0].distance(t[1]),n=t[1].distance(t[2]),s=t[2].distance(t[0]);return e>=n&&e>=s?[t[0],t[1]]:n>=e&&n>=s?[t[1],t[2]]:[t[2],t[0]]}static pointWitMinAngleWithX(t,e){let n=r.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=r.MAX_VALUE,i=null;for(let r=0;r<t.length;r++){const o=t[r];if(o===e)continue;if(o===n)continue;const l=$t.angleBetween(e,o,n);l<s&&(s=l,i=o)}return i}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new m(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),_t.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=_t.copyDeep(e),null;let n=yn.lowestPoint(e),s=yn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=yn.pointWithMinAngleWithSegment(e,n,s);if($t.isObtuse(n,t,s))return this._extremalPts=[new m(n),new m(s)],null;if($t.isObtuse(t,n,s))n=t;else{if(!$t.isObtuse(t,s,n))return this._extremalPts=[new m(n),new m(s),new m(t)],null;s=t}}g.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}getMaximumDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre);case 2:return this._input.getFactory().createLineString([this._extremalPts[0],this._extremalPts[1]]);default:const t=yn.farthestPoints(this._extremalPts);return this._input.getFactory().createLineString(t)}}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new m((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=ne.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}}class xn{constructor(){xn.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new Kt,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];xn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new xn(t).getDiameter()}static getMinimumRectangle(t){return new xn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new m(0,n/e),i=new m(1,n/e-t/e)):(s=new m(n/t,0),i=new m(n/t-e/t,1)),new Kt(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof rt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=r.MAX_VALUE;let e=1;const n=new Kt;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new sn(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=xn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new Kt(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=r.MAX_VALUE,s=-r.MAX_VALUE,i=r.MAX_VALUE,o=-r.MAX_VALUE;for(let r=0;r<this._convexHullPts.length;r++){const l=xn.computeC(t,e,this._convexHullPts[r]);l>s&&(s=l),l<n&&(n=l);const a=xn.computeC(-e,t,this._convexHullPts[r]);a>o&&(o=a),a<i&&(i=a)}const l=xn.computeSegmentForLine(-t,-e,o),a=xn.computeSegmentForLine(-t,-e,i),c=xn.computeSegmentForLine(-e,t,s),h=xn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),p=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(p)}}var En=Object.freeze({__proto__:null,distance:Me,locate:je,match:Je,Angle:$t,Area:nt,Centroid:$e,ConvexHull:sn,Distance:z,InteriorPointArea:on,InteriorPointLine:hn,InteriorPointPoint:un,Length:W,Orientation:q,PointLocation:Ue,PointLocator:fn,RobustLineIntersector:jt,MinimumBoundingCircle:yn,MinimumDiameter:xn});class In{constructor(){In.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t}static densifyPoints(t,e,n){const s=new Kt,i=new R;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new In(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new Nn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new s("Tolerance must be positive");this._distanceTolerance=t}}class Nn extends me{constructor(){super(),Nn.constructor_.apply(this,arguments)}static constructor_(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=In.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof $&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}}In.DensifyTransformer=Nn;var wn=Object.freeze({__proto__:null,Densifier:In});class Cn{static isNorthern(t){return t===Cn.NE||t===Cn.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===Cn.SE?t===Cn.SE||t===Cn.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Cn.NE:Cn.SE:e>=0?Cn.NW:Cn.SW}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new s("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?Cn.NE:Cn.SE:e.y>=t.y?Cn.NW:Cn.SW}}}Cn.NE=0,Cn.NW=1,Cn.SW=2,Cn.SE=3;class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static constructor_(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t}static create(t,e){const n=new Sn(t),s=new Sn(e);return n.link(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}isEdgesSorted(){const t=this.findLowest();let e=t;do{const n=e.oNext();if(n===t)break;if(!(n.compareTo(e)>0))return!1;e=n}while(e!==t);return!0}oNext(){return this._sym._next}directionY(){return this.directionPt().getY()-this._orig.getY()}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;this.insertionEdge(t).insertAfter(t)}insertAfter(t){g.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof m&&arguments[0]instanceof m){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}findLowest(){let t=this,e=this.oNext();do{e.compareTo(t)<0&&(t=e),e=e.oNext()}while(e!==this);return t}directionPt(){return this.dest()}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.directionX(),n=this.directionY(),s=t.directionX(),i=t.directionY();if(e===s&&n===i)return 0;const r=Cn.quadrant(e,n),o=Cn.quadrant(s,i);if(r>o)return 1;if(r<o)return-1;const l=this.directionPt(),a=t.directionPt();return q.index(t._orig,a,l)}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}directionX(){return this.directionPt().getX()-this._orig.getX()}insertionEdge(t){let e=this;do{const n=e.oNext();if(n.compareTo(e)>0&&t.compareTo(e)>=0&&t.compareTo(n)<=0)return e;if(n.compareTo(e)<=0&&(t.compareTo(n)<=0||t.compareTo(e)>=0))return e;e=n}while(e!==this);return g.shouldNeverReachHere(),null}compareTo(t){const e=t;return this.compareAngularDirection(e)}toStringNode(){const t=this.orig();this.dest();const e=new pt;e.append("Node( "+Wt.format(t)+" )\n");let n=this;do{e.append("  -> "+n),e.append("\n"),n=n.oNext()}while(n!==this);return e.toString()}link(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}toStringNodeEdge(){return"  -> ("+Wt.format(this.dest())}setNext(t){this._next=t}}class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1;const t=arguments[0];Sn.constructor_.call(this,t)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}}class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static constructor_(){this._vertexMap=new Nt}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return n.link(s),n}createEdge(t){return new Sn(t)}addEdge(t,e){if(!Tn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}}class Rn extends Ln{constructor(){super(),Rn.constructor_.apply(this,arguments)}static constructor_(){this._isStart=!1;const t=arguments[0];Ln.constructor_.call(this,t)}setStart(){this._isStart=!0}isStart(){return this._isStart}}class Pn extends Tn{constructor(){super()}createEdge(t){return new Rn(t)}}class On{constructor(){On.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._factory=null,this._graph=null,this._lines=new L,this._nodeEdgeStack=new en,this._ringStartEdge=null,this._graph=new Pn}static dissolve(t){const e=new On;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new R;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new R;let n=t;for(this._ringStartEdge=null,Ln.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Ln.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Ln.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Ln.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Ln.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof U){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof $&&this.add(t)}})}else if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof $){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}}var vn=Object.freeze({__proto__:null,LineDissolver:On});class bn{static opposite(t){return t===bn.LEFT?bn.RIGHT:t===bn.RIGHT?bn.LEFT:t}}bn.ON=0,bn.LEFT=1,bn.RIGHT=2;let Mn=class{constructor(){Mn.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}};class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=Dn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=Dn.INSERT,this._label=t,this._xValue=e,this._obj=n}}isDelete(){return this._eventType===Dn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===Dn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}get interfaces_(){return[o]}}Dn.INSERT=1,Dn.DELETE=2;class An{}let Fn=class{constructor(){Fn.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Fn.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}};class Gn extends An{constructor(){super(),Gn.constructor_.apply(this,arguments)}static constructor_(){this.events=new L,this.nOverlaps=null}prepareEvents(){xe.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Fn&&I(arguments[0],C)&&I(arguments[1],C)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&I(arguments[0],C)&&arguments[1]instanceof Fn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new Mn(n,t),i=new Dn(e,n.getMinX(t),s);this.events.add(i),this.events.add(new Dn(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class qn{constructor(){qn.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[bn.ON]=t}else if(arguments[0]instanceof qn){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[bn.ON]=t,this.location[bn.LEFT]=e,this.location[bn.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==Qt.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[bn.ON]=this.location[bn.ON],t[bn.LEFT]=Qt.NONE,t[bn.RIGHT]=Qt.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[bn.LEFT];this.location[bn.LEFT]=this.location[bn.RIGHT],this.location[bn.RIGHT]=t}toString(){const t=new v;return this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[bn.LEFT])),t.append(Qt.toLocationSymbol(this.location[bn.ON])),this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[bn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[bn.ON]=t,this.location[bn.LEFT]=e,this.location[bn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:Qt.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===Qt.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(bn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(Qt.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}}class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new qn(t),this.elt[1]=new qn(t)}else if(arguments[0]instanceof Bn){const t=arguments[0];this.elt[0]=new qn(t.elt[0]),this.elt[1]=new qn(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new qn(Qt.NONE),this.elt[1]=new qn(Qt.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new qn(t,e,n),this.elt[1]=new qn(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new qn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[1]=new qn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[t].setLocations(e,n,s)}}static toLineLabel(t){const e=new Bn(Qt.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new qn(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(bn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new v;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(bn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new qn(this.elt[t].location[0]))}}class Yn{constructor(){Yn.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new m(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[o]}}class Vn extends xt{}function zn(t){return null==t?0:t.color}function Xn(t){return null==t?null:t.parent}function kn(t,e){null!==t&&(t.color=e)}function Un(t){return null==t?null:t.left}function Hn(t){return null==t?null:t.right}class Wn extends Vn{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,s,i=this.root_;do{if(n=i,s=t.compareTo(i.key),s<0)i=i.left;else{if(!(s>0)){const t=i.value;return i.value=e,t}i=i.right}}while(null!==i);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)Xn(t)===Un(Xn(Xn(t)))?(e=Hn(Xn(Xn(t))),1===zn(e)?(kn(Xn(t),0),kn(e,0),kn(Xn(Xn(t)),1),t=Xn(Xn(t))):(t===Hn(Xn(t))&&(t=Xn(t),this.rotateLeft(t)),kn(Xn(t),0),kn(Xn(Xn(t)),1),this.rotateRight(Xn(Xn(t))))):(e=Un(Xn(Xn(t))),1===zn(e)?(kn(Xn(t),0),kn(e,0),kn(Xn(Xn(t)),1),t=Xn(Xn(t))):(t===Un(Xn(t))&&(t=Xn(t),this.rotateRight(t)),kn(Xn(t),0),kn(Xn(Xn(t)),1),this.rotateLeft(Xn(Xn(t)))));this.root_.color=0}values(){const t=new L;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=Wn.successor(e));)t.add(e.value);return t}entrySet(){const t=new Et;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=Wn.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new ts(r,new Bn(this.edge._label))}add(t,e,n){const s=new Yn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}}class jn{constructor(){jn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)jn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),Y.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=st.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return Y.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class Kn{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new jn(Math.trunc(t.length/2));n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return n.toArray()}findChainEnd(t,e){const n=Cn.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(Cn.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}OLDgetChainStartIndices(t){let e=0;const n=new L;n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return Kn.toIntArray(n)}}class Qn{constructor(){Qn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return O.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}}class Jn{constructor(){Jn.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map((()=>Array(3)));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Jn.NULL_VALUE}static depthAtLocation(t){return t===Qt.EXTERIOR?0:t===Qt.INTERIOR?1:Jn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Jn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Jn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Jn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][bn.RIGHT]-this._depth[t][bn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?Qt.EXTERIOR:Qt.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==Qt.EXTERIOR&&s!==Qt.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Jn.depthAtLocation(s):this._depth[e][n]+=Jn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===Qt.INTERIOR&&this._depth[t][e]++}}}Jn.NULL_VALUE=-1;let $n=class{constructor(){$n.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){g.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}},ts=class extends $n{constructor(){super(),ts.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new Zn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Jn,this._depthDelta=0,1===arguments.length){const t=arguments[0];ts.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Jt&&arguments[0]instanceof Bn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,bn.ON),t.getLocation(1,bn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,bn.LEFT),t.getLocation(1,bn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,bn.RIGHT),t.getLocation(1,bn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new ts(t,Bn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof ts))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){ts.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Qn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new O;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new m(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new pt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}},es=class extends $n{constructor(){super(),es.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Bn(0,Qt.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=Qt.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==Qt.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Bn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof es){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Bn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===Qt.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=Qt.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case Qt.BOUNDARY:n=Qt.INTERIOR;break;case Qt.INTERIOR:default:n=Qt.BOUNDARY}this._label.setLocation(t,n)}},ns=class{constructor(){ns.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new Wn,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof m){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof es){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new L;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===Qt.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}};class ss{constructor(){ss.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ss.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ss.constructor_.call(this,t),this.init(e,n),this._label=s}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:q.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Cn.quadrant(this._dx,this._dy),g.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}get interfaces_(){return[o]}}class is extends h{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new m(e):void 0,this.name=Object.keys({TopologyException:is})[0]}getCoordinate(){return this.pt}}let rs=class extends ss{constructor(){super(),rs.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(ss.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===Qt.EXTERIOR&&e===Qt.INTERIOR?1:t===Qt.INTERIOR&&e===Qt.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Bn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new is("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,bn.LEFT)===Qt.INTERIOR&&this._label.getLocation(e,bn.RIGHT)===Qt.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[bn.LEFT]+"/"+this._depth[bn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Qt.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Qt.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===bn.LEFT&&(s=-1);const i=bn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}};class os{createNode(t){return new es(t,null)}}let ls=class{constructor(){ls.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new L,this._nodes=null,this._edgeEndList=new L,0===arguments.length)this._nodes=new ns(new os);else if(1===arguments.length){const t=arguments[0];this._nodes=new ns(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof es){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){Y.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===Qt.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(q.index(t,e,s)===q.COLLINEAR&&Cn.quadrant(t,e)===Cn.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){Y.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new rs(t,!0),s=new rs(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}};class as extends ls{constructor(){super(),as.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new Nt,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new fn,2===arguments.length){const t=arguments[0],e=arguments[1];as.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?Qt.BOUNDARY:Qt.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=Qt.NONE;i=n.getLocation(t,bn.ON),i===Qt.BOUNDARY&&s++;const r=as.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new Fn(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const s=this.createEdgeSetIntersector(),i=this._parentGeom instanceof gt||this._parentGeom instanceof rt||this._parentGeom instanceof yt,r=t||!i;return s.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new Fn(e,n,!0);s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof et){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,Qt.INTERIOR)}else if(arguments[0]instanceof m){const t=arguments[0];this.insertPoint(this._argIndex,t,Qt.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),Qt.EXTERIOR,Qt.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,Qt.INTERIOR,Qt.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],Qt.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],Qt.BOUNDARY)}addLineString(t){const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new ts(e,new Bn(this._argIndex,Qt.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),g.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===Qt.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=_t.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;q.isCCW(s)&&(i=n,r=e);const o=new ts(s,new Bn(this._argIndex,Qt.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],Qt.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new Bn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Gn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof U))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof yt&&(this._useBoundaryDeterminationRule=!1),t instanceof rt)this.addPolygon(t);else if(t instanceof $)this.addLineString(t);else if(t instanceof et)this.addPoint(t);else if(t instanceof ut)this.addCollection(t);else if(t instanceof St)this.addCollection(t);else if(t instanceof yt)this.addCollection(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return I(this._parentGeom,it)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ze(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof $){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}}var cs=Object.freeze({__proto__:null,GeometryGraph:as});class hs{visit(t){}}class us{constructor(){us.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e),this._left=null,this._right=null,this._count=1,this._data=n}}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}}class gs{constructor(){gs.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)gs.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return gs.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new R;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new us(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new L;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof O&&I(arguments[1],C)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[hs]}visit(t){e.add(t)}})}else if(arguments[0]instanceof O&&I(arguments[1],hs)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new ds(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new us(t,e);return r?s.setLeft(o):s.setRight(o),o}}class ds{constructor(){ds.constructor_.apply(this,arguments)}static constructor_(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new O(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}get interfaces_(){return[hs]}}gs.BestMatchVisitor=ds;var _s=Object.freeze({__proto__:null,KdTree:gs});class ps{constructor(){ps.constructor_.apply(this,arguments)}static constructor_(){this._items=new L,this._subnode=new Array(4).fill(null)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}get interfaces_(){return[c]}}function ms(){}ms.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},ms.powerOf2=function(t){return Math.pow(2,t)};class fs{constructor(){fs.constructor_.apply(this,arguments)}static constructor_(){this._pt=new m,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return ms.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=fs.computeQuadLevel(t),this._env=new O,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ms.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new m((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}}let ys=class extends ps{constructor(){super(),ys.constructor_.apply(this,arguments)}static constructor_(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2}static createNode(t){const e=new fs(t);return new ys(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new O(e);null!==t&&n.expandToInclude(t._env);const s=ys.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=ps.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=ps.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new O(e,n,s,i);return new ys(r,this._level-1)}insertNode(t){g.isTrue(null===this._env||this._env.contains(t._env));const e=ps.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}};class xs{static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return ms.exponent(s)<=xs.MIN_BINARY_EXPONENT}}xs.MIN_BINARY_EXPONENT=-50;class Es extends ps{constructor(){super()}insert(t,e){const n=ps.getSubnodeIndex(t,Es.origin.x,Es.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=ys.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){g.isTrue(t.getEnvelope().contains(e));const s=xs.isZeroWidth(e.getMinX(),e.getMaxX()),i=xs.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}}Es.origin=new m(0,0);class Is{insert(t,e){}remove(t,e){}query(){}}class Ns{constructor(){Ns.constructor_.apply(this,arguments)}static constructor_(){this._root=null,this._minExtent=1,this._root=new Es}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s+=e/2),i===r&&(i-=e/2,r+=e/2),new O(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=Ns.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new L;return this._root.addAllItems(t),t}remove(t,e){const n=Ns.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}get interfaces_(){return[Is,c]}}var ws=Object.freeze({__proto__:null,Quadtree:Ns});class Cs{getBounds(){}}class Ss{constructor(){Ss.constructor_.apply(this,arguments)}static constructor_(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e}getItem(){return this._item}getBounds(){return this._bounds}get interfaces_(){return[Cs,c]}}class Ls{constructor(){Ls.constructor_.apply(this,arguments)}static constructor_(){this._size=null,this._items=null,this._size=0,this._items=new L,this._items.add(null)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}}class Ts{constructor(){Ts.constructor_.apply(this,arguments)}static constructor_(){if(this._childBoundables=new L,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){g.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}get interfaces_(){return[Cs,c]}}class Rs{static maxDistance(t,e,n,s,i,r,o,l){let a=Rs.distance(t,e,i,r);return a=Math.max(a,Rs.distance(t,e,o,l)),a=Math.max(a,Rs.distance(n,s,i,r)),a=Math.max(a,Rs.distance(n,s,o,l)),a}static distance(t,e,n,s){const i=n-t,r=s-e;return Math.sqrt(i*i+r*r)}static maximumDistance(t,e){const n=Math.min(t.getMinX(),e.getMinX()),s=Math.min(t.getMinY(),e.getMinY()),i=Math.max(t.getMaxX(),e.getMaxX()),r=Math.max(t.getMaxY(),e.getMaxY());return Rs.distance(n,s,i,r)}static minMaxDistance(t,e){const n=t.getMinX(),s=t.getMinY(),i=t.getMaxX(),r=t.getMaxY(),o=e.getMinX(),l=e.getMinY(),a=e.getMaxX(),c=e.getMaxY();let h=Rs.maxDistance(n,s,n,r,o,l,o,c);return h=Math.min(h,Rs.maxDistance(n,s,n,r,o,l,a,l)),h=Math.min(h,Rs.maxDistance(n,s,n,r,a,c,o,c)),h=Math.min(h,Rs.maxDistance(n,s,n,r,a,c,a,l)),h=Math.min(h,Rs.maxDistance(n,s,i,s,o,l,o,c)),h=Math.min(h,Rs.maxDistance(n,s,i,s,o,l,a,l)),h=Math.min(h,Rs.maxDistance(n,s,i,s,a,c,o,c)),h=Math.min(h,Rs.maxDistance(n,s,i,s,a,c,a,l)),h=Math.min(h,Rs.maxDistance(i,r,n,r,o,l,o,c)),h=Math.min(h,Rs.maxDistance(i,r,n,r,o,l,a,l)),h=Math.min(h,Rs.maxDistance(i,r,n,r,a,c,o,c)),h=Math.min(h,Rs.maxDistance(i,r,n,r,a,c,a,l)),h=Math.min(h,Rs.maxDistance(i,r,i,s,o,l,o,c)),h=Math.min(h,Rs.maxDistance(i,r,i,s,o,l,a,l)),h=Math.min(h,Rs.maxDistance(i,r,i,s,a,c,o,c)),h=Math.min(h,Rs.maxDistance(i,r,i,s,a,c,a,l)),h}}class Ps{constructor(){Ps.constructor_.apply(this,arguments)}static constructor_(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof Ts}maximumDistance(){return Rs.maximumDistance(this._boundable1.getBounds(),this._boundable2.getBounds())}expandToQueue(t,e){const n=Ps.isComposite(this._boundable1),i=Ps.isComposite(this._boundable2);if(n&&i)return Ps.area(this._boundable1)>Ps.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,!1,t,e),null):(this.expand(this._boundable2,this._boundable1,!0,t,e),null);if(n)return this.expand(this._boundable1,this._boundable2,!1,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,!0,t,e),null;throw new s("neither boundable is composite")}isLeaves(){return!(Ps.isComposite(this._boundable1)||Ps.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s,i){for(let r=t.getChildBoundables().iterator();r.hasNext();){const t=r.next();let o=null;o=n?new Ps(e,t,this._itemDistance):new Ps(t,e,this._itemDistance),o.getDistance()<i&&s.add(o)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}get interfaces_(){return[o]}}class Os{constructor(){Os.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._built=!1,this._itemBoundables=new L,this._nodeCapacity=null,0===arguments.length)Os.constructor_.call(this,Os.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];g.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(I(arguments[2],De)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ts?this.queryInternal(t,i,e):i instanceof Ss?e.visitItem(i.getItem()):g.shouldNeverReachHere())}}else if(I(arguments[2],C)&&arguments[0]instanceof Object&&arguments[1]instanceof Ts){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ts?this.queryInternal(t,i,e):i instanceof Ss?e.add(i.getItem()):g.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof Ts?t+=this.size(n):n instanceof Ss&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof Ss&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new L:t}if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof Ts){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof Ss?e.add(t.getItem()):g.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){g.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new Ss(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new L;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(g.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof Ts?this.boundablesAtLevel(t,e,n):(g.isTrue(e instanceof Ss),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new L;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof Ts&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){g.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof Ts){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=new L;n.add(this.createNode(e));const s=new L(t);xe.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}get interfaces_(){return[c]}}Os.IntersectsOp=function(){},Os.DEFAULT_NODE_CAPACITY=10;class vs{distance(t,e){}}class bs extends Os{constructor(){super(),bs.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)bs.constructor_.call(this,bs.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];Os.constructor_.call(this,t)}}static centreX(t){return bs.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return bs.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){g.isTrue(t.length>0);const n=new L;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}nearestNeighbourK(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.nearestNeighbourK(t,r.POSITIVE_INFINITY,e)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=arguments[1];const s=new Ls;s.add(t);const i=new Ls;for(;!s.isEmpty()&&n>=0;){const t=s.poll(),r=t.getDistance();if(r>=n)break;if(t.isLeaves())if(i.size()<e)i.add(t);else{i.peek().getDistance()>r&&(i.poll(),i.add(t));n=i.peek().getDistance()}else t.expandToQueue(s,n)}return bs.getItems(i)}}createNode(t){return new Ms(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return bs.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new L;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return bs.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new L(t);xe.sort(s,bs.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(I(arguments[0],vs)){const t=arguments[0];if(this.isEmpty())return null;const e=new Ps(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof Ps){const t=arguments[0];let e=r.POSITIVE_INFINITY,n=null;const s=new Ls;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return null===n?null:[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}}else{if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isEmpty()||t.isEmpty())return null;const n=new Ps(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(3===arguments.length){const t=arguments[2],e=new Ss(arguments[0],arguments[1]),n=new Ps(this.getRoot(),e,t);return this.nearestNeighbour(n)[0]}if(4===arguments.length){const t=arguments[2],e=arguments[3],n=new Ss(arguments[0],arguments[1]),s=new Ps(this.getRoot(),n,t);return this.nearestNeighbourK(s,e)}}}isWithinDistance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=r.POSITIVE_INFINITY;const s=new Ls;for(s.add(t);!s.isEmpty();){const t=s.poll(),i=t.getDistance();if(i>e)return!1;if(t.maximumDistance()<=e)return!0;if(t.isLeaves()){if(n=i,n<=e)return!0}else t.expandToQueue(s,n)}return!1}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Ps(this.getRoot(),t.getRoot(),e);return this.isWithinDistance(s,n)}}get interfaces_(){return[Is,c]}}class Ms extends Ts{constructor(){super(),Ms.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0];Ts.constructor_.call(this,t)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new O(n.getBounds()):t.expandToInclude(n.getBounds())}return t}}bs.STRtreeNode=Ms,bs.xComparator=new class{get interfaces_(){return[a]}compare(t,e){return Os.compareDoubles(bs.centreX(t.getBounds()),bs.centreX(e.getBounds()))}},bs.yComparator=new class{get interfaces_(){return[a]}compare(t,e){return Os.compareDoubles(bs.centreY(t.getBounds()),bs.centreY(e.getBounds()))}},bs.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},bs.DEFAULT_NODE_CAPACITY=10;var Ds=Object.freeze({__proto__:null,STRtree:bs}),As=Object.freeze({__proto__:null,kdtree:_s,quadtree:ws,strtree:Ds});const Fs=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class Gs{constructor(t){this.geometryFactory=t||new Lt}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!qs[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==Fs.indexOf(n)?qs[n].call(this,e.coordinates):"GeometryCollection"===n?qs[n].call(this,e.geometries):qs[n].call(this,e)}write(t){const e=t.getGeometryType();if(!Bs[e])throw new Error("Geometry is not supported");return Bs[e].call(this,t)}}const qs={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!qs[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=qs.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new m(...s))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new m(t[0],t[1]),new m(t[2],t[1]),new m(t[2],t[3]),new m(t[0],t[3]),new m(t[0],t[1])])},Point:function(t){const e=new m(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(qs.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=qs.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(qs.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=qs.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=qs.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(qs.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},Bs={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:Bs.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(Bs.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=Bs.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=Bs.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Bs.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(Bs[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Ys(t){return[t.x,t.y]}var Vs=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new Gs(t||new Lt)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new Gs(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Lt,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new m(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Ys);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Ys);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Ys)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Ys));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Ys))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Ht(t||new Lt)}read(t){return this.parser.read(t)}},WKTWriter:Wt});class zs{static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=zs.relativeSign(e.x,n.x),i=zs.relativeSign(e.y,n.y);switch(t){case 0:return zs.compareValue(s,i);case 1:return zs.compareValue(i,s);case 2:return zs.compareValue(i,-s);case 3:return zs.compareValue(-s,i);case 4:return zs.compareValue(-s,-i);case 5:return zs.compareValue(-i,-s);case 6:return zs.compareValue(-i,s);case 7:return zs.compareValue(s,-i)}return g.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}}class Xs{constructor(){Xs.constructor_.apply(this,arguments)}static constructor_(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new m(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:this._isInterior?e._isInterior?zs.compare(this._segmentOctant,this.coord,e.coord):1:-1}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}toString(){return this.segmentIndex+":"+this.coord.toString()}isInterior(){return this._isInterior}get interfaces_(){return[o]}}class ks{constructor(){ks.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn,this._edge=null;const t=arguments[0];this._edge=t}getSplitCoordinates(){const t=new R;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new L;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}createSplitEdgePts(t,e){let n=e.segmentIndex-t.segmentIndex+2;if(2===n)return[new m(t.coord),new m(e.coord)];const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new m(e.coord)),r}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e);this._edge.getCoordinate(e+1);const s=this._edge.getCoordinate(e+2);n.equals2D(s)&&t.add(b.valueOf(e+1))}}addEdgeCoordinates(t,e,n){const s=this.createSplitEdgePts(t,e);n.add(s,!1)}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(b.valueOf(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){const n=this.createSplitEdgePts(t,e);return new Zs(n,this._edge.getData())}add(t,e){const n=new Xs(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(g.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new h("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new h("bad split edge end point at "+i)}}class Us{static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the octant for point ( "+t+", "+e+" )");const n=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?n>=i?0:1:n>=i?7:6:e>=0?n>=i?3:2:n>=i?4:5}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,i=e.y-t.y;if(0===n&&0===i)throw new s("Cannot compute the octant for two identical points "+t);return Us.octant(n,i)}}}class Hs{getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}}class Ws{addIntersection(t,e){}get interfaces_(){return[Hs]}}class Zs{constructor(){Zs.constructor_.apply(this,arguments)}static constructor_(){this._nodeList=new ks(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new L;return Zs.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){e.next().getNodeList().addSplitEdges(t)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Us.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[1],e=arguments[3],n=new m(arguments[0].getIntersection(e));this.addIntersection(n,t)}}toString(){return Wt.toLineString(new mt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}get interfaces_(){return[Ws]}}class js{constructor(){js.constructor_.apply(this,arguments)}static constructor_(){this._overlapSeg1=new Kt,this._overlapSeg2=new Kt}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];arguments[0].getLineSegment(t,this._overlapSeg1),e.getLineSegment(n,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}}class Ks{constructor(){Ks.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new O(t,e)}return this._env}overlaps(t,e,n,s,i){return O.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}}class Qs{static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=Cn.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(Cn.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Qs.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;let s=0;do{const i=Qs.findChainEnd(t,s),r=new Ks(t,s,i,e);n.add(r),s=i}while(s<t.length-1);return n}}}class Js{computeNodes(t){}getNodedSubstrings(){}}class $s{constructor(){$s.constructor_.apply(this,arguments)}static constructor_(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}}setSegmentIntersector(t){this._segInt=t}get interfaces_(){return[Js]}}class ti extends $s{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){if(this._monoChains=new L,this._index=new bs,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];$s.constructor_.call(this,t)}}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Zs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Qs.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new ei(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}}class ei extends js{constructor(){super(),ei.constructor_.apply(this,arguments)}static constructor_(){this._si=null;const t=arguments[0];this._si=t}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[1],e=arguments[2],n=arguments[3],s=arguments[0].getContext(),i=e.getContext();this._si.processIntersections(s,t,i,n)}}}ti.SegmentOverlapAction=ei;class ni{constructor(){ni.constructor_.apply(this,arguments)}static constructor_(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ni.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}}rescale(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&Y.out.println(t)}}scale(){if(I(arguments[0],N)){const t=arguments[0],e=new L(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Zs(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new m(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].getZ());return _t.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}get interfaces_(){return[Js]}}var si=Object.freeze({__proto__:null,MCIndexNoder:ti,ScaledNoder:ni,SegmentString:Hs});class ii{constructor(){ii.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];ii.constructor_.call(this,t,gn.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}}static getBoundary(){if(1===arguments.length){return new ii(arguments[0]).getBoundary()}if(2===arguments.length){return new ii(arguments[0],arguments[1]).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof $?this.boundaryLineString(this._geom):this._geom instanceof St?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new L;this._endpointMap=new Wn;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return _t.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new ri,this._endpointMap.put(t,e)),e.count++}}let ri=class{constructor(){ri.constructor_.apply(this,arguments)}static constructor_(){this.count=null}};class oi{constructor(){oi.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}}static isSimple(){if(1===arguments.length){return new oi(arguments[0]).isSimple()}if(2===arguments.length){return new oi(arguments[0],arguments[1]).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new at;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new Wn;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.isClosed(),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new as(0,t),n=new jt,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new li(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof $||t instanceof St?this.isSimpleLinearGeometry(t):t instanceof ut?this.isSimpleMultiPoint(t):I(t,it)?this.isSimplePolygonal(t):!(t instanceof ht)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}}class li{constructor(){li.constructor_.apply(this,arguments)}static constructor_(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}}oi.EndpointInfo=li;class ai{constructor(){ai.constructor_.apply(this,arguments)}static constructor_(){if(this._quadrantSegments=ai.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=ai.CAP_ROUND,this._joinStyle=ai.JOIN_ROUND,this._mitreLimit=ai.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=ai.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=ai.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=ai.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==ai.JOIN_ROUND&&(this._quadrantSegments=ai.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}}ai.CAP_ROUND=1,ai.CAP_FLAT=2,ai.CAP_SQUARE=3,ai.JOIN_ROUND=1,ai.JOIN_MITRE=2,ai.JOIN_BEVEL=3,ai.DEFAULT_QUADRANT_SEGMENTS=8,ai.DEFAULT_MITRE_LIMIT=5,ai.DEFAULT_SIMPLIFY_FACTOR=.01;class ci{constructor(){ci.constructor_.apply(this,arguments)}static constructor_(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();g.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=q.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===q.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===q.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=bn.LEFT;return n[e].y<n[e+1].y&&(s=bn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}g.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe;this.getRightmostSide(this._minDe,this._minIndex)===bn.LEFT&&(this._orientedDe=this._minDe.getSym())}}class hi{constructor(){this.array=[]}addLast(t){this.array.push(t)}removeFirst(){return this.array.shift()}isEmpty(){return 0===this.array.length}}class ui{constructor(){ui.constructor_.apply(this,arguments)}static constructor_(){this._finder=null,this._dirEdgeList=new L,this._nodes=new L,this._rightMostCoord=null,this._env=null,this._finder=new ci}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new is("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel(),e.setEdgeDepths(bn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(bn.RIGHT)>=1&&e.getDepth(bn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new Et,n=new hi,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new O;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new en;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(bn.LEFT,t.getDepth(bn.RIGHT)),e.setDepth(bn.RIGHT,t.getDepth(bn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}get interfaces_(){return[o]}}let gi=class{constructor(){gi.constructor_.apply(this,arguments)}static constructor_(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new L,this._pts=new L,this._label=new Bn(Qt.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new L,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=q.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new is("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new is("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();g.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!Ue.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[1],e=arguments[0].getLocation(t,bn.RIGHT);if(e===Qt.NONE)return null;if(this._label.getLocation(t)===Qt.NONE)return this._label.setLocation(t,e),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}};class di extends gi{constructor(){super(),di.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];gi.constructor_.call(this,t,e)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}}class _i extends gi{constructor(){super(),_i.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];gi.constructor_.call(this,t,e)}buildMinimalRings(){const t=new L;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new di(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}}class pi{constructor(){pi.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=null,this._shellList=new L;const t=arguments[0];this._geometryFactory=t}static findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getLinearRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=_t.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;Ue.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getLinearRing().getEnvelopeInternal())}return r}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=pi.findEdgeRingContaining(e,t);if(null===n)throw new is("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}buildMaximalEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new _i(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return g.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ls.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new L,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}}class mi{constructor(){mi.constructor_.apply(this,arguments)}static constructor_(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=q.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t}static simplify(t,e){return new mi(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=mi.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){if(!(q.index(t,e,n)===this._angleOrientation))return!1;return z.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/mi.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return q.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=q.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===mi.DELETE;)e++;return e}isShallow(t,e,n,s){return z.pointToSegment(e,t,n)<s}collapseLine(){const t=new R;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==mi.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}}mi.INIT=0,mi.DELETE=1,mi.KEEP=1,mi.NUM_PTS_TO_CHECK=10;class fi{constructor(){fi.constructor_.apply(this,arguments)}static constructor_(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new L}getCoordinates(){return this._ptList.toArray(fi.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new m(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Lt).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new m(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}}fi.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class yi{constructor(){yi.constructor_.apply(this,arguments)}static constructor_(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new Kt,this._seg1=new Kt,this._offset0=new Kt,this._offset1=new Kt,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new jt,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===ai.JOIN_ROUND&&(this._closingSegLengthFactor=yi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=q.index(this._s0,this._s1,this._s2),s=n===q.CLOCKWISE&&this._side===bn.LEFT||n===q.COUNTERCLOCKWISE&&this._side===bn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new Kt(t,e),s=new Kt;this.computeOffsetSegment(n,bn.LEFT,this._distance,s);const i=new Kt;this.computeOffsetSegment(n,bn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case ai.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,q.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case ai.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case ai.CAP_SQUARE:const t=new m;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new m(s.p1.x+t.x,s.p1.y+t.y),r=new m(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){const i=B.intersection(e.p0,e.p1,n.p0,n.p1);if(null!==i){if((s<=0?1:i.distance(t)/Math.abs(s))<=this._bufParams.getMitreLimit())return this._segList.addPt(i),null}this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*yi.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===ai.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===ai.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new m(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new m(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===q.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=$t.angle(i,this._seg0.p0),o=$t.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2,l=$t.normalize(r+o),a=$t.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),g=i.y+c*Math.sin(a),d=new m(u,g),_=new Kt(i,d),p=_.pointAlongOffset(1,h),f=_.pointAlongOffset(1,-h);this._side===bn.LEFT?(this._segList.addPt(p),this._segList.addPt(f)):(this._segList.addPt(f),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===q.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;const a=o/l,c=new m;for(let n=0;n<l;n++){const s=e+r*n*a;c.x=t.x+i*Math.cos(s),c.y=t.y+i*Math.sin(s),this._segList.addPt(c)}}computeOffsetSegment(t,e,n,s){const i=e===bn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*yi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new m((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new m((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new m(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new fi,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*yi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2);this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===ai.JOIN_BEVEL||this._bufParams.getJoinStyle()===ai.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,q.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}}yi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,yi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,yi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,yi.MAX_CLOSING_SEG_LEN_FACTOR=80;class xi{constructor(){xi.constructor_.apply(this,arguments)}static constructor_(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new m(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&_t.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=mi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],bn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=mi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],bn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===bn.RIGHT&&(s=-s);const i=mi.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=mi.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],bn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=mi.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],bn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case ai.CAP_ROUND:e.createCircle(t);break;case ai.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,this.isLineOffsetEmpty(e))return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return xi.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=mi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],bn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=mi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],bn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}isLineOffsetEmpty(t){return 0===t||t<0&&!this._bufParams.isSingleSided()}getSegGen(t){return new yi(this._precisionModel,this._bufParams,t)}}class Ei{constructor(){Ei.constructor_.apply(this,arguments)}static constructor_(){this._subgraphs=null,this._seg=new Kt;const t=arguments[0];this._subgraphs=t}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(I(arguments[2],C)&&arguments[0]instanceof m&&arguments[1]instanceof rs){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse();if(Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(q.index(this._seg.p0,this._seg.p1,t)===q.RIGHT)continue;let r=e.getDepth(bn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(bn.RIGHT));const o=new Ii(this._seg,r);n.add(o)}}else if(I(arguments[2],C)&&arguments[0]instanceof m&&I(arguments[1],C)){const t=arguments[0],e=arguments[2];for(let n=arguments[1].iterator();n.hasNext();){const s=n.next();s.isForward()&&this.findStabbedSegments(t,s,e)}}}getDepth(t){const e=this.findStabbedSegments(t);if(0===e.size())return 0;return xe.min(e)._leftDepth}}class Ii{constructor(){Ii.constructor_.apply(this,arguments)}static constructor_(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new Kt(t),this._leftDepth=e}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}get interfaces_(){return[o]}}Ei.DepthSegment=Ii;class Ni{constructor(){Ni.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n}addRingSide(t,e,n,s,i){if(0===e&&t.length<gt.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=gt.MINIMUM_VALID_SIZE&&q.isCCW(t)&&(r=i,o=s,n=bn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}addRingBothSides(t,e){this.addRingSide(t,e,bn.LEFT,Qt.EXTERIOR,Qt.INTERIOR),this.addRingSide(t,e,bn.RIGHT,Qt.INTERIOR,Qt.EXTERIOR)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,Qt.EXTERIOR,Qt.INTERIOR)}addPolygon(t){let e=this._distance,n=bn.LEFT;this._distance<0&&(e=-this._distance,n=bn.RIGHT);const s=t.getExteriorRing(),i=_t.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addRingSide(i,e,n,Qt.EXTERIOR,Qt.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=_t.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addRingSide(r,e,bn.opposite(n),Qt.INTERIOR,Qt.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new ne(t[0],t[1],t[2]),s=n.inCentre();return z.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._curveBuilder.isLineOffsetEmpty(this._distance))return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(_t.isRing(e)&&!this._curveBuilder.getBufferParameters().isSingleSided())this.addRingBothSides(e,this._distance);else{const t=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(t,Qt.EXTERIOR,Qt.INTERIOR)}}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Zs(t,new Bn(0,Qt.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}add(t){if(t.isEmpty())return null;if(t instanceof rt)this.addPolygon(t);else if(t instanceof $)this.addLineString(t);else if(t instanceof et)this.addPoint(t);else if(t instanceof ut)this.addCollection(t);else if(t instanceof St)this.addCollection(t);else if(t instanceof yt)this.addCollection(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}}class wi{constructor(){wi.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new Wn,this._edgeList=null,this._ptInAreaLocation=[Qt.NONE,Qt.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=Qt.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,bn.LEFT)!==Qt.NONE&&(e=s.getLocation(t,bn.LEFT))}if(e===Qt.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,bn.ON)===Qt.NONE&&i.setLocation(t,bn.ON,n),i.isArea(t)){const e=i.getLocation(t,bn.LEFT),r=i.getLocation(t,bn.RIGHT);if(r!==Qt.NONE){if(r!==n)throw new is("side location conflict",s.getCoordinate());e===Qt.NONE&&g.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else g.isTrue(i.getLocation(t,bn.LEFT)===Qt.NONE,"found single null side"),i.setLocation(t,bn.RIGHT,n),i.setLocation(t,bn.LEFT,n)}}}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}print(t){Y.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,bn.LEFT);g.isTrue(s!==Qt.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();g.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,bn.LEFT),r=n.getLocation(t,bn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new L(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===Qt.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new v;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===Qt.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=Qt.NONE;if(e[n])r=Qt.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}}let Ci=class extends wi{constructor(){super(),Ci.constructor_.apply(this,arguments)}static constructor_(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new is("no outgoing dirEdge found",this.getCoordinate());g.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return Cn.isNorthern(i)&&Cn.isNorthern(r)?n:Cn.isNorthern(i)||Cn.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(g.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){Y.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new L;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(bn.LEFT),s=t.getDepth(bn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new is("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[1];let e=arguments[2];for(let n=arguments[0];n<t;n++){const t=this._edgeList.get(n);t.setEdgeDepths(bn.RIGHT,e),e=t.getDepth(bn.LEFT)}return e}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(g.isTrue(null!==e,"found null for first outgoing dirEdge"),g.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=Qt.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=Qt.INTERIOR;break}if(s.isInResult()){t=Qt.EXTERIOR;break}}}if(t===Qt.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===Qt.INTERIOR):(n.isInResult()&&(e=Qt.EXTERIOR),s.isInResult()&&(e=Qt.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Bn(Qt.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==Qt.INTERIOR&&n!==Qt.BOUNDARY||this._label.setLocation(t,Qt.INTERIOR)}}}};class Si extends os{constructor(){super()}createNode(t){return new es(t,new Ci)}}class Li{constructor(){Li.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=Li.orientation(t)}static orientation(t){return 1===_t.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return Li.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}get interfaces_(){return[o]}}class Ti{constructor(){Ti.constructor_.apply(this,arguments)}static constructor_(){this._edges=new L,this._ocaMap=new Wn}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new Li(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new Li(t.getCoordinates());this._ocaMap.put(e,t)}}class Ri{processIntersections(t,e,n,s){}isDone(){}}class Pi{constructor(){Pi.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Pi.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}get interfaces_(){return[Ri]}}class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static constructor_(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Ti;const t=arguments[0];this._bufParams=t}static depthDelta(t){const e=t.getLocation(0,bn.LEFT),n=t.getLocation(0,bn.RIGHT);return e===Qt.INTERIOR&&n===Qt.EXTERIOR?1:e===Qt.EXTERIOR&&n===Qt.INTERIOR?-1:0}static convertSegStrings(t){const e=new Lt,n=new L;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Bn(t.getLabel()),s.flip()),n.merge(s);const i=Oi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(Oi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new Ei(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new L;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new ui;n.create(t),e.add(n)}}return xe.sort(e,xe.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new ti,n=new jt;return n.setPrecisionModel(t),e.setSegmentIntersector(new Pi(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new xi(n,this._bufParams),i=new Ni(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new ls(new Si),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new pi(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();if(l.size()<=0)return this.createEmptyResultGeometry();return this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new ts(e.getCoordinates(),new Bn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}}class vi{constructor(){vi.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null;const t=arguments[0];this._segStrings=t}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new h("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new h("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new h("found non-noded collapse at "+vi.fact.createLineString([t,e,n]))}}vi.fact=new Lt;class bi{constructor(){bi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new s("Scale factor must be non-zero");1!==e&&(this._pt=new m(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new m,this._p1Scaled=new m),this.initCorners(this._pt)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return g.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){const e=.5;this._minx=t.x-e,this._maxx=t.x+e,this._miny=t.y-e,this._maxy=t.y+e,this._corner[0]=new m(this._maxx,this._maxy),this._corner[1]=new m(this._minx,this._maxy),this._corner[2]=new m(this._minx,this._miny),this._corner[3]=new m(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=bi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new O(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}}bi.SAFE_ENV_EXPANSION_FACTOR=.75;class Mi{constructor(){Mi.constructor_.apply(this,arguments)}static constructor_(){this.selectedSegment=new Kt}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[1];arguments[0].getLineSegment(t,this.selectedSegment),this.select(this.selectedSegment)}}}class Di{constructor(){Di.constructor_.apply(this,arguments)}static constructor_(){this._index=null;const t=arguments[0];this._index=t}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Ai(t,e,n);return this._index.query(s,new class{get interfaces_(){return[De]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}}class Ai extends Mi{constructor(){super(),Ai.constructor_.apply(this,arguments)}static constructor_(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof Ks))return super.select.apply(this,arguments);{const t=arguments[1],e=arguments[0].getContext();if(this._parentEdge===e&&(t===this._hotPixelVertexIndex||t+1===this._hotPixelVertexIndex))return null;this._isNodeAdded|=this._hotPixel.addSnappedNode(e,t)}}}Di.HotPixelSnapAction=Ai;class Fi{constructor(){Fi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new L}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}get interfaces_(){return[Ri]}}class Gi{constructor(){Gi.constructor_.apply(this,arguments)}static constructor_(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new jt,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()}checkCorrectness(t){const e=Zs.getNodedSubstrings(t),s=new vi(e);try{s.checkValid()}catch(t){if(!(t instanceof n))throw t;t.printStackTrace()}}getNodedSubstrings(){return Zs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Fi(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Zs){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new bi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new ti,this._pointSnapper=new Di(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new bi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}get interfaces_(){return[Js]}}class qi{constructor(){qi.constructor_.apply(this,arguments)}static constructor_(){if(this._argGeom=null,this._distance=null,this._bufParams=new ai,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}}static bufferOp(){if(2===arguments.length){const t=arguments[1];return new qi(arguments[0]).getResultGeometry(t)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof U&&"number"==typeof arguments[1]){const t=arguments[1],e=arguments[2],n=new qi(arguments[0]);n.setQuadrantSegments(e);return n.getResultGeometry(t)}if(arguments[2]instanceof ai&&arguments[0]instanceof U&&"number"==typeof arguments[1]){const t=arguments[1];return new qi(arguments[0],arguments[2]).getResultGeometry(t)}}else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3],s=new qi(arguments[0]);s.setQuadrantSegments(e),s.setEndCapStyle(n);return s.getResultGeometry(t)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=V.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ni(new Gi(new wt(1)),t.getScale()),n=new Oi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=qi.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof is))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=qi.precisionScaleFactor(this._argGeom,this._distance,t),n=new wt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===wt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new Oi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof h))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}}qi.CAP_ROUND=ai.CAP_ROUND,qi.CAP_BUTT=ai.CAP_FLAT,qi.CAP_FLAT=ai.CAP_FLAT,qi.CAP_SQUARE=ai.CAP_SQUARE,qi.MAX_PRECISION_DIGITS=12;var Bi=Object.freeze({__proto__:null,BufferOp:qi,BufferParameters:ai});class Yi{constructor(){Yi.constructor_.apply(this,arguments)}static constructor_(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Yi.constructor_.call(this,t,Yi.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}}getSegmentIndex(){return this._segIndex}getCoordinate(){return this._pt}isInsideArea(){return this._segIndex===Yi.INSIDE_AREA}toString(){return this._component.getGeometryType()+"["+this._segIndex+"]-"+Wt.toPoint(this._pt)}getGeometryComponent(){return this._component}}Yi.INSIDE_AREA=-1;class Vi{constructor(){Vi.constructor_.apply(this,arguments)}static constructor_(){this._locations=null;const t=arguments[0];this._locations=t}static getLocations(t){const e=new L;return t.apply(new Vi(e)),e}filter(t){if(t.isEmpty())return null;(t instanceof et||t instanceof $||t instanceof rt)&&this._locations.add(new Yi(t,0,t.getCoordinate()))}get interfaces_(){return[J]}}class zi{constructor(){zi.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new fn,this._minDistanceLocation=null,this._minDistance=r.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];zi.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}}static distance(t,e){return new zi(t,e).distance()}static isWithinDistance(t,e,n){if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)return!1;return new zi(t,e,n).distance()<=n}static nearestPoints(t,e){return new zi(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ie.getPolygons(n);if(i.size()>0){const n=Vi.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&I(arguments[0],C)&&I(arguments[1],C)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Yi&&arguments[1]instanceof rt){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(Qt.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Yi(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=ye.getLines(this._geom[0]),n=ye.getLines(this._geom[1]),s=Ee.getPoints(this._geom[0]),i=Ee.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){this.computeMinDistance();return[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof $&&arguments[1]instanceof et){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=z.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new Kt(s[r],s[r+1]).closestPoint(i);n[0]=new Yi(t,r,l),n[1]=new Yi(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof $&&arguments[1]instanceof $){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++){const o=new O(s[r],s[r+1]);if(!(o.distance(e.getEnvelopeInternal())>this._minDistance))for(let l=0;l<i.length-1;l++){const a=new O(i[l],i[l+1]);if(o.distance(a)>this._minDistance)continue;const c=z.segmentToSegment(s[r],s[r+1],i[l],i[l+1]);if(c<this._minDistance){this._minDistance=c;const o=new Kt(s[r],s[r+1]),a=new Kt(i[l],i[l+1]),h=o.closestPoints(a);n[0]=new Yi(t,r,h[0]),n[1]=new Yi(e,l,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Yi(i,0,i.getCoordinate()),n[1]=new Yi(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new s("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}}var Xi=Object.freeze({__proto__:null,DistanceOp:zi});class ki{constructor(){ki.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._directedEdges=new L,this._coordinates=null;const t=arguments[0];this._factory=t}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new R;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&_t.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}}class Ui{constructor(){Ui.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1,this._isVisited=!1,this._data=null}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}}class Hi extends Ui{constructor(){super(),Hi.constructor_.apply(this,arguments)}static constructor_(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=Cn.quadrant(i,r),this._angle=Math.atan2(r,i)}}static toEdges(t){const e=new L;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:q.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}get interfaces_(){return[o]}}class Wi extends Hi{constructor(){super(),Wi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hi.constructor_.call(this,t,e,n,s)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(g.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}}class Zi extends Ui{constructor(){super(),Zi.constructor_.apply(this,arguments)}static constructor_(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Ki){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}}class ji{constructor(){ji.constructor_.apply(this,arguments)}static constructor_(){this._outEdges=new L,this._sorted=!1}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(xe.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Zi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof Hi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}}class Ki extends Ui{constructor(){super(),Ki.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];Ki.constructor_.call(this,t,new ji)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}}static getEdgesBetween(t,e){const n=Hi.toEdges(t.getOutEdges().getEdges()),s=new Et(n),i=Hi.toEdges(e.getOutEdges().getEdges());return s.retainAll(i),s}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}}class Qi extends Zi{constructor(){super(),Qi.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Wn}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}}class $i{constructor(){$i.constructor_.apply(this,arguments)}static constructor_(){this._edges=new Et,this._dirEdges=new Et,this._nodeMap=new Ji}findNodesOfDegree(t){const e=new L;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Zi){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof Hi){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Ki){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Zi){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof Hi){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Ki){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Zi){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof Hi){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}}class tr extends $i{constructor(){super()}addEdge(t){if(t.isEmpty())return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Wi(i,r,e[1],!0),l=new Wi(r,i,e[e.length-2],!1),a=new Qi(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new Ki(t),this.add(e)),e}}class er{constructor(){er.constructor_.apply(this,arguments)}static constructor_(){this._graph=new tr,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(g.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Ui.setMarked(this._graph.nodeIterator(),!1),Ui.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new L,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new L;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new ki(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof U){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof $&&this.addLineString(n)}}else if(I(arguments[0],N)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}}class nr{constructor(){nr.constructor_.apply(this,arguments)}static constructor_(){this._parentGraph=null,this._edges=new Et,this._dirEdges=new L,this._nodeMap=new Ji;const t=arguments[0];this._parentGraph=t}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}}class sr{constructor(){sr.constructor_.apply(this,arguments)}static constructor_(){this._graph=null;const t=arguments[0];this._graph=t}addReachable(t,e){const n=new en;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new nr(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new L;Ui.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}}class ir{constructor(){ir.constructor_.apply(this,arguments)}static constructor_(){this._graph=new tr,this._factory=new Lt,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=b.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof St))return!0;const e=t,n=new at;let s=null;const i=new L;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new m(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new ir;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();g.isTrue(this._lineCount===e,"Lines were missing from result"),g.isTrue(this._sequencedGeometry instanceof $||this._sequencedGeometry instanceof St,"Result is not lineal")}findSequences(){const t=new L;for(let e=new sr(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=ir.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&g.isTrue(i===s,"path not contiguous")}findSequence(t){Ui.setVisited(t.edgeIterator(),!1);const e=ir.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new hi,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=ir.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new hi;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new L;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=ir.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof U){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof $&&this.addLine(t)}})}}}var rr=Object.freeze({__proto__:null,LineMerger:er,LineSequencer:ir});class or{constructor(){or.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new Kt,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof $&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];or.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=or.isClosed(t),this._snapTolerance=e}}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new m(i)),0===s&&this._isClosed&&t.set(t.size()-1,new m(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new R(this._srcPts);this.snapVertices(e,t),this.snapSegments(e,t);return e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new m(n),!1)}}findSegmentIndexToSnap(t,e){let n=r.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}}class lr{constructor(){lr.constructor_.apply(this,arguments)}static constructor_(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t}static snap(t,e,n){const s=new Array(2).fill(null),i=new lr(t);s[0]=i.snapTo(e,n);const r=new lr(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=lr.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===wt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(lr.computeOverlaySnapTolerance(t),lr.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*lr.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new lr(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new ar(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new ar(t,n,!0).transform(this._srcGeom);let i=s;return e&&I(i,it)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new at,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=r.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}}lr.SNAP_PRECISION_FACTOR=1e-9;class ar extends me{constructor(){super(),ar.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}}snapLine(t,e){const n=new or(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}}var cr=Object.freeze({__proto__:null,GeometrySnapper:lr,LineStringSnapper:or});class hr{constructor(){hr.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Us.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Wt.toLineString(new mt(this._pts))}get interfaces_(){return[Hs]}}class ur{constructor(){ur.constructor_.apply(this,arguments)}static constructor_(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._keepIntersections=!0,this._isInteriorIntersectionsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new L,this._intersectionCount=0;const t=arguments[0];this._li=t,this._interiorIntersection=null}static createAllIntersectionsFinder(t){const e=new ur(t);return e.setFindAllIntersections(!0),e}static isInteriorVertexIntersection(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3];return(!arguments[2]||!n)&&!!t.equals2D(e)}if(8===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6],l=arguments[7];return!!ur.isInteriorVertexIntersection(t,n,i,o)||(!!ur.isInteriorVertexIntersection(t,s,i,l)||(!!ur.isInteriorVertexIntersection(e,n,r,o)||!!ur.isInteriorVertexIntersection(e,s,r,l)))}}static createInteriorIntersectionCounter(t){const e=new ur(t);return e.setInteriorIntersectionsOnly(!0),e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static createIntersectionCounter(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static isEndSegment(t,e){return 0===e||e>=t.size()-2}static createAnyIntersectionFinder(t){return new ur(t)}static createInteriorIntersectionsFinder(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.setInteriorIntersectionsOnly(!0),e}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}getIntersection(){return this._interiorIntersection}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;const i=t===n;if(i&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(ur.isEndSegment(t,e)||ur.isEndSegment(n,s)))return null}const r=t.getCoordinate(e),o=t.getCoordinate(e+1),l=n.getCoordinate(s),a=n.getCoordinate(s+1),c=0===e,h=e+2===t.size(),u=0===s,g=s+2===n.size();this._li.computeIntersection(r,o,l,a);const d=this._li.hasIntersection()&&this._li.isInteriorIntersection();let _=!1;if(!this._isInteriorIntersectionsOnly){_=!(i&&Math.abs(s-e)<=1)&&ur.isInteriorVertexIntersection(r,o,l,a,c,h,u,g)}(d||_)&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=r,this._intSegments[1]=o,this._intSegments[2]=l,this._intSegments[3]=a,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}setInteriorIntersectionsOnly(t){this._isInteriorIntersectionsOnly=t}get interfaces_(){return[Ri]}}class gr{constructor(){gr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t}static computeIntersections(t){const e=new gr(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new ur(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new ti;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new is(this.getErrorMessage(),this._segInt.getIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Wt.toLineString(t[0],t[1])+" and "+Wt.toLineString(t[2],t[3])}}class dr{constructor(){dr.constructor_.apply(this,arguments)}static constructor_(){this._nv=null;const t=arguments[0];this._nv=new gr(dr.toSegmentStrings(t))}static toSegmentStrings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new hr(t.getCoordinates(),t))}return e}static checkValid(t){new dr(t).checkValid()}checkValid(){this._nv.checkValid()}}class _r{constructor(){_r.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new L,this._resultLineList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!wr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=this._geometryFactory.createLineString(e.getCoordinates());this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(g.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(wr.isResultOfOp(s,e)&&e===wr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}}class pr{constructor(){pr.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._resultPointList=new L;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===wr.INTERSECTION))){const e=n.getLabel();wr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}}class mr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new i,this._commonSignExp=null}getCommon(){return r.longBitsToDouble(this._commonBits)}add(t){const e=r.doubleToLongBits(t);if(this._isFirst)return this._commonBits=e,this._commonSignExp=mr.signExpBits(this._commonBits),this._isFirst=!1,null;if(mr.signExpBits(e)!==this._commonSignExp)return this._commonBits.high=0,this._commonBits.low=0,null;this._commonMantissaBitsCount=mr.numCommonMostSigMantissaBits(this._commonBits,e),this._commonBits=mr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))}toString(){if(1===arguments.length){const t=arguments[0],e=r.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+i.toBinaryString(t),s=n.substring(n.length-64);return s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]"}}getClass(){return mr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(mr.getBit(t,s)!==mr.getBit(e,s))return n;n++}return 52}}class fr{constructor(){fr.constructor_.apply(this,arguments)}static constructor_(){this._commonCoord=null,this._ccFilter=new yr}addCommonBits(t){const e=new xr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new m(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new xr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}}class yr{constructor(){yr.constructor_.apply(this,arguments)}static constructor_(){this._commonBitsX=new mr,this._commonBitsY=new mr}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new m(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}get interfaces_(){return[H]}}class xr{constructor(){xr.constructor_.apply(this,arguments)}static constructor_(){this.trans=null;const t=arguments[0];this.trans=t}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}get interfaces_(){return[P]}}fr.CommonCoordinateFilter=yr,fr.Translater=xr;class Er{constructor(){Er.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()}static overlayOp(t,e,n){return new Er(t,e).getResultGeometry(n)}static union(t,e){return Er.overlayOp(t,e,wr.UNION)}static intersection(t,e){return Er.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){return Er.overlayOp(t,e,wr.SYMDIFFERENCE)}static difference(t,e){return Er.overlayOp(t,e,wr.DIFFERENCE)}selfSnap(t){return new lr(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new fr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=wr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||Y.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=lr.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return lr.snap(e[0],e[1],this._snapTolerance)}}class Ir{constructor(){Ir.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e}static overlayOp(t,e,n){return new Ir(t,e).getResultGeometry(n)}static union(t,e){return Ir.overlayOp(t,e,wr.UNION)}static intersection(t,e){return Ir.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){return Ir.overlayOp(t,e,wr.SYMDIFFERENCE)}static difference(t,e){return Ir.overlayOp(t,e,wr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=wr.overlayOp(this._geom[0],this._geom[1],t); true&&(n=!0)}catch(t){if(!(t instanceof h))throw t;s=t}if(!n)try{e=Er.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof h?s:t}return e}}class Nr{constructor(){Nr.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new jt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new as(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new as(0,t,n),this._arg[1]=new as(1,e,n)}}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}}class wr extends Nr{constructor(){super(),wr.constructor_.apply(this,arguments)}static constructor_(){this._ptLocator=new fn,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new Ti,this._resultPolyList=new L,this._resultLineList=new L,this._resultPointList=new L;const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e),this._graph=new ls(new Si),this._geomFact=t.getFactory()}static overlayOp(t,e,n){return new wr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return wr.createEmptyResult(wr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ce.map(t,new class{get interfaces_(){return[MapOp]}map(t){return wr.intersection(t,n)}})}return Ir.overlayOp(t,e,wr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case wr.INTERSECTION:r=Math.min(s,i);break;case wr.UNION:r=Math.max(s,i);break;case wr.DIFFERENCE:r=s;break;case wr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){const i=wr.resultDimension(t,e,n);return s.createEmpty(i)}static difference(t,e){if(t.isEmpty())return wr.createEmptyResult(wr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Ir.overlayOp(t,e,wr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return wr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1],n=arguments[2];switch(t===Qt.BOUNDARY&&(t=Qt.INTERIOR),e===Qt.BOUNDARY&&(e=Qt.INTERIOR),n){case wr.INTERSECTION:return t===Qt.INTERIOR&&e===Qt.INTERIOR;case wr.UNION:return t===Qt.INTERIOR||e===Qt.INTERIOR;case wr.DIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR;case wr.SYMDIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR||t!==Qt.INTERIOR&&e===Qt.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Bn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new L;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?wr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==Qt.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new L;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new L;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),dr.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new pi(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new _r(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new pr(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&wr.isResultOfOp(s.getLocation(0,bn.RIGHT),s.getLocation(1,bn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(g.isTrue(!s.isNull(t,bn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,bn.LEFT,s.getLocation(t,bn.LEFT)),g.isTrue(!s.isNull(t,bn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,bn.RIGHT,s.getLocation(t,bn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}}wr.INTERSECTION=1,wr.UNION=2,wr.DIFFERENCE=3,wr.SYMDIFFERENCE=4;var Cr=Object.freeze({__proto__:null,snap:cr,OverlayOp:wr});class Sr extends Hi{constructor(){super(),Sr.constructor_.apply(this,arguments)}static constructor_(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hi.constructor_.call(this,t,e,n,s)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}}class Lr extends Zi{constructor(){super(),Lr.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Tr{constructor(){Tr.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=new Lt,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){if(t.isEmpty())return null;const n=t.getCoordinates(),s=n[0],i=Tr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR&&(l=o.getSym()),g.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof rt){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof yt){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{g.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new _i(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,bn.RIGHT)===Qt.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new L;this._geomGraph.computeSplitEdges(t);const e=new ls(new Si);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}}class Rr{createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new ss(t,n.coord,r,new Bn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new Bn(t.getLabel());o.flip();const l=new ss(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}}class Pr extends ss{constructor(){super(),Pr.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new L,1===arguments.length){const t=arguments[0];Pr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];ss.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Bn(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===Qt.BOUNDARY&&n++,i===Qt.INTERIOR&&(s=!0)}let i=Qt.NONE;s&&(i=Qt.INTERIOR),n>0&&(i=as.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===Qt.INTERIOR)return this._label.setLocation(t,e,Qt.INTERIOR),null;n===Qt.EXTERIOR&&this._label.setLocation(t,e,Qt.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,bn.LEFT),this.computeLabelSide(t,bn.RIGHT)}updateIM(t){ts.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Bn(Qt.NONE,Qt.NONE,Qt.NONE):new Bn(Qt.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class Or extends wi{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Pr(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class vr extends es{constructor(){super(),vr.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];es.constructor_.call(this,t,e)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}}class br extends os{constructor(){super()}createNode(t){return new vr(t,new Or)}}class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static constructor_(){this._nodes=new ns(new br)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new Rr).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===Qt.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,Qt.INTERIOR)}}}}class Dr{constructor(){Dr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._geomGraph=null,this._nodeGraph=new Mr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}}class Ar{constructor(){Ar.constructor_.apply(this,arguments)}static constructor_(){this._graph=null,this._rings=new L,this._totalEnv=new O,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t}buildIndex(){this._index=new bs;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Gr.findPtNotNode(n,i,this._graph);if(null===o)continue;if(Ue.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}}class Fr{constructor(){Fr.constructor_.apply(this,arguments)}static constructor_(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Fr.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}}getErrorType(){return this._errorType}getMessage(){return Fr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}}Fr.ERROR=0,Fr.REPEATED_POINT=1,Fr.HOLE_OUTSIDE_SHELL=2,Fr.NESTED_HOLES=3,Fr.DISCONNECTED_INTERIOR=4,Fr.SELF_INTERSECTION=5,Fr.RING_SELF_INTERSECTION=6,Fr.NESTED_SHELLS=7,Fr.DUPLICATE_RINGS=8,Fr.TOO_FEW_POINTS=9,Fr.INVALID_COORDINATE=10,Fr.RING_NOT_CLOSED=11,Fr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Gr{constructor(){Gr.constructor_.apply(this,arguments)}static constructor_(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof U){return new Gr(arguments[0]).isValid()}if(arguments[0]instanceof m){const t=arguments[0];return!r.isNaN(t.x)&&(!r.isInfinite(t.x)&&(!r.isNaN(t.y)&&!r.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Gr.isValid(t[e]))return this._validErr=new Fr(Fr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof rt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){if(t.getNumInteriorRing()<=0)return null;const n=new Ar(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);s.isEmpty()||n.add(s)}n.isNonNested()||(this._validErr=new Fr(Fr.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new Dr(t);if(!e.isNodeConsistentArea())return this._validErr=new Fr(Fr.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Fr(Fr.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Gr.findPtNotNode(s,e,n);if(null!==r){if(!Ue.isInRing(r,i))return r}const o=Gr.findPtNotNode(i,t,n);if(null!==o){return Ue.isInRing(o,s)?o:null}return g.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new Tr(t);e.isInteriorsConnected()||(this._validErr=new Fr(Fr.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new at;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Fr(Fr.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){if(t.getNumInteriorRing()<=0)return null;const n=t.getExteriorRing(),s=n.isEmpty(),i=new ze(n);for(let r=0;r<t.getNumInteriorRing();r++){const o=t.getInteriorRingN(r);let l=null;if(o.isEmpty())continue;if(l=Gr.findPtNotNode(o.getCoordinates(),n,e),null===l)return null;if(s||Qt.EXTERIOR===i.locate(l))return this._validErr=new Fr(Fr.HOLE_OUTSIDE_SHELL,l),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Fr(Fr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof et){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof ut){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof gt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new jt;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof $){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new as(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof rt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof yt){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new as(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof ht){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof U){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof et)this.checkValid(t);else if(t instanceof ut)this.checkValid(t);else if(t instanceof gt)this.checkValid(t);else if(t instanceof $)this.checkValid(t);else if(t instanceof rt)this.checkValid(t);else if(t instanceof yt)this.checkValid(t);else{if(!(t instanceof ht))throw new K(t.getGeometryType());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing();if(i.isEmpty())return null;const r=i.getCoordinates(),o=Gr.findPtNotNode(s,i,n);if(null===o)return null;if(!Ue.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Fr(Fr.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Fr(Fr.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(t.isEmpty())return null;if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Fr(Fr.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}}class qr{constructor(){qr.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._deList=new L,this._lowestEdge=null,this._ring=null,this._locator=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t}static findDirEdgesInRing(t){let e=t;const n=new L;do{n.add(e),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing().getEnvelopeInternal();if(l.equals(s))continue;if(!l.contains(s))continue;i=_t.ptNotInList(n.getCoordinates(),e.getCoordinates());e.isInRing(i)&&(null===r||o.contains(l))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new R;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();qr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Gr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isInRing(t){return Qt.EXTERIOR!==this.getLocator().locate(t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof gt){const t=arguments[0];null===this._holes&&(this._holes=new L),this._holes.add(t)}else if(arguments[0]instanceof qr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new L),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=q.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Wt.toLineString(new mt(this.getCoordinates()))}getLocator(){return null===this._locator&&(this._locator=new ze(this.getRing())),this._locator}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&Y.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof n))throw t;Y.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}}qr.EnvelopeComparator=class{compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}get interfaces_(){return[a]}};class Br extends $i{constructor(){super(),Br.constructor_.apply(this,arguments)}static constructor_(){this._factory=null;const t=arguments[0];this._factory=t}static findLabeledEdgeRings(t){const e=new L;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=qr.findDirEdgesInRing(t);Br.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(g.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();Br.getDegree(i,e)>1&&(null===s&&(s=new L),s.add(i)),n=n.getNext(),g.isTrue(null!==n,"found null DE in ring"),g.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new qr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();Br.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=_t.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Sr(i,r,e[1],!0),l=new Sr(r,i,e[e.length-2],!1),a=new Lr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),Br.findLabeledEdgeRings(this._dirEdges);const t=new L;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Br.label(this._dirEdges,-1);const t=Br.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new L;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new Ki(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=Br.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();Br.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new Et,n=new en;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();Br.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===Br.getDegreeNonDeleted(o)&&n.push(o)}}return e}}class Yr{constructor(){Yr.constructor_.apply(this,arguments)}static constructor_(){this._shells=null,this._shellIndex=null;const t=arguments[0];this._shells=t,this.buildIndex()}static assignHolesToShells(t,e){new Yr(e).assignHolesToShells(t)}assignHolesToShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.assignHoleToShell(t)}}buildIndex(){this._shellIndex=new bs;for(const t of this._shells)this._shellIndex.insert(t.getRing().getEnvelopeInternal(),t)}queryOverlappingShells(t){return this._shellIndex.query(t)}findShellContaining(t){const e=t.getRing().getEnvelopeInternal(),n=this.queryOverlappingShells(e);return qr.findEdgeRingContaining(t,n)}assignHoleToShell(t){const e=this.findShellContaining(t);null!==e&&e.addHole(t)}}class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static constructor_(){if(this._lineStringAdder=new zr(this),this._graph=null,this._dangles=new L,this._cutEdges=new L,this._invalidRingLines=new L,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Vr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}}static extractPolygons(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static findDisjointShells(t){Vr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Lt),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Lt.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new L,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new L;this._invalidRingLines=new L,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Yr.assignHolesToShells(this._holeList,this._shellList),xe.sort(this._shellList,new qr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Vr.findDisjointShells(this._shellList),n=!1),this._polyList=Vr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof $){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Br(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof U){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new L,this._shellList=new L;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}}class zr{constructor(){zr.constructor_.apply(this,arguments)}static constructor_(){this.p=null;const t=arguments[0];this.p=t}filter(t){t instanceof $&&this.p.add(t)}get interfaces_(){return[k]}}Vr.LineStringAdder=zr;var Xr=Object.freeze({__proto__:null,Polygonizer:Vr});class kr{constructor(){kr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._ptLocator=new fn,this._arg=null,this._nodes=new ns(new br),this._im=null,this._isolatedEdges=new L,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,Qt.EXTERIOR)}computeIM(){const t=new Jt;if(t.set(Qt.EXTERIOR,Qt.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new Rr,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===Qt.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,Qt.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===Qt.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,Qt.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();g.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(Qt.INTERIOR,Qt.EXTERIOR,e.getDimension()),t.set(Qt.BOUNDARY,Qt.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(Qt.EXTERIOR,Qt.INTERIOR,n.getDimension()),t.set(Qt.EXTERIOR,Qt.BOUNDARY,n.getBoundaryDimension()))}}class Ur{constructor(){Ur.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new Ur(t).contains(e)}isContainedInBoundary(t){if(t instanceof rt)return!1;if(t instanceof et)return this.isPointContainedInBoundary(t);if(t instanceof $)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new m,s=new m;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof et){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof m){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new m(t.getMinX(),t.getMinY()),this._diagUp1=new m(t.getMaxX(),t.getMaxY()),this._diagDown0=new m(t.getMinX(),t.getMaxY()),this._diagDown1=new m(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new O(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Wr{constructor(){Wr.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Wr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Zr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new jr(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new Kr(this._rectangle);return s.applyTo(t),!!s.intersects()}}class Zr extends Ne{constructor(){super(),Zr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}}class jr extends Ne{constructor(){super(),jr.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof rt))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new m;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}}class Kr extends Ne{constructor(){super(),Kr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new m,this._p1=new m;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Hr(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=ye.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class Qr extends Nr{constructor(){super(),Qr.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Nr.constructor_.call(this,t,e),this._relate=new kr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Nr.constructor_.call(this,t,e,n),this._relate=new kr(this._arg)}}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Qr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Wr.intersects(t,e);if(e.isRectangle())return Wr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Qr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Qr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){return new Qr(arguments[0],arguments[1]).getIntersectionMatrix()}if(3===arguments.length){return new Qr(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Qr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Ur.contains(t,e):new Qr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}}var Jr=Object.freeze({__proto__:null,RelateOp:Qr});class $r{constructor(){$r.constructor_.apply(this,arguments)}static constructor_(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()}static union(t,e){return new $r(t,e).union()}union(){const t=new fn,e=new at;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===Qt.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=_t.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),he.combine(n,this._otherGeom)}}class to{constructor(){to.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._polygons=new L,this._lines=new L,this._points=new L,this._dimension=Q.FALSE}static extract(){if(I(arguments[0],N)){const t=arguments[0],e=new to;return e.add(t),e}if(arguments[0]instanceof U){const t=arguments[0],e=new to;return e.add(t),e}}getFactory(){return this._geomFactory}recordDimension(t){t>this._dimension&&(this._dimension=t)}getDimension(){return this._dimension}filter(t){return this.recordDimension(t.getDimension()),t instanceof ht||t.isEmpty()?null:t instanceof rt?(this._polygons.add(t),null):t instanceof $?(this._lines.add(t),null):t instanceof et?(this._points.add(t),null):void g.shouldNeverReachHere("Unhandled geometry type: "+t.getGeometryType())}getExtract(t){switch(t){case 0:return this._points;case 1:return this._lines;case 2:return this._polygons}return g.shouldNeverReachHere("Invalid dimension: "+t),null}isEmpty(){return this._polygons.isEmpty()&&this._lines.isEmpty()&&this._points.isEmpty()}add(){if(I(arguments[0],N)){const t=arguments[0];for(const e of t)this.add(e)}else if(arguments[0]instanceof U){const t=arguments[0];null===this._geomFactory&&(this._geomFactory=t.getFactory()),t.apply(this)}}get interfaces_(){return[J]}}class eo{static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return wr.createEmptyResult(wr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return U.checkNotGeometryCollection(t),U.checkNotGeometryCollection(e),Ir.overlayOp(t,e,wr.UNION)}}class no{constructor(){no.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._g0=null,this._g1=null,this._isUnionSafe=null;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e,this._geomFactory=t.getFactory()}static containsProperly(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!t.isNull()&&(e.getX()>t.getMinX()&&e.getX()<t.getMaxX()&&e.getY()>t.getMinY()&&e.getY()<t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return no.containsProperly(t,e)&&no.containsProperly(t,n)}}static union(t,e){return new no(t,e).union()}static intersects(t,e,n){return t.intersects(e)||t.intersects(n)}static overlapEnvelope(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();return n.intersection(s)}static extractBorderSegments(t,e,n){t.apply(new class{get interfaces_(){return[P]}filter(t,s){if(s<=0)return null;const i=t.getCoordinate(s-1),r=t.getCoordinate(s);if(no.intersects(e,i,r)&&!no.containsProperly(e,i,r)){const t=new Kt(i,r);n.add(t)}}isDone(){return!1}isGeometryChanged(){return!1}})}static unionBuffer(t,e){return t.getFactory().createGeometryCollection([t,e]).buffer(0)}isBorderSegmentsSame(t,e){const n=this.extractBorderSegments(this._g0,this._g1,e),s=new L;return no.extractBorderSegments(t,e,s),this.isEqual(n,s)}extractByEnvelope(t,e,n){const s=new L;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);if(r.getEnvelopeInternal().intersects(t))s.add(r);else{const t=r.copy();n.add(t)}}return this._geomFactory.buildGeometry(s)}isEqual(t,e){if(t.size()!==e.size())return!1;const n=new Et(t);for(const t of e)if(!n.contains(t))return!1;return!0}union(){const t=no.overlapEnvelope(this._g0,this._g1);if(t.isNull()){const t=this._g0.copy(),e=this._g1.copy();return he.combine(t,e)}const e=new L,n=this.extractByEnvelope(t,this._g0,e),s=this.extractByEnvelope(t,this._g1,e),i=this.unionFull(n,s);let r=null;return this._isUnionSafe=this.isBorderSegmentsSame(i,t),r=this._isUnionSafe?this.combine(i,e):this.unionFull(this._g0,this._g1),r}combine(t,e){if(e.size()<=0)return t;e.add(t);return he.combine(e)}unionFull(t,e){try{return eo.union(t,e)}catch(n){if(n instanceof is)return no.unionBuffer(t,e);throw n}}extractBorderSegments(t,e,n){const s=new L;return no.extractBorderSegments(t,n,s),null!==e&&no.extractBorderSegments(e,n,s),s}isUnionOptimized(){return this._isUnionSafe}}class so{constructor(){so.constructor_.apply(this,arguments)}static constructor_(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new L)}static restrictToPolygons(t){if(I(t,it))return t;const e=Ie.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Lt.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new so(t).union()}reduceToGeometries(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;I(t,C)?s=this.unionTree(t):t instanceof U&&(s=t),e.add(s)}return e}union(){if(null===this._inputPolys)throw new D("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new bs(so.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=so.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(so.getGeometry(t,e),so.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionActual(t,e)}unionActual(t,e){const n=no.union(t,e);return so.restrictToPolygons(n)}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}}so.STRTREE_NODE_CAPACITY=4;class io{constructor(){io.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._extracter=null,1===arguments.length){if(I(arguments[0],N)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof U){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}}static union(){if(1===arguments.length){if(I(arguments[0],N)){return new io(arguments[0]).union()}if(arguments[0]instanceof U){return new io(arguments[0]).union()}}else if(2===arguments.length){return new io(arguments[0],arguments[1]).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return Ir.overlayOp(t,e,wr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:wr.union(t,e)}extract(){if(I(arguments[0],N)){const t=arguments[0];this._extracter=to.extract(t)}else if(arguments[0]instanceof U){const t=arguments[0];this._extracter=to.extract(t)}}union(){if(null===this._geomFact&&(this._geomFact=this._extracter.getFactory()),null===this._geomFact)return null;if(this._extracter.isEmpty())return this._geomFact.createEmpty(this._extracter.getDimension());const t=this._extracter.getExtract(0),e=this._extracter.getExtract(1),n=this._extracter.getExtract(2);let s=null;if(t.size()>0){const e=this._geomFact.buildGeometry(t);s=this.unionNoOpt(e)}let i=null;if(e.size()>0){const t=this._geomFact.buildGeometry(e);i=this.unionNoOpt(t)}let r=null;n.size()>0&&(r=so.union(n));const o=this.unionWithNull(i,r);let l=null;return l=null===s?o:null===o?s:$r.union(s,o),null===l?this._geomFact.createGeometryCollection():l}}var ro=Object.freeze({__proto__:null,UnaryUnionOp:io}),oo=Object.freeze({__proto__:null,IsValidOp:Gr,ConsistentAreaTester:Dr}),lo=Object.freeze({__proto__:null,BoundaryOp:ii,IsSimpleOp:oi,buffer:Bi,distance:Xi,linemerge:rr,overlay:Cr,polygonize:Xr,relate:Jr,union:ro,valid:oo});class ao{constructor(){ao.constructor_.apply(this,arguments)}static constructor_(){if(this._returnToOriginalPrecision=!0,this._cbr=null,0===arguments.length)ao.constructor_.call(this,!0);else if(1===arguments.length){const t=arguments[0];this._returnToOriginalPrecision=t}}computeResultPrecision(t){return this._returnToOriginalPrecision&&this._cbr.addCommonBits(t),t}union(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].union(n[1]))}intersection(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].intersection(n[1]))}removeCommonBits(){if(1===arguments.length){const t=arguments[0];this._cbr=new fr,this._cbr.add(t);return this._cbr.removeCommonBits(t.copy())}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._cbr=new fr,this._cbr.add(t),this._cbr.add(e);const n=new Array(2).fill(null);return n[0]=this._cbr.removeCommonBits(t.copy()),n[1]=this._cbr.removeCommonBits(e.copy()),n}}buffer(t,e){const n=this.removeCommonBits(t);return this.computeResultPrecision(n.buffer(e))}symDifference(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].symDifference(n[1]))}difference(t,e){const n=this.removeCommonBits(t,e);return this.computeResultPrecision(n[0].difference(n[1]))}}class co extends ue.CoordinateOperation{constructor(){super(),co.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e}edit(){if(2===arguments.length&&arguments[1]instanceof U&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new m(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new R(n,!1).toCoordinateArray();let i=0;e instanceof $&&(i=2),e instanceof gt&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}}class ho{constructor(){ho.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t}static reduce(t,e){return new ho(e).reduce(t)}static reducePointwise(t,e){const n=new ho(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));return qi.bufferOp(e,0)}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new ue(n)}else e=new ue;let n=this._removeCollapsed;t.getDimension()>=2&&(n=!0);return e.edit(t,new co(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new ue.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Lt(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:I(e,it)?Gr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new ue;const n=this.createFactory(t,e);return new ue(n)}}class uo{constructor(){uo.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._pts=null,this._start=null,this._end=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._pts=t,this._start=e,this._end=e+1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pts=t,this._start=e,this._end=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._geom=t,this._pts=e,this._start=n,this._end=s}}computeDistanceLineLine(t,e){let n=r.MAX_VALUE;for(let s=this._start;s<this._end-1;s++){const i=this._pts.getCoordinate(s),r=this._pts.getCoordinate(s+1);for(let o=t._start;o<t._end-1;o++){const l=t._pts.getCoordinate(o),a=t._pts.getCoordinate(o+1),c=z.segmentToSegment(i,r,l,a);if(c<n&&(n=c,null!==e&&this.updateNearestLocationsLineLine(s,i,r,t,o,l,a,e),n<=0))return n}}return n}updateNearestLocationsPointLine(t,e,n,s,i,r){r[0]=new Yi(this._geom,this._start,new m(t));const o=new Kt(s,i).closestPoint(t);r[1]=new Yi(e._geom,n,new m(o))}size(){return this._end-this._start}getCoordinate(t){return this._pts.getCoordinate(this._start+t)}nearestLocations(t){const e=this.isPoint(),n=t.isPoint(),s=new Array(2).fill(null);if(e&&n){const e=this._pts.getCoordinate(this._start),n=t._pts.getCoordinate(t._start);s[0]=new Yi(this._geom,this._start,new m(e)),s[1]=new Yi(t._geom,t._start,new m(n))}else if(e){const e=this._pts.getCoordinate(this._start);this.computeDistancePointLine(e,t,s)}else if(n){const e=t._pts.getCoordinate(t._start);this.computeDistancePointLine(e,this,s);const n=s[0];s[0]=s[1],s[1]=n}else this.computeDistanceLineLine(t,s);return s}getEnvelope(){const t=new O;for(let e=this._start;e<this._end;e++)t.expandToInclude(this._pts.getX(e),this._pts.getY(e));return t}updateNearestLocationsLineLine(t,e,n,s,i,r,o,l){const a=new Kt(e,n),c=new Kt(r,o),h=a.closestPoints(c);l[0]=new Yi(this._geom,t,new m(h[0])),l[1]=new Yi(s._geom,i,new m(h[1]))}toString(){const t=new v;t.append("LINESTRING ( ");const e=new m;for(let n=this._start;n<this._end;n++)n>this._start&&t.append(", "),this._pts.getCoordinate(n,e),t.append(e.x+" "+e.y);return t.append(" )"),t.toString()}computeDistancePointLine(t,e,n){let s=r.MAX_VALUE;for(let i=e._start;i<e._end-1;i++){const r=e._pts.getCoordinate(i),o=e._pts.getCoordinate(i+1),l=z.pointToSegment(t,r,o);if(l<s&&(s=l,null!==n&&this.updateNearestLocationsPointLine(t,e,i,r,o,n),s<=0))return s}return s}isPoint(){return this._end-this._start==1}distance(t){const e=this.isPoint(),n=t.isPoint();let s=null;if(e&&n){const e=this._pts.getCoordinate(this._start),n=t._pts.getCoordinate(t._start);s=e.distance(n)}else if(e){const e=this._pts.getCoordinate(this._start);s=this.computeDistancePointLine(e,t,null)}else if(n){const e=t._pts.getCoordinate(t._start);s=this.computeDistancePointLine(e,this,null)}else s=this.computeDistanceLineLine(t,null);return s}}class go{static addFacetSequences(t,e,n){let s=0;const i=e.size();for(;s<=i-1;){let r=s+go.FACET_SEQUENCE_SIZE+1;r>=i-1&&(r=i);const o=new uo(t,e,s,r);n.add(o),s+=go.FACET_SEQUENCE_SIZE}}static computeFacetSequences(t){const e=new L;return t.apply(new class{get interfaces_(){return[k]}filter(t){let n=null;(t instanceof $||t instanceof et)&&(n=t.getCoordinateSequence(),go.addFacetSequences(t,n,e))}}),e}static build(t){const e=new bs(go.STR_TREE_NODE_CAPACITY);for(let n=go.computeFacetSequences(t).iterator();n.hasNext();){const t=n.next();e.insert(t.getEnvelope(),t)}return e.build(),e}}go.FACET_SEQUENCE_SIZE=6,go.STR_TREE_NODE_CAPACITY=4;class _o{constructor(){_o.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._minClearance=null,this._minClearancePts=null;const t=arguments[0];this._inputGeom=t}static getLine(t){return new _o(t).getLine()}static getDistance(t){return new _o(t).getDistance()}getLine(){return this.compute(),null===this._minClearancePts||null===this._minClearancePts[0]?this._inputGeom.getFactory().createLineString():this._inputGeom.getFactory().createLineString(this._minClearancePts)}compute(){if(null!==this._minClearancePts)return null;if(this._minClearancePts=new Array(2).fill(null),this._minClearance=r.MAX_VALUE,this._inputGeom.isEmpty())return null;const t=go.build(this._inputGeom).nearestNeighbour(new po),e=new po;this._minClearance=e.distance(t[0],t[1]),this._minClearancePts=e.getCoordinates()}getDistance(){return this.compute(),this._minClearance}}class po{constructor(){po.constructor_.apply(this,arguments)}static constructor_(){this._minDist=r.MAX_VALUE,this._minPts=new Array(2).fill(null)}vertexDistance(t,e){for(let n=0;n<t.size();n++)for(let s=0;s<e.size();s++){const i=t.getCoordinate(n),r=e.getCoordinate(s);if(!i.equals2D(r)){const t=i.distance(r);if(t<this._minDist&&(this._minDist=t,this._minPts[0]=i,this._minPts[1]=r,0===t))return t}}return this._minDist}getCoordinates(){return this._minPts}segmentDistance(t,e){for(let n=0;n<t.size();n++)for(let s=1;s<e.size();s++){const i=t.getCoordinate(n),r=e.getCoordinate(s-1),o=e.getCoordinate(s);if(!i.equals2D(r)&&!i.equals2D(o)){const t=z.pointToSegment(i,r,o);if(t<this._minDist&&(this._minDist=t,this.updatePts(i,r,o),0===t))return t}}return this._minDist}distance(){if(arguments[0]instanceof Ss&&arguments[1]instanceof Ss){const t=arguments[1],e=arguments[0].getItem(),n=t.getItem();return this._minDist=r.MAX_VALUE,this.distance(e,n)}if(arguments[0]instanceof uo&&arguments[1]instanceof uo){const t=arguments[0],e=arguments[1];return this.vertexDistance(t,e),1===t.size()&&1===e.size()?this._minDist:this._minDist<=0?this._minDist:(this.segmentDistance(t,e),this._minDist<=0||this.segmentDistance(e,t),this._minDist)}}updatePts(t,e,n){this._minPts[0]=t;const s=new Kt(e,n);this._minPts[1]=new m(s.closestPoint(t))}get interfaces_(){return[vs]}}_o.MinClearanceDistance=po;class mo{constructor(){mo.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._minClearance=null,this._minClearancePts=null;const t=arguments[0];this._inputGeom=t}static getLine(t){return new mo(t).getLine()}static getDistance(t){return new mo(t).getDistance()}getLine(){return this.compute(),this._inputGeom.getFactory().createLineString(this._minClearancePts)}updateClearance(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t<this._minClearance&&(this._minClearance=t,this._minClearancePts[0]=new m(e),this._minClearancePts[1]=new m(n))}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t<this._minClearance){this._minClearance=t,this._minClearancePts[0]=new m(e);const i=new Kt(n,s);this._minClearancePts[1]=new m(i.closestPoint(e))}}}compute(){if(null!==this._minClearancePts)return null;this._minClearancePts=new Array(2).fill(null),this._minClearance=r.MAX_VALUE,this._inputGeom.apply(new fo(this))}getDistance(){return this.compute(),this._minClearance}}class fo{constructor(){fo.constructor_.apply(this,arguments)}static constructor_(){this.smc=null;const t=arguments[0];this.smc=t}filter(t){this.smc._inputGeom.apply(new yo(this.smc,t))}get interfaces_(){return[H]}}class yo{constructor(){yo.constructor_.apply(this,arguments)}static constructor_(){this.smc=null,this._queryPt=null;const t=arguments[0],e=arguments[1];this.smc=t,this._queryPt=e}isGeometryChanged(){return!1}checkVertexDistance(t){const e=t.distance(this._queryPt);e>0&&this.smc.updateClearance(e,this._queryPt,t)}filter(t,e){this.checkVertexDistance(t.getCoordinate(e)),e>0&&this.checkSegmentDistance(t.getCoordinate(e-1),t.getCoordinate(e))}checkSegmentDistance(t,e){if(this._queryPt.equals2D(t)||this._queryPt.equals2D(e))return null;const n=z.pointToSegment(this._queryPt,e,t);n>0&&this.smc.updateClearance(n,this._queryPt,e,t)}isDone(){return!1}get interfaces_(){return[P]}}mo.VertexCoordinateFilter=fo,mo.ComputeMCCoordinateSequenceFilter=yo;var xo=Object.freeze({__proto__:null,CommonBits:mr,CommonBitsOp:ao,CommonBitsRemover:fr,EnhancedPrecisionOp:class{static union(t,e){let n=null;try{return t.union(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).union(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static intersection(t,e){let n=null;try{return t.intersection(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).intersection(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static buffer(t,e){let n=null;try{return t.buffer(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).buffer(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static symDifference(t,e){let n=null;try{return t.symDifference(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).symDifference(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}static difference(t,e){let n=null;try{return t.difference(e)}catch(t){if(!(t instanceof h))throw t;n=t}try{const s=new ao(!0).difference(t,e);if(!s.isValid())throw n;return s}catch(t){throw t instanceof h?n:t}}},GeometryPrecisionReducer:ho,MinimumClearance:_o,SimpleMinimumClearance:mo});class Eo{constructor(){Eo.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new Kt;const t=arguments[0];this._pts=t}static simplify(t,e){const n=new Eo(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new R;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new m(this._pts[e]));return t.toCoordinateArray()}}class Io{constructor(){Io.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Io(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new No(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class No extends me{constructor(){super(),No.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):Eo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof rt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof gt?s:null}}Io.DPTransformer=No;class wo extends Kt{constructor(){super(),wo.constructor_.apply(this,arguments)}static constructor_(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];wo.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,t,e),this._parent=n,this._index=s}}getIndex(){return this._index}getParent(){return this._parent}}class Co{constructor(){Co.constructor_.apply(this,arguments)}static constructor_(){if(this._parentLine=null,this._segs=null,this._resultSegs=new L,this._minimumSize=null,1===arguments.length){const t=arguments[0];Co.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(Co.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(Co.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new wo(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return Co.extractCoordinates(this._resultSegs)}}class So{constructor(){So.constructor_.apply(this,arguments)}static constructor_(){this._index=new Ns}remove(t){this._index.remove(new O(t.p0,t.p1),t)}add(){if(arguments[0]instanceof Co){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof Kt){const t=arguments[0];this._index.insert(new O(t.p0,t.p1),t)}}query(t){const e=new O(t.p0,t.p1),n=new Lo(t);this._index.query(e,n);return n.getItems()}}class Lo{constructor(){Lo.constructor_.apply(this,arguments)}static constructor_(){this._querySeg=null,this._items=new L;const t=arguments[0];this._querySeg=t}visitItem(t){const e=t;O.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class To{constructor(){To.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._inputIndex=new So,this._outputIndex=new So,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new Kt(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new Kt;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new Kt;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(To.isInLineSection(t,e,i))continue;return!0}}return!1}}class Ro{constructor(){Ro.constructor_.apply(this,arguments)}static constructor_(){this._inputIndex=new So,this._outputIndex=new So,this._distanceTolerance=0}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new To(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}}class Po{constructor(){Po.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._lineSimplifier=new Ro,this._linestringMap=null;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Po(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();this._linestringMap=new Nt,this._inputGeom.apply(new vo(this)),this._lineSimplifier.simplify(this._linestringMap.values());return new Oo(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}}class Oo extends me{constructor(){super(),Oo.constructor_.apply(this,arguments)}static constructor_(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof $){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}}class vo{constructor(){vo.constructor_.apply(this,arguments)}static constructor_(){this.tps=null;const t=arguments[0];this.tps=t}filter(t){if(t instanceof $){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new Co(e,n);this.tps._linestringMap.put(e,s)}}get interfaces_(){return[k]}}Po.LineStringTransformer=Oo,Po.LineStringMapBuilderFilter=vo;class bo{constructor(){bo.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e}static simplify(t,e){return new bo(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=Mo.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new m(n[0])]:n}}class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static constructor_(){this._pt=null,this._prev=null,this._next=null,this._area=Mo.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new Mo(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new R;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=Mo.MAX_AREA,null;this._area=Math.abs(ne.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}}Mo.MAX_AREA=r.MAX_VALUE,bo.VWVertex=Mo;class Do{constructor(){Do.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new Do(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Ao(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class Ao extends me{constructor(){super(),Ao.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof yt?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):bo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof rt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof gt?s:null}}Do.VWTransformer=Ao;var Fo=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Io,TopologyPreservingSimplifier:Po,VWSimplifier:Do});class Go{constructor(){Go.constructor_.apply(this,arguments)}static constructor_(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()}static pointAlongReverse(t,e){const n=new m;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=Go.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=Go.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}}class qo{findSplitPoint(t,e){}}class Bo{static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new Go(n),r=Bo.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}get interfaces_(){return[qo]}}class Yo{static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=A.valueOf(t.x).selfSubtract(s.x),r=A.valueOf(t.y).selfSubtract(s.y),o=A.valueOf(e.x).selfSubtract(s.x),l=A.valueOf(e.y).selfSubtract(s.y),a=A.valueOf(n.x).selfSubtract(s.x),c=A.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),p=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(p.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=Yo.isInCircleNonRobust(t,e,n,s),r=Yo.isInCircleDDSlow(t,e,n,s),o=Yo.isInCircleCC(t,e,n,s),l=ne.circumcentre(t,e,n);Y.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(Y.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),Y.out.println(Wt.toLineString(new mt([t,e,n,s]))),Y.out.println("Circumcentre = "+Wt.toPoint(l)+" radius = "+t.distance(l)),Y.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),Y.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),Y.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),Y.out.println())}static isInCircleDDFast(t,e,n,s){const i=A.sqr(t.x).selfAdd(A.sqr(t.y)).selfMultiply(Yo.triAreaDDFast(e,n,s)),r=A.sqr(e.x).selfAdd(A.sqr(e.y)).selfMultiply(Yo.triAreaDDFast(t,n,s)),o=A.sqr(n.x).selfAdd(A.sqr(n.y)).selfMultiply(Yo.triAreaDDFast(t,e,s)),l=A.sqr(s.x).selfAdd(A.sqr(s.y)).selfMultiply(Yo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=ne.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=A.valueOf(s.x),r=A.valueOf(s.y),o=A.valueOf(t.x),l=A.valueOf(t.y),a=A.valueOf(e.x),c=A.valueOf(e.y),h=A.valueOf(n.x),u=A.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(Yo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(Yo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(Yo.triAreaDDSlow(o,l,a,c,i,r)),p=i.multiply(i).add(r.multiply(r)).multiply(Yo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(p).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*Yo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*Yo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*Yo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*Yo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return Yo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=A.valueOf(e.x).selfSubtract(t.x).selfMultiply(A.valueOf(n.y).selfSubtract(t.y)),i=A.valueOf(e.y).selfSubtract(t.y).selfMultiply(A.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}}class Vo{constructor(){Vo.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new m(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e,n)}}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.getZ()-e.getZ();return e.getZ()+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}}circleCenter(t,e){const n=new Vo(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new ee(s,i);let o=null;try{o=new Vo(r.getX(),r.getY())}catch(s){if(!(s instanceof te))throw s;Y.err.println("a: "+n+"  b: "+t+"  c: "+e),Y.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.getZ()}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new ee(t.getX()+n/2,t.getY()+s/2,1),r=new ee(t.getX()-s+n/2,t.getY()+n+s/2,1);return new ee(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return Yo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.getZ()+t.getZ())/2;return new Vo(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.setZ(t)}times(t){return new Vo(t*this._p.x,t*this._p.y)}cross(){return new Vo(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new Vo(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=this,s=e.sub(t),i=n.sub(t),r=s.crossProduct(i);return r>0?Vo.LEFT:r<0?Vo.RIGHT:s.getX()*i.getX()<0||s.getY()*i.getY()<0?Vo.BEHIND:s.magn()<i.magn()?Vo.BEYOND:t.equals(n)?Vo.ORIGIN:e.equals(n)?Vo.DESTINATION:Vo.BETWEEN}sum(t){return new Vo(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}}Vo.LEFT=0,Vo.RIGHT=1,Vo.BEYOND=2,Vo.BEHIND=3,Vo.BETWEEN=4,Vo.ORIGIN=5,Vo.DESTINATION=6;class zo extends Vo{constructor(){super(),zo.constructor_.apply(this,arguments)}static constructor_(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];Vo.constructor_.call(this,t)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}}class Xo{constructor(){Xo.constructor_.apply(this,arguments)}static constructor_(){this._rot=null,this._vertex=null,this._next=null,this._data=null}static makeEdge(t,e){const n=new Xo,s=new Xo,i=new Xo,r=new Xo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();Xo.splice(t,e),Xo.splice(t.sym(),n),Xo.splice(t,e.lNext()),Xo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=Xo.makeEdge(t.dest(),e.orig());return Xo.splice(n,t.lNext()),Xo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new Kt(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Wt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}}class ko{constructor(){ko.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);Xo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))Xo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}}class Uo{locate(t){}}class Ho{constructor(){Ho.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}get interfaces_(){return[Uo]}}class Wo extends h{constructor(){super(),Wo.constructor_.apply(this,arguments)}static constructor_(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];h.constructor_.call(this,t)}else if(arguments[0]instanceof Kt){const t=arguments[0];h.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new Kt(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,Wo.msgWithSpatial(t,e)),this._seg=new Kt(e)}}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}}class Zo{visit(t){}}class jo{constructor(){jo.constructor_.apply(this,arguments)}static constructor_(){this._visitedKey=0,this._quadEdges=new L,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new Kt,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/jo.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Ho(this)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new s("Edges do not form a triangle")}getTriangleVertices(t){const e=new Jo;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=Xo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new L,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new R;i.addAll(n,!1),i.closeRing(),i.size()<4&&(Y.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);Xo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return Xo.splice(e.sym(),n),Xo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);jo.getTriangleEdges(t,e);const n=new Array(3).fill(null);jo.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=Xo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new en;n.push(this._startingEdge);const s=new Et;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());return this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new O(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new Vo((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new Vo(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new Vo(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new O(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new $o;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new Et;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new L,n=new Et;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Qo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new L,n=new en;n.push(this._startingEdge);const s=new Et;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){Xo.splice(t,t.oPrev()),Xo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new Wo(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new Ko,!0);const e=new L;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Lt.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);Xo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof Vo){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._locator.locate(new Vo(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new Vo(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}}class Ko{visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=ne.circumcentreDD(e,n,s),r=new Vo(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}get interfaces_(){return[Zo]}}class Qo{constructor(){Qo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}get interfaces_(){return[Zo]}}class Jo{constructor(){Jo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}get interfaces_(){return[Zo]}}class $o{constructor(){$o.constructor_.apply(this,arguments)}static constructor_(){this._coordList=new R,this._triCoords=new L}checkTriangleSize(t){t.length>=2?Wt.toLineString(t[0],t[1]):t.length>=1&&Wt.toPoint(t[0])}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}get interfaces_(){return[Zo]}}jo.TriangleCircumcentreVisitor=Ko,jo.TriangleEdgesListVisitor=Qo,jo.TriangleVertexListVisitor=Jo,jo.TriangleCoordinatesVisitor=$o,jo.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class tl{constructor(){tl.constructor_.apply(this,arguments)}static constructor_(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new Kt(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new Kt(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];tl.constructor_.call(this,new m(t,e,n),new m(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];tl.constructor_.call(this,new m(t,e,n),new m(s,i,r),o)}}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).getZ()}getStartZ(){return this._ls.getCoordinate(0).getZ()}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}}class el extends h{constructor(){super(),el.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,el.msgWithCoord(t,e)),this._pt=new m(e)}}static msgWithCoord(t,e){return null!==e?t+" [ "+Wt.toPoint(e)+" ]":t}getCoordinate(){return this._pt}}class nl{constructor(){nl.constructor_.apply(this,arguments)}static constructor_(){this._initialVertices=null,this._segVertices=null,this._segments=new L,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new Bo,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new L(t),this._tolerance=e,this._kdt=new gs(e)}static computeVertexEnvelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<nl.MAX_SPLIT_ITER);if(t===nl.MAX_SPLIT_ITER)throw new el("Too many splitting iterations while enforcing constraints.  Last split point was at: ",this._splitPt)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Lt,e=this.getPointArray(),n=new sn(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new m((e.x+n.x)/2,(e.y+n.y)/2),i=e.distance(s),o=new O(s);o.expandBy(i);const l=this._kdt.query(o);let a=null,c=r.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const r=t.next().getCoordinate();if(r.equals2D(e)||r.equals2D(n))continue;const o=s.distance(r);if(o<i){const t=o;(null===a||t<c)&&(a=r,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new L;let n=0;const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new tl(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new tl(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new zo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new zo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=nl.computeVertexEnvelope(this._initialVertices),e=nl.computeVertexEnvelope(this._segVertices),n=new O(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new O(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new jo(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Ho(this._subdiv)),this._incDel=new ko(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof zo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof m){const t=arguments[0];this.insertSite(this.createVertex(t))}}}nl.MAX_SPLIT_ITER=99;class sl{constructor(){sl.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null}static extractUniqueCoordinates(t){if(null===t)return new R;const e=t.getCoordinates();return sl.unique(e)}static envelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=_t.copyDeep(t);st.sort(e);return new R(e,!1)}static toVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Vo(t))}return e}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords),e=sl.toVertices(this._siteCoords);this._subdiv=new jo(t,this._tolerance);new ko(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof U){const t=arguments[0];this._siteCoords=sl.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=sl.unique(_t.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}}class il{constructor(){il.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new Wn}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=ye.getLines(t),n=new L;for(let t=e.iterator();t.hasNext();){const e=t.next();il.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[1],e=arguments[0].getCoordinates();for(let n=1;n<e.length;n++)t.add(new tl(e[n-1],e[n]))}}createSiteVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new zo(t))}return e}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords);let e=new L;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=il.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new nl(n,this._tolerance);s.setConstraints(e,new L(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=sl.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new zo(e[t]);this._constraintVertexMap.put(e[t],n)}}}class rl{constructor(){rl.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new L;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=wr.intersection(n,r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Lt.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=sl.envelope(this._siteCoords);if(this._diagramEnv=this._clipEnv,null===this._diagramEnv){this._diagramEnv=t;const e=this._diagramEnv.getDiameter();this._diagramEnv.expandBy(e)}const e=sl.toVertices(this._siteCoords);this._subdiv=new jo(t,this._tolerance);new ko(this._subdiv).insertSites(e)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return rl.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof U){const t=arguments[0];this._siteCoords=sl.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=sl.unique(_t.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}}var ll=Object.freeze({__proto__:null,Vertex:Vo}),al=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:il,DelaunayTriangulationBuilder:sl,VoronoiDiagramBuilder:rl,quadedge:ll});class cl{constructor(){cl.constructor_.apply(this,arguments)}static constructor_(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];cl.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];cl.constructor_.call(this,t,e.getComponentIndex(),cl.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!I(t,Z))throw new s("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=n,this.loadCurrentLine()}}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}}class hl{constructor(){hl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new hl(t).indexOf(e)}static indexOfAfter(t,e,n){return new hl(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=e,i=0;const o=new Kt,l=new cl(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const r=o.distance(t),a=this.segmentNearestMeasure(o,t,i);r<n&&a>e&&(s=a,n=r),i+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}}class ul{constructor(){ul.constructor_.apply(this,arguments)}static constructor_(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ul.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}}static getEndLocation(t){const e=new ul;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.getZ()-t.getZ())*n+t.getZ();return new m(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}static numSegments(t){const e=t.getNumPoints();return e<=1?0:e-1}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex),n=ul.numSegments(e);return this._segmentIndex>=n||this._segmentIndex===n-1&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex),n=ul.numSegments(e);return this._segmentIndex<n?this:new ul(this._componentIndex,n-1,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=ul.numSegments(e))return n;const s=e.getCoordinateN(this._segmentIndex+1);return ul.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=ul.numSegments(e)){const t=e.getCoordinateN(e.getNumPoints()-2);return new Kt(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new Kt(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=ul.numSegments(e),this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=ul.numSegments(e),this._segmentFraction=0}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new ul(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=ul.numSegments(e)&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}get interfaces_(){return[o]}}class gl{constructor(){gl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new gl(t).indexOf(e)}static indexOfAfter(t,e,n){return new gl(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=0,i=0,o=-1;const l=new Kt;for(let r=new cl(this._linearGeom);r.hasNext();r.next())if(!r.isEndOfLine()){l.p0=r.getSegmentStart(),l.p1=r.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=r.getComponentIndex(),u=r.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,i=u,o=c,n=a)}if(n===r.MAX_VALUE)return new ul(e);return new ul(s,i,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=ul.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}}class dl{constructor(){dl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indicesOf(t,e){return new dl(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new gl(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}}class _l{constructor(){_l.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static getLength(t,e){return new _l(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[1];return new _l(arguments[0]).getLocation(t)}if(3===arguments.length){const t=arguments[1],e=arguments[2];return new _l(arguments[0]).getLocation(t,e)}}getLength(t){let e=0;const n=new cl(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new ul(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new ul;let e=0;const n=new cl(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new ul(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new ul(r,o,s)}e+=i}n.next()}return ul.getEndLocation(this._linearGeom)}}class pl{constructor(){pl.constructor_.apply(this,arguments)}static constructor_(){this._geomFact=null,this._lines=new L,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let n=null;try{n=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof s))throw t;if(!this._ignoreInvalidLines)throw t}null!==n&&this._lines.add(n)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new R),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}}class ml{constructor(){ml.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}static extract(t,e,n){return new ml(t).extract(e,n)}computeLinear(t,e){const n=new pl(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new cl(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new R;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return I(t,Z)?t.reverse():(g.shouldNeverReachHere("non-linear geometry encountered"),null)}}class fl{constructor(){fl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return _l.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return _l.getLocation(this._linearGeom,t,e)}}project(t){return hl.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return _l.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=_l.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return hl.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return ml.extract(this._linearGeom,r,o)}indexOf(t){return hl.indexOf(this._linearGeom,t)}indicesOf(t){const e=dl.indicesOf(this._linearGeom,t);return[_l.getLength(this._linearGeom,e[0]),_l.getLength(this._linearGeom,e[1])]}}class yl{constructor(){yl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return gl.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof $||this._linearGeom instanceof St))throw new s("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[1],e=arguments[0].toLowest(this._linearGeom);return e.getSegment(this._linearGeom).pointAlongOffset(e.getSegmentFraction(),t)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return ul.getEndLocation(this._linearGeom)}getStartIndex(){return new ul}indexOfAfter(t,e){return gl.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return ml.extract(this._linearGeom,t,e)}indexOf(t){return gl.indexOf(this._linearGeom,t)}indicesOf(t){return dl.indicesOf(this._linearGeom,t)}}var xl=Object.freeze({__proto__:null,LengthIndexedLine:fl,LengthLocationMap:_l,LinearGeometryBuilder:pl,LinearIterator:cl,LinearLocation:ul,LocationIndexedLine:yl});class El{static transform(t,e){const n=new L;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}}El.Function=function(){};class Il{constructor(){Il.constructor_.apply(this,arguments)}static constructor_(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}get interfaces_(){return[H]}}class Nl{constructor(){Nl.constructor_.apply(this,arguments)}static constructor_(){this._n=0}filter(t){this._n++}getCount(){return this._n}get interfaces_(){return[H]}}class wl{constructor(){wl.constructor_.apply(this,arguments)}static constructor_(){this._counts=new Nt}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new Cl(1)):e.increment()}}class Cl{constructor(){Cl.constructor_.apply(this,arguments)}static constructor_(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}}count(){return this.count}increment(){this.count++}}function Sl(){}function Ll(){}function Tl(){}wl.Counter=Cl;class Rl extends n{}function Pl(){}class Ol{static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new Tl,n=new Sl;return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";new Ll(Ol.getStackTrace(t));const s=new Pl;for(let t=0;t<e;t++)try{n+=s.readLine()+Ol.NEWLINE}catch(t){if(!(t instanceof Rl))throw t;g.shouldNeverReachHere()}return n}}static spaces(t){return Ol.chars(" ",t)}static split(t,e){const n=e.length,s=new L;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}}Ol.NEWLINE=Y.getProperty("line.separator");var vl=Object.freeze({__proto__:null,CollectionUtil:El,CoordinateArrayFilter:Il,CoordinateCountFilter:Nl,GeometricShapeFactory:we,NumberUtil:e,ObjectCounter:wl,PriorityQueue:Ls,StringUtil:Ol,UniqueCoordinateArrayFilter:nn});$.prototype.getBoundary=function(){return ii.getBoundary(this)},St.prototype.getBoundary=function(){return ii.getBoundary(this)},U.prototype.equalsTopo=function(t){return Qr.equalsTopo(this,t)},U.prototype.equals=function(t){return null!==t&&Qr.equalsTopo(this,t)},U.prototype.union=function(){if(0===arguments.length)return io.union(this);if(1===arguments.length){const t=arguments[0];return eo.union(this,t)}},U.prototype.isValid=function(){return Gr.isValid(this)},U.prototype.intersection=function(t){return wr.intersection(this,t)},U.prototype.covers=function(t){return Qr.covers(this,t)},U.prototype.coveredBy=function(t){return Qr.covers(t,this)},U.prototype.touches=function(t){return Qr.touches(this,t)},U.prototype.intersects=function(t){return Qr.intersects(this,t)},U.prototype.within=function(t){return Qr.contains(t,this)},U.prototype.overlaps=function(t){return Qr.overlaps(this,t)},U.prototype.disjoint=function(t){return Qr.disjoint(this,t)},U.prototype.crosses=function(t){return Qr.crosses(this,t)},U.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return qi.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return qi.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return qi.bufferOp(this,t,e,n)}},U.prototype.convexHull=function(){return new sn(this).getConvexHull()},U.prototype.relate=function(){if(1===arguments.length){const t=arguments[0];return Qr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Qr.relate(this,t).matches(e)}},U.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=$e.getCentroid(this);return this.createPointFromInternalCoord(t,this)},U.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new un(this):1===e?new hn(this):new on(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},U.prototype.symDifference=function(t){return wr.symDifference(this,t)},U.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},U.prototype.toText=function(){return(new Wt).write(this)},U.prototype.toString=function(){return this.toText()},U.prototype.contains=function(t){return Qr.contains(this,t)},U.prototype.difference=function(t){return wr.difference(this,t)},U.prototype.isSimple=function(){return new oi(this).isSimple()},U.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&zi.isWithinDistance(this,t,e)},U.prototype.distance=function(t){return zi.distance(this,t)};t.algorithm=En,t.densify=wn,t.dissolve=vn,t.geom=Te,t.geomgraph=cs,t.index=As,t.io=Vs,t.linearref=xl,t.noding=si,t.operation=lo,t.precision=xo,t.simplify=Fo,t.triangulate=al,t.util=vl,t.version="2.9.3"}));
//# sourceMappingURL=jsts.min.js.map


/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./src/base/AgentPoint.js":
/*!********************************!*\
  !*** ./src/base/AgentPoint.js ***!
  \********************************/
/*! exports provided: AgentPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgentPoint", function() { return AgentPoint; });
//@ts-check

/** */
class AgentPoint {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(x, y, sx=0, sy=0) {

        //position

        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y

        //speed

        /** @type {number} */
        this.sx = sx
        /** @type {number} */
        this.sy = sy
        /** @type {number} */
        this.s = undefined
        /** @type {number} */
        this.sa = undefined
    }


    /**
     * @param {AgentPoint} a
     * @returns {number} The distance to another agent.
     */
    d(a) {
        return this.dP(a.x, a.y);
    }

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @returns {number} The distance to a position.
     */
    dP(x, y) {
        return Math.hypot((x - this.x), (y - this.y));
    }

    /** 
    * Set random speed
    * 
    * @param {number} minSpeed
    * @param {number} maxSpeed
    */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        this.s = minSpeed + Math.random() * (maxSpeed - minSpeed);
        this.sa = 2 * Math.random() * Math.PI;
        this.sx = this.s * Math.cos(this.sa)
        this.sy = this.s * Math.sin(this.sa)
    }

    /** */
    computeSpeed() {
        this.s = Math.hypot(this.sx, this.sy);
        return this.s
    }

    /** */
    computeSpeedAngle() {
        this.sa = Math.atan2(this.sy, this.sx);
        return this.sa
    }

}


/***/ }),

/***/ "./src/base/GeoCanvas.js":
/*!*******************************!*\
  !*** ./src/base/GeoCanvas.js ***!
  \*******************************/
/*! exports provided: GeoCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoCanvas", function() { return GeoCanvas; });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
//@ts-check
/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */




/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 * 
 * @author Julien Gaffuri
 */
class GeoCanvas {

    /**
     * @constructor
     * @param {string} canvasId
     * @param {object} center Geographical coordinates of the center
     * @param {number} zf The zoom factor (pixel size, in ground m)
     */
    constructor(canvasId = "vacanvas", center = undefined, zf = 1) {

        /** @type {object} */
        this.canvas = document.getElementById(canvasId);

        /** @type {number} */
        this.w = this.canvas.offsetWidth;
        /** @type {number} */
        this.h = this.canvas.offsetHeight;

        this.canvas.width = this.w;
        this.canvas.height = this.h;

        /**@type {object} */
        this.ctx = this.canvas.getContext("2d");

        // set geo coordinates of the center
        this.setCenter(center || { x: this.w * 0.5, y: this.h * 0.5 })

        // set zoom factor: pixel size, in m/pix
        this.setZf(zf);

        //extent
        /** @type {Envelope} */
        this.extGeo = undefined;
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoomIdentity"]
        Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(this.canvas).call(
            Object(d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoom"])().on("zoom", (e) => {
                const t = e.transform
                const f = tP.k / t.k
                if (f == 1) {
                    //pan
                    const dx = tP.x - t.x
                    const dy = tP.y - t.y
                    this.pan(dx * this.getZf(), -dy * this.getZf())
                } else {
                    const se = e.sourceEvent;
                    if (se instanceof WheelEvent) {
                        //zoom at the mouse position
                        this.zoom(f, this.pixToGeoX(e.sourceEvent.offsetX), this.pixToGeoY(e.sourceEvent.offsetY))
                    } else if (se instanceof TouchEvent) {
                        //compute average position of the touches
                        let tx = 0, ty = 0
                        for (let tt of se.targetTouches) { tx += tt.clientX; ty += tt.clientY }
                        tx /= se.targetTouches.length; ty /= se.targetTouches.length
                        //zoom at this average position
                        this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                    }
                }
                tP = t
            }));
    }

    /** @param {{x:number,y:number}} v Geographical coordinates of the center */
    setCenter(v) { this.center = v; }
    /** @returns {{x:number,y:number}} Geographical coordinates of the center */
    getCenter() { return this.center; }

    /** @param {number} v The zoom factor (pixel size, in ground m) */
    setZf(v) { this.zf = v; }
    /** @returns {number} The zoom factor (pixel size, in ground m) */
    getZf() { return this.zf; }




    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.getZf();
        const tx = -this.center.x / this.getZf() + this.w * 0.5;
        const ty = this.center.y / this.getZf() + this.h * 0.5;
        this.ctx.setTransform(k, 0, 0, -k, tx, ty);
    }


    /** The function specifying how to draw the map. */
    redraw() {
        throw new Error('Method redraw not implemented.');
    }

    /**
     * Clear the app screen. To be used before a redraw for example.
     * @param {string} color 
     */
    clear(color = "white") {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.w, this.h);
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
    */
    geoToPixX(xGeo) { return (xGeo - this.center.x) / this.getZf() + this.w * 0.5; }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
    */
    geoToPixY(yGeo) { return -(yGeo - this.center.y) / this.getZf() + this.h * 0.5; }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
    */
    pixToGeoX(x) { return (x - this.w * 0.5) * this.getZf() + this.center.x; }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
    */
    pixToGeoY(y) { return -(y - this.h * 0.5) * this.getZf() + this.center.y; }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo, dyGeo) {
        //TODO force extend to remain
        this.center.x += dxGeo;
        this.center.y += dyGeo;
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.center.x, yGeo = this.center.y) {
        //TODO force extend to remain
        this.setZf(f * this.getZf());
        this.center.x += (xGeo - this.center.x) * (1 - f)
        this.center.y += (yGeo - this.center.y) * (1 - f)
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * @param {number} marginPx 
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx)
        }
        return this.extGeo;
    }

    /**
     * Check if the object has to be drawn
     * 
     * @param {{x:number,y:number}} obj 
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false;
        if (obj.x > this.extGeo.xMax) return false;
        if (obj.y < this.extGeo.yMin) return false;
        if (obj.y > this.extGeo.yMax) return false;
        return true
    }

}


/***/ }),

/***/ "./src/base/SpatialIndex.js":
/*!**********************************!*\
  !*** ./src/base/SpatialIndex.js ***!
  \**********************************/
/*! exports provided: SpatialIndex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpatialIndex", function() { return SpatialIndex; });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
//@ts-check

//see https://github.com/mourner/rbush


/**
 * @template T
 */
class SpatialIndex {

    /**
     * @constructor
     */
    constructor() {
        class MyRBush extends rbush__WEBPACK_IMPORTED_MODULE_0___default.a {
            /** @param {{x:number,y:number}} obj  */
            toBBox(obj) { return { minX: obj.x, minY: obj.y, maxX: obj.x, maxY: obj.y }; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinX(a, b) { return a.x - b.x; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinY(a, b) { return a.y - b.y; }
        }

        /** @type {MyRBush} */
        this.tree = new MyRBush();
    }

    //TODO bulk remove ?

    /**
     * @param {number} xmin
     * @param {number} ymin
     * @param {number} xmax
     * @param {number} ymax
     * @return {Array.<T>}
     */
    get(xmin, ymin, xmax, ymax) {
        return this.tree.search({
            minX: xmin,
            minY: ymin,
            maxX: xmax,
            maxY: ymax
        });
    }

    /**
     * @param {T} obj
     */
    insert(obj) {
        this.tree.insert(obj);
    }

    /**
     * Bulk insert
     * 
     * @param {Array.<T>} objs
     */
    load(objs) {
        this.tree.load(objs);
    }

    /**
     * @param {T} obj
     */
    remove(obj) {
        this.tree.remove(obj)
    }

    /**
     */
    clear() {
        this.tree.clear()
    }

}


/***/ }),

/***/ "./src/base/lib.js":
/*!*************************!*\
  !*** ./src/base/lib.js ***!
  \*************************/
/*! exports provided: objToArray, removeFromArray, removeFromArrayS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objToArray", function() { return objToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArray", function() { return removeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArrayS", function() { return removeFromArrayS; });
//@ts-check
/**
 * @template T
 * @param {Object.<?, T>} obj
 * @returns {Array.<T>}
 */
const objToArray = function (obj) {
    var out = [];
    for (var key in obj)
        if (obj.hasOwnProperty(key))
            out.push(obj[key]);
    return out;
};

/**
 * @template T
 * @param {Array.<T>} arr
 * @param {T} obj
 * @param {boolean} msg 
 */
const removeFromArray = function (arr, obj, msg = true) {
    /** @type {number} */
    var index = arr.indexOf(obj);
    if (index > -1)
        arr.splice(index, 1);
    else
        if (msg) console.log("Impossible to remove element not present in array.");
};

/**
 * 
 * @template T
 * @param {Array.<T>} arr
 * @param {Array.<T>} objs 
 * @param {boolean} msg 
 */
const removeFromArrayS = function (arr, objs, msg = true) {
    for (let obj of objs)
        removeFromArray(arr, obj, msg)
};


/***/ }),

/***/ "./src/fish/Sardin.js":
/*!****************************!*\
  !*** ./src/fish/Sardin.js ***!
  \****************************/
/*! exports provided: Sardin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sardin", function() { return Sardin; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check





/** */
class Sardin extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {Sea} sea 
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(sea, x = sea.w * Math.random(), y = sea.h * Math.random(), sx = undefined, sy = undefined) {

        //
        super(x, y, sx, sy)

        /** @type {Sea} */
        this.sea = sea;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > sea.w ? sea.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > sea.h ? sea.h : y

        //speed
        if (!sx && !sy) {
            this.setRandomSpeed(0, this.sea.V_MAX)

            //acceleration
            /** @type {number} */
            this.ax = 0
            /** @type {number} */
            this.ay = 0

            //list of sardins in vision field
            /** @type {Array.<Sardin>} */
            this.obs = []
            //list of sardins in collision field
            /** @type {Array.<Sardin>} */
            this.col = []
        }
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    observe(sindex) {

        /** @type {Sea} */
        const s = this.sea
        /** @type {number} */
        const dO = s.D_OBS

        //initialise lists
        /** @type {Array.<Sardin>} */
        this.obs = [];
        /** @type {Array.<Sardin>} */
        this.col = [];

        //get sardins around using spatial index
        /** @type {Array.<Sardin>} */
        const ss = sindex.get(this.x - dO, this.y - dO, this.x + dO, this.y + dO);

        //get sardins in observation and collision fields
        for (let f of ss) {
            if (f == this) continue;
            if (this.d(f) <= s.D_COL)
                this.col.push(f);
            if (this.d(f) <= dO) {
                //check angle
                let da = Math.atan2(f.y - this.y, f.x - this.x) - this.sa;
                if (da > Math.PI) da -= 2 * Math.PI;
                else if (da <= -Math.PI) da += 2 * Math.PI;
                da = Math.abs(da);
                if (da > s.A_OBS * 0.5) continue;
                this.obs.push(f);
            }
        }

        //initialise acceleration
        this.ax = 0; this.ay = 0;

        //collision: repulsion
        for (let f of this.col) {
            const d = this.d(f);
            const a = 1.0 * (1 / (d * d) - 1 / (s.D_COL * s.D_COL));
            this.ax += a * (this.x - f.x) / d;
            this.ay += a * (this.y - f.y) / d;
        }

        // toward target speed
        const dv = (s.V_TARGET - this.s) * 0.01;
        this.ax += dv * this.sx / this.s;
        this.ay += dv * this.sy / this.s;

        //toward the observed mean position
        /*if(obs.size()>1){
            double xn=0,yn=0;
            for(Sardin s:obs){
                xn+=s.x;
                yn+=s.y;
            }
            xn=xn/obs.size();
            yn=yn/obs.size();
            double d=Math.hypot(xn-x,yn-y);
            ax+=-0.1*(x-xn)/d;
            ay+=-0.1*(y-yn)/d;
        }*/

        //toward the observed speed
        const t = 0.9;
        if (this.obs.length > 1) {
            let dsx = 0, dsy = 0;
            for (let s of this.obs) {
                dsx += s.sx;
                dsy += s.sy;
            }
            dsx = (t - 1) * this.sx + (1 - t) * dsx / this.obs.length;
            dsy = (t - 1) * this.sy + (1 - t) * dsy / this.obs.length;

            const a = 0.1;
            this.ax += a * dsx;
            this.ay += a * dsy;
        }

        //avoid shark
        const sh = s.shark;
        if (sh != null) {
            const d = Math.hypot((sh.x - this.x), (sh.y - this.y));
            if (d <= s.D_OBS) {
                const a = 5.0 * (1 / (d * d) - 1 / (dO * dO));
                this.ax += a * (this.x - sh.x) / d;
                this.ay += a * (this.y - sh.y) / d;
            }
        }

    }


    /**
     * @param {number} timeStepMs 
     */
    move(timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.sy += this.ay * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.s = this.computeSpeed()
        if (this.s > this.sea.V_MAX) {
            this.s = this.sea.V_MAX;
            this.sx = this.sea.V_MAX * Math.cos(this.sa);
            this.sy = this.sea.V_MAX * Math.sin(this.sa);
        }

        //compute new position
        this.x += this.sx * timeStepMs;
        this.y += this.sy * timeStepMs;

        //limit
        if (this.x < 0) this.x = this.sea.w;
        if (this.y < 0) this.y = this.sea.h;
        if (this.x > this.sea.w) this.x = 0;
        if (this.y > this.sea.h) this.y = 0;
    }


    /**
     * Display a sardin body
     * 
     * @param {GeoCanvas} cp 
     * @param {number} length 
     */
    display(cp, length) {
        const c2 = cp.ctx
        const c = Math.floor(255 * Math.abs(this.sa) / Math.PI);
        c2.strokeStyle = "rgb(255, 255, " + c + ")"
        const a = length / this.s;
        const dx = a * this.sx * 0.5;
        const dy = a * this.sy * 0.5;

        c2.beginPath();
        c2.moveTo(this.x - dx, this.y - dy);
        c2.lineTo(this.x + dx, this.y + dy);
        c2.closePath();
        c2.stroke();
    }

    /**
     * Display sardin vision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} lineWidth 
     */
    displayVisionField(cp, fillStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.arc(this.x, this.y, this.sea.D_OBS / cp.getZf(),
            this.sa - this.sea.A_OBS * 0.5,
            this.sa + this.sea.A_OBS * 0.5
        );
        c2.closePath();
        c2.fill();
    }

    /**
     * Display sardin vision links
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayVisionLinks(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        for (let sa2 of this.obs) {
            c2.beginPath();
            c2.moveTo(this.x, this.y);
            c2.lineTo(sa2.x, sa2.y);
            c2.closePath();
            c2.stroke();
        }
    }

    /**
     * Display sardin collision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayCollisionField(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.sea.D_COL * 0.5 / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/fish/Sea.js":
/*!*************************!*\
  !*** ./src/fish/Sea.js ***!
  \*************************/
/*! exports provided: Sea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sea", function() { return Sea; });
/* harmony import */ var _Sardin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sardin */ "./src/fish/Sardin.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
//@ts-check




/** */
class Sea {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */        //get 10 random locations

    constructor(w, h) {

        //TODO should become static attributes of Sardin class

        //observation
        /** @type {number} */
        this.D_OBS = 50
        /** @type {number} */
        this.A_OBS = 200 * Math.PI / 180

        //collision
        /** @type {number} */
        this.D_COL = 10

        //speed
        /** @type {number} */
        this.V_TARGET = 0.3
        /** @type {number} */
        this.V_MAX = 0.6

        //shark
        /** @type {number} */
        this.D_SHARK_EAT = 12
        /** @type {number} */
        this.EATEN_SARDIN_NB = 0


        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Sardin>} */
        this.fish = []

        //TODO
        this.shark = null;

        /** @type {Array.<Sardin>} */
        this.killed = [];
    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //ini
        for (let f of this.fish) {
            f.computeSpeed()
            f.computeSpeedAngle()
        }

        //make spatial index
        /** @type {SpatialIndex.<Sardin>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.fish)

        //observe
        for (let f of this.fish)
            f.observe(sindex);

        //shark eat fish
        this.sharkEat(sindex);

        //dispose spatial index
        //sindex.clear()

        //move
        for (let f of this.fish)
            f.move(timeStepMs);
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    sharkEat(sindex) {
        if (this.shark == null) return;

        /** @type {Array.<Sardin>} */
        this.killed = [];

        const x = this.shark.x, y = this.shark.y;
        const ss = sindex.get(x - this.D_SHARK_EAT, y - this.D_SHARK_EAT, x + this.D_SHARK_EAT, y + this.D_SHARK_EAT);
        for (let s of ss) {
            const d = Math.hypot((x - s.x), (y - s.y));
            if (d > this.D_SHARK_EAT) continue;
            this.killed.push(s);
            Object(_base_lib__WEBPACK_IMPORTED_MODULE_2__["removeFromArray"])(this.fish, s)
            //sindex.remove(s);
        }
        this.EATEN_SARDIN_NB += this.killed.length;
        //eatenFishNb.setText("Eaten fish: " + EATEN_SARDIN_NB);
        return this;
    }

    /**
     * Add fish
     * 
     * @param {number} nb 
     * @returns {this}
     */
    addFish(nb = 1) {
        for (let i = 0; i < nb; i++)
            this.fish.push(new _Sardin__WEBPACK_IMPORTED_MODULE_0__["Sardin"](this));
        return this
    }

    /**
     * Set random speed for all fish
     * @returns {this}
     */
    setRandomSpeed() {
        for (let f of this.fish)
            f.setRandomSpeed()
        return this
    }

}


/***/ }),

/***/ "./src/fish/index.js":
/*!***************************!*\
  !*** ./src/fish/index.js ***!
  \***************************/
/*! exports provided: fish */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return fish; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check



class FishSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        //TODO
        //add eaten fish nb label

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        /** @type {boolean} */
        this.showFishVisionField = false
        /** @type {boolean} */
        this.showFishVisionLinks = false
        /** @type {boolean} */
        this.showFishCollisionField = false

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx
            const s = th.sea

            this.initCanvasTransform()

            //clear
            c2.fillStyle = "rgba(120,120,255,0.6)";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //show vision field
            if (th.showFishVisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionField(this, "rgba(200,200,200,0.15)", 1)
            //show vision links
            if (th.showFishVisionLinks)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionLinks(this, "rgba(255,100,100,0.3)", 1)
            //show collision field
            if (th.showFishCollisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayCollisionField(this, "purple", 1)


            //display sardins
            c2.lineWidth = 2
            const sardinLength = 7
            for (let sa of s.fish)
                if (this.toDraw(sa))
                    sa.display(this, sardinLength)


            //display shark
            if (s.shark != null) {

                c2.lineWidth = 4
                c2.strokeStyle = "black"

                const sharkLength = 12
                const dx = sharkLength * Math.cos(s.shark.angle);
                const dy = sharkLength * Math.sin(s.shark.angle);

                c2.beginPath();
                c2.moveTo(s.shark.x, s.shark.y);
                c2.lineTo(s.shark.x - dx, s.shark.y + dy);
                c2.closePath();
                c2.stroke();
            }

            //display blood spot
            c2.fillStyle = "red";
            c2.lineWidth = 1
            for (let sa of s.killed) {
                c2.beginPath();
                c2.moveTo(sa.x, sa.y);
                c2.arc(sa.x, sa.y, 4, 0, 2 * Math.PI);
                c2.closePath();
                c2.fill();
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        this.cplus.canvas.addEventListener("mouseover", e => {
            th.sea.shark = { x: th.cplus.pixToGeoX(e.offsetX), y: th.cplus.pixToGeoY(e.offsetY), angle: 0 }
        });
        this.cplus.canvas.addEventListener("mousemove", e => {
            const xG = th.cplus.pixToGeoX(e.offsetX);
            const yG = th.cplus.pixToGeoY(e.offsetY);
            const angle = Math.atan2(-yG + th.sea.shark.y, xG - th.sea.shark.x);
            th.sea.shark = { x: xG, y: yG, angle: angle }
        });
        this.cplus.canvas.addEventListener("mouseout", e => {
            th.sea.shark = null;
        });


        /** @type {Sea} */
        this.sea = new _Sea__WEBPACK_IMPORTED_MODULE_0__["Sea"](this.w, this.h)

    }


    /**
     * @param {number} density 
     * @returns {this}
     */
    initRandom(density = 0.001) {
        this.sea.addFish(density * this.sea.w * this.sea.h);
        return this
    }

    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.sea.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this
    }

}

/**
 * @param {Object} opts 
 */
const fish = function (opts) {
    return new FishSimulation(opts)
}


/***/ }),

/***/ "./src/gol/Cell.js":
/*!*************************!*\
  !*** ./src/gol/Cell.js ***!
  \*************************/
/*! exports provided: Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return Cell; });
//@ts-check

/**
 * 
 */
class Cell {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} nb 
     */
    constructor(x, y, nb=0) {
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.nb = nb
    }

}


/***/ }),

/***/ "./src/gol/Universe.js":
/*!*****************************!*\
  !*** ./src/gol/Universe.js ***!
  \*****************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




/**
 * 
 */
class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Cell>} */
        this.population = [];
        /** @type {Object.<string,Cell>} */
        this.populationI = {};
    }

    /**
     * @param {number} x
     * @param {number} y
     * @returns {Cell|null}
     */
    add(x, y) {

        //find cell at location
        /**@type {string}*/
        const id = x + "_" + y;
        if (this.populationI[id]) return null;

        //create new cell
        /**@type {Cell} */
        const cell = new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x, y, 0)
        this.population.push(cell)
        this.populationI[id] = cell
        return cell
    }

    /**
     * @returns {this}
     */
    step() {

        //TODO double indexing? by raw and then column ?
        //populate cell surroundings
        /** @type {Object.<string, Cell>}
         * @dict */
        const surI = {};
        //go through list of cells
        for (let cell of this.population) {
            // +1 surrounding cells
            const srs = Universe.getCellSurrounding(cell, this);
            for (let sur of srs) {
                const key = sur.x + "_" + sur.y;
                const sur_ = surI[key];
                if (sur_) {
                    sur_.nb++;
                } else {
                    sur.nb = 1;
                    surI[key] = sur;
                }
            }
        }

        //B3/S23
        //kill cells
        /** @type {Array.<Cell>} */
        const cellsToKeep = [];
        /** @type {Object.<string, Cell>}
         * @dict */
        const cellsToKeepI = {};
        for (let cell of this.population) {
            const key = cell.x + "_" + cell.y;
            const cell_ = surI[key];
            if (!cell_) continue;
            //if (nb<2 or nb>3) -> kill
            if (cell_.nb < 2 || cell_.nb > 3) continue;
            cellsToKeep.push(cell);
            cellsToKeepI[key] = cell;
        }
        this.population = cellsToKeep;
        this.populationI = cellsToKeepI;

        //create new cells
        /** @type {Array.<Cell>} */
        const surs = Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["objToArray"])(surI);
        for (let sur of surs) {

            if (sur.nb !== 3) continue;

            //check if already alive
            const key = sur.x + "_" + sur.y;
            let cell = this.populationI[key];
            if (cell) continue;

            //create new cell
            this.population.push(sur);
            this.populationI[key] = sur;
        }
        return this;
    }


    /**
     * @param {number} nb
     * @param {number} timeoutMS
     * @param {GeoCanvas} cplus
     * @return {Universe}
     */
    start(nb, timeoutMS, cplus) {
        let i = 0;
        const uni = this;
        const engine = function () {
            //console.log(i);
            uni.step();
            cplus.redraw();
            if (nb > 0 && i++ > nb) return;
            setTimeout(engine, timeoutMS);
        };
        engine();
        return this;
    }

    /**
     * @param {Cell} cell
     * @param {Universe} uni
     * @return {Array.<Cell>}
     */
    static getCellSurrounding(cell, uni) {
        const x1 = cell.x === 0 ? uni.w - 1 : cell.x - 1;
        const x2 = cell.x === uni.w - 1 ? 0 : cell.x + 1;
        const y1 = cell.y === 0 ? uni.h - 1 : cell.y - 1;
        const y2 = cell.y === uni.h - 1 ? 0 : cell.y + 1;
        return [
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y2),
        ];
    }

}


/***/ }),

/***/ "./src/gol/index.js":
/*!**************************!*\
  !*** ./src/gol/index.js ***!
  \**************************/
/*! exports provided: gameOfLife */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return gameOfLife; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Universe */ "./src/gol/Universe.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




//TODO zoom/pan, with canvas transform: better universe limits
//TODO buttons (play, stop, speed, draw, pan)
//TODO check canvas animation


class GoLSimulation {

    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //clear
            this.initCanvasTransform()
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            //draw cells
            this.setCanvasTransform()
            c2.fillStyle = "blue";
            for (let cell of th.uni.population)
                c2.fillRect((cell.x), (cell.y), 1, 1);

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };

        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_1__["Universe"](this.w, this.h);
    }


    //
    initRandom(density = 0.05) {
        let i = 0;
        /** @type {number} */
        const nb = this.uni.w * this.uni.h * density;
        while (i < nb) {
            const x = Math.round(this.uni.w * Math.random());
            const y = Math.round(this.uni.h * Math.random());
            /** @type {Cell} */
            const cell = this.uni.add(x, y);
            if (cell) i++;
        }
        return this;
    }


    //
    start() {
        this.uni.start(-1, 0, this.cplus);
        return this;
    }

}


const gameOfLife = function (opts) {
    return new GoLSimulation(opts)
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: planets, gameOfLife, fish, preyPredator, urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _planets_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planets/index */ "./src/planets/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return _planets_index__WEBPACK_IMPORTED_MODULE_0__["planets"]; });

/* harmony import */ var _gol_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gol/index */ "./src/gol/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return _gol_index__WEBPACK_IMPORTED_MODULE_1__["gameOfLife"]; });

/* harmony import */ var _fish_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fish/index */ "./src/fish/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return _fish_index__WEBPACK_IMPORTED_MODULE_2__["fish"]; });

/* harmony import */ var _pp_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pp/index */ "./src/pp/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return _pp_index__WEBPACK_IMPORTED_MODULE_3__["preyPredator"]; });

/* harmony import */ var _urban_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./urban/index */ "./src/urban/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return _urban_index__WEBPACK_IMPORTED_MODULE_4__["urban"]; });

//@ts-check








/***/ }),

/***/ "./src/planets/Planet.js":
/*!*******************************!*\
  !*** ./src/planets/Planet.js ***!
  \*******************************/
/*! exports provided: Planet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Planet", function() { return Planet; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




class Planet extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @constructor
     * @param {Universe} u The universe the planet belongs to.
     * @param {number} m The mass
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} sx The speed x
     * @param {number} sy The speed y
     */
    constructor(u, m, x, y, sx = 0, sy = 0) {

        //
        super(x, y, sx, sy)

        /** @type {Universe} */
        this.u = u;
        u.ps.push(this)

        /** @type {number} */
        this.m = m;

        //compute radius
        /** @type {number} */
        const r = this.r();

        //set position
        /** @type {number} */
        this.x = x < r ? r : x > u.w - r ? u.w - r : x;
        /** @type {number} */
        this.y = y < r ? r : y > u.h - r ? u.h - r : y;

        //acceleration
        /** @type {number} */
        this.ax = 0;
        /** @type {number} */
        this.ay = 0;
    }

    /**
     * Update the force, based on the gravity of other planets.
     * @param {number} exponent
     */
    observe(exponent) {

        //compute gravity field at planet location
        const g = this.u.getGravityField(this.x, this.y, this, exponent);

        //set acceleration
        /** @type {number} */
        this.ax = g.gx;
        /** @type {number} */
        this.ay = g.gy;
    }


    /**
     * @return {number} The radius of the planet, depending on its mass.
     */
    r() {
        return Math.pow(this.m / Math.PI, 0.5);
    }


    /**
     * 
     * @param {boolean} bounce 
     * @param {number} maxSpeed 
     * @param {number} timeStepMs 
     */
    change(bounce = false, maxSpeed = 0.8, timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs;
        this.sy += this.ay * timeStepMs;

        //check vmax
        if (maxSpeed > 0) {
            /** @type {number} */
            const v = Math.sqrt(this.sx * this.sx + this.sy * this.sy);
            if (v > maxSpeed) {
                this.sx = maxSpeed * this.sx / v;
                this.sy = maxSpeed * this.sy / v;
            }
        }

        //compute new position
        /** @type {number} */
        let nx = this.x + this.sx * timeStepMs;
        /** @type {number} */
        let ny = this.y + this.sy * timeStepMs;

        //handle position limit
        if (bounce) {
            const r = this.r();
            const e = 1;
            if (nx < r) { nx = r; this.sx = -this.sx * e; }
            if (ny < r) { ny = r; this.sy = -this.sy * e; }
            if (nx > this.u.w - r) { nx = this.u.w - r; this.sx = -this.sx * e; }
            if (ny > this.u.h - r) { ny = this.u.h - r; this.sy = -this.sy * e; }
        } else {
            if (nx < 0) { nx = this.u.w; }
            if (ny < 0) { ny = this.u.h; }
            if (nx > this.u.w) { nx = 0; }
            if (ny > this.u.h) { ny = 0; }
        }

        //move
        this.x = nx;
        this.y = ny;
    }


    /**
     * Display planet
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     */
    display(cp, fillStyle) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r() / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
    }

    /**
     * Display planet acceleration
     * 
     * @param {GeoCanvas} cp 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     * @param {number} factor 
     */
    displayAcceleration(cp, strokeStyle = "cyan", lineWidth = 1, factor = 5000) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.lineTo(this.x + factor * this.ax, this.y + factor * this.ay);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/planets/Universe.js":
/*!*********************************!*\
  !*** ./src/planets/Universe.js ***!
  \*********************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
//@ts-check




class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Planet>} */
        this.ps = [];
    }

    /**
     * Compute the mass of the universe, as the sum of the mass of its planets.
     * @returns {number}
     */
    m() {
        let m = 0;
        for (let p of this.ps)
            m += p.m;
        return m;
    }


    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {Planet} pIgnore A planet to ignore
     * @param {number} exponent
     * @returns {{gx:number,gy:number}}
     */
    getGravityField(x, y, pIgnore = undefined, exponent = 2) {

        /** @type {number} */
        let gx = 0
        /** @type {number} */
        let gy = 0

        //gothrough all planets in the universe
        for (let p of this.ps) {

            //ignore planet
            if (pIgnore && p == pIgnore)
                continue;

            //compute distance
            /** @type {number} */
            let d = p.dP(x, y);
            if (d === 0)
                continue;

            //compute and add contribution
            d = d * Math.pow(d, exponent);
            gx += 0.01 * (p.x - x) * p.m / d;
            gy += 0.01 * (p.y - y) * p.m / d;
        }
        return { gx: gx, gy: gy }
    }


    /**
     * Aggregate two planets
     * 
     * @param {Planet} p1
     * @param {Planet} p2
     * @param {SpatialIndex.<Planet>} sindex
     * @returns {Planet}
     */
    aggregate(p1, p2, sindex) {
        const m = p1.m + p2.m;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](
            this,
            m,
            (p1.x * p1.m + p2.x * p2.m) / m,
            (p1.y * p1.m + p2.y * p2.m) / m,
            (p1.sx * p1.m + p2.sx * p2.m) / m,
            (p1.sy * p1.m + p2.sy * p2.m) / m
        );
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p1);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p2);

        if (sindex) {
            sindex.remove(p1)
            sindex.remove(p2)
            sindex.insert(p)
        }

        return p;
    }



    /**
     * @param {SpatialIndex.<Planet>} sindex
     * @param {number} collisionFactor
     * @returns {Array.<Planet>}
     */
    findCollision(sindex, collisionFactor = 1) {
        for (let pi of this.ps) {

            const w = 2 * pi.r();
            const cand = sindex.get(pi.x - w, pi.y - w, pi.x + w, pi.y + w);

            for (let pj of cand) {

                if (pi == pj) continue;

                /** @type {number} */
                const d1 = pi.d(pj);
                /** @type {number} */
                const d2 = (pi.r() + pj.r()) * collisionFactor;
                if (d1 > d2)
                    continue;
                return [pi, pj];

            }
        }
        return null;
    }


    /**
     * Add planets with random speed
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed
     * @param {number} maxSpeed
     * @returns {this}
     */
    addPlanets(nb = 1, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        for (let i = 0; i < nb; i++) {
            const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, mi, this.w * Math.random(), this.h * Math.random());
            p.setRandomSpeed(minSpeed, maxSpeed);
        }
        return this;
    }



    /**
     * 
     * @param {boolean} bounce 
     * @param {number} vmax 
     * @param {number} exponent 
     * @param {number} collisionFactor 
     * @param {number} timeStepMs 
     * @returns {this}
     */
    step(bounce = false, vmax = 0.8, exponent = 2, collisionFactor = 1, timeStepMs = 10) {

        //observation
        for (let p of this.ps)
            p.observe(exponent);

        //action
        for (let p of this.ps)
            p.change(bounce, vmax, timeStepMs);


        //collision detection
        this.detectCollisions(collisionFactor)

        return this;
    }

    /**
     * @param {number} collisionFactor 
     * @returns {this}
     */
    detectCollisions(collisionFactor = 1) {

        /** @type {SpatialIndex.<Planet>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.ps)

        //find first collision
        /** @type {Array.<Planet>} */
        let pair = this.findCollision(sindex, collisionFactor);
        while (pair !== null) {

            //aggregate
            const p = this.aggregate(pair[0], pair[1], sindex)

            //find next collision
            pair = this.findCollision(sindex, collisionFactor);
        }

        return this;
    }


    /**
     * Assign random speed to all planets
     * 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        for (let p of this.ps)
            p.setRandomSpeed(minSpeed, maxSpeed)
        return this
    }

    /**
     * @returns {Planet} The largest planet of the universe, usually the star.
     */
    getLargestPlanet() {
        let pM = null, mM = 0;
        for (let p of this.ps)
            if (p.m > mM) { pM = p; mM = p.m }
        return pM
    }

    /**
     * Get largest planet and explode it.
     */
    explodeLargestPlanet() {
        const p = this.getLargestPlanet()
        this.explode(p)
    }

    /**
     * Explode a planet into pieces
     * 
     * @param {Planet} p 
     * @param {number} nb 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     */
    explode(p, nb = -1, minSpeed = 0.8, maxSpeed = 1.5, rad = -1) {
        if (nb <= 0) nb = Math.floor(p.m);
        if (nb <= 0) return;
        const angleStep = 2 * Math.PI / nb;
        for (let i = 0; i < nb; i++) {
            //create planet

            //position
            if (rad < 0) rad = 2 * p.r()
            const d = rad * Math.random();
            const a = i * angleStep;
            const x = d * Math.cos(a), y = d * Math.sin(a);

            //speed
            const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
            const aS = a + 2 * (Math.random() - 0.5) * 2 * Math.PI / 3;
            const sx = speed * Math.cos(aS), sy = speed * Math.sin(aS);

            new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, p.m / nb, p.x + x, p.y + y, p.sx + sx, p.sy + sy)
        }
        //remove p from universe
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p);
    }

}


/***/ }),

/***/ "./src/planets/index.js":
/*!******************************!*\
  !*** ./src/planets/index.js ***!
  \******************************/
/*! exports provided: planets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return planets; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/**  */
class PlanetSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {number} */
        this.maxSpeed = opts.maxSpeed || 0.8;
        /** @type {boolean} */
        this.bounce = opts.bounce || false
        /** @type {number} */
        this.exponent = opts.exponent || 2;
        /** @type {number} */
        this.collisionFactor = opts.collisionFactor || 1;

        /** @type {boolean} */
        this.showPlanetAcceleration = false

        /** @type {string|undefined} */
        this.showField = undefined
        /** @type {number} */
        this.fieldRes = 20
        /** @type {number} */
        this.fieldFactor = 1000
        /** @type {string} */
        this.fieldStrokeStyle = "#99bbff";

        /** @type {number} */
        this.tailings = opts.tailings || 0.1;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear, with transparency
            c2.fillStyle = "rgba(0,0,0," + th.tailings + ")";
            c2.fillRect(0, 0, th.w, th.h);
            //c2.fillRect(-1e20, -1e20, 2e20, 2e20); //todo

            //display gravity field
            if (th.showField === "f")
                th.displayGravityField(this, true)
            else if (th.showField === "i")
                th.displayGravityField(this, false)


            this.setCanvasTransform()

            //display planets
            for (let p of th.uni.ps) {
                if (!this.toDraw(p)) continue
                const t = p.m / th.uni.m();
                p.display(this, "rgb(255,255," + Math.floor(255 * (1 - t)) + ")")
            }

            //display planets acceleration
            if (th.showPlanetAcceleration) {
                for (let p of th.uni.ps) {
                    if (!this.toDraw(p)) continue
                    p.displayAcceleration(this)
                }
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Universe} */
        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_0__["Universe"](this.w, this.h)
    }


    /**
     * @param {GeoCanvas} cp 
     * @param {boolean} field 
     */
    displayGravityField(cp, field = true) {
        const c2 = cp.ctx
        const res = this.fieldRes
        const f = this.fieldFactor
        const f_ = field ? 0.3 * res : 0.6 * res;
        c2.strokeStyle = this.fieldStrokeStyle
        for (let x = res * 0.5; x < this.w; x += res) {
            const xG = cp.pixToGeoX(x);
            if (xG > this.uni.w || xG < 0) continue
            for (let y = res / 2; y < this.h; y += res) {
                const yG = cp.pixToGeoY(y);
                if (yG > this.uni.h || yG < 0) continue
                //get gravity field
                const g = this.uni.getGravityField(xG, yG, undefined, this.exponent);
                const g_ = Math.hypot(g.gx, g.gy)

                c2.lineWidth = Math.min(f * g_, 0.3 * res);
                const dx = f_ * g.gx / g_, dy = f_ * g.gy / g_

                //draw
                c2.beginPath();
                if (field) {
                    //gravity field
                    c2.moveTo(x - dx, y + dy);
                    c2.lineTo(x + dx, y - dy);
                } else {
                    //isopotential lines
                    c2.moveTo(x + dy, y + dx);
                    c2.lineTo(x - dy, y - dx);
                }
                c2.closePath();
                c2.stroke();
            }
        }
    }


    /**
     * Initialise with random planets
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    initRandom(nb = 1000, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        this.uni.addPlanets(nb, mi, minSpeed, maxSpeed);
        return this;
    }

    /**
     * Initialise with big bang setup
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     * @returns {this}
     */
    initBigBang(nb = 1000, mi = 1, minSpeed = 0.35, maxSpeed = 0.7, rad = 100) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        //create big planet in the middle
        const cx = this.w * 0.5, cy = this.h * 0.5;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_1__["Planet"](this.uni, nb * mi, cx, cy, 0, 0);
        //explode it
        this.uni.explode(p, nb, minSpeed, maxSpeed, rad)
        return this;
    }

    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.uni.step(t.bounce, t.maxSpeed, t.exponent, t.collisionFactor, timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const planets = function (opts) {
    return new PlanetSimulation(opts)
}


/***/ }),

/***/ "./src/pp/Animal.js":
/*!**************************!*\
  !*** ./src/pp/Animal.js ***!
  \**************************/
/*! exports provided: Animal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animal", function() { return Animal; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




/** */
class Animal extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {number} type 
     * @param {Land} l 
     * @param {number} x 
     * @param {number} y 
     */
    constructor(type, l, x = 0, y = 0) {

        super(x, y)

        /** @type {number} */
        this.type = type;
        /** @type {Land} */
        this.l = l;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > l.w ? l.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > l.h ? l.h : y

        //the other animals around
        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        //add to the spatial index
        l.grid.insert(this);
    }


    /**
     * @param {*} timeStepMs 
     */
    move(timeStepMs = 10) {
        const l = this.l
        l.grid.remove(this);

        const angle = Math.random() * 2 * Math.PI;
        const r = 0.01 * Math.random();

        this.sx += r * Math.cos(angle) * timeStepMs;
        this.sx = this.sx > l.V_MAX ? l.V_MAX : this.sx < -l.V_MAX ? -l.V_MAX : this.sx

        this.sy += r * Math.sin(angle) * timeStepMs;
        this.sy = this.sy > l.V_MAX ? l.V_MAX : this.sy < -l.V_MAX ? -l.V_MAX : this.sy

        this.x += this.sx * timeStepMs;
        this.x = this.x < 0 ? l.w : this.x > l.w ? 0 : this.x

        this.y += this.sy * timeStepMs;
        this.y = this.y < 0 ? l.h : this.y > l.h ? 0 : this.y

        l.grid.insert(this);
    }


    /** Observe */
    observe() {
        const l = this.l

        //get animals around
        const as = l.grid.get(this.x - l.d, this.y - l.d, this.x + l.d, this.y + l.d);

        this.preys = [];
        this.predators = [];

        for (let a of as) {
            if (a == this) continue;
            if (this.d(a) > l.d) continue;
            if (a.type == 0)
                this.preys.push(a);
            else
                this.predators.push(a);
        }
    }

    /** @returns {Animal} */
    makeChild() {
        //do better: make child around
        return new Animal(this.type, this.l, this.x, this.y);
    }



    /**
     * Display animal
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} size 
     */
    display(cp, fillStyle = "blue", size = 2) {
        cp.ctx.fillStyle = fillStyle;
        cp.ctx.fillRect(this.x, this.y, size, size);
        /*c2.beginPath();
        c2.arc(a.x, a.y, 0.5, 0, 2*Math.PI);
        c2.closePath();
        c2.fill();*/
    }

}


/***/ }),

/***/ "./src/pp/Land.js":
/*!************************!*\
  !*** ./src/pp/Land.js ***!
  \************************/
/*! exports provided: Land */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Land", function() { return Land; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
//@ts-check




class Land {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */
    constructor(w, h) {

        //the max speed
        /** @type {number} */
        this.V_MAX = 0.1

        /** @type {number} */
        this.p = 0.02 //predator death probability
        /** @type {number} */
        this.q = 0.1 //prey reproduction probability
        /** @type {number} */
        this.r = 0.5 //eaten prey transformation probability
        /** @type {number} */
        this.nb = 3 //neighbors number

        /** @type {number} */
        this.w = w
        /** @type {number} */
        this.h = h

        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        /** @type {number} */
        this.d = 10
        /** @type {SpatialIndex.<Animal>} */
        this.grid = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /*int[][] histo;
        int index=0;
        this.c2Chart=c2Chart;
        this.hChart=hChart;
        this.histo=new int[wChart][];
        for(int i=0;i<wChart;i++)
            histo[i]=new int[]{0,0};*/

    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //observe
        for (let a of this.preys) a.observe();
        for (let a of this.predators) a.observe();

        const preysToBorn = []
        const preysToDie = []
        const predsToBorn = []
        const predsToDie = []

        //prey
        for (let prey of this.preys) {
            //reproduction if no predator around
            if (Math.random() > this.q) continue;
            if (prey.predators.length != 0) continue;
            if (prey.preys.length >= this.nb) continue;
            preysToBorn.push(prey.makeChild());
        }

        //predator
        for (let pred of this.predators) {
            //no prey around: predator dies with probability p
            if (pred.preys.length == 0) {
                if (Math.random() < this.p) predsToDie.push(pred);
            }
            //prey around
            else {
                //eat prey
                //choose randomly
                const preyToEat = pred.preys[Math.floor(pred.preys.length * Math.random())];
                preysToDie.push(preyToEat);

                //predator reproduction
                if (Math.random() > this.r) continue;
                if (pred.predators.length >= this.nb) continue;
                predsToBorn.push(pred.makeChild());
            }
        }

        this.preys.push(...preysToBorn);
        this.predators.push(...predsToBorn);

        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.preys, preysToDie, false)
        for (let a of preysToDie) this.grid.remove(a);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.predators, predsToDie, false)
        for (let a of predsToDie) this.grid.remove(a);

        //move
        for (let a of this.preys)
            a.move(timeStepMs);
        for (let a of this.predators)
            a.move(timeStepMs);

        /*/histo
        histo[index] = new int[]{ preys.size(), predators.size() };
        if (index == histo.length - 1) index = 0;
        else index++;*/

    }
}


/***/ }),

/***/ "./src/pp/index.js":
/*!*************************!*\
  !*** ./src/pp/index.js ***!
  \*************************/
/*! exports provided: preyPredator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return preyPredator; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/** */
class PreyPredatorSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);


        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //transparency
            this.initCanvasTransform()
            c2.fillStyle = "rgba(255,255,255,0.5)";
            c2.fillRect(0, 0, th.w, th.h);

            //display animals
            this.setCanvasTransform()
            for (let a of th.land.preys)
                if (this.toDraw(a))
                    a.display(this, "blue");
            for (let a of th.land.predators)
                if (this.toDraw(a))
                    a.display(this, "red");

            /*/label
            c2.fillStyle = "lightgray";
            c2.fillRect(0, 0, 65, 13);
            c2.fillStyle = "black";
            c2.fillText(preys.length + "/" + predators.length, 2, 10);*/

            //chart
            //c2Chart.setFillStyle(backColor2);
            //c2Chart.fillRect(0, 0, w, h);

            //double max = getMaxHisto();
            /*public int getMaxHisto() {
                int max=0;
                for(int i=0;i<histo.length;i++){
                    if(histo[i][0]>max) max=histo[i][0];
                    if(histo[i][1]>max) max=histo[i][1];
                }
                return max;
            }*/
            /*
                        if (max != 0) {
                            double h1, h2;
                            for (int i = 0; i < histo.length; i++) {
                                h1 = hChart * histo[i][0] / max;
                                h2 = hChart * histo[i][1] / max;
                                c2Chart.setFillStyle(preyColor2);
                                c2Chart.fillRect(i, hChart - h1, 1, h1);
                                c2Chart.setFillStyle(predatorColor2);
                                c2Chart.fillRect(i, hChart - h2, 1, h2);
                            }
                        }
                        c2Chart.setFillStyle(CssColor.make(255, 255, 255));
                        c2Chart.fillRect(index, 0, 1, hChart);
            */

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };


        /** @type {Land} */
        this.land = new _Land__WEBPACK_IMPORTED_MODULE_0__["Land"](this.w, this.h)

    }



    //TODO test init in a bubble ?
    //TODO use density as input parameters instead of nb

    /**
     * 
     * @param {number} preyDensity 
     * @param {number} predatorDensity 
     * @returns {this}
     */
    initRandom(preyDensity = 0.003, predatorDensity = 0.003) {
        const l = this.land
        for (let i = 0; i < preyDensity * l.w * l.h; i++)
            l.preys.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](0, l, l.w * Math.random(), l.h * Math.random())
            );
        for (let i = 0; i < predatorDensity * l.w * l.h; i++)
            l.predators.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](1, l, l.w * Math.random(), l.h * Math.random())
            );
        return this;
    }


    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.land.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

}


/**
 * @param {Object} opts 
 */
const preyPredator = function (opts) {
    return new PreyPredatorSimulation(opts)
}


/***/ }),

/***/ "./src/urban/Building.js":
/*!*******************************!*\
  !*** ./src/urban/Building.js ***!
  \*******************************/
/*! exports provided: Building */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Building", function() { return Building; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check



class Building {

    /**
     * @constructor
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} area The area
     */
    constructor(x, y, area) {

        //set position
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.area = area
    }

    /**
     * @returns { number }
     */
    r() {
        return Math.sqrt(this.area / Math.PI)
    }

    /**
     * @param {Building} b 
     */
    overlap(b) {
        const d1 = b.r() + this.r()
        const d2 = Math.hypot((b.x - this.x), (b.y - this.y));
        return d2 < d1
    }



    /**
     * @param {SpatialIndex.<Building>} sindex 
     * @param {number} sDistance 
     * @returns {boolean}
     */
    checkCollision(sindex, sDistance) {

        //get buildings around using spatial index
        /** @type {Array.<Building>} */
        const ss = sindex.get(this.x - sDistance, this.y - sDistance, this.x + sDistance, this.y + sDistance);

        for (let b of ss) {
            if (b == this) continue;
            if (this.overlap(b)) return true
        }
        return false;
    }




    /**
     * Display
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     * @param {String} strokeStyle 
     */
    display(cp, fillStyle, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
        c2.stroke();
    }


}


/***/ }),

/***/ "./src/urban/Map.js":
/*!**************************!*\
  !*** ./src/urban/Map.js ***!
  \**************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Building__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Building */ "./src/urban/Building.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jsts__WEBPACK_IMPORTED_MODULE_2__);
//@ts-check




class Map {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Building>} */
        this.bs = [];
        /** @type {SpatialIndex.<Building>} */
        this.buIndex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();


        /*
        //test turf
                var ls = turf.lineString([[1000, 0], [1000, 1000]]);
                console.log(ls)
                //var pt = turf.point([1000, 1000]);
                var buff = turf.buffer(ls, 10, 'degrees');
                console.log(buff)
        */

        //test jsts
        //https://bjornharrtell.github.io/jsts/
        var reader = new jsts__WEBPACK_IMPORTED_MODULE_2___default.a.io.WKTReader()
        var a = reader.read('POINT (-20 0)')
        console.log(reader)
        console.log(a)
        a = a.buffer(40)
        console.log(a)
        var w = new jsts__WEBPACK_IMPORTED_MODULE_2___default.a.io.WKTWriter()
        console.log(w.write(a))
    }

    /** */
    addBuilding() {

        //compute candidate location, size and type for next building
        //TODO low local congestion AND go to high density (with good access to other stuff)

        //make random building
        const makeRandomBuilding = () => {
            const x = this.w * Math.random();
            const y = this.h * Math.random();
            const area = 40 + 200 * Math.random()
            return new _Building__WEBPACK_IMPORTED_MODULE_1__["Building"](x, y, area)
        }

        //TODO should not overlap with other entities (roads, building)

        /** @type {number} */
        const sDistance = 100;
        /** @type {Building} */
        let bu = makeRandomBuilding();
        while (bu.checkCollision(this.buIndex, sDistance)) {
            bu = makeRandomBuilding();
        }

        //add building
        this.bs.push(bu);
        this.buIndex.load([bu])
    }

    /**
     * @returns {this}
     */
    step() {

        //compute building need
        const buNeed = 10;

        //urbanise
        for (let i = 0; i < buNeed; i++) {
            this.addBuilding();
        }

        //extend road network
        //TODO

        return this;
    }

}


/***/ }),

/***/ "./src/urban/index.js":
/*!****************************!*\
  !*** ./src/urban/index.js ***!
  \****************************/
/*! exports provided: urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return urban; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map */ "./src/urban/Map.js");
//@ts-check



/**  */
class UrbanSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //display buildings
            for (let b of th.map.bs) {
                if (!this.toDraw(b)) continue
                b.display(this, "lightgray", "black", 2)
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Map} */
        this.map = new _Map__WEBPACK_IMPORTED_MODULE_1__["Map"](this.w, this.h)
    }


    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.map.step();
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const urban = function (opts) {
    return new UrbanSimulation(opts)
}


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZWN0YWcvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3ZlY3RhZy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY3ViZWhlbGl4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2RyYWcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9iYWNrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9ib3VuY2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2V4cC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcG9seS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvc2luLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kaXNjcmV0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hjbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hzbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2h1ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbGFiLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JvdW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRvci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9sb2NhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tYXRjaGVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlcnMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2xvd2VyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZXMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvd2luZG93LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW50ZXJydXB0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0clR3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2RlbGF5LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZVZhcnlpbmcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2NoZWR1bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3R3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2pzdHMvZGlzdC9qc3RzLm1pbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvcmJ1c2gvcmJ1c2gubWluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL0FnZW50UG9pbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Jhc2UvR2VvQ2FudmFzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL1NwYXRpYWxJbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvYmFzZS9saWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Zpc2gvU2FyZGluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9maXNoL1NlYS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZmlzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL0NlbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2dvbC9Vbml2ZXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcGxhbmV0cy9QbGFuZXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvVW5pdmVyc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BwL0FuaW1hbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvTGFuZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL0J1aWxkaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9NYXAuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMkM7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUFNLFdBQVcseURBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ087QUFDUDtBQUNBIiwiZmlsZSI6InZlY3RhZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInZlY3RhZ1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJ2ZWN0YWdcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiYnVpbGQvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2xvcigpIHt9XG5cbmV4cG9ydCB2YXIgZGFya2VyID0gMC43O1xuZXhwb3J0IHZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4ID0gL14jKFswLTlhLWZdezMsOH0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlSSwgcmVJLCByZUldICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlUCwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVJLCByZUksIHJlSSwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlUCwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xhXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIik7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGNvcHk6IGZ1bmN0aW9uKGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHRoaXMuY29uc3RydWN0b3IsIHRoaXMsIGNoYW5uZWxzKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogY29sb3JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IGNvbG9yX2Zvcm1hdEhleCxcbiAgZm9ybWF0SHNsOiBjb2xvcl9mb3JtYXRIc2wsXG4gIGZvcm1hdFJnYjogY29sb3JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogY29sb3JfZm9ybWF0UmdiXG59KTtcblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SHNsKCkge1xuICByZXR1cm4gaHNsQ29udmVydCh0aGlzKS5mb3JtYXRIc2woKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0UmdiKCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRSZ2IoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtLCBsO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4LmV4ZWMoZm9ybWF0KSkgPyAobCA9IG1bMV0ubGVuZ3RoLCBtID0gcGFyc2VJbnQobVsxXSwgMTYpLCBsID09PSA2ID8gcmdibihtKSAvLyAjZmYwMDAwXG4gICAgICA6IGwgPT09IDMgPyBuZXcgUmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpIC8vICNmMDBcbiAgICAgIDogbCA9PT0gOCA/IHJnYmEobSA+PiAyNCAmIDB4ZmYsIG0gPj4gMTYgJiAweGZmLCBtID4+IDggJiAweGZmLCAobSAmIDB4ZmYpIC8gMHhmZikgLy8gI2ZmMDAwMDAwXG4gICAgICA6IGwgPT09IDQgPyByZ2JhKChtID4+IDEyICYgMHhmKSB8IChtID4+IDggJiAweGYwKSwgKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKCgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZikpIC8gMHhmZikgLy8gI2YwMDBcbiAgICAgIDogbnVsbCkgLy8gaW52YWxpZCBoZXhcbiAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcbiAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgMSkgLy8gcmdiKDEwMCUsIDAlLCAwJSlcbiAgICAgIDogKG0gPSByZVJnYmFJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pIC8vIHJnYmEoMjU1LCAwLCAwLCAxKVxuICAgICAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcbiAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgMSkgLy8gaHNsKDEyMCwgNTAlLCA1MCUpXG4gICAgICA6IChtID0gcmVIc2xhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCBtWzRdKSAvLyBoc2xhKDEyMCwgNTAlLCA1MCUsIDEpXG4gICAgICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICA6IGZvcm1hdCA9PT0gXCJ0cmFuc3BhcmVudFwiID8gbmV3IFJnYihOYU4sIE5hTiwgTmFOLCAwKVxuICAgICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiByZ2JuKG4pIHtcbiAgcmV0dXJuIG5ldyBSZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmLCAxKTtcbn1cblxuZnVuY3Rpb24gcmdiYShyLCBnLCBiLCBhKSB7XG4gIGlmIChhIDw9IDApIHIgPSBnID0gYiA9IE5hTjtcbiAgcmV0dXJuIG5ldyBSZ2IociwgZywgYiwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5yID0gK3I7XG4gIHRoaXMuZyA9ICtnO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShSZ2IsIHJnYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKC0wLjUgPD0gdGhpcy5yICYmIHRoaXMuciA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmcgJiYgdGhpcy5nIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuYiAmJiB0aGlzLmIgPCAyNTUuNSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgaGV4OiByZ2JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IHJnYl9mb3JtYXRIZXgsXG4gIGZvcm1hdFJnYjogcmdiX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IHJnYl9mb3JtYXRSZ2Jcbn0pKTtcblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIFwiI1wiICsgaGV4KHRoaXMucikgKyBoZXgodGhpcy5nKSArIGhleCh0aGlzLmIpO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0UmdiKCkge1xuICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgcmV0dXJuIChhID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCIpXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLnIpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5nKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuYikgfHwgMCkpXG4gICAgICArIChhID09PSAxID8gXCIpXCIgOiBcIiwgXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodmFsdWUpIHx8IDApKTtcbiAgcmV0dXJuICh2YWx1ZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIHZhbHVlLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gaHNsYShoLCBzLCBsLCBhKSB7XG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcbiAgZWxzZSBpZiAobCA8PSAwIHx8IGwgPj0gMSkgaCA9IHMgPSBOYU47XG4gIGVsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBmb3JtYXRIc2w6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICAgIHJldHVybiAoYSA9PT0gMSA/IFwiaHNsKFwiIDogXCJoc2xhKFwiKVxuICAgICAgICArICh0aGlzLmggfHwgMCkgKyBcIiwgXCJcbiAgICAgICAgKyAodGhpcy5zIHx8IDApICogMTAwICsgXCIlLCBcIlxuICAgICAgICArICh0aGlzLmwgfHwgMCkgKiAxMDAgKyBcIiVcIlxuICAgICAgICArIChhID09PSAxID8gXCIpXCIgOiBcIiwgXCIgKyBhICsgXCIpXCIpO1xuICB9XG59KSk7XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdiLCBkYXJrZXIsIGJyaWdodGVyfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWdyZWVzLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbnZhciBBID0gLTAuMTQ4NjEsXG4gICAgQiA9ICsxLjc4Mjc3LFxuICAgIEMgPSAtMC4yOTIyNyxcbiAgICBEID0gLTAuOTA2NDksXG4gICAgRSA9ICsxLjk3Mjk0LFxuICAgIEVEID0gRSAqIEQsXG4gICAgRUIgPSBFICogQixcbiAgICBCQ19EQSA9IEIgKiBDIC0gRCAqIEE7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEN1YmVoZWxpeCkgcmV0dXJuIG5ldyBDdWJlaGVsaXgoby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbCA9IChCQ19EQSAqIGIgKyBFRCAqIHIgLSBFQiAqIGcpIC8gKEJDX0RBICsgRUQgLSBFQiksXG4gICAgICBibCA9IGIgLSBsLFxuICAgICAgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBELFxuICAgICAgcyA9IE1hdGguc3FydChrICogayArIGJsICogYmwpIC8gKEUgKiBsICogKDEgLSBsKSksIC8vIE5hTiBpZiBsPTAgb3IgbD0xXG4gICAgICBoID0gcyA/IE1hdGguYXRhbjIoaywgYmwpICogZGVncmVlcyAtIDEyMCA6IE5hTjtcbiAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCA8IDAgPyBoICsgMzYwIDogaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjdWJlaGVsaXhDb252ZXJ0KGgpIDogbmV3IEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEN1YmVoZWxpeCwgY3ViZWhlbGl4LCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gaXNOYU4odGhpcy5oKSA/IDAgOiAodGhpcy5oICsgMTIwKSAqIHJhZGlhbnMsXG4gICAgICAgIGwgPSArdGhpcy5sLFxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcbiAgICAgICAgY29zaCA9IE1hdGguY29zKGgpLFxuICAgICAgICBzaW5oID0gTWF0aC5zaW4oaCk7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICAyNTUgKiAobCArIGEgKiAoQSAqIGNvc2ggKyBCICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEMgKiBjb3NoICsgRCAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG4gIHJldHVybiBwcm90b3R5cGU7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgY29sb3IsIHJnYiwgaHNsfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGxhYiwgaGNsLCBsY2gsIGdyYXl9IGZyb20gXCIuL2xhYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1YmVoZWxpeH0gZnJvbSBcIi4vY3ViZWhlbGl4LmpzXCI7XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcbmltcG9ydCB7Q29sb3IsIHJnYkNvbnZlcnQsIFJnYn0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmltcG9ydCB7ZGVncmVlcywgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG4vLyBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL2xhYi1hbmQtcmdiXG5jb25zdCBLID0gMTgsXG4gICAgWG4gPSAwLjk2NDIyLFxuICAgIFluID0gMSxcbiAgICBabiA9IDAuODI1MjEsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIGhjbDJsYWIobyk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSByZ2IybHJnYihvLnIpLFxuICAgICAgZyA9IHJnYjJscmdiKG8uZyksXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIyMjUwNDUgKiByICsgMC43MTY4Nzg2ICogZyArIDAuMDYwNjE2OSAqIGIpIC8gWW4pLCB4LCB6O1xuICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB4ID0geiA9IHk7IGVsc2Uge1xuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xuICAgIHogPSB4eXoybGFiKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZyArIDAuNzE0MTczMyAqIGIpIC8gWm4pO1xuICB9XG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXkobCwgb3BhY2l0eSkge1xuICByZXR1cm4gbmV3IExhYihsLCAwLCAwLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwIDwgby5sICYmIG8ubCA8IDEwMCA/IDAgOiBOYU4sIG8ubCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBNYXRoLmF0YW4yKG8uYiwgby5hKSAqIGRlZ3JlZXM7XG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmZ1bmN0aW9uIGhjbDJsYWIobykge1xuICBpZiAoaXNOYU4oby5oKSkgcmV0dXJuIG5ldyBMYWIoby5sLCAwLCAwLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IG8uaCAqIHJhZGlhbnM7XG4gIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBoY2wybGFiKHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG4iLCJleHBvcnQgY29uc3QgcmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgY29uc3QgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogKCkgPT4ge319O1xuXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykgfHwgL1tcXHMuXS8udGVzdCh0KSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBkaXNwYXRjaH0gZnJvbSBcIi4vZGlzcGF0Y2guanNcIjtcbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtzZWxlY3QsIHBvaW50ZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2RyYWcsIHt5ZXNkcmFnfSBmcm9tIFwiLi9ub2RyYWcuanNcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9ucGFzc2l2ZSwgbm9ucGFzc2l2ZWNhcHR1cmUsIG5vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IERyYWdFdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoZXZlbnQpIHtcbiAgcmV0dXJuICFldmVudC5jdHJsS2V5ICYmICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGV2ZW50LCBkKSB7XG4gIHJldHVybiBkID09IG51bGwgPyB7eDogZXZlbnQueCwgeTogZXZlbnQueX0gOiBkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBjb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IGRlZmF1bHRTdWJqZWN0LFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIGdlc3R1cmVzID0ge30sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImVuZFwiKSxcbiAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICBtb3VzZWRvd254LFxuICAgICAgbW91c2Vkb3dueSxcbiAgICAgIG1vdXNlbW92aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZCwgbm9ucGFzc2l2ZSlcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKGV2ZW50LCBkKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuY2FsbCh0aGlzLCBldmVudCwgZCkpIHJldHVybjtcbiAgICB2YXIgZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KHRoaXMsIGNvbnRhaW5lci5jYWxsKHRoaXMsIGV2ZW50LCBkKSwgZXZlbnQsIGQsIFwibW91c2VcIik7XG4gICAgaWYgKCFnZXN0dXJlKSByZXR1cm47XG4gICAgc2VsZWN0KGV2ZW50LnZpZXcpXG4gICAgICAub24oXCJtb3VzZW1vdmUuZHJhZ1wiLCBtb3VzZW1vdmVkLCBub25wYXNzaXZlY2FwdHVyZSlcbiAgICAgIC5vbihcIm1vdXNldXAuZHJhZ1wiLCBtb3VzZXVwcGVkLCBub25wYXNzaXZlY2FwdHVyZSk7XG4gICAgbm9kcmFnKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIG1vdXNlbW92aW5nID0gZmFsc2U7XG4gICAgbW91c2Vkb3dueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgbW91c2Vkb3dueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgZ2VzdHVyZShcInN0YXJ0XCIsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoZXZlbnQpIHtcbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XG4gICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0gbW91c2Vkb3dueCwgZHkgPSBldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNldXBwZWQoZXZlbnQpIHtcbiAgICBzZWxlY3QoZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIiwgbnVsbCk7XG4gICAgeWVzZHJhZyhldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZ2VzdHVyZXMubW91c2UoXCJlbmRcIiwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKGV2ZW50LCBkKSB7XG4gICAgaWYgKCFmaWx0ZXIuY2FsbCh0aGlzLCBldmVudCwgZCkpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmNhbGwodGhpcywgZXZlbnQsIGQpLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KHRoaXMsIGMsIGV2ZW50LCBkLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHRvdWNoZXNbaV0pKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBnZXN0dXJlKFwic3RhcnRcIiwgZXZlbnQsIHRvdWNoZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICAgIGdlc3R1cmUoXCJkcmFnXCIsIGV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKGV2ZW50KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBnZXN0dXJlKFwiZW5kXCIsIGV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVzdGFydCh0aGF0LCBjb250YWluZXIsIGV2ZW50LCBkLCBpZGVudGlmaWVyLCB0b3VjaCkge1xuICAgIHZhciBkaXNwYXRjaCA9IGxpc3RlbmVycy5jb3B5KCksXG4gICAgICAgIHAgPSBwb2ludGVyKHRvdWNoIHx8IGV2ZW50LCBjb250YWluZXIpLCBkeCwgZHksXG4gICAgICAgIHM7XG5cbiAgICBpZiAoKHMgPSBzdWJqZWN0LmNhbGwodGhhdCwgbmV3IERyYWdFdmVudChcImJlZm9yZXN0YXJ0XCIsIHtcbiAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgICB0YXJnZXQ6IGRyYWcsXG4gICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgeDogcFswXSxcbiAgICAgICAgeTogcFsxXSxcbiAgICAgICAgZHg6IDAsXG4gICAgICAgIGR5OiAwLFxuICAgICAgICBkaXNwYXRjaFxuICAgICAgfSksIGQpKSA9PSBudWxsKSByZXR1cm47XG5cbiAgICBkeCA9IHMueCAtIHBbMF0gfHwgMDtcbiAgICBkeSA9IHMueSAtIHBbMV0gfHwgMDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBnZXN0dXJlKHR5cGUsIGV2ZW50LCB0b3VjaCkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRlbnRpZmllcl0gPSBnZXN0dXJlLCBuID0gYWN0aXZlKys7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5kXCI6IGRlbGV0ZSBnZXN0dXJlc1tpZGVudGlmaWVyXSwgLS1hY3RpdmU7IC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSBcImRyYWdcIjogcCA9IHBvaW50ZXIodG91Y2ggfHwgZXZlbnQsIGNvbnRhaW5lciksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2guY2FsbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhhdCxcbiAgICAgICAgbmV3IERyYWdFdmVudCh0eXBlLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHN1YmplY3Q6IHMsXG4gICAgICAgICAgdGFyZ2V0OiBkcmFnLFxuICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgYWN0aXZlOiBuLFxuICAgICAgICAgIHg6IHBbMF0gKyBkeCxcbiAgICAgICAgICB5OiBwWzFdICsgZHksXG4gICAgICAgICAgZHg6IHBbMF0gLSBwMFswXSxcbiAgICAgICAgICBkeTogcFsxXSAtIHAwWzFdLFxuICAgICAgICAgIGRpc3BhdGNoXG4gICAgICAgIH0pLFxuICAgICAgICBkXG4gICAgICApO1xuICAgIH07XG4gIH1cblxuICBkcmFnLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogZmlsdGVyO1xuICB9O1xuXG4gIGRyYWcuY29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogY29udGFpbmVyO1xuICB9O1xuXG4gIGRyYWcuc3ViamVjdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdWJqZWN0ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBzdWJqZWN0O1xuICB9O1xuXG4gIGRyYWcudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgZHJhZy5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBkcmFnIDogdmFsdWU7XG4gIH07XG5cbiAgZHJhZy5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCBkcmFnKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIGRyYWc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnRXZlbnQodHlwZSwge1xuICBzb3VyY2VFdmVudCxcbiAgc3ViamVjdCxcbiAgdGFyZ2V0LFxuICBpZGVudGlmaWVyLFxuICBhY3RpdmUsXG4gIHgsIHksIGR4LCBkeSxcbiAgZGlzcGF0Y2hcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHt2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzb3VyY2VFdmVudDoge3ZhbHVlOiBzb3VyY2VFdmVudCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzdWJqZWN0OiB7dmFsdWU6IHN1YmplY3QsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdGFyZ2V0OiB7dmFsdWU6IHRhcmdldCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBpZGVudGlmaWVyOiB7dmFsdWU6IGlkZW50aWZpZXIsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgYWN0aXZlOiB7dmFsdWU6IGFjdGl2ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB4OiB7dmFsdWU6IHgsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgeToge3ZhbHVlOiB5LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIGR4OiB7dmFsdWU6IGR4LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIGR5OiB7dmFsdWU6IGR5LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIF86IHt2YWx1ZTogZGlzcGF0Y2h9XG4gIH0pO1xufVxuXG5EcmFnRXZlbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IHRoaXMuXy5vbi5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gIHJldHVybiB2YWx1ZSA9PT0gdGhpcy5fID8gdGhpcyA6IHZhbHVlO1xufTtcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBkcmFnfSBmcm9tIFwiLi9kcmFnLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZHJhZ0Rpc2FibGUsIHllc2RyYWcgYXMgZHJhZ0VuYWJsZX0gZnJvbSBcIi4vbm9kcmFnLmpzXCI7XG4iLCJpbXBvcnQge3NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IG5vZXZlbnQsIHtub25wYXNzaXZlY2FwdHVyZX0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fX25vc2VsZWN0ID0gcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0O1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuIiwiLy8gVGhlc2UgYXJlIHR5cGljYWxseSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggbm9ldmVudCB0byBlbnN1cmUgdGhhdCB3ZSBjYW5cbi8vIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudC5cbmV4cG9ydCBjb25zdCBub25wYXNzaXZlID0ge3Bhc3NpdmU6IGZhbHNlfTtcbmV4cG9ydCBjb25zdCBub25wYXNzaXZlY2FwdHVyZSA9IHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZX07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsInZhciBvdmVyc2hvb3QgPSAxLjcwMTU4O1xuXG5leHBvcnQgdmFyIGJhY2tJbiA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja0luKHQpIHtcbiAgICByZXR1cm4gKHQgPSArdCkgKiB0ICogKHMgKiAodCAtIDEpICsgdCk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW47XG59KShvdmVyc2hvb3QpO1xuXG5leHBvcnQgdmFyIGJhY2tPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogKCh0ICsgMSkgKiBzICsgdCkgKyAxO1xuICB9XG5cbiAgYmFja091dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tPdXQ7XG59KShvdmVyc2hvb3QpO1xuXG5leHBvcnQgdmFyIGJhY2tJbk91dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDwgMSA/IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykgOiAodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpIC8gMjtcbiAgfVxuXG4gIGJhY2tJbk91dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tJbk91dDtcbn0pKG92ZXJzaG9vdCk7XG4iLCJ2YXIgYjEgPSA0IC8gMTEsXG4gICAgYjIgPSA2IC8gMTEsXG4gICAgYjMgPSA4IC8gMTEsXG4gICAgYjQgPSAzIC8gNCxcbiAgICBiNSA9IDkgLyAxMSxcbiAgICBiNiA9IDEwIC8gMTEsXG4gICAgYjcgPSAxNSAvIDE2LFxuICAgIGI4ID0gMjEgLyAyMixcbiAgICBiOSA9IDYzIC8gNjQsXG4gICAgYjAgPSAxIC8gYjEgLyBiMTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcbiAgcmV0dXJuIDEgLSBib3VuY2VPdXQoMSAtIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gYm91bmNlT3V0KDEgLSB0KSA6IGJvdW5jZU91dCh0IC0gMSkgKyAxKSAvIDI7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY2lyY2xlSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KSA6IE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpIC8gMjtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufVxuIiwiaW1wb3J0IHt0cG10fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbnZhciB0YXUgPSAyICogTWF0aC5QSSxcbiAgICBhbXBsaXR1ZGUgPSAxLFxuICAgIHBlcmlvZCA9IDAuMztcblxuZXhwb3J0IHZhciBlbGFzdGljSW4gPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gYSAqIHRwbXQoLSgtLXQpKSAqIE1hdGguc2luKChzIC0gdCkgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNJbi5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbi5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbjtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxuZXhwb3J0IHZhciBlbGFzdGljT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAxIC0gYSAqIHRwbXQodCA9ICt0KSAqIE1hdGguc2luKCh0ICsgcykgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNPdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljT3V0LnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY091dDtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxuZXhwb3J0IHZhciBlbGFzdGljSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ID0gdCAqIDIgLSAxKSA8IDBcbiAgICAgICAgPyBhICogdHBtdCgtdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcClcbiAgICAgICAgOiAyIC0gYSAqIHRwbXQodCkgKiBNYXRoLnNpbigocyArIHQpIC8gcCkpIC8gMjtcbiAgfVxuXG4gIGVsYXN0aWNJbk91dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbk91dC5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbk91dDtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcbiIsImltcG9ydCB7dHBtdH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwSW4odCkge1xuICByZXR1cm4gdHBtdCgxIC0gK3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwT3V0KHQpIHtcbiAgcmV0dXJuIDEgLSB0cG10KHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0cG10KDEgLSB0KSA6IDIgLSB0cG10KHQgLSAxKSkgLyAyO1xufVxuIiwiZXhwb3J0IHtcbiAgbGluZWFyIGFzIGVhc2VMaW5lYXJcbn0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5cbmV4cG9ydCB7XG4gIHF1YWRJbk91dCBhcyBlYXNlUXVhZCxcbiAgcXVhZEluIGFzIGVhc2VRdWFkSW4sXG4gIHF1YWRPdXQgYXMgZWFzZVF1YWRPdXQsXG4gIHF1YWRJbk91dCBhcyBlYXNlUXVhZEluT3V0XG59IGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IHtcbiAgY3ViaWNJbk91dCBhcyBlYXNlQ3ViaWMsXG4gIGN1YmljSW4gYXMgZWFzZUN1YmljSW4sXG4gIGN1YmljT3V0IGFzIGVhc2VDdWJpY091dCxcbiAgY3ViaWNJbk91dCBhcyBlYXNlQ3ViaWNJbk91dFxufSBmcm9tIFwiLi9jdWJpYy5qc1wiO1xuXG5leHBvcnQge1xuICBwb2x5SW5PdXQgYXMgZWFzZVBvbHksXG4gIHBvbHlJbiBhcyBlYXNlUG9seUluLFxuICBwb2x5T3V0IGFzIGVhc2VQb2x5T3V0LFxuICBwb2x5SW5PdXQgYXMgZWFzZVBvbHlJbk91dFxufSBmcm9tIFwiLi9wb2x5LmpzXCI7XG5cbmV4cG9ydCB7XG4gIHNpbkluT3V0IGFzIGVhc2VTaW4sXG4gIHNpbkluIGFzIGVhc2VTaW5JbixcbiAgc2luT3V0IGFzIGVhc2VTaW5PdXQsXG4gIHNpbkluT3V0IGFzIGVhc2VTaW5Jbk91dFxufSBmcm9tIFwiLi9zaW4uanNcIjtcblxuZXhwb3J0IHtcbiAgZXhwSW5PdXQgYXMgZWFzZUV4cCxcbiAgZXhwSW4gYXMgZWFzZUV4cEluLFxuICBleHBPdXQgYXMgZWFzZUV4cE91dCxcbiAgZXhwSW5PdXQgYXMgZWFzZUV4cEluT3V0XG59IGZyb20gXCIuL2V4cC5qc1wiO1xuXG5leHBvcnQge1xuICBjaXJjbGVJbk91dCBhcyBlYXNlQ2lyY2xlLFxuICBjaXJjbGVJbiBhcyBlYXNlQ2lyY2xlSW4sXG4gIGNpcmNsZU91dCBhcyBlYXNlQ2lyY2xlT3V0LFxuICBjaXJjbGVJbk91dCBhcyBlYXNlQ2lyY2xlSW5PdXRcbn0gZnJvbSBcIi4vY2lyY2xlLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGJvdW5jZU91dCBhcyBlYXNlQm91bmNlLFxuICBib3VuY2VJbiBhcyBlYXNlQm91bmNlSW4sXG4gIGJvdW5jZU91dCBhcyBlYXNlQm91bmNlT3V0LFxuICBib3VuY2VJbk91dCBhcyBlYXNlQm91bmNlSW5PdXRcbn0gZnJvbSBcIi4vYm91bmNlLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGJhY2tJbk91dCBhcyBlYXNlQmFjayxcbiAgYmFja0luIGFzIGVhc2VCYWNrSW4sXG4gIGJhY2tPdXQgYXMgZWFzZUJhY2tPdXQsXG4gIGJhY2tJbk91dCBhcyBlYXNlQmFja0luT3V0XG59IGZyb20gXCIuL2JhY2suanNcIjtcblxuZXhwb3J0IHtcbiAgZWxhc3RpY091dCBhcyBlYXNlRWxhc3RpYyxcbiAgZWxhc3RpY0luIGFzIGVhc2VFbGFzdGljSW4sXG4gIGVsYXN0aWNPdXQgYXMgZWFzZUVsYXN0aWNPdXQsXG4gIGVsYXN0aWNJbk91dCBhcyBlYXNlRWxhc3RpY0luT3V0XG59IGZyb20gXCIuL2VsYXN0aWMuanNcIjtcbiIsImV4cG9ydCBjb25zdCBsaW5lYXIgPSB0ID0+ICt0O1xuIiwiLy8gdHBtdCBpcyB0d28gcG93ZXIgbWludXMgdGVuIHRpbWVzIHQgc2NhbGVkIHRvIFswLDFdXG5leHBvcnQgZnVuY3Rpb24gdHBtdCh4KSB7XG4gIHJldHVybiAoTWF0aC5wb3coMiwgLTEwICogeCkgLSAwLjAwMDk3NjU2MjUpICogMS4wMDA5Nzc1MTcxMDY1NDk0O1xufVxuIiwidmFyIGV4cG9uZW50ID0gMztcblxuZXhwb3J0IHZhciBwb2x5SW4gPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICB9XG5cbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW47XG59KShleHBvbmVudCk7XG5cbmV4cG9ydCB2YXIgcG9seU91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seU91dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgZSk7XG4gIH1cblxuICBwb2x5T3V0LmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5T3V0O1xufSkoZXhwb25lbnQpO1xuXG5leHBvcnQgdmFyIHBvbHlJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdyh0LCBlKSA6IDIgLSBNYXRoLnBvdygyIC0gdCwgZSkpIC8gMjtcbiAgfVxuXG4gIHBvbHlJbk91dC5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seUluT3V0O1xufSkoZXhwb25lbnQpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbih0KSB7XG4gIHJldHVybiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICByZXR1cm4gdCAqICgyIC0gdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCA6IC0tdCAqICgyIC0gdCkgKyAxKSAvIDI7XG59XG4iLCJ2YXIgcGkgPSBNYXRoLlBJLFxuICAgIGhhbGZQaSA9IHBpIC8gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuICgrdCA9PT0gMSkgPyAxIDogMSAtIE1hdGguY29zKHQgKiBoYWxmUGkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc2luKHQgKiBoYWxmUGkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luSW5PdXQodCkge1xuICByZXR1cm4gKDEgLSBNYXRoLmNvcyhwaSAqIHQpKSAvIDI7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIChpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXkgOiBnZW5lcmljQXJyYXkpKGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJpY0FycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYSksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxuICAgICAgICB2MSA9IHZhbHVlc1tpXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbaSArIDFdLFxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxuICAgICAgICB2MyA9IGkgPCBuIC0gMSA/IHZhbHVlc1tpICsgMl0gOiAyICogdjIgLSB2MTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jhc2lzfSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIHQgKiBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XG4gIHJldHVybiBhID0gTWF0aC5wb3coYSwgeSksIGIgPSBNYXRoLnBvdyhiLCB5KSAtIGEsIHkgPSAxIC8geSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhhICsgdCAqIGIsIHkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVlKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImltcG9ydCB7Y3ViZWhlbGl4IGFzIGNvbG9yQ3ViZWhlbGl4fSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gY3ViZWhlbGl4KGh1ZSkge1xuICByZXR1cm4gKGZ1bmN0aW9uIGN1YmVoZWxpeEdhbW1hKHkpIHtcbiAgICB5ID0gK3k7XG5cbiAgICBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JDdWJlaGVsaXgoc3RhcnQpKS5oLCAoZW5kID0gY29sb3JDdWJlaGVsaXgoZW5kKSkuaCksXG4gICAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcbiAgICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGN1YmVoZWxpeC5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xuXG4gICAgcmV0dXJuIGN1YmVoZWxpeDtcbiAgfSkoMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1YmVoZWxpeChodWUpO1xuZXhwb3J0IHZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4KGNvbG9yKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICogKDEgLSB0KSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG4iLCJpbXBvcnQge2hjbCBhcyBjb2xvckhjbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhjbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhjbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhjbChlbmQpKS5oKSxcbiAgICAgICAgYyA9IGNvbG9yKHN0YXJ0LmMsIGVuZC5jKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5jID0gYyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGNsKGh1ZSk7XG5leHBvcnQgdmFyIGhjbExvbmcgPSBoY2woY29sb3IpO1xuIiwiaW1wb3J0IHtoc2wgYXMgY29sb3JIc2x9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBoc2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JIc2woc3RhcnQpKS5oLCAoZW5kID0gY29sb3JIc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBjb2xvcihzdGFydC5zLCBlbmQucyksXG4gICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhzbChodWUpO1xuZXhwb3J0IHZhciBoc2xMb25nID0gaHNsKGNvbG9yKTtcbiIsImltcG9ydCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0gaHVlKCthLCArYik7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHggPSBpKHQpO1xuICAgIHJldHVybiB4IC0gMzYwICogTWF0aC5mbG9vcih4IC8gMzYwKTtcbiAgfTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUFycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURhdGV9IGZyb20gXCIuL2RhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURpc2NyZXRlfSBmcm9tIFwiLi9kaXNjcmV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHVlfSBmcm9tIFwiLi9odWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlcn0gZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU9iamVjdH0gZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcIi4vcm91bmQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5leHBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzLCBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2Z30gZnJvbSBcIi4vdHJhbnNmb3JtL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVab29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSZ2IsIHJnYkJhc2lzIGFzIGludGVycG9sYXRlUmdiQmFzaXMsIHJnYkJhc2lzQ2xvc2VkIGFzIGludGVycG9sYXRlUmdiQmFzaXNDbG9zZWR9IGZyb20gXCIuL3JnYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHNsLCBoc2xMb25nIGFzIGludGVycG9sYXRlSHNsTG9uZ30gZnJvbSBcIi4vaHNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVMYWJ9IGZyb20gXCIuL2xhYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSGNsLCBoY2xMb25nIGFzIGludGVycG9sYXRlSGNsTG9uZ30gZnJvbSBcIi4vaGNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXgsIGN1YmVoZWxpeExvbmcgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nfSBmcm9tIFwiLi9jdWJlaGVsaXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwaWVjZXdpc2V9IGZyb20gXCIuL3BpZWNld2lzZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHF1YW50aXplfSBmcm9tIFwiLi9xdWFudGl6ZS5qc1wiO1xuIiwiaW1wb3J0IHtsYWIgYXMgY29sb3JMYWJ9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yIGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gY29sb3IoKHN0YXJ0ID0gY29sb3JMYWIoc3RhcnQpKS5sLCAoZW5kID0gY29sb3JMYWIoZW5kKSkubCksXG4gICAgICBhID0gY29sb3Ioc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIGlmICghYikgYiA9IFtdO1xuICB2YXIgbiA9IGEgPyBNYXRoLm1pbihiLmxlbmd0aCwgYS5sZW5ndGgpIDogMCxcbiAgICAgIGMgPSBiLnNsaWNlKCksXG4gICAgICBpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNbaV0gPSBhW2ldICogKDEgLSB0KSArIGJbaV0gKiB0O1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJBcnJheSh4KSB7XG4gIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoeCkgJiYgISh4IGluc3RhbmNlb2YgRGF0YVZpZXcpO1xufVxuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSB2YWx1ZShhW2tdLCBiW2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1trXSA9IGJba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgdmFsdWV9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBpZWNld2lzZShpbnRlcnBvbGF0ZSwgdmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkgdmFsdWVzID0gaW50ZXJwb2xhdGUsIGludGVycG9sYXRlID0gdmFsdWU7XG4gIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGggLSAxLCB2ID0gdmFsdWVzWzBdLCBJID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIElbaV0gPSBpbnRlcnBvbGF0ZSh2LCB2ID0gdmFsdWVzWysraV0pO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqPSBuKSkpO1xuICAgIHJldHVybiBJW2ldKHQgLSBpKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVycG9sYXRvciwgbikge1xuICB2YXIgc2FtcGxlcyA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoaSAvIChuIC0gMSkpO1xuICByZXR1cm4gc2FtcGxlcztcbn1cbiIsImltcG9ydCB7cmdiIGFzIGNvbG9yUmdifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBiYXNpcyBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuaW1wb3J0IGJhc2lzQ2xvc2VkIGZyb20gXCIuL2Jhc2lzQ2xvc2VkLmpzXCI7XG5pbXBvcnQgbm9nYW1tYSwge2dhbW1hfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gcmdiR2FtbWEoeSkge1xuICB2YXIgY29sb3IgPSBnYW1tYSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gY29sb3JSZ2Ioc3RhcnQpKS5yLCAoZW5kID0gY29sb3JSZ2IoZW5kKSkuciksXG4gICAgICAgIGcgPSBjb2xvcihzdGFydC5nLCBlbmQuZyksXG4gICAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuciA9IHIodCk7XG4gICAgICBzdGFydC5nID0gZyh0KTtcbiAgICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICByZ2IuZ2FtbWEgPSByZ2JHYW1tYTtcblxuICByZXR1cm4gcmdiO1xufSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3I7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBjb2xvclJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvci5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IuciA9IHIodCk7XG4gICAgICBjb2xvci5nID0gZyh0KTtcbiAgICAgIGNvbG9yLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKGJhc2lzKTtcbmV4cG9ydCB2YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChhICogKDEgLSB0KSArIGIgKiB0KTtcbiAgfTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXG4gICAgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uZShiKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBiaSA9IHJlQS5sYXN0SW5kZXggPSByZUIubGFzdEluZGV4ID0gMCwgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYW0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICAgICAgYnMsIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gICAgICBpID0gLTEsIC8vIGluZGV4IGluIHNcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG5cbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcblxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuICB3aGlsZSAoKGFtID0gcmVBLmV4ZWMoYSkpXG4gICAgICAmJiAoYm0gPSByZUIuZXhlYyhiKSkpIHtcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHsgLy8gbnVtYmVycyBpbiBhICYgYiBtYXRjaFxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJtO1xuICAgIH0gZWxzZSB7IC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtpOiBpLCB4OiBudW1iZXIoYW0sIGJtKX0pO1xuICAgIH1cbiAgICBiaSA9IHJlQi5sYXN0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgcmVtYWlucyBvZiBiLlxuICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgZWxzZSBzWysraV0gPSBicztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgb3B0aW1pemF0aW9uIGZvciBvbmx5IGEgc2luZ2xlIG1hdGNoLlxuICAvLyBPdGhlcndpc2UsIGludGVycG9sYXRlIGVhY2ggb2YgdGhlIG51bWJlcnMgYW5kIHJlam9pbiB0aGUgc3RyaW5nLlxuICByZXR1cm4gcy5sZW5ndGggPCAyID8gKHFbMF1cbiAgICAgID8gb25lKHFbMF0ueClcbiAgICAgIDogemVybyhiKSlcbiAgICAgIDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG59XG4iLCJ2YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG5cbmV4cG9ydCB2YXIgaWRlbnRpdHkgPSB7XG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgc2tld1g6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBzY2FsZVgsIHNjYWxlWSwgc2tld1g7XG4gIGlmIChzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYikpIGEgLz0gc2NhbGVYLCBiIC89IHNjYWxlWDtcbiAgaWYgKHNrZXdYID0gYSAqIGMgKyBiICogZCkgYyAtPSBhICogc2tld1gsIGQgLT0gYiAqIHNrZXdYO1xuICBpZiAoc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpKSBjIC89IHNjYWxlWSwgZCAvPSBzY2FsZVksIHNrZXdYIC89IHNjYWxlWTtcbiAgaWYgKGEgKiBkIDwgYiAqIGMpIGEgPSAtYSwgYiA9IC1iLCBza2V3WCA9IC1za2V3WCwgc2NhbGVYID0gLXNjYWxlWDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBlLFxuICAgIHRyYW5zbGF0ZVk6IGYsXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKGIsIGEpICogZGVncmVlcyxcbiAgICBza2V3WDogTWF0aC5hdGFuKHNrZXdYKSAqIGRlZ3JlZXMsXG4gICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgc2NhbGVZOiBzY2FsZVlcbiAgfTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4uL251bWJlci5qc1wiO1xuaW1wb3J0IHtwYXJzZUNzcywgcGFyc2VTdmd9IGZyb20gXCIuL3BhcnNlLmpzXCI7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuXG4gIGZ1bmN0aW9uIHBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiIFwiIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiIHx8IHliKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB4YiArIHB4Q29tbWEgKyB5YiArIHB4UGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdGF0ZShhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIGlmIChhIC0gYiA+IDE4MCkgYiArPSAzNjA7IGVsc2UgaWYgKGIgLSBhID4gMTgwKSBhICs9IDM2MDsgLy8gc2hvcnRlc3QgcGF0aFxuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2V3WChhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiICE9PSAxIHx8IHliICE9PSAxKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiArIHhiICsgXCIsXCIgKyB5YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XG4gICAgdHJhbnNsYXRlKGEudHJhbnNsYXRlWCwgYS50cmFuc2xhdGVZLCBiLnRyYW5zbGF0ZVgsIGIudHJhbnNsYXRlWSwgcywgcSk7XG4gICAgcm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XG4gICAgc2NhbGUoYS5zY2FsZVgsIGEuc2NhbGVZLCBiLnNjYWxlWCwgYi5zY2FsZVksIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDsgLy8gZ2NcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlU3ZnLCBcIiwgXCIsIFwiKVwiLCBcIilcIik7XG4iLCJpbXBvcnQgZGVjb21wb3NlLCB7aWRlbnRpdHl9IGZyb20gXCIuL2RlY29tcG9zZS5qc1wiO1xuXG52YXIgc3ZnTm9kZTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBjb25zdCBtID0gbmV3ICh0eXBlb2YgRE9NTWF0cml4ID09PSBcImZ1bmN0aW9uXCIgPyBET01NYXRyaXggOiBXZWJLaXRDU1NNYXRyaXgpKHZhbHVlICsgXCJcIik7XG4gIHJldHVybiBtLmlzSWRlbnRpdHkgPyBpZGVudGl0eSA6IGRlY29tcG9zZShtLmEsIG0uYiwgbS5jLCBtLmQsIG0uZSwgbS5mKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3ZnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghc3ZnTm9kZSkgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdmFsdWUpO1xuICBpZiAoISh2YWx1ZSA9IHN2Z05vZGUudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkpIHJldHVybiBpZGVudGl0eTtcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XG4gIHJldHVybiBkZWNvbXBvc2UodmFsdWUuYSwgdmFsdWUuYiwgdmFsdWUuYywgdmFsdWUuZCwgdmFsdWUuZSwgdmFsdWUuZik7XG59XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCByZ2IgZnJvbSBcIi4vcmdiLmpzXCI7XG5pbXBvcnQge2dlbmVyaWNBcnJheX0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBkYXRlIGZyb20gXCIuL2RhdGUuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQgb2JqZWN0IGZyb20gXCIuL29iamVjdC5qc1wiO1xuaW1wb3J0IHN0cmluZyBmcm9tIFwiLi9zdHJpbmcuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IG51bWJlckFycmF5LCB7aXNOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgdCA9IHR5cGVvZiBiLCBjO1xuICByZXR1cm4gYiA9PSBudWxsIHx8IHQgPT09IFwiYm9vbGVhblwiID8gY29uc3RhbnQoYilcbiAgICAgIDogKHQgPT09IFwibnVtYmVyXCIgPyBudW1iZXJcbiAgICAgIDogdCA9PT0gXCJzdHJpbmdcIiA/ICgoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgcmdiKSA6IHN0cmluZylcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gcmdiXG4gICAgICA6IGIgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZVxuICAgICAgOiBpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXlcbiAgICAgIDogQXJyYXkuaXNBcnJheShiKSA/IGdlbmVyaWNBcnJheVxuICAgICAgOiB0eXBlb2YgYi52YWx1ZU9mICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIudG9TdHJpbmcgIT09IFwiZnVuY3Rpb25cIiB8fCBpc05hTihiKSA/IG9iamVjdFxuICAgICAgOiBudW1iZXIpKGEsIGIpO1xufVxuIiwidmFyIGVwc2lsb24yID0gMWUtMTI7XG5cbmZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiB6b29tUmhvKHJobywgcmhvMiwgcmhvNCkge1xuXG4gIC8vIHAwID0gW3V4MCwgdXkwLCB3MF1cbiAgLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxuICBmdW5jdGlvbiB6b29tKHAwLCBwMSkge1xuICAgIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sXG4gICAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgICAgZHggPSB1eDEgLSB1eDAsXG4gICAgICAgIGR5ID0gdXkxIC0gdXkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgICBpLFxuICAgICAgICBTO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gICAgaWYgKGQyIDwgZXBzaWxvbjIpIHtcbiAgICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdCAqIGR4LFxuICAgICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgICB3MCAqIE1hdGguZXhwKHJobyAqIHQgKiBTKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYWwgY2FzZS5cbiAgICBlbHNlIHtcbiAgICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksXG4gICAgICAgICAgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG80ICogZDIpIC8gKDIgKiB3MCAqIHJobzIgKiBkMSksXG4gICAgICAgICAgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG80ICogZDIpIC8gKDIgKiB3MSAqIHJobzIgKiBkMSksXG4gICAgICAgICAgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLFxuICAgICAgICAgIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICAgIFMgPSAocjEgLSByMCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcyA9IHQgKiBTLFxuICAgICAgICAgICAgY29zaHIwID0gY29zaChyMCksXG4gICAgICAgICAgICB1ID0gdzAgLyAocmhvMiAqIGQxKSAqIChjb3NocjAgKiB0YW5oKHJobyAqIHMgKyByMCkgLSBzaW5oKHIwKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdSAqIGR4LFxuICAgICAgICAgIHV5MCArIHUgKiBkeSxcbiAgICAgICAgICB3MCAqIGNvc2hyMCAvIGNvc2gocmhvICogcyArIHIwKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkuZHVyYXRpb24gPSBTICogMTAwMCAqIHJobyAvIE1hdGguU1FSVDI7XG5cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIHpvb20ucmhvID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBfMSA9IE1hdGgubWF4KDFlLTMsICtfKSwgXzIgPSBfMSAqIF8xLCBfNCA9IF8yICogXzI7XG4gICAgcmV0dXJuIHpvb21SaG8oXzEsIF8yLCBfNCk7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59KShNYXRoLlNRUlQyLCAyLCA0KTtcbiIsIi8vIEdpdmVuIHNvbWV0aGluZyBhcnJheSBsaWtlIChvciBudWxsKSwgcmV0dXJucyBzb21ldGhpbmcgdGhhdCBpcyBzdHJpY3RseSBhblxuLy8gYXJyYXkuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBhcnJheS1saWtlIG9iamVjdHMgcGFzc2VkIHRvIGQzLnNlbGVjdEFsbFxuLy8gb3Igc2VsZWN0aW9uLnNlbGVjdEFsbCBhcmUgY29udmVydGVkIGludG8gcHJvcGVyIGFycmF5cyB3aGVuIGNyZWF0aW5nIGFcbi8vIHNlbGVjdGlvbjsgd2UgZG9u4oCZdCBldmVyIHdhbnQgdG8gY3JlYXRlIGEgc2VsZWN0aW9uIGJhY2tlZCBieSBhIGxpdmVcbi8vIEhUTUxDb2xsZWN0aW9uIG9yIE5vZGVMaXN0LiBIb3dldmVyLCBub3RlIHRoYXQgc2VsZWN0aW9uLnNlbGVjdEFsbCB3aWxsIHVzZSBhXG4vLyBzdGF0aWMgTm9kZUxpc3QgYXMgYSBncm91cCwgc2luY2UgaXQgc2FmZWx5IGRlcml2ZWQgZnJvbSBxdWVyeVNlbGVjdG9yQWxsLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJyYXkoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gW10gOiBBcnJheS5pc0FycmF5KHgpID8geCA6IEFycmF5LmZyb20oeCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdChjcmVhdG9yKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuL25hbWVzcGFjZS5qc1wiO1xuaW1wb3J0IHt4aHRtbH0gZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICA/IGNyZWF0b3JGaXhlZFxuICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0ZX0gZnJvbSBcIi4vY3JlYXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3JlYXRvcn0gZnJvbSBcIi4vY3JlYXRvci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGxvY2FsfSBmcm9tIFwiLi9sb2NhbC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1hdGNoZXJ9IGZyb20gXCIuL21hdGNoZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2V9IGZyb20gXCIuL25hbWVzcGFjZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5hbWVzcGFjZXN9IGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwb2ludGVyfSBmcm9tIFwiLi9wb2ludGVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcG9pbnRlcnN9IGZyb20gXCIuL3BvaW50ZXJzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0fSBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RBbGx9IGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdGlvbn0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3J9IGZyb20gXCIuL3NlbGVjdG9yLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3JBbGx9IGZyb20gXCIuL3NlbGVjdG9yQWxsLmpzXCI7XG5leHBvcnQge3N0eWxlVmFsdWUgYXMgc3R5bGV9IGZyb20gXCIuL3NlbGVjdGlvbi9zdHlsZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHdpbmRvd30gZnJvbSBcIi4vd2luZG93LmpzXCI7XG4iLCJ2YXIgbmV4dElkID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9jYWwoKSB7XG4gIHJldHVybiBuZXcgTG9jYWw7XG59XG5cbmZ1bmN0aW9uIExvY2FsKCkge1xuICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xufVxuXG5Mb2NhbC5wcm90b3R5cGUgPSBsb2NhbC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMb2NhbCxcbiAgZ2V0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fO1xuICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgIHJldHVybiBub2RlW2lkXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiBub2RlW3RoaXMuX10gPSB2YWx1ZTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuXyBpbiBub2RlICYmIGRlbGV0ZSBub2RlW3RoaXMuX107XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRNYXRjaGVyKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbiIsImltcG9ydCBuYW1lc3BhY2VzIGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xuICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbn1cbiIsImV4cG9ydCB2YXIgeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCwgbm9kZSkge1xuICBldmVudCA9IHNvdXJjZUV2ZW50KGV2ZW50KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG4gICAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICAgIH1cbiAgICBpZiAobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV07XG59XG4iLCJpbXBvcnQgcG9pbnRlciBmcm9tIFwiLi9wb2ludGVyLmpzXCI7XG5pbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnRzLCBub2RlKSB7XG4gIGlmIChldmVudHMudGFyZ2V0KSB7IC8vIGkuZS4sIGluc3RhbmNlb2YgRXZlbnQsIG5vdCBUb3VjaExpc3Qgb3IgaXRlcmFibGVcbiAgICBldmVudHMgPSBzb3VyY2VFdmVudChldmVudHMpO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIG5vZGUgPSBldmVudHMuY3VycmVudFRhcmdldDtcbiAgICBldmVudHMgPSBldmVudHMudG91Y2hlcyB8fCBbZXZlbnRzXTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShldmVudHMsIGV2ZW50ID0+IHBvaW50ZXIoZXZlbnQsIG5vZGUpKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW2FycmF5KHNlbGVjdG9yKV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4uL25hbWVzcGFjZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59XG4iLCJmdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZShmYWxzZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgTWFwLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSArIFwiXCI7XG4gICAgICBpZiAobm9kZUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlKSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSkgKyBcIlwiO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlKSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWUuZGVsZXRlKGtleVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWVzW2ldKSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXR1bShub2RlKSB7XG4gIHJldHVybiBub2RlLl9fZGF0YV9fO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIEFycmF5LmZyb20odGhpcywgZGF0dW0pO1xuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IGFycmF5bGlrZSh2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cykpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gR2l2ZW4gc29tZSBkYXRhLCB0aGlzIHJldHVybnMgYW4gYXJyYXktbGlrZSB2aWV3IG9mIGl0OiBhbiBvYmplY3QgdGhhdFxuLy8gZXhwb3NlcyBhIGxlbmd0aCBwcm9wZXJ0eSBhbmQgYWxsb3dzIG51bWVyaWMgaW5kZXhpbmcuIE5vdGUgdGhhdCB1bmxpa2Vcbi8vIHNlbGVjdEFsbCwgdGhpcyBpc27igJl0IHdvcnJpZWQgYWJvdXQg4oCcbGl2ZeKAnSBjb2xsZWN0aW9ucyBiZWNhdXNlIHRoZSByZXN1bHRpbmdcbi8vIGFycmF5IHdpbGwgb25seSBiZSB1c2VkIGJyaWVmbHkgd2hpbGUgZGF0YSBpcyBiZWluZyBib3VuZC4gKEl0IGlzIHBvc3NpYmxlIHRvXG4vLyBjYXVzZSB0aGUgZGF0YSB0byBjaGFuZ2Ugd2hpbGUgaXRlcmF0aW5nIGJ5IHVzaW5nIGEga2V5IGZ1bmN0aW9uLCBidXQgcGxlYXNlXG4vLyBkb27igJl0OyB3ZeKAmWQgcmF0aGVyIGF2b2lkIGEgZ3JhdHVpdG91cyBjb3B5LilcbmZ1bmN0aW9uIGFycmF5bGlrZShkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGRhdGFcbiAgICA/IGRhdGEgLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKGRhdGEpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJmdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cbiIsImltcG9ydCBzZWxlY3Rpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkIGZyb20gXCIuL3NlbGVjdENoaWxkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuIGZyb20gXCIuL3NlbGVjdENoaWxkcmVuLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VudGVyIGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2V4aXQgZnJvbSBcIi4vZXhpdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9qb2luIGZyb20gXCIuL2pvaW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb3JkZXIgZnJvbSBcIi4vb3JkZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc29ydCBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NhbGwgZnJvbSBcIi4vY2FsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlcyBmcm9tIFwiLi9ub2Rlcy5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlIGZyb20gXCIuL25vZGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VtcHR5IGZyb20gXCIuL2VtcHR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VhY2ggZnJvbSBcIi4vZWFjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcHJvcGVydHkgZnJvbSBcIi4vcHJvcGVydHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xhc3NlZCBmcm9tIFwiLi9jbGFzc2VkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9odG1sIGZyb20gXCIuL2h0bWwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmFpc2UgZnJvbSBcIi4vcmFpc2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbG93ZXIgZnJvbSBcIi4vbG93ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXBwZW5kIGZyb20gXCIuL2FwcGVuZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnNlcnQgZnJvbSBcIi4vaW5zZXJ0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xvbmUgZnJvbSBcIi4vY2xvbmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0dW0gZnJvbSBcIi4vZGF0dW0uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGlzcGF0Y2ggZnJvbSBcIi4vZGlzcGF0Y2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3IuanNcIjtcblxuZXhwb3J0IHZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gIHNlbGVjdDogc2VsZWN0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiBzZWxlY3Rpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3NlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gIGRhdGE6IHNlbGVjdGlvbl9kYXRhLFxuICBlbnRlcjogc2VsZWN0aW9uX2VudGVyLFxuICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgam9pbjogc2VsZWN0aW9uX2pvaW4sXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogc2VsZWN0aW9uX3NlbGVjdGlvbixcbiAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gIGNhbGw6IHNlbGVjdGlvbl9jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3NpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICBhdHRyOiBzZWxlY3Rpb25fYXR0cixcbiAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgY2xhc3NlZDogc2VsZWN0aW9uX2NsYXNzZWQsXG4gIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgcmFpc2U6IHNlbGVjdGlvbl9yYWlzZSxcbiAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICBpbnNlcnQ6IHNlbGVjdGlvbl9pbnNlcnQsXG4gIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcbiAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgb246IHNlbGVjdGlvbl9vbixcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9pdGVyYXRvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VsZWN0aW9uO1xuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKigpIHtcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbmVudGVyLCBvbnVwZGF0ZSwgb25leGl0KSB7XG4gIHZhciBlbnRlciA9IHRoaXMuZW50ZXIoKSwgdXBkYXRlID0gdGhpcywgZXhpdCA9IHRoaXMuZXhpdCgpO1xuICBpZiAodHlwZW9mIG9uZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVudGVyID0gb25lbnRlcihlbnRlcik7XG4gICAgaWYgKGVudGVyKSBlbnRlciA9IGVudGVyLnNlbGVjdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGVudGVyID0gZW50ZXIuYXBwZW5kKG9uZW50ZXIgKyBcIlwiKTtcbiAgfVxuICBpZiAob251cGRhdGUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZSA9IG9udXBkYXRlKHVwZGF0ZSk7XG4gICAgaWYgKHVwZGF0ZSkgdXBkYXRlID0gdXBkYXRlLnNlbGVjdGlvbigpO1xuICB9XG4gIGlmIChvbmV4aXQgPT0gbnVsbCkgZXhpdC5yZW1vdmUoKTsgZWxzZSBvbmV4aXQoZXhpdCk7XG4gIHJldHVybiBlbnRlciAmJiB1cGRhdGUgPyBlbnRlci5tZXJnZSh1cGRhdGUpLm9yZGVyKCkgOiB1cGRhdGU7XG59XG4iLCJmdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQ7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG59XG4iLCJmdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCwgdGhpcy5fX2RhdGFfXyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIodmFsdWUpO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8ub3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBvcHRpb25zOiBvcHRpb25zfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBvcHRpb25zKSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgaWYgKG5leHQgJiYgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuZXh0KSBeIDQpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XG59XG4iLCJmdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi4vYXJyYXkuanNcIjtcbmltcG9ydCBzZWxlY3RvckFsbCBmcm9tIFwiLi4vc2VsZWN0b3JBbGwuanNcIjtcblxuZnVuY3Rpb24gYXJyYXlBbGwoc2VsZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJyYXkoc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgPT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gYXJyYXlBbGwoc2VsZWN0KTtcbiAgZWxzZSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQ7XG5cbmZ1bmN0aW9uIGNoaWxkRmluZChtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbmQuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoaWxkRmlyc3QoKSB7XG4gIHJldHVybiB0aGlzLmZpcnN0RWxlbWVudENoaWxkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QobWF0Y2ggPT0gbnVsbCA/IGNoaWxkRmlyc3RcbiAgICAgIDogY2hpbGRGaW5kKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5cbmZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5GaWx0ZXIobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdEFsbChtYXRjaCA9PSBudWxsID8gY2hpbGRyZW5cbiAgICAgIDogY2hpbGRyZW5GaWx0ZXIodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSArK3NpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG59XG4iLCJmdW5jdGlvbiBub25lKCkge31cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJmdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBsZXQgc291cmNlRXZlbnQ7XG4gIHdoaWxlIChzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50KSBldmVudCA9IHNvdXJjZUV2ZW50O1xuICByZXR1cm4gZXZlbnQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuIiwiZXhwb3J0IHtcbiAgbm93LFxuICB0aW1lcixcbiAgdGltZXJGbHVzaFxufSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHRpbWVvdXRcbn0gZnJvbSBcIi4vdGltZW91dC5qc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIGludGVydmFsXG59IGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG4iLCJpbXBvcnQge1RpbWVyLCBub3d9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lciwgdG90YWwgPSBkZWxheTtcbiAgaWYgKGRlbGF5ID09IG51bGwpIHJldHVybiB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSwgdDtcbiAgdC5fcmVzdGFydCA9IHQucmVzdGFydDtcbiAgdC5yZXN0YXJ0ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgZGVsYXkgPSArZGVsYXksIHRpbWUgPSB0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lO1xuICAgIHQuX3Jlc3RhcnQoZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgICAgdC5fcmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgICB9LCBkZWxheSwgdGltZSk7XG4gIH1cbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwiaW1wb3J0IHtUaW1lcn0gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZWxhcHNlZCA9PiB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsInZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwodW5kZWZpbmVkLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7U0NIRURVTEVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbnZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgaTtcblxuICBpZiAoc2NoZWR1bGVzKSB7XG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5zdGF0ZSA+IFNDSEVEVUxFRCAmJiBzY2hlZHVsZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYWN0aXZlfSBmcm9tIFwiLi9hY3RpdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnJ1cHR9IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuIiwiaW1wb3J0IHtTVEFSVElORywgRU5ESU5HLCBFTkRFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcblxuICBpZiAoIXNjaGVkdWxlcykgcmV0dXJuO1xuXG4gIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG5cbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLm5hbWUgIT09IG5hbWUpIHsgZW1wdHkgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBhY3RpdmUgPSBzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HICYmIHNjaGVkdWxlLnN0YXRlIDwgRU5ESU5HO1xuICAgIHNjaGVkdWxlLnN0YXRlID0gRU5ERUQ7XG4gICAgc2NoZWR1bGUudGltZXIuc3RvcCgpO1xuICAgIHNjaGVkdWxlLm9uLmNhbGwoYWN0aXZlID8gXCJpbnRlcnJ1cHRcIiA6IFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlLmluZGV4LCBzY2hlZHVsZS5ncm91cCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgfVxuXG4gIGlmIChlbXB0eSkgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBzZWxlY3Rpb25faW50ZXJydXB0IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcblxuc2VsZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBzZWxlY3Rpb25faW50ZXJydXB0O1xuc2VsZWN0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uID0gc2VsZWN0aW9uX3RyYW5zaXRpb247XG4iLCJpbXBvcnQgaW50ZXJydXB0IGZyb20gXCIuLi9pbnRlcnJ1cHQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlIGZyb20gXCIuLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge2Vhc2VDdWJpY0luT3V0fSBmcm9tIFwiZDMtZWFzZVwiO1xuaW1wb3J0IHtub3d9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGVhc2VDdWJpY0luT3V0XG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG4gIHdoaWxlICghKHRpbWluZyA9IG5vZGUuX190cmFuc2l0aW9uKSB8fCAhKHRpbWluZyA9IHRpbWluZ1tpZF0pKSB7XG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNpdGlvbiAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IG5vdygpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGksIGdyb3VwLCB0aW1pbmcgfHwgaW5oZXJpdChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pKGZ1bGxuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdmFsdWUgPT0gbnVsbCA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIGksIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlKG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJhdHRyLlwiICsgbmFtZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtnZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGRlbGF5RnVuY3Rpb25cbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGR1cmF0aW9uRnVuY3Rpb25cbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZVZhcnlpbmcoaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMuZWFjaChlYXNlVmFyeWluZyh0aGlzLl9pZCwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG9uMCwgb24xLCB0aGF0ID0gdGhpcywgaWQgPSB0aGF0Ll9pZCwgc2l6ZSA9IHRoYXQuc2l6ZSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGNhbmNlbCA9IHt2YWx1ZTogcmVqZWN0fSxcbiAgICAgICAgZW5kID0ge3ZhbHVlOiBmdW5jdGlvbigpIHsgaWYgKC0tc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpOyB9fTtcblxuICAgIHRoYXQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICAgIGlmIChvbiAhPT0gb24wKSB7XG4gICAgICAgIG9uMSA9IChvbjAgPSBvbikuY29weSgpO1xuICAgICAgICBvbjEuXy5jYW5jZWwucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5pbnRlcnJ1cHQucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5lbmQucHVzaChlbmQpO1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBzZWxlY3Rpb24gd2FzIGVtcHR5LCByZXNvbHZlIGVuZCBpbW1lZGlhdGVseVxuICAgIGlmIChzaXplID09PSAwKSByZXNvbHZlKCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHttYXRjaGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyVHdlZW4gZnJvbSBcIi4vYXR0clR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kZWxheSBmcm9tIFwiLi9kZWxheS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2UgZnJvbSBcIi4vZWFzZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcgZnJvbSBcIi4vZWFzZVZhcnlpbmcuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0aW9uIGZyb20gXCIuL3NlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gZnJvbSBcIi4vc3R5bGVUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0VHdlZW4gZnJvbSBcIi4vdGV4dFR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3R3ZWVuIGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lbmQgZnJvbSBcIi4vZW5kLmpzXCI7XG5cbnZhciBpZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0aW9uKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHRyYW5zaXRpb25fZmlsdGVyLFxuICBtZXJnZTogdHJhbnNpdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiB0cmFuc2l0aW9uX3NlbGVjdGlvbixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbl90cmFuc2l0aW9uLFxuICBjYWxsOiBzZWxlY3Rpb25fcHJvdG90eXBlLmNhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9wcm90b3R5cGUuZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9wcm90b3R5cGUuZWFjaCxcbiAgb246IHRyYW5zaXRpb25fb24sXG4gIGF0dHI6IHRyYW5zaXRpb25fYXR0cixcbiAgYXR0clR3ZWVuOiB0cmFuc2l0aW9uX2F0dHJUd2VlbixcbiAgc3R5bGU6IHRyYW5zaXRpb25fc3R5bGUsXG4gIHN0eWxlVHdlZW46IHRyYW5zaXRpb25fc3R5bGVUd2VlbixcbiAgdGV4dDogdHJhbnNpdGlvbl90ZXh0LFxuICB0ZXh0VHdlZW46IHRyYW5zaXRpb25fdGV4dFR3ZWVuLFxuICByZW1vdmU6IHRyYW5zaXRpb25fcmVtb3ZlLFxuICB0d2VlbjogdHJhbnNpdGlvbl90d2VlbixcbiAgZGVsYXk6IHRyYW5zaXRpb25fZGVsYXksXG4gIGR1cmF0aW9uOiB0cmFuc2l0aW9uX2R1cmF0aW9uLFxuICBlYXNlOiB0cmFuc2l0aW9uX2Vhc2UsXG4gIGVhc2VWYXJ5aW5nOiB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nLFxuICBlbmQ6IHRyYW5zaXRpb25fZW5kLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX3Byb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdXG59O1xuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQge2ludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVTdHJpbmd9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIGludGVycG9sYXRlUmdiKVxuICAgICAgOiBpbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgaWYgKHRyYW5zaXRpb24uX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSB0cmFuc2l0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcbiAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKS5ldmVyeShmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lciwgdGltZW91dH0gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbmV4cG9ydCB2YXIgQ1JFQVRFRCA9IDA7XG5leHBvcnQgdmFyIFNDSEVEVUxFRCA9IDE7XG5leHBvcnQgdmFyIFNUQVJUSU5HID0gMjtcbmV4cG9ydCB2YXIgU1RBUlRFRCA9IDM7XG5leHBvcnQgdmFyIFJVTk5JTkcgPSA0O1xuZXhwb3J0IHZhciBFTkRJTkcgPSA1O1xuZXhwb3J0IHZhciBFTkRFRCA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGVzKSBub2RlLl9fdHJhbnNpdGlvbiA9IHt9O1xuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBncm91cDogZ3JvdXAsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBvbjogZW1wdHlPbixcbiAgICB0d2VlbjogZW1wdHlUd2VlbixcbiAgICB0aW1lOiB0aW1pbmcudGltZSxcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxuICAgIGR1cmF0aW9uOiB0aW1pbmcuZHVyYXRpb24sXG4gICAgZWFzZTogdGltaW5nLmVhc2UsXG4gICAgdGltZXI6IG51bGwsXG4gICAgc3RhdGU6IENSRUFURURcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSB0aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobm9kZSwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHtzZWxlY3Rvcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3RvckFsbH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG52YXIgU2VsZWN0aW9uID0gc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c3R5bGV9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlTnVsbChuYW1lLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHN0cmluZzEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCBzdHJpbmcxMCA9IHN0cmluZzEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpLFxuICAgICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHN0cmluZzEgPSB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVNYXliZVJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgb24wLCBvbjEsIGxpc3RlbmVyMCwga2V5ID0gXCJzdHlsZS5cIiArIG5hbWUsIGV2ZW50ID0gXCJlbmQuXCIgKyBrZXksIHJlbW92ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub24sXG4gICAgICAgIGxpc3RlbmVyID0gc2NoZWR1bGUudmFsdWVba2V5XSA9PSBudWxsID8gcmVtb3ZlIHx8IChyZW1vdmUgPSBzdHlsZVJlbW92ZShuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjAgfHwgbGlzdGVuZXIwICE9PSBsaXN0ZW5lcikgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihldmVudCwgbGlzdGVuZXIwID0gbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZU51bGwobmFtZSwgaSkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZShuYW1lKSlcbiAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpKVxuICAgICAgLmVhY2goc3R5bGVNYXliZVJlbW92ZSh0aGlzLl9pZCwgbmFtZSkpXG4gICAgOiB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlKSwgcHJpb3JpdHkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBudWxsKTtcbn1cbiIsImZ1bmN0aW9uIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkuY2FsbCh0aGlzLCB0KSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgdCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQgPSAoaTAgPSBpKSAmJiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cbiIsImltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24odHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxuICAgICAgOiB0ZXh0Q29uc3RhbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCIpKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRJbnRlcnBvbGF0ZShpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGkuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgdGV4dEludGVycG9sYXRlKGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJ0ZXh0XCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCB0ZXh0VHdlZW4odmFsdWUpKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gdHdlZW5SZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9IHR3ZWVuMCA9IHR3ZWVuO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFpvb21FdmVudCh0eXBlLCB7XG4gIHNvdXJjZUV2ZW50LFxuICB0YXJnZXQsXG4gIHRyYW5zZm9ybSxcbiAgZGlzcGF0Y2hcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHt2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzb3VyY2VFdmVudDoge3ZhbHVlOiBzb3VyY2VFdmVudCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0YXJnZXQ6IHt2YWx1ZTogdGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRyYW5zZm9ybToge3ZhbHVlOiB0cmFuc2Zvcm0sIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgXzoge3ZhbHVlOiBkaXNwYXRjaH1cbiAgfSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgem9vbX0gZnJvbSBcIi4vem9vbS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHpvb21UcmFuc2Zvcm0sIGlkZW50aXR5IGFzIHpvb21JZGVudGl0eSwgVHJhbnNmb3JtIGFzIFpvb21UcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCk7XG5cbnRyYW5zZm9ybS5wcm90b3R5cGUgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX196b29tKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuIGlkZW50aXR5O1xuICByZXR1cm4gbm9kZS5fX3pvb207XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7ZHJhZ0Rpc2FibGUsIGRyYWdFbmFibGV9IGZyb20gXCJkMy1kcmFnXCI7XG5pbXBvcnQge2ludGVycG9sYXRlWm9vbX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3NlbGVjdCwgcG9pbnRlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtpbnRlcnJ1cHR9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBab29tRXZlbnQgZnJvbSBcIi4vZXZlbnQuanNcIjtcbmltcG9ydCB7VHJhbnNmb3JtLCBpZGVudGl0eX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG4vLyBleGNlcHQgZm9yIHBpbmNoLXRvLXpvb20sIHdoaWNoIGlzIHNlbnQgYXMgYSB3aGVlbCtjdHJsS2V5IGV2ZW50XG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICBpZiAoZS5oYXNBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpKSB7XG4gICAgICBlID0gZS52aWV3Qm94LmJhc2VWYWw7XG4gICAgICByZXR1cm4gW1tlLngsIGUueV0sIFtlLnggKyBlLndpZHRoLCBlLnkgKyBlLmhlaWdodF1dO1xuICAgIH1cbiAgICByZXR1cm4gW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbZS5jbGllbnRXaWR0aCwgZS5jbGllbnRIZWlnaHRdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YShldmVudCkge1xuICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIChldmVudC5jdHJsS2V5ID8gMTAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzBdLFxuICAgICAgZHgxID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzFdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVswXSxcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXG4gICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzFdO1xuICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZShcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgZHkxID4gZHkwID8gKGR5MCArIGR5MSkgLyAyIDogTWF0aC5taW4oMCwgZHkwKSB8fCBNYXRoLm1heCgwLCBkeTEpXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBjb25zdHJhaW4gPSBkZWZhdWx0Q29uc3RyYWluLFxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IFtbLUluZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIEluZmluaXR5XV0sXG4gICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVab29tLFxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hmaXJzdCxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgdG91Y2hEZWxheSA9IDUwMCxcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDAsXG4gICAgICB0YXBEaXN0YW5jZSA9IDEwO1xuXG4gIGZ1bmN0aW9uIHpvb20oc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKVxuICAgICAgICAub24oXCJ3aGVlbC56b29tXCIsIHdoZWVsZWQsIHtwYXNzaXZlOiBmYWxzZX0pXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlZG93bmVkKVxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuem9vbSB0b3VjaGNhbmNlbC56b29tXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICB6b29tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmludGVycnVwdCgpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGdlc3R1cmUodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIC5ldmVudChldmVudClcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC56b29tKG51bGwsIHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdHJhbnNmb3JtKVxuICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS5zY2FsZVRvKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gazAgKiBrMTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS5zY2FsZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwLFxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0aGlzLl9fem9vbS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB4LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeVxuICAgICAgKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgbnVsbCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcDtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHAwWzBdLCBwMFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyAteC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyAteS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXlcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgaykge1xuICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIGspKTtcbiAgICByZXR1cm4gayA9PT0gdHJhbnNmb3JtLmsgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKGssIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBwMCwgcDEpIHtcbiAgICB2YXIgeCA9IHAwWzBdIC0gcDFbMF0gKiB0cmFuc2Zvcm0uaywgeSA9IHAwWzFdIC0gcDFbMV0gKiB0cmFuc2Zvcm0uaztcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtLnggJiYgeSA9PT0gdHJhbnNmb3JtLnkgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybS5rLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGV4dGVudCkge1xuICAgIHJldHVybiBbKCtleHRlbnRbMF1bMF0gKyArZXh0ZW50WzFdWzBdKSAvIDIsICgrZXh0ZW50WzBdWzFdICsgK2V4dGVudFsxXVsxXSkgLyAyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLnN0YXJ0KCk7IH0pXG4gICAgICAgIC5vbihcImludGVycnVwdC56b29tIGVuZC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLmVuZCgpOyB9KVxuICAgICAgICAudHdlZW4oXCJ6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZyA9IGdlc3R1cmUodGhhdCwgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gcG9pbnQgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHBvaW50ID09PSBcImZ1bmN0aW9uXCIgPyBwb2ludC5hcHBseSh0aGF0LCBhcmdzKSA6IHBvaW50LFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX3pvb21pbmcpIHx8IG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB0aGlzLnNvdXJjZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB0aGlzLnRhcHMgPSAwO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgZXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHRoaXMuc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy50aGF0Ll9fem9vbWluZyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aGF0Ll9fem9vbWluZztcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgZCA9IHNlbGVjdCh0aGlzLnRoYXQpLmRhdHVtKCk7XG4gICAgICBsaXN0ZW5lcnMuY2FsbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy50aGF0LFxuICAgICAgICBuZXcgWm9vbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogdGhpcy5zb3VyY2VFdmVudCxcbiAgICAgICAgICB0YXJnZXQ6IHpvb20sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMudGhhdC5fX3pvb20sXG4gICAgICAgICAgZGlzcGF0Y2g6IGxpc3RlbmVyc1xuICAgICAgICB9KSxcbiAgICAgICAgZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gd2hlZWxlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQpO1xuXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSByZWNlbnQgd2hlZWwgZXZlbnRzLCByZXNldCB0aGUgd2hlZWwgaWRsZSB0aW1lb3V0LlxuICAgIGlmIChnLndoZWVsKSB7XG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XG4gICAgICAgIGcubW91c2VbMV0gPSB0LmludmVydChnLm1vdXNlWzBdID0gcCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXG4gICAgZWxzZSBpZiAodC5rID09PSBrKSByZXR1cm47XG5cbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXG4gICAgZWxzZSB7XG4gICAgICBnLm1vdXNlID0gW3AsIHQuaW52ZXJ0KHApXTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBnLndoZWVsID0gc2V0VGltZW91dCh3aGVlbGlkbGVkLCB3aGVlbERlbGF5KTtcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIHRydWUpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdiA9IHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksXG4gICAgICAgIHgwID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBldmVudC5jbGllbnRZO1xuXG4gICAgZHJhZ0Rpc2FibGUoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKGV2ZW50KSB7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuZXZlbnQoZXZlbnQpXG4gICAgICAgLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKGcudGhhdC5fX3pvb20sIGcubW91c2VbMF0gPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwcGVkKGV2ZW50KSB7XG4gICAgICB2Lm9uKFwibW91c2Vtb3ZlLnpvb20gbW91c2V1cC56b29tXCIsIG51bGwpO1xuICAgICAgZHJhZ0VuYWJsZShldmVudC52aWV3LCBnLm1vdmVkKTtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgZy5ldmVudChldmVudCkuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBwb2ludGVyKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCwgdGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGV2ZW50LnNoaWZ0S2V5ID8gMC41IDogMiksXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJncyksIHRyYW5zbGF0ZUV4dGVudCk7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHNjaGVkdWxlLCB0MSwgcDAsIGV2ZW50KTtcbiAgICBlbHNlIHNlbGVjdCh0aGlzKS5jYWxsKHpvb20udHJhbnNmb3JtLCB0MSwgcDAsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSBuKS5ldmVudChldmVudCksXG4gICAgICAgIHN0YXJ0ZWQsIGksIHQsIHA7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBwID0gW3AsIHRoaXMuX196b29tLmludmVydChwKSwgdC5pZGVudGlmaWVyXTtcbiAgICAgIGlmICghZy50b3VjaDApIGcudG91Y2gwID0gcCwgc3RhcnRlZCA9IHRydWUsIGcudGFwcyA9IDEgKyAhIXRvdWNoc3RhcnRpbmc7XG4gICAgICBlbHNlIGlmICghZy50b3VjaDEgJiYgZy50b3VjaDBbMl0gIT09IHBbMl0pIGcudG91Y2gxID0gcCwgZy50YXBzID0gMDtcbiAgICB9XG5cbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICBpZiAoZy50YXBzIDwgMikgdG91Y2hmaXJzdCA9IHBbMF0sIHRvdWNoc3RhcnRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaHN0YXJ0aW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdCwgcCwgbDtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMFswXSA9IHA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMVswXSA9IHA7XG4gICAgfVxuICAgIHQgPSBnLnRoYXQuX196b29tO1xuICAgIGlmIChnLnRvdWNoMSkge1xuICAgICAgdmFyIHAwID0gZy50b3VjaDBbMF0sIGwwID0gZy50b3VjaDBbMV0sXG4gICAgICAgICAgcDEgPSBnLnRvdWNoMVswXSwgbDEgPSBnLnRvdWNoMVsxXSxcbiAgICAgICAgICBkcCA9IChkcCA9IHAxWzBdIC0gcDBbMF0pICogZHAgKyAoZHAgPSBwMVsxXSAtIHAwWzFdKSAqIGRwLFxuICAgICAgICAgIGRsID0gKGRsID0gbDFbMF0gLSBsMFswXSkgKiBkbCArIChkbCA9IGwxWzFdIC0gbDBbMV0pICogZGw7XG4gICAgICB0ID0gc2NhbGUodCwgTWF0aC5zcXJ0KGRwIC8gZGwpKTtcbiAgICAgIHAgPSBbKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMl07XG4gICAgICBsID0gWyhsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChnLnRvdWNoMCkgcCA9IGcudG91Y2gwWzBdLCBsID0gZy50b3VjaDBbMV07XG4gICAgZWxzZSByZXR1cm47XG5cbiAgICBnLnpvb20oXCJ0b3VjaFwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHQsIHAsIGwpLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDE7XG4gICAgfVxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICBpZiAoZy50b3VjaDApIGcudG91Y2gwWzFdID0gdGhpcy5fX3pvb20uaW52ZXJ0KGcudG91Y2gwWzBdKTtcbiAgICBlbHNlIHtcbiAgICAgIGcuZW5kKCk7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhIGRibHRhcCwgcmVyb3V0ZSB0byB0aGUgKG9wdGlvbmFsKSBkYmxjbGljay56b29tIGhhbmRsZXIuXG4gICAgICBpZiAoZy50YXBzID09PSAyKSB7XG4gICAgICAgIHQgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgICBpZiAoTWF0aC5oeXBvdCh0b3VjaGZpcnN0WzBdIC0gdFswXSwgdG91Y2hmaXJzdFsxXSAtIHRbMV0pIDwgdGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICB2YXIgcCA9IHNlbGVjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIik7XG4gICAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHpvb20ud2hlZWxEZWx0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3aGVlbERlbHRhID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHpvb20pIDogd2hlZWxEZWx0YTtcbiAgfTtcblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgem9vbS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSksIHpvb20pIDogZXh0ZW50O1xuICB9O1xuXG4gIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGVFeHRlbnRbMF1bMF0gPSArX1swXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzBdID0gK19bMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXSA9ICtfWzBdWzFdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV0gPSArX1sxXVsxXSwgem9vbSkgOiBbW3RyYW5zbGF0ZUV4dGVudFswXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdXSwgW3RyYW5zbGF0ZUV4dGVudFsxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdXV07XG4gIH07XG5cbiAgem9vbS5jb25zdHJhaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uc3RyYWluID0gXywgem9vbSkgOiBjb25zdHJhaW47XG4gIH07XG5cbiAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xuICB9O1xuXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCB6b29tKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHpvb20ub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xuICB9O1xuXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgem9vbSkgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHpvb20udGFwRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFwRGlzdGFuY2UgPSArXywgem9vbSkgOiB0YXBEaXN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn1cbiIsIi8qKlxuICogSlNUUy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FREx2MS50eHRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FUEx2MS50eHRcbiAqIEBsaWNlbnNlXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUoKHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5qc3RzPXt9KX0odGhpcywoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgZXtzdGF0aWMgZXF1YWxzV2l0aFRvbGVyYW5jZSh0LGUsbil7cmV0dXJuIE1hdGguYWJzKHQtZSk8PW59fWNsYXNzIG4gZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0V4Y2VwdGlvbjpufSlbMF19dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5tZXNzYWdlfX1jbGFzcyBzIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjpzfSlbMF19fWNsYXNzIGl7Y29uc3RydWN0b3IodCxlKXt0aGlzLmxvdz1lfHwwLHRoaXMuaGlnaD10fHwwfXN0YXRpYyB0b0JpbmFyeVN0cmluZyh0KXtsZXQgZSxuPVwiXCI7Zm9yKGU9MjE0NzQ4MzY0ODtlPjA7ZT4+Pj0xKW4rPSh0LmhpZ2gmZSk9PT1lP1wiMVwiOlwiMFwiO2ZvcihlPTIxNDc0ODM2NDg7ZT4wO2U+Pj49MSluKz0odC5sb3cmZSk9PT1lP1wiMVwiOlwiMFwiO3JldHVybiBufX1mdW5jdGlvbiByKCl7fWZ1bmN0aW9uIG8oKXt9ZnVuY3Rpb24gbCgpe31mdW5jdGlvbiBhKCl7fWZ1bmN0aW9uIGMoKXt9ci5OYU49TmFOLHIuaXNOYU49dD0+TnVtYmVyLmlzTmFOKHQpLHIuaXNJbmZpbml0ZT10PT4hTnVtYmVyLmlzRmluaXRlKHQpLHIuTUFYX1ZBTFVFPU51bWJlci5NQVhfVkFMVUUsci5QT1NJVElWRV9JTkZJTklUWT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksci5ORUdBVElWRV9JTkZJTklUWT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXCJmdW5jdGlvblwiPT10eXBlb2YgRmxvYXQ2NEFycmF5JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBJbnQzMkFycmF5P2Z1bmN0aW9uKCl7Y29uc3QgdD0yMTQ2NDM1MDcyLGU9bmV3IEZsb2F0NjRBcnJheSgxKSxuPW5ldyBJbnQzMkFycmF5KGUuYnVmZmVyKTtyLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24ocyl7ZVswXT1zO2xldCByPTB8blswXSxvPTB8blsxXTtyZXR1cm4obyZ0KT09PXQmJjAhPSgxMDQ4NTc1Jm8pJiYwIT09ciYmKHI9MCxvPTIxNDY5NTkzNjApLG5ldyBpKG8scil9LHIubG9uZ0JpdHNUb0RvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gblswXT10LmxvdyxuWzFdPXQuaGlnaCxlWzBdfX0oKTpmdW5jdGlvbigpe2NvbnN0IHQ9MTAyMyxlPU1hdGgubG9nMixuPU1hdGguZmxvb3Iscz1NYXRoLnBvdyxvPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTUzO3Q+MDt0LS0pe2NvbnN0IGk9cygyLHQpLTE7aWYobihlKGkpKSsxPT09dClyZXR1cm4gaX1yZXR1cm4gMH0oKTtyLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24ocil7bGV0IGwsYSxjLGgsdSxnLGQsXyxwO2lmKHI8MHx8MS9yPT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPyhnPTE8PDMxLHI9LXIpOmc9MCwwPT09cilyZXR1cm4gcD0wLF89ZyxuZXcgaShfLHApO2lmKHI9PT0xLzApcmV0dXJuIHA9MCxfPTIxNDY0MzUwNzJ8ZyxuZXcgaShfLHApO2lmKHIhPXIpcmV0dXJuIHA9MCxfPTIxNDY5NTkzNjAsbmV3IGkoXyxwKTtpZihoPTAscD0wLGw9bihyKSxsPjEpaWYobDw9byloPW4oZShsKSksaDw9MjA/KHA9MCxfPWw8PDIwLWgmMTA0ODU3NSk6KGM9aC0yMCxhPXMoMixjKSxwPWwlYTw8MzItYyxfPWwvYSYxMDQ4NTc1KTtlbHNlIGZvcihjPWwscD0wO2E9Yy8yLGM9bihhKSwwIT09YzspaCsrLHA+Pj49MSxwfD0oMSZfKTw8MzEsXz4+Pj0xLGEhPT1jJiYoX3w9NTI0Mjg4KTtpZihkPWgrdCx1PTA9PT1sLGw9ci1sLGg8NTImJjAhPT1sKWZvcihjPTA7Oyl7aWYoYT0yKmwsYT49MT8obD1hLTEsdT8oZC0tLHU9ITEpOihjPDw9MSxjfD0xLGgrKykpOihsPWEsdT8wPT0tLWQmJihoKyssdT0hMSk6KGM8PD0xLGgrKykpLDIwPT09aClffD1jLGM9MDtlbHNlIGlmKDUyPT09aCl7cHw9YzticmVha31pZigxPT09YSl7aDwyMD9ffD1jPDwyMC1oOmg8NTImJihwfD1jPDw1Mi1oKTticmVha319cmV0dXJuIF98PWQ8PDIwLF98PWcsbmV3IGkoXyxwKX0sci5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKGUpe2xldCBuLGkscixvO2NvbnN0IGw9ZS5oaWdoLGE9ZS5sb3csYz1sJjE8PDMxPy0xOjE7Zm9yKHI9KCgyMTQ2NDM1MDcyJmwpPj4yMCktdCxvPTAsaT0xPDwxOSxuPTE7bjw9MjA7bisrKWwmaSYmKG8rPXMoMiwtbikpLGk+Pj49MTtmb3IoaT0xPDwzMSxuPTIxO248PTUyO24rKylhJmkmJihvKz1zKDIsLW4pKSxpPj4+PTE7aWYoLTEwMjM9PT1yKXtpZigwPT09bylyZXR1cm4gMCpjO3I9LTEwMjJ9ZWxzZXtpZigxMDI0PT09cilyZXR1cm4gMD09PW8/Yy8wOk5hTjtvKz0xfXJldHVybiBjKm8qcygyLHIpfX0oKTtjbGFzcyBoIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe1J1bnRpbWVFeGNlcHRpb246aH0pWzBdfX1jbGFzcyB1IGV4dGVuZHMgaHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCloLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19fWNsYXNzIGd7c3RhdGljIHNob3VsZE5ldmVyUmVhY2hIZXJlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZy5zaG91bGROZXZlclJlYWNoSGVyZShudWxsKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aHJvdyBuZXcgdShcIlNob3VsZCBuZXZlciByZWFjaCBoZXJlXCIrKG51bGwhPT10P1wiOiBcIit0OlwiXCIpKX19c3RhdGljIGlzVHJ1ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtnLmlzVHJ1ZSh0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2lmKCFhcmd1bWVudHNbMF0pdGhyb3cgbnVsbD09PXQ/bmV3IHU6bmV3IHUodCl9fXN0YXRpYyBlcXVhbHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zy5lcXVhbHModCxlLG51bGwpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKCFlLmVxdWFscyh0KSl0aHJvdyBuZXcgdShcIkV4cGVjdGVkIFwiK3QrXCIgYnV0IGVuY291bnRlcmVkIFwiK2UrKG51bGwhPT1uP1wiOiBcIituOlwiXCIpKX19fWNvbnN0IGQ9bmV3IEFycmF5QnVmZmVyKDgpLF89bmV3IEZsb2F0NjRBcnJheShkKSxwPW5ldyBJbnQzMkFycmF5KGQpO2NsYXNzIG17Y29uc3RydWN0b3IoKXttLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMuej1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKW0uY29uc3RydWN0b3JfLmNhbGwodGhpcywwLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55LHQuZ2V0WigpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG0uTlVMTF9PUkRJTkFURSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy54PXQsdGhpcy55PWUsdGhpcy56PW59fXN0YXRpYyBoYXNoQ29kZSh0KXtyZXR1cm4gX1swXT10LHBbMF1ecFsxXX1nZXRNKCl7cmV0dXJuIHIuTmFOfXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgbS5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgbS5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgbS5aOnRoaXMuc2V0WihlKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fWVxdWFsczJEKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy54LHQueCxuKSYmISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy55LHQueSxuKX19c2V0TSh0KXt0aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK20uTSl9Z2V0Wigpe3JldHVybiB0aGlzLnp9Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgbS5YOnJldHVybiB0aGlzLng7Y2FzZSBtLlk6cmV0dXJuIHRoaXMueTtjYXNlIG0uWjpyZXR1cm4gdGhpcy5nZXRaKCl9dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1lcXVhbHMzRCh0KXtyZXR1cm4gdGhpcy54PT09dC54JiZ0aGlzLnk9PT10LnkmJih0aGlzLmdldFooKT09PXQuZ2V0WigpfHxyLmlzTmFOKHRoaXMuZ2V0WigpKSYmci5pc05hTih0LmdldFooKSkpfWVxdWFscyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIG0mJnRoaXMuZXF1YWxzMkQodCl9ZXF1YWxJbloodCxuKXtyZXR1cm4gZS5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMuZ2V0WigpLHQuZ2V0WigpLG4pfXNldFgodCl7dGhpcy54PXR9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy54PGUueD8tMTp0aGlzLng+ZS54PzE6dGhpcy55PGUueT8tMTp0aGlzLnk+ZS55PzE6MH1nZXRYKCl7cmV0dXJuIHRoaXMueH1zZXRaKHQpe3RoaXMuej10fWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZShcInRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoaXMgY2xhc3MgaXMgQ2xvbmVhYmxlXCIpLG51bGw7dGhyb3cgdH19Y29weSgpe3JldHVybiBuZXcgbSh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLmdldFooKStcIilcIn1kaXN0YW5jZTNEKHQpe2NvbnN0IGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnkscz10aGlzLmdldFooKS10LmdldFooKTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4rcypzKX1nZXRZKCl7cmV0dXJuIHRoaXMueX1zZXRZKHQpe3RoaXMueT10fWRpc3RhbmNlKHQpe2NvbnN0IGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuKX1oYXNoQ29kZSgpe2xldCB0PTE3O3JldHVybiB0PTM3KnQrbS5oYXNoQ29kZSh0aGlzLngpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMueSksdH1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC5nZXRaKCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW28sbCxjXX19Y2xhc3MgZntjb25zdHJ1Y3Rvcigpe2YuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGltZW5zaW9uc1RvVGVzdD0yLDA9PT1hcmd1bWVudHMubGVuZ3RoKWYuY29uc3RydWN0b3JfLmNhbGwodGhpcywyKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigyIT09dCYmMyE9PXQpdGhyb3cgbmV3IHMoXCJvbmx5IDIgb3IgMyBkaW1lbnNpb25zIG1heSBiZSBzcGVjaWZpZWRcIik7dGhpcy5fZGltZW5zaW9uc1RvVGVzdD10fX1zdGF0aWMgY29tcGFyZSh0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6ci5pc05hTih0KT9yLmlzTmFOKGUpPzA6LTE6ci5pc05hTihlKT8xOjB9Y29tcGFyZSh0LGUpe2NvbnN0IG49Zi5jb21wYXJlKHQueCxlLngpO2lmKDAhPT1uKXJldHVybiBuO2NvbnN0IHM9Zi5jb21wYXJlKHQueSxlLnkpO2lmKDAhPT1zKXJldHVybiBzO2lmKHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q8PTIpcmV0dXJuIDA7cmV0dXJuIGYuY29tcGFyZSh0LmdldFooKSxlLmdldFooKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1tLkRpbWVuc2lvbmFsQ29tcGFyYXRvcj1mLG0uTlVMTF9PUkRJTkFURT1yLk5hTixtLlg9MCxtLlk9MSxtLlo9MixtLk09MztjbGFzcyB5IGV4dGVuZHMgbXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCltLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbS5OVUxMX09SRElOQVRFKX19c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSB5Llg6dGhpcy54PWU7YnJlYWs7Y2FzZSB5Llk6dGhpcy55PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX1nZXRaKCl7cmV0dXJuIG0uTlVMTF9PUkRJTkFURX1nZXRPcmRpbmF0ZSh0KXtzd2l0Y2godCl7Y2FzZSB5Llg6cmV0dXJuIHRoaXMueDtjYXNlIHkuWTpyZXR1cm4gdGhpcy55fXRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9c2V0Wih0KXt0aHJvdyBuZXcgcyhcIkNvb3JkaW5hdGVYWSBkaW1lbnNpb24gMiBkb2VzIG5vdCBzdXBwb3J0IHotb3JkaW5hdGVcIil9Y29weSgpe3JldHVybiBuZXcgeSh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiKVwifXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKX19eS5YPTAseS5ZPTEseS5aPS0xLHkuTT0tMTtjbGFzcyB4IGV4dGVuZHMgbXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpbS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLl9tPTA7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB4KXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSksdGhpcy5fbT10Ll9tfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSksdGhpcy5fbT10aGlzLmdldE0oKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxtLk5VTExfT1JESU5BVEUpLHRoaXMuX209bn19Z2V0TSgpe3JldHVybiB0aGlzLl9tfXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgeC5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgeC5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgeC5NOnRoaXMuX209ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fXNldE0odCl7dGhpcy5fbT10fWdldFooKXtyZXR1cm4gbS5OVUxMX09SRElOQVRFfWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIHguWDpyZXR1cm4gdGhpcy54O2Nhc2UgeC5ZOnJldHVybiB0aGlzLnk7Y2FzZSB4Lk06cmV0dXJuIHRoaXMuX219dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1zZXRaKHQpe3Rocm93IG5ldyBzKFwiQ29vcmRpbmF0ZVhZIGRpbWVuc2lvbiAyIGRvZXMgbm90IHN1cHBvcnQgei1vcmRpbmF0ZVwiKX1jb3B5KCl7cmV0dXJuIG5ldyB4KHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIgbT1cIit0aGlzLmdldE0oKStcIilcIn1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC5nZXRaKCksdGhpcy5fbT10LmdldE0oKX19eC5YPTAseC5ZPTEseC5aPS0xLHguTT0yO2NsYXNzIEUgZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxFLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX209bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCltLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuX209MDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLl9tPXQuX219ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLl9tPXRoaXMuZ2V0TSgpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4pLHRoaXMuX209c319Z2V0TSgpe3JldHVybiB0aGlzLl9tfXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgbS5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgbS5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgbS5aOnRoaXMuej1lO2JyZWFrO2Nhc2UgbS5NOnRoaXMuX209ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fXNldE0odCl7dGhpcy5fbT10fWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIG0uWDpyZXR1cm4gdGhpcy54O2Nhc2UgbS5ZOnJldHVybiB0aGlzLnk7Y2FzZSBtLlo6cmV0dXJuIHRoaXMuZ2V0WigpO2Nhc2UgbS5NOnJldHVybiB0aGlzLmdldE0oKX10aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfWNvcHkoKXtyZXR1cm4gbmV3IEUodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiwgXCIrdGhpcy5nZXRaKCkrXCIgbT1cIit0aGlzLmdldE0oKStcIilcIn1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC5nZXRaKCksdGhpcy5fbT10LmdldE0oKX19ZnVuY3Rpb24gSSh0LGUpe3JldHVybiB0LmludGVyZmFjZXNfJiZ0LmludGVyZmFjZXNfLmluZGV4T2YoZSk+LTF9Y2xhc3MgTnthZGQoKXt9YWRkQWxsKCl7fWlzRW1wdHkoKXt9aXRlcmF0b3IoKXt9c2l6ZSgpe310b0FycmF5KCl7fXJlbW92ZSgpe319Y2xhc3MgdyBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uOnd9KVswXX19Y2xhc3MgQyBleHRlbmRzIE57Z2V0KCl7fXNldCgpe31pc0VtcHR5KCl7fX1jbGFzcyBTIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe05vU3VjaEVsZW1lbnRFeGNlcHRpb246U30pWzBdfX1jbGFzcyBMIGV4dGVuZHMgQ3tjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuYXJyYXk9W10sdCBpbnN0YW5jZW9mIE4mJnRoaXMuYWRkQWxsKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDLE5dfWVuc3VyZUNhcGFjaXR5KCl7fWFkZCh0KXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5hcnJheS5wdXNoKHQpOnRoaXMuYXJyYXkuc3BsaWNlKGFyZ3VtZW50c1swXSwwLGFyZ3VtZW50c1sxXSksITB9Y2xlYXIoKXt0aGlzLmFycmF5PVtdfWFkZEFsbCh0KXtmb3IoY29uc3QgZSBvZiB0KXRoaXMuYXJyYXkucHVzaChlKX1zZXQodCxlKXtjb25zdCBuPXRoaXMuYXJyYXlbdF07cmV0dXJuIHRoaXMuYXJyYXlbdF09ZSxufWl0ZXJhdG9yKCl7cmV0dXJuIG5ldyBUKHRoaXMpfWdldCh0KXtpZih0PDB8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyB3O3JldHVybiB0aGlzLmFycmF5W3RdfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuYXJyYXkubGVuZ3RofXNvcnQodCl7dD90aGlzLmFycmF5LnNvcnQoKChlLG4pPT50LmNvbXBhcmUoZSxuKSkpOnRoaXMuYXJyYXkuc29ydCgpfXNpemUoKXtyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGh9dG9BcnJheSgpe3JldHVybiB0aGlzLmFycmF5LnNsaWNlKCl9cmVtb3ZlKHQpe2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheS5sZW5ndGg7ZTxuO2UrKylpZih0aGlzLmFycmF5W2VdPT09dClyZXR1cm4hIXRoaXMuYXJyYXkuc3BsaWNlKGUsMSk7cmV0dXJuITF9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5hcnJheS52YWx1ZXMoKX19bGV0IFQ9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5hcnJheUxpc3Q9dCx0aGlzLnBvc2l0aW9uPTB9bmV4dCgpe2lmKHRoaXMucG9zaXRpb249PT10aGlzLmFycmF5TGlzdC5zaXplKCkpdGhyb3cgbmV3IFM7cmV0dXJuIHRoaXMuYXJyYXlMaXN0LmdldCh0aGlzLnBvc2l0aW9uKyspfWhhc05leHQoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbjx0aGlzLmFycmF5TGlzdC5zaXplKCl9c2V0KHQpe3JldHVybiB0aGlzLmFycmF5TGlzdC5zZXQodGhpcy5wb3NpdGlvbi0xLHQpfXJlbW92ZSgpe3RoaXMuYXJyYXlMaXN0LnJlbW92ZSh0aGlzLmFycmF5TGlzdC5nZXQodGhpcy5wb3NpdGlvbikpfX07Y2xhc3MgUiBleHRlbmRzIEx7Y29uc3RydWN0b3IoKXtzdXBlcigpLFIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsZSl9fWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuZ2V0KHQpfWFkZEFsbCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2xldCBlPSExO2ZvcihsZXQgbj1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtuLmhhc05leHQoKTspdGhpcy5hZGQobi5uZXh0KCksdCksZT0hMDtyZXR1cm4gZX1yZXR1cm4gc3VwZXIuYWRkQWxsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbG9uZSgpe2NvbnN0IHQ9c3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuc2l6ZSgpO2UrKyl0LmFkZChlLHRoaXMuZ2V0KGUpLmNsb25lKCkpO3JldHVybiB0fXRvQ29vcmRpbmF0ZUFycmF5KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMudG9BcnJheShSLmNvb3JkQXJyYXlUeXBlKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdKXJldHVybiB0aGlzLnRvQXJyYXkoUi5jb29yZEFycmF5VHlwZSk7Y29uc3QgdD10aGlzLnNpemUoKSxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dDtuKyspZVtuXT10aGlzLmdldCh0LW4tMSk7cmV0dXJuIGV9fWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3VwZXIuYWRkLmNhbGwodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZCh0LGUsITApLCEwfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCFhcmd1bWVudHNbMV0mJnRoaXMuc2l6ZSgpPj0xKXtpZih0aGlzLmdldCh0aGlzLnNpemUoKS0xKS5lcXVhbHMyRCh0KSlyZXR1cm4gbnVsbH1zdXBlci5hZGQuY2FsbCh0aGlzLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQodCxlKSwhMH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHNbMl0pZm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpcy5hZGQodFtuXSxlKTtlbHNlIGZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKXRoaXMuYWRkKHRbbl0sZSk7cmV0dXJuITB9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighYXJndW1lbnRzWzJdKXtjb25zdCBuPXRoaXMuc2l6ZSgpO2lmKG4+MCl7aWYodD4wKXtpZih0aGlzLmdldCh0LTEpLmVxdWFsczJEKGUpKXJldHVybiBudWxsfWlmKHQ8bil7aWYodGhpcy5nZXQodCkuZXF1YWxzMkQoZSkpcmV0dXJuIG51bGx9fX1zdXBlci5hZGQuY2FsbCh0aGlzLHQsZSl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2xldCBpPTE7bj5zJiYoaT0tMSk7Zm9yKGxldCByPW47ciE9PXM7cis9aSl0aGlzLmFkZCh0W3JdLGUpO3JldHVybiEwfX1jbG9zZVJpbmcoKXtpZih0aGlzLnNpemUoKT4wKXtjb25zdCB0PXRoaXMuZ2V0KDApLmNvcHkoKTt0aGlzLmFkZCh0LCExKX19fVIuY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCk7Y2xhc3MgUHtmaWx0ZXIodCxlKXt9aXNEb25lKCl7fWlzR2VvbWV0cnlDaGFuZ2VkKCl7fX1jbGFzcyBPe2NvbnN0cnVjdG9yKCl7Ty5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9taW54PW51bGwsdGhpcy5fbWF4eD1udWxsLHRoaXMuX21pbnk9bnVsbCx0aGlzLl9tYXh5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodC54LGUueCx0LnksZS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmluaXQodCxlLG4scyl9fXN0YXRpYyBpbnRlcnNlY3RzKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuLng+PSh0Lng8ZS54P3QueDplLngpJiZuLng8PSh0Lng+ZS54P3QueDplLngpJiZuLnk+PSh0Lnk8ZS55P3QueTplLnkpJiZuLnk8PSh0Lnk+ZS55P3QueTplLnkpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtsZXQgaT1NYXRoLm1pbihuLngscy54KSxyPU1hdGgubWF4KG4ueCxzLngpLG89TWF0aC5taW4odC54LGUueCksbD1NYXRoLm1heCh0LngsZS54KTtyZXR1cm4hKG8+cikmJighKGw8aSkmJihpPU1hdGgubWluKG4ueSxzLnkpLHI9TWF0aC5tYXgobi55LHMueSksbz1NYXRoLm1pbih0LnksZS55KSxsPU1hdGgubWF4KHQueSxlLnkpLCEobz5yKSYmIShsPGkpKSl9fWdldEFyZWEoKXtyZXR1cm4gdGhpcy5nZXRXaWR0aCgpKnRoaXMuZ2V0SGVpZ2h0KCl9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIE8pKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpOnRoaXMuX21heHg9PT1lLmdldE1heFgoKSYmdGhpcy5fbWF4eT09PWUuZ2V0TWF4WSgpJiZ0aGlzLl9taW54PT09ZS5nZXRNaW5YKCkmJnRoaXMuX21pbnk9PT1lLmdldE1pblkoKX1pbnRlcnNlY3Rpb24odCl7aWYodGhpcy5pc051bGwoKXx8dC5pc051bGwoKXx8IXRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gbmV3IE87Y29uc3QgZT10aGlzLl9taW54PnQuX21pbng/dGhpcy5fbWlueDp0Ll9taW54LG49dGhpcy5fbWlueT50Ll9taW55P3RoaXMuX21pbnk6dC5fbWlueSxzPXRoaXMuX21heHg8dC5fbWF4eD90aGlzLl9tYXh4OnQuX21heHgsaT10aGlzLl9tYXh5PHQuX21heHk/dGhpcy5fbWF4eTp0Ll9tYXh5O3JldHVybiBuZXcgTyhlLHMsbixpKX1pc051bGwoKXtyZXR1cm4gdGhpcy5fbWF4eDx0aGlzLl9taW54fWdldE1heFgoKXtyZXR1cm4gdGhpcy5fbWF4eH1jb3ZlcnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModC54LHQueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkmJih0LmdldE1pblgoKT49dGhpcy5fbWlueCYmdC5nZXRNYXhYKCk8PXRoaXMuX21heHgmJnQuZ2V0TWluWSgpPj10aGlzLl9taW55JiZ0LmdldE1heFkoKTw9dGhpcy5fbWF4eSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYodD49dGhpcy5fbWlueCYmdDw9dGhpcy5fbWF4eCYmZT49dGhpcy5fbWlueSYmZTw9dGhpcy5fbWF4eSl9fWludGVyc2VjdHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkmJiEodC5fbWlueD50aGlzLl9tYXh4fHx0Ll9tYXh4PHRoaXMuX21pbnh8fHQuX21pbnk+dGhpcy5fbWF4eXx8dC5fbWF4eTx0aGlzLl9taW55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmludGVyc2VjdHModC54LHQueSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmlzTnVsbCgpKXJldHVybiExO2lmKCh0Lng8ZS54P3QueDplLngpPnRoaXMuX21heHgpcmV0dXJuITE7aWYoKHQueD5lLng/dC54OmUueCk8dGhpcy5fbWlueClyZXR1cm4hMTtpZigodC55PGUueT90Lnk6ZS55KT50aGlzLl9tYXh5KXJldHVybiExO3JldHVybiEoKHQueT5lLnk/dC55OmUueSk8dGhpcy5fbWlueSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiEodD50aGlzLl9tYXh4fHx0PHRoaXMuX21pbnh8fGU+dGhpcy5fbWF4eXx8ZTx0aGlzLl9taW55KX19fWdldE1pblkoKXtyZXR1cm4gdGhpcy5fbWlueX1nZXREaWFtZXRlcigpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiBNYXRoLnNxcnQodCp0K2UqZSl9Z2V0TWluWCgpe3JldHVybiB0aGlzLl9taW54fWV4cGFuZFRvSW5jbHVkZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kVG9JbmNsdWRlKHQueCx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaXNOdWxsKCk/KHRoaXMuX21pbng9dC5nZXRNaW5YKCksdGhpcy5fbWF4eD10LmdldE1heFgoKSx0aGlzLl9taW55PXQuZ2V0TWluWSgpLHRoaXMuX21heHk9dC5nZXRNYXhZKCkpOih0Ll9taW54PHRoaXMuX21pbngmJih0aGlzLl9taW54PXQuX21pbngpLHQuX21heHg+dGhpcy5fbWF4eCYmKHRoaXMuX21heHg9dC5fbWF4eCksdC5fbWlueTx0aGlzLl9taW55JiYodGhpcy5fbWlueT10Ll9taW55KSx0Ll9tYXh5PnRoaXMuX21heHkmJih0aGlzLl9tYXh5PXQuX21heHkpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pc051bGwoKT8odGhpcy5fbWlueD10LHRoaXMuX21heHg9dCx0aGlzLl9taW55PWUsdGhpcy5fbWF4eT1lKToodDx0aGlzLl9taW54JiYodGhpcy5fbWlueD10KSx0PnRoaXMuX21heHgmJih0aGlzLl9tYXh4PXQpLGU8dGhpcy5fbWlueSYmKHRoaXMuX21pbnk9ZSksZT50aGlzLl9tYXh5JiYodGhpcy5fbWF4eT1lKSl9fW1pbkV4dGVudCgpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiB0PGU/dDplfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLl9tYXh4LXRoaXMuX21pbnh9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpPzA6LTE6ZS5pc051bGwoKT8xOnRoaXMuX21pbng8ZS5fbWlueD8tMTp0aGlzLl9taW54PmUuX21pbng/MTp0aGlzLl9taW55PGUuX21pbnk/LTE6dGhpcy5fbWlueT5lLl9taW55PzE6dGhpcy5fbWF4eDxlLl9tYXh4Py0xOnRoaXMuX21heHg+ZS5fbWF4eD8xOnRoaXMuX21heHk8ZS5fbWF4eT8tMTp0aGlzLl9tYXh5PmUuX21heHk/MTowfXRyYW5zbGF0ZSh0LGUpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5pbml0KHRoaXMuZ2V0TWluWCgpK3QsdGhpcy5nZXRNYXhYKCkrdCx0aGlzLmdldE1pblkoKStlLHRoaXMuZ2V0TWF4WSgpK2UpfWNvcHkoKXtyZXR1cm4gbmV3IE8odGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIkVudltcIit0aGlzLl9taW54K1wiIDogXCIrdGhpcy5fbWF4eCtcIiwgXCIrdGhpcy5fbWlueStcIiA6IFwiK3RoaXMuX21heHkrXCJdXCJ9c2V0VG9OdWxsKCl7dGhpcy5fbWlueD0wLHRoaXMuX21heHg9LTEsdGhpcy5fbWlueT0wLHRoaXMuX21heHk9LTF9ZGlzam9pbnQodCl7cmV0dXJuISghdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkpfHwodC5fbWlueD50aGlzLl9tYXh4fHx0Ll9tYXh4PHRoaXMuX21pbnh8fHQuX21pbnk+dGhpcy5fbWF4eXx8dC5fbWF4eTx0aGlzLl9taW55KX1nZXRIZWlnaHQoKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMuX21heHktdGhpcy5fbWlueX1tYXhFeHRlbnQoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdD5lP3Q6ZX1leHBhbmRCeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZEJ5KHQsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLl9taW54LT10LHRoaXMuX21heHgrPXQsdGhpcy5fbWlueS09ZSx0aGlzLl9tYXh5Kz1lLCh0aGlzLl9taW54PnRoaXMuX21heHh8fHRoaXMuX21pbnk+dGhpcy5fbWF4eSkmJnRoaXMuc2V0VG9OdWxsKCl9fWNvbnRhaW5zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb3ZlcnModCxlKX19Y2VudHJlKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/bnVsbDpuZXcgbSgodGhpcy5nZXRNaW5YKCkrdGhpcy5nZXRNYXhYKCkpLzIsKHRoaXMuZ2V0TWluWSgpK3RoaXMuZ2V0TWF4WSgpKS8yKX1pbml0KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb051bGwoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9taW54PXQuX21pbngsdGhpcy5fbWF4eD10Ll9tYXh4LHRoaXMuX21pbnk9dC5fbWlueSx0aGlzLl9tYXh5PXQuX21heHl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LngsZS54LHQueSxlLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3Q8ZT8odGhpcy5fbWlueD10LHRoaXMuX21heHg9ZSk6KHRoaXMuX21pbng9ZSx0aGlzLl9tYXh4PXQpLG48cz8odGhpcy5fbWlueT1uLHRoaXMuX21heHk9cyk6KHRoaXMuX21pbnk9cyx0aGlzLl9tYXh5PW4pfX1nZXRNYXhZKCl7cmV0dXJuIHRoaXMuX21heHl9ZGlzdGFuY2UodCl7aWYodGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiAwO2xldCBlPTA7dGhpcy5fbWF4eDx0Ll9taW54P2U9dC5fbWlueC10aGlzLl9tYXh4OnRoaXMuX21pbng+dC5fbWF4eCYmKGU9dGhpcy5fbWlueC10Ll9tYXh4KTtsZXQgbj0wO3JldHVybiB0aGlzLl9tYXh5PHQuX21pbnk/bj10Ll9taW55LXRoaXMuX21heHk6dGhpcy5fbWlueT50Ll9tYXh5JiYobj10aGlzLl9taW55LXQuX21heHkpLDA9PT1lP246MD09PW4/ZTpNYXRoLnNxcnQoZSplK24qbil9aGFzaENvZGUoKXtsZXQgdD0xNztyZXR1cm4gdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWlueCksdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWF4eCksdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWlueSksdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWF4eSksdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxjXX19Y2xhc3Mgdntjb25zdHJ1Y3Rvcih0KXt0aGlzLnN0cj10fWFwcGVuZCh0KXt0aGlzLnN0cis9dH1zZXRDaGFyQXQodCxlKXt0aGlzLnN0cj10aGlzLnN0ci5zdWJzdHIoMCx0KStlK3RoaXMuc3RyLnN1YnN0cih0KzEpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc3RyfX1jbGFzcyBie2NvbnN0cnVjdG9yKHQpe3RoaXMudmFsdWU9dH1pbnRWYWx1ZSgpe3JldHVybiB0aGlzLnZhbHVlfWNvbXBhcmVUbyh0KXtyZXR1cm4gdGhpcy52YWx1ZTx0Py0xOnRoaXMudmFsdWU+dD8xOjB9c3RhdGljIGNvbXBhcmUodCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9c3RhdGljIGlzTmFuKHQpe3JldHVybiBOdW1iZXIuaXNOYU4odCl9c3RhdGljIHZhbHVlT2YodCl7cmV0dXJuIG5ldyBiKHQpfX1jbGFzcyBNe3N0YXRpYyBpc1doaXRlc3BhY2UodCl7cmV0dXJuIHQ8PTMyJiZ0Pj0wfHwxMjc9PT10fXN0YXRpYyB0b1VwcGVyQ2FzZSh0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfX1jbGFzcyBEIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0lsbGVnYWxTdGF0ZUV4Y2VwdGlvbjpEfSlbMF19fWNsYXNzIEF7Y29uc3RydWN0b3IoKXtBLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2hpPTAsdGhpcy5fbG89MCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtBLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsQS5wYXJzZSh0KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LGUpfX1zdGF0aWMgZGV0ZXJtaW5hbnQoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gQS5kZXRlcm1pbmFudChBLnZhbHVlT2YodCksQS52YWx1ZU9mKGUpLEEudmFsdWVPZihuKSxBLnZhbHVlT2YocykpfWlmKGFyZ3VtZW50c1szXWluc3RhbmNlb2YgQSYmYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM107cmV0dXJuIGFyZ3VtZW50c1swXS5tdWx0aXBseShuKS5zZWxmU3VidHJhY3QodC5tdWx0aXBseShlKSl9fXN0YXRpYyBzcXIodCl7cmV0dXJuIEEudmFsdWVPZih0KS5zZWxmTXVsdGlwbHkodCl9c3RhdGljIHZhbHVlT2YoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gQS5wYXJzZSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtyZXR1cm4gbmV3IEEoYXJndW1lbnRzWzBdKX19c3RhdGljIHNxcnQodCl7cmV0dXJuIEEudmFsdWVPZih0KS5zcXJ0KCl9c3RhdGljIHBhcnNlKHQpe2xldCBlPTA7Y29uc3Qgbj10Lmxlbmd0aDtmb3IoO00uaXNXaGl0ZXNwYWNlKHQuY2hhckF0KGUpKTspZSsrO2xldCBzPSExO2lmKGU8bil7Y29uc3Qgbj10LmNoYXJBdChlKTtcIi1cIiE9PW4mJlwiK1wiIT09bnx8KGUrKyxcIi1cIj09PW4mJihzPSEwKSl9Y29uc3QgaT1uZXcgQTtsZXQgcj0wLG89MCxsPTAsYT0hMTtmb3IoOyEoZT49bik7KXtjb25zdCBuPXQuY2hhckF0KGUpO2lmKGUrKyxNLmlzRGlnaXQobikpe2NvbnN0IHQ9bi1cIjBcIjtpLnNlbGZNdWx0aXBseShBLlRFTiksaS5zZWxmQWRkKHQpLHIrK31lbHNle2lmKFwiLlwiIT09bil7aWYoXCJlXCI9PT1ufHxcIkVcIj09PW4pe2NvbnN0IG49dC5zdWJzdHJpbmcoZSk7dHJ5e2w9Yi5wYXJzZUludChuKX1jYXRjaChlKXt0aHJvdyBlIGluc3RhbmNlb2YgTnVtYmVyRm9ybWF0RXhjZXB0aW9uP25ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJJbnZhbGlkIGV4cG9uZW50IFwiK24rXCIgaW4gc3RyaW5nIFwiK3QpOmV9YnJlYWt9dGhyb3cgbmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIituK1wiJyBhdCBwb3NpdGlvbiBcIitlK1wiIGluIHN0cmluZyBcIit0KX1vPXIsYT0hMH19bGV0IGM9aTthfHwobz1yKTtjb25zdCBoPXItby1sO2lmKDA9PT1oKWM9aTtlbHNlIGlmKGg+MCl7Y29uc3QgdD1BLlRFTi5wb3coaCk7Yz1pLmRpdmlkZSh0KX1lbHNlIGlmKGg8MCl7Y29uc3QgdD1BLlRFTi5wb3coLWgpO2M9aS5tdWx0aXBseSh0KX1yZXR1cm4gcz9jLm5lZ2F0ZSgpOmN9c3RhdGljIGNyZWF0ZU5hTigpe3JldHVybiBuZXcgQShyLk5hTixyLk5hTil9c3RhdGljIGNvcHkodCl7cmV0dXJuIG5ldyBBKHQpfXN0YXRpYyBtYWduaXR1ZGUodCl7Y29uc3QgZT1NYXRoLmFicyh0KSxuPU1hdGgubG9nKGUpL01hdGgubG9nKDEwKTtsZXQgcz1NYXRoLnRydW5jKE1hdGguZmxvb3IobikpO3JldHVybiAxMCpNYXRoLnBvdygxMCxzKTw9ZSYmKHMrPTEpLHN9c3RhdGljIHN0cmluZ09mQ2hhcih0LGUpe2NvbnN0IG49bmV3IHY7Zm9yKGxldCBzPTA7czxlO3MrKyluLmFwcGVuZCh0KTtyZXR1cm4gbi50b1N0cmluZygpfWxlKHQpe3JldHVybiB0aGlzLl9oaTx0Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG88PXQuX2xvfWV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh0LGUpe2xldCBuPXRoaXMuYWJzKCkscz1BLm1hZ25pdHVkZShuLl9oaSk7Y29uc3QgaT1BLlRFTi5wb3cocyk7bj1uLmRpdmlkZShpKSxuLmd0KEEuVEVOKT8obj1uLmRpdmlkZShBLlRFTikscys9MSk6bi5sdChBLk9ORSkmJihuPW4ubXVsdGlwbHkoQS5URU4pLHMtPTEpO2NvbnN0IHI9cysxLG89bmV3IHYsbD1BLk1BWF9QUklOVF9ESUdJVFMtMTtmb3IobGV0IGU9MDtlPD1sO2UrKyl7dCYmZT09PXImJm8uYXBwZW5kKFwiLlwiKTtjb25zdCBzPU1hdGgudHJ1bmMobi5faGkpO2lmKHM8MClicmVhaztsZXQgaT0hMSxhPTA7cz45PyhpPSEwLGE9XCI5XCIpOmE9XCIwXCIrcyxvLmFwcGVuZChhKSxuPW4uc3VidHJhY3QoQS52YWx1ZU9mKHMpKS5tdWx0aXBseShBLlRFTiksaSYmbi5zZWxmQWRkKEEuVEVOKTtsZXQgYz0hMDtjb25zdCBoPUEubWFnbml0dWRlKG4uX2hpKTtpZihoPDAmJk1hdGguYWJzKGgpPj1sLWUmJihjPSExKSwhYylicmVha31yZXR1cm4gZVswXT1zLG8udG9TdHJpbmcoKX1zcXIoKXtyZXR1cm4gdGhpcy5tdWx0aXBseSh0aGlzKX1kb3VibGVWYWx1ZSgpe3JldHVybiB0aGlzLl9oaSt0aGlzLl9sb31zdWJ0cmFjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKHQubmVnYXRlKCkpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCgtdCl9fWVxdWFscygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz09PXQuX2xvfX1pc1plcm8oKXtyZXR1cm4gMD09PXRoaXMuX2hpJiYwPT09dGhpcy5fbG99c2VsZlN1YnRyYWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10Ll9oaSwtdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQsMCl9fWdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKXtyZXR1cm4gdGhpcy5pc1plcm8oKT9cIjAuMFwiOnRoaXMuaXNOYU4oKT9cIk5hTiBcIjpudWxsfW1pbih0KXtyZXR1cm4gdGhpcy5sZSh0KT90aGlzOnR9c2VsZkRpdmlkZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodCwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbCxjPW51bGw7cmV0dXJuIG89dGhpcy5faGkvdCxsPUEuU1BMSVQqbyxuPWwtbyxjPUEuU1BMSVQqdCxuPWwtbixzPW8tbixpPWMtdCxhPW8qdCxpPWMtaSxyPXQtaSxjPW4qaS1hK24qcitzKmkrcypyLGw9KHRoaXMuX2hpLWEtYyt0aGlzLl9sby1vKmUpL3QsYz1vK2wsdGhpcy5faGk9Yyx0aGlzLl9sbz1vLWMrbCx0aGlzfX1kdW1wKCl7cmV0dXJuXCJERDxcIit0aGlzLl9oaStcIiwgXCIrdGhpcy5fbG8rXCI+XCJ9ZGl2aWRlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbDtyPXRoaXMuX2hpL3QuX2hpLG89QS5TUExJVCpyLGU9by1yLGE9QS5TUExJVCp0Ll9oaSxlPW8tZSxuPXItZSxzPWEtdC5faGksbD1yKnQuX2hpLHM9YS1zLGk9dC5faGktcyxhPWUqcy1sK2UqaStuKnMrbippLG89KHRoaXMuX2hpLWwtYSt0aGlzLl9sby1yKnQuX2xvKS90Ll9oaSxhPXIrbztyZXR1cm4gbmV3IEEoYSxyLWErbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4odCk/QS5jcmVhdGVOYU4oKTpBLmNvcHkodGhpcykuc2VsZkRpdmlkZSh0LDApfX1nZSh0KXtyZXR1cm4gdGhpcy5faGk+dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPj10Ll9sb31wb3codCl7aWYoMD09PXQpcmV0dXJuIEEudmFsdWVPZigxKTtsZXQgZT1uZXcgQSh0aGlzKSxuPUEudmFsdWVPZigxKSxzPU1hdGguYWJzKHQpO2lmKHM+MSlmb3IoO3M+MDspcyUyPT0xJiZuLnNlbGZNdWx0aXBseShlKSxzLz0yLHM+MCYmKGU9ZS5zcXIoKSk7ZWxzZSBuPWU7cmV0dXJuIHQ8MD9uLnJlY2lwcm9jYWwoKTpufWNlaWwoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIEEuTmFOO2NvbnN0IHQ9TWF0aC5jZWlsKHRoaXMuX2hpKTtsZXQgZT0wO3JldHVybiB0PT09dGhpcy5faGkmJihlPU1hdGguY2VpbCh0aGlzLl9sbykpLG5ldyBBKHQsZSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5faGk8ZS5faGk/LTE6dGhpcy5faGk+ZS5faGk/MTp0aGlzLl9sbzxlLl9sbz8tMTp0aGlzLl9sbz5lLl9sbz8xOjB9cmludCgpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gdGhpcztyZXR1cm4gdGhpcy5hZGQoLjUpLmZsb29yKCl9c2V0VmFsdWUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc31pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KHQpLHRoaXN9fW1heCh0KXtyZXR1cm4gdGhpcy5nZSh0KT90aGlzOnR9c3FydCgpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIEEudmFsdWVPZigwKTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gQS5OYU47Y29uc3QgdD0xL01hdGguc3FydCh0aGlzLl9oaSksZT10aGlzLl9oaSp0LG49QS52YWx1ZU9mKGUpLHM9dGhpcy5zdWJ0cmFjdChuLnNxcigpKS5faGkqKC41KnQpO3JldHVybiBuLmFkZChzKX1zZWxmQWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkFkZCh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsO3JldHVybiBzPXRoaXMuX2hpK3Qscj1zLXRoaXMuX2hpLGk9cy1yLGk9dC1yKyh0aGlzLl9oaS1pKSxvPWkrdGhpcy5fbG8sZT1zK28sbj1vKyhzLWUpLHRoaXMuX2hpPWUrbix0aGlzLl9sbz1uKyhlLXRoaXMuX2hpKSx0aGlzfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsLGM9bnVsbDtvPXRoaXMuX2hpK3QsaT10aGlzLl9sbytlLGE9by10aGlzLl9oaSxjPWktdGhpcy5fbG8sbD1vLWEscj1pLWMsbD10LWErKHRoaXMuX2hpLWwpLHI9ZS1jKyh0aGlzLl9sby1yKSxhPWwraSxuPW8rYSxzPWErKG8tbiksYT1yK3M7Y29uc3QgaD1uK2EsdT1hKyhuLWgpO3JldHVybiB0aGlzLl9oaT1oLHRoaXMuX2xvPXUsdGhpc319c2VsZk11bHRpcGx5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodCwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsO289QS5TUExJVCp0aGlzLl9oaSxuPW8tdGhpcy5faGksbD1BLlNQTElUKnQsbj1vLW4scz10aGlzLl9oaS1uLGk9bC10LG89dGhpcy5faGkqdCxpPWwtaSxyPXQtaSxsPW4qaS1vK24qcitzKmkrcypyKyh0aGlzLl9oaSplK3RoaXMuX2xvKnQpO2NvbnN0IGE9bytsO249by1hO2NvbnN0IGM9bCtuO3JldHVybiB0aGlzLl9oaT1hLHRoaXMuX2xvPWMsdGhpc319c2VsZlNxcigpe3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0aGlzKX1mbG9vcigpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gQS5OYU47Y29uc3QgdD1NYXRoLmZsb29yKHRoaXMuX2hpKTtsZXQgZT0wO3JldHVybiB0PT09dGhpcy5faGkmJihlPU1hdGguZmxvb3IodGhpcy5fbG8pKSxuZXcgQSh0LGUpfW5lZ2F0ZSgpe3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczpuZXcgQSgtdGhpcy5faGksLXRoaXMuX2xvKX1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIG51bGw7dGhyb3cgdH19bXVsdGlwbHkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmlzTmFOKCk/QS5jcmVhdGVOYU4oKTpBLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKHQpP0EuY3JlYXRlTmFOKCk6QS5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0LDApfX1pc05hTigpe3JldHVybiByLmlzTmFOKHRoaXMuX2hpKX1pbnRWYWx1ZSgpe3JldHVybiBNYXRoLnRydW5jKHRoaXMuX2hpKX10b1N0cmluZygpe2NvbnN0IHQ9QS5tYWduaXR1ZGUodGhpcy5faGkpO3JldHVybiB0Pj0tMyYmdDw9MjA/dGhpcy50b1N0YW5kYXJkTm90YXRpb24oKTp0aGlzLnRvU2NpTm90YXRpb24oKX10b1N0YW5kYXJkTm90YXRpb24oKXtjb25zdCB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMCxlKSxzPWVbMF0rMTtsZXQgaT1uO2lmKFwiLlwiPT09bi5jaGFyQXQoMCkpaT1cIjBcIituO2Vsc2UgaWYoczwwKWk9XCIwLlwiK0Euc3RyaW5nT2ZDaGFyKFwiMFwiLC1zKStuO2Vsc2UgaWYoLTE9PT1uLmluZGV4T2YoXCIuXCIpKXtjb25zdCB0PXMtbi5sZW5ndGg7aT1uK0Euc3RyaW5nT2ZDaGFyKFwiMFwiLHQpK1wiLjBcIn1yZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIraTppfXJlY2lwcm9jYWwoKXtsZXQgdD1udWxsLGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbDtpPTEvdGhpcy5faGkscj1BLlNQTElUKmksdD1yLWksbD1BLlNQTElUKnRoaXMuX2hpLHQ9ci10LGU9aS10LG49bC10aGlzLl9oaSxvPWkqdGhpcy5faGksbj1sLW4scz10aGlzLl9oaS1uLGw9dCpuLW8rdCpzK2UqbitlKnMscj0oMS1vLWwtaSp0aGlzLl9sbykvdGhpcy5faGk7Y29uc3QgYT1pK3I7cmV0dXJuIG5ldyBBKGEsaS1hK3IpfXRvU2NpTm90YXRpb24oKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBBLlNDSV9OT1RfWkVSTztjb25zdCB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMSxlKSxzPUEuU0NJX05PVF9FWFBPTkVOVF9DSEFSK2VbMF07aWYoXCIwXCI9PT1uLmNoYXJBdCgwKSl0aHJvdyBuZXcgRChcIkZvdW5kIGxlYWRpbmcgemVybzogXCIrbik7bGV0IGk9XCJcIjtuLmxlbmd0aD4xJiYoaT1uLnN1YnN0cmluZygxKSk7Y29uc3Qgcj1uLmNoYXJBdCgwKStcIi5cIitpO3JldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIityK3M6citzfWFicygpe3JldHVybiB0aGlzLmlzTmFOKCk/QS5OYU46dGhpcy5pc05lZ2F0aXZlKCk/dGhpcy5uZWdhdGUoKTpuZXcgQSh0aGlzKX1pc1Bvc2l0aXZlKCl7cmV0dXJuIHRoaXMuX2hpPjB8fDA9PT10aGlzLl9oaSYmdGhpcy5fbG8+MH1sdCh0KXtyZXR1cm4gdGhpcy5faGk8dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPHQuX2xvfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEEuY29weSh0aGlzKS5zZWxmQWRkKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBBLmNvcHkodGhpcykuc2VsZkFkZCh0KX19aW5pdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9oaT10LHRoaXMuX2xvPTB9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2hpPXQuX2hpLHRoaXMuX2xvPXQuX2xvfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9oaT10LHRoaXMuX2xvPWV9fWd0KHQpe3JldHVybiB0aGlzLl9oaT50Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG8+dC5fbG99aXNOZWdhdGl2ZSgpe3JldHVybiB0aGlzLl9oaTwwfHwwPT09dGhpcy5faGkmJnRoaXMuX2xvPDB9dHJ1bmMoKXtyZXR1cm4gdGhpcy5pc05hTigpP0EuTmFOOnRoaXMuaXNQb3NpdGl2ZSgpP3RoaXMuZmxvb3IoKTp0aGlzLmNlaWwoKX1zaWdudW0oKXtyZXR1cm4gdGhpcy5faGk+MD8xOnRoaXMuX2hpPDA/LTE6dGhpcy5fbG8+MD8xOnRoaXMuX2xvPDA/LTE6MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYyxvLGxdfX1BLlBJPW5ldyBBKDMuMTQxNTkyNjUzNTg5NzkzLDEyMjQ2NDY3OTkxNDczNTMyZS0zMiksQS5UV09fUEk9bmV3IEEoNi4yODMxODUzMDcxNzk1ODYsMjQ0OTI5MzU5ODI5NDcwNjRlLTMyKSxBLlBJXzI9bmV3IEEoMS41NzA3OTYzMjY3OTQ4OTY2LDYxMjMyMzM5OTU3MzY3NjZlLTMyKSxBLkU9bmV3IEEoMi43MTgyODE4Mjg0NTkwNDUsMTQ0NTY0Njg5MTcyOTI1MDJlLTMyKSxBLk5hTj1uZXcgQShyLk5hTixyLk5hTiksQS5FUFM9MTIzMjU5NTE2NDQwNzgzZS00NixBLlNQTElUPTEzNDIxNzcyOSxBLk1BWF9QUklOVF9ESUdJVFM9MzIsQS5URU49QS52YWx1ZU9mKDEwKSxBLk9ORT1BLnZhbHVlT2YoMSksQS5TQ0lfTk9UX0VYUE9ORU5UX0NIQVI9XCJFXCIsQS5TQ0lfTk9UX1pFUk89XCIwLjBFMFwiO2NsYXNzIEZ7c3RhdGljIG9yaWVudGF0aW9uSW5kZXgodCxlLG4pe2NvbnN0IHM9Ri5vcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKTtpZihzPD0xKXJldHVybiBzO2NvbnN0IGk9QS52YWx1ZU9mKGUueCkuc2VsZkFkZCgtdC54KSxyPUEudmFsdWVPZihlLnkpLnNlbGZBZGQoLXQueSksbz1BLnZhbHVlT2Yobi54KS5zZWxmQWRkKC1lLngpLGw9QS52YWx1ZU9mKG4ueSkuc2VsZkFkZCgtZS55KTtyZXR1cm4gaS5zZWxmTXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHIuc2VsZk11bHRpcGx5KG8pKS5zaWdudW0oKX1zdGF0aWMgc2lnbk9mRGV0MngyKCl7aWYoYXJndW1lbnRzWzNdaW5zdGFuY2VvZiBBJiZhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEEmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXTtyZXR1cm4gYXJndW1lbnRzWzBdLm11bHRpcGx5KG4pLnNlbGZTdWJ0cmFjdCh0Lm11bHRpcGx5KGUpKS5zaWdudW0oKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPUEudmFsdWVPZih0KSxyPUEudmFsdWVPZihlKSxvPUEudmFsdWVPZihuKSxsPUEudmFsdWVPZihzKTtyZXR1cm4gaS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoci5tdWx0aXBseShvKSkuc2lnbnVtKCl9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1uZXcgQSh0LnkpLnNlbGZTdWJ0cmFjdChlLnkpLG89bmV3IEEoZS54KS5zZWxmU3VidHJhY3QodC54KSxsPW5ldyBBKHQueCkuc2VsZk11bHRpcGx5KGUueSkuc2VsZlN1YnRyYWN0KG5ldyBBKGUueCkuc2VsZk11bHRpcGx5KHQueSkpLGE9bmV3IEEobi55KS5zZWxmU3VidHJhY3Qocy55KSxjPW5ldyBBKHMueCkuc2VsZlN1YnRyYWN0KG4ueCksaD1uZXcgQShuLngpLnNlbGZNdWx0aXBseShzLnkpLnNlbGZTdWJ0cmFjdChuZXcgQShzLngpLnNlbGZNdWx0aXBseShuLnkpKSx1PW8ubXVsdGlwbHkoaCkuc2VsZlN1YnRyYWN0KGMubXVsdGlwbHkobCkpLGc9YS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3QoaS5tdWx0aXBseShoKSksZD1pLm11bHRpcGx5KGMpLnNlbGZTdWJ0cmFjdChhLm11bHRpcGx5KG8pKSxfPXUuc2VsZkRpdmlkZShkKS5kb3VibGVWYWx1ZSgpLHA9Zy5zZWxmRGl2aWRlKGQpLmRvdWJsZVZhbHVlKCk7cmV0dXJuIHIuaXNOYU4oXyl8fHIuaXNJbmZpbml0ZShfKXx8ci5pc05hTihwKXx8ci5pc0luZmluaXRlKHApP251bGw6bmV3IG0oXyxwKX1zdGF0aWMgb3JpZW50YXRpb25JbmRleEZpbHRlcih0LGUsbil7bGV0IHM9bnVsbDtjb25zdCBpPSh0Lngtbi54KSooZS55LW4ueSkscj0odC55LW4ueSkqKGUueC1uLngpLG89aS1yO2lmKGk+MCl7aWYocjw9MClyZXR1cm4gRi5zaWdudW0obyk7cz1pK3J9ZWxzZXtpZighKGk8MCkpcmV0dXJuIEYuc2lnbnVtKG8pO2lmKHI+PTApcmV0dXJuIEYuc2lnbnVtKG8pO3M9LWktcn1jb25zdCBsPUYuRFBfU0FGRV9FUFNJTE9OKnM7cmV0dXJuIG8+PWx8fC1vPj1sP0Yuc2lnbnVtKG8pOjJ9c3RhdGljIHNpZ251bSh0KXtyZXR1cm4gdD4wPzE6dDwwPy0xOjB9fUYuRFBfU0FGRV9FUFNJTE9OPTFlLTE1O2NsYXNzIEd7Z2V0TSh0KXtpZih0aGlzLmhhc00oKSl7Y29uc3QgZT10aGlzLmdldERpbWVuc2lvbigpLXRoaXMuZ2V0TWVhc3VyZXMoKTtyZXR1cm4gdGhpcy5nZXRPcmRpbmF0ZSh0LGUpfXJldHVybiByLk5hTn1zZXRPcmRpbmF0ZSh0LGUsbil7fWdldFoodCl7cmV0dXJuIHRoaXMuaGFzWigpP3RoaXMuZ2V0T3JkaW5hdGUodCwyKTpyLk5hTn1zaXplKCl7fWdldE9yZGluYXRlKHQsZSl7fWdldENvb3JkaW5hdGUoKXt9Z2V0Q29vcmRpbmF0ZUNvcHkodCl7fWNyZWF0ZUNvb3JkaW5hdGUoKXt9Z2V0RGltZW5zaW9uKCl7fWhhc00oKXtyZXR1cm4gdGhpcy5nZXRNZWFzdXJlcygpPjB9Z2V0WCh0KXt9aGFzWigpe3JldHVybiB0aGlzLmdldERpbWVuc2lvbigpLXRoaXMuZ2V0TWVhc3VyZXMoKT4yfWdldE1lYXN1cmVzKCl7cmV0dXJuIDB9ZXhwYW5kRW52ZWxvcGUodCl7fWNvcHkoKXt9Z2V0WSh0KXt9dG9Db29yZGluYXRlQXJyYXkoKXt9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1HLlg9MCxHLlk9MSxHLlo9MixHLk09MztjbGFzcyBxe3N0YXRpYyBpbmRleCh0LGUsbil7cmV0dXJuIEYub3JpZW50YXRpb25JbmRleCh0LGUsbil9c3RhdGljIGlzQ0NXKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10Lmxlbmd0aC0xO2lmKGU8Myl0aHJvdyBuZXcgcyhcIlJpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkXCIpO2xldCBuPXRbMF0saT0wO2ZvcihsZXQgcz0xO3M8PWU7cysrKXtjb25zdCBlPXRbc107ZS55Pm4ueSYmKG49ZSxpPXMpfWxldCByPWk7ZG97ci09MSxyPDAmJihyPWUpfXdoaWxlKHRbcl0uZXF1YWxzMkQobikmJnIhPT1pKTtsZXQgbz1pO2Rve289KG8rMSklZX13aGlsZSh0W29dLmVxdWFsczJEKG4pJiZvIT09aSk7Y29uc3QgbD10W3JdLGE9dFtvXTtpZihsLmVxdWFsczJEKG4pfHxhLmVxdWFsczJEKG4pfHxsLmVxdWFsczJEKGEpKXJldHVybiExO2NvbnN0IGM9cS5pbmRleChsLG4sYSk7bGV0IGg9bnVsbDtyZXR1cm4gaD0wPT09Yz9sLng+YS54OmM+MCxofWlmKEkoYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpLTE7aWYoZTwzKXRocm93IG5ldyBzKFwiUmluZyBoYXMgZmV3ZXIgdGhhbiA0IHBvaW50cywgc28gb3JpZW50YXRpb24gY2Fubm90IGJlIGRldGVybWluZWRcIik7bGV0IG49dC5nZXRDb29yZGluYXRlKDApLGk9MDtmb3IobGV0IHM9MTtzPD1lO3MrKyl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUocyk7ZS55Pm4ueSYmKG49ZSxpPXMpfWxldCByPW51bGwsbz1pO2Rve28tPTEsbzwwJiYobz1lKSxyPXQuZ2V0Q29vcmRpbmF0ZShvKX13aGlsZShyLmVxdWFsczJEKG4pJiZvIT09aSk7bGV0IGw9bnVsbCxhPWk7ZG97YT0oYSsxKSVlLGw9dC5nZXRDb29yZGluYXRlKGEpfXdoaWxlKGwuZXF1YWxzMkQobikmJmEhPT1pKTtpZihyLmVxdWFsczJEKG4pfHxsLmVxdWFsczJEKG4pfHxyLmVxdWFsczJEKGwpKXJldHVybiExO2NvbnN0IGM9cS5pbmRleChyLG4sbCk7bGV0IGg9bnVsbDtyZXR1cm4gaD0wPT09Yz9yLng+bC54OmM+MCxofX19cS5DTE9DS1dJU0U9LTEscS5SSUdIVD1xLkNMT0NLV0lTRSxxLkNPVU5URVJDTE9DS1dJU0U9MSxxLkxFRlQ9cS5DT1VOVEVSQ0xPQ0tXSVNFLHEuQ09MTElORUFSPTAscS5TVFJBSUdIVD1xLkNPTExJTkVBUjtjbGFzcyBCe3N0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT10Lng8ZS54P3QueDplLngsbz10Lnk8ZS55P3QueTplLnksbD10Lng+ZS54P3QueDplLngsYT10Lnk+ZS55P3QueTplLnksYz1uLng8cy54P24ueDpzLngsaD1uLnk8cy55P24ueTpzLnksdT1uLng+cy54P24ueDpzLngsZz1uLnk+cy55P24ueTpzLnksZD0oKGk+Yz9pOmMpKyhsPHU/bDp1KSkvMixfPSgobz5oP286aCkrKGE8Zz9hOmcpKS8yLHA9dC54LWQsZj10LnktXyx5PWUueC1kLHg9ZS55LV8sRT1uLngtZCxJPW4ueS1fLE49cy54LWQsdz1zLnktXyxDPWYteCxTPXktcCxMPXAqeC15KmYsVD1JLXcsUj1OLUUsUD1FKnctTipJLE89QypSLVQqUyx2PShTKlAtUipMKS9PLGI9KFQqTC1DKlApL087cmV0dXJuIHIuaXNOYU4odil8fHIuaXNJbmZpbml0ZSh2KXx8ci5pc05hTihiKXx8ci5pc0luZmluaXRlKGIpP251bGw6bmV3IG0oditkLGIrXyl9fWNsYXNzIFl7c3RhdGljIGFycmF5Y29weSh0LGUsbixzLGkpe2xldCByPTA7Zm9yKGxldCBvPWU7bzxlK2k7bysrKW5bcytyXT10W29dLHIrK31zdGF0aWMgZ2V0UHJvcGVydHkodCl7cmV0dXJue1wibGluZS5zZXBhcmF0b3JcIjpcIlxcblwifVt0XX19Y2xhc3MgVntzdGF0aWMgbG9nMTAodCl7Y29uc3QgZT1NYXRoLmxvZyh0KTtyZXR1cm4gci5pc0luZmluaXRlKGUpfHxyLmlzTmFOKGUpP2U6ZS9WLkxPR18xMH1zdGF0aWMgbWluKHQsZSxuLHMpe2xldCBpPXQ7cmV0dXJuIGU8aSYmKGk9ZSksbjxpJiYoaT1uKSxzPGkmJihpPXMpLGl9c3RhdGljIGNsYW1wKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQ8ZT9lOnQ+bj9uOnR9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQ8ZT9lOnQ+bj9uOnR9fXN0YXRpYyB3cmFwKHQsZSl7cmV0dXJuIHQ8MD9lLSAtdCVlOnQlZX1zdGF0aWMgbWF4KCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO2xldCBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdD5uJiYobj10KSxlPm4mJihuPWUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdO2xldCBzPWFyZ3VtZW50c1swXTtyZXR1cm4gdD5zJiYocz10KSxlPnMmJihzPWUpLG4+cyYmKHM9biksc319c3RhdGljIGF2ZXJhZ2UodCxlKXtyZXR1cm4odCtlKS8yfX1WLkxPR18xMD1NYXRoLmxvZygxMCk7Y2xhc3MgentzdGF0aWMgc2VnbWVudFRvU2VnbWVudCh0LGUsbixzKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gei5wb2ludFRvU2VnbWVudCh0LG4scyk7aWYobi5lcXVhbHMocykpcmV0dXJuIHoucG9pbnRUb1NlZ21lbnQocyx0LGUpO2xldCBpPSExO2lmKE8uaW50ZXJzZWN0cyh0LGUsbixzKSl7Y29uc3Qgcj0oZS54LXQueCkqKHMueS1uLnkpLShlLnktdC55KSoocy54LW4ueCk7aWYoMD09PXIpaT0hMDtlbHNle2NvbnN0IG89KHQueS1uLnkpKihzLngtbi54KS0odC54LW4ueCkqKHMueS1uLnkpLGw9KCh0Lnktbi55KSooZS54LXQueCktKHQueC1uLngpKihlLnktdC55KSkvcixhPW8vcjsoYTwwfHxhPjF8fGw8MHx8bD4xKSYmKGk9ITApfX1lbHNlIGk9ITA7cmV0dXJuIGk/Vi5taW4oei5wb2ludFRvU2VnbWVudCh0LG4scyksei5wb2ludFRvU2VnbWVudChlLG4scyksei5wb2ludFRvU2VnbWVudChuLHQsZSksei5wb2ludFRvU2VnbWVudChzLHQsZSkpOjB9c3RhdGljIHBvaW50VG9TZWdtZW50KHQsZSxuKXtpZihlLng9PT1uLngmJmUueT09PW4ueSlyZXR1cm4gdC5kaXN0YW5jZShlKTtjb25zdCBzPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxpPSgodC54LWUueCkqKG4ueC1lLngpKyh0LnktZS55KSoobi55LWUueSkpL3M7aWYoaTw9MClyZXR1cm4gdC5kaXN0YW5jZShlKTtpZihpPj0xKXJldHVybiB0LmRpc3RhbmNlKG4pO2NvbnN0IHI9KChlLnktdC55KSoobi54LWUueCktKGUueC10LngpKihuLnktZS55KSkvcztyZXR1cm4gTWF0aC5hYnMocikqTWF0aC5zcXJ0KHMpfXN0YXRpYyBwb2ludFRvTGluZVBlcnBlbmRpY3VsYXIodCxlLG4pe2NvbnN0IHM9KG4ueC1lLngpKihuLngtZS54KSsobi55LWUueSkqKG4ueS1lLnkpLGk9KChlLnktdC55KSoobi54LWUueCktKGUueC10LngpKihuLnktZS55KSkvcztyZXR1cm4gTWF0aC5hYnMoaSkqTWF0aC5zcXJ0KHMpfXN0YXRpYyBwb2ludFRvU2VnbWVudFN0cmluZyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgcyhcIkxpbmUgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB2ZXJ0ZXhcIik7bGV0IG49dC5kaXN0YW5jZShlWzBdKTtmb3IobGV0IHM9MDtzPGUubGVuZ3RoLTE7cysrKXtjb25zdCBpPXoucG9pbnRUb1NlZ21lbnQodCxlW3NdLGVbcysxXSk7aTxuJiYobj1pKX1yZXR1cm4gbn19Y2xhc3MgWHtjcmVhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5fHxJKGFyZ3VtZW50c1swXSxHKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jcmVhdGUodCxlKX19fWNsYXNzIGt7ZmlsdGVyKHQpe319Y2xhc3MgVXtjb25zdHJ1Y3Rvcigpe1UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0dlb21ldHJ5Q29sbGVjdGlvbigpe3JldHVybiB0aGlzLmdldFR5cGVDb2RlKCk9PT1VLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTn1nZXRGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2ZhY3Rvcnl9Z2V0R2VvbWV0cnlOKHQpe3JldHVybiB0aGlzfWdldEFyZWEoKXtyZXR1cm4gMH1pc1JlY3RhbmdsZSgpe3JldHVybiExfWVxdWFsc0V4YWN0KHQpe3JldHVybiB0aGlzPT09dHx8dGhpcy5lcXVhbHNFeGFjdCh0LDApfWdlb21ldHJ5Q2hhbmdlZCgpe3RoaXMuYXBwbHkoVS5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIpfWdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpe3RoaXMuX2VudmVsb3BlPW51bGx9ZXF1YWxzTm9ybSh0KXtyZXR1cm4gbnVsbCE9PXQmJnRoaXMubm9ybSgpLmVxdWFsc0V4YWN0KHQubm9ybSgpKX1nZXRMZW5ndGgoKXtyZXR1cm4gMH1nZXROdW1HZW9tZXRyaWVzKCl7cmV0dXJuIDF9Y29tcGFyZVRvKCl7bGV0IHQ7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9YXJndW1lbnRzWzBdO3JldHVybiB0PWUsdGhpcy5nZXRUeXBlQ29kZSgpIT09dC5nZXRUeXBlQ29kZSgpP3RoaXMuZ2V0VHlwZUNvZGUoKS10LmdldFR5cGVDb2RlKCk6dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6dC5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhlKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHQ9ZSx0aGlzLmdldFR5cGVDb2RlKCkhPT10LmdldFR5cGVDb2RlKCk/dGhpcy5nZXRUeXBlQ29kZSgpLXQuZ2V0VHlwZUNvZGUoKTp0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTp0LmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKGUsbil9fWdldFVzZXJEYXRhKCl7cmV0dXJuIHRoaXMuX3VzZXJEYXRhfWdldFNSSUQoKXtyZXR1cm4gdGhpcy5fU1JJRH1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1zdGF0aWMgY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCl7aWYodC5nZXRUeXBlQ29kZSgpPT09VS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT04pdGhyb3cgbmV3IHMoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIil9ZXF1YWwodCxlLG4pe3JldHVybiAwPT09bj90LmVxdWFscyhlKTp0LmRpc3RhbmNlKGUpPD1ufW5vcm0oKXtjb25zdCB0PXRoaXMuY29weSgpO3JldHVybiB0Lm5vcm1hbGl6ZSgpLHR9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5yZXZlcnNlSW50ZXJuYWwoKTtyZXR1cm4gbnVsbCE9dGhpcy5lbnZlbG9wZSYmKHQuZW52ZWxvcGU9dGhpcy5lbnZlbG9wZS5jb3B5KCkpLHQuc2V0U1JJRCh0aGlzLmdldFNSSUQoKSksdH1jb3B5KCl7Y29uc3QgdD10aGlzLmNvcHlJbnRlcm5hbCgpO3JldHVybiB0LmVudmVsb3BlPW51bGw9PXRoaXMuX2VudmVsb3BlP251bGw6dGhpcy5fZW52ZWxvcGUuY29weSgpLHQuX1NSSUQ9dGhpcy5fU1JJRCx0Ll91c2VyRGF0YT10aGlzLl91c2VyRGF0YSx0fWdldFByZWNpc2lvbk1vZGVsKCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX1nZXRFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lbnZlbG9wZSYmKHRoaXMuX2VudmVsb3BlPXRoaXMuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKSksbmV3IE8odGhpcy5fZW52ZWxvcGUpfXNldFNSSUQodCl7dGhpcy5fU1JJRD10fXNldFVzZXJEYXRhKHQpe3RoaXMuX3VzZXJEYXRhPXR9Y29tcGFyZSh0LGUpe2NvbnN0IG49dC5pdGVyYXRvcigpLHM9ZS5pdGVyYXRvcigpO2Zvcig7bi5oYXNOZXh0KCkmJnMuaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxlPXMubmV4dCgpLGk9dC5jb21wYXJlVG8oZSk7aWYoMCE9PWkpcmV0dXJuIGl9cmV0dXJuIG4uaGFzTmV4dCgpPzE6cy5oYXNOZXh0KCk/LTE6MH1oYXNoQ29kZSgpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpfWlzRXF1aXZhbGVudENsYXNzKHQpe3JldHVybiB0aGlzLmdldFR5cGVDb2RlKCk9PXQuZ2V0VHlwZUNvZGUoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbCxvLGNdfWdldENsYXNzKCl7cmV0dXJuIFV9c3RhdGljIGhhc05vbkVtcHR5RWxlbWVudHModCl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIXRbZV0uaXNFbXB0eSgpKXJldHVybiEwO3JldHVybiExfXN0YXRpYyBoYXNOdWxsRWxlbWVudHModCl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYobnVsbD09PXRbZV0pcmV0dXJuITA7cmV0dXJuITF9fVUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKHQpe3QmJih0aGlzLl9lbnZlbG9wZT1udWxsLHRoaXMuX3VzZXJEYXRhPW51bGwsdGhpcy5fZmFjdG9yeT10LHRoaXMuX1NSSUQ9dC5nZXRTUklEKCkpfSxVLlRZUEVDT0RFX1BPSU5UPTAsVS5UWVBFQ09ERV9NVUxUSVBPSU5UPTEsVS5UWVBFQ09ERV9MSU5FU1RSSU5HPTIsVS5UWVBFQ09ERV9MSU5FQVJSSU5HPTMsVS5UWVBFQ09ERV9NVUxUSUxJTkVTVFJJTkc9NCxVLlRZUEVDT0RFX1BPTFlHT049NSxVLlRZUEVDT0RFX01VTFRJUE9MWUdPTj02LFUuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OPTcsVS5UWVBFTkFNRV9QT0lOVD1cIlBvaW50XCIsVS5UWVBFTkFNRV9NVUxUSVBPSU5UPVwiTXVsdGlQb2ludFwiLFUuVFlQRU5BTUVfTElORVNUUklORz1cIkxpbmVTdHJpbmdcIixVLlRZUEVOQU1FX0xJTkVBUlJJTkc9XCJMaW5lYXJSaW5nXCIsVS5UWVBFTkFNRV9NVUxUSUxJTkVTVFJJTkc9XCJNdWx0aUxpbmVTdHJpbmdcIixVLlRZUEVOQU1FX1BPTFlHT049XCJQb2x5Z29uXCIsVS5UWVBFTkFNRV9NVUxUSVBPTFlHT049XCJNdWx0aVBvbHlnb25cIixVLlRZUEVOQU1FX0dFT01FVFJZQ09MTEVDVElPTj1cIkdlb21ldHJ5Q29sbGVjdGlvblwiLFUuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyPXtnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119LGZpbHRlcih0KXt0Lmdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpfX07Y2xhc3MgSHtmaWx0ZXIodCl7fX1jbGFzcyBXe3N0YXRpYyBvZkxpbmUodCl7Y29uc3QgZT10LnNpemUoKTtpZihlPD0xKXJldHVybiAwO2xldCBuPTA7Y29uc3Qgcz1uZXcgbTt0LmdldENvb3JkaW5hdGUoMCxzKTtsZXQgaT1zLngscj1zLnk7Zm9yKGxldCBvPTE7bzxlO28rKyl7dC5nZXRDb29yZGluYXRlKG8scyk7Y29uc3QgZT1zLngsbD1zLnksYT1lLWksYz1sLXI7bis9TWF0aC5zcXJ0KGEqYStjKmMpLGk9ZSxyPWx9cmV0dXJuIG59fWNsYXNzIFp7fWNsYXNzIGp7c3RhdGljIGNvcHlDb29yZCh0LGUsbixzKXtjb25zdCBpPU1hdGgubWluKHQuZ2V0RGltZW5zaW9uKCksbi5nZXREaW1lbnNpb24oKSk7Zm9yKGxldCByPTA7cjxpO3IrKyluLnNldE9yZGluYXRlKHMscix0LmdldE9yZGluYXRlKGUscikpfXN0YXRpYyBpc1JpbmcodCl7Y29uc3QgZT10LnNpemUoKTtyZXR1cm4gMD09PWV8fCEoZTw9MykmJih0LmdldE9yZGluYXRlKDAsRy5YKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEcuWCkmJnQuZ2V0T3JkaW5hdGUoMCxHLlkpPT09dC5nZXRPcmRpbmF0ZShlLTEsRy5ZKSl9c3RhdGljIHNjcm9sbCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxHKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtqLnNjcm9sbCh0LGUsai5pc1JpbmcodCkpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sRykmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1qLmluZGV4T2YoZSx0KTtpZihuPD0wKXJldHVybiBudWxsO2ouc2Nyb2xsKHQsbil9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGU8PTApcmV0dXJuIG51bGw7Y29uc3Qgcz10LmNvcHkoKSxpPW4/dC5zaXplKCktMTp0LnNpemUoKTtmb3IobGV0IG49MDtuPGk7bisrKWZvcihsZXQgcj0wO3I8dC5nZXREaW1lbnNpb24oKTtyKyspdC5zZXRPcmRpbmF0ZShuLHIscy5nZXRPcmRpbmF0ZSgoZStuKSVpLHIpKTtpZihuKWZvcihsZXQgZT0wO2U8dC5nZXREaW1lbnNpb24oKTtlKyspdC5zZXRPcmRpbmF0ZShpLGUsdC5nZXRPcmRpbmF0ZSgwLGUpKX19c3RhdGljIGlzRXF1YWwodCxlKXtjb25zdCBuPXQuc2l6ZSgpO2lmKG4hPT1lLnNpemUoKSlyZXR1cm4hMTtjb25zdCBzPU1hdGgubWluKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSk7Zm9yKGxldCBpPTA7aTxuO2krKylmb3IobGV0IG49MDtuPHM7bisrKXtjb25zdCBzPXQuZ2V0T3JkaW5hdGUoaSxuKSxvPWUuZ2V0T3JkaW5hdGUoaSxuKTtpZih0LmdldE9yZGluYXRlKGksbikhPT1lLmdldE9yZGluYXRlKGksbikmJighci5pc05hTihzKXx8IXIuaXNOYU4obykpKXJldHVybiExfXJldHVybiEwfXN0YXRpYyBtaW5Db29yZGluYXRlSW5kZXgoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGoubWluQ29vcmRpbmF0ZUluZGV4KHQsMCx0LnNpemUoKS0xKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl07bGV0IG49LTEscz1udWxsO2ZvcihsZXQgaT1hcmd1bWVudHNbMV07aTw9ZTtpKyspe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKGkpOyhudWxsPT09c3x8cy5jb21wYXJlVG8oZSk+MCkmJihzPWUsbj1pKX1yZXR1cm4gbn19c3RhdGljIGV4dGVuZCh0LGUsbil7Y29uc3Qgcz10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLGk9ZS5zaXplKCk7aWYoai5jb3B5KGUsMCxzLDAsaSksaT4wKWZvcihsZXQgdD1pO3Q8bjt0Kyspai5jb3B5KGUsaS0xLHMsdCwxKTtyZXR1cm4gc31zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQuc2l6ZSgpLTEsbj1NYXRoLnRydW5jKGUvMik7Zm9yKGxldCBzPTA7czw9bjtzKyspai5zd2FwKHQscyxlLXMpfXN0YXRpYyBzd2FwKHQsZSxuKXtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IobGV0IHM9MDtzPHQuZ2V0RGltZW5zaW9uKCk7cysrKXtjb25zdCBpPXQuZ2V0T3JkaW5hdGUoZSxzKTt0LnNldE9yZGluYXRlKGUscyx0LmdldE9yZGluYXRlKG4scykpLHQuc2V0T3JkaW5hdGUobixzLGkpfX1zdGF0aWMgY29weSh0LGUsbixzLGkpe2ZvcihsZXQgcj0wO3I8aTtyKyspai5jb3B5Q29vcmQodCxlK3IsbixzK3IpfXN0YXRpYyBlbnN1cmVWYWxpZFJpbmcodCxlKXtjb25zdCBuPWUuc2l6ZSgpO2lmKDA9PT1uKXJldHVybiBlO2lmKG48PTMpcmV0dXJuIGouY3JlYXRlQ2xvc2VkUmluZyh0LGUsNCk7cmV0dXJuIGUuZ2V0T3JkaW5hdGUoMCxHLlgpPT09ZS5nZXRPcmRpbmF0ZShuLTEsRy5YKSYmZS5nZXRPcmRpbmF0ZSgwLEcuWSk9PT1lLmdldE9yZGluYXRlKG4tMSxHLlkpP2U6ai5jcmVhdGVDbG9zZWRSaW5nKHQsZSxuKzEpfXN0YXRpYyBpbmRleE9mKHQsZSl7Zm9yKGxldCBuPTA7bjxlLnNpemUoKTtuKyspaWYodC54PT09ZS5nZXRPcmRpbmF0ZShuLEcuWCkmJnQueT09PWUuZ2V0T3JkaW5hdGUobixHLlkpKXJldHVybiBuO3JldHVybi0xfXN0YXRpYyBjcmVhdGVDbG9zZWRSaW5nKHQsZSxuKXtjb25zdCBzPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSksaT1lLnNpemUoKTtqLmNvcHkoZSwwLHMsMCxpKTtmb3IobGV0IHQ9aTt0PG47dCsrKWouY29weShlLDAscyx0LDEpO3JldHVybiBzfXN0YXRpYyBtaW5Db29yZGluYXRlKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlKG4pOyhudWxsPT09ZXx8ZS5jb21wYXJlVG8ocyk+MCkmJihlPXMpfXJldHVybiBlfX1jbGFzcyBLIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uOkt9KVswXX19Y2xhc3MgUXtzdGF0aWMgdG9EaW1lbnNpb25TeW1ib2wodCl7c3dpdGNoKHQpe2Nhc2UgUS5GQUxTRTpyZXR1cm4gUS5TWU1fRkFMU0U7Y2FzZSBRLlRSVUU6cmV0dXJuIFEuU1lNX1RSVUU7Y2FzZSBRLkRPTlRDQVJFOnJldHVybiBRLlNZTV9ET05UQ0FSRTtjYXNlIFEuUDpyZXR1cm4gUS5TWU1fUDtjYXNlIFEuTDpyZXR1cm4gUS5TWU1fTDtjYXNlIFEuQTpyZXR1cm4gUS5TWU1fQX10aHJvdyBuZXcgcyhcIlVua25vd24gZGltZW5zaW9uIHZhbHVlOiBcIit0KX1zdGF0aWMgdG9EaW1lbnNpb25WYWx1ZSh0KXtzd2l0Y2goTS50b1VwcGVyQ2FzZSh0KSl7Y2FzZSBRLlNZTV9GQUxTRTpyZXR1cm4gUS5GQUxTRTtjYXNlIFEuU1lNX1RSVUU6cmV0dXJuIFEuVFJVRTtjYXNlIFEuU1lNX0RPTlRDQVJFOnJldHVybiBRLkRPTlRDQVJFO2Nhc2UgUS5TWU1fUDpyZXR1cm4gUS5QO2Nhc2UgUS5TWU1fTDpyZXR1cm4gUS5MO2Nhc2UgUS5TWU1fQTpyZXR1cm4gUS5BfXRocm93IG5ldyBzKFwiVW5rbm93biBkaW1lbnNpb24gc3ltYm9sOiBcIit0KX19US5QPTAsUS5MPTEsUS5BPTIsUS5GQUxTRT0tMSxRLlRSVUU9LTIsUS5ET05UQ0FSRT0tMyxRLlNZTV9GQUxTRT1cIkZcIixRLlNZTV9UUlVFPVwiVFwiLFEuU1lNX0RPTlRDQVJFPVwiKlwiLFEuU1lNX1A9XCIwXCIsUS5TWU1fTD1cIjFcIixRLlNZTV9BPVwiMlwiO2NsYXNzIEp7ZmlsdGVyKHQpe319Y2xhc3MgJCBleHRlbmRzIFV7Y29uc3RydWN0b3IoKXtzdXBlcigpLCQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcG9pbnRzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1UuY29uc3RydWN0b3JfLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9fWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP25ldyBPOnRoaXMuX3BvaW50cy5leHBhbmRFbnZlbG9wZShuZXcgTyl9aXNSaW5nKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKSYmdGhpcy5pc1NpbXBsZSgpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3BvaW50cy50b0Nvb3JkaW5hdGVBcnJheSgpfWNvcHlJbnRlcm5hbCgpe3JldHVybiBuZXcgJCh0aGlzLl9wb2ludHMuY29weSgpLHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10O2lmKHRoaXMuX3BvaW50cy5zaXplKCkhPT1uLl9wb2ludHMuc2l6ZSgpKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcG9pbnRzLnNpemUoKTt0KyspaWYoIXRoaXMuZXF1YWwodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCksbi5fcG9pbnRzLmdldENvb3JkaW5hdGUodCksZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PE1hdGgudHJ1bmModGhpcy5fcG9pbnRzLnNpemUoKS8yKTt0Kyspe2NvbnN0IGU9dGhpcy5fcG9pbnRzLnNpemUoKS0xLXQ7aWYoIXRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLmVxdWFscyh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSkpe2lmKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLmNvbXBhcmVUbyh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSk+MCl7Y29uc3QgdD10aGlzLl9wb2ludHMuY29weSgpO2oucmV2ZXJzZSh0KSx0aGlzLl9wb2ludHM9dH1yZXR1cm4gbnVsbH19fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSgwKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/US5GQUxTRTowfWlzQ2xvc2VkKCl7cmV0dXJuIXRoaXMuaXNFbXB0eSgpJiZ0aGlzLmdldENvb3JkaW5hdGVOKDApLmVxdWFsczJEKHRoaXMuZ2V0Q29vcmRpbmF0ZU4odGhpcy5nZXROdW1Qb2ludHMoKS0xKSl9cmV2ZXJzZUludGVybmFsKCl7Y29uc3QgdD10aGlzLl9wb2ludHMuY29weSgpO3JldHVybiBqLnJldmVyc2UodCksdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0KX1nZXRFbmRQb2ludCgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9MSU5FU1RSSU5HfWdldERpbWVuc2lvbigpe3JldHVybiAxfWdldExlbmd0aCgpe3JldHVybiBXLm9mTGluZSh0aGlzLl9wb2ludHMpfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLl9wb2ludHMuc2l6ZSgpfWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT0wLG49MDtmb3IoO2U8dGhpcy5fcG9pbnRzLnNpemUoKSYmbjx0Ll9wb2ludHMuc2l6ZSgpOyl7Y29uc3Qgcz10aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKS5jb21wYXJlVG8odC5fcG9pbnRzLmdldENvb3JkaW5hdGUobikpO2lmKDAhPT1zKXJldHVybiBzO2UrKyxuKyt9cmV0dXJuIGU8dGhpcy5fcG9pbnRzLnNpemUoKT8xOm48dC5fcG9pbnRzLnNpemUoKT8tMTowfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzFdLmNvbXBhcmUodGhpcy5fcG9pbnRzLHQuX3BvaW50cyl9fWFwcGx5KCl7aWYoSShhcmd1bWVudHNbMF0sSCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKTtlKyspdC5maWx0ZXIodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLl9wb2ludHMuc2l6ZSgpKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKSYmKHQuZmlsdGVyKHRoaXMuX3BvaW50cyxlKSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxKKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLGspKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfX1nZXRCb3VuZGFyeSgpe3Rocm93IG5ldyBLfWlzRXF1aXZhbGVudENsYXNzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgJH1nZXRDb29yZGluYXRlTih0KXtyZXR1cm4gdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfTElORVNUUklOR31nZXRDb29yZGluYXRlU2VxdWVuY2UoKXtyZXR1cm4gdGhpcy5fcG9pbnRzfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX3BvaW50cy5zaXplKCl9aW5pdCh0KXtpZihudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLDE9PT10LnNpemUoKSl0aHJvdyBuZXcgcyhcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lU3RyaW5nIChmb3VuZCBcIit0LnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSAyKVwiKTt0aGlzLl9wb2ludHM9dH1pc0Nvb3JkaW5hdGUodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpO2UrKylpZih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKS5lcXVhbHModCkpcmV0dXJuITA7cmV0dXJuITF9Z2V0U3RhcnRQb2ludCgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKDApfWdldFBvaW50Tih0KXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltaXX19Y2xhc3MgdHR7fWNsYXNzIGV0IGV4dGVuZHMgVXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmRpbmF0ZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtVLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG5ldyBPO2NvbnN0IHQ9bmV3IE87cmV0dXJuIHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2Nvb3JkaW5hdGVzLmdldFgoMCksdGhpcy5fY29vcmRpbmF0ZXMuZ2V0WSgwKSksdH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9bXTpbdGhpcy5nZXRDb29yZGluYXRlKCldfWNvcHlJbnRlcm5hbCgpe3JldHVybiBuZXcgZXQodGhpcy5fY29vcmRpbmF0ZXMuY29weSgpLHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiYoISghdGhpcy5pc0VtcHR5KCl8fCF0LmlzRW1wdHkoKSl8fHRoaXMuaXNFbXB0eSgpPT09dC5pc0VtcHR5KCkmJnRoaXMuZXF1YWwodC5nZXRDb29yZGluYXRlKCksdGhpcy5nZXRDb29yZGluYXRlKCksZSkpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gMCE9PXRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKT90aGlzLl9jb29yZGluYXRlcy5nZXRDb29yZGluYXRlKDApOm51bGx9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gUS5GQUxTRX1yZXZlcnNlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY29vcmRpbmF0ZXMuY29weSgpKX1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX1BPSU5UfWdldERpbWVuc2lvbigpe3JldHVybiAwfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8wOjF9Z2V0WCgpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgRChcImdldFggY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS54fWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1sxXS5jb21wYXJlKHRoaXMuX2Nvb3JkaW5hdGVzLHQuX2Nvb3JkaW5hdGVzKX19YXBwbHkoKXtpZihJKGFyZ3VtZW50c1swXSxIKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuX2Nvb3JkaW5hdGVzLDApLHQuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEopKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX1BPSU5UfWdldENvb3JkaW5hdGVTZXF1ZW5jZSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc31nZXRZKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBEKFwiZ2V0WSBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnl9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpfWluaXQodCl7bnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSxnLmlzVHJ1ZSh0LnNpemUoKTw9MSksdGhpcy5fY29vcmRpbmF0ZXM9dH1pc1NpbXBsZSgpe3JldHVybiEwfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblt0dF19fWNsYXNzIG50e3N0YXRpYyBvZlJpbmcoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hYnMobnQub2ZSaW5nU2lnbmVkKHQpKX1pZihJKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYWJzKG50Lm9mUmluZ1NpZ25lZCh0KSl9fXN0YXRpYyBvZlJpbmdTaWduZWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0Lmxlbmd0aDwzKXJldHVybiAwO2xldCBlPTA7Y29uc3Qgbj10WzBdLng7Zm9yKGxldCBzPTE7czx0Lmxlbmd0aC0xO3MrKyl7Y29uc3QgaT10W3NdLngtbixyPXRbcysxXS55O2UrPWkqKHRbcy0xXS55LXIpfXJldHVybiBlLzJ9aWYoSShhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCk7aWYoZTwzKXJldHVybiAwO2NvbnN0IG49bmV3IG0scz1uZXcgbSxpPW5ldyBtO3QuZ2V0Q29vcmRpbmF0ZSgwLHMpLHQuZ2V0Q29vcmRpbmF0ZSgxLGkpO2NvbnN0IHI9cy54O2kueC09cjtsZXQgbz0wO2ZvcihsZXQgbD0xO2w8ZS0xO2wrKyluLnk9cy55LHMueD1pLngscy55PWkueSx0LmdldENvb3JkaW5hdGUobCsxLGkpLGkueC09cixvKz1zLngqKG4ueS1pLnkpO3JldHVybiBvLzJ9fX1jbGFzcyBzdHtzdGF0aWMgc29ydCgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXQuc29ydCgoKHQsZSk9PnQuY29tcGFyZVRvKGUpKSk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl0LnNvcnQoKCh0LGUpPT5hcmd1bWVudHNbMV0uY29tcGFyZSh0LGUpKSk7ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT10LnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO2Uuc29ydCgpO2NvbnN0IG49dC5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsdC5zbGljZShhcmd1bWVudHNbMl0sdC5sZW5ndGgpKTt0LnNwbGljZSgwLHQubGVuZ3RoKTtmb3IoY29uc3QgZSBvZiBuKXQucHVzaChlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPXQuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSk7ZS5zb3J0KCgodCxlKT0+YXJndW1lbnRzWzNdLmNvbXBhcmUodCxlKSkpO2NvbnN0IG49dC5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsdC5zbGljZShhcmd1bWVudHNbMl0sdC5sZW5ndGgpKTt0LnNwbGljZSgwLHQubGVuZ3RoKTtmb3IoY29uc3QgZSBvZiBuKXQucHVzaChlKX19c3RhdGljIGFzTGlzdCh0KXtjb25zdCBlPW5ldyBMO2Zvcihjb25zdCBuIG9mIHQpZS5hZGQobik7cmV0dXJuIGV9c3RhdGljIGNvcHlPZih0LGUpe3JldHVybiB0LnNsaWNlKDAsZSl9fWNsYXNzIGl0e31jbGFzcyBydCBleHRlbmRzIFV7Y29uc3RydWN0b3IoKXtzdXBlcigpLHJ0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NoZWxsPW51bGwsdGhpcy5faG9sZXM9bnVsbDtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoVS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG4pLG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKCkpLG51bGw9PT1lJiYoZT1bXSksVS5oYXNOdWxsRWxlbWVudHMoZSkpdGhyb3cgbmV3IHMoXCJob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7aWYodC5pc0VtcHR5KCkmJlUuaGFzTm9uRW1wdHlFbGVtZW50cyhlKSl0aHJvdyBuZXcgcyhcInNoZWxsIGlzIGVtcHR5IGJ1dCBob2xlcyBhcmUgbm90XCIpO3RoaXMuX3NoZWxsPXQsdGhpcy5faG9sZXM9ZX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiB0aGlzLl9zaGVsbC5nZXRFbnZlbG9wZUludGVybmFsKCl9Z2V0Q29vcmRpbmF0ZXMoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm5bXTtjb25zdCB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO2xldCBlPS0xO2NvbnN0IG49dGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyllKyssdFtlXT1uW3NdO2ZvcihsZXQgbj0wO248dGhpcy5faG9sZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10aGlzLl9ob2xlc1tuXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKWUrKyx0W2VdPXNbbl19cmV0dXJuIHR9Z2V0QXJlYSgpe2xldCB0PTA7dCs9bnQub2ZSaW5nKHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdC09bnQub2ZSaW5nKHRoaXMuX2hvbGVzW2VdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtyZXR1cm4gdH1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX3NoZWxsLmNvcHkoKSxlPW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKWVbdF09dGhpcy5faG9sZXNbdF0uY29weSgpO3JldHVybiBuZXcgcnQodCxlLHRoaXMuX2ZhY3RvcnkpfWlzUmVjdGFuZ2xlKCl7aWYoMCE9PXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCkpcmV0dXJuITE7aWYobnVsbD09PXRoaXMuX3NoZWxsKXJldHVybiExO2lmKDUhPT10aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKSlyZXR1cm4hMTtjb25zdCB0PXRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLGU9dGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCk7Zm9yKGxldCBuPTA7bjw1O24rKyl7Y29uc3Qgcz10LmdldFgobik7aWYocyE9PWUuZ2V0TWluWCgpJiZzIT09ZS5nZXRNYXhYKCkpcmV0dXJuITE7Y29uc3QgaT10LmdldFkobik7aWYoaSE9PWUuZ2V0TWluWSgpJiZpIT09ZS5nZXRNYXhZKCkpcmV0dXJuITF9bGV0IG49dC5nZXRYKDApLHM9dC5nZXRZKDApO2ZvcihsZXQgZT0xO2U8PTQ7ZSsrKXtjb25zdCBpPXQuZ2V0WChlKSxyPXQuZ2V0WShlKTtpZihpIT09bj09PShyIT09cykpcmV0dXJuITE7bj1pLHM9cn1yZXR1cm4hMH1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dCxzPXRoaXMuX3NoZWxsLGk9bi5fc2hlbGw7aWYoIXMuZXF1YWxzRXhhY3QoaSxlKSlyZXR1cm4hMTtpZih0aGlzLl9ob2xlcy5sZW5ndGghPT1uLl9ob2xlcy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9ob2xlc1t0XS5lcXVhbHNFeGFjdChuLl9ob2xlc1t0XSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLl9zaGVsbD10aGlzLm5vcm1hbGl6ZWQodGhpcy5fc2hlbGwsITApO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKyl0aGlzLl9ob2xlc1t0XT10aGlzLm5vcm1hbGl6ZWQodGhpcy5faG9sZXNbdF0sITEpO3N0LnNvcnQodGhpcy5faG9sZXMpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxzPWoubWluQ29vcmRpbmF0ZUluZGV4KG4sMCxuLnNpemUoKS0yKTtqLnNjcm9sbChuLHMsITApLHEuaXNDQ1cobik9PT1lJiZqLnJldmVyc2Uobil9fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZSgpfWdldE51bUludGVyaW9yUmluZygpe3JldHVybiB0aGlzLl9ob2xlcy5sZW5ndGh9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gMX1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkucmV2ZXJzZSgpLGU9bmV3IEFycmF5KHRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCkpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspZVt0XT10aGlzLmdldEludGVyaW9yUmluZ04odCkucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKHQsZSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gVS5UWVBFQ09ERV9QT0xZR09OfWdldERpbWVuc2lvbigpe3JldHVybiAyfWdldExlbmd0aCgpe2xldCB0PTA7dCs9dGhpcy5fc2hlbGwuZ2V0TGVuZ3RoKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2hvbGVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fWdldE51bVBvaW50cygpe2xldCB0PXRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9ob2xlc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH1jb252ZXhIdWxsKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpfW5vcm1hbGl6ZWQodCxlKXtjb25zdCBuPXQuY29weSgpO3JldHVybiB0aGlzLm5vcm1hbGl6ZShuLGUpLG59Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fc2hlbGwsbj10Ll9zaGVsbDtyZXR1cm4gZS5jb21wYXJlVG9TYW1lQ2xhc3Mobil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLG49dGhpcy5fc2hlbGwscz1lLl9zaGVsbCxpPW4uY29tcGFyZVRvU2FtZUNsYXNzKHMsdCk7aWYoMCE9PWkpcmV0dXJuIGk7Y29uc3Qgcj10aGlzLmdldE51bUludGVyaW9yUmluZygpLG89ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtsZXQgbD0wO2Zvcig7bDxyJiZsPG87KXtjb25zdCBuPXRoaXMuZ2V0SW50ZXJpb3JSaW5nTihsKSxzPWUuZ2V0SW50ZXJpb3JSaW5nTihsKSxpPW4uY29tcGFyZVRvU2FtZUNsYXNzKHMsdCk7aWYoMCE9PWkpcmV0dXJuIGk7bCsrfXJldHVybiBsPHI/MTpsPG8/LTE6MH19YXBwbHkoKXtpZihJKGFyZ3VtZW50c1swXSxIKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2hlbGwuYXBwbHkodCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX3NoZWxsLmFwcGx5KHQpLCF0LmlzRG9uZSgpKWZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoJiYodGhpcy5faG9sZXNbZV0uYXBwbHkodCksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sSikpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxrKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyksdGhpcy5fc2hlbGwuYXBwbHkodCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpfX1nZXRCb3VuZGFyeSgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgrMSkuZmlsbChudWxsKTt0WzBdPXRoaXMuX3NoZWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0W2UrMV09dGhpcy5faG9sZXNbZV07cmV0dXJuIHQubGVuZ3RoPD0xP3RoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodFswXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk6dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX1BPTFlHT059Z2V0RXh0ZXJpb3JSaW5nKCl7cmV0dXJuIHRoaXMuX3NoZWxsfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fc2hlbGwuaXNFbXB0eSgpfWdldEludGVyaW9yUmluZ04odCl7cmV0dXJuIHRoaXMuX2hvbGVzW3RdfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltpdF19fWNsYXNzIG90IGV4dGVuZHMgTntjb250YWlucygpe319Y2xhc3MgbHQgZXh0ZW5kcyBvdHt9Y2xhc3MgYXQgZXh0ZW5kcyBsdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuYXJyYXk9W10sdCBpbnN0YW5jZW9mIE4mJnRoaXMuYWRkQWxsKHQpfWNvbnRhaW5zKHQpe2Zvcihjb25zdCBlIG9mIHRoaXMuYXJyYXkpaWYoMD09PWUuY29tcGFyZVRvKHQpKXJldHVybiEwO3JldHVybiExfWFkZCh0KXtpZih0aGlzLmNvbnRhaW5zKHQpKXJldHVybiExO2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheS5sZW5ndGg7ZTxuO2UrKyl7aWYoMT09PXRoaXMuYXJyYXlbZV0uY29tcGFyZVRvKHQpKXJldHVybiEhdGhpcy5hcnJheS5zcGxpY2UoZSwwLHQpfXJldHVybiB0aGlzLmFycmF5LnB1c2godCksITB9YWRkQWxsKHQpe2Zvcihjb25zdCBlIG9mIHQpdGhpcy5hZGQoZSk7cmV0dXJuITB9cmVtb3ZlKCl7dGhyb3cgbmV3IEt9c2l6ZSgpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aH1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Lmxlbmd0aH10b0FycmF5KCl7cmV0dXJuIHRoaXMuYXJyYXkuc2xpY2UoKX1pdGVyYXRvcigpe3JldHVybiBuZXcgY3QodGhpcy5hcnJheSl9fWxldCBjdD1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmFycmF5PXQsdGhpcy5wb3NpdGlvbj0wfW5leHQoKXtpZih0aGlzLnBvc2l0aW9uPT09dGhpcy5hcnJheS5sZW5ndGgpdGhyb3cgbmV3IFM7cmV0dXJuIHRoaXMuYXJyYXlbdGhpcy5wb3NpdGlvbisrXX1oYXNOZXh0KCl7cmV0dXJuIHRoaXMucG9zaXRpb248dGhpcy5hcnJheS5sZW5ndGh9cmVtb3ZlKCl7dGhyb3cgbmV3IEt9fTtjbGFzcyBodCBleHRlbmRzIFV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGh0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb21ldHJpZXM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKFUuY29uc3RydWN0b3JfLmNhbGwodGhpcyxlKSxudWxsPT09dCYmKHQ9W10pLFUuaGFzTnVsbEVsZW1lbnRzKHQpKXRocm93IG5ldyBzKFwiZ2VvbWV0cmllcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7dGhpcy5fZ2VvbWV0cmllcz10fX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IE87Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiB0fWdldEdlb21ldHJ5Tih0KXtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1t0XX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7bGV0IGU9LTE7Zm9yKGxldCBuPTA7bjx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dGhpcy5fZ2VvbWV0cmllc1tuXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKWUrKyx0W2VdPXNbbl19cmV0dXJuIHR9Z2V0QXJlYSgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRBcmVhKCk7cmV0dXJuIHR9Y29weUludGVybmFsKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGh0KHQsdGhpcy5fZmFjdG9yeSl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQ7aWYodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGghPT1uLl9nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5lcXVhbHNFeGFjdChuLl9nZW9tZXRyaWVzW3RdLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspdGhpcy5fZ2VvbWV0cmllc1t0XS5ub3JtYWxpemUoKTtzdC5zb3J0KHRoaXMuX2dlb21ldHJpZXMpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLl9nZW9tZXRyaWVzWzBdLmdldENvb3JkaW5hdGUoKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe2xldCB0PVEuRkFMU0U7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSk7cmV0dXJuIHR9cmV2ZXJzZUludGVybmFsKCl7Y29uc3QgdD10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBMKHQpO2ZvcihsZXQgbj0wO248dDtuKyspZS5hZGQodGhpcy5fZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCkpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGUpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OfWdldERpbWVuc2lvbigpe2xldCB0PVEuRkFMU0U7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0RGltZW5zaW9uKCkpO3JldHVybiB0fWdldExlbmd0aCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH1nZXROdW1Qb2ludHMoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9Z2V0TnVtR2VvbWV0cmllcygpe3JldHVybiB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aH1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgYXQoc3QuYXNMaXN0KHRoaXMuX2dlb21ldHJpZXMpKSxuPW5ldyBhdChzdC5hc0xpc3QodC5fZ2VvbWV0cmllcykpO3JldHVybiB0aGlzLmNvbXBhcmUoZSxuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0sbj10aGlzLmdldE51bUdlb21ldHJpZXMoKSxzPWUuZ2V0TnVtR2VvbWV0cmllcygpO2xldCBpPTA7Zm9yKDtpPG4mJmk8czspe2NvbnN0IG49dGhpcy5nZXRHZW9tZXRyeU4oaSkscz1lLmdldEdlb21ldHJ5TihpKSxyPW4uY29tcGFyZVRvU2FtZUNsYXNzKHMsdCk7aWYoMCE9PXIpcmV0dXJuIHI7aSsrfXJldHVybiBpPG4/MTppPHM/LTE6MH19YXBwbHkoKXtpZihJKGFyZ3VtZW50c1swXSxIKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFApKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCYmKHRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sSikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxrKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KX19Z2V0Qm91bmRhcnkoKXtyZXR1cm4gVS5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSxnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCksbnVsbH1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9HRU9NRVRSWUNPTExFQ1RJT059aXNFbXB0eSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9nZW9tZXRyaWVzW3RdLmlzRW1wdHkoKSlyZXR1cm4hMTtyZXR1cm4hMH19Y2xhc3MgdXQgZXh0ZW5kcyBodHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfWNvcHlJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyB1dCh0LHRoaXMuX2ZhY3RvcnkpfWlzVmFsaWQoKXtyZXR1cm4hMH1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbdF0uZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiBzdXBlci5nZXRDb29yZGluYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiBRLkZBTFNFfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfTVVMVElQT0lOVH1nZXREaW1lbnNpb24oKXtyZXR1cm4gMH1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gVS5UWVBFTkFNRV9NVUxUSVBPSU5UfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblt0dF19fWNsYXNzIGd0IGV4dGVuZHMgJHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZ3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07JC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy52YWxpZGF0ZUNvbnN0cnVjdGlvbigpfWNvcHlJbnRlcm5hbCgpe3JldHVybiBuZXcgZ3QodGhpcy5fcG9pbnRzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiBRLkZBTFNFfWlzQ2xvc2VkKCl7cmV0dXJuISF0aGlzLmlzRW1wdHkoKXx8c3VwZXIuaXNDbG9zZWQuY2FsbCh0aGlzKX1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7cmV0dXJuIGoucmV2ZXJzZSh0KSx0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHQpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfTElORUFSUklOR312YWxpZGF0ZUNvbnN0cnVjdGlvbigpe2lmKCF0aGlzLmlzRW1wdHkoKSYmIXN1cGVyLmlzQ2xvc2VkLmNhbGwodGhpcykpdGhyb3cgbmV3IHMoXCJQb2ludHMgb2YgTGluZWFyUmluZyBkbyBub3QgZm9ybSBhIGNsb3NlZCBsaW5lc3RyaW5nXCIpO2lmKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPj0xJiZ0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKTxndC5NSU5JTVVNX1ZBTElEX1NJWkUpdGhyb3cgbmV3IHMoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZWFyUmluZyAoZm91bmQgXCIrdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gNClcIil9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfTElORUFSUklOR319Z3QuTUlOSU1VTV9WQUxJRF9TSVpFPTQ7Y2xhc3MgZHR7c3RhdGljIG1lYXN1cmVzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgeT8wOnQgaW5zdGFuY2VvZiB4fHx0IGluc3RhbmNlb2YgRT8xOjB9c3RhdGljIGRpbWVuc2lvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHk/Mjp0IGluc3RhbmNlb2YgeD8zOnQgaW5zdGFuY2VvZiBFPzQ6M31zdGF0aWMgY3JlYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBkdC5jcmVhdGUodCwwKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIDI9PT10P25ldyB5OjM9PT10JiYwPT09ZT9uZXcgbTozPT09dCYmMT09PWU/bmV3IHg6ND09PXQmJjE9PT1lP25ldyBFOm5ldyBtfX19Y2xhc3MgX3R7c3RhdGljIGlzUmluZyh0KXtyZXR1cm4hKHQubGVuZ3RoPDQpJiYhIXRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9c3RhdGljIHB0Tm90SW5MaXN0KHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHM9dFtuXTtpZihfdC5pbmRleE9mKHMsZSk8MClyZXR1cm4gc31yZXR1cm4gbnVsbH1zdGF0aWMgc2Nyb2xsKHQsZSl7Y29uc3Qgbj1fdC5pbmRleE9mKGUsdCk7aWYobjwwKXJldHVybiBudWxsO2NvbnN0IHM9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO1kuYXJyYXljb3B5KHQsbixzLDAsdC5sZW5ndGgtbiksWS5hcnJheWNvcHkodCwwLHMsdC5sZW5ndGgtbixuKSxZLmFycmF5Y29weShzLDAsdCwwLHQubGVuZ3RoKX1zdGF0aWMgZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09PXR8fG51bGw9PT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspaWYoMCE9PW4uY29tcGFyZSh0W3NdLGVbc10pKXJldHVybiExO3JldHVybiEwfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgUjtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyllLmludGVyc2VjdHModFtzXSkmJm4uYWRkKHRbc10sITApO3JldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIG1lYXN1cmVzKHQpe2lmKG51bGw9PT10fHwwPT09dC5sZW5ndGgpcmV0dXJuIDA7bGV0IGU9MDtmb3IoY29uc3QgbiBvZiB0KWU9TWF0aC5tYXgoZSxkdC5tZWFzdXJlcyhuKSk7cmV0dXJuIGV9c3RhdGljIGhhc1JlcGVhdGVkUG9pbnRzKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZS0xXS5lcXVhbHModFtlXSkpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIHJlbW92ZVJlcGVhdGVkUG9pbnRzKHQpe2lmKCFfdC5oYXNSZXBlYXRlZFBvaW50cyh0KSlyZXR1cm4gdDtyZXR1cm4gbmV3IFIodCwhMSkudG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQubGVuZ3RoLTEsbj1NYXRoLnRydW5jKGUvMik7Zm9yKGxldCBzPTA7czw9bjtzKyspe2NvbnN0IG49dFtzXTt0W3NdPXRbZS1zXSx0W2Utc109bn19c3RhdGljIHJlbW92ZU51bGwodCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyludWxsIT09dFtuXSYmZSsrO2NvbnN0IG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7aWYoMD09PWUpcmV0dXJuIG47bGV0IHM9MDtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyludWxsIT09dFtlXSYmKG5bcysrXT10W2VdKTtyZXR1cm4gbn1zdGF0aWMgY29weURlZXAoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT10W25dLmNvcHkoKTtyZXR1cm4gZX1pZig1PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF07Zm9yKGxldCByPTA7cjxpO3IrKyluW3Mrcl09dFtlK3JdLmNvcHkoKX19c3RhdGljIGlzRXF1YWxSZXZlcnNlZCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl0saT1lW3QubGVuZ3RoLW4tMV07aWYoMCE9PXMuY29tcGFyZVRvKGkpKXJldHVybiExfXJldHVybiEwfXN0YXRpYyBlbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBPO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWUuZXhwYW5kVG9JbmNsdWRlKHRbbl0pO3JldHVybiBlfXN0YXRpYyB0b0Nvb3JkaW5hdGVBcnJheSh0KXtyZXR1cm4gdC50b0FycmF5KF90LmNvb3JkQXJyYXlUeXBlKX1zdGF0aWMgZGltZW5zaW9uKHQpe2lmKG51bGw9PT10fHwwPT09dC5sZW5ndGgpcmV0dXJuIDM7bGV0IGU9MDtmb3IoY29uc3QgbiBvZiB0KWU9TWF0aC5tYXgoZSxkdC5kaW1lbnNpb24obikpO3JldHVybiBlfXN0YXRpYyBhdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nKHQsZSl7cmV0dXJuIGUubGVuZ3RoPj10P2U6W119c3RhdGljIGluZGV4T2YodCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylpZih0LmVxdWFscyhlW25dKSlyZXR1cm4gbjtyZXR1cm4tMX1zdGF0aWMgaW5jcmVhc2luZ0RpcmVjdGlvbih0KXtmb3IobGV0IGU9MDtlPE1hdGgudHJ1bmModC5sZW5ndGgvMik7ZSsrKXtjb25zdCBuPXQubGVuZ3RoLTEtZSxzPXRbZV0uY29tcGFyZVRvKHRbbl0pO2lmKDAhPT1zKXJldHVybiBzfXJldHVybiAxfXN0YXRpYyBjb21wYXJlKHQsZSl7bGV0IG49MDtmb3IoO248dC5sZW5ndGgmJm48ZS5sZW5ndGg7KXtjb25zdCBzPXRbbl0uY29tcGFyZVRvKGVbbl0pO2lmKDAhPT1zKXJldHVybiBzO24rK31yZXR1cm4gbjxlLmxlbmd0aD8tMTpuPHQubGVuZ3RoPzE6MH1zdGF0aWMgbWluQ29vcmRpbmF0ZSh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKShudWxsPT09ZXx8ZS5jb21wYXJlVG8odFtuXSk+MCkmJihlPXRbbl0pO3JldHVybiBlfXN0YXRpYyBleHRyYWN0KHQsZSxuKXtlPVYuY2xhbXAoZSwwLHQubGVuZ3RoKTtsZXQgcz0obj1WLmNsYW1wKG4sLTEsdC5sZW5ndGgpKS1lKzE7bjwwJiYocz0wKSxlPj10Lmxlbmd0aCYmKHM9MCksbjxlJiYocz0wKTtjb25zdCBpPW5ldyBBcnJheShzKS5maWxsKG51bGwpO2lmKDA9PT1zKXJldHVybiBpO2xldCByPTA7Zm9yKGxldCBzPWU7czw9bjtzKyspaVtyKytdPXRbc107cmV0dXJuIGl9fV90LkZvcndhcmRDb21wYXJhdG9yPWNsYXNze2NvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO3JldHVybiBfdC5jb21wYXJlKG4scyl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX0sX3QuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I9Y2xhc3N7Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7aWYobi5sZW5ndGg8cy5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+cy5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2NvbnN0IGk9X3QuY29tcGFyZShuLHMpO3JldHVybiBfdC5pc0VxdWFsUmV2ZXJzZWQobixzKT8wOml9T0xEY29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7aWYobi5sZW5ndGg8cy5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+cy5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2NvbnN0IGk9X3QuaW5jcmVhc2luZ0RpcmVjdGlvbihuKSxyPV90LmluY3JlYXNpbmdEaXJlY3Rpb24ocyk7bGV0IG89aT4wPzA6bi5sZW5ndGgtMSxsPXI+MD8wOm4ubGVuZ3RoLTE7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IHQ9bltvXS5jb21wYXJlVG8oc1tsXSk7aWYoMCE9PXQpcmV0dXJuIHQ7bys9aSxsKz1yfXJldHVybiAwfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19LF90LmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIHB0e2NvbnN0cnVjdG9yKHQpe3RoaXMuc3RyPXR9YXBwZW5kKHQpe3RoaXMuc3RyKz10fXNldENoYXJBdCh0LGUpe3RoaXMuc3RyPXRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5zdHJ9fWNsYXNzIG10e2NvbnN0cnVjdG9yKCl7bXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGltZW5zaW9uPTMsdGhpcy5fbWVhc3VyZXM9MCx0aGlzLl9jb29yZGluYXRlcz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTttdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsX3QuZGltZW5zaW9uKHQpLF90Lm1lYXN1cmVzKHQpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0O2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT1uZXcgbX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dClyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDt0aGlzLl9kaW1lbnNpb249dC5nZXREaW1lbnNpb24oKSx0aGlzLl9tZWFzdXJlcz10LmdldE1lYXN1cmVzKCksdGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT10LmdldENvb3JkaW5hdGVDb3B5KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO210LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLF90Lm1lYXN1cmVzKHQpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLl9kaW1lbnNpb249ZTtmb3IobGV0IG49MDtuPHQ7bisrKXRoaXMuX2Nvb3JkaW5hdGVzW25dPWR0LmNyZWF0ZShlKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZGltZW5zaW9uPWUsdGhpcy5fbWVhc3VyZXM9bix0aGlzLl9jb29yZGluYXRlcz1udWxsPT09dD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTp0fWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5fZGltZW5zaW9uPWUsdGhpcy5fbWVhc3VyZXM9bjtmb3IobGV0IGU9MDtlPHQ7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPXRoaXMuY3JlYXRlQ29vcmRpbmF0ZSgpfX1nZXRNKHQpe3JldHVybiB0aGlzLmhhc00oKT90aGlzLl9jb29yZGluYXRlc1t0XS5nZXRNKCk6ci5OYU59c2V0T3JkaW5hdGUodCxlLG4pe3N3aXRjaChlKXtjYXNlIEcuWDp0aGlzLl9jb29yZGluYXRlc1t0XS54PW47YnJlYWs7Y2FzZSBHLlk6dGhpcy5fY29vcmRpbmF0ZXNbdF0ueT1uO2JyZWFrO2RlZmF1bHQ6dGhpcy5fY29vcmRpbmF0ZXNbdF0uc2V0T3JkaW5hdGUoZSxuKX19Z2V0Wih0KXtyZXR1cm4gdGhpcy5oYXNaKCk/dGhpcy5fY29vcmRpbmF0ZXNbdF0uZ2V0WigpOnIuTmFOfXNpemUoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RofWdldE9yZGluYXRlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgRy5YOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS54O2Nhc2UgRy5ZOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS55O2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLmdldE9yZGluYXRlKGUpfX1nZXRDb29yZGluYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07YXJndW1lbnRzWzFdLnNldENvb3JkaW5hdGUodGhpcy5fY29vcmRpbmF0ZXNbdF0pfX1nZXRDb29yZGluYXRlQ29weSh0KXtjb25zdCBlPXRoaXMuY3JlYXRlQ29vcmRpbmF0ZSgpO3JldHVybiBlLnNldENvb3JkaW5hdGUodGhpcy5fY29vcmRpbmF0ZXNbdF0pLGV9Y3JlYXRlQ29vcmRpbmF0ZSgpe3JldHVybiBkdC5jcmVhdGUodGhpcy5nZXREaW1lbnNpb24oKSx0aGlzLmdldE1lYXN1cmVzKCkpfWdldERpbWVuc2lvbigpe3JldHVybiB0aGlzLl9kaW1lbnNpb259Z2V0WCh0KXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueH1nZXRNZWFzdXJlcygpe3JldHVybiB0aGlzLl9tZWFzdXJlc31leHBhbmRFbnZlbG9wZSh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0fWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5jcmVhdGVDb29yZGluYXRlKCk7bi5zZXRDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKSx0W2VdPW59cmV0dXJuIG5ldyBtdCh0LHRoaXMuX2RpbWVuc2lvbix0aGlzLl9tZWFzdXJlcyl9dG9TdHJpbmcoKXtpZih0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg+MCl7Y29uc3QgdD1uZXcgcHQoMTcqdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoKTt0LmFwcGVuZChcIihcIiksdC5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbMF0pO2ZvcihsZXQgZT0xO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmFwcGVuZChcIiwgXCIpLHQuYXBwZW5kKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdC5hcHBlbmQoXCIpXCIpLHQudG9TdHJpbmcoKX1yZXR1cm5cIigpXCJ9Z2V0WSh0KXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueX10b0Nvb3JkaW5hdGVBcnJheSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRyxjXX19Y2xhc3MgZnR7c3RhdGljIGluc3RhbmNlKCl7cmV0dXJuIGZ0Lmluc3RhbmNlT2JqZWN0fXJlYWRSZXNvbHZlKCl7cmV0dXJuIGZ0Lmluc3RhbmNlKCl9Y3JlYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3JldHVybiBuZXcgbXQoYXJndW1lbnRzWzBdKX1pZihJKGFyZ3VtZW50c1swXSxHKSl7cmV0dXJuIG5ldyBtdChhcmd1bWVudHNbMF0pfX1lbHNle2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMV07cmV0dXJuIHQ+MyYmKHQ9MyksdDwyJiYodD0yKSxuZXcgbXQoYXJndW1lbnRzWzBdLHQpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMl0sZT1hcmd1bWVudHNbMV0tdDtyZXR1cm4gdD4xJiYodD0xKSxlPjMmJihlPTMpLGU8MiYmKGU9MiksbmV3IG10KGFyZ3VtZW50c1swXSxlK3QsdCl9fX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bWCxjXX19ZnQuaW5zdGFuY2VPYmplY3Q9bmV3IGZ0O2NsYXNzIHl0IGV4dGVuZHMgaHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHl0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2h0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgeXQodCx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiAxfWdldFR5cGVDb2RlKCl7cmV0dXJuIFUuVFlQRUNPREVfTVVMVElQT0xZR09OfWdldERpbWVuc2lvbigpe3JldHVybiAyfWdldEJvdW5kYXJ5KCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeSgpO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXQuYWRkKG4uZ2V0R2VvbWV0cnlOKGUpKX1jb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQudG9BcnJheShlKSl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFUuVFlQRU5BTUVfTVVMVElQT0xZR09OfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltpdF19fWxldCB4dD1jbGFzc3tnZXQoKXt9cHV0KCl7fXNpemUoKXt9dmFsdWVzKCl7fWVudHJ5U2V0KCl7fX07Y2xhc3MgRXQgZXh0ZW5kcyBvdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMubWFwPW5ldyBNYXAsdCBpbnN0YW5jZW9mIE4mJnRoaXMuYWRkQWxsKHQpfWNvbnRhaW5zKHQpe2NvbnN0IGU9dC5oYXNoQ29kZT90Lmhhc2hDb2RlKCk6dDtyZXR1cm4hIXRoaXMubWFwLmhhcyhlKX1hZGQodCl7Y29uc3QgZT10Lmhhc2hDb2RlP3QuaGFzaENvZGUoKTp0O3JldHVybiF0aGlzLm1hcC5oYXMoZSkmJiEhdGhpcy5tYXAuc2V0KGUsdCl9YWRkQWxsKHQpe2Zvcihjb25zdCBlIG9mIHQpdGhpcy5hZGQoZSk7cmV0dXJuITB9cmVtb3ZlKCl7dGhyb3cgbmV3IEt9c2l6ZSgpe3JldHVybiB0aGlzLm1hcC5zaXplfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMubWFwLnNpemV9dG9BcnJheSgpe3JldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKX1pdGVyYXRvcigpe3JldHVybiBuZXcgSXQodGhpcy5tYXApfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIHRoaXMubWFwfX1sZXQgSXQ9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5pdGVyYXRvcj10LnZhbHVlcygpO2NvbnN0e2RvbmU6ZSx2YWx1ZTpufT10aGlzLml0ZXJhdG9yLm5leHQoKTt0aGlzLmRvbmU9ZSx0aGlzLnZhbHVlPW59bmV4dCgpe2lmKHRoaXMuZG9uZSl0aHJvdyBuZXcgUztjb25zdCB0PXRoaXMudmFsdWUse2RvbmU6ZSx2YWx1ZTpufT10aGlzLml0ZXJhdG9yLm5leHQoKTtyZXR1cm4gdGhpcy5kb25lPWUsdGhpcy52YWx1ZT1uLHR9aGFzTmV4dCgpe3JldHVybiF0aGlzLmRvbmV9cmVtb3ZlKCl7dGhyb3cgbmV3IEt9fTtjbGFzcyBOdCBleHRlbmRzIHh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLm1hcD1uZXcgTWFwfWdldCh0KXtyZXR1cm4gdGhpcy5tYXAuZ2V0KHQpfHxudWxsfXB1dCh0LGUpe3JldHVybiB0aGlzLm1hcC5zZXQodCxlKSxlfXZhbHVlcygpe2NvbnN0IHQ9bmV3IEwsZT10aGlzLm1hcC52YWx1ZXMoKTtsZXQgbj1lLm5leHQoKTtmb3IoOyFuLmRvbmU7KXQuYWRkKG4udmFsdWUpLG49ZS5uZXh0KCk7cmV0dXJuIHR9ZW50cnlTZXQoKXtjb25zdCB0PW5ldyBFdDtyZXR1cm4gdGhpcy5tYXAuZW50cmllcygpLmZvckVhY2goKGU9PnQuYWRkKGUpKSksdH1zaXplKCl7cmV0dXJuIHRoaXMubWFwLnNpemUoKX19Y2xhc3Mgd3R7Y29uc3RydWN0b3IoKXt3dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tb2RlbFR5cGU9bnVsbCx0aGlzLl9zY2FsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX21vZGVsVHlwZT13dC5GTE9BVElORztlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQ3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT10LHQ9PT13dC5GSVhFRCYmdGhpcy5zZXRTY2FsZSgxKX1lbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT13dC5GSVhFRCx0aGlzLnNldFNjYWxlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB3dCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXQuX21vZGVsVHlwZSx0aGlzLl9zY2FsZT10Ll9zY2FsZX19c3RhdGljIG1vc3RQcmVjaXNlKHQsZSl7cmV0dXJuIHQuY29tcGFyZVRvKGUpPj0wP3Q6ZX1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2Ygd3QpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09ZS5fbW9kZWxUeXBlJiZ0aGlzLl9zY2FsZT09PWUuX3NjYWxlfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQsbj10aGlzLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpLHM9ZS5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKTtyZXR1cm4gYi5jb21wYXJlKG4scyl9Z2V0U2NhbGUoKXtyZXR1cm4gdGhpcy5fc2NhbGV9aXNGbG9hdGluZygpe3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElOR3x8dGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkdfU0lOR0xFfWdldFR5cGUoKXtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlfXRvU3RyaW5nKCl7bGV0IHQ9XCJVTktOT1dOXCI7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HP3Q9XCJGbG9hdGluZ1wiOnRoaXMuX21vZGVsVHlwZT09PXd0LkZMT0FUSU5HX1NJTkdMRT90PVwiRmxvYXRpbmctU2luZ2xlXCI6dGhpcy5fbW9kZWxUeXBlPT09d3QuRklYRUQmJih0PVwiRml4ZWQgKFNjYWxlPVwiK3RoaXMuZ2V0U2NhbGUoKStcIilcIiksdH1tYWtlUHJlY2lzZSgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHIuaXNOYU4odCkpcmV0dXJuIHQ7aWYodGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkdfU0lOR0xFKXtyZXR1cm4gdH1yZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09d3QuRklYRUQ/TWF0aC5yb3VuZCh0KnRoaXMuX3NjYWxlKS90aGlzLl9zY2FsZTp0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkcpcmV0dXJuIG51bGw7dC54PXRoaXMubWFrZVByZWNpc2UodC54KSx0Lnk9dGhpcy5tYWtlUHJlY2lzZSh0LnkpfX1nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKXtsZXQgdD0xNjtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09d3QuRkxPQVRJTkc/dD0xNjp0aGlzLl9tb2RlbFR5cGU9PT13dC5GTE9BVElOR19TSU5HTEU/dD02OnRoaXMuX21vZGVsVHlwZT09PXd0LkZJWEVEJiYodD0xK01hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0U2NhbGUoKSkvTWF0aC5sb2coMTApKSkpLHR9c2V0U2NhbGUodCl7dGhpcy5fc2NhbGU9TWF0aC5hYnModCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2Msb119fWNsYXNzIEN0e2NvbnN0cnVjdG9yKCl7Q3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbmFtZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25hbWU9dCxDdC5uYW1lVG9UeXBlTWFwLnB1dCh0LHRoaXMpfXJlYWRSZXNvbHZlKCl7cmV0dXJuIEN0Lm5hbWVUb1R5cGVNYXAuZ2V0KHRoaXMuX25hbWUpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX25hbWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NdfX1DdC5uYW1lVG9UeXBlTWFwPW5ldyBOdCx3dC5UeXBlPUN0LHd0LkZJWEVEPW5ldyBDdChcIkZJWEVEXCIpLHd0LkZMT0FUSU5HPW5ldyBDdChcIkZMT0FUSU5HXCIpLHd0LkZMT0FUSU5HX1NJTkdMRT1uZXcgQ3QoXCJGTE9BVElORyBTSU5HTEVcIiksd3QubWF4aW11bVByZWNpc2VWYWx1ZT05MDA3MTk5MjU0NzQwOTkyO2NsYXNzIFN0IGV4dGVuZHMgaHR7Y29uc3RydWN0b3IoKXtzdXBlcigpLFN0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2h0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgU3QodCx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/US5GQUxTRTowfWlzQ2xvc2VkKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNDbG9zZWQoKSlyZXR1cm4hMTtyZXR1cm4hMH1nZXRUeXBlQ29kZSgpe3JldHVybiBVLlRZUEVDT0RFX01VTFRJTElORVNUUklOR31nZXREaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRCb3VuZGFyeSgpe3Rocm93IG5ldyBLfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBVLlRZUEVOQU1FX01VTFRJTElORVNUUklOR31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bWl19fWNsYXNzIEx0e2NvbnN0cnVjdG9yKCl7THQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW51bGwsdGhpcy5fU1JJRD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUx0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IHd0LDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLFgpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtMdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyB3dCwwLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB3dCl7Y29uc3QgdD1hcmd1bWVudHNbMF07THQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDAsTHQuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0x0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLEx0LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1uLHRoaXMuX1NSSUQ9ZX19c3RhdGljIHRvTXVsdGlQb2x5Z29uQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9HZW9tZXRyeUFycmF5KHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIGdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCl7cmV0dXJuIGZ0Lmluc3RhbmNlKCl9c3RhdGljIHRvTXVsdGlMaW5lU3RyaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9MaW5lU3RyaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9NdWx0aVBvaW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9MaW5lYXJSaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9Qb2ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvUG9seWdvbkFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIGNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfWNyZWF0ZUVtcHR5KHQpe3N3aXRjaCh0KXtjYXNlLTE6cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7Y2FzZSAwOnJldHVybiB0aGlzLmNyZWF0ZVBvaW50KCk7Y2FzZSAxOnJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDI6cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbigpO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIGRpbWVuc2lvbjogXCIrdCl9fXRvR2VvbWV0cnkodCl7cmV0dXJuIHQuaXNOdWxsKCk/dGhpcy5jcmVhdGVQb2ludCgpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCkmJnQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVQb2ludChuZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSkpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCl8fHQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IG0odC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpXSk6dGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhbbmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSxuZXcgbSh0LmdldE1heFgoKSx0LmdldE1heFkoKSksbmV3IG0odC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpLG5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKV0pLG51bGwpfWNyZWF0ZUxpbmVTdHJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihJKGFyZ3VtZW50c1swXSxHKSl7cmV0dXJuIG5ldyAkKGFyZ3VtZW50c1swXSx0aGlzKX19fWNyZWF0ZU11bHRpTGluZVN0cmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgU3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBTdChhcmd1bWVudHNbMF0sdGhpcyl9fWJ1aWxkR2VvbWV0cnkodCl7bGV0IGU9bnVsbCxuPSExLHM9ITE7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCkscj10LmdldFR5cGVDb2RlKCk7bnVsbD09PWUmJihlPXIpLHIhPT1lJiYobj0hMCksdCBpbnN0YW5jZW9mIGh0JiYocz0hMCl9aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYobnx8cylyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oTHQudG9HZW9tZXRyeUFycmF5KHQpKTtjb25zdCBpPXQuaXRlcmF0b3IoKS5uZXh0KCk7aWYodC5zaXplKCk+MSl7aWYoaSBpbnN0YW5jZW9mIHJ0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9seWdvbihMdC50b1BvbHlnb25BcnJheSh0KSk7aWYoaSBpbnN0YW5jZW9mICQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKEx0LnRvTGluZVN0cmluZ0FycmF5KHQpKTtpZihpIGluc3RhbmNlb2YgZXQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChMdC50b1BvaW50QXJyYXkodCkpO2cuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogXCIraS5nZXRHZW9tZXRyeVR5cGUoKSl9cmV0dXJuIGl9Y3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHModCl7cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9Y3JlYXRlUG9pbnQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2ludCh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW3RdKTpudWxsKX1pZihJKGFyZ3VtZW50c1swXSxHKSl7cmV0dXJuIG5ldyBldChhcmd1bWVudHNbMF0sdGhpcyl9fX1nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnl9Y3JlYXRlUG9seWdvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24obnVsbCxudWxsKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBndCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0LG51bGwpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IHJ0KGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sdGhpcyl9fWdldFNSSUQoKXtyZXR1cm4gdGhpcy5fU1JJRH1jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGh0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgaHQoYXJndW1lbnRzWzBdLHRoaXMpfX1nZXRQcmVjaXNpb25Nb2RlbCgpe3JldHVybiB0aGlzLl9wcmVjaXNpb25Nb2RlbH1jcmVhdGVMaW5lYXJSaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoSShhcmd1bWVudHNbMF0sRykpe3JldHVybiBuZXcgZ3QoYXJndW1lbnRzWzBdLHRoaXMpfX19Y3JlYXRlTXVsdGlQb2x5Z29uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyB5dChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IHl0KGFyZ3VtZW50c1swXSx0aGlzKX19Y3JlYXRlTXVsdGlQb2ludCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgdXQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7cmV0dXJuIG5ldyB1dChhcmd1bWVudHNbMF0sdGhpcyl9aWYoSShhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSgxLHQuZ2V0RGltZW5zaW9uKCksdC5nZXRNZWFzdXJlcygpKTtqLmNvcHkodCxuLHMsMCwxKSxlW25dPXRoaXMuY3JlYXRlUG9pbnQocyl9cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChlKX19fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjXX19Y29uc3QgVHQ9XCJYWVwiLFJ0PVwiWFlaXCIsUHQ9XCJYWU1cIixPdD1cIlhZWk1cIix2dD17UE9JTlQ6XCJQb2ludFwiLExJTkVfU1RSSU5HOlwiTGluZVN0cmluZ1wiLExJTkVBUl9SSU5HOlwiTGluZWFyUmluZ1wiLFBPTFlHT046XCJQb2x5Z29uXCIsTVVMVElfUE9JTlQ6XCJNdWx0aVBvaW50XCIsTVVMVElfTElORV9TVFJJTkc6XCJNdWx0aUxpbmVTdHJpbmdcIixNVUxUSV9QT0xZR09OOlwiTXVsdGlQb2x5Z29uXCIsR0VPTUVUUllfQ09MTEVDVElPTjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLENJUkNMRTpcIkNpcmNsZVwifSxidD1cIkVNUFRZXCIsTXQ9MSxEdD0yLEF0PTMsRnQ9NCxHdD01LHF0PTY7Zm9yKGNvbnN0IHQgaW4gdnQpdnRbdF0udG9VcHBlckNhc2UoKTtjbGFzcyBCdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLndrdD10LHRoaXMuaW5kZXhfPS0xfWlzQWxwaGFfKHQpe3JldHVybiB0Pj1cImFcIiYmdDw9XCJ6XCJ8fHQ+PVwiQVwiJiZ0PD1cIlpcIn1pc051bWVyaWNfKHQsZSl7cmV0dXJuIHQ+PVwiMFwiJiZ0PD1cIjlcInx8XCIuXCI9PXQmJiEodm9pZCAwIT09ZSYmZSl9aXNXaGl0ZVNwYWNlXyh0KXtyZXR1cm5cIiBcIj09dHx8XCJcXHRcIj09dHx8XCJcXHJcIj09dHx8XCJcXG5cIj09dH1uZXh0Q2hhcl8oKXtyZXR1cm4gdGhpcy53a3QuY2hhckF0KCsrdGhpcy5pbmRleF8pfW5leHRUb2tlbigpe2NvbnN0IHQ9dGhpcy5uZXh0Q2hhcl8oKSxlPXRoaXMuaW5kZXhfO2xldCBuLHM9dDtpZihcIihcIj09dCluPUR0O2Vsc2UgaWYoXCIsXCI9PXQpbj1HdDtlbHNlIGlmKFwiKVwiPT10KW49QXQ7ZWxzZSBpZih0aGlzLmlzTnVtZXJpY18odCl8fFwiLVwiPT10KW49RnQscz10aGlzLnJlYWROdW1iZXJfKCk7ZWxzZSBpZih0aGlzLmlzQWxwaGFfKHQpKW49TXQscz10aGlzLnJlYWRUZXh0XygpO2Vsc2V7aWYodGhpcy5pc1doaXRlU3BhY2VfKHQpKXJldHVybiB0aGlzLm5leHRUb2tlbigpO2lmKFwiXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIit0KTtuPXF0fXJldHVybntwb3NpdGlvbjplLHZhbHVlOnMsdHlwZTpufX1yZWFkTnVtYmVyXygpe2xldCB0O2NvbnN0IGU9dGhpcy5pbmRleF87bGV0IG49ITEscz0hMTtkb3tcIi5cIj09dD9uPSEwOlwiZVwiIT10JiZcIkVcIiE9dHx8KHM9ITApLHQ9dGhpcy5uZXh0Q2hhcl8oKX13aGlsZSh0aGlzLmlzTnVtZXJpY18odCxuKXx8IXMmJihcImVcIj09dHx8XCJFXCI9PXQpfHxzJiYoXCItXCI9PXR8fFwiK1wiPT10KSk7cmV0dXJuIHBhcnNlRmxvYXQodGhpcy53a3Quc3Vic3RyaW5nKGUsdGhpcy5pbmRleF8tLSkpfXJlYWRUZXh0Xygpe2xldCB0O2NvbnN0IGU9dGhpcy5pbmRleF87ZG97dD10aGlzLm5leHRDaGFyXygpfXdoaWxlKHRoaXMuaXNBbHBoYV8odCkpO3JldHVybiB0aGlzLndrdC5zdWJzdHJpbmcoZSx0aGlzLmluZGV4Xy0tKS50b1VwcGVyQ2FzZSgpfX1jbGFzcyBZdHtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMubGV4ZXJfPXQsdGhpcy50b2tlbl8sdGhpcy5sYXlvdXRfPVR0LHRoaXMuZmFjdG9yeT1lfWNvbnN1bWVfKCl7dGhpcy50b2tlbl89dGhpcy5sZXhlcl8ubmV4dFRva2VuKCl9aXNUb2tlblR5cGUodCl7cmV0dXJuIHRoaXMudG9rZW5fLnR5cGU9PXR9bWF0Y2godCl7Y29uc3QgZT10aGlzLmlzVG9rZW5UeXBlKHQpO3JldHVybiBlJiZ0aGlzLmNvbnN1bWVfKCksZX1wYXJzZSgpe3RoaXMuY29uc3VtZV8oKTtyZXR1cm4gdGhpcy5wYXJzZUdlb21ldHJ5XygpfXBhcnNlR2VvbWV0cnlMYXlvdXRfKCl7bGV0IHQ9VHQ7Y29uc3QgZT10aGlzLnRva2VuXztpZih0aGlzLmlzVG9rZW5UeXBlKE10KSl7Y29uc3Qgbj1lLnZhbHVlO1wiWlwiPT09bj90PVJ0OlwiTVwiPT09bj90PVB0OlwiWk1cIj09PW4mJih0PU90KSx0IT09VHQmJnRoaXMuY29uc3VtZV8oKX1yZXR1cm4gdH1wYXJzZUdlb21ldHJ5Q29sbGVjdGlvblRleHRfKCl7aWYodGhpcy5tYXRjaChEdCkpe2NvbnN0IHQ9W107ZG97dC5wdXNoKHRoaXMucGFyc2VHZW9tZXRyeV8oKSl9d2hpbGUodGhpcy5tYXRjaChHdCkpO2lmKHRoaXMubWF0Y2goQXQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvaW50VGV4dF8oKXtpZih0aGlzLm1hdGNoKER0KSl7Y29uc3QgdD10aGlzLnBhcnNlUG9pbnRfKCk7aWYodGhpcy5tYXRjaChBdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm4gbnVsbDt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTGluZVN0cmluZ1RleHRfKCl7aWYodGhpcy5tYXRjaChEdCkpe2NvbnN0IHQ9dGhpcy5wYXJzZVBvaW50TGlzdF8oKTtpZih0aGlzLm1hdGNoKEF0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VQb2x5Z29uVGV4dF8oKXtpZih0aGlzLm1hdGNoKER0KSl7Y29uc3QgdD10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRMaXN0XygpO2lmKHRoaXMubWF0Y2goQXQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZU11bHRpUG9pbnRUZXh0Xygpe2lmKHRoaXMubWF0Y2goRHQpKXtsZXQgdDtpZih0PXRoaXMudG9rZW5fLnR5cGU9PUR0P3RoaXMucGFyc2VQb2ludFRleHRMaXN0XygpOnRoaXMucGFyc2VQb2ludExpc3RfKCksdGhpcy5tYXRjaChBdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTXVsdGlMaW5lU3RyaW5nVGV4dF8oKXtpZih0aGlzLm1hdGNoKER0KSl7Y29uc3QgdD10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRMaXN0XygpO2lmKHRoaXMubWF0Y2goQXQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZU11bHRpUG9seWdvblRleHRfKCl7aWYodGhpcy5tYXRjaChEdCkpe2NvbnN0IHQ9dGhpcy5wYXJzZVBvbHlnb25UZXh0TGlzdF8oKTtpZih0aGlzLm1hdGNoKEF0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VQb2ludF8oKXtjb25zdCB0PVtdLGU9dGhpcy5sYXlvdXRfLmxlbmd0aDtmb3IobGV0IG49MDtuPGU7KytuKXtjb25zdCBlPXRoaXMudG9rZW5fO2lmKCF0aGlzLm1hdGNoKEZ0KSlicmVhazt0LnB1c2goZS52YWx1ZSl9aWYodC5sZW5ndGg9PWUpcmV0dXJuIHQ7dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvaW50TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlUG9pbnRfKCldO2Zvcig7dGhpcy5tYXRjaChHdCk7KXQucHVzaCh0aGlzLnBhcnNlUG9pbnRfKCkpO3JldHVybiB0fXBhcnNlUG9pbnRUZXh0TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlUG9pbnRUZXh0XygpXTtmb3IoO3RoaXMubWF0Y2goR3QpOyl0LnB1c2godGhpcy5wYXJzZVBvaW50VGV4dF8oKSk7cmV0dXJuIHR9cGFyc2VMaW5lU3RyaW5nVGV4dExpc3RfKCl7Y29uc3QgdD1bdGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpXTtmb3IoO3RoaXMubWF0Y2goR3QpOyl0LnB1c2godGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpKTtyZXR1cm4gdH1wYXJzZVBvbHlnb25UZXh0TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlUG9seWdvblRleHRfKCldO2Zvcig7dGhpcy5tYXRjaChHdCk7KXQucHVzaCh0aGlzLnBhcnNlUG9seWdvblRleHRfKCkpO3JldHVybiB0fWlzRW1wdHlHZW9tZXRyeV8oKXtjb25zdCB0PXRoaXMuaXNUb2tlblR5cGUoTXQpJiZ0aGlzLnRva2VuXy52YWx1ZT09YnQ7cmV0dXJuIHQmJnRoaXMuY29uc3VtZV8oKSx0fWZvcm1hdEVycm9yTWVzc2FnZV8oKXtyZXR1cm5cIlVuZXhwZWN0ZWQgYFwiK3RoaXMudG9rZW5fLnZhbHVlK1wiYCBhdCBwb3NpdGlvbiBcIit0aGlzLnRva2VuXy5wb3NpdGlvbitcIiBpbiBgXCIrdGhpcy5sZXhlcl8ud2t0K1wiYFwifXBhcnNlR2VvbWV0cnlfKCl7Y29uc3QgdD10aGlzLmZhY3RvcnksZT10PT5uZXcgbSguLi50KSxuPW49Pntjb25zdCBzPW4ubWFwKChuPT50LmNyZWF0ZUxpbmVhclJpbmcobi5tYXAoZSkpKSk7cmV0dXJuIHMubGVuZ3RoPjE/dC5jcmVhdGVQb2x5Z29uKHNbMF0scy5zbGljZSgxKSk6dC5jcmVhdGVQb2x5Z29uKHNbMF0pfSxzPXRoaXMudG9rZW5fO2lmKHRoaXMubWF0Y2goTXQpKXtjb25zdCBpPXMudmFsdWU7aWYodGhpcy5sYXlvdXRfPXRoaXMucGFyc2VHZW9tZXRyeUxheW91dF8oKSxcIkdFT01FVFJZQ09MTEVDVElPTlwiPT1pKXtjb25zdCBlPXRoaXMucGFyc2VHZW9tZXRyeUNvbGxlY3Rpb25UZXh0XygpO3JldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX1zd2l0Y2goaSl7Y2FzZVwiUE9JTlRcIjp7Y29uc3QgZT10aGlzLnBhcnNlUG9pbnRUZXh0XygpO3JldHVybiBlP3QuY3JlYXRlUG9pbnQobmV3IG0oLi4uZSkpOnQuY3JlYXRlUG9pbnQoKX1jYXNlXCJMSU5FU1RSSU5HXCI6e2NvbnN0IG49dGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpLm1hcChlKTtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKG4pfWNhc2VcIkxJTkVBUlJJTkdcIjp7Y29uc3Qgbj10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCkubWFwKGUpO3JldHVybiB0LmNyZWF0ZUxpbmVhclJpbmcobil9Y2FzZVwiUE9MWUdPTlwiOntjb25zdCBlPXRoaXMucGFyc2VQb2x5Z29uVGV4dF8oKTtyZXR1cm4gZSYmMCE9PWUubGVuZ3RoP24oZSk6dC5jcmVhdGVQb2x5Z29uKCl9Y2FzZVwiTVVMVElQT0lOVFwiOntjb25zdCBuPXRoaXMucGFyc2VNdWx0aVBvaW50VGV4dF8oKTtpZighbnx8MD09PW4ubGVuZ3RoKXJldHVybiB0LmNyZWF0ZU11bHRpUG9pbnQoKTtjb25zdCBzPW4ubWFwKGUpLm1hcCgoZT0+dC5jcmVhdGVQb2ludChlKSkpO3JldHVybiB0LmNyZWF0ZU11bHRpUG9pbnQocyl9Y2FzZVwiTVVMVElMSU5FU1RSSU5HXCI6e2NvbnN0IG49dGhpcy5wYXJzZU11bHRpTGluZVN0cmluZ1RleHRfKCkubWFwKChuPT50LmNyZWF0ZUxpbmVTdHJpbmcobi5tYXAoZSkpKSk7cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfWNhc2VcIk1VTFRJUE9MWUdPTlwiOntjb25zdCBlPXRoaXMucGFyc2VNdWx0aVBvbHlnb25UZXh0XygpO2lmKCFlfHwwPT09ZS5sZW5ndGgpcmV0dXJuIHQuY3JlYXRlTXVsdGlQb2x5Z29uKCk7Y29uc3Qgcz1lLm1hcChuKTtyZXR1cm4gdC5jcmVhdGVNdWx0aVBvbHlnb24ocyl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdlb21ldHJ5IHR5cGU6IFwiK2kpfX10aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfX1mdW5jdGlvbiBWdCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm5cIlwiO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKCksbj1bZS54LGUueV07cmV0dXJuIHZvaWQgMD09PWUuenx8TnVtYmVyLmlzTmFOKGUueil8fG4ucHVzaChlLnopLHZvaWQgMD09PWUubXx8TnVtYmVyLmlzTmFOKGUubSl8fG4ucHVzaChlLm0pLG4uam9pbihcIiBcIil9ZnVuY3Rpb24genQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCkubWFwKCh0PT57Y29uc3QgZT1bdC54LHQueV07cmV0dXJuIHZvaWQgMD09PXQuenx8TnVtYmVyLmlzTmFOKHQueil8fGUucHVzaCh0LnopLHZvaWQgMD09PXQubXx8TnVtYmVyLmlzTmFOKHQubSl8fGUucHVzaCh0Lm0pLGV9KSksbj1bXTtmb3IobGV0IHQ9MCxzPWUubGVuZ3RoO3Q8czsrK3Qpbi5wdXNoKGVbdF0uam9pbihcIiBcIikpO3JldHVybiBuLmpvaW4oXCIsIFwiKX1mdW5jdGlvbiBYdCh0KXtjb25zdCBlPVtdO2UucHVzaChcIihcIit6dCh0LmdldEV4dGVyaW9yUmluZygpKStcIilcIik7Zm9yKGxldCBuPTAscz10LmdldE51bUludGVyaW9yUmluZygpO248czsrK24pZS5wdXNoKFwiKFwiK3p0KHQuZ2V0SW50ZXJpb3JSaW5nTihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX1jb25zdCBrdD17UG9pbnQ6VnQsTGluZVN0cmluZzp6dCxMaW5lYXJSaW5nOnp0LFBvbHlnb246WHQsTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goXCIoXCIrVnQodC5nZXRHZW9tZXRyeU4obikpK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goXCIoXCIrenQodC5nZXRHZW9tZXRyeU4obikpK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goXCIoXCIrWHQodC5nZXRHZW9tZXRyeU4obikpK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goVXQodC5nZXRHZW9tZXRyeU4obikpKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9fTtmdW5jdGlvbiBVdCh0KXtsZXQgZT10LmdldEdlb21ldHJ5VHlwZSgpO2NvbnN0IG49a3RbZV07ZT1lLnRvVXBwZXJDYXNlKCk7Y29uc3Qgcz1mdW5jdGlvbih0KXtsZXQgZT1cIlwiO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlO2NvbnN0IG49dC5nZXRDb29yZGluYXRlKCk7cmV0dXJuIHZvaWQgMD09PW4uenx8TnVtYmVyLmlzTmFOKG4ueil8fChlKz1cIlpcIiksdm9pZCAwPT09bi5tfHxOdW1iZXIuaXNOYU4obi5tKXx8KGUrPVwiTVwiKSxlfSh0KTtpZihzLmxlbmd0aD4wJiYoZSs9XCIgXCIrcyksdC5pc0VtcHR5KCkpcmV0dXJuIGUrXCIgXCIrYnQ7cmV0dXJuIGUrXCIgKFwiK24odCkrXCIpXCJ9Y2xhc3MgSHR7Y29uc3RydWN0b3IodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEx0LHRoaXMucHJlY2lzaW9uTW9kZWw9dGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX1yZWFkKHQpe2NvbnN0IGU9bmV3IEJ0KHQpO3JldHVybiBuZXcgWXQoZSx0aGlzLmdlb21ldHJ5RmFjdG9yeSkucGFyc2UoKX13cml0ZSh0KXtyZXR1cm4gVXQodCl9fWNsYXNzIFd0e2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyBIdCh0KX13cml0ZSh0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9c3RhdGljIHRvTGluZVN0cmluZyh0LGUpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtyZXR1cm5cIkxJTkVTVFJJTkcgKCBcIit0LngrXCIgXCIrdC55K1wiLCBcIitlLngrXCIgXCIrZS55K1wiIClcIn19Y2xhc3MgWnR7Y29uc3RydWN0b3IoKXtadC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZXN1bHQ9bnVsbCx0aGlzLl9pbnB1dExpbmVzPUFycmF5KDIpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgyKSkpLHRoaXMuX2ludFB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2ludExpbmVJbmRleD1udWxsLHRoaXMuX2lzUHJvcGVyPW51bGwsdGhpcy5fcGE9bnVsbCx0aGlzLl9wYj1udWxsLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5faW50UHRbMF09bmV3IG0sdGhpcy5faW50UHRbMV09bmV3IG0sdGhpcy5fcGE9dGhpcy5faW50UHRbMF0sdGhpcy5fcGI9dGhpcy5faW50UHRbMV0sdGhpcy5fcmVzdWx0PTB9c3RhdGljIGNvbXB1dGVFZGdlRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9TWF0aC5hYnMobi54LWUueCksaT1NYXRoLmFicyhuLnktZS55KTtsZXQgcj0tMTtpZih0LmVxdWFscyhlKSlyPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlyPXM+aT9zOmk7ZWxzZXtjb25zdCBuPU1hdGguYWJzKHQueC1lLngpLG89TWF0aC5hYnModC55LWUueSk7cj1zPmk/bjpvLDAhPT1yfHx0LmVxdWFscyhlKXx8KHI9TWF0aC5tYXgobixvKSl9cmV0dXJuIGcuaXNUcnVlKCEoMD09PXImJiF0LmVxdWFscyhlKSksXCJCYWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1zdGF0aWMgbm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueSxyPU1hdGguc3FydChzKnMraSppKTtyZXR1cm4gZy5pc1RydWUoISgwPT09ciYmIXQuZXF1YWxzKGUpKSxcIkludmFsaWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1nZXRJbmRleEFsb25nU2VnbWVudCh0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bZV19Z2V0VG9wb2xvZ3lTdW1tYXJ5KCl7Y29uc3QgdD1uZXcgcHQ7cmV0dXJuIHRoaXMuaXNFbmRQb2ludCgpJiZ0LmFwcGVuZChcIiBlbmRwb2ludFwiKSx0aGlzLl9pc1Byb3BlciYmdC5hcHBlbmQoXCIgcHJvcGVyXCIpLHRoaXMuaXNDb2xsaW5lYXIoKSYmdC5hcHBlbmQoXCIgY29sbGluZWFyXCIpLHQudG9TdHJpbmcoKX1jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSxuLHMpe3RoaXMuX2lucHV0TGluZXNbMF1bMF09dCx0aGlzLl9pbnB1dExpbmVzWzBdWzFdPWUsdGhpcy5faW5wdXRMaW5lc1sxXVswXT1uLHRoaXMuX2lucHV0TGluZXNbMV1bMV09cyx0aGlzLl9yZXN1bHQ9dGhpcy5jb21wdXRlSW50ZXJzZWN0KHQsZSxuLHMpfWdldEludGVyc2VjdGlvbk51bSgpe3JldHVybiB0aGlzLl9yZXN1bHR9Y29tcHV0ZUludExpbmVJbmRleCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW51bGw9PT10aGlzLl9pbnRMaW5lSW5kZXgmJih0aGlzLl9pbnRMaW5lSW5kZXg9QXJyYXkoMikuZmlsbCgpLm1hcCgoKCk9PkFycmF5KDIpKSksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDApLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwwKT50aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDEpPyh0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMF09MCx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMV09MSk6KHRoaXMuX2ludExpbmVJbmRleFt0XVswXT0xLHRoaXMuX2ludExpbmVJbmRleFt0XVsxXT0wKX19aXNQcm9wZXIoKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5faXNQcm9wZXJ9c2V0UHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fcHJlY2lzaW9uTW9kZWw9dH1pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCl8fCEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDEpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX3Jlc3VsdDtlKyspaWYoIXRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHRoaXMuX2lucHV0TGluZXNbdF1bMF0pJiYhdGhpcy5faW50UHRbZV0uZXF1YWxzMkQodGhpcy5faW5wdXRMaW5lc1t0XVsxXSkpcmV0dXJuITA7cmV0dXJuITF9fWdldEludGVyc2VjdGlvbih0KXtyZXR1cm4gdGhpcy5faW50UHRbdF19aXNFbmRQb2ludCgpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpJiYhdGhpcy5faXNQcm9wZXJ9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdCE9PVp0Lk5PX0lOVEVSU0VDVElPTn1nZXRFZGdlRGlzdGFuY2UodCxlKXtyZXR1cm4gWnQuY29tcHV0ZUVkZ2VEaXN0YW5jZSh0aGlzLl9pbnRQdFtlXSx0aGlzLl9pbnB1dExpbmVzW3RdWzBdLHRoaXMuX2lucHV0TGluZXNbdF1bMV0pfWlzQ29sbGluZWFyKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdD09PVp0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT059dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sdGhpcy5faW5wdXRMaW5lc1swXVsxXSkrXCIgLSBcIitXdC50b0xpbmVTdHJpbmcodGhpcy5faW5wdXRMaW5lc1sxXVswXSx0aGlzLl9pbnB1dExpbmVzWzFdWzFdKSt0aGlzLmdldFRvcG9sb2d5U3VtbWFyeSgpfWdldEVuZHBvaW50KHQsZSl7cmV0dXJuIHRoaXMuX2lucHV0TGluZXNbdF1bZV19aXNJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9yZXN1bHQ7ZSsrKWlmKHRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHQpKXJldHVybiEwO3JldHVybiExfWdldEludGVyc2VjdGlvbkFsb25nU2VnbWVudCh0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLl9pbnRQdFt0aGlzLl9pbnRMaW5lSW5kZXhbdF1bZV1dfX1adC5ET05UX0lOVEVSU0VDVD0wLFp0LkRPX0lOVEVSU0VDVD0xLFp0LkNPTExJTkVBUj0yLFp0Lk5PX0lOVEVSU0VDVElPTj0wLFp0LlBPSU5UX0lOVEVSU0VDVElPTj0xLFp0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT049MjtjbGFzcyBqdCBleHRlbmRzIFp0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1zdGF0aWMgbmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpe2xldCBpPXQscj16LnBvaW50VG9TZWdtZW50KHQsbixzKSxvPXoucG9pbnRUb1NlZ21lbnQoZSxuLHMpO3JldHVybiBvPHImJihyPW8saT1lKSxvPXoucG9pbnRUb1NlZ21lbnQobix0LGUpLG88ciYmKHI9byxpPW4pLG89ei5wb2ludFRvU2VnbWVudChzLHQsZSksbzxyJiYocj1vLGk9cyksaX1pc0luU2VnbWVudEVudmVsb3Blcyh0KXtjb25zdCBlPW5ldyBPKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sdGhpcy5faW5wdXRMaW5lc1swXVsxXSksbj1uZXcgTyh0aGlzLl9pbnB1dExpbmVzWzFdWzBdLHRoaXMuX2lucHV0TGluZXNbMV1bMV0pO3JldHVybiBlLmNvbnRhaW5zKHQpJiZuLmNvbnRhaW5zKHQpfWNvbXB1dGVJbnRlcnNlY3Rpb24oKXtpZigzIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gc3VwZXIuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX2lzUHJvcGVyPSExLE8uaW50ZXJzZWN0cyhlLG4sdCkmJjA9PT1xLmluZGV4KGUsbix0KSYmMD09PXEuaW5kZXgobixlLHQpKXJldHVybiB0aGlzLl9pc1Byb3Blcj0hMCwodC5lcXVhbHMoZSl8fHQuZXF1YWxzKG4pKSYmKHRoaXMuX2lzUHJvcGVyPSExKSx0aGlzLl9yZXN1bHQ9WnQuUE9JTlRfSU5URVJTRUNUSU9OLG51bGw7dGhpcy5fcmVzdWx0PVp0Lk5PX0lOVEVSU0VDVElPTn19aW50ZXJzZWN0aW9uKHQsZSxuLHMpe2xldCBpPXRoaXMuaW50ZXJzZWN0aW9uU2FmZSh0LGUsbixzKTtyZXR1cm4gdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhpKXx8KGk9bmV3IG0oanQubmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpKSksbnVsbCE9PXRoaXMuX3ByZWNpc2lvbk1vZGVsJiZ0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShpKSxpfWNoZWNrREQodCxlLG4scyxpKXtjb25zdCByPUYuaW50ZXJzZWN0aW9uKHQsZSxuLHMpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhyKTtZLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3IpLGkuZGlzdGFuY2Uocik+MWUtNCYmWS5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIraS5kaXN0YW5jZShyKSl9aW50ZXJzZWN0aW9uU2FmZSh0LGUsbixzKXtsZXQgaT1CLmludGVyc2VjdGlvbih0LGUsbixzKTtyZXR1cm4gbnVsbD09PWkmJihpPWp0Lm5lYXJlc3RFbmRwb2ludCh0LGUsbixzKSksaX1jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9Ty5pbnRlcnNlY3RzKHQsZSxuKSxyPU8uaW50ZXJzZWN0cyh0LGUscyksbz1PLmludGVyc2VjdHMobixzLHQpLGw9Ty5pbnRlcnNlY3RzKG4scyxlKTtyZXR1cm4gaSYmcj8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT1zLFp0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOm8mJmw/KHRoaXMuX2ludFB0WzBdPXQsdGhpcy5faW50UHRbMV09ZSxadC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTppJiZvPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPXQsIW4uZXF1YWxzKHQpfHxyfHxsP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTppJiZsPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPWUsIW4uZXF1YWxzKGUpfHxyfHxvP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTpyJiZvPyh0aGlzLl9pbnRQdFswXT1zLHRoaXMuX2ludFB0WzFdPXQsIXMuZXF1YWxzKHQpfHxpfHxsP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTpyJiZsPyh0aGlzLl9pbnRQdFswXT1zLHRoaXMuX2ludFB0WzFdPWUsIXMuZXF1YWxzKGUpfHxpfHxvP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTpadC5OT19JTlRFUlNFQ1RJT059Y29tcHV0ZUludGVyc2VjdCh0LGUsbixzKXtpZih0aGlzLl9pc1Byb3Blcj0hMSwhTy5pbnRlcnNlY3RzKHQsZSxuLHMpKXJldHVybiBadC5OT19JTlRFUlNFQ1RJT047Y29uc3QgaT1xLmluZGV4KHQsZSxuKSxyPXEuaW5kZXgodCxlLHMpO2lmKGk+MCYmcj4wfHxpPDAmJnI8MClyZXR1cm4gWnQuTk9fSU5URVJTRUNUSU9OO2NvbnN0IG89cS5pbmRleChuLHMsdCksbD1xLmluZGV4KG4scyxlKTtpZihvPjAmJmw+MHx8bzwwJiZsPDApcmV0dXJuIFp0Lk5PX0lOVEVSU0VDVElPTjtyZXR1cm4gMD09PWkmJjA9PT1yJiYwPT09byYmMD09PWw/dGhpcy5jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHQsZSxuLHMpOigwPT09aXx8MD09PXJ8fDA9PT1vfHwwPT09bD8odGhpcy5faXNQcm9wZXI9ITEsdC5lcXVhbHMyRChuKXx8dC5lcXVhbHMyRChzKT90aGlzLl9pbnRQdFswXT10OmUuZXF1YWxzMkQobil8fGUuZXF1YWxzMkQocyk/dGhpcy5faW50UHRbMF09ZTowPT09aT90aGlzLl9pbnRQdFswXT1uZXcgbShuKTowPT09cj90aGlzLl9pbnRQdFswXT1uZXcgbShzKTowPT09bz90aGlzLl9pbnRQdFswXT1uZXcgbSh0KTowPT09bCYmKHRoaXMuX2ludFB0WzBdPW5ldyBtKGUpKSk6KHRoaXMuX2lzUHJvcGVyPSEwLHRoaXMuX2ludFB0WzBdPXRoaXMuaW50ZXJzZWN0aW9uKHQsZSxuLHMpKSxadC5QT0lOVF9JTlRFUlNFQ1RJT04pfX1jbGFzcyBLdHtjb25zdHJ1Y3Rvcigpe0t0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpS3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSxuZXcgbSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07S3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucDA9dCx0aGlzLnAxPWV9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107S3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSh0LGUpLG5ldyBtKG4scykpfX1zdGF0aWMgbWlkUG9pbnQodCxlKXtyZXR1cm4gbmV3IG0oKHQueCtlLngpLzIsKHQueStlLnkpLzIpfW1pblgoKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LHRoaXMucDEueCl9b3JpZW50YXRpb25JbmRleCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9cS5pbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMCksbj1xLmluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAxKTtyZXR1cm4gZT49MCYmbj49MHx8ZTw9MCYmbjw9MD9NYXRoLm1heChlLG4pOjB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gcS5pbmRleCh0aGlzLnAwLHRoaXMucDEsdCl9fXRvR2VvbWV0cnkodCl7cmV0dXJuIHQuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5wMCx0aGlzLnAxXSl9aXNWZXJ0aWNhbCgpe3JldHVybiB0aGlzLnAwLng9PT10aGlzLnAxLnh9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIEt0KSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMucDAuZXF1YWxzKGUucDApJiZ0aGlzLnAxLmVxdWFscyhlLnAxKX1pbnRlcnNlY3Rpb24odCl7Y29uc3QgZT1uZXcganQ7cmV0dXJuIGUuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKSxlLmhhc0ludGVyc2VjdGlvbigpP2UuZ2V0SW50ZXJzZWN0aW9uKDApOm51bGx9cHJvamVjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5lcXVhbHModGhpcy5wMCl8fHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiBuZXcgbSh0KTtjb25zdCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KSxuPW5ldyBtO3JldHVybiBuLng9dGhpcy5wMC54K2UqKHRoaXMucDEueC10aGlzLnAwLngpLG4ueT10aGlzLnAwLnkrZSoodGhpcy5wMS55LXRoaXMucDAueSksbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0LnAwKSxuPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0LnAxKTtpZihlPj0xJiZuPj0xKXJldHVybiBudWxsO2lmKGU8PTAmJm48PTApcmV0dXJuIG51bGw7bGV0IHM9dGhpcy5wcm9qZWN0KHQucDApO2U8MCYmKHM9dGhpcy5wMCksZT4xJiYocz10aGlzLnAxKTtsZXQgaT10aGlzLnByb2plY3QodC5wMSk7cmV0dXJuIG48MCYmKGk9dGhpcy5wMCksbj4xJiYoaT10aGlzLnAxKSxuZXcgS3QocyxpKX19bm9ybWFsaXplKCl7dGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCk8MCYmdGhpcy5yZXZlcnNlKCl9YW5nbGUoKXtyZXR1cm4gTWF0aC5hdGFuMih0aGlzLnAxLnktdGhpcy5wMC55LHRoaXMucDEueC10aGlzLnAwLngpfWdldENvb3JkaW5hdGUodCl7cmV0dXJuIDA9PT10P3RoaXMucDA6dGhpcy5wMX1kaXN0YW5jZVBlcnBlbmRpY3VsYXIodCl7cmV0dXJuIHoucG9pbnRUb0xpbmVQZXJwZW5kaWN1bGFyKHQsdGhpcy5wMCx0aGlzLnAxKX1taW5ZKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueSx0aGlzLnAxLnkpfW1pZFBvaW50KCl7cmV0dXJuIEt0Lm1pZFBvaW50KHRoaXMucDAsdGhpcy5wMSl9cHJvamVjdGlvbkZhY3Rvcih0KXtpZih0LmVxdWFscyh0aGlzLnAwKSlyZXR1cm4gMDtpZih0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gMTtjb25zdCBlPXRoaXMucDEueC10aGlzLnAwLngsbj10aGlzLnAxLnktdGhpcy5wMC55LHM9ZSplK24qbjtpZihzPD0wKXJldHVybiByLk5hTjtyZXR1cm4oKHQueC10aGlzLnAwLngpKmUrKHQueS10aGlzLnAwLnkpKm4pL3N9Y2xvc2VzdFBvaW50cyh0KXtjb25zdCBlPXRoaXMuaW50ZXJzZWN0aW9uKHQpO2lmKG51bGwhPT1lKXJldHVybltlLGVdO2NvbnN0IG49bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7bGV0IHM9ci5NQVhfVkFMVUUsaT1udWxsO2NvbnN0IG89dGhpcy5jbG9zZXN0UG9pbnQodC5wMCk7cz1vLmRpc3RhbmNlKHQucDApLG5bMF09byxuWzFdPXQucDA7Y29uc3QgbD10aGlzLmNsb3Nlc3RQb2ludCh0LnAxKTtpPWwuZGlzdGFuY2UodC5wMSksaTxzJiYocz1pLG5bMF09bCxuWzFdPXQucDEpO2NvbnN0IGE9dC5jbG9zZXN0UG9pbnQodGhpcy5wMCk7aT1hLmRpc3RhbmNlKHRoaXMucDApLGk8cyYmKHM9aSxuWzBdPXRoaXMucDAsblsxXT1hKTtjb25zdCBjPXQuY2xvc2VzdFBvaW50KHRoaXMucDEpO3JldHVybiBpPWMuZGlzdGFuY2UodGhpcy5wMSksaTxzJiYocz1pLG5bMF09dGhpcy5wMSxuWzFdPWMpLG59Y2xvc2VzdFBvaW50KHQpe2NvbnN0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO2lmKGU+MCYmZTwxKXJldHVybiB0aGlzLnByb2plY3QodCk7cmV0dXJuIHRoaXMucDAuZGlzdGFuY2UodCk8dGhpcy5wMS5kaXN0YW5jZSh0KT90aGlzLnAwOnRoaXMucDF9bWF4WCgpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLngsdGhpcy5wMS54KX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0aGlzLnAxKX1jb21wYXJlVG8odCl7Y29uc3QgZT10LG49dGhpcy5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dGhpcy5wMS5jb21wYXJlVG8oZS5wMSl9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMucDAuZXF1YWxzKHQucDApJiZ0aGlzLnAxLmVxdWFscyh0LnAxKXx8dGhpcy5wMC5lcXVhbHModC5wMSkmJnRoaXMucDEuZXF1YWxzKHQucDApfWxpbmVJbnRlcnNlY3Rpb24odCl7cmV0dXJuIEIuaW50ZXJzZWN0aW9uKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfW1heFkoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC55LHRoaXMucDEueSl9cG9pbnRBbG9uZ09mZnNldCh0LGUpe2NvbnN0IG49dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLHM9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGk9dGhpcy5wMS54LXRoaXMucDAueCxyPXRoaXMucDEueS10aGlzLnAwLnksbz1NYXRoLnNxcnQoaSppK3Iqcik7bGV0IGw9MCxhPTA7aWYoMCE9PWUpe2lmKG88PTApdGhyb3cgbmV3IEQoXCJDYW5ub3QgY29tcHV0ZSBvZmZzZXQgZnJvbSB6ZXJvLWxlbmd0aCBsaW5lIHNlZ21lbnRcIik7bD1lKmkvbyxhPWUqci9vfXJldHVybiBuZXcgbShuLWEscytsKX1zZXRDb29yZGluYXRlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldENvb3JkaW5hdGVzKHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wMC54PXQueCx0aGlzLnAwLnk9dC55LHRoaXMucDEueD1lLngsdGhpcy5wMS55PWUueX19c2VnbWVudEZyYWN0aW9uKHQpe2xldCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtyZXR1cm4gZTwwP2U9MDooZT4xfHxyLmlzTmFOKGUpKSYmKGU9MSksZX10b1N0cmluZygpe3JldHVyblwiTElORVNUUklORyggXCIrdGhpcy5wMC54K1wiIFwiK3RoaXMucDAueStcIiwgXCIrdGhpcy5wMS54K1wiIFwiK3RoaXMucDEueStcIilcIn1pc0hvcml6b250YWwoKXtyZXR1cm4gdGhpcy5wMC55PT09dGhpcy5wMS55fXJlZmxlY3QodCl7Y29uc3QgZT10aGlzLnAxLmdldFkoKS10aGlzLnAwLmdldFkoKSxuPXRoaXMucDAuZ2V0WCgpLXRoaXMucDEuZ2V0WCgpLHM9dGhpcy5wMC5nZXRZKCkqKHRoaXMucDEuZ2V0WCgpLXRoaXMucDAuZ2V0WCgpKS10aGlzLnAwLmdldFgoKSoodGhpcy5wMS5nZXRZKCktdGhpcy5wMC5nZXRZKCkpLGk9ZSplK24qbixyPWUqZS1uKm4sbz10LmdldFgoKSxsPXQuZ2V0WSgpO3JldHVybiBuZXcgbSgoLXIqby0yKmUqbipsLTIqZSpzKS9pLChyKmwtMiplKm4qby0yKm4qcykvaSl9ZGlzdGFuY2UoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gei5zZWdtZW50VG9TZWdtZW50KHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHoucG9pbnRUb1NlZ21lbnQodCx0aGlzLnAwLHRoaXMucDEpfX1wb2ludEFsb25nKHQpe2NvbnN0IGU9bmV3IG07cmV0dXJuIGUueD10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCksZS55PXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxlfWhhc2hDb2RlKCl7bGV0IHQ9ci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7Y29uc3QgZT1NYXRoLnRydW5jKHQpXk1hdGgudHJ1bmModD4+MzIpO2xldCBuPXIuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO25ePTMxKnIuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpO3JldHVybiBlXihNYXRoLnRydW5jKG4pXk1hdGgudHJ1bmMobj4+MzIpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxjXX19Y2xhc3MgUXR7c3RhdGljIHRvTG9jYXRpb25TeW1ib2wodCl7c3dpdGNoKHQpe2Nhc2UgUXQuRVhURVJJT1I6cmV0dXJuXCJlXCI7Y2FzZSBRdC5CT1VOREFSWTpyZXR1cm5cImJcIjtjYXNlIFF0LklOVEVSSU9SOnJldHVyblwiaVwiO2Nhc2UgUXQuTk9ORTpyZXR1cm5cIi1cIn10aHJvdyBuZXcgcyhcIlVua25vd24gbG9jYXRpb24gdmFsdWU6IFwiK3QpfX1RdC5JTlRFUklPUj0wLFF0LkJPVU5EQVJZPTEsUXQuRVhURVJJT1I9MixRdC5OT05FPS0xO2NsYXNzIEp0e2NvbnN0cnVjdG9yKCl7SnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbWF0cml4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbWF0cml4PUFycmF5KDMpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgzKSkpLHRoaXMuc2V0QWxsKFEuRkFMU0UpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07SnQuY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5zZXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEp0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtKdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXT10Ll9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXT10Ll9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXT10Ll9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXT10Ll9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXT10Ll9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXT10Ll9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXT10Ll9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXT10Ll9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkVYVEVSSU9SXT10Ll9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkVYVEVSSU9SXX19c3RhdGljIG1hdGNoZXMoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBlPT09US5TWU1fRE9OVENBUkV8fChlPT09US5TWU1fVFJVRSYmKHQ+PTB8fHQ9PT1RLlRSVUUpfHwoZT09PVEuU1lNX0ZBTFNFJiZ0PT09US5GQUxTRXx8KGU9PT1RLlNZTV9QJiZ0PT09US5QfHwoZT09PVEuU1lNX0wmJnQ9PT1RLkx8fGU9PT1RLlNZTV9BJiZ0PT09US5BKSkpKX1pZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IEp0KGFyZ3VtZW50c1swXSkubWF0Y2hlcyh0KX19c3RhdGljIGlzVHJ1ZSh0KXtyZXR1cm4gdD49MHx8dD09PVEuVFJVRX1pc0ludGVyc2VjdHMoKXtyZXR1cm4hdGhpcy5pc0Rpc2pvaW50KCl9aXNDb3ZlcnMoKXtyZXR1cm4oSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldKSkmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV09PT1RLkZBTFNFfWlzQ292ZXJlZEJ5KCl7cmV0dXJuKEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXSkpJiZ0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdPT09US5GQUxTRX1zZXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49TWF0aC50cnVuYyhlLzMpLHM9ZSUzO3RoaXMuX21hdHJpeFtuXVtzXT1RLnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9tYXRyaXhbdF1bZV09bn19aXNDb250YWlucygpe3JldHVybiBKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldPT09US5GQUxTRX1zZXRBdExlYXN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPU1hdGgudHJ1bmMoZS8zKSxzPWUlMzt0aGlzLnNldEF0TGVhc3QobixzLFEudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSkpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9tYXRyaXhbdF1bZV08biYmKHRoaXMuX21hdHJpeFt0XVtlXT1uKX19c2V0QXRMZWFzdElmVmFsaWQodCxlLG4pe3Q+PTAmJmU+PTAmJnRoaXMuc2V0QXRMZWFzdCh0LGUsbil9aXNXaXRoaW4oKXtyZXR1cm4gSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXT09PVEuRkFMU0V9aXNUb3VjaGVzKHQsZSl7cmV0dXJuIHQ+ZT90aGlzLmlzVG91Y2hlcyhlLHQpOih0PT09US5BJiZlPT09US5BfHx0PT09US5MJiZlPT09US5MfHx0PT09US5MJiZlPT09US5BfHx0PT09US5QJiZlPT09US5BfHx0PT09US5QJiZlPT09US5MKSYmKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdPT09US5GQUxTRSYmKEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXSkpKX1pc092ZXJsYXBzKHQsZSl7cmV0dXJuIHQ9PT1RLlAmJmU9PT1RLlB8fHQ9PT1RLkEmJmU9PT1RLkE/SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdKTp0PT09US5MJiZlPT09US5MJiYoMT09PXRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl0pKX1pc0VxdWFscyh0LGUpe3JldHVybiB0PT09ZSYmKEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5FWFRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldPT09US5GQUxTRSl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyBwdChcIjEyMzQ1Njc4OVwiKTtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdC5zZXRDaGFyQXQoMyplK24sUS50b0RpbWVuc2lvblN5bWJvbCh0aGlzLl9tYXRyaXhbZV1bbl0pKTtyZXR1cm4gdC50b1N0cmluZygpfXNldEFsbCh0KXtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdGhpcy5fbWF0cml4W2VdW25dPXR9Z2V0KHQsZSl7cmV0dXJuIHRoaXMuX21hdHJpeFt0XVtlXX10cmFuc3Bvc2UoKXtsZXQgdD10aGlzLl9tYXRyaXhbMV1bMF07cmV0dXJuIHRoaXMuX21hdHJpeFsxXVswXT10aGlzLl9tYXRyaXhbMF1bMV0sdGhpcy5fbWF0cml4WzBdWzFdPXQsdD10aGlzLl9tYXRyaXhbMl1bMF0sdGhpcy5fbWF0cml4WzJdWzBdPXRoaXMuX21hdHJpeFswXVsyXSx0aGlzLl9tYXRyaXhbMF1bMl09dCx0PXRoaXMuX21hdHJpeFsyXVsxXSx0aGlzLl9tYXRyaXhbMl1bMV09dGhpcy5fbWF0cml4WzFdWzJdLHRoaXMuX21hdHJpeFsxXVsyXT10LHRoaXN9bWF0Y2hlcyh0KXtpZig5IT09dC5sZW5ndGgpdGhyb3cgbmV3IHMoXCJTaG91bGQgYmUgbGVuZ3RoIDk6IFwiK3QpO2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKylpZighSnQubWF0Y2hlcyh0aGlzLl9tYXRyaXhbZV1bbl0sdC5jaGFyQXQoMyplK24pKSlyZXR1cm4hMTtyZXR1cm4hMH1hZGQodCl7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXRoaXMuc2V0QXRMZWFzdChlLG4sdC5nZXQoZSxuKSl9aXNEaXNqb2ludCgpe3JldHVybiB0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXT09PVEuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldPT09US5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl09PT1RLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXT09PVEuRkFMU0V9aXNDcm9zc2VzKHQsZSl7cmV0dXJuIHQ9PT1RLlAmJmU9PT1RLkx8fHQ9PT1RLlAmJmU9PT1RLkF8fHQ9PT1RLkwmJmU9PT1RLkE/SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdKTp0PT09US5MJiZlPT09US5QfHx0PT09US5BJiZlPT09US5QfHx0PT09US5BJiZlPT09US5MP0p0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXSk6dD09PVEuTCYmZT09PVEuTCYmMD09PXRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19Y2xhc3MgJHR7c3RhdGljIHRvRGVncmVlcyh0KXtyZXR1cm4gMTgwKnQvTWF0aC5QSX1zdGF0aWMgbm9ybWFsaXplKHQpe2Zvcig7dD5NYXRoLlBJOyl0LT0kdC5QSV9USU1FU18yO2Zvcig7dDw9LU1hdGguUEk7KXQrPSR0LlBJX1RJTUVTXzI7cmV0dXJuIHR9c3RhdGljIGFuZ2xlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmF0YW4yKHQueSx0LngpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10Lngscz1lLnktdC55O3JldHVybiBNYXRoLmF0YW4yKHMsbil9fXN0YXRpYyBpc0FjdXRlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55O3JldHVybiBzKihuLngtZS54KStpKihuLnktZS55KT4wfXN0YXRpYyBpc09idHVzZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueTtyZXR1cm4gcyoobi54LWUueCkraSoobi55LWUueSk8MH1zdGF0aWMgaW50ZXJpb3JBbmdsZSh0LGUsbil7Y29uc3Qgcz0kdC5hbmdsZShlLHQpLGk9JHQuYW5nbGUoZSxuKTtyZXR1cm4gTWF0aC5hYnMoaS1zKX1zdGF0aWMgbm9ybWFsaXplUG9zaXRpdmUodCl7aWYodDwwKXtmb3IoO3Q8MDspdCs9JHQuUElfVElNRVNfMjt0Pj0kdC5QSV9USU1FU18yJiYodD0wKX1lbHNle2Zvcig7dD49JHQuUElfVElNRVNfMjspdC09JHQuUElfVElNRVNfMjt0PDAmJih0PTApfXJldHVybiB0fXN0YXRpYyBhbmdsZUJldHdlZW4odCxlLG4pe2NvbnN0IHM9JHQuYW5nbGUoZSx0KSxpPSR0LmFuZ2xlKGUsbik7cmV0dXJuICR0LmRpZmYocyxpKX1zdGF0aWMgZGlmZih0LGUpe2xldCBuPW51bGw7cmV0dXJuIG49dDxlP2UtdDp0LWUsbj5NYXRoLlBJJiYobj0yKk1hdGguUEktbiksbn1zdGF0aWMgdG9SYWRpYW5zKHQpe3JldHVybiB0Kk1hdGguUEkvMTgwfXN0YXRpYyBnZXRUdXJuKHQsZSl7Y29uc3Qgbj1NYXRoLnNpbihlLXQpO3JldHVybiBuPjA/JHQuQ09VTlRFUkNMT0NLV0lTRTpuPDA/JHQuQ0xPQ0tXSVNFOiR0Lk5PTkV9c3RhdGljIGFuZ2xlQmV0d2Vlbk9yaWVudGVkKHQsZSxuKXtjb25zdCBzPSR0LmFuZ2xlKGUsdCksaT0kdC5hbmdsZShlLG4pLXM7cmV0dXJuIGk8PS1NYXRoLlBJP2krJHQuUElfVElNRVNfMjppPk1hdGguUEk/aS0kdC5QSV9USU1FU18yOml9fSR0LlBJX1RJTUVTXzI9MipNYXRoLlBJLCR0LlBJX09WRVJfMj1NYXRoLlBJLzIsJHQuUElfT1ZFUl80PU1hdGguUEkvNCwkdC5DT1VOVEVSQ0xPQ0tXSVNFPXEuQ09VTlRFUkNMT0NLV0lTRSwkdC5DTE9DS1dJU0U9cS5DTE9DS1dJU0UsJHQuTk9ORT1xLkNPTExJTkVBUjtjbGFzcyB0ZSBleHRlbmRzIG57Y29uc3RydWN0b3IoKXtzdXBlcigpLHRlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe24uY29uc3RydWN0b3JfLmNhbGwodGhpcyxcIlByb2plY3RpdmUgcG9pbnQgbm90IHJlcHJlc2VudGFibGUgb24gdGhlIENhcnRlc2lhbiBwbGFuZS5cIil9fWNsYXNzIGVle2NvbnN0cnVjdG9yKCl7ZWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy53PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy54PTAsdGhpcy55PTAsdGhpcy53PTE7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMudz0xfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMueD10LHRoaXMueT1lLHRoaXMudz0xfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQueSplLnctZS55KnQudyx0aGlzLnk9ZS54KnQudy10LngqZS53LHRoaXMudz10LngqZS55LWUueCp0Lnl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQueS1lLnksdGhpcy55PWUueC10LngsdGhpcy53PXQueCplLnktZS54KnQueX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy54PXQsdGhpcy55PWUsdGhpcy53PW59ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT10LnktZS55LHI9ZS54LXQueCxvPXQueCplLnktZS54KnQueSxsPW4ueS1zLnksYT1zLngtbi54LGM9bi54KnMueS1zLngqbi55O3RoaXMueD1yKmMtYSpvLHRoaXMueT1sKm8taSpjLHRoaXMudz1pKmEtbCpyfX1nZXRZKCl7Y29uc3QgdD10aGlzLnkvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdGU7cmV0dXJuIHR9Z2V0WCgpe2NvbnN0IHQ9dGhpcy54L3RoaXMudztpZihyLmlzTmFOKHQpfHxyLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IHRlO3JldHVybiB0fWdldENvb3JkaW5hdGUoKXtjb25zdCB0PW5ldyBtO3JldHVybiB0Lng9dGhpcy5nZXRYKCksdC55PXRoaXMuZ2V0WSgpLHR9fWNsYXNzIG5le2NvbnN0cnVjdG9yKCl7bmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLnAyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5wMD10LHRoaXMucDE9ZSx0aGlzLnAyPW59c3RhdGljIGFyZWEodCxlLG4pe3JldHVybiBNYXRoLmFicygoKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yKX1zdGF0aWMgc2lnbmVkQXJlYSh0LGUsbil7cmV0dXJuKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMn1zdGF0aWMgZGV0KHQsZSxuLHMpe3JldHVybiB0KnMtZSpufXN0YXRpYyBpbnRlcnBvbGF0ZVoodCxlLG4scyl7Y29uc3QgaT1lLngscj1lLnksbz1uLngtaSxsPXMueC1pLGE9bi55LXIsYz1zLnktcixoPW8qYy1sKmEsdT10LngtaSxnPXQueS1yLGQ9KGMqdS1sKmcpL2gsXz0oLWEqdStvKmcpL2g7cmV0dXJuIGUuZ2V0WigpK2QqKG4uZ2V0WigpLWUuZ2V0WigpKStfKihzLmdldFooKS1lLmdldFooKSl9c3RhdGljIGxvbmdlc3RTaWRlTGVuZ3RoKHQsZSxuKXtjb25zdCBzPXQuZGlzdGFuY2UoZSksaT1lLmRpc3RhbmNlKG4pLHI9bi5kaXN0YW5jZSh0KTtsZXQgbz1zO3JldHVybiBpPm8mJihvPWkpLHI+byYmKG89ciksb31zdGF0aWMgY2lyY3VtY2VudHJlREQodCxlLG4pe2NvbnN0IHM9QS52YWx1ZU9mKHQueCkuc3VidHJhY3Qobi54KSxpPUEudmFsdWVPZih0LnkpLnN1YnRyYWN0KG4ueSkscj1BLnZhbHVlT2YoZS54KS5zdWJ0cmFjdChuLngpLG89QS52YWx1ZU9mKGUueSkuc3VidHJhY3Qobi55KSxsPUEuZGV0ZXJtaW5hbnQocyxpLHIsbykubXVsdGlwbHkoMiksYT1zLnNxcigpLmFkZChpLnNxcigpKSxjPXIuc3FyKCkuYWRkKG8uc3FyKCkpLGg9QS5kZXRlcm1pbmFudChpLGEsbyxjKSx1PUEuZGV0ZXJtaW5hbnQocyxhLHIsYyksZz1BLnZhbHVlT2Yobi54KS5zdWJ0cmFjdChoLmRpdmlkZShsKSkuZG91YmxlVmFsdWUoKSxkPUEudmFsdWVPZihuLnkpLmFkZCh1LmRpdmlkZShsKSkuZG91YmxlVmFsdWUoKTtyZXR1cm4gbmV3IG0oZyxkKX1zdGF0aWMgaXNBY3V0ZSh0LGUsbil7cmV0dXJuISEkdC5pc0FjdXRlKHQsZSxuKSYmKCEhJHQuaXNBY3V0ZShlLG4sdCkmJiEhJHQuaXNBY3V0ZShuLHQsZSkpfXN0YXRpYyBjaXJjdW1jZW50cmUodCxlLG4pe2NvbnN0IHM9bi54LGk9bi55LHI9dC54LXMsbz10LnktaSxsPWUueC1zLGE9ZS55LWksYz0yKm5lLmRldChyLG8sbCxhKSxoPW5lLmRldChvLHIqcitvKm8sYSxsKmwrYSphKSx1PW5lLmRldChyLHIqcitvKm8sbCxsKmwrYSphKTtyZXR1cm4gbmV3IG0ocy1oL2MsaSt1L2MpfXN0YXRpYyBwZXJwZW5kaWN1bGFyQmlzZWN0b3IodCxlKXtjb25zdCBuPWUueC10Lngscz1lLnktdC55LGk9bmV3IGVlKHQueCtuLzIsdC55K3MvMiwxKSxyPW5ldyBlZSh0LngtcytuLzIsdC55K24rcy8yLDEpO3JldHVybiBuZXcgZWUoaSxyKX1zdGF0aWMgYW5nbGVCaXNlY3Rvcih0LGUsbil7Y29uc3Qgcz1lLmRpc3RhbmNlKHQpLGk9cy8ocytlLmRpc3RhbmNlKG4pKSxyPW4ueC10Lngsbz1uLnktdC55O3JldHVybiBuZXcgbSh0LngraSpyLHQueStpKm8pfXN0YXRpYyBhcmVhM0QodCxlLG4pe2NvbnN0IHM9ZS54LXQueCxpPWUueS10Lnkscj1lLmdldFooKS10LmdldFooKSxvPW4ueC10LngsbD1uLnktdC55LGE9bi5nZXRaKCktdC5nZXRaKCksYz1pKmEtcipsLGg9cipvLXMqYSx1PXMqbC1pKm8sZz1jKmMraCpoK3UqdTtyZXR1cm4gTWF0aC5zcXJ0KGcpLzJ9c3RhdGljIGNlbnRyb2lkKHQsZSxuKXtjb25zdCBzPSh0LngrZS54K24ueCkvMyxpPSh0LnkrZS55K24ueSkvMztyZXR1cm4gbmV3IG0ocyxpKX1zdGF0aWMgaW5DZW50cmUodCxlLG4pe2NvbnN0IHM9ZS5kaXN0YW5jZShuKSxpPXQuZGlzdGFuY2Uobikscj10LmRpc3RhbmNlKGUpLG89cytpK3IsbD0ocyp0LngraSplLngrcipuLngpL28sYT0ocyp0LnkraSplLnkrcipuLnkpL287cmV0dXJuIG5ldyBtKGwsYSl9YXJlYSgpe3JldHVybiBuZS5hcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1zaWduZWRBcmVhKCl7cmV0dXJuIG5lLnNpZ25lZEFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWludGVycG9sYXRlWih0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgcyhcIlN1cHBsaWVkIHBvaW50IGlzIG51bGwuXCIpO3JldHVybiBuZS5pbnRlcnBvbGF0ZVoodCx0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9bG9uZ2VzdFNpZGVMZW5ndGgoKXtyZXR1cm4gbmUubG9uZ2VzdFNpZGVMZW5ndGgodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWlzQWN1dGUoKXtyZXR1cm4gbmUuaXNBY3V0ZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Y2lyY3VtY2VudHJlKCl7cmV0dXJuIG5lLmNpcmN1bWNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9YXJlYTNEKCl7cmV0dXJuIG5lLmFyZWEzRCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Y2VudHJvaWQoKXtyZXR1cm4gbmUuY2VudHJvaWQodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWluQ2VudHJlKCl7cmV0dXJuIG5lLmluQ2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX19Y2xhc3Mgc2UgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxzZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCluLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO24uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19fWNsYXNzIGlle2NvbnN0cnVjdG9yKCl7aWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbTAwPW51bGwsdGhpcy5fbTAxPW51bGwsdGhpcy5fbTAyPW51bGwsdGhpcy5fbTEwPW51bGwsdGhpcy5fbTExPW51bGwsdGhpcy5fbTEyPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb0lkZW50aXR5KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbTAwPXRbMF0sdGhpcy5fbTAxPXRbMV0sdGhpcy5fbTAyPXRbMl0sdGhpcy5fbTEwPXRbM10sdGhpcy5fbTExPXRbNF0sdGhpcy5fbTEyPXRbNV19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGllKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQpfX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzVdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzRdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQsZSxuLHMsaSxyKX19c3RhdGljIHRyYW5zbGF0aW9uSW5zdGFuY2UodCxlKXtjb25zdCBuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1RyYW5zbGF0aW9uKHQsZSksbn1zdGF0aWMgc2hlYXJJbnN0YW5jZSh0LGUpe2NvbnN0IG49bmV3IGllO3JldHVybiBuLnNldFRvU2hlYXIodCxlKSxufXN0YXRpYyByZWZsZWN0aW9uSW5zdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9SZWZsZWN0aW9uKHQsZSksbn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgaWU7cmV0dXJuIGkuc2V0VG9SZWZsZWN0aW9uKHQsZSxuLHMpLGl9fXN0YXRpYyByb3RhdGlvbkluc3RhbmNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBpZS5yb3RhdGlvbkluc3RhbmNlKE1hdGguc2luKHQpLE1hdGguY29zKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9Sb3RhdGlvbih0LGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBpZS5yb3RhdGlvbkluc3RhbmNlKE1hdGguc2luKHQpLE1hdGguY29zKHQpLGUsbil9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGllO3JldHVybiBpLnNldFRvUm90YXRpb24odCxlLG4scyksaX19c3RhdGljIHNjYWxlSW5zdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9TY2FsZSh0LGUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGllO3JldHVybiBpLnRyYW5zbGF0ZSgtbiwtcyksaS5zY2FsZSh0LGUpLGkudHJhbnNsYXRlKG4scyksaX19c2V0VG9SZWZsZWN0aW9uQmFzaWModCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXRocm93IG5ldyBzKFwiUmVmbGVjdGlvbiBsaW5lIHBvaW50cyBtdXN0IGJlIGRpc3RpbmN0XCIpO2NvbnN0IHI9bi10LG89aS1lLGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9by9sLGM9ci9sLGg9MiphKmMsdT1jKmMtYSphO3JldHVybiB0aGlzLl9tMDA9dSx0aGlzLl9tMDE9aCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9aCx0aGlzLl9tMTE9LXUsdGhpcy5fbTEyPTAsdGhpc31nZXRJbnZlcnNlKCl7Y29uc3QgdD10aGlzLmdldERldGVybWluYW50KCk7aWYoMD09PXQpdGhyb3cgbmV3IHNlKFwiVHJhbnNmb3JtYXRpb24gaXMgbm9uLWludmVydGlibGVcIik7Y29uc3QgZT10aGlzLl9tMTEvdCxuPS10aGlzLl9tMTAvdCxzPS10aGlzLl9tMDEvdCxpPXRoaXMuX20wMC90LHI9KHRoaXMuX20wMSp0aGlzLl9tMTItdGhpcy5fbTAyKnRoaXMuX20xMSkvdCxvPSgtdGhpcy5fbTAwKnRoaXMuX20xMit0aGlzLl9tMTAqdGhpcy5fbTAyKS90O3JldHVybiBuZXcgaWUoZSxzLHIsbixpLG8pfWNvbXBvc2UodCl7Y29uc3QgZT10Ll9tMDAqdGhpcy5fbTAwK3QuX20wMSp0aGlzLl9tMTAsbj10Ll9tMDAqdGhpcy5fbTAxK3QuX20wMSp0aGlzLl9tMTEscz10Ll9tMDAqdGhpcy5fbTAyK3QuX20wMSp0aGlzLl9tMTIrdC5fbTAyLGk9dC5fbTEwKnRoaXMuX20wMCt0Ll9tMTEqdGhpcy5fbTEwLHI9dC5fbTEwKnRoaXMuX20wMSt0Ll9tMTEqdGhpcy5fbTExLG89dC5fbTEwKnRoaXMuX20wMit0Ll9tMTEqdGhpcy5fbTEyK3QuX20xMjtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPW4sdGhpcy5fbTAyPXMsdGhpcy5fbTEwPWksdGhpcy5fbTExPXIsdGhpcy5fbTEyPW8sdGhpc31lcXVhbHModCl7aWYobnVsbD09PXQpcmV0dXJuITE7aWYoISh0IGluc3RhbmNlb2YgaWUpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fbTAwPT09ZS5fbTAwJiZ0aGlzLl9tMDE9PT1lLl9tMDEmJnRoaXMuX20wMj09PWUuX20wMiYmdGhpcy5fbTEwPT09ZS5fbTEwJiZ0aGlzLl9tMTE9PT1lLl9tMTEmJnRoaXMuX20xMj09PWUuX20xMn1zZXRUb1NjYWxlKHQsZSl7cmV0dXJuIHRoaXMuX20wMD10LHRoaXMuX20wMT0wLHRoaXMuX20wMj0wLHRoaXMuX20xMD0wLHRoaXMuX20xMT1lLHRoaXMuX20xMj0wLHRoaXN9aXNJZGVudGl0eSgpe3JldHVybiAxPT09dGhpcy5fbTAwJiYwPT09dGhpcy5fbTAxJiYwPT09dGhpcy5fbTAyJiYwPT09dGhpcy5fbTEwJiYxPT09dGhpcy5fbTExJiYwPT09dGhpcy5fbTEyfXNjYWxlKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShpZS5zY2FsZUluc3RhbmNlKHQsZSkpLHRoaXN9c2V0VG9JZGVudGl0eSgpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9MCx0aGlzfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITB9c2V0VHJhbnNmb3JtYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX20wMD10Ll9tMDAsdGhpcy5fbTAxPXQuX20wMSx0aGlzLl9tMDI9dC5fbTAyLHRoaXMuX20xMD10Ll9tMTAsdGhpcy5fbTExPXQuX20xMSx0aGlzLl9tMTI9dC5fbTEyLHRoaXN9aWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3JldHVybiB0aGlzLl9tMDA9dCx0aGlzLl9tMDE9ZSx0aGlzLl9tMDI9bix0aGlzLl9tMTA9cyx0aGlzLl9tMTE9aSx0aGlzLl9tMTI9cix0aGlzfX1zZXRUb1JvdGF0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNldFRvUm90YXRpb24oTWF0aC5zaW4odCksTWF0aC5jb3ModCkpLHRoaXN9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9LXQsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPXQsdGhpcy5fbTExPWUsdGhpcy5fbTEyPTAsdGhpc31pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuc2V0VG9Sb3RhdGlvbihNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSxlLG4pLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9LXQsdGhpcy5fbTAyPW4tbiplK3MqdCx0aGlzLl9tMTA9dCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9cy1uKnQtcyplLHRoaXN9fWdldE1hdHJpeEVudHJpZXMoKXtyZXR1cm5bdGhpcy5fbTAwLHRoaXMuX20wMSx0aGlzLl9tMDIsdGhpcy5fbTEwLHRoaXMuX20xMSx0aGlzLl9tMTJdfWZpbHRlcih0LGUpe3RoaXMudHJhbnNmb3JtKHQsZSl9cm90YXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucm90YXRpb25JbnN0YW5jZSh0KSksdGhpc31pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucm90YXRpb25JbnN0YW5jZSh0LGUsbikpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucm90YXRpb25JbnN0YW5jZSh0LGUsbixzKSksdGhpc319Z2V0RGV0ZXJtaW5hbnQoKXtyZXR1cm4gdGhpcy5fbTAwKnRoaXMuX20xMS10aGlzLl9tMDEqdGhpcy5fbTEwfWNvbXBvc2VCZWZvcmUodCl7Y29uc3QgZT10aGlzLl9tMDAqdC5fbTAwK3RoaXMuX20wMSp0Ll9tMTAsbj10aGlzLl9tMDAqdC5fbTAxK3RoaXMuX20wMSp0Ll9tMTEscz10aGlzLl9tMDAqdC5fbTAyK3RoaXMuX20wMSp0Ll9tMTIrdGhpcy5fbTAyLGk9dGhpcy5fbTEwKnQuX20wMCt0aGlzLl9tMTEqdC5fbTEwLHI9dGhpcy5fbTEwKnQuX20wMSt0aGlzLl9tMTEqdC5fbTExLG89dGhpcy5fbTEwKnQuX20wMit0aGlzLl9tMTEqdC5fbTEyK3RoaXMuX20xMjtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPW4sdGhpcy5fbTAyPXMsdGhpcy5fbTEwPWksdGhpcy5fbTExPXIsdGhpcy5fbTEyPW8sdGhpc31zZXRUb1NoZWFyKHQsZSl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT10LHRoaXMuX20wMj0wLHRoaXMuX20xMD1lLHRoaXMuX20xMT0xLHRoaXMuX20xMj0wLHRoaXN9aXNEb25lKCl7cmV0dXJuITF9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgdDtnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG51bGx9dHJhbnNsYXRlKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShpZS50cmFuc2xhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9c2V0VG9SZWZsZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgcyhcIlJlZmxlY3Rpb24gdmVjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7aWYodD09PWUpcmV0dXJuIHRoaXMuX20wMD0wLHRoaXMuX20wMT0xLHRoaXMuX20wMj0wLHRoaXMuX20xMD0xLHRoaXMuX20xMT0wLHRoaXMuX20xMj0wLHRoaXM7Y29uc3Qgbj1NYXRoLnNxcnQodCp0K2UqZSksaT1lL24scj10L247cmV0dXJuIHRoaXMucm90YXRlKC1pLHIpLHRoaXMuc2NhbGUoMSwtMSksdGhpcy5yb3RhdGUoaSxyKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtpZih0PT09biYmZT09PWkpdGhyb3cgbmV3IHMoXCJSZWZsZWN0aW9uIGxpbmUgcG9pbnRzIG11c3QgYmUgZGlzdGluY3RcIik7dGhpcy5zZXRUb1RyYW5zbGF0aW9uKC10LC1lKTtjb25zdCByPW4tdCxvPWktZSxsPU1hdGguc3FydChyKnIrbypvKSxhPW8vbCxjPXIvbDtyZXR1cm4gdGhpcy5yb3RhdGUoLWEsYyksdGhpcy5zY2FsZSgxLC0xKSx0aGlzLnJvdGF0ZShhLGMpLHRoaXMudHJhbnNsYXRlKHQsZSksdGhpc319dG9TdHJpbmcoKXtyZXR1cm5cIkFmZmluZVRyYW5zZm9ybWF0aW9uW1tcIit0aGlzLl9tMDArXCIsIFwiK3RoaXMuX20wMStcIiwgXCIrdGhpcy5fbTAyK1wiXSwgW1wiK3RoaXMuX20xMCtcIiwgXCIrdGhpcy5fbTExK1wiLCBcIit0aGlzLl9tMTIrXCJdXVwifXNldFRvVHJhbnNsYXRpb24odCxlKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPXQsdGhpcy5fbTEwPTAsdGhpcy5fbTExPTEsdGhpcy5fbTEyPWUsdGhpc31zaGVhcih0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UoaWUuc2hlYXJJbnN0YW5jZSh0LGUpKSx0aGlzfXRyYW5zZm9ybSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXS5jb3B5KCk7cmV0dXJuIHQuYXBwbHkodGhpcyksdH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbTAwKnQueCt0aGlzLl9tMDEqdC55K3RoaXMuX20wMixzPXRoaXMuX20xMCp0LngrdGhpcy5fbTExKnQueSt0aGlzLl9tMTI7cmV0dXJuIGUueD1uLGUueT1zLGV9aWYoSShhcmd1bWVudHNbMF0sRykmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9tMDAqdC5nZXRPcmRpbmF0ZShlLDApK3RoaXMuX20wMSp0LmdldE9yZGluYXRlKGUsMSkrdGhpcy5fbTAyLHM9dGhpcy5fbTEwKnQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLl9tMTEqdC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMuX20xMjt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX19fXJlZmxlY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlKSksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlLG4scykpLHRoaXN9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsLFBdfX1jbGFzcyByZXtzdGF0aWMgc29sdmUodCxlKXtjb25zdCBuPWUubGVuZ3RoO2lmKHQubGVuZ3RoIT09bnx8dFswXS5sZW5ndGghPT1uKXRocm93IG5ldyBzKFwiTWF0cml4IEEgaXMgaW5jb3JyZWN0bHkgc2l6ZWRcIik7Zm9yKGxldCBzPTA7czxuO3MrKyl7bGV0IGk9cztmb3IobGV0IGU9cysxO2U8bjtlKyspTWF0aC5hYnModFtlXVtzXSk+TWF0aC5hYnModFtpXVtzXSkmJihpPWUpO2lmKDA9PT10W2ldW3NdKXJldHVybiBudWxsO3JlLnN3YXBSb3dzKHQscyxpKSxyZS5zd2FwUm93cyhlLHMsaSk7Zm9yKGxldCBpPXMrMTtpPG47aSsrKXtjb25zdCByPXRbaV1bc10vdFtzXVtzXTtmb3IobGV0IGU9bi0xO2U+PXM7ZS0tKXRbaV1bZV0tPXRbc11bZV0qcjtlW2ldLT1lW3NdKnJ9fWNvbnN0IGk9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7Zm9yKGxldCBzPW4tMTtzPj0wO3MtLSl7bGV0IHI9MDtmb3IobGV0IGU9cysxO2U8bjtlKyspcis9dFtzXVtlXSppW2VdO2lbc109KGVbc10tcikvdFtzXVtzXX1yZXR1cm4gaX1zdGF0aWMgc3dhcFJvd3MoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKGxldCBzPTA7czx0WzBdLmxlbmd0aDtzKyspe2NvbnN0IGk9dFtlXVtzXTt0W2VdW3NdPXRbbl1bc10sdFtuXVtzXT1pfX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPT09bilyZXR1cm4gbnVsbDtjb25zdCBzPXRbZV07dFtlXT10W25dLHRbbl09c319fWNsYXNzIG9le2NvbnN0cnVjdG9yKCl7b2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3JjMD1udWxsLHRoaXMuX3NyYzE9bnVsbCx0aGlzLl9zcmMyPW51bGwsdGhpcy5fZGVzdDA9bnVsbCx0aGlzLl9kZXN0MT1udWxsLHRoaXMuX2Rlc3QyPW51bGwsdGhpcy5fbTAwPW51bGwsdGhpcy5fbTAxPW51bGwsdGhpcy5fbTAyPW51bGwsdGhpcy5fbTEwPW51bGwsdGhpcy5fbTExPW51bGwsdGhpcy5fbTEyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07dGhpcy5fc3JjMD10LHRoaXMuX3NyYzE9ZSx0aGlzLl9zcmMyPW4sdGhpcy5fZGVzdDA9cyx0aGlzLl9kZXN0MT1pLHRoaXMuX2Rlc3QyPXJ9c29sdmUodCl7Y29uc3QgZT1bW3RoaXMuX3NyYzAueCx0aGlzLl9zcmMwLnksMV0sW3RoaXMuX3NyYzEueCx0aGlzLl9zcmMxLnksMV0sW3RoaXMuX3NyYzIueCx0aGlzLl9zcmMyLnksMV1dO3JldHVybiByZS5zb2x2ZShlLHQpfWNvbXB1dGUoKXtjb25zdCB0PVt0aGlzLl9kZXN0MC54LHRoaXMuX2Rlc3QxLngsdGhpcy5fZGVzdDIueF0sZT10aGlzLnNvbHZlKHQpO2lmKG51bGw9PT1lKXJldHVybiExO3RoaXMuX20wMD1lWzBdLHRoaXMuX20wMT1lWzFdLHRoaXMuX20wMj1lWzJdO2NvbnN0IG49W3RoaXMuX2Rlc3QwLnksdGhpcy5fZGVzdDEueSx0aGlzLl9kZXN0Mi55XSxzPXRoaXMuc29sdmUobik7cmV0dXJuIG51bGwhPT1zJiYodGhpcy5fbTEwPXNbMF0sdGhpcy5fbTExPXNbMV0sdGhpcy5fbTEyPXNbMl0sITApfWdldFRyYW5zZm9ybWF0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpP25ldyBpZSh0aGlzLl9tMDAsdGhpcy5fbTAxLHRoaXMuX20wMix0aGlzLl9tMTAsdGhpcy5fbTExLHRoaXMuX20xMik6bnVsbH19Y2xhc3MgbGV7c3RhdGljIGNyZWF0ZUZyb21CYXNlTGluZXModCxlLG4scyl7Y29uc3QgaT1uZXcgbSh0Lngrcy54LW4ueCx0Lnkrcy55LW4ueSkscj0kdC5hbmdsZUJldHdlZW5PcmllbnRlZChlLHQsaSksbz1lLmRpc3RhbmNlKHQpLGw9cy5kaXN0YW5jZShuKTtpZigwPT09bylyZXR1cm4gbmV3IGllO2NvbnN0IGE9bC9vLGM9aWUudHJhbnNsYXRpb25JbnN0YW5jZSgtdC54LC10LnkpO3JldHVybiBjLnJvdGF0ZShyKSxjLnNjYWxlKGEsYSksYy50cmFuc2xhdGUobi54LG4ueSksY31zdGF0aWMgY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10Lngscz1lLnktdC55O3JldHVybiBpZS50cmFuc2xhdGlvbkluc3RhbmNlKG4scyl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgcyhcIlNyYyBhbmQgRGVzdCBhcnJheXMgYXJlIG5vdCB0aGUgc2FtZSBsZW5ndGhcIik7aWYodC5sZW5ndGg8PTApdGhyb3cgbmV3IHMoXCJUb28gZmV3IGNvbnRyb2wgcG9pbnRzXCIpO2lmKHQubGVuZ3RoPjMpdGhyb3cgbmV3IHMoXCJUb28gbWFueSBjb250cm9sIHBvaW50c1wiKTtyZXR1cm4gMT09PXQubGVuZ3RoP2xlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLGVbMF0pOjI9PT10Lmxlbmd0aD9sZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSx0WzFdLGVbMF0sZVsxXSk6bGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sdFsxXSx0WzJdLGVbMF0sZVsxXSxlWzJdKX19ZWxzZXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgbShzLngtbi54LHMueS1uLnkpLHI9JHQuYW5nbGVCZXR3ZWVuT3JpZW50ZWQoZSx0LGkpLG89ZS5kaXN0YW5jZSh0KSxsPXMuZGlzdGFuY2Uobik7aWYoMD09PW8pcmV0dXJuIG51bGw7Y29uc3QgYT1sL28sYz1pZS50cmFuc2xhdGlvbkluc3RhbmNlKC10LngsLXQueSk7cmV0dXJuIGMucm90YXRlKHIpLGMuc2NhbGUoYSxhKSxjLnRyYW5zbGF0ZShuLngsbi55KSxjfWlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IG9lKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdKS5nZXRUcmFuc2Zvcm1hdGlvbigpfX19fWNsYXNzIGFle2NvbnN0cnVjdG9yKCl7YWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29vcmRzPXR9c3RhdGljIGdldENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEw7cmV0dXJuIHQuYXBwbHkobmV3IGFlKGUpKSxlfWZpbHRlcih0KXsodCBpbnN0YW5jZW9mICR8fHQgaW5zdGFuY2VvZiBldCkmJnRoaXMuX2Nvb3Jkcy5hZGQodC5nZXRDb29yZGluYXRlKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX19Y2xhc3MgY2V7Y29uc3RydWN0b3IoKXtjZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9tYXBPcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21hcE9wPXR9c3RhdGljIG1hcCh0LGUpe3JldHVybiBuZXcgY2UoZSkubWFwKHQpfW1hcCh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXRoaXMuX21hcE9wLm1hcCh0LmdldEdlb21ldHJ5TihuKSk7cy5pc0VtcHR5KCl8fGUuYWRkKHMpfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oTHQudG9HZW9tZXRyeUFycmF5KGUpKX19Y2xhc3MgaGV7Y29uc3RydWN0b3IoKXtoZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX3NraXBFbXB0eT0hMSx0aGlzLl9pbnB1dEdlb21zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Rvcnk9aGUuZXh0cmFjdEZhY3RvcnkodCksdGhpcy5faW5wdXRHZW9tcz10fXN0YXRpYyBjb21iaW5lKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgaGUoYXJndW1lbnRzWzBdKS5jb21iaW5lKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgaGUoaGUuY3JlYXRlTGlzdCh0LGUpKS5jb21iaW5lKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuZXcgaGUoaGUuY3JlYXRlTGlzdCh0LGUsbikpLmNvbWJpbmUoKX19c3RhdGljIGV4dHJhY3RGYWN0b3J5KHQpe3JldHVybiB0LmlzRW1wdHkoKT9udWxsOnQuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpfXN0YXRpYyBjcmVhdGVMaXN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7cmV0dXJuIG4uYWRkKHQpLG4uYWRkKGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IEw7cmV0dXJuIHMuYWRkKHQpLHMuYWRkKGUpLHMuYWRkKG4pLHN9fWV4dHJhY3RFbGVtZW50cyh0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO3RoaXMuX3NraXBFbXB0eSYmcy5pc0VtcHR5KCl8fGUuYWRkKHMpfX1jb21iaW5lKCl7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9dGhpcy5faW5wdXRHZW9tcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3RFbGVtZW50cyhuLHQpfXJldHVybiAwPT09dC5zaXplKCk/bnVsbCE9PXRoaXMuX2dlb21GYWN0b3J5P3RoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpOm51bGw6dGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX19Y2xhc3MgdWV7Y29uc3RydWN0b3IoKXt1ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5faXNVc2VyRGF0YUNvcGllZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fX1zZXRDb3B5VXNlckRhdGEodCl7dGhpcy5faXNVc2VyRGF0YUNvcGllZD10fWVkaXQodCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuZWRpdEludGVybmFsKHQsZSk7cmV0dXJuIHRoaXMuX2lzVXNlckRhdGFDb3BpZWQmJm4uc2V0VXNlckRhdGEodC5nZXRVc2VyRGF0YSgpKSxufWVkaXRJbnRlcm5hbCh0LGUpe3JldHVybiBudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHQgaW5zdGFuY2VvZiBodD90aGlzLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKTp0IGluc3RhbmNlb2YgcnQ/dGhpcy5lZGl0UG9seWdvbih0LGUpOnQgaW5zdGFuY2VvZiBldHx8dCBpbnN0YW5jZW9mICQ/ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSk6KGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbnN1cHBvcnRlZCBHZW9tZXRyeSB0eXBlOiBcIit0LmdldEdlb21ldHJ5VHlwZSgpKSxudWxsKX1lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj1lLmVkaXQodCx0aGlzLl9mYWN0b3J5KSxzPW5ldyBMO2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBpPXRoaXMuZWRpdChuLmdldEdlb21ldHJ5Tih0KSxlKTtudWxsPT09aXx8aS5pc0VtcHR5KCl8fHMuYWRkKGkpfXJldHVybiBuLmdldEdlb21ldHJ5VHlwZSgpPT09VS5UWVBFTkFNRV9NVUxUSVBPSU5UP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChzLnRvQXJyYXkoW10pKTpuLmdldEdlb21ldHJ5VHlwZSgpPT09VS5UWVBFTkFNRV9NVUxUSUxJTkVTVFJJTkc/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocy50b0FycmF5KFtdKSk6bi5nZXRHZW9tZXRyeVR5cGUoKT09PVUuVFlQRU5BTUVfTVVMVElQT0xZR09OP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKHMudG9BcnJheShbXSkpOnRoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKHMudG9BcnJheShbXSkpfWVkaXRQb2x5Z29uKHQsZSl7bGV0IG49ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSk7aWYobnVsbD09PW4mJihuPXRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbigpKSxuLmlzRW1wdHkoKSlyZXR1cm4gbjtjb25zdCBzPXRoaXMuZWRpdChuLmdldEV4dGVyaW9yUmluZygpLGUpO2lmKG51bGw9PT1zfHxzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7Y29uc3QgaT1uZXcgTDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXtjb25zdCBzPXRoaXMuZWRpdChuLmdldEludGVyaW9yUmluZ04odCksZSk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHxpLmFkZChzKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHMsaS50b0FycmF5KFtdKSl9fWZ1bmN0aW9uIGdlKCl7fXVlLkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uPWdlO3VlLk5vT3BHZW9tZXRyeU9wZXJhdGlvbj1jbGFzc3tlZGl0KHQsZSl7cmV0dXJuIHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2dlXX19LHVlLkNvb3JkaW5hdGVPcGVyYXRpb249Y2xhc3N7ZWRpdCh0LGUpe2NvbnN0IG49dGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KTtyZXR1cm4gdCBpbnN0YW5jZW9mIGd0P251bGw9PT1uP2UuY3JlYXRlTGluZWFyUmluZygpOmUuY3JlYXRlTGluZWFyUmluZyhuKTp0IGluc3RhbmNlb2YgJD9udWxsPT09bj9lLmNyZWF0ZUxpbmVTdHJpbmcoKTplLmNyZWF0ZUxpbmVTdHJpbmcobik6dCBpbnN0YW5jZW9mIGV0P251bGw9PT1ufHwwPT09bi5sZW5ndGg/ZS5jcmVhdGVQb2ludCgpOmUuY3JlYXRlUG9pbnQoblswXSk6dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ2VdfX0sdWUuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uPWNsYXNze2VkaXQodCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIGd0P2UuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mICQ/ZS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgZXQ/ZS5jcmVhdGVQb2ludCh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ2VdfX07Y2xhc3MgZGV7Y29uc3RydWN0b3IoKXtkZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tZXRyeVR5cGU9bnVsbCx0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21ldHJ5VHlwZT10LHRoaXMuX2NvbXBzPWV9c3RhdGljIGlzT2ZUeXBlKHQsZSl7cmV0dXJuIHQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1lfHxlPT09VS5UWVBFTkFNRV9MSU5FU1RSSU5HJiZ0LmdldEdlb21ldHJ5VHlwZSgpPT09VS5UWVBFTkFNRV9MSU5FQVJSSU5HfXN0YXRpYyBleHRyYWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBkZS5leHRyYWN0KHQsZSxuZXcgTCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0LmdldEdlb21ldHJ5VHlwZSgpPT09ZT9uLmFkZCh0KTp0IGluc3RhbmNlb2YgaHQmJnQuYXBwbHkobmV3IGRlKGUsbikpLG59fWZpbHRlcih0KXsobnVsbD09PXRoaXMuX2dlb21ldHJ5VHlwZXx8ZGUuaXNPZlR5cGUodCx0aGlzLl9nZW9tZXRyeVR5cGUpKSYmdGhpcy5fY29tcHMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKXX19Y2xhc3MgX2V7c3RhdGljIG1hcCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSYmSShhcmd1bWVudHNbMV0scGUpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1HZW9tZXRyaWVzKCk7cysrKXtjb25zdCBpPWUubWFwKHQuZ2V0R2VvbWV0cnlOKHMpKTtudWxsIT09aSYmbi5hZGQoaSl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkobil9aWYoSShhcmd1bWVudHNbMF0sTikmJkkoYXJndW1lbnRzWzFdLHBlKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPWUubWFwKHQpO251bGwhPT1pJiZuLmFkZChpKX1yZXR1cm4gbn19fWZ1bmN0aW9uIHBlKCl7fV9lLk1hcE9wPXBlO2NsYXNzIG1le2NvbnN0cnVjdG9yKCl7bWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX3BydW5lRW1wdHlHZW9tZXRyeT0hMCx0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU9ITAsdGhpcy5fcHJlc2VydmVDb2xsZWN0aW9ucz0hMSx0aGlzLl9wcmVzZXJ2ZVR5cGU9ITF9dHJhbnNmb3JtUG9pbnQodCxlKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfXRyYW5zZm9ybVBvbHlnb24odCxlKXtsZXQgbj0hMDtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEV4dGVyaW9yUmluZygpLHQpO251bGwhPT1zJiZzIGluc3RhbmNlb2YgZ3QmJiFzLmlzRW1wdHkoKXx8KG49ITEpO2NvbnN0IGk9bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpLHQpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8KHMgaW5zdGFuY2VvZiBndHx8KG49ITEpLGkuYWRkKHMpKX1pZihuKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24ocyxpLnRvQXJyYXkoW10pKTt7Y29uc3QgdD1uZXcgTDtyZXR1cm4gbnVsbCE9PXMmJnQuYWRkKHMpLHQuYWRkQWxsKGkpLHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX19Y3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlKHQpe3JldHVybiB0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCl9Z2V0SW5wdXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb219dHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtyZXR1cm4gdGhpcy5jb3B5KHQpfXRyYW5zZm9ybUxpbmVTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9dHJhbnNmb3JtTXVsdGlQb2ludCh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1Qb2ludCh0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtUG9seWdvbih0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX1jb3B5KHQpe3JldHVybiB0LmNvcHkoKX10cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtKHQuZ2V0R2VvbWV0cnlOKGUpKTtudWxsIT09cyYmKHRoaXMuX3BydW5lRW1wdHlHZW9tZXRyeSYmcy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlP3RoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEx0LnRvR2VvbWV0cnlBcnJheShuKSk6dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybSh0KXtpZih0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHQgaW5zdGFuY2VvZiBldClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiB1dClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGd0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgJClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFN0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBydClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIHl0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBodClyZXR1cm4gdGhpcy50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxudWxsKTt0aHJvdyBuZXcgcyhcIlVua25vd24gR2VvbWV0cnkgc3VidHlwZTogXCIrdC5nZXRHZW9tZXRyeVR5cGUoKSl9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49dGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobnVsbCk7Y29uc3Qgcz1uLnNpemUoKTtyZXR1cm4gcz4wJiZzPDQmJiF0aGlzLl9wcmVzZXJ2ZVR5cGU/dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4pOnRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuKX19Y2xhc3MgZmV7Y29uc3RydWN0b3IoKXtmZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBzPXR9c3RhdGljIGdldEdlb21ldHJ5KHQpe3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGZlLmdldExpbmVzKHQpKX1zdGF0aWMgZ2V0TGluZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGZlLmdldExpbmVzKHQsbmV3IEwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mICQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIGh0JiZ0LmFwcGx5KG5ldyBmZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiAkJiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pdfX1jbGFzcyB5ZXtjb25zdHJ1Y3Rvcigpe3llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xpbmVzPW51bGwsdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmc9ITEsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVzPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbGluZXM9dCx0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz1lfX1zdGF0aWMgZ2V0R2VvbWV0cnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoeWUuZ2V0TGluZXModCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh5ZS5nZXRMaW5lcyh0LGUpKX19c3RhdGljIGdldExpbmVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB5ZS5nZXRMaW5lcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sTikmJkkoYXJndW1lbnRzWzFdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtmb3IobGV0IGU9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3llLmdldExpbmVzKG4sdCl9cmV0dXJuIHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtyZXR1cm4gdC5hcHBseShuZXcgeWUobixlKSksbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUmJkkoYXJndW1lbnRzWzFdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mICQ/ZS5hZGQodCk6dC5hcHBseShuZXcgeWUoZSkpLGV9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZJKGFyZ3VtZW50c1swXSxOKSYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO2ZvcihsZXQgbj1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7eWUuZ2V0TGluZXMocyx0LGUpfXJldHVybiB0fWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUmJkkoYXJndW1lbnRzWzFdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXTtyZXR1cm4gYXJndW1lbnRzWzBdLmFwcGx5KG5ldyB5ZSh0LGUpKSx0fX19ZmlsdGVyKHQpe2lmKHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nJiZ0IGluc3RhbmNlb2YgZ3Qpe2NvbnN0IGU9dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtyZXR1cm4gdGhpcy5fbGluZXMuYWRkKGUpLG51bGx9dCBpbnN0YW5jZW9mICQmJnRoaXMuX2xpbmVzLmFkZCh0KX1zZXRGb3JjZVRvTGluZVN0cmluZyh0KXt0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX19Y29uc3QgeGU9e3JldmVyc2VPcmRlcjpmdW5jdGlvbigpe3JldHVybntjb21wYXJlOih0LGUpPT5lLmNvbXBhcmVUbyh0KX19LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4geGUuc29ydCh0KSx0LmdldCgwKX0sc29ydDpmdW5jdGlvbih0LGUpe2NvbnN0IG49dC50b0FycmF5KCk7ZT9zdC5zb3J0KG4sZSk6c3Quc29ydChuKTtjb25zdCBzPXQuaXRlcmF0b3IoKTtmb3IobGV0IHQ9MCxlPW4ubGVuZ3RoO3Q8ZTt0Kyspcy5uZXh0KCkscy5zZXQoblt0XSl9LHNpbmdsZXRvbkxpc3Q6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgTDtyZXR1cm4gZS5hZGQodCksZX19O2NsYXNzIEVle2NvbnN0cnVjdG9yKCl7RWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXR9c3RhdGljIGdldFBvaW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdCBpbnN0YW5jZW9mIGV0P3hlLnNpbmdsZXRvbkxpc3QodCk6RWUuZ2V0UG9pbnRzKHQsbmV3IEwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIGV0P2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBodCYmdC5hcHBseShuZXcgRWUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgZXQmJnRoaXMuX3B0cy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pdfX1jbGFzcyBJZXtjb25zdHJ1Y3Rvcigpe0llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcHM9dH1zdGF0aWMgZ2V0UG9seWdvbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEllLmdldFBvbHlnb25zKHQsbmV3IEwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIHJ0P2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBodCYmdC5hcHBseShuZXcgSWUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgcnQmJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSl19fWNsYXNzIE5le2NvbnN0cnVjdG9yKCl7TmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNEb25lPSExfWFwcGx5VG8odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKSYmIXRoaXMuX2lzRG9uZTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYobiBpbnN0YW5jZW9mIGh0KXRoaXMuYXBwbHlUbyhuKTtlbHNlIGlmKHRoaXMudmlzaXQobiksdGhpcy5pc0RvbmUoKSlyZXR1cm4gdGhpcy5faXNEb25lPSEwLG51bGx9fX1jbGFzcyB3ZXtjb25zdHJ1Y3Rvcigpe3dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fcHJlY01vZGVsPW51bGwsdGhpcy5fZGltPW5ldyBDZSx0aGlzLl9uUHRzPTEwMCx0aGlzLl9yb3RhdGlvbkFuZ2xlPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpd2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgTHQpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0PXQsdGhpcy5fcHJlY01vZGVsPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKX19Y3JlYXRlU3VwZXJjaXJjbGUodCl7Y29uc3QgZT0xL3Qsbj10aGlzLl9kaW0uZ2V0TWluU2l6ZSgpLzIscz10aGlzLl9kaW0uZ2V0Q2VudHJlKCksaT1NYXRoLnBvdyhuLHQpLHI9bixvPU1hdGgucG93KGkvMixlKSxsPU1hdGgudHJ1bmModGhpcy5fblB0cy84KSxhPW5ldyBBcnJheSg4KmwrMSkuZmlsbChudWxsKSxjPW8vbDtmb3IobGV0IG49MDtuPD1sO24rKyl7bGV0IG89MCxoPXI7aWYoMCE9PW4pe289YypuO2NvbnN0IHM9TWF0aC5wb3cobyx0KTtoPU1hdGgucG93KGktcyxlKX1hW25dPXRoaXMuY29vcmRUcmFucyhvLGgscyksYVsyKmwtbl09dGhpcy5jb29yZFRyYW5zKGgsbyxzKSxhWzIqbCtuXT10aGlzLmNvb3JkVHJhbnMoaCwtbyxzKSxhWzQqbC1uXT10aGlzLmNvb3JkVHJhbnMobywtaCxzKSxhWzQqbCtuXT10aGlzLmNvb3JkVHJhbnMoLW8sLWgscyksYVs2Kmwtbl09dGhpcy5jb29yZFRyYW5zKC1oLC1vLHMpLGFbNipsK25dPXRoaXMuY29vcmRUcmFucygtaCxvLHMpLGFbOCpsLW5dPXRoaXMuY29vcmRUcmFucygtbyxoLHMpfWFbYS5sZW5ndGgtMV09bmV3IG0oYVswXSk7Y29uc3QgaD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGEpLHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihoKTtyZXR1cm4gdGhpcy5yb3RhdGUodSl9c2V0TnVtUG9pbnRzKHQpe3RoaXMuX25QdHM9dH1zZXRCYXNlKHQpe3RoaXMuX2RpbS5zZXRCYXNlKHQpfXNldFJvdGF0aW9uKHQpe3RoaXMuX3JvdGF0aW9uQW5nbGU9dH1zZXRXaWR0aCh0KXt0aGlzLl9kaW0uc2V0V2lkdGgodCl9Y3JlYXRlRWxsaXBzZSgpe2NvbnN0IHQ9dGhpcy5fZGltLmdldEVudmVsb3BlKCksZT10LmdldFdpZHRoKCkvMixuPXQuZ2V0SGVpZ2h0KCkvMixzPXQuZ2V0TWluWCgpK2UsaT10LmdldE1pblkoKStuLHI9bmV3IEFycmF5KHRoaXMuX25QdHMrMSkuZmlsbChudWxsKTtsZXQgbz0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fblB0czt0Kyspe2NvbnN0IGw9dCooMipNYXRoLlBJL3RoaXMuX25QdHMpLGE9ZSpNYXRoLmNvcyhsKStzLGM9bipNYXRoLnNpbihsKStpO3JbbysrXT10aGlzLmNvb3JkKGEsYyl9cltvXT1uZXcgbShyWzBdKTtjb25zdCBsPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcociksYT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGwpO3JldHVybiB0aGlzLnJvdGF0ZShhKX1jb29yZFRyYW5zKHQsZSxuKXtyZXR1cm4gdGhpcy5jb29yZCh0K24ueCxlK24ueSl9Y3JlYXRlU3F1aXJjbGUoKXtyZXR1cm4gdGhpcy5jcmVhdGVTdXBlcmNpcmNsZSg0KX1zZXRFbnZlbG9wZSh0KXt0aGlzLl9kaW0uc2V0RW52ZWxvcGUodCl9c2V0Q2VudHJlKHQpe3RoaXMuX2RpbS5zZXRDZW50cmUodCl9Y3JlYXRlQXJjKHQsZSl7Y29uc3Qgbj10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxzPW4uZ2V0V2lkdGgoKS8yLGk9bi5nZXRIZWlnaHQoKS8yLHI9bi5nZXRNaW5YKCkrcyxvPW4uZ2V0TWluWSgpK2k7bGV0IGw9ZTsobDw9MHx8bD4yKk1hdGguUEkpJiYobD0yKk1hdGguUEkpO2NvbnN0IGE9bC8odGhpcy5fblB0cy0xKSxjPW5ldyBBcnJheSh0aGlzLl9uUHRzKS5maWxsKG51bGwpO2xldCBoPTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9uUHRzO2UrKyl7Y29uc3Qgbj10K2UqYSxsPXMqTWF0aC5jb3Mobikrcix1PWkqTWF0aC5zaW4obikrbztjW2grK109dGhpcy5jb29yZChsLHUpfWNvbnN0IHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZVN0cmluZyhjKTtyZXR1cm4gdGhpcy5yb3RhdGUodSl9cm90YXRlKHQpe2lmKDAhPT10aGlzLl9yb3RhdGlvbkFuZ2xlKXtjb25zdCBlPWllLnJvdGF0aW9uSW5zdGFuY2UodGhpcy5fcm90YXRpb25BbmdsZSx0aGlzLl9kaW0uZ2V0Q2VudHJlKCkueCx0aGlzLl9kaW0uZ2V0Q2VudHJlKCkueSk7dC5hcHBseShlKX1yZXR1cm4gdH1jb29yZCh0LGUpe2NvbnN0IG49bmV3IG0odCxlKTtyZXR1cm4gdGhpcy5fcHJlY01vZGVsLm1ha2VQcmVjaXNlKG4pLG59Y3JlYXRlQXJjUG9seWdvbih0LGUpe2NvbnN0IG49dGhpcy5fZGltLmdldEVudmVsb3BlKCkscz1uLmdldFdpZHRoKCkvMixpPW4uZ2V0SGVpZ2h0KCkvMixyPW4uZ2V0TWluWCgpK3Msbz1uLmdldE1pblkoKStpO2xldCBsPWU7KGw8PTB8fGw+MipNYXRoLlBJKSYmKGw9MipNYXRoLlBJKTtjb25zdCBhPWwvKHRoaXMuX25QdHMtMSksYz1uZXcgQXJyYXkodGhpcy5fblB0cysyKS5maWxsKG51bGwpO2xldCBoPTA7Y1toKytdPXRoaXMuY29vcmQocixvKTtmb3IobGV0IGU9MDtlPHRoaXMuX25QdHM7ZSsrKXtjb25zdCBuPXQrYSplLGw9cypNYXRoLmNvcyhuKStyLHU9aSpNYXRoLnNpbihuKStvO2NbaCsrXT10aGlzLmNvb3JkKGwsdSl9Y1toKytdPXRoaXMuY29vcmQocixvKTtjb25zdCB1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcoYyksZz10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKHUpO3JldHVybiB0aGlzLnJvdGF0ZShnKX1jcmVhdGVSZWN0YW5nbGUoKXtsZXQgdD1udWxsLGU9MCxuPU1hdGgudHJ1bmModGhpcy5fblB0cy80KTtuPDEmJihuPTEpO2NvbnN0IHM9dGhpcy5fZGltLmdldEVudmVsb3BlKCkuZ2V0V2lkdGgoKS9uLGk9dGhpcy5fZGltLmdldEVudmVsb3BlKCkuZ2V0SGVpZ2h0KCkvbixyPW5ldyBBcnJheSg0Km4rMSkuZmlsbChudWxsKSxvPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpO2Zvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1pblgoKSt0KnMsaT1vLmdldE1pblkoKTtyW2UrK109dGhpcy5jb29yZChuLGkpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1heFgoKSxzPW8uZ2V0TWluWSgpK3QqaTtyW2UrK109dGhpcy5jb29yZChuLHMpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1heFgoKS10KnMsaT1vLmdldE1heFkoKTtyW2UrK109dGhpcy5jb29yZChuLGkpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1pblgoKSxzPW8uZ2V0TWF4WSgpLXQqaTtyW2UrK109dGhpcy5jb29yZChuLHMpfXJbZSsrXT1uZXcgbShyWzBdKTtjb25zdCBsPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcociksYT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGwpO3JldHVybiB0aGlzLnJvdGF0ZShhKX1jcmVhdGVDaXJjbGUoKXtyZXR1cm4gdGhpcy5jcmVhdGVFbGxpcHNlKCl9c2V0SGVpZ2h0KHQpe3RoaXMuX2RpbS5zZXRIZWlnaHQodCl9c2V0U2l6ZSh0KXt0aGlzLl9kaW0uc2V0U2l6ZSh0KX19Y2xhc3MgQ2V7Y29uc3RydWN0b3IoKXtDZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmJhc2U9bnVsbCx0aGlzLmNlbnRyZT1udWxsLHRoaXMud2lkdGg9bnVsbCx0aGlzLmhlaWdodD1udWxsfXNldEJhc2UodCl7dGhpcy5iYXNlPXR9c2V0V2lkdGgodCl7dGhpcy53aWR0aD10fWdldEJhc2UoKXtyZXR1cm4gdGhpcy5iYXNlfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMud2lkdGh9c2V0RW52ZWxvcGUodCl7dGhpcy53aWR0aD10LmdldFdpZHRoKCksdGhpcy5oZWlnaHQ9dC5nZXRIZWlnaHQoKSx0aGlzLmJhc2U9bmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuY2VudHJlPW5ldyBtKHQuY2VudHJlKCkpfXNldENlbnRyZSh0KXt0aGlzLmNlbnRyZT10fWdldE1pblNpemUoKXtyZXR1cm4gTWF0aC5taW4odGhpcy53aWR0aCx0aGlzLmhlaWdodCl9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuYmFzZT9uZXcgTyh0aGlzLmJhc2UueCx0aGlzLmJhc2UueCt0aGlzLndpZHRoLHRoaXMuYmFzZS55LHRoaXMuYmFzZS55K3RoaXMuaGVpZ2h0KTpudWxsIT09dGhpcy5jZW50cmU/bmV3IE8odGhpcy5jZW50cmUueC10aGlzLndpZHRoLzIsdGhpcy5jZW50cmUueCt0aGlzLndpZHRoLzIsdGhpcy5jZW50cmUueS10aGlzLmhlaWdodC8yLHRoaXMuY2VudHJlLnkrdGhpcy5oZWlnaHQvMik6bmV3IE8oMCx0aGlzLndpZHRoLDAsdGhpcy5oZWlnaHQpfWdldENlbnRyZSgpe3JldHVybiBudWxsPT09dGhpcy5jZW50cmUmJih0aGlzLmNlbnRyZT1uZXcgbSh0aGlzLmJhc2UueCt0aGlzLndpZHRoLzIsdGhpcy5iYXNlLnkrdGhpcy5oZWlnaHQvMikpLHRoaXMuY2VudHJlfWdldEhlaWdodCgpe3JldHVybiB0aGlzLmhlaWdodH1zZXRIZWlnaHQodCl7dGhpcy5oZWlnaHQ9dH1zZXRTaXplKHQpe3RoaXMuaGVpZ2h0PXQsdGhpcy53aWR0aD10fX13ZS5EaW1lbnNpb25zPUNlO2NsYXNzIFNlIGV4dGVuZHMgd2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLFNlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX251bUFybXM9OCx0aGlzLl9hcm1MZW5ndGhSYXRpbz0uNSwwPT09YXJndW1lbnRzLmxlbmd0aCl3ZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt3ZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX1zdGF0aWMgY3JlYXRlKHQsZSxuLHMsaSl7Y29uc3Qgcj1uZXcgU2U7ci5zZXRDZW50cmUodCksci5zZXRTaXplKGUpLHIuc2V0TnVtUG9pbnRzKG4pLHIuc2V0QXJtTGVuZ3RoUmF0aW8oaSksci5zZXROdW1Bcm1zKHMpO3JldHVybiByLmNyZWF0ZVNpbmVTdGFyKCl9c2V0TnVtQXJtcyh0KXt0aGlzLl9udW1Bcm1zPXR9c2V0QXJtTGVuZ3RoUmF0aW8odCl7dGhpcy5fYXJtTGVuZ3RoUmF0aW89dH1jcmVhdGVTaW5lU3Rhcigpe2NvbnN0IHQ9dGhpcy5fZGltLmdldEVudmVsb3BlKCksZT10LmdldFdpZHRoKCkvMjtsZXQgbj10aGlzLl9hcm1MZW5ndGhSYXRpbztuPDAmJihuPTApLG4+MSYmKG49MSk7Y29uc3Qgcz1uKmUsaT0oMS1uKSplLHI9dC5nZXRNaW5YKCkrZSxvPXQuZ2V0TWluWSgpK2UsbD1uZXcgQXJyYXkodGhpcy5fblB0cysxKS5maWxsKG51bGwpO2xldCBhPTA7Zm9yKGxldCB0PTA7dDx0aGlzLl9uUHRzO3QrKyl7Y29uc3QgZT10L3RoaXMuX25QdHMqdGhpcy5fbnVtQXJtcyxuPWUtTWF0aC5mbG9vcihlKSxjPTIqTWF0aC5QSSpuLGg9aStzKigoTWF0aC5jb3MoYykrMSkvMiksdT10KigyKk1hdGguUEkvdGhpcy5fblB0cyksZz1oKk1hdGguY29zKHUpK3IsZD1oKk1hdGguc2luKHUpK287bFthKytdPXRoaXMuY29vcmQoZyxkKX1sW2FdPW5ldyBtKGxbMF0pO2NvbnN0IGM9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhsKTtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihjKX19dmFyIExlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFmZmluZVRyYW5zZm9ybWF0aW9uOmllLEFmZmluZVRyYW5zZm9ybWF0aW9uQnVpbGRlcjpvZSxBZmZpbmVUcmFuc2Zvcm1hdGlvbkZhY3Rvcnk6bGUsQ29tcG9uZW50Q29vcmRpbmF0ZUV4dHJhY3RlcjphZSxHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXI6Y2UsR2VvbWV0cnlDb21iaW5lcjpoZSxHZW9tZXRyeUVkaXRvcjp1ZSxHZW9tZXRyeUV4dHJhY3RlcjpkZSxHZW9tZXRyeU1hcHBlcjpfZSxHZW9tZXRyeVRyYW5zZm9ybWVyOm1lLExpbmVTdHJpbmdFeHRyYWN0ZXI6ZmUsTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyOnllLFBvaW50RXh0cmFjdGVyOkVlLFBvbHlnb25FeHRyYWN0ZXI6SWUsU2hvcnRDaXJjdWl0ZWRHZW9tZXRyeVZpc2l0b3I6TmUsU2luZVN0YXJGYWN0b3J5OlNlfSksVGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29vcmRpbmF0ZTptLENvb3JkaW5hdGVYWTp5LENvb3JkaW5hdGVYWU06eCxDb29yZGluYXRlWFlaTTpFLENvb3JkaW5hdGVMaXN0OlIsQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyOlAsRW52ZWxvcGU6TyxMaW5lU2VnbWVudDpLdCxHZW9tZXRyeUZhY3Rvcnk6THQsR2VvbWV0cnk6VSxQb2ludDpldCxMaW5lU3RyaW5nOiQsTGluZWFyUmluZzpndCxQb2x5Z29uOnJ0LEdlb21ldHJ5Q29sbGVjdGlvbjpodCxNdWx0aVBvaW50OnV0LE11bHRpTGluZVN0cmluZzpTdCxNdWx0aVBvbHlnb246eXQsRGltZW5zaW9uOlEsSW50ZXJzZWN0aW9uTWF0cml4Okp0LFByZWNpc2lvbk1vZGVsOnd0LExvY2F0aW9uOlF0LFRyaWFuZ2xlOm5lLHV0aWw6TGV9KTtjbGFzcyBSZXtjb25zdHJ1Y3Rvcigpe1JlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0PVtuZXcgbSxuZXcgbV0sdGhpcy5fZGlzdGFuY2U9ci5OYU4sdGhpcy5faXNOdWxsPSEwfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0fWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0W3RdfXNldE1pbmltdW0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRNaW5pbXVtKHQuX3B0WzBdLHQuX3B0WzFdKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLl9pc051bGwpcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZSh0LGUpLG51bGw7Y29uc3Qgbj10LmRpc3RhbmNlKGUpO248dGhpcy5fZGlzdGFuY2UmJnRoaXMuaW5pdGlhbGl6ZSh0LGUsbil9fWluaXRpYWxpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9pc051bGw9ITA7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZSh0KSx0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKGUpLHRoaXMuX2Rpc3RhbmNlPXQuZGlzdGFuY2UoZSksdGhpcy5faXNOdWxsPSExfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUodCksdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShlKSx0aGlzLl9kaXN0YW5jZT1uLHRoaXMuX2lzTnVsbD0hMX19dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKHRoaXMuX3B0WzBdLHRoaXMuX3B0WzFdKX1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9kaXN0YW5jZX1zZXRNYXhpbXVtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TWF4aW11bSh0Ll9wdFswXSx0Ll9wdFsxXSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNOdWxsKXJldHVybiB0aGlzLmluaXRpYWxpemUodCxlKSxudWxsO2NvbnN0IG49dC5kaXN0YW5jZShlKTtuPnRoaXMuX2Rpc3RhbmNlJiZ0aGlzLmluaXRpYWxpemUodCxlLG4pfX19Y2xhc3MgUGV7c3RhdGljIGNvbXB1dGVEaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBLdCxpPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoLTE7dCsrKXtzLnNldENvb3JkaW5hdGVzKGlbdF0saVt0KzFdKTtjb25zdCByPXMuY2xvc2VzdFBvaW50KGUpO24uc2V0TWluaW11bShyLGUpfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcnQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07UGUuY29tcHV0ZURpc3RhbmNlKHQuZ2V0RXh0ZXJpb3JSaW5nKCksZSxuKTtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKVBlLmNvbXB1dGVEaXN0YW5jZSh0LmdldEludGVyaW9yUmluZ04ocyksZSxuKX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0IGluc3RhbmNlb2YgJClQZS5jb21wdXRlRGlzdGFuY2UodCxlLG4pO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHJ0KVBlLmNvbXB1dGVEaXN0YW5jZSh0LGUsbik7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpe2NvbnN0IHM9dDtmb3IobGV0IHQ9MDt0PHMuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3QgaT1zLmdldEdlb21ldHJ5Tih0KTtQZS5jb21wdXRlRGlzdGFuY2UoaSxlLG4pfX1lbHNlIG4uc2V0TWluaW11bSh0LmdldENvb3JkaW5hdGUoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbMF0uY2xvc2VzdFBvaW50KHQpO2Uuc2V0TWluaW11bShuLHQpfX19Y2xhc3MgT2V7Y29uc3RydWN0b3IoKXtPZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nMD1udWxsLHRoaXMuX2cxPW51bGwsdGhpcy5fcHREaXN0PW5ldyBSZSx0aGlzLl9kZW5zaWZ5RnJhYz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2cwPXQsdGhpcy5fZzE9ZX1zdGF0aWMgZGlzdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBPZShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5kaXN0YW5jZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1syXSxlPW5ldyBPZShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKTtyZXR1cm4gZS5zZXREZW5zaWZ5RnJhY3Rpb24odCksZS5kaXN0YW5jZSgpfX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdERpc3QuZ2V0Q29vcmRpbmF0ZXMoKX1zZXREZW5zaWZ5RnJhY3Rpb24odCl7aWYodD4xfHx0PD0wKXRocm93IG5ldyBzKFwiRnJhY3Rpb24gaXMgbm90IGluIHJhbmdlICgwLjAgLSAxLjBdXCIpO3RoaXMuX2RlbnNpZnlGcmFjPXR9Y29tcHV0ZSh0LGUpe3RoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodCxlLHRoaXMuX3B0RGlzdCksdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZShlLHQsdGhpcy5fcHREaXN0KX1kaXN0YW5jZSgpe3JldHVybiB0aGlzLmNvbXB1dGUodGhpcy5fZzAsdGhpcy5fZzEpLHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpfWNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHQsZSxuKXtjb25zdCBzPW5ldyB2ZShlKTtpZih0LmFwcGx5KHMpLG4uc2V0TWF4aW11bShzLmdldE1heFBvaW50RGlzdGFuY2UoKSksdGhpcy5fZGVuc2lmeUZyYWM+MCl7Y29uc3Qgcz1uZXcgYmUoZSx0aGlzLl9kZW5zaWZ5RnJhYyk7dC5hcHBseShzKSxuLnNldE1heGltdW0ocy5nZXRNYXhQb2ludERpc3RhbmNlKCkpfX1vcmllbnRlZERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodGhpcy5fZzAsdGhpcy5fZzEsdGhpcy5fcHREaXN0KSx0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKX19Y2xhc3MgdmV7Y29uc3RydWN0b3IoKXt2ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9tYXhQdERpc3Q9bmV3IFJlLHRoaXMuX21pblB0RGlzdD1uZXcgUmUsdGhpcy5fZXVjbGlkZWFuRGlzdD1uZXcgUGUsdGhpcy5fZ2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb209dH1maWx0ZXIodCl7dGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKSxQZS5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSx0LHRoaXMuX21pblB0RGlzdCksdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KX1nZXRNYXhQb2ludERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21heFB0RGlzdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSF19fWNsYXNzIGJle2NvbnN0cnVjdG9yKCl7YmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWF4UHREaXN0PW5ldyBSZSx0aGlzLl9taW5QdERpc3Q9bmV3IFJlLHRoaXMuX2dlb209bnVsbCx0aGlzLl9udW1TdWJTZWdzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbT10LHRoaXMuX251bVN1YlNlZ3M9TWF0aC50cnVuYyhNYXRoLnJvdW5kKDEvZSkpfWZpbHRlcih0LGUpe2lmKDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlKGUtMSkscz10LmdldENvb3JkaW5hdGUoZSksaT0ocy54LW4ueCkvdGhpcy5fbnVtU3ViU2VncyxyPShzLnktbi55KS90aGlzLl9udW1TdWJTZWdzO2ZvcihsZXQgdD0wO3Q8dGhpcy5fbnVtU3ViU2Vnczt0Kyspe2NvbnN0IGU9bi54K3QqaSxzPW4ueSt0KnIsbz1uZXcgbShlLHMpO3RoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCksUGUuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sbyx0aGlzLl9taW5QdERpc3QpLHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCl9fWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITF9Z2V0TWF4UG9pbnREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9tYXhQdERpc3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1BdfX1PZS5NYXhQb2ludERpc3RhbmNlRmlsdGVyPXZlLE9lLk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlcj1iZTt2YXIgTWU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZTpPZSxEaXN0YW5jZVRvUG9pbnQ6UGUsUG9pbnRQYWlyRGlzdGFuY2U6UmV9KTtjbGFzcyBEZXt2aXNpdEl0ZW0odCl7fX1jbGFzcyBBZXtsb2NhdGUodCl7fX1jbGFzcyBGZXtjb25zdHJ1Y3Rvcigpe0ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21pbj1yLlBPU0lUSVZFX0lORklOSVRZLHRoaXMuX21heD1yLk5FR0FUSVZFX0lORklOSVRZfWdldE1pbigpe3JldHVybiB0aGlzLl9taW59aW50ZXJzZWN0cyh0LGUpe3JldHVybiEodGhpcy5fbWluPmV8fHRoaXMuX21heDx0KX1nZXRNYXgoKXtyZXR1cm4gdGhpcy5fbWF4fXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyhuZXcgbSh0aGlzLl9taW4sMCksbmV3IG0odGhpcy5fbWF4LDApKX19RmUuTm9kZUNvbXBhcmF0b3I9Y2xhc3N7Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWUsaT0obi5fbWluK24uX21heCkvMixyPShzLl9taW4rcy5fbWF4KS8yO3JldHVybiBpPHI/LTE6aT5yPzE6MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fTtjbGFzcyBHZSBleHRlbmRzIEZle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxHZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pdGVtPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWluPXQsdGhpcy5fbWF4PWUsdGhpcy5faXRlbT1ufXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bi52aXNpdEl0ZW0odGhpcy5faXRlbSl9fWNsYXNzIHFlIGV4dGVuZHMgRmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLHFlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGUxPW51bGwsdGhpcy5fbm9kZTI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2RlMT10LHRoaXMuX25vZGUyPWUsdGhpcy5idWlsZEV4dGVudCh0aGlzLl9ub2RlMSx0aGlzLl9ub2RlMil9YnVpbGRFeHRlbnQodCxlKXt0aGlzLl9taW49TWF0aC5taW4odC5fbWluLGUuX21pbiksdGhpcy5fbWF4PU1hdGgubWF4KHQuX21heCxlLl9tYXgpfXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bnVsbCE9PXRoaXMuX25vZGUxJiZ0aGlzLl9ub2RlMS5xdWVyeSh0LGUsbiksbnVsbCE9PXRoaXMuX25vZGUyJiZ0aGlzLl9ub2RlMi5xdWVyeSh0LGUsbil9fWNsYXNzIEJle2NvbnN0cnVjdG9yKCl7QmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGVhdmVzPW5ldyBMLHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9sZXZlbD0wfWJ1aWxkVHJlZSgpe3hlLnNvcnQodGhpcy5fbGVhdmVzLG5ldyBGZS5Ob2RlQ29tcGFyYXRvcik7bGV0IHQ9dGhpcy5fbGVhdmVzLGU9bnVsbCxuPW5ldyBMO2Zvcig7Oyl7aWYodGhpcy5idWlsZExldmVsKHQsbiksMT09PW4uc2l6ZSgpKXJldHVybiBuLmdldCgwKTtlPXQsdD1uLG49ZX19aW5zZXJ0KHQsZSxuKXtpZihudWxsIT09dGhpcy5fcm9vdCl0aHJvdyBuZXcgRChcIkluZGV4IGNhbm5vdCBiZSBhZGRlZCB0byBvbmNlIGl0IGhhcyBiZWVuIHF1ZXJpZWRcIik7dGhpcy5fbGVhdmVzLmFkZChuZXcgR2UodCxlLG4pKX1xdWVyeSh0LGUsbil7aWYodGhpcy5pbml0KCksbnVsbD09PXRoaXMuX3Jvb3QpcmV0dXJuIG51bGw7dGhpcy5fcm9vdC5xdWVyeSh0LGUsbil9YnVpbGRSb290KCl7aWYobnVsbCE9PXRoaXMuX3Jvb3QpcmV0dXJuIG51bGw7dGhpcy5fcm9vdD10aGlzLmJ1aWxkVHJlZSgpfXByaW50Tm9kZSh0KXtZLm91dC5wcmludGxuKFd0LnRvTGluZVN0cmluZyhuZXcgbSh0Ll9taW4sdGhpcy5fbGV2ZWwpLG5ldyBtKHQuX21heCx0aGlzLl9sZXZlbCkpKX1pbml0KCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb290fHwwPT09dGhpcy5fbGVhdmVzLnNpemUoKT9udWxsOnZvaWQgdGhpcy5idWlsZFJvb3QoKX1idWlsZExldmVsKHQsZSl7dGhpcy5fbGV2ZWwrKyxlLmNsZWFyKCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKz0yKXtjb25zdCBzPXQuZ2V0KG4pO2lmKG51bGw9PT0obisxPHQuc2l6ZSgpP3QuZ2V0KG4pOm51bGwpKWUuYWRkKHMpO2Vsc2V7Y29uc3Qgcz1uZXcgcWUodC5nZXQobiksdC5nZXQobisxKSk7ZS5hZGQocyl9fX19Y2xhc3MgWWV7Y29uc3RydWN0b3IoKXtZZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pdGVtcz1uZXcgTH12aXNpdEl0ZW0odCl7dGhpcy5faXRlbXMuYWRkKHQpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltEZV19fWNsYXNzIFZle2NvbnN0cnVjdG9yKCl7VmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcD1udWxsLHRoaXMuX2Nyb3NzaW5nQ291bnQ9MCx0aGlzLl9pc1BvaW50T25TZWdtZW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3A9dH1zdGF0aWMgbG9jYXRlUG9pbnRJblJpbmcoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJkkoYXJndW1lbnRzWzFdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPW5ldyBWZShhcmd1bWVudHNbMF0pLG49bmV3IG0scz1uZXcgbTtmb3IobGV0IGk9MTtpPHQuc2l6ZSgpO2krKylpZih0LmdldENvb3JkaW5hdGUoaSxuKSx0LmdldENvb3JkaW5hdGUoaS0xLHMpLGUuY291bnRTZWdtZW50KG4scyksZS5pc09uU2VnbWVudCgpKXJldHVybiBlLmdldExvY2F0aW9uKCk7cmV0dXJuIGUuZ2V0TG9jYXRpb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9bmV3IFZlKGFyZ3VtZW50c1swXSk7Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHM9dFtuXSxpPXRbbi0xXTtpZihlLmNvdW50U2VnbWVudChzLGkpLGUuaXNPblNlZ21lbnQoKSlyZXR1cm4gZS5nZXRMb2NhdGlvbigpfXJldHVybiBlLmdldExvY2F0aW9uKCl9fWNvdW50U2VnbWVudCh0LGUpe2lmKHQueDx0aGlzLl9wLngmJmUueDx0aGlzLl9wLngpcmV0dXJuIG51bGw7aWYodGhpcy5fcC54PT09ZS54JiZ0aGlzLl9wLnk9PT1lLnkpcmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITAsbnVsbDtpZih0Lnk9PT10aGlzLl9wLnkmJmUueT09PXRoaXMuX3AueSl7bGV0IG49dC54LHM9ZS54O3JldHVybiBuPnMmJihuPWUueCxzPXQueCksdGhpcy5fcC54Pj1uJiZ0aGlzLl9wLng8PXMmJih0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwKSxudWxsfWlmKHQueT50aGlzLl9wLnkmJmUueTw9dGhpcy5fcC55fHxlLnk+dGhpcy5fcC55JiZ0Lnk8PXRoaXMuX3AueSl7bGV0IG49cS5pbmRleCh0LGUsdGhpcy5fcCk7aWYobj09PXEuQ09MTElORUFSKXJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwLG51bGw7ZS55PHQueSYmKG49LW4pLG49PT1xLkxFRlQmJnRoaXMuX2Nyb3NzaW5nQ291bnQrK319aXNQb2ludEluUG9seWdvbigpe3JldHVybiB0aGlzLmdldExvY2F0aW9uKCkhPT1RdC5FWFRFUklPUn1nZXRMb2NhdGlvbigpe3JldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50P1F0LkJPVU5EQVJZOnRoaXMuX2Nyb3NzaW5nQ291bnQlMj09MT9RdC5JTlRFUklPUjpRdC5FWFRFUklPUn1pc09uU2VnbWVudCgpe3JldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50fX1jbGFzcyB6ZXtjb25zdHJ1Y3Rvcigpe3plLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb209bnVsbCx0aGlzLl9pbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCEoSSh0LGl0KXx8dCBpbnN0YW5jZW9mIGd0KSl0aHJvdyBuZXcgcyhcIkFyZ3VtZW50IG11c3QgYmUgUG9seWdvbmFsIG9yIExpbmVhclJpbmdcIik7dGhpcy5fZ2VvbT10fWxvY2F0ZSh0KXtudWxsPT09dGhpcy5faW5kZXgmJih0aGlzLl9pbmRleD1uZXcga2UodGhpcy5fZ2VvbSksdGhpcy5fZ2VvbT1udWxsKTtjb25zdCBlPW5ldyBWZSh0KSxuPW5ldyBYZShlKTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkodC55LHQueSxuKSxlLmdldExvY2F0aW9uKCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX19Y2xhc3MgWGV7Y29uc3RydWN0b3IoKXtYZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb3VudGVyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY291bnRlcj10fXZpc2l0SXRlbSh0KXtjb25zdCBlPXQ7dGhpcy5fY291bnRlci5jb3VudFNlZ21lbnQoZS5nZXRDb29yZGluYXRlKDApLGUuZ2V0Q29vcmRpbmF0ZSgxKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RlXX19Y2xhc3Mga2V7Y29uc3RydWN0b3IoKXtrZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0VtcHR5PSExLHRoaXMuX2luZGV4PW5ldyBCZTtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmlzRW1wdHkoKT90aGlzLl9pc0VtcHR5PSEwOnRoaXMuaW5pdCh0KX1pbml0KHQpe2ZvcihsZXQgZT15ZS5nZXRMaW5lcyh0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKS5nZXRDb29yZGluYXRlcygpO3RoaXMuYWRkTGluZSh0KX19YWRkTGluZSh0KXtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj1uZXcgS3QodFtlLTFdLHRbZV0pLHM9TWF0aC5taW4obi5wMC55LG4ucDEueSksaT1NYXRoLm1heChuLnAwLnksbi5wMS55KTt0aGlzLl9pbmRleC5pbnNlcnQocyxpLG4pfX1xdWVyeSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLl9pc0VtcHR5KXJldHVybiBuZXcgTDtjb25zdCBuPW5ldyBZZTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkodCxlLG4pLG4uZ2V0SXRlbXMoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodGhpcy5faXNFbXB0eSlyZXR1cm4gbnVsbDt0aGlzLl9pbmRleC5xdWVyeSh0LGUsbil9fX16ZS5TZWdtZW50VmlzaXRvcj1YZSx6ZS5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeT1rZTtjbGFzcyBVZXtzdGF0aWMgaXNPbkxpbmUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJkkoYXJndW1lbnRzWzFdLEcpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBqdCxzPW5ldyBtLGk9bmV3IG0scj1lLnNpemUoKTtmb3IobGV0IG89MTtvPHI7bysrKWlmKGUuZ2V0Q29vcmRpbmF0ZShvLTEscyksZS5nZXRDb29yZGluYXRlKG8saSksbi5jb21wdXRlSW50ZXJzZWN0aW9uKHQscyxpKSxuLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiEwO3JldHVybiExfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcganQ7Zm9yKGxldCBzPTE7czxlLmxlbmd0aDtzKyspe2NvbnN0IGk9ZVtzLTFdLHI9ZVtzXTtpZihuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxpLHIpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITB9cmV0dXJuITF9fXN0YXRpYyBsb2NhdGVJblJpbmcodCxlKXtyZXR1cm4gVmUubG9jYXRlUG9pbnRJblJpbmcodCxlKX1zdGF0aWMgaXNJblJpbmcodCxlKXtyZXR1cm4gVWUubG9jYXRlSW5SaW5nKHQsZSkhPT1RdC5FWFRFUklPUn19Y2xhc3MgSGV7aGFzTmV4dCgpe31uZXh0KCl7fXJlbW92ZSgpe319Y2xhc3MgV2V7Y29uc3RydWN0b3IoKXtXZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl9hdFN0YXJ0PW51bGwsdGhpcy5fbWF4PW51bGwsdGhpcy5faW5kZXg9bnVsbCx0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnQ9dCx0aGlzLl9hdFN0YXJ0PSEwLHRoaXMuX2luZGV4PTAsdGhpcy5fbWF4PXQuZ2V0TnVtR2VvbWV0cmllcygpfXN0YXRpYyBpc0F0b21pYyh0KXtyZXR1cm4hKHQgaW5zdGFuY2VvZiBodCl9bmV4dCgpe2lmKHRoaXMuX2F0U3RhcnQpcmV0dXJuIHRoaXMuX2F0U3RhcnQ9ITEsV2UuaXNBdG9taWModGhpcy5fcGFyZW50KSYmdGhpcy5faW5kZXgrKyx0aGlzLl9wYXJlbnQ7aWYobnVsbCE9PXRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSlyZXR1cm4gdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKTt0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1pZih0aGlzLl9pbmRleD49dGhpcy5fbWF4KXRocm93IG5ldyBTO2NvbnN0IHQ9dGhpcy5fcGFyZW50LmdldEdlb21ldHJ5Tih0aGlzLl9pbmRleCsrKTtyZXR1cm4gdCBpbnN0YW5jZW9mIGh0Pyh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bmV3IFdlKHQpLHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCkpOnR9cmVtb3ZlKCl7dGhyb3cgbmV3IEsodGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSl9aGFzTmV4dCgpe2lmKHRoaXMuX2F0U3RhcnQpcmV0dXJuITA7aWYobnVsbCE9PXRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSlyZXR1cm4hMDt0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1yZXR1cm4hKHRoaXMuX2luZGV4Pj10aGlzLl9tYXgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIZV19fWNsYXNzIFple2NvbnN0cnVjdG9yKCl7WmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb209dH1zdGF0aWMgbG9jYXRlUG9pbnRJblBvbHlnb24odCxlKXtpZihlLmlzRW1wdHkoKSlyZXR1cm4gUXQuRVhURVJJT1I7Y29uc3Qgbj1lLmdldEV4dGVyaW9yUmluZygpLHM9WmUubG9jYXRlUG9pbnRJblJpbmcodCxuKTtpZihzIT09UXQuSU5URVJJT1IpcmV0dXJuIHM7Zm9yKGxldCBuPTA7bjxlLmdldE51bUludGVyaW9yUmluZygpO24rKyl7Y29uc3Qgcz1lLmdldEludGVyaW9yUmluZ04obiksaT1aZS5sb2NhdGVQb2ludEluUmluZyh0LHMpO2lmKGk9PT1RdC5CT1VOREFSWSlyZXR1cm4gUXQuQk9VTkRBUlk7aWYoaT09PVF0LklOVEVSSU9SKXJldHVybiBRdC5FWFRFUklPUn1yZXR1cm4gUXQuSU5URVJJT1J9c3RhdGljIGxvY2F0ZVBvaW50SW5SaW5nKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/VWUubG9jYXRlSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpRdC5FWFRFUklPUn1zdGF0aWMgY29udGFpbnNQb2ludEluUG9seWdvbih0LGUpe3JldHVybiBRdC5FWFRFUklPUiE9PVplLmxvY2F0ZVBvaW50SW5Qb2x5Z29uKHQsZSl9c3RhdGljIGxvY2F0ZUluR2VvbWV0cnkodCxlKXtpZihlIGluc3RhbmNlb2YgcnQpcmV0dXJuIFplLmxvY2F0ZVBvaW50SW5Qb2x5Z29uKHQsZSk7aWYoZSBpbnN0YW5jZW9mIGh0KXtjb25zdCBuPW5ldyBXZShlKTtmb3IoO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzIT09ZSl7Y29uc3QgZT1aZS5sb2NhdGVJbkdlb21ldHJ5KHQscyk7aWYoZSE9PVF0LkVYVEVSSU9SKXJldHVybiBlfX19cmV0dXJuIFF0LkVYVEVSSU9SfXN0YXRpYyBpc0NvbnRhaW5lZCh0LGUpe3JldHVybiBRdC5FWFRFUklPUiE9PVplLmxvY2F0ZSh0LGUpfXN0YXRpYyBsb2NhdGUodCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/UXQuRVhURVJJT1I6ZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9aZS5sb2NhdGVJbkdlb21ldHJ5KHQsZSk6UXQuRVhURVJJT1J9bG9jYXRlKHQpe3JldHVybiBaZS5sb2NhdGUodCx0aGlzLl9nZW9tKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfX12YXIgamU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvcjp6ZSxQb2ludE9uR2VvbWV0cnlMb2NhdG9yOkFlLFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvcjpaZX0pO2NsYXNzIEtle21lYXN1cmUodCxlKXt9fWNsYXNzIFFle3N0YXRpYyBkaWFnb25hbFNpemUodCl7aWYodC5pc051bGwoKSlyZXR1cm4gMDtjb25zdCBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuKX1tZWFzdXJlKHQsZSl7Y29uc3Qgbj1PZS5kaXN0YW5jZSh0LGUsUWUuREVOU0lGWV9GUkFDVElPTikscz1uZXcgTyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cy5leHBhbmRUb0luY2x1ZGUoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiAxLW4vUWUuZGlhZ29uYWxTaXplKHMpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltLZV19fVFlLkRFTlNJRllfRlJBQ1RJT049LjI1O3ZhciBKZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBcmVhU2ltaWxhcml0eU1lYXN1cmU6Y2xhc3N7bWVhc3VyZSh0LGUpe3JldHVybiB0LmludGVyc2VjdGlvbihlKS5nZXRBcmVhKCkvdC51bmlvbihlKS5nZXRBcmVhKCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0tlXX19LEhhdXNkb3JmZlNpbWlsYXJpdHlNZWFzdXJlOlFlLFNpbWlsYXJpdHlNZWFzdXJlOktlLFNpbWlsYXJpdHlNZWFzdXJlQ29tYmluZXI6Y2xhc3N7c3RhdGljIGNvbWJpbmUodCxlKXtyZXR1cm4gTWF0aC5taW4odCxlKX19fSk7Y2xhc3MgJGV7Y29uc3RydWN0b3IoKXskZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9hcmVhQmFzZVB0PW51bGwsdGhpcy5fdHJpYW5nbGVDZW50Mz1uZXcgbSx0aGlzLl9hcmVhc3VtMj0wLHRoaXMuX2NnMz1uZXcgbSx0aGlzLl9saW5lQ2VudFN1bT1uZXcgbSx0aGlzLl90b3RhbExlbmd0aD0wLHRoaXMuX3B0Q291bnQ9MCx0aGlzLl9wdENlbnRTdW09bmV3IG07Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJlYUJhc2VQdD1udWxsLHRoaXMuYWRkKHQpfXN0YXRpYyBhcmVhMih0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0obi54LXQueCkqKGUueS10LnkpfXN0YXRpYyBjZW50cm9pZDModCxlLG4scyl7cmV0dXJuIHMueD10LngrZS54K24ueCxzLnk9dC55K2UueStuLnksbnVsbH1zdGF0aWMgZ2V0Q2VudHJvaWQodCl7cmV0dXJuIG5ldyAkZSh0KS5nZXRDZW50cm9pZCgpfXNldEFyZWFCYXNlUG9pbnQodCl7dGhpcy5fYXJlYUJhc2VQdD10fWFkZFBvaW50KHQpe3RoaXMuX3B0Q291bnQrPTEsdGhpcy5fcHRDZW50U3VtLngrPXQueCx0aGlzLl9wdENlbnRTdW0ueSs9dC55fWFkZExpbmVTZWdtZW50cyh0KXtsZXQgZT0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspe2NvbnN0IHM9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2lmKDA9PT1zKWNvbnRpbnVlO2UrPXM7Y29uc3QgaT0odFtuXS54K3RbbisxXS54KS8yO3RoaXMuX2xpbmVDZW50U3VtLngrPXMqaTtjb25zdCByPSh0W25dLnkrdFtuKzFdLnkpLzI7dGhpcy5fbGluZUNlbnRTdW0ueSs9cypyfXRoaXMuX3RvdGFsTGVuZ3RoKz1lLDA9PT1lJiZ0Lmxlbmd0aD4wJiZ0aGlzLmFkZFBvaW50KHRbMF0pfWFkZEhvbGUodCl7Y29uc3QgZT1xLmlzQ0NXKHQpO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLl9hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfWdldENlbnRyb2lkKCl7Y29uc3QgdD1uZXcgbTtpZihNYXRoLmFicyh0aGlzLl9hcmVhc3VtMik+MCl0Lng9dGhpcy5fY2czLngvMy90aGlzLl9hcmVhc3VtMix0Lnk9dGhpcy5fY2czLnkvMy90aGlzLl9hcmVhc3VtMjtlbHNlIGlmKHRoaXMuX3RvdGFsTGVuZ3RoPjApdC54PXRoaXMuX2xpbmVDZW50U3VtLngvdGhpcy5fdG90YWxMZW5ndGgsdC55PXRoaXMuX2xpbmVDZW50U3VtLnkvdGhpcy5fdG90YWxMZW5ndGg7ZWxzZXtpZighKHRoaXMuX3B0Q291bnQ+MCkpcmV0dXJuIG51bGw7dC54PXRoaXMuX3B0Q2VudFN1bS54L3RoaXMuX3B0Q291bnQsdC55PXRoaXMuX3B0Q2VudFN1bS55L3RoaXMuX3B0Q291bnR9cmV0dXJuIHR9YWRkU2hlbGwodCl7dC5sZW5ndGg+MCYmdGhpcy5zZXRBcmVhQmFzZVBvaW50KHRbMF0pO2NvbnN0IGU9IXEuaXNDQ1codCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuX2FyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9YWRkVHJpYW5nbGUodCxlLG4scyl7Y29uc3QgaT1zPzE6LTE7JGUuY2VudHJvaWQzKHQsZSxuLHRoaXMuX3RyaWFuZ2xlQ2VudDMpO2NvbnN0IHI9JGUuYXJlYTIodCxlLG4pO3RoaXMuX2NnMy54Kz1pKnIqdGhpcy5fdHJpYW5nbGVDZW50My54LHRoaXMuX2NnMy55Kz1pKnIqdGhpcy5fdHJpYW5nbGVDZW50My55LHRoaXMuX2FyZWFzdW0yKz1pKnJ9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBydCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGRTaGVsbCh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspdGhpcy5hZGRIb2xlKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIGV0KXRoaXMuYWRkUG9pbnQodC5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mICQpdGhpcy5hZGRMaW5lU2VnbWVudHModC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBydCl7Y29uc3QgZT10O3RoaXMuYWRkKGUpfWVsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4odCkpfX19fWNsYXNzIHRuIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0VtcHR5U3RhY2tFeGNlcHRpb246dG59KVswXX19Y2xhc3MgZW4gZXh0ZW5kcyBDe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmFycmF5PVtdfWFkZCh0KXtyZXR1cm4gdGhpcy5hcnJheS5wdXNoKHQpLCEwfWdldCh0KXtpZih0PDB8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyB3O3JldHVybiB0aGlzLmFycmF5W3RdfXB1c2godCl7cmV0dXJuIHRoaXMuYXJyYXkucHVzaCh0KSx0fXBvcCgpe2lmKDA9PT10aGlzLmFycmF5Lmxlbmd0aCl0aHJvdyBuZXcgdG47cmV0dXJuIHRoaXMuYXJyYXkucG9wKCl9cGVlaygpe2lmKDA9PT10aGlzLmFycmF5Lmxlbmd0aCl0aHJvdyBuZXcgdG47cmV0dXJuIHRoaXMuYXJyYXlbdGhpcy5hcnJheS5sZW5ndGgtMV19ZW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuYXJyYXkubGVuZ3RofWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5lbXB0eSgpfXNlYXJjaCh0KXtyZXR1cm4gdGhpcy5hcnJheS5pbmRleE9mKHQpfXNpemUoKXtyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGh9dG9BcnJheSgpe3JldHVybiB0aGlzLmFycmF5LnNsaWNlKCl9fWNsYXNzIG5ue2NvbnN0cnVjdG9yKCl7bm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmRTZXQ9bmV3IEV0LHRoaXMuX2xpc3Q9bmV3IEx9c3RhdGljIGZpbHRlckNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IG5uO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWUuZmlsdGVyKHRbbl0pO3JldHVybiBlLmdldENvb3JkaW5hdGVzKCl9ZmlsdGVyKHQpe3RoaXMuX2Nvb3JkU2V0LmFkZCh0KSYmdGhpcy5fbGlzdC5hZGQodCl9Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9saXN0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5fbGlzdC50b0FycmF5KHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIXX19Y2xhc3Mgc257Y29uc3RydWN0b3IoKXtzbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX2lucHV0UHRzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3NuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsc24uZXh0cmFjdENvb3JkaW5hdGVzKHQpLHQuZ2V0RmFjdG9yeSgpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dFB0cz1ubi5maWx0ZXJDb29yZGluYXRlcyh0KSx0aGlzLl9nZW9tRmFjdG9yeT1lfX1zdGF0aWMgZXh0cmFjdENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IG5uO3JldHVybiB0LmFwcGx5KGUpLGUuZ2V0Q29vcmRpbmF0ZXMoKX1wcmVTb3J0KHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspKHRbbl0ueTx0WzBdLnl8fHRbbl0ueT09PXRbMF0ueSYmdFtuXS54PHRbMF0ueCkmJihlPXRbMF0sdFswXT10W25dLHRbbl09ZSk7cmV0dXJuIHN0LnNvcnQodCwxLHQubGVuZ3RoLG5ldyBybih0WzBdKSksdH1jb21wdXRlT2N0UmluZyh0KXtjb25zdCBlPXRoaXMuY29tcHV0ZU9jdFB0cyh0KSxuPW5ldyBSO3JldHVybiBuLmFkZChlLCExKSxuLnNpemUoKTwzP251bGw6KG4uY2xvc2VSaW5nKCksbi50b0Nvb3JkaW5hdGVBcnJheSgpKX1saW5lT3JQb2x5Z29uKHQpe2lmKDM9PT0odD10aGlzLmNsZWFuUmluZyh0KSkubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFt0WzBdLHRbMV1dKTtjb25zdCBlPXRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZVBvbHlnb24oZSl9Y2xlYW5SaW5nKHQpe2cuZXF1YWxzKHRbMF0sdFt0Lmxlbmd0aC0xXSk7Y29uc3QgZT1uZXcgTDtsZXQgbj1udWxsO2ZvcihsZXQgcz0wO3M8PXQubGVuZ3RoLTI7cysrKXtjb25zdCBpPXRbc10scj10W3MrMV07aS5lcXVhbHMocil8fChudWxsIT09biYmdGhpcy5pc0JldHdlZW4obixpLHIpfHwoZS5hZGQoaSksbj1pKSl9ZS5hZGQodFt0Lmxlbmd0aC0xXSk7Y29uc3Qgcz1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIGUudG9BcnJheShzKX1pc0JldHdlZW4odCxlLG4pe2lmKDAhPT1xLmluZGV4KHQsZSxuKSlyZXR1cm4hMTtpZih0LnghPT1uLngpe2lmKHQueDw9ZS54JiZlLng8PW4ueClyZXR1cm4hMDtpZihuLng8PWUueCYmZS54PD10LngpcmV0dXJuITB9aWYodC55IT09bi55KXtpZih0Lnk8PWUueSYmZS55PD1uLnkpcmV0dXJuITA7aWYobi55PD1lLnkmJmUueTw9dC55KXJldHVybiEwfXJldHVybiExfXJlZHVjZSh0KXtjb25zdCBlPXRoaXMuY29tcHV0ZU9jdFJpbmcodCk7aWYobnVsbD09PWUpcmV0dXJuIHQ7Y29uc3Qgbj1uZXcgYXQ7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspbi5hZGQoZVt0XSk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspVWUuaXNJblJpbmcodFtzXSxlKXx8bi5hZGQodFtzXSk7Y29uc3Qgcz1fdC50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gcy5sZW5ndGg8Mz90aGlzLnBhZEFycmF5MyhzKTpzfWdldENvbnZleEh1bGwoKXtpZigwPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtpZigxPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLl9pbnB1dFB0c1swXSk7aWYoMj09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLl9pbnB1dFB0cyk7bGV0IHQ9dGhpcy5faW5wdXRQdHM7dGhpcy5faW5wdXRQdHMubGVuZ3RoPjUwJiYodD10aGlzLnJlZHVjZSh0aGlzLl9pbnB1dFB0cykpO2NvbnN0IGU9dGhpcy5wcmVTb3J0KHQpLG49dGhpcy5ncmFoYW1TY2FuKGUpLHM9dGhpcy50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gdGhpcy5saW5lT3JQb2x5Z29uKHMpfXBhZEFycmF5Myh0KXtjb25zdCBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKW48dC5sZW5ndGg/ZVtuXT10W25dOmVbbl09dFswXTtyZXR1cm4gZX1jb21wdXRlT2N0UHRzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10WzBdO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueDxlWzBdLngmJihlWzBdPXRbbl0pLHRbbl0ueC10W25dLnk8ZVsxXS54LWVbMV0ueSYmKGVbMV09dFtuXSksdFtuXS55PmVbMl0ueSYmKGVbMl09dFtuXSksdFtuXS54K3Rbbl0ueT5lWzNdLngrZVszXS55JiYoZVszXT10W25dKSx0W25dLng+ZVs0XS54JiYoZVs0XT10W25dKSx0W25dLngtdFtuXS55PmVbNV0ueC1lWzVdLnkmJihlWzVdPXRbbl0pLHRbbl0ueTxlWzZdLnkmJihlWzZdPXRbbl0pLHRbbl0ueCt0W25dLnk8ZVs3XS54K2VbN10ueSYmKGVbN109dFtuXSk7cmV0dXJuIGV9dG9Db29yZGluYXRlQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspe2NvbnN0IHM9dC5nZXQobik7ZVtuXT1zfXJldHVybiBlfWdyYWhhbVNjYW4odCl7bGV0IGU9bnVsbDtjb25zdCBuPW5ldyBlbjtuLnB1c2godFswXSksbi5wdXNoKHRbMV0pLG4ucHVzaCh0WzJdKTtmb3IobGV0IHM9MztzPHQubGVuZ3RoO3MrKyl7Zm9yKGU9bi5wb3AoKTshbi5lbXB0eSgpJiZxLmluZGV4KG4ucGVlaygpLGUsdFtzXSk+MDspZT1uLnBvcCgpO24ucHVzaChlKSxuLnB1c2godFtzXSl9cmV0dXJuIG4ucHVzaCh0WzBdKSxufX1jbGFzcyBybntjb25zdHJ1Y3Rvcigpe3JuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX29yaWdpbj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX29yaWdpbj10fXN0YXRpYyBwb2xhckNvbXBhcmUodCxlLG4pe2NvbnN0IHM9ZS54LXQueCxpPWUueS10Lnkscj1uLngtdC54LG89bi55LXQueSxsPXEuaW5kZXgodCxlLG4pO2lmKGw9PT1xLkNPVU5URVJDTE9DS1dJU0UpcmV0dXJuIDE7aWYobD09PXEuQ0xPQ0tXSVNFKXJldHVybi0xO2NvbnN0IGE9cypzK2kqaSxjPXIqcitvKm87cmV0dXJuIGE8Yz8tMTphPmM/MTowfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO3JldHVybiBybi5wb2xhckNvbXBhcmUodGhpcy5fb3JpZ2luLG4scyl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1zbi5SYWRpYWxDb21wYXJhdG9yPXJuO2NsYXNzIG9ue2NvbnN0cnVjdG9yKCl7b24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW50ZXJpb3JQb2ludD1udWxsLHRoaXMuX21heFdpZHRoPS0xO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucHJvY2Vzcyh0KX1zdGF0aWMgZ2V0SW50ZXJpb3JQb2ludCh0KXtyZXR1cm4gbmV3IG9uKHQpLmdldEludGVyaW9yUG9pbnQoKX1zdGF0aWMgYXZnKHQsZSl7cmV0dXJuKHQrZSkvMn1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9cHJvY2Vzcyh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgcnQpdGhpcy5wcm9jZXNzUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBodCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMucHJvY2VzcyhlLmdldEdlb21ldHJ5Tih0KSl9fXByb2Nlc3NQb2x5Z29uKHQpe2NvbnN0IGU9bmV3IGxuKHQpO2UucHJvY2VzcygpO2NvbnN0IG49ZS5nZXRXaWR0aCgpO24+dGhpcy5fbWF4V2lkdGgmJih0aGlzLl9tYXhXaWR0aD1uLHRoaXMuX2ludGVyaW9yUG9pbnQ9ZS5nZXRJbnRlcmlvclBvaW50KCkpfX1jbGFzcyBsbntjb25zdHJ1Y3Rvcigpe2xuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BvbHlnb249bnVsbCx0aGlzLl9pbnRlcmlvclBvaW50WT1udWxsLHRoaXMuX2ludGVyaW9yU2VjdGlvbldpZHRoPTAsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BvbHlnb249dCx0aGlzLl9pbnRlcmlvclBvaW50WT1jbi5nZXRTY2FuTGluZVkodCl9c3RhdGljIGlzRWRnZUNyb3NzaW5nQ291bnRlZCh0LGUsbil7Y29uc3Qgcz10LmdldFkoKSxpPWUuZ2V0WSgpO3JldHVybiBzIT09aSYmKCEocz09PW4mJmk8bikmJiEoaT09PW4mJnM8bikpfXN0YXRpYyBpbnRlcnNlY3RzSG9yaXpvbnRhbExpbmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIShlPHQuZ2V0TWluWSgpKSYmIShlPnQuZ2V0TWF4WSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuISh0LmdldFkoKT5uJiZlLmdldFkoKT5uKSYmISh0LmdldFkoKTxuJiZlLmdldFkoKTxuKX19c3RhdGljIGludGVyc2VjdGlvbih0LGUsbil7Y29uc3Qgcz10LmdldFgoKSxpPWUuZ2V0WCgpO2lmKHM9PT1pKXJldHVybiBzO2NvbnN0IHI9aS1zLG89KGUuZ2V0WSgpLXQuZ2V0WSgpKS9yO3JldHVybiBzKyhuLXQuZ2V0WSgpKS9vfWZpbmRCZXN0TWlkcG9pbnQodCl7aWYoMD09PXQuc2l6ZSgpKXJldHVybiBudWxsO2cuaXNUcnVlKDA9PXQuc2l6ZSgpJTIsXCJJbnRlcmlvciBQb2ludCByb2J1c3RuZXNzIGZhaWx1cmU6IG9kZCBudW1iZXIgb2Ygc2NhbmxpbmUgY3Jvc3NpbmdzXCIpLHQuc29ydChuZXcgYW4pO2ZvcihsZXQgZT0wO2U8dC5zaXplKCk7ZSs9Mil7Y29uc3Qgbj10LmdldChlKSxzPXQuZ2V0KGUrMSksaT1zLW47aWYoaT50aGlzLl9pbnRlcmlvclNlY3Rpb25XaWR0aCl7dGhpcy5faW50ZXJpb3JTZWN0aW9uV2lkdGg9aTtjb25zdCB0PW9uLmF2ZyhuLHMpO3RoaXMuX2ludGVyaW9yUG9pbnQ9bmV3IG0odCx0aGlzLl9pbnRlcmlvclBvaW50WSl9fX1wcm9jZXNzKCl7aWYodGhpcy5fcG9seWdvbi5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5faW50ZXJpb3JQb2ludD1uZXcgbSh0aGlzLl9wb2x5Z29uLmdldENvb3JkaW5hdGUoKSk7Y29uc3QgdD1uZXcgTDt0aGlzLnNjYW5SaW5nKHRoaXMuX3BvbHlnb24uZ2V0RXh0ZXJpb3JSaW5nKCksdCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2x5Z29uLmdldE51bUludGVyaW9yUmluZygpO2UrKyl0aGlzLnNjYW5SaW5nKHRoaXMuX3BvbHlnb24uZ2V0SW50ZXJpb3JSaW5nTihlKSx0KTt0aGlzLmZpbmRCZXN0TWlkcG9pbnQodCl9c2NhblJpbmcodCxlKXtpZighbG4uaW50ZXJzZWN0c0hvcml6b250YWxMaW5lKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMuX2ludGVyaW9yUG9pbnRZKSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTE7dDxuLnNpemUoKTt0Kyspe2NvbnN0IHM9bi5nZXRDb29yZGluYXRlKHQtMSksaT1uLmdldENvb3JkaW5hdGUodCk7dGhpcy5hZGRFZGdlQ3Jvc3NpbmcocyxpLHRoaXMuX2ludGVyaW9yUG9pbnRZLGUpfX1nZXRXaWR0aCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclNlY3Rpb25XaWR0aH1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9YWRkRWRnZUNyb3NzaW5nKHQsZSxuLHMpe2lmKCFsbi5pbnRlcnNlY3RzSG9yaXpvbnRhbExpbmUodCxlLG4pKXJldHVybiBudWxsO2lmKCFsbi5pc0VkZ2VDcm9zc2luZ0NvdW50ZWQodCxlLG4pKXJldHVybiBudWxsO2NvbnN0IGk9bG4uaW50ZXJzZWN0aW9uKHQsZSxuKTtzLmFkZChpKX19Y2xhc3MgYW57Y29tcGFyZSh0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fWxuLkRvdWJsZUNvbXBhcmF0b3I9YW47Y2xhc3MgY257Y29uc3RydWN0b3IoKXtjbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wb2x5PW51bGwsdGhpcy5fY2VudHJlWT1udWxsLHRoaXMuX2hpWT1yLk1BWF9WQUxVRSx0aGlzLl9sb1k9LXIuTUFYX1ZBTFVFO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BvbHk9dCx0aGlzLl9oaVk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWF4WSgpLHRoaXMuX2xvWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNaW5ZKCksdGhpcy5fY2VudHJlWT1vbi5hdmcodGhpcy5fbG9ZLHRoaXMuX2hpWSl9c3RhdGljIGdldFNjYW5MaW5lWSh0KXtyZXR1cm4gbmV3IGNuKHQpLmdldFNjYW5MaW5lWSgpfXVwZGF0ZUludGVydmFsKHQpe3Q8PXRoaXMuX2NlbnRyZVk/dD50aGlzLl9sb1kmJih0aGlzLl9sb1k9dCk6dD50aGlzLl9jZW50cmVZJiZ0PHRoaXMuX2hpWSYmKHRoaXMuX2hpWT10KX1nZXRTY2FuTGluZVkoKXt0aGlzLnByb2Nlc3ModGhpcy5fcG9seS5nZXRFeHRlcmlvclJpbmcoKSk7Zm9yKGxldCB0PTA7dDx0aGlzLl9wb2x5LmdldE51bUludGVyaW9yUmluZygpO3QrKyl0aGlzLnByb2Nlc3ModGhpcy5fcG9seS5nZXRJbnRlcmlvclJpbmdOKHQpKTtyZXR1cm4gb24uYXZnKHRoaXMuX2hpWSx0aGlzLl9sb1kpfXByb2Nlc3ModCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBuPWUuZ2V0WSh0KTt0aGlzLnVwZGF0ZUludGVydmFsKG4pfX19b24uSW50ZXJpb3JQb2ludFBvbHlnb249bG4sb24uU2NhbkxpbmVZT3JkaW5hdGVGaW5kZXI9Y247Y2xhc3MgaG57Y29uc3RydWN0b3IoKXtobi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jZW50cm9pZD1udWxsLHRoaXMuX21pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmlzRW1wdHkoKT90aGlzLl9jZW50cm9pZD1udWxsOih0aGlzLl9jZW50cm9pZD0kZS5nZXRDZW50cm9pZCh0KSx0LmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodGhpcy5fY2VudHJvaWQpKSx0aGlzLmFkZEludGVyaW9yKHQpLG51bGw9PT10aGlzLl9pbnRlcmlvclBvaW50JiZ0aGlzLmFkZEVuZHBvaW50cyh0KX1zdGF0aWMgZ2V0SW50ZXJpb3JQb2ludCh0KXtyZXR1cm4gbmV3IGhuKHQpLmdldEludGVyaW9yUG9pbnQoKX1hZGRFbmRwb2ludHMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiAkKXRoaXMuYWRkRW5kcG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZEVuZHBvaW50cyhlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodFswXSksdGhpcy5hZGQodFt0Lmxlbmd0aC0xXSl9fWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGRJbnRlcmlvcigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mICQpdGhpcy5hZGRJbnRlcmlvcih0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGRJbnRlcmlvcihlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aC0xO2UrKyl0aGlzLmFkZCh0W2VdKX19YWRkKHQpe2NvbnN0IGU9dC5kaXN0YW5jZSh0aGlzLl9jZW50cm9pZCk7ZTx0aGlzLl9taW5EaXN0YW5jZSYmKHRoaXMuX2ludGVyaW9yUG9pbnQ9bmV3IG0odCksdGhpcy5fbWluRGlzdGFuY2U9ZSl9fWNsYXNzIHVue2NvbnN0cnVjdG9yKCl7dW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY2VudHJvaWQ9bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY2VudHJvaWQ9JGUuZ2V0Q2VudHJvaWQodCksdGhpcy5hZGQodCl9c3RhdGljIGdldEludGVyaW9yUG9pbnQodCl7cmV0dXJuIG5ldyB1bih0KS5nZXRJbnRlcmlvclBvaW50KCl9Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIGV0KXRoaXMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBodCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5kaXN0YW5jZSh0aGlzLl9jZW50cm9pZCk7ZTx0aGlzLl9taW5EaXN0YW5jZSYmKHRoaXMuX2ludGVyaW9yUG9pbnQ9bmV3IG0odCksdGhpcy5fbWluRGlzdGFuY2U9ZSl9fX1jbGFzcyBnbntpc0luQm91bmRhcnkodCl7fX1jbGFzcyBkbntpc0luQm91bmRhcnkodCl7cmV0dXJuIHQlMj09MX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ25dfX1jbGFzcyBfbntpc0luQm91bmRhcnkodCl7cmV0dXJuIHQ+MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ25dfX1jbGFzcyBwbntpc0luQm91bmRhcnkodCl7cmV0dXJuIHQ+MX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ25dfX1jbGFzcyBtbntpc0luQm91bmRhcnkodCl7cmV0dXJuIDE9PT10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnbl19fWduLk1vZDJCb3VuZGFyeU5vZGVSdWxlPWRuLGduLkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1fbixnbi5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1wbixnbi5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPW1uLGduLk1PRDJfQk9VTkRBUllfUlVMRT1uZXcgZG4sZ24uRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgX24sZ24uTVVMVElWQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgcG4sZ24uTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBtbixnbi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU9Z24uTU9EMl9CT1VOREFSWV9SVUxFO2NsYXNzIGZue2NvbnN0cnVjdG9yKCl7Zm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fYm91bmRhcnlSdWxlPWduLk9HQ19TRlNfQk9VTkRBUllfUlVMRSx0aGlzLl9pc0luPW51bGwsdGhpcy5fbnVtQm91bmRhcmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dCl0aHJvdyBuZXcgcyhcIlJ1bGUgbXVzdCBiZSBub24tbnVsbFwiKTt0aGlzLl9ib3VuZGFyeVJ1bGU9dH19bG9jYXRlSW5Qb2x5Z29uUmluZyh0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP1VlLmxvY2F0ZUluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6UXQuRVhURVJJT1J9aW50ZXJzZWN0cyh0LGUpe3JldHVybiB0aGlzLmxvY2F0ZSh0LGUpIT09UXQuRVhURVJJT1J9dXBkYXRlTG9jYXRpb25JbmZvKHQpe3Q9PT1RdC5JTlRFUklPUiYmKHRoaXMuX2lzSW49ITApLHQ9PT1RdC5CT1VOREFSWSYmdGhpcy5fbnVtQm91bmRhcmllcysrfWNvbXB1dGVMb2NhdGlvbih0LGUpe2lmKGUgaW5zdGFuY2VvZiBldCYmdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPblBvaW50KHQsZSkpLGUgaW5zdGFuY2VvZiAkKXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIHJ0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW5Qb2x5Z29uKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFN0KXtjb25zdCBuPWU7Zm9yKGxldCBlPTA7ZTxuLmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9bi5nZXRHZW9tZXRyeU4oZSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxzKSl9fWVsc2UgaWYoZSBpbnN0YW5jZW9mIHl0KXtjb25zdCBuPWU7Zm9yKGxldCBlPTA7ZTxuLmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9bi5nZXRHZW9tZXRyeU4oZSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJblBvbHlnb24odCxzKSl9fWVsc2UgaWYoZSBpbnN0YW5jZW9mIGh0KXtjb25zdCBuPW5ldyBXZShlKTtmb3IoO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzIT09ZSYmdGhpcy5jb21wdXRlTG9jYXRpb24odCxzKX19fWxvY2F0ZU9uUG9pbnQodCxlKXtyZXR1cm4gZS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodCk/UXQuSU5URVJJT1I6UXQuRVhURVJJT1J9bG9jYXRlT25MaW5lU3RyaW5nKHQsZSl7aWYoIWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCkpcmV0dXJuIFF0LkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtyZXR1cm4gZS5pc0Nsb3NlZCgpfHwhdC5lcXVhbHMobi5nZXRDb29yZGluYXRlKDApKSYmIXQuZXF1YWxzKG4uZ2V0Q29vcmRpbmF0ZShuLnNpemUoKS0xKSk/VWUuaXNPbkxpbmUodCxuKT9RdC5JTlRFUklPUjpRdC5FWFRFUklPUjpRdC5CT1VOREFSWX1sb2NhdGVJblBvbHlnb24odCxlKXtpZihlLmlzRW1wdHkoKSlyZXR1cm4gUXQuRVhURVJJT1I7Y29uc3Qgbj1lLmdldEV4dGVyaW9yUmluZygpLHM9dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQsbik7aWYocz09PVF0LkVYVEVSSU9SKXJldHVybiBRdC5FWFRFUklPUjtpZihzPT09UXQuQk9VTkRBUlkpcmV0dXJuIFF0LkJPVU5EQVJZO2ZvcihsZXQgbj0wO248ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtuKyspe2NvbnN0IHM9ZS5nZXRJbnRlcmlvclJpbmdOKG4pLGk9dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQscyk7aWYoaT09PVF0LklOVEVSSU9SKXJldHVybiBRdC5FWFRFUklPUjtpZihpPT09UXQuQk9VTkRBUlkpcmV0dXJuIFF0LkJPVU5EQVJZfXJldHVybiBRdC5JTlRFUklPUn1sb2NhdGUodCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/UXQuRVhURVJJT1I6ZSBpbnN0YW5jZW9mICQ/dGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxlKTplIGluc3RhbmNlb2YgcnQ/dGhpcy5sb2NhdGVJblBvbHlnb24odCxlKToodGhpcy5faXNJbj0hMSx0aGlzLl9udW1Cb3VuZGFyaWVzPTAsdGhpcy5jb21wdXRlTG9jYXRpb24odCxlKSx0aGlzLl9ib3VuZGFyeVJ1bGUuaXNJbkJvdW5kYXJ5KHRoaXMuX251bUJvdW5kYXJpZXMpP1F0LkJPVU5EQVJZOnRoaXMuX251bUJvdW5kYXJpZXM+MHx8dGhpcy5faXNJbj9RdC5JTlRFUklPUjpRdC5FWFRFUklPUil9fWNsYXNzIHlue2NvbnN0cnVjdG9yKCl7eW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXQ9bnVsbCx0aGlzLl9leHRyZW1hbFB0cz1udWxsLHRoaXMuX2NlbnRyZT1udWxsLHRoaXMuX3JhZGl1cz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0PXR9c3RhdGljIGZhcnRoZXN0UG9pbnRzKHQpe2NvbnN0IGU9dFswXS5kaXN0YW5jZSh0WzFdKSxuPXRbMV0uZGlzdGFuY2UodFsyXSkscz10WzJdLmRpc3RhbmNlKHRbMF0pO3JldHVybiBlPj1uJiZlPj1zP1t0WzBdLHRbMV1dOm4+PWUmJm4+PXM/W3RbMV0sdFsyXV06W3RbMl0sdFswXV19c3RhdGljIHBvaW50V2l0TWluQW5nbGVXaXRoWCh0LGUpe2xldCBuPXIuTUFYX1ZBTFVFLHM9bnVsbDtmb3IobGV0IGk9MDtpPHQubGVuZ3RoO2krKyl7Y29uc3Qgcj10W2ldO2lmKHI9PT1lKWNvbnRpbnVlO2NvbnN0IG89ci54LWUueDtsZXQgbD1yLnktZS55O2w8MCYmKGw9LWwpO2NvbnN0IGE9bC9NYXRoLnNxcnQobypvK2wqbCk7YTxuJiYobj1hLHM9cil9cmV0dXJuIHN9c3RhdGljIGxvd2VzdFBvaW50KHQpe2xldCBlPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXS55PGUueSYmKGU9dFtuXSk7cmV0dXJuIGV9c3RhdGljIHBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQodCxlLG4pe2xldCBzPXIuTUFYX1ZBTFVFLGk9bnVsbDtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3Qgbz10W3JdO2lmKG89PT1lKWNvbnRpbnVlO2lmKG89PT1uKWNvbnRpbnVlO2NvbnN0IGw9JHQuYW5nbGVCZXR3ZWVuKGUsbyxuKTtsPHMmJihzPWwsaT1vKX1yZXR1cm4gaX1nZXRSYWRpdXMoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fcmFkaXVzfWdldERpYW1ldGVyKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2NlbnRyZSl9Y29uc3QgdD10aGlzLl9leHRyZW1hbFB0c1swXSxlPXRoaXMuX2V4dHJlbWFsUHRzWzFdO3JldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9Z2V0RXh0cmVtYWxQb2ludHMoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHN9Y29tcHV0ZUNpcmNsZVBvaW50cygpe2lmKHRoaXMuX2lucHV0LmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDtpZigxPT09dGhpcy5faW5wdXQuZ2V0TnVtUG9pbnRzKCkpe2NvbnN0IHQ9dGhpcy5faW5wdXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBtKHRbMF0pXSxudWxsfWNvbnN0IHQ9dGhpcy5faW5wdXQuY29udmV4SHVsbCgpLmdldENvb3JkaW5hdGVzKCk7bGV0IGU9dDtpZih0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pJiYoZT1uZXcgQXJyYXkodC5sZW5ndGgtMSkuZmlsbChudWxsKSxfdC5jb3B5RGVlcCh0LDAsZSwwLHQubGVuZ3RoLTEpKSxlLmxlbmd0aDw9MilyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9X3QuY29weURlZXAoZSksbnVsbDtsZXQgbj15bi5sb3dlc3RQb2ludChlKSxzPXluLnBvaW50V2l0TWluQW5nbGVXaXRoWChlLG4pO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCB0PXluLnBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQoZSxuLHMpO2lmKCR0LmlzT2J0dXNlKG4sdCxzKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBtKG4pLG5ldyBtKHMpXSxudWxsO2lmKCR0LmlzT2J0dXNlKHQsbixzKSluPXQ7ZWxzZXtpZighJHQuaXNPYnR1c2UodCxzLG4pKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IG0obiksbmV3IG0ocyksbmV3IG0odCldLG51bGw7cz10fX1nLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiTG9naWMgZmFpbHVyZSBpbiBNaW5pbXVtIEJvdW5kaW5nIENpcmNsZSBhbGdvcml0aG0hXCIpfWNvbXB1dGUoKXtpZihudWxsIT09dGhpcy5fZXh0cmVtYWxQdHMpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ2lyY2xlUG9pbnRzKCksdGhpcy5jb21wdXRlQ2VudHJlKCksbnVsbCE9PXRoaXMuX2NlbnRyZSYmKHRoaXMuX3JhZGl1cz10aGlzLl9jZW50cmUuZGlzdGFuY2UodGhpcy5fZXh0cmVtYWxQdHNbMF0pKX1nZXRDaXJjbGUoKXtpZih0aGlzLmNvbXB1dGUoKSxudWxsPT09dGhpcy5fY2VudHJlKXJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbigpO2NvbnN0IHQ9dGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2NlbnRyZSk7cmV0dXJuIDA9PT10aGlzLl9yYWRpdXM/dDp0LmJ1ZmZlcih0aGlzLl9yYWRpdXMpfWdldENlbnRyZSgpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9jZW50cmV9Z2V0TWF4aW11bURpYW1ldGVyKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2NlbnRyZSk7Y2FzZSAyOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5fZXh0cmVtYWxQdHNbMF0sdGhpcy5fZXh0cmVtYWxQdHNbMV1dKTtkZWZhdWx0OmNvbnN0IHQ9eW4uZmFydGhlc3RQb2ludHModGhpcy5fZXh0cmVtYWxQdHMpO3JldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0KX19Y29tcHV0ZUNlbnRyZSgpe3N3aXRjaCh0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDp0aGlzLl9jZW50cmU9bnVsbDticmVhaztjYXNlIDE6dGhpcy5fY2VudHJlPXRoaXMuX2V4dHJlbWFsUHRzWzBdO2JyZWFrO2Nhc2UgMjp0aGlzLl9jZW50cmU9bmV3IG0oKHRoaXMuX2V4dHJlbWFsUHRzWzBdLngrdGhpcy5fZXh0cmVtYWxQdHNbMV0ueCkvMiwodGhpcy5fZXh0cmVtYWxQdHNbMF0ueSt0aGlzLl9leHRyZW1hbFB0c1sxXS55KS8yKTticmVhaztjYXNlIDM6dGhpcy5fY2VudHJlPW5lLmNpcmN1bWNlbnRyZSh0aGlzLl9leHRyZW1hbFB0c1swXSx0aGlzLl9leHRyZW1hbFB0c1sxXSx0aGlzLl9leHRyZW1hbFB0c1syXSl9fX1jbGFzcyB4bntjb25zdHJ1Y3Rvcigpe3huLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2lzQ29udmV4PW51bGwsdGhpcy5fY29udmV4SHVsbFB0cz1udWxsLHRoaXMuX21pbkJhc2VTZWc9bmV3IEt0LHRoaXMuX21pbldpZHRoUHQ9bnVsbCx0aGlzLl9taW5QdEluZGV4PW51bGwsdGhpcy5fbWluV2lkdGg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07eG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LCExKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9pc0NvbnZleD1lfX1zdGF0aWMgbmV4dEluZGV4KHQsZSl7cmV0dXJuKytlPj10Lmxlbmd0aCYmKGU9MCksZX1zdGF0aWMgY29tcHV0ZUModCxlLG4pe3JldHVybiB0Km4ueS1lKm4ueH1zdGF0aWMgZ2V0TWluaW11bURpYW1ldGVyKHQpe3JldHVybiBuZXcgeG4odCkuZ2V0RGlhbWV0ZXIoKX1zdGF0aWMgZ2V0TWluaW11bVJlY3RhbmdsZSh0KXtyZXR1cm4gbmV3IHhuKHQpLmdldE1pbmltdW1SZWN0YW5nbGUoKX1zdGF0aWMgY29tcHV0ZVNlZ21lbnRGb3JMaW5lKHQsZSxuKXtsZXQgcz1udWxsLGk9bnVsbDtyZXR1cm4gTWF0aC5hYnMoZSk+TWF0aC5hYnModCk/KHM9bmV3IG0oMCxuL2UpLGk9bmV3IG0oMSxuL2UtdC9lKSk6KHM9bmV3IG0obi90LDApLGk9bmV3IG0obi90LWUvdCwxKSksbmV3IEt0KHMsaSl9Z2V0V2lkdGhDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuX21pbldpZHRoUHR9Z2V0U3VwcG9ydGluZ1NlZ21lbnQoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLl9taW5CYXNlU2VnLnAwLHRoaXMuX21pbkJhc2VTZWcucDFdKX1nZXREaWFtZXRlcigpe2lmKHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLG51bGw9PT10aGlzLl9taW5XaWR0aFB0KXJldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjb25zdCB0PXRoaXMuX21pbkJhc2VTZWcucHJvamVjdCh0aGlzLl9taW5XaWR0aFB0KTtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LHRoaXMuX21pbldpZHRoUHRdKX1jb21wdXRlV2lkdGhDb252ZXgodCl7dGhpcy5fY29udmV4SHVsbFB0cz10IGluc3RhbmNlb2YgcnQ/dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpOnQuZ2V0Q29vcmRpbmF0ZXMoKSwwPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD1udWxsLHRoaXMuX21pbkJhc2VTZWc9bnVsbCk6MT09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAwPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMT10aGlzLl9jb252ZXhIdWxsUHRzWzBdKToyPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGh8fDM9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDE9dGhpcy5fY29udmV4SHVsbFB0c1sxXSk6dGhpcy5jb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyKHRoaXMuX2NvbnZleEh1bGxQdHMpfWNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodCl7dGhpcy5fbWluV2lkdGg9ci5NQVhfVkFMVUU7bGV0IGU9MTtjb25zdCBuPW5ldyBLdDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoLTE7cysrKW4ucDA9dFtzXSxuLnAxPXRbcysxXSxlPXRoaXMuZmluZE1heFBlcnBEaXN0YW5jZSh0LG4sZSl9Y29tcHV0ZU1pbmltdW1EaWFtZXRlcigpe2lmKG51bGwhPT10aGlzLl9taW5XaWR0aFB0KXJldHVybiBudWxsO2lmKHRoaXMuX2lzQ29udmV4KXRoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHRoaXMuX2lucHV0R2VvbSk7ZWxzZXtjb25zdCB0PW5ldyBzbih0aGlzLl9pbnB1dEdlb20pLmdldENvbnZleEh1bGwoKTt0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0KX19Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuX21pbldpZHRofWZpbmRNYXhQZXJwRGlzdGFuY2UodCxlLG4pe2xldCBzPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbbl0pLGk9cyxyPW4sbz1yO2Zvcig7aT49czspcz1pLHI9byxvPXhuLm5leHRJbmRleCh0LHIpLGk9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtvXSk7cmV0dXJuIHM8dGhpcy5fbWluV2lkdGgmJih0aGlzLl9taW5QdEluZGV4PXIsdGhpcy5fbWluV2lkdGg9cyx0aGlzLl9taW5XaWR0aFB0PXRbdGhpcy5fbWluUHRJbmRleF0sdGhpcy5fbWluQmFzZVNlZz1uZXcgS3QoZSkpLHJ9Z2V0TWluaW11bVJlY3RhbmdsZSgpe2lmKHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLDA9PT10aGlzLl9taW5XaWR0aClyZXR1cm4gdGhpcy5fbWluQmFzZVNlZy5wMC5lcXVhbHMyRCh0aGlzLl9taW5CYXNlU2VnLnAxKT90aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX21pbkJhc2VTZWcucDApOnRoaXMuX21pbkJhc2VTZWcudG9HZW9tZXRyeSh0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpKTtjb25zdCB0PXRoaXMuX21pbkJhc2VTZWcucDEueC10aGlzLl9taW5CYXNlU2VnLnAwLngsZT10aGlzLl9taW5CYXNlU2VnLnAxLnktdGhpcy5fbWluQmFzZVNlZy5wMC55O2xldCBuPXIuTUFYX1ZBTFVFLHM9LXIuTUFYX1ZBTFVFLGk9ci5NQVhfVkFMVUUsbz0tci5NQVhfVkFMVUU7Zm9yKGxldCByPTA7cjx0aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aDtyKyspe2NvbnN0IGw9eG4uY29tcHV0ZUModCxlLHRoaXMuX2NvbnZleEh1bGxQdHNbcl0pO2w+cyYmKHM9bCksbDxuJiYobj1sKTtjb25zdCBhPXhuLmNvbXB1dGVDKC1lLHQsdGhpcy5fY29udmV4SHVsbFB0c1tyXSk7YT5vJiYobz1hKSxhPGkmJihpPWEpfWNvbnN0IGw9eG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC10LC1lLG8pLGE9eG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC10LC1lLGkpLGM9eG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQscyksaD14bi5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxuKSx1PWMubGluZUludGVyc2VjdGlvbihsKSxnPWgubGluZUludGVyc2VjdGlvbihsKSxkPWgubGluZUludGVyc2VjdGlvbihhKSxfPWMubGluZUludGVyc2VjdGlvbihhKSxwPXRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhbdSxnLGQsXyx1XSk7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbihwKX19dmFyIEVuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRpc3RhbmNlOk1lLGxvY2F0ZTpqZSxtYXRjaDpKZSxBbmdsZTokdCxBcmVhOm50LENlbnRyb2lkOiRlLENvbnZleEh1bGw6c24sRGlzdGFuY2U6eixJbnRlcmlvclBvaW50QXJlYTpvbixJbnRlcmlvclBvaW50TGluZTpobixJbnRlcmlvclBvaW50UG9pbnQ6dW4sTGVuZ3RoOlcsT3JpZW50YXRpb246cSxQb2ludExvY2F0aW9uOlVlLFBvaW50TG9jYXRvcjpmbixSb2J1c3RMaW5lSW50ZXJzZWN0b3I6anQsTWluaW11bUJvdW5kaW5nQ2lyY2xlOnluLE1pbmltdW1EaWFtZXRlcjp4bn0pO2NsYXNzIElue2NvbnN0cnVjdG9yKCl7SW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgZGVuc2lmeVBvaW50cyh0LGUsbil7Y29uc3Qgcz1uZXcgS3QsaT1uZXcgUjtmb3IobGV0IHI9MDtyPHQubGVuZ3RoLTE7cisrKXtzLnAwPXRbcl0scy5wMT10W3IrMV0saS5hZGQocy5wMCwhMSk7Y29uc3Qgbz1zLmdldExlbmd0aCgpLGw9TWF0aC50cnVuYyhvL2UpKzE7aWYobD4xKXtjb25zdCB0PW8vbDtmb3IobGV0IGU9MTtlPGw7ZSsrKXtjb25zdCByPWUqdC9vLGw9cy5wb2ludEFsb25nKHIpO24ubWFrZVByZWNpc2UobCksaS5hZGQobCwhMSl9fX1yZXR1cm4gaS5hZGQodFt0Lmxlbmd0aC0xXSwhMSksaS50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyBkZW5zaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgSW4odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfWdldFJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBObih0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDw9MCl0aHJvdyBuZXcgcyhcIlRvbGVyYW5jZSBtdXN0IGJlIHBvc2l0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9fWNsYXNzIE5uIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLE5uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiB5dD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IHM9SW4uZGVuc2lmeVBvaW50cyhuLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UsZS5nZXRQcmVjaXNpb25Nb2RlbCgpKTtyZXR1cm4gZSBpbnN0YW5jZW9mICQmJjE9PT1zLmxlbmd0aCYmKHM9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHQuYnVmZmVyKDApfX1Jbi5EZW5zaWZ5VHJhbnNmb3JtZXI9Tm47dmFyIHduPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERlbnNpZmllcjpJbn0pO2NsYXNzIENue3N0YXRpYyBpc05vcnRoZXJuKHQpe3JldHVybiB0PT09Q24uTkV8fHQ9PT1Dbi5OV31zdGF0aWMgaXNPcHBvc2l0ZSh0LGUpe2lmKHQ9PT1lKXJldHVybiExO3JldHVybiAyPT09KHQtZSs0KSU0fXN0YXRpYyBjb21tb25IYWxmUGxhbmUodCxlKXtpZih0PT09ZSlyZXR1cm4gdDtpZigyPT09KHQtZSs0KSU0KXJldHVybi0xO2NvbnN0IG49dDxlP3Q6ZTtyZXR1cm4gMD09PW4mJjM9PT0odD5lP3Q6ZSk/MzpufXN0YXRpYyBpc0luSGFsZlBsYW5lKHQsZSl7cmV0dXJuIGU9PT1Dbi5TRT90PT09Q24uU0V8fHQ9PT1Dbi5TVzp0PT09ZXx8dD09PWUrMX1zdGF0aWMgcXVhZHJhbnQoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IHMoXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO3JldHVybiB0Pj0wP2U+PTA/Q24uTkU6Q24uU0U6ZT49MD9Dbi5OVzpDbi5TV31pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoZS54PT09dC54JiZlLnk9PT10LnkpdGhyb3cgbmV3IHMoXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK3QpO3JldHVybiBlLng+PXQueD9lLnk+PXQueT9Dbi5ORTpDbi5TRTplLnk+PXQueT9Dbi5OVzpDbi5TV319fUNuLk5FPTAsQ24uTlc9MSxDbi5TVz0yLENuLlNFPTM7Y2xhc3MgU257Y29uc3RydWN0b3IoKXtTbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vcmlnPW51bGwsdGhpcy5fc3ltPW51bGwsdGhpcy5fbmV4dD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX29yaWc9dH1zdGF0aWMgY3JlYXRlKHQsZSl7Y29uc3Qgbj1uZXcgU24odCkscz1uZXcgU24oZSk7cmV0dXJuIG4ubGluayhzKSxufWZpbmQodCl7bGV0IGU9dGhpcztkb3tpZihudWxsPT09ZSlyZXR1cm4gbnVsbDtpZihlLmRlc3QoKS5lcXVhbHMyRCh0KSlyZXR1cm4gZTtlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIG51bGx9ZGVzdCgpe3JldHVybiB0aGlzLl9zeW0uX29yaWd9aXNFZGdlc1NvcnRlZCgpe2NvbnN0IHQ9dGhpcy5maW5kTG93ZXN0KCk7bGV0IGU9dDtkb3tjb25zdCBuPWUub05leHQoKTtpZihuPT09dClicmVhaztpZighKG4uY29tcGFyZVRvKGUpPjApKXJldHVybiExO2U9bn13aGlsZShlIT09dCk7cmV0dXJuITB9b05leHQoKXtyZXR1cm4gdGhpcy5fc3ltLl9uZXh0fWRpcmVjdGlvblkoKXtyZXR1cm4gdGhpcy5kaXJlY3Rpb25QdCgpLmdldFkoKS10aGlzLl9vcmlnLmdldFkoKX1pbnNlcnQodCl7aWYodGhpcy5vTmV4dCgpPT09dGhpcylyZXR1cm4gdGhpcy5pbnNlcnRBZnRlcih0KSxudWxsO3RoaXMuaW5zZXJ0aW9uRWRnZSh0KS5pbnNlcnRBZnRlcih0KX1pbnNlcnRBZnRlcih0KXtnLmVxdWFscyh0aGlzLl9vcmlnLHQub3JpZygpKTtjb25zdCBlPXRoaXMub05leHQoKTt0aGlzLl9zeW0uc2V0TmV4dCh0KSx0LnN5bSgpLnNldE5leHQoZSl9ZGVncmVlKCl7bGV0IHQ9MCxlPXRoaXM7ZG97dCsrLGU9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gdH1lcXVhbHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9vcmlnLmVxdWFsczJEKHQpJiZ0aGlzLl9zeW0uX29yaWcuZXF1YWxzKGUpfX1maW5kTG93ZXN0KCl7bGV0IHQ9dGhpcyxlPXRoaXMub05leHQoKTtkb3tlLmNvbXBhcmVUbyh0KTwwJiYodD1lKSxlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIHR9ZGlyZWN0aW9uUHQoKXtyZXR1cm4gdGhpcy5kZXN0KCl9c3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1wcmV2KCl7cmV0dXJuIHRoaXMuX3N5bS5uZXh0KCkuX3N5bX1jb21wYXJlQW5ndWxhckRpcmVjdGlvbih0KXtjb25zdCBlPXRoaXMuZGlyZWN0aW9uWCgpLG49dGhpcy5kaXJlY3Rpb25ZKCkscz10LmRpcmVjdGlvblgoKSxpPXQuZGlyZWN0aW9uWSgpO2lmKGU9PT1zJiZuPT09aSlyZXR1cm4gMDtjb25zdCByPUNuLnF1YWRyYW50KGUsbiksbz1Dbi5xdWFkcmFudChzLGkpO2lmKHI+bylyZXR1cm4gMTtpZihyPG8pcmV0dXJuLTE7Y29uc3QgbD10aGlzLmRpcmVjdGlvblB0KCksYT10LmRpcmVjdGlvblB0KCk7cmV0dXJuIHEuaW5kZXgodC5fb3JpZyxhLGwpfXByZXZOb2RlKCl7bGV0IHQ9dGhpcztmb3IoOzI9PT10LmRlZ3JlZSgpOylpZih0PXQucHJldigpLHQ9PT10aGlzKXJldHVybiBudWxsO3JldHVybiB0fWRpcmVjdGlvblgoKXtyZXR1cm4gdGhpcy5kaXJlY3Rpb25QdCgpLmdldFgoKS10aGlzLl9vcmlnLmdldFgoKX1pbnNlcnRpb25FZGdlKHQpe2xldCBlPXRoaXM7ZG97Y29uc3Qgbj1lLm9OZXh0KCk7aWYobi5jb21wYXJlVG8oZSk+MCYmdC5jb21wYXJlVG8oZSk+PTAmJnQuY29tcGFyZVRvKG4pPD0wKXJldHVybiBlO2lmKG4uY29tcGFyZVRvKGUpPD0wJiYodC5jb21wYXJlVG8obik8PTB8fHQuY29tcGFyZVRvKGUpPj0wKSlyZXR1cm4gZTtlPW59d2hpbGUoZSE9PXRoaXMpO3JldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCksbnVsbH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKGUpfXRvU3RyaW5nTm9kZSgpe2NvbnN0IHQ9dGhpcy5vcmlnKCk7dGhpcy5kZXN0KCk7Y29uc3QgZT1uZXcgcHQ7ZS5hcHBlbmQoXCJOb2RlKCBcIitXdC5mb3JtYXQodCkrXCIgKVxcblwiKTtsZXQgbj10aGlzO2Rve2UuYXBwZW5kKFwiICAtPiBcIituKSxlLmFwcGVuZChcIlxcblwiKSxuPW4ub05leHQoKX13aGlsZShuIT09dGhpcyk7cmV0dXJuIGUudG9TdHJpbmcoKX1saW5rKHQpe3RoaXMuc2V0U3ltKHQpLHQuc2V0U3ltKHRoaXMpLHRoaXMuc2V0TmV4dCh0KSx0LnNldE5leHQodGhpcyl9bmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fXNldFN5bSh0KXt0aGlzLl9zeW09dH1vcmlnKCl7cmV0dXJuIHRoaXMuX29yaWd9dG9TdHJpbmcoKXtyZXR1cm5cIkhFKFwiK3RoaXMuX29yaWcueCtcIiBcIit0aGlzLl9vcmlnLnkrXCIsIFwiK3RoaXMuX3N5bS5fb3JpZy54K1wiIFwiK3RoaXMuX3N5bS5fb3JpZy55K1wiKVwifXRvU3RyaW5nTm9kZUVkZ2UoKXtyZXR1cm5cIiAgLT4gKFwiK1d0LmZvcm1hdCh0aGlzLmRlc3QoKSl9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9fWNsYXNzIExuIGV4dGVuZHMgU257Y29uc3RydWN0b3IoKXtzdXBlcigpLExuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzTWFya2VkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO1NuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9c3RhdGljIHNldE1hcmtCb3RoKHQsZSl7dC5zZXRNYXJrKGUpLHQuc3ltKCkuc2V0TWFyayhlKX1zdGF0aWMgaXNNYXJrZWQodCl7cmV0dXJuIHQuaXNNYXJrZWQoKX1zdGF0aWMgc2V0TWFyayh0LGUpe3Quc2V0TWFyayhlKX1zdGF0aWMgbWFya0JvdGgodCl7dC5tYXJrKCksdC5zeW0oKS5tYXJrKCl9c3RhdGljIG1hcmsodCl7dC5tYXJrKCl9bWFyaygpe3RoaXMuX2lzTWFya2VkPSEwfXNldE1hcmsodCl7dGhpcy5faXNNYXJrZWQ9dH1pc01hcmtlZCgpe3JldHVybiB0aGlzLl9pc01hcmtlZH19Y2xhc3MgVG57Y29uc3RydWN0b3IoKXtUbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl92ZXJ0ZXhNYXA9bmV3IE50fXN0YXRpYyBpc1ZhbGlkRWRnZSh0LGUpe3JldHVybiAwIT09ZS5jb21wYXJlVG8odCl9aW5zZXJ0KHQsZSxuKXtjb25zdCBzPXRoaXMuY3JlYXRlKHQsZSk7bnVsbCE9PW4/bi5pbnNlcnQocyk6dGhpcy5fdmVydGV4TWFwLnB1dCh0LHMpO2NvbnN0IGk9dGhpcy5fdmVydGV4TWFwLmdldChlKTtyZXR1cm4gbnVsbCE9PWk/aS5pbnNlcnQocy5zeW0oKSk6dGhpcy5fdmVydGV4TWFwLnB1dChlLHMuc3ltKCkpLHN9Y3JlYXRlKHQsZSl7Y29uc3Qgbj10aGlzLmNyZWF0ZUVkZ2UodCkscz10aGlzLmNyZWF0ZUVkZ2UoZSk7cmV0dXJuIG4ubGluayhzKSxufWNyZWF0ZUVkZ2UodCl7cmV0dXJuIG5ldyBTbih0KX1hZGRFZGdlKHQsZSl7aWYoIVRuLmlzVmFsaWRFZGdlKHQsZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLl92ZXJ0ZXhNYXAuZ2V0KHQpO2xldCBzPW51bGw7aWYobnVsbCE9PW4mJihzPW4uZmluZChlKSksbnVsbCE9PXMpcmV0dXJuIHM7cmV0dXJuIHRoaXMuaW5zZXJ0KHQsZSxuKX1nZXRWZXJ0ZXhFZGdlcygpe3JldHVybiB0aGlzLl92ZXJ0ZXhNYXAudmFsdWVzKCl9ZmluZEVkZ2UodCxlKXtjb25zdCBuPXRoaXMuX3ZlcnRleE1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1uP251bGw6bi5maW5kKGUpfX1jbGFzcyBSbiBleHRlbmRzIExue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxSbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc1N0YXJ0PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO0xuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9c2V0U3RhcnQoKXt0aGlzLl9pc1N0YXJ0PSEwfWlzU3RhcnQoKXtyZXR1cm4gdGhpcy5faXNTdGFydH19Y2xhc3MgUG4gZXh0ZW5kcyBUbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9Y3JlYXRlRWRnZSh0KXtyZXR1cm4gbmV3IFJuKHQpfX1jbGFzcyBPbntjb25zdHJ1Y3Rvcigpe09uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Jlc3VsdD1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2xpbmVzPW5ldyBMLHRoaXMuX25vZGVFZGdlU3RhY2s9bmV3IGVuLHRoaXMuX3JpbmdTdGFydEVkZ2U9bnVsbCx0aGlzLl9ncmFwaD1uZXcgUG59c3RhdGljIGRpc3NvbHZlKHQpe2NvbnN0IGU9bmV3IE9uO3JldHVybiBlLmFkZCh0KSxlLmdldFJlc3VsdCgpfWFkZExpbmUodCl7dGhpcy5fbGluZXMuYWRkKHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LnRvQ29vcmRpbmF0ZUFycmF5KCkpKX11cGRhdGVSaW5nU3RhcnRFZGdlKHQpe3JldHVybiB0LmlzU3RhcnQoKXx8KHQ9dC5zeW0oKSkuaXNTdGFydCgpP251bGw9PT10aGlzLl9yaW5nU3RhcnRFZGdlPyh0aGlzLl9yaW5nU3RhcnRFZGdlPXQsbnVsbCk6dm9pZCh0Lm9yaWcoKS5jb21wYXJlVG8odGhpcy5fcmluZ1N0YXJ0RWRnZS5vcmlnKCkpPDAmJih0aGlzLl9yaW5nU3RhcnRFZGdlPXQpKTpudWxsfWdldFJlc3VsdCgpe3JldHVybiBudWxsPT09dGhpcy5fcmVzdWx0JiZ0aGlzLmNvbXB1dGVSZXN1bHQoKSx0aGlzLl9yZXN1bHR9cHJvY2Vzcyh0KXtsZXQgZT10LnByZXZOb2RlKCk7bnVsbD09PWUmJihlPXQpLHRoaXMuc3RhY2tFZGdlcyhlKSx0aGlzLmJ1aWxkTGluZXMoKX1idWlsZFJpbmcodCl7Y29uc3QgZT1uZXcgUjtsZXQgbj10O2ZvcihlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzPT09dClicmVhaztlLmFkZChzLm9yaWcoKS5jb3B5KCksITEpLG49c31lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuYWRkTGluZShlKX1idWlsZExpbmUodCl7Y29uc3QgZT1uZXcgUjtsZXQgbj10O2Zvcih0aGlzLl9yaW5nU3RhcnRFZGdlPW51bGwsTG4ubWFya0JvdGgobiksZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe3RoaXMudXBkYXRlUmluZ1N0YXJ0RWRnZShuKTtjb25zdCBzPW4ubmV4dCgpO2lmKHM9PT10KXJldHVybiB0aGlzLmJ1aWxkUmluZyh0aGlzLl9yaW5nU3RhcnRFZGdlKSxudWxsO2UuYWRkKHMub3JpZygpLmNvcHkoKSwhMSksbj1zLExuLm1hcmtCb3RoKG4pfWUuYWRkKG4uZGVzdCgpLmNsb25lKCksITEpLHRoaXMuc3RhY2tFZGdlcyhuLnN5bSgpKSx0aGlzLmFkZExpbmUoZSl9c3RhY2tFZGdlcyh0KXtsZXQgZT10O2Rve0xuLmlzTWFya2VkKGUpfHx0aGlzLl9ub2RlRWRnZVN0YWNrLmFkZChlKSxlPWUub05leHQoKX13aGlsZShlIT09dCl9Y29tcHV0ZVJlc3VsdCgpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXRWZXJ0ZXhFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0xuLmlzTWFya2VkKGUpfHx0aGlzLnByb2Nlc3MoZSl9dGhpcy5fcmVzdWx0PXRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyl9YnVpbGRMaW5lcygpe2Zvcig7IXRoaXMuX25vZGVFZGdlU3RhY2suZW1wdHkoKTspe2NvbnN0IHQ9dGhpcy5fbm9kZUVkZ2VTdGFjay5wb3AoKTtMbi5pc01hcmtlZCh0KXx8dGhpcy5idWlsZExpbmUodCl9fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7YXJndW1lbnRzWzBdLmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiAkJiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7bGV0IG49ITE7Zm9yKGxldCB0PTE7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9dGhpcy5fZ3JhcGguYWRkRWRnZShlLmdldENvb3JkaW5hdGUodC0xKSxlLmdldENvb3JkaW5hdGUodCkpO251bGwhPT1zJiYobnx8KHMuc2V0U3RhcnQoKSxuPSEwKSl9fX19dmFyIHZuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExpbmVEaXNzb2x2ZXI6T259KTtjbGFzcyBibntzdGF0aWMgb3Bwb3NpdGUodCl7cmV0dXJuIHQ9PT1ibi5MRUZUP2JuLlJJR0hUOnQ9PT1ibi5SSUdIVD9ibi5MRUZUOnR9fWJuLk9OPTAsYm4uTEVGVD0xLGJuLlJJR0hUPTI7bGV0IE1uPWNsYXNze2NvbnN0cnVjdG9yKCl7TW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5tY2U9bnVsbCx0aGlzLmNoYWluSW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm1jZT10LHRoaXMuY2hhaW5JbmRleD1lfWNvbXB1dGVJbnRlcnNlY3Rpb25zKHQsZSl7dGhpcy5tY2UuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLmNoYWluSW5kZXgsdC5tY2UsdC5jaGFpbkluZGV4LGUpfX07Y2xhc3MgRG57Y29uc3RydWN0b3IoKXtEbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9sYWJlbD1udWxsLHRoaXMuX3hWYWx1ZT1udWxsLHRoaXMuX2V2ZW50VHlwZT1udWxsLHRoaXMuX2luc2VydEV2ZW50PW51bGwsdGhpcy5fZGVsZXRlRXZlbnRJbmRleD1udWxsLHRoaXMuX29iaj1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ldmVudFR5cGU9RG4uREVMRVRFLHRoaXMuX3hWYWx1ZT10LHRoaXMuX2luc2VydEV2ZW50PWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZXZlbnRUeXBlPURuLklOU0VSVCx0aGlzLl9sYWJlbD10LHRoaXMuX3hWYWx1ZT1lLHRoaXMuX29iaj1ufX1pc0RlbGV0ZSgpe3JldHVybiB0aGlzLl9ldmVudFR5cGU9PT1Ebi5ERUxFVEV9c2V0RGVsZXRlRXZlbnRJbmRleCh0KXt0aGlzLl9kZWxldGVFdmVudEluZGV4PXR9Z2V0T2JqZWN0KCl7cmV0dXJuIHRoaXMuX29ian1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl94VmFsdWU8ZS5feFZhbHVlPy0xOnRoaXMuX3hWYWx1ZT5lLl94VmFsdWU/MTp0aGlzLl9ldmVudFR5cGU8ZS5fZXZlbnRUeXBlPy0xOnRoaXMuX2V2ZW50VHlwZT5lLl9ldmVudFR5cGU/MTowfWdldEluc2VydEV2ZW50KCl7cmV0dXJuIHRoaXMuX2luc2VydEV2ZW50fWlzSW5zZXJ0KCl7cmV0dXJuIHRoaXMuX2V2ZW50VHlwZT09PURuLklOU0VSVH1pc1NhbWVMYWJlbCh0KXtyZXR1cm4gbnVsbCE9PXRoaXMuX2xhYmVsJiZ0aGlzLl9sYWJlbD09PXQuX2xhYmVsfWdldERlbGV0ZUV2ZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fZGVsZXRlRXZlbnRJbmRleH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fURuLklOU0VSVD0xLERuLkRFTEVURT0yO2NsYXNzIEFue31sZXQgRm49Y2xhc3N7Y29uc3RydWN0b3IoKXtGbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5faGFzUHJvcGVyPSExLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSExLHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9pbmNsdWRlUHJvcGVyPW51bGwsdGhpcy5fcmVjb3JkSXNvbGF0ZWQ9bnVsbCx0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb249bnVsbCx0aGlzLl9udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wLHRoaXMuX2JkeU5vZGVzPW51bGwsdGhpcy5faXNEb25lPSExLHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbGk9dCx0aGlzLl9pbmNsdWRlUHJvcGVyPWUsdGhpcy5fcmVjb3JkSXNvbGF0ZWQ9bn1zdGF0aWMgaXNBZGphY2VudFNlZ21lbnRzKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfWlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXtpZih0PT09biYmMT09PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihGbi5pc0FkamFjZW50U2VnbWVudHMoZSxzKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe2NvbnN0IG49dC5nZXROdW1Qb2ludHMoKS0xO2lmKDA9PT1lJiZzPT09bnx8MD09PXMmJmU9PT1uKXJldHVybiEwfX1yZXR1cm4hMX1nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpe3JldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH1zZXRJc0RvbmVJZlByb3BlckludCh0KXt0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50PXR9aGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3J9aXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKS5nZXRDb29yZGluYXRlKCk7aWYodC5pc0ludGVyc2VjdGlvbihlKSlyZXR1cm4hMH1yZXR1cm4hMX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIHRoaXMuX2lzRG9uZX1pc0JvdW5kYXJ5UG9pbnQodCxlKXtyZXR1cm4gbnVsbCE9PWUmJighIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzBdKXx8ISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVsxXSkpfXNldEJvdW5kYXJ5Tm9kZXModCxlKXt0aGlzLl9iZHlOb2Rlcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9iZHlOb2Rlc1swXT10LHRoaXMuX2JkeU5vZGVzWzFdPWV9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5fcmVjb3JkSXNvbGF0ZWQmJih0LnNldElzb2xhdGVkKCExKSxuLnNldElzb2xhdGVkKCExKSksdGhpcy5fbnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLCF0aGlzLl9pbmNsdWRlUHJvcGVyJiZ0aGlzLl9saS5pc1Byb3BlcigpfHwodC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSkpLHRoaXMuX2xpLmlzUHJvcGVyKCkmJih0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkuY29weSgpLHRoaXMuX2hhc1Byb3Blcj0hMCx0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50JiYodGhpcy5faXNEb25lPSEwKSx0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLl9saSx0aGlzLl9iZHlOb2Rlcyl8fCh0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKSl9fTtjbGFzcyBHbiBleHRlbmRzIEFue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxHbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmV2ZW50cz1uZXcgTCx0aGlzLm5PdmVybGFwcz1udWxsfXByZXBhcmVFdmVudHMoKXt4ZS5zb3J0KHRoaXMuZXZlbnRzKTtmb3IobGV0IHQ9MDt0PHRoaXMuZXZlbnRzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5ldmVudHMuZ2V0KHQpO2UuaXNEZWxldGUoKSYmZS5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgodCl9fWNvbXB1dGVJbnRlcnNlY3Rpb25zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubk92ZXJsYXBzPTAsdGhpcy5wcmVwYXJlRXZlbnRzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLmV2ZW50cy5zaXplKCk7ZSsrKXtjb25zdCBuPXRoaXMuZXZlbnRzLmdldChlKTtpZihuLmlzSW5zZXJ0KCkmJnRoaXMucHJvY2Vzc092ZXJsYXBzKGUsbi5nZXREZWxldGVFdmVudEluZGV4KCksbix0KSx0LmlzRG9uZSgpKWJyZWFrfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgRm4mJkkoYXJndW1lbnRzWzBdLEMpJiZJKGFyZ3VtZW50c1sxXSxDKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5hZGRFZGdlcyh0LHQpLHRoaXMuYWRkRWRnZXMoZSxlKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKG4pfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJkkoYXJndW1lbnRzWzBdLEMpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEZuKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl0/dGhpcy5hZGRFZGdlcyh0LG51bGwpOnRoaXMuYWRkRWRnZXModCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhlKX19YWRkRWRnZSh0LGUpe2NvbnN0IG49dC5nZXRNb25vdG9uZUNoYWluRWRnZSgpLHM9bi5nZXRTdGFydEluZGV4ZXMoKTtmb3IobGV0IHQ9MDt0PHMubGVuZ3RoLTE7dCsrKXtjb25zdCBzPW5ldyBNbihuLHQpLGk9bmV3IERuKGUsbi5nZXRNaW5YKHQpLHMpO3RoaXMuZXZlbnRzLmFkZChpKSx0aGlzLmV2ZW50cy5hZGQobmV3IERuKG4uZ2V0TWF4WCh0KSxpKSl9fXByb2Nlc3NPdmVybGFwcyh0LGUsbixzKXtjb25zdCBpPW4uZ2V0T2JqZWN0KCk7Zm9yKGxldCByPXQ7cjxlO3IrKyl7Y29uc3QgdD10aGlzLmV2ZW50cy5nZXQocik7aWYodC5pc0luc2VydCgpKXtjb25zdCBlPXQuZ2V0T2JqZWN0KCk7bi5pc1NhbWVMYWJlbCh0KXx8KGkuY29tcHV0ZUludGVyc2VjdGlvbnMoZSxzKSx0aGlzLm5PdmVybGFwcysrKX19fWFkZEVkZ2VzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGRFZGdlKGUsZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5hZGRFZGdlKG4sdCl9fX19Y2xhc3MgcW57Y29uc3RydWN0b3IoKXtxbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLmxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0Lmxlbmd0aCl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCgxKSx0aGlzLmxvY2F0aW9uW2JuLk9OXT10fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxbil7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pbml0KHQubG9jYXRpb24ubGVuZ3RoKSxudWxsIT09dClmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuaW5pdCgzKSx0aGlzLmxvY2F0aW9uW2JuLk9OXT10LHRoaXMubG9jYXRpb25bYm4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW2JuLlJJR0hUXT1ufX1zZXRBbGxMb2NhdGlvbnModCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10fWlzTnVsbCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF0hPT1RdC5OT05FKXJldHVybiExO3JldHVybiEwfXNldEFsbExvY2F0aW9uc0lmTnVsbCh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPT09UXQuTk9ORSYmKHRoaXMubG9jYXRpb25bZV09dCl9aXNMaW5lKCl7cmV0dXJuIDE9PT10aGlzLmxvY2F0aW9uLmxlbmd0aH1tZXJnZSh0KXtpZih0LmxvY2F0aW9uLmxlbmd0aD50aGlzLmxvY2F0aW9uLmxlbmd0aCl7Y29uc3QgdD1uZXcgQXJyYXkoMykuZmlsbChudWxsKTt0W2JuLk9OXT10aGlzLmxvY2F0aW9uW2JuLk9OXSx0W2JuLkxFRlRdPVF0Lk5PTkUsdFtibi5SSUdIVF09UXQuTk9ORSx0aGlzLmxvY2F0aW9uPXR9Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PVF0Lk5PTkUmJmU8dC5sb2NhdGlvbi5sZW5ndGgmJih0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV0pfWdldExvY2F0aW9ucygpe3JldHVybiB0aGlzLmxvY2F0aW9ufWZsaXAoKXtpZih0aGlzLmxvY2F0aW9uLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMubG9jYXRpb25bYm4uTEVGVF07dGhpcy5sb2NhdGlvbltibi5MRUZUXT10aGlzLmxvY2F0aW9uW2JuLlJJR0hUXSx0aGlzLmxvY2F0aW9uW2JuLlJJR0hUXT10fXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdjtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQoUXQudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2JuLkxFRlRdKSksdC5hcHBlbmQoUXQudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2JuLk9OXSkpLHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKFF0LnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltibi5SSUdIVF0pKSx0LnRvU3RyaW5nKCl9c2V0TG9jYXRpb25zKHQsZSxuKXt0aGlzLmxvY2F0aW9uW2JuLk9OXT10LHRoaXMubG9jYXRpb25bYm4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW2JuLlJJR0hUXT1ufWdldCh0KXtyZXR1cm4gdDx0aGlzLmxvY2F0aW9uLmxlbmd0aD90aGlzLmxvY2F0aW9uW3RdOlF0Lk5PTkV9aXNBcmVhKCl7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjF9aXNBbnlOdWxsKCl7Zm9yKGxldCB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XT09PVF0Lk5PTkUpcmV0dXJuITA7cmV0dXJuITF9c2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRMb2NhdGlvbihibi5PTix0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmxvY2F0aW9uW3RdPWV9fWluaXQodCl7dGhpcy5sb2NhdGlvbj1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLnNldEFsbExvY2F0aW9ucyhRdC5OT05FKX1pc0VxdWFsT25TaWRlKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRpb25bZV09PT10LmxvY2F0aW9uW2VdfWFsbFBvc2l0aW9uc0VxdWFsKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKWlmKHRoaXMubG9jYXRpb25bZV0hPT10KXJldHVybiExO3JldHVybiEwfX1jbGFzcyBCbntjb25zdHJ1Y3Rvcigpe0JuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuZWx0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBxbih0KSx0aGlzLmVsdFsxXT1uZXcgcW4odCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEJuKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgcW4odC5lbHRbMF0pLHRoaXMuZWx0WzFdPW5ldyBxbih0LmVsdFsxXSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0WzBdPW5ldyBxbihRdC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgcW4oUXQuTk9ORSksdGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5lbHRbMF09bmV3IHFuKHQsZSxuKSx0aGlzLmVsdFsxXT1uZXcgcW4odCxlLG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuZWx0WzBdPW5ldyBxbihRdC5OT05FLFF0Lk5PTkUsUXQuTk9ORSksdGhpcy5lbHRbMV09bmV3IHFuKFF0Lk5PTkUsUXQuTk9ORSxRdC5OT05FKSx0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbnMoZSxuLHMpfX1zdGF0aWMgdG9MaW5lTGFiZWwodCl7Y29uc3QgZT1uZXcgQm4oUXQuTk9ORSk7Zm9yKGxldCBuPTA7bjwyO24rKyllLnNldExvY2F0aW9uKG4sdC5nZXRMb2NhdGlvbihuKSk7cmV0dXJuIGV9Z2V0R2VvbWV0cnlDb3VudCgpe2xldCB0PTA7cmV0dXJuIHRoaXMuZWx0WzBdLmlzTnVsbCgpfHx0KyssdGhpcy5lbHRbMV0uaXNOdWxsKCl8fHQrKyx0fXNldEFsbExvY2F0aW9ucyh0LGUpe3RoaXMuZWx0W3RdLnNldEFsbExvY2F0aW9ucyhlKX1pc051bGwodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTnVsbCgpfXNldEFsbExvY2F0aW9uc0lmTnVsbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQpLHRoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zSWZOdWxsKGUpfX1pc0xpbmUodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTGluZSgpfW1lcmdlKHQpe2ZvcihsZXQgZT0wO2U8MjtlKyspbnVsbD09PXRoaXMuZWx0W2VdJiZudWxsIT09dC5lbHRbZV0/dGhpcy5lbHRbZV09bmV3IHFuKHQuZWx0W2VdKTp0aGlzLmVsdFtlXS5tZXJnZSh0LmVsdFtlXSl9ZmxpcCgpe3RoaXMuZWx0WzBdLmZsaXAoKSx0aGlzLmVsdFsxXS5mbGlwKCl9Z2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmdldChibi5PTil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoZSl9fXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdjtyZXR1cm4gbnVsbCE9PXRoaXMuZWx0WzBdJiYodC5hcHBlbmQoXCJBOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFswXS50b1N0cmluZygpKSksbnVsbCE9PXRoaXMuZWx0WzFdJiYodC5hcHBlbmQoXCIgQjpcIiksdC5hcHBlbmQodGhpcy5lbHRbMV0udG9TdHJpbmcoKSkpLHQudG9TdHJpbmcoKX1pc0FyZWEoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5lbHRbMF0uaXNBcmVhKCl8fHRoaXMuZWx0WzFdLmlzQXJlYSgpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBcmVhKCl9fWlzQW55TnVsbCh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBbnlOdWxsKCl9c2V0TG9jYXRpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oYm4uT04sZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oZSxuKX19aXNFcXVhbE9uU2lkZSh0LGUpe3JldHVybiB0aGlzLmVsdFswXS5pc0VxdWFsT25TaWRlKHQuZWx0WzBdLGUpJiZ0aGlzLmVsdFsxXS5pc0VxdWFsT25TaWRlKHQuZWx0WzFdLGUpfWFsbFBvc2l0aW9uc0VxdWFsKHQsZSl7cmV0dXJuIHRoaXMuZWx0W3RdLmFsbFBvc2l0aW9uc0VxdWFsKGUpfXRvTGluZSh0KXt0aGlzLmVsdFt0XS5pc0FyZWEoKSYmKHRoaXMuZWx0W3RdPW5ldyBxbih0aGlzLmVsdFt0XS5sb2NhdGlvblswXSkpfX1jbGFzcyBZbntjb25zdHJ1Y3Rvcigpe1luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuZGlzdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuY29vcmQ9bmV3IG0odCksdGhpcy5zZWdtZW50SW5kZXg9ZSx0aGlzLmRpc3Q9bn1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXh9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvb3JkfXByaW50KHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KSx0LnByaW50bG4oXCIgZGlzdCA9IFwiK3RoaXMuZGlzdCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlKGUuc2VnbWVudEluZGV4LGUuZGlzdCl9aXNFbmRQb2ludCh0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYwPT09dGhpcy5kaXN0fHx0aGlzLnNlZ21lbnRJbmRleD09PXR9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5jb29yZCtcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4K1wiIGRpc3QgPSBcIit0aGlzLmRpc3R9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5kaXN0fWNvbXBhcmUodCxlKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8dD8tMTp0aGlzLnNlZ21lbnRJbmRleD50PzE6dGhpcy5kaXN0PGU/LTE6dGhpcy5kaXN0PmU/MTowfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgVm4gZXh0ZW5kcyB4dHt9ZnVuY3Rpb24gem4odCl7cmV0dXJuIG51bGw9PXQ/MDp0LmNvbG9yfWZ1bmN0aW9uIFhuKHQpe3JldHVybiBudWxsPT10P251bGw6dC5wYXJlbnR9ZnVuY3Rpb24ga24odCxlKXtudWxsIT09dCYmKHQuY29sb3I9ZSl9ZnVuY3Rpb24gVW4odCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LmxlZnR9ZnVuY3Rpb24gSG4odCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnJpZ2h0fWNsYXNzIFduIGV4dGVuZHMgVm57Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucm9vdF89bnVsbCx0aGlzLnNpemVfPTB9Z2V0KHQpe2xldCBlPXRoaXMucm9vdF87Zm9yKDtudWxsIT09ZTspe2NvbnN0IG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4gZS52YWx1ZTtlPWUucmlnaHR9fXJldHVybiBudWxsfXB1dCh0LGUpe2lmKG51bGw9PT10aGlzLnJvb3RfKXJldHVybiB0aGlzLnJvb3RfPXtrZXk6dCx2YWx1ZTplLGxlZnQ6bnVsbCxyaWdodDpudWxsLHBhcmVudDpudWxsLGNvbG9yOjAsZ2V0VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5KCl7cmV0dXJuIHRoaXMua2V5fX0sdGhpcy5zaXplXz0xLG51bGw7bGV0IG4scyxpPXRoaXMucm9vdF87ZG97aWYobj1pLHM9dC5jb21wYXJlVG8oaS5rZXkpLHM8MClpPWkubGVmdDtlbHNle2lmKCEocz4wKSl7Y29uc3QgdD1pLnZhbHVlO3JldHVybiBpLnZhbHVlPWUsdH1pPWkucmlnaHR9fXdoaWxlKG51bGwhPT1pKTtjb25zdCByPXtrZXk6dCxsZWZ0Om51bGwscmlnaHQ6bnVsbCx2YWx1ZTplLHBhcmVudDpuLGNvbG9yOjAsZ2V0VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5KCl7cmV0dXJuIHRoaXMua2V5fX07cmV0dXJuIHM8MD9uLmxlZnQ9cjpuLnJpZ2h0PXIsdGhpcy5maXhBZnRlckluc2VydGlvbihyKSx0aGlzLnNpemVfKyssbnVsbH1maXhBZnRlckluc2VydGlvbih0KXtsZXQgZTtmb3IodC5jb2xvcj0xO251bGwhPXQmJnQhPT10aGlzLnJvb3RfJiYxPT09dC5wYXJlbnQuY29sb3I7KVhuKHQpPT09VW4oWG4oWG4odCkpKT8oZT1IbihYbihYbih0KSkpLDE9PT16bihlKT8oa24oWG4odCksMCksa24oZSwwKSxrbihYbihYbih0KSksMSksdD1YbihYbih0KSkpOih0PT09SG4oWG4odCkpJiYodD1Ybih0KSx0aGlzLnJvdGF0ZUxlZnQodCkpLGtuKFhuKHQpLDApLGtuKFhuKFhuKHQpKSwxKSx0aGlzLnJvdGF0ZVJpZ2h0KFhuKFhuKHQpKSkpKTooZT1VbihYbihYbih0KSkpLDE9PT16bihlKT8oa24oWG4odCksMCksa24oZSwwKSxrbihYbihYbih0KSksMSksdD1YbihYbih0KSkpOih0PT09VW4oWG4odCkpJiYodD1Ybih0KSx0aGlzLnJvdGF0ZVJpZ2h0KHQpKSxrbihYbih0KSwwKSxrbihYbihYbih0KSksMSksdGhpcy5yb3RhdGVMZWZ0KFhuKFhuKHQpKSkpKTt0aGlzLnJvb3RfLmNvbG9yPTB9dmFsdWVzKCl7Y29uc3QgdD1uZXcgTDtsZXQgZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZS52YWx1ZSk7bnVsbCE9PShlPVduLnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUudmFsdWUpO3JldHVybiB0fWVudHJ5U2V0KCl7Y29uc3QgdD1uZXcgRXQ7bGV0IGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUpO251bGwhPT0oZT1Xbi5zdWNjZXNzb3IoZSkpOyl0LmFkZChlKTtyZXR1cm4gdH1yb3RhdGVMZWZ0KHQpe2lmKG51bGwhPXQpe2NvbnN0IGU9dC5yaWdodDt0LnJpZ2h0PWUubGVmdCxudWxsIT1lLmxlZnQmJihlLmxlZnQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5sZWZ0PT09dD90LnBhcmVudC5sZWZ0PWU6dC5wYXJlbnQucmlnaHQ9ZSxlLmxlZnQ9dCx0LnBhcmVudD1lfX1yb3RhdGVSaWdodCh0KXtpZihudWxsIT10KXtjb25zdCBlPXQubGVmdDt0LmxlZnQ9ZS5yaWdodCxudWxsIT1lLnJpZ2h0JiYoZS5yaWdodC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LnJpZ2h0PT09dD90LnBhcmVudC5yaWdodD1lOnQucGFyZW50LmxlZnQ9ZSxlLnJpZ2h0PXQsdC5wYXJlbnQ9ZX19Z2V0Rmlyc3RFbnRyeSgpe2xldCB0PXRoaXMucm9vdF87aWYobnVsbCE9dClmb3IoO251bGwhPXQubGVmdDspdD10LmxlZnQ7cmV0dXJuIHR9c3RhdGljIHN1Y2Nlc3Nvcih0KXtsZXQgZTtpZihudWxsPT09dClyZXR1cm4gbnVsbDtpZihudWxsIT09dC5yaWdodCl7Zm9yKGU9dC5yaWdodDtudWxsIT09ZS5sZWZ0OyllPWUubGVmdDtyZXR1cm4gZX17ZT10LnBhcmVudDtsZXQgbj10O2Zvcig7bnVsbCE9PWUmJm49PT1lLnJpZ2h0OyluPWUsZT1lLnBhcmVudDtyZXR1cm4gZX19c2l6ZSgpe3JldHVybiB0aGlzLnNpemVffWNvbnRhaW5zS2V5KHQpe2xldCBlPXRoaXMucm9vdF87Zm9yKDtudWxsIT09ZTspe2NvbnN0IG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4hMDtlPWUucmlnaHR9fXJldHVybiExfX1jbGFzcyBabntjb25zdHJ1Y3Rvcigpe1puLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVNYXA9bmV3IFduLHRoaXMuZWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fXByaW50KHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfWFkZFNwbGl0RWRnZXModCl7dGhpcy5hZGRFbmRwb2ludHMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4scyk7dC5hZGQoaSksbj1zfX1hZGRFbmRwb2ludHMoKXtjb25zdCB0PXRoaXMuZWRnZS5wdHMubGVuZ3RoLTE7dGhpcy5hZGQodGhpcy5lZGdlLnB0c1swXSwwLDApLHRoaXMuYWRkKHRoaXMuZWRnZS5wdHNbdF0sdCwwKX1jcmVhdGVTcGxpdEVkZ2UodCxlKXtsZXQgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyO2NvbnN0IHM9dGhpcy5lZGdlLnB0c1tlLnNlZ21lbnRJbmRleF0saT1lLmRpc3Q+MHx8IWUuY29vcmQuZXF1YWxzMkQocyk7aXx8bi0tO2NvbnN0IHI9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7bGV0IG89MDtyW28rK109bmV3IG0odC5jb29yZCk7Zm9yKGxldCBuPXQuc2VnbWVudEluZGV4KzE7bjw9ZS5zZWdtZW50SW5kZXg7bisrKXJbbysrXT10aGlzLmVkZ2UucHRzW25dO3JldHVybiBpJiYocltvXT1lLmNvb3JkKSxuZXcgdHMocixuZXcgQm4odGhpcy5lZGdlLl9sYWJlbCkpfWFkZCh0LGUsbil7Y29uc3Qgcz1uZXcgWW4odCxlLG4pLGk9dGhpcy5fbm9kZU1hcC5nZXQocyk7cmV0dXJuIG51bGwhPT1pP2k6KHRoaXMuX25vZGVNYXAucHV0KHMscykscyl9aXNJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvb3JkLmVxdWFscyh0KSlyZXR1cm4hMH1yZXR1cm4hMX19Y2xhc3Mgam57Y29uc3RydWN0b3IoKXtqbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9kYXRhPW51bGwsdGhpcy5fc2l6ZT0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKWpuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMTApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RhdGE9bmV3IEFycmF5KHQpLmZpbGwobnVsbCl9fXNpemUoKXtyZXR1cm4gdGhpcy5fc2l6ZX1hZGRBbGwodCl7cmV0dXJuIG51bGw9PT10fHwwPT09dC5sZW5ndGg/bnVsbDoodGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplK3QubGVuZ3RoKSxZLmFycmF5Y29weSh0LDAsdGhpcy5fZGF0YSx0aGlzLl9zaXplLHQubGVuZ3RoKSx2b2lkKHRoaXMuX3NpemUrPXQubGVuZ3RoKSl9ZW5zdXJlQ2FwYWNpdHkodCl7aWYodDw9dGhpcy5fZGF0YS5sZW5ndGgpcmV0dXJuIG51bGw7Y29uc3QgZT1NYXRoLm1heCh0LDIqdGhpcy5fZGF0YS5sZW5ndGgpO3RoaXMuX2RhdGE9c3QuY29weU9mKHRoaXMuX2RhdGEsZSl9dG9BcnJheSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX3NpemUpLmZpbGwobnVsbCk7cmV0dXJuIFkuYXJyYXljb3B5KHRoaXMuX2RhdGEsMCx0LDAsdGhpcy5fc2l6ZSksdH1hZGQodCl7dGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplKzEpLHRoaXMuX2RhdGFbdGhpcy5fc2l6ZV09dCwrK3RoaXMuX3NpemV9fWNsYXNzIEtue3N0YXRpYyB0b0ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX1nZXRDaGFpblN0YXJ0SW5kaWNlcyh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IGpuKE1hdGgudHJ1bmModC5sZW5ndGgvMikpO24uYWRkKGUpO2Rve2NvbnN0IHM9dGhpcy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChzKSxlPXN9d2hpbGUoZTx0Lmxlbmd0aC0xKTtyZXR1cm4gbi50b0FycmF5KCl9ZmluZENoYWluRW5kKHQsZSl7Y29uc3Qgbj1Dbi5xdWFkcmFudCh0W2VdLHRbZSsxXSk7bGV0IHM9ZSsxO2Zvcig7czx0Lmxlbmd0aDspe2lmKENuLnF1YWRyYW50KHRbcy0xXSx0W3NdKSE9PW4pYnJlYWs7cysrfXJldHVybiBzLTF9T0xEZ2V0Q2hhaW5TdGFydEluZGljZXModCl7bGV0IGU9MDtjb25zdCBuPW5ldyBMO24uYWRkKGUpO2Rve2NvbnN0IHM9dGhpcy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChzKSxlPXN9d2hpbGUoZTx0Lmxlbmd0aC0xKTtyZXR1cm4gS24udG9JbnRBcnJheShuKX19Y2xhc3MgUW57Y29uc3RydWN0b3IoKXtRbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmU9bnVsbCx0aGlzLnB0cz1udWxsLHRoaXMuc3RhcnRJbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZT10LHRoaXMucHRzPXQuZ2V0Q29vcmRpbmF0ZXMoKTtjb25zdCBlPW5ldyBLbjt0aGlzLnN0YXJ0SW5kZXg9ZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0aGlzLnB0cyl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9Z2V0TWF4WCh0KXtjb25zdCBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPm4/ZTpufWdldE1pblgodCl7Y29uc3QgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZTxuP2U6bn1jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLnN0YXJ0SW5kZXhbdF0sdGhpcy5zdGFydEluZGV4W3QrMV0sZSxlLnN0YXJ0SW5kZXhbbl0sZS5zdGFydEluZGV4W24rMV0scyl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07aWYoZS10PT0xJiZpLXM9PTEpcmV0dXJuIHIuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmUsdCxuLmUscyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odCxvLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHQsbyxuLGwsaSxyKSksbzxlJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG8sZSxuLGwsaSxyKSl9fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE8uaW50ZXJzZWN0cyh0aGlzLnB0c1t0XSx0aGlzLnB0c1tlXSxuLnB0c1tzXSxuLnB0c1tpXSl9Z2V0U3RhcnRJbmRleGVzKCl7cmV0dXJuIHRoaXMuc3RhcnRJbmRleH1jb21wdXRlSW50ZXJzZWN0cyh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5zdGFydEluZGV4Lmxlbmd0aC0xO24rKylmb3IobGV0IHM9MDtzPHQuc3RhcnRJbmRleC5sZW5ndGgtMTtzKyspdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG4sdCxzLGUpfX1jbGFzcyBKbntjb25zdHJ1Y3Rvcigpe0puLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2RlcHRoPUFycmF5KDIpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgzKSkpO2ZvcihsZXQgdD0wO3Q8Mjt0KyspZm9yKGxldCBlPTA7ZTwzO2UrKyl0aGlzLl9kZXB0aFt0XVtlXT1Kbi5OVUxMX1ZBTFVFfXN0YXRpYyBkZXB0aEF0TG9jYXRpb24odCl7cmV0dXJuIHQ9PT1RdC5FWFRFUklPUj8wOnQ9PT1RdC5JTlRFUklPUj8xOkpuLk5VTExfVkFMVUV9Z2V0RGVwdGgodCxlKXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV19c2V0RGVwdGgodCxlLG4pe3RoaXMuX2RlcHRoW3RdW2VdPW59aXNOdWxsKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD0wO3Q8Mjt0KyspZm9yKGxldCBlPTA7ZTwzO2UrKylpZih0aGlzLl9kZXB0aFt0XVtlXSE9PUpuLk5VTExfVkFMVUUpcmV0dXJuITE7cmV0dXJuITB9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kZXB0aFt0XVsxXT09PUpuLk5VTExfVkFMVUV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXT09PUpuLk5VTExfVkFMVUV9fW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8Mjt0KyspaWYoIXRoaXMuaXNOdWxsKHQpKXtsZXQgZT10aGlzLl9kZXB0aFt0XVsxXTt0aGlzLl9kZXB0aFt0XVsyXTxlJiYoZT10aGlzLl9kZXB0aFt0XVsyXSksZTwwJiYoZT0wKTtmb3IobGV0IG49MTtuPDM7bisrKXtsZXQgcz0wO3RoaXMuX2RlcHRoW3RdW25dPmUmJihzPTEpLHRoaXMuX2RlcHRoW3RdW25dPXN9fX1nZXREZWx0YSh0KXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bYm4uUklHSFRdLXRoaXMuX2RlcHRoW3RdW2JuLkxFRlRdfWdldExvY2F0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdPD0wP1F0LkVYVEVSSU9SOlF0LklOVEVSSU9SfXRvU3RyaW5nKCl7cmV0dXJuXCJBOiBcIit0aGlzLl9kZXB0aFswXVsxXStcIixcIit0aGlzLl9kZXB0aFswXVsyXStcIiBCOiBcIit0aGlzLl9kZXB0aFsxXVsxXStcIixcIit0aGlzLl9kZXB0aFsxXVsyXX1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTwyO2UrKylmb3IobGV0IG49MTtuPDM7bisrKXtjb25zdCBzPXQuZ2V0TG9jYXRpb24oZSxuKTtzIT09UXQuRVhURVJJT1ImJnMhPT1RdC5JTlRFUklPUnx8KHRoaXMuaXNOdWxsKGUsbik/dGhpcy5fZGVwdGhbZV1bbl09Sm4uZGVwdGhBdExvY2F0aW9uKHMpOnRoaXMuX2RlcHRoW2VdW25dKz1Kbi5kZXB0aEF0TG9jYXRpb24ocykpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl09PT1RdC5JTlRFUklPUiYmdGhpcy5fZGVwdGhbdF1bZV0rK319fUpuLk5VTExfVkFMVUU9LTE7bGV0ICRuPWNsYXNze2NvbnN0cnVjdG9yKCl7JG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzQ292ZXJlZD0hMSx0aGlzLl9pc0NvdmVyZWRTZXQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sYWJlbD10fX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fXNldEluUmVzdWx0KHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH1pc0NvdmVyZWQoKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkfWlzQ292ZXJlZFNldCgpe3JldHVybiB0aGlzLl9pc0NvdmVyZWRTZXR9c2V0TGFiZWwodCl7dGhpcy5fbGFiZWw9dH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1zZXRDb3ZlcmVkKHQpe3RoaXMuX2lzQ292ZXJlZD10LHRoaXMuX2lzQ292ZXJlZFNldD0hMH11cGRhdGVJTSh0KXtnLmlzVHJ1ZSh0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCk+PTIsXCJmb3VuZCBwYXJ0aWFsIGxhYmVsXCIpLHRoaXMuY29tcHV0ZUlNKHQpfWlzSW5SZXN1bHQoKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfX0sdHM9Y2xhc3MgZXh0ZW5kcyAkbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5wdHM9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLmVpTGlzdD1uZXcgWm4odGhpcyksdGhpcy5fbmFtZT1udWxsLHRoaXMuX21jZT1udWxsLHRoaXMuX2lzSXNvbGF0ZWQ9ITAsdGhpcy5fZGVwdGg9bmV3IEpuLHRoaXMuX2RlcHRoRGVsdGE9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dHMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucHRzPXQsdGhpcy5fbGFiZWw9ZX19c3RhdGljIHVwZGF0ZUlNKCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBKdCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCbikpcmV0dXJuIHN1cGVyLnVwZGF0ZUlNLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsYm4uT04pLHQuZ2V0TG9jYXRpb24oMSxibi5PTiksMSksdC5pc0FyZWEoKSYmKGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGJuLkxFRlQpLHQuZ2V0TG9jYXRpb24oMSxibi5MRUZUKSwyKSxlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxibi5SSUdIVCksdC5nZXRMb2NhdGlvbigxLGJuLlJJR0hUKSwyKSl9fWdldERlcHRoKCl7cmV0dXJuIHRoaXMuX2RlcHRofWdldENvbGxhcHNlZEVkZ2UoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3RbMF09dGhpcy5wdHNbMF0sdFsxXT10aGlzLnB0c1sxXTtyZXR1cm4gbmV3IHRzKHQsQm4udG9MaW5lTGFiZWwodGhpcy5fbGFiZWwpKX1pc0lzb2xhdGVkKCl7cmV0dXJuIHRoaXMuX2lzSXNvbGF0ZWR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9c2V0SXNvbGF0ZWQodCl7dGhpcy5faXNJc29sYXRlZD10fXNldE5hbWUodCl7dGhpcy5fbmFtZT10fWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiB0cykpcmV0dXJuITE7Y29uc3QgZT10O2lmKHRoaXMucHRzLmxlbmd0aCE9PWUucHRzLmxlbmd0aClyZXR1cm4hMTtsZXQgbj0hMCxzPSEwLGk9dGhpcy5wdHMubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKylpZih0aGlzLnB0c1t0XS5lcXVhbHMyRChlLnB0c1t0XSl8fChuPSExKSx0aGlzLnB0c1t0XS5lcXVhbHMyRChlLnB0c1stLWldKXx8KHM9ITEpLCFuJiYhcylyZXR1cm4hMTtyZXR1cm4hMH1nZXRDb29yZGluYXRlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMucHRzLmxlbmd0aD4wP3RoaXMucHRzWzBdOm51bGw7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnB0c1t0XX19cHJpbnQodCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpLHQucHJpbnQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3QucHJpbnQoXCIpICBcIit0aGlzLl9sYWJlbCtcIiBcIit0aGlzLl9kZXB0aERlbHRhKX1jb21wdXRlSU0odCl7dHMudXBkYXRlSU0odGhpcy5fbGFiZWwsdCl9aXNDb2xsYXBzZWQoKXtyZXR1cm4hIXRoaXMuX2xhYmVsLmlzQXJlYSgpJiYoMz09PXRoaXMucHRzLmxlbmd0aCYmISF0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbMl0pKX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX1nZXRNYXhpbXVtU2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aC0xfWdldERlcHRoRGVsdGEoKXtyZXR1cm4gdGhpcy5fZGVwdGhEZWx0YX1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofXByaW50UmV2ZXJzZSh0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIik7Zm9yKGxldCBlPXRoaXMucHRzLmxlbmd0aC0xO2U+PTA7ZS0tKXQucHJpbnQodGhpcy5wdHNbZV0rXCIgXCIpO3QucHJpbnRsbihcIlwiKX1nZXRNb25vdG9uZUNoYWluRWRnZSgpe3JldHVybiBudWxsPT09dGhpcy5fbWNlJiYodGhpcy5fbWNlPW5ldyBRbih0aGlzKSksdGhpcy5fbWNlfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7dGhpcy5fZW52PW5ldyBPO2ZvcihsZXQgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLl9lbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMucHRzW3RdKX1yZXR1cm4gdGhpcy5fZW52fWFkZEludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPW5ldyBtKHQuZ2V0SW50ZXJzZWN0aW9uKHMpKTtsZXQgcj1lLG89dC5nZXRFZGdlRGlzdGFuY2UobixzKTtjb25zdCBsPXIrMTtpZihsPHRoaXMucHRzLmxlbmd0aCl7Y29uc3QgdD10aGlzLnB0c1tsXTtpLmVxdWFsczJEKHQpJiYocj1sLG89MCl9dGhpcy5laUxpc3QuYWRkKGkscixvKX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHB0O3QuYXBwZW5kKFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIiksdC5hcHBlbmQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5hcHBlbmQoXCIsXCIpLHQuYXBwZW5kKHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7cmV0dXJuIHQuYXBwZW5kKFwiKSAgXCIrdGhpcy5fbGFiZWwrXCIgXCIrdGhpcy5fZGVwdGhEZWx0YSksdC50b1N0cmluZygpfWlzUG9pbnR3aXNlRXF1YWwodCl7aWYodGhpcy5wdHMubGVuZ3RoIT09dC5wdHMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKylpZighdGhpcy5wdHNbZV0uZXF1YWxzMkQodC5wdHNbZV0pKXJldHVybiExO3JldHVybiEwfXNldERlcHRoRGVsdGEodCl7dGhpcy5fZGVwdGhEZWx0YT10fWdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCl7cmV0dXJuIHRoaXMuZWlMaXN0fWFkZEludGVyc2VjdGlvbnModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl9fSxlcz1jbGFzcyBleHRlbmRzICRue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxlcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZD1udWxsLHRoaXMuX2VkZ2VzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmQ9dCx0aGlzLl9lZGdlcz1lLHRoaXMuX2xhYmVsPW5ldyBCbigwLFF0Lk5PTkUpfWlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKXtmb3IobGV0IHQ9dGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2lmKHQubmV4dCgpLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpcmV0dXJuITB9cmV0dXJuITF9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fY29vcmR9cHJpbnQodCl7dC5wcmludGxuKFwibm9kZSBcIit0aGlzLl9jb29yZCtcIiBsYmw6IFwiK3RoaXMuX2xhYmVsKX1jb21wdXRlSU0odCl7fWNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpe2xldCBuPVF0Lk5PTkU7aWYobj10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKSwhdC5pc051bGwoZSkpe2NvbnN0IHM9dC5nZXRMb2NhdGlvbihlKTtuIT09UXQuQk9VTkRBUlkmJihuPXMpfXJldHVybiBufXNldExhYmVsKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSl8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpcmV0dXJuIHN1cGVyLnNldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMuX2xhYmVsP3RoaXMuX2xhYmVsPW5ldyBCbih0LGUpOnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSl9fWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfW1lcmdlTGFiZWwoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVzKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodC5fbGFiZWwpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCbil7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTwyO2UrKyl7Y29uc3Qgbj10aGlzLmNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpO3RoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUpPT09UXQuTk9ORSYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oZSxuKX19fWFkZCh0KXt0aGlzLl9lZGdlcy5pbnNlcnQodCksdC5zZXROb2RlKHRoaXMpfXNldExhYmVsQm91bmRhcnkodCl7aWYobnVsbD09PXRoaXMuX2xhYmVsKXJldHVybiBudWxsO2xldCBlPVF0Lk5PTkU7bnVsbCE9PXRoaXMuX2xhYmVsJiYoZT10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbih0KSk7bGV0IG49bnVsbDtzd2l0Y2goZSl7Y2FzZSBRdC5CT1VOREFSWTpuPVF0LklOVEVSSU9SO2JyZWFrO2Nhc2UgUXQuSU5URVJJT1I6ZGVmYXVsdDpuPVF0LkJPVU5EQVJZfXRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsbil9fSxucz1jbGFzc3tjb25zdHJ1Y3Rvcigpe25zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMubm9kZU1hcD1uZXcgV24sdGhpcy5ub2RlRmFjdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUZhY3Q9dH1maW5kKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfWFkZE5vZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPXRoaXMubm9kZU1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1lJiYoZT10aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUodCksdGhpcy5ub2RlTWFwLnB1dCh0LGUpKSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZXMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5ub2RlTWFwLmdldCh0LmdldENvb3JkaW5hdGUoKSk7cmV0dXJuIG51bGw9PT1lPyh0aGlzLm5vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHQpOihlLm1lcmdlTGFiZWwodCksZSl9fXByaW50KHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX1nZXRCb3VuZGFyeU5vZGVzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpPT09UXQuQk9VTkRBUlkmJmUuYWRkKHMpfXJldHVybiBlfWFkZCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuYWRkTm9kZShlKS5hZGQodCl9fTtjbGFzcyBzc3tjb25zdHJ1Y3Rvcigpe3NzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2VkZ2U9bnVsbCx0aGlzLl9sYWJlbD1udWxsLHRoaXMuX25vZGU9bnVsbCx0aGlzLl9wMD1udWxsLHRoaXMuX3AxPW51bGwsdGhpcy5fZHg9bnVsbCx0aGlzLl9keT1udWxsLHRoaXMuX3F1YWRyYW50PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2U9dH1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtzcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLG51bGwpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3NzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCksdGhpcy5pbml0KGUsbiksdGhpcy5fbGFiZWw9c319Y29tcGFyZURpcmVjdGlvbih0KXtyZXR1cm4gdGhpcy5fZHg9PT10Ll9keCYmdGhpcy5fZHk9PT10Ll9keT8wOnRoaXMuX3F1YWRyYW50PnQuX3F1YWRyYW50PzE6dGhpcy5fcXVhZHJhbnQ8dC5fcXVhZHJhbnQ/LTE6cS5pbmRleCh0Ll9wMCx0Ll9wMSx0aGlzLl9wMSl9Z2V0RHkoKXtyZXR1cm4gdGhpcy5fZHl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wMH1zZXROb2RlKHQpe3RoaXMuX25vZGU9dH1wcmludCh0KXtjb25zdCBlPU1hdGguYXRhbjIodGhpcy5fZHksdGhpcy5fZHgpLG49dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxzPW4ubGFzdEluZGV4T2YoXCIuXCIpLGk9bi5zdWJzdHJpbmcocysxKTt0LnByaW50KFwiICBcIitpK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK2UrXCIgICBcIit0aGlzLl9sYWJlbCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpfWdldERpcmVjdGVkQ29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wMX1nZXREeCgpe3JldHVybiB0aGlzLl9keH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9Z2V0UXVhZHJhbnQoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnR9Z2V0Tm9kZSgpe3JldHVybiB0aGlzLl9ub2RlfXRvU3RyaW5nKCl7Y29uc3QgdD1NYXRoLmF0YW4yKHRoaXMuX2R5LHRoaXMuX2R4KSxlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKTtyZXR1cm5cIiAgXCIrZS5zdWJzdHJpbmcobisxKStcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIit0K1wiICAgXCIrdGhpcy5fbGFiZWx9Y29tcHV0ZUxhYmVsKHQpe31pbml0KHQsZSl7dGhpcy5fcDA9dCx0aGlzLl9wMT1lLHRoaXMuX2R4PWUueC10LngsdGhpcy5fZHk9ZS55LXQueSx0aGlzLl9xdWFkcmFudD1Dbi5xdWFkcmFudCh0aGlzLl9keCx0aGlzLl9keSksZy5pc1RydWUoISgwPT09dGhpcy5fZHgmJjA9PT10aGlzLl9keSksXCJFZGdlRW5kIHdpdGggaWRlbnRpY2FsIGVuZHBvaW50cyBmb3VuZFwiKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIGlzIGV4dGVuZHMgaHtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKGU/dCtcIiBbIFwiK2UrXCIgXVwiOnQpLHRoaXMucHQ9ZT9uZXcgbShlKTp2b2lkIDAsdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtUb3BvbG9neUV4Y2VwdGlvbjppc30pWzBdfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5wdH19bGV0IHJzPWNsYXNzIGV4dGVuZHMgc3N7Y29uc3RydWN0b3IoKXtzdXBlcigpLHJzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRm9yd2FyZD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9uZXh0TWluPW51bGwsdGhpcy5fZWRnZVJpbmc9bnVsbCx0aGlzLl9taW5FZGdlUmluZz1udWxsLHRoaXMuX2RlcHRoPVswLC05OTksLTk5OV07Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoc3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLl9pc0ZvcndhcmQ9ZSxlKXRoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUoMCksdC5nZXRDb29yZGluYXRlKDEpKTtlbHNle2NvbnN0IGU9dC5nZXROdW1Qb2ludHMoKS0xO3RoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUoZSksdC5nZXRDb29yZGluYXRlKGUtMSkpfXRoaXMuY29tcHV0ZURpcmVjdGVkTGFiZWwoKX1zdGF0aWMgZGVwdGhGYWN0b3IodCxlKXtyZXR1cm4gdD09PVF0LkVYVEVSSU9SJiZlPT09UXQuSU5URVJJT1I/MTp0PT09UXQuSU5URVJJT1ImJmU9PT1RdC5FWFRFUklPUj8tMTowfWdldE5leHRNaW4oKXtyZXR1cm4gdGhpcy5fbmV4dE1pbn1nZXREZXB0aCh0KXtyZXR1cm4gdGhpcy5fZGVwdGhbdF19c2V0VmlzaXRlZCh0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH1jb21wdXRlRGlyZWN0ZWRMYWJlbCgpe3RoaXMuX2xhYmVsPW5ldyBCbih0aGlzLl9lZGdlLmdldExhYmVsKCkpLHRoaXMuX2lzRm9yd2FyZHx8dGhpcy5fbGFiZWwuZmxpcCgpfWdldE5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1zZXREZXB0aCh0LGUpe2lmKC05OTkhPT10aGlzLl9kZXB0aFt0XSYmdGhpcy5fZGVwdGhbdF0hPT1lKXRocm93IG5ldyBpcyhcImFzc2lnbmVkIGRlcHRocyBkbyBub3QgbWF0Y2hcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7dGhpcy5fZGVwdGhbdF09ZX1pc0ludGVyaW9yQXJlYUVkZ2UoKXtsZXQgdD0hMDtmb3IobGV0IGU9MDtlPDI7ZSsrKXRoaXMuX2xhYmVsLmlzQXJlYShlKSYmdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSxibi5MRUZUKT09PVF0LklOVEVSSU9SJiZ0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlLGJuLlJJR0hUKT09PVF0LklOVEVSSU9SfHwodD0hMSk7cmV0dXJuIHR9c2V0TmV4dE1pbih0KXt0aGlzLl9uZXh0TWluPXR9cHJpbnQodCl7c3VwZXIucHJpbnQuY2FsbCh0aGlzLHQpLHQucHJpbnQoXCIgXCIrdGhpcy5fZGVwdGhbYm4uTEVGVF0rXCIvXCIrdGhpcy5fZGVwdGhbYm4uUklHSFRdKSx0LnByaW50KFwiIChcIit0aGlzLmdldERlcHRoRGVsdGEoKStcIilcIiksdGhpcy5faXNJblJlc3VsdCYmdC5wcmludChcIiBpblJlc3VsdFwiKX1zZXRNaW5FZGdlUmluZyh0KXt0aGlzLl9taW5FZGdlUmluZz10fWlzTGluZUVkZ2UoKXtjb25zdCB0PXRoaXMuX2xhYmVsLmlzTGluZSgwKXx8dGhpcy5fbGFiZWwuaXNMaW5lKDEpLGU9IXRoaXMuX2xhYmVsLmlzQXJlYSgwKXx8dGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMCxRdC5FWFRFUklPUiksbj0hdGhpcy5fbGFiZWwuaXNBcmVhKDEpfHx0aGlzLl9sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgxLFF0LkVYVEVSSU9SKTtyZXR1cm4gdCYmZSYmbn1zZXRFZGdlUmluZyh0KXt0aGlzLl9lZGdlUmluZz10fWdldE1pbkVkZ2VSaW5nKCl7cmV0dXJuIHRoaXMuX21pbkVkZ2VSaW5nfWdldERlcHRoRGVsdGEoKXtsZXQgdD10aGlzLl9lZGdlLmdldERlcHRoRGVsdGEoKTtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfHwodD0tdCksdH1zZXRJblJlc3VsdCh0KXt0aGlzLl9pc0luUmVzdWx0PXR9Z2V0U3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1pc0ZvcndhcmQoKXtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1wcmludEVkZ2UodCl7dGhpcy5wcmludCh0KSx0LnByaW50KFwiIFwiKSx0aGlzLl9pc0ZvcndhcmQ/dGhpcy5fZWRnZS5wcmludCh0KTp0aGlzLl9lZGdlLnByaW50UmV2ZXJzZSh0KX1zZXRTeW0odCl7dGhpcy5fc3ltPXR9c2V0VmlzaXRlZEVkZ2UodCl7dGhpcy5zZXRWaXNpdGVkKHQpLHRoaXMuX3N5bS5zZXRWaXNpdGVkKHQpfXNldEVkZ2VEZXB0aHModCxlKXtsZXQgbj10aGlzLmdldEVkZ2UoKS5nZXREZXB0aERlbHRhKCk7dGhpcy5faXNGb3J3YXJkfHwobj0tbik7bGV0IHM9MTt0PT09Ym4uTEVGVCYmKHM9LTEpO2NvbnN0IGk9Ym4ub3Bwb3NpdGUodCkscj1lK24qczt0aGlzLnNldERlcHRoKHQsZSksdGhpcy5zZXREZXB0aChpLHIpfWdldEVkZ2VSaW5nKCl7cmV0dXJuIHRoaXMuX2VkZ2VSaW5nfWlzSW5SZXN1bHQoKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfX07Y2xhc3Mgb3N7Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IGVzKHQsbnVsbCl9fWxldCBscz1jbGFzc3tjb25zdHJ1Y3Rvcigpe2xzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2VkZ2VzPW5ldyBMLHRoaXMuX25vZGVzPW51bGwsdGhpcy5fZWRnZUVuZExpc3Q9bmV3IEwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbm9kZXM9bmV3IG5zKG5ldyBvcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbm9kZXM9bmV3IG5zKHQpfX1zdGF0aWMgbGlua1Jlc3VsdERpcmVjdGVkRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19cHJpbnRFZGdlcyh0KXt0LnByaW50bG4oXCJFZGdlczpcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlcy5zaXplKCk7ZSsrKXt0LnByaW50bG4oXCJlZGdlIFwiK2UrXCI6XCIpO2NvbnN0IG49dGhpcy5fZWRnZXMuZ2V0KGUpO24ucHJpbnQodCksbi5laUxpc3QucHJpbnQodCl9fWZpbmQodCl7cmV0dXJuIHRoaXMuX25vZGVzLmZpbmQodCl9YWRkTm9kZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZXMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUodCl9fWdldE5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpfWxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fWRlYnVnUHJpbnRsbih0KXtZLm91dC5wcmludGxuKHQpfWlzQm91bmRhcnlOb2RlKHQsZSl7Y29uc3Qgbj10aGlzLl9ub2Rlcy5maW5kKGUpO2lmKG51bGw9PT1uKXJldHVybiExO2NvbnN0IHM9bi5nZXRMYWJlbCgpO3JldHVybiBudWxsIT09cyYmcy5nZXRMb2NhdGlvbih0KT09PVF0LkJPVU5EQVJZfWxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl9fW1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxuLHMpe3JldHVybiEhdC5lcXVhbHMobikmJihxLmluZGV4KHQsZSxzKT09PXEuQ09MTElORUFSJiZDbi5xdWFkcmFudCh0LGUpPT09Q24ucXVhZHJhbnQobixzKSl9Z2V0RWRnZUVuZHMoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZExpc3R9ZGVidWdQcmludCh0KXtZLm91dC5wcmludCh0KX1nZXRFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1maW5kRWRnZUluU2FtZURpcmVjdGlvbih0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5fZWRnZXMuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLl9lZGdlcy5nZXQobiksaT1zLmdldENvb3JkaW5hdGVzKCk7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsaVswXSxpWzFdKSlyZXR1cm4gcztpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxpW2kubGVuZ3RoLTFdLGlbaS5sZW5ndGgtMl0pKXJldHVybiBzfXJldHVybiBudWxsfWluc2VydEVkZ2UodCl7dGhpcy5fZWRnZXMuYWRkKHQpfWZpbmRFZGdlRW5kKHQpe2ZvcihsZXQgZT10aGlzLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobi5nZXRFZGdlKCk9PT10KXJldHVybiBufXJldHVybiBudWxsfWFkZEVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuX2VkZ2VzLmFkZCh0KTtjb25zdCBuPW5ldyBycyh0LCEwKSxzPW5ldyBycyh0LCExKTtuLnNldFN5bShzKSxzLnNldFN5bShuKSx0aGlzLmFkZChuKSx0aGlzLmFkZChzKX19YWRkKHQpe3RoaXMuX25vZGVzLmFkZCh0KSx0aGlzLl9lZGdlRW5kTGlzdC5hZGQodCl9Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZXMudmFsdWVzKCl9ZmluZEVkZ2UodCxlKXtmb3IobGV0IG49MDtuPHRoaXMuX2VkZ2VzLnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5fZWRnZXMuZ2V0KG4pLGk9cy5nZXRDb29yZGluYXRlcygpO2lmKHQuZXF1YWxzKGlbMF0pJiZlLmVxdWFscyhpWzFdKSlyZXR1cm4gc31yZXR1cm4gbnVsbH19O2NsYXNzIGFzIGV4dGVuZHMgbHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLGFzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BhcmVudEdlb209bnVsbCx0aGlzLl9saW5lRWRnZU1hcD1uZXcgTnQsdGhpcy5fYm91bmRhcnlOb2RlUnVsZT1udWxsLHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITAsdGhpcy5fYXJnSW5kZXg9bnVsbCx0aGlzLl9ib3VuZGFyeU5vZGVzPW51bGwsdGhpcy5faGFzVG9vRmV3UG9pbnRzPSExLHRoaXMuX2ludmFsaWRQb2ludD1udWxsLHRoaXMuX2FyZWFQdExvY2F0b3I9bnVsbCx0aGlzLl9wdExvY2F0b3I9bmV3IGZuLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxnbi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2FyZ0luZGV4PXQsdGhpcy5fcGFyZW50R2VvbT1lLHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGU9bixudWxsIT09ZSYmdGhpcy5hZGQoZSl9fXN0YXRpYyBkZXRlcm1pbmVCb3VuZGFyeSh0LGUpe3JldHVybiB0LmlzSW5Cb3VuZGFyeShlKT9RdC5CT1VOREFSWTpRdC5JTlRFUklPUn1pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSl7Y29uc3Qgbj10aGlzLl9ub2Rlcy5hZGROb2RlKGUpLmdldExhYmVsKCk7bGV0IHM9MSxpPVF0Lk5PTkU7aT1uLmdldExvY2F0aW9uKHQsYm4uT04pLGk9PT1RdC5CT1VOREFSWSYmcysrO2NvbnN0IHI9YXMuZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5fYm91bmRhcnlOb2RlUnVsZSxzKTtuLnNldExvY2F0aW9uKHQscil9Y29tcHV0ZVNlbGZOb2Rlcygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wdXRlU2VsZk5vZGVzKHQsZSwhMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49bmV3IEZuKGFyZ3VtZW50c1swXSwhMCwhMSk7bi5zZXRJc0RvbmVJZlByb3BlckludChlKTtjb25zdCBzPXRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCksaT10aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgZ3R8fHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBydHx8dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIHl0LHI9dHx8IWk7cmV0dXJuIHMuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsbixyKSx0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLl9hcmdJbmRleCksbn19Y29tcHV0ZVNwbGl0RWRnZXModCl7Zm9yKGxldCBlPXRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5laUxpc3QuYWRkU3BsaXRFZGdlcyh0KX19Y29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHQsZSxuKXtjb25zdCBzPW5ldyBGbihlLG4sITApO3Muc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSx0LmdldEJvdW5kYXJ5Tm9kZXMoKSk7cmV0dXJuIHRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCkuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsdC5fZWRnZXMscyksc31nZXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9wYXJlbnRHZW9tfWdldEJvdW5kYXJ5Tm9kZVJ1bGUoKXtyZXR1cm4gdGhpcy5fYm91bmRhcnlOb2RlUnVsZX1oYXNUb29GZXdQb2ludHMoKXtyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzfWFkZFBvaW50KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBldCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxRdC5JTlRFUklPUil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxRdC5JTlRFUklPUil9fWFkZFBvbHlnb24odCl7dGhpcy5hZGRQb2x5Z29uUmluZyh0LmdldEV4dGVyaW9yUmluZygpLFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBuPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTt0aGlzLmFkZFBvbHlnb25SaW5nKG4sUXQuSU5URVJJT1IsUXQuRVhURVJJT1IpfX1hZGRFZGdlKHQpe3RoaXMuaW5zZXJ0RWRnZSh0KTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LGVbMF0sUXQuQk9VTkRBUlkpLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSxRdC5CT1VOREFSWSl9YWRkTGluZVN0cmluZyh0KXtjb25zdCBlPV90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuX2ludmFsaWRQb2ludD1lWzBdLG51bGw7Y29uc3Qgbj1uZXcgdHMoZSxuZXcgQm4odGhpcy5fYXJnSW5kZXgsUXQuSU5URVJJT1IpKTt0aGlzLl9saW5lRWRnZU1hcC5wdXQodCxuKSx0aGlzLmluc2VydEVkZ2UobiksZy5pc1RydWUoZS5sZW5ndGg+PTIsXCJmb3VuZCBMaW5lU3RyaW5nIHdpdGggc2luZ2xlIHBvaW50XCIpLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCxlWzBdKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSl9Z2V0SW52YWxpZFBvaW50KCl7cmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludH1nZXRCb3VuZGFyeVBvaW50cygpe2NvbnN0IHQ9dGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7bGV0IG49MDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtlW24rK109dC5nZXRDb29yZGluYXRlKCkuY29weSgpfXJldHVybiBlfWdldEJvdW5kYXJ5Tm9kZXMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2JvdW5kYXJ5Tm9kZXMmJih0aGlzLl9ib3VuZGFyeU5vZGVzPXRoaXMuX25vZGVzLmdldEJvdW5kYXJ5Tm9kZXModGhpcy5fYXJnSW5kZXgpKSx0aGlzLl9ib3VuZGFyeU5vZGVzfWFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQsZSxuKXtpZih0aGlzLmlzQm91bmRhcnlOb2RlKHQsZSkpcmV0dXJuIG51bGw7bj09PVF0LkJPVU5EQVJZJiZ0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlP3RoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpOnRoaXMuaW5zZXJ0UG9pbnQodCxlLG4pfWFkZFBvbHlnb25SaW5nKHQsZSxuKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBzPV90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYocy5sZW5ndGg8NClyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuX2ludmFsaWRQb2ludD1zWzBdLG51bGw7bGV0IGk9ZSxyPW47cS5pc0NDVyhzKSYmKGk9bixyPWUpO2NvbnN0IG89bmV3IHRzKHMsbmV3IEJuKHRoaXMuX2FyZ0luZGV4LFF0LkJPVU5EQVJZLGkscikpO3RoaXMuX2xpbmVFZGdlTWFwLnB1dCh0LG8pLHRoaXMuaW5zZXJ0RWRnZShvKSx0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHNbMF0sUXQuQk9VTkRBUlkpfWluc2VydFBvaW50KHQsZSxuKXtjb25zdCBzPXRoaXMuX25vZGVzLmFkZE5vZGUoZSksaT1zLmdldExhYmVsKCk7bnVsbD09PWk/cy5fbGFiZWw9bmV3IEJuKHQsbik6aS5zZXRMb2NhdGlvbih0LG4pfWNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3Rvcigpe3JldHVybiBuZXcgR259YWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5laUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSh0LG4uY29vcmQscyl9fX1hZGQoKXtpZighKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpKXJldHVybiBzdXBlci5hZGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgeXQmJih0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSExKSx0IGluc3RhbmNlb2YgcnQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mICQpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGV0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgdXQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB5dCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBodCkpdGhyb3cgbmV3IEsodC5nZXRHZW9tZXRyeVR5cGUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX19YWRkQ29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19bG9jYXRlKHQpe3JldHVybiBJKHRoaXMuX3BhcmVudEdlb20saXQpJiZ0aGlzLl9wYXJlbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKT41MD8obnVsbD09PXRoaXMuX2FyZWFQdExvY2F0b3ImJih0aGlzLl9hcmVhUHRMb2NhdG9yPW5ldyB6ZSh0aGlzLl9wYXJlbnRHZW9tKSksdGhpcy5fYXJlYVB0TG9jYXRvci5sb2NhdGUodCkpOnRoaXMuX3B0TG9jYXRvci5sb2NhdGUodCx0aGlzLl9wYXJlbnRHZW9tKX1maW5kRWRnZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9saW5lRWRnZU1hcC5nZXQodCl9cmV0dXJuIHN1cGVyLmZpbmRFZGdlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIGNzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5R3JhcGg6YXN9KTtjbGFzcyBoc3t2aXNpdCh0KXt9fWNsYXNzIHVze2NvbnN0cnVjdG9yKCl7dXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcD1udWxsLHRoaXMuX2RhdGE9bnVsbCx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPW5ldyBtKHQpLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PTEsdGhpcy5fZGF0YT1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3A9bmV3IG0odCxlKSx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD0xLHRoaXMuX2RhdGE9bn19aXNSZXBlYXRlZCgpe3JldHVybiB0aGlzLl9jb3VudD4xfWdldFJpZ2h0KCl7cmV0dXJuIHRoaXMuX3JpZ2h0fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcH1zZXRMZWZ0KHQpe3RoaXMuX2xlZnQ9dH1nZXRYKCl7cmV0dXJuIHRoaXMuX3AueH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fY291bnR9Z2V0TGVmdCgpe3JldHVybiB0aGlzLl9sZWZ0fWdldFkoKXtyZXR1cm4gdGhpcy5fcC55fWluY3JlbWVudCgpe3RoaXMuX2NvdW50PXRoaXMuX2NvdW50KzF9c2V0UmlnaHQodCl7dGhpcy5fcmlnaHQ9dH19Y2xhc3MgZ3N7Y29uc3RydWN0b3IoKXtncy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9yb290PW51bGwsdGhpcy5fbnVtYmVyT2ZOb2Rlcz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWdzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fdG9sZXJhbmNlPXR9fXN0YXRpYyB0b0Nvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBncy50b0Nvb3JkaW5hdGVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBSO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9ZT90LmdldENvdW50KCk6MTtmb3IobGV0IGU9MDtlPGk7ZSsrKW4uYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpLCEwKX1yZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfX1pbnNlcnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5zZXJ0KHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKG51bGw9PT10aGlzLl9yb290KXJldHVybiB0aGlzLl9yb290PW5ldyB1cyh0LGUpLHRoaXMuX3Jvb3Q7aWYodGhpcy5fdG9sZXJhbmNlPjApe2NvbnN0IGU9dGhpcy5maW5kQmVzdE1hdGNoTm9kZSh0KTtpZihudWxsIT09ZSlyZXR1cm4gZS5pbmNyZW1lbnQoKSxlfXJldHVybiB0aGlzLmluc2VydEV4YWN0KHQsZSl9fXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyYmSShhcmd1bWVudHNbMV0sQykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMuX3Jvb3QsdCwhMCxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2hzXX12aXNpdCh0KXtlLmFkZCh0KX19KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyYmSShhcmd1bWVudHNbMV0saHMpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLl9yb290LHQsITAsZSl9fXF1ZXJ5Tm9kZSh0LGUsbixzKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtsZXQgaT1udWxsLHI9bnVsbCxvPW51bGw7bj8oaT1lLmdldE1pblgoKSxyPWUuZ2V0TWF4WCgpLG89dC5nZXRYKCkpOihpPWUuZ2V0TWluWSgpLHI9ZS5nZXRNYXhZKCksbz10LmdldFkoKSk7Y29uc3QgbD1vPD1yO2k8byYmdGhpcy5xdWVyeU5vZGUodC5nZXRMZWZ0KCksZSwhbixzKSxlLmNvbnRhaW5zKHQuZ2V0Q29vcmRpbmF0ZSgpKSYmcy52aXNpdCh0KSxsJiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldFJpZ2h0KCksZSwhbixzKX1maW5kQmVzdE1hdGNoTm9kZSh0KXtjb25zdCBlPW5ldyBkcyh0LHRoaXMuX3RvbGVyYW5jZSk7cmV0dXJuIHRoaXMucXVlcnkoZS5xdWVyeUVudmVsb3BlKCksZSksZS5nZXROb2RlKCl9aXNFbXB0eSgpe3JldHVybiBudWxsPT09dGhpcy5fcm9vdH1pbnNlcnRFeGFjdCh0LGUpe2xldCBuPXRoaXMuX3Jvb3Qscz10aGlzLl9yb290LGk9ITAscj0hMDtmb3IoO251bGwhPT1uOyl7aWYobnVsbCE9PW4pe2lmKHQuZGlzdGFuY2Uobi5nZXRDb29yZGluYXRlKCkpPD10aGlzLl90b2xlcmFuY2UpcmV0dXJuIG4uaW5jcmVtZW50KCksbn1yPWk/dC54PG4uZ2V0WCgpOnQueTxuLmdldFkoKSxzPW4sbj1yP24uZ2V0TGVmdCgpOm4uZ2V0UmlnaHQoKSxpPSFpfXRoaXMuX251bWJlck9mTm9kZXM9dGhpcy5fbnVtYmVyT2ZOb2RlcysxO2NvbnN0IG89bmV3IHVzKHQsZSk7cmV0dXJuIHI/cy5zZXRMZWZ0KG8pOnMuc2V0UmlnaHQobyksb319Y2xhc3MgZHN7Y29uc3RydWN0b3IoKXtkcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90b2xlcmFuY2U9bnVsbCx0aGlzLl9tYXRjaE5vZGU9bnVsbCx0aGlzLl9tYXRjaERpc3Q9MCx0aGlzLl9wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD10LHRoaXMuX3RvbGVyYW5jZT1lfXZpc2l0KHQpe2NvbnN0IGU9dGhpcy5fcC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSk7aWYoIShlPD10aGlzLl90b2xlcmFuY2UpKXJldHVybiBudWxsO2xldCBuPSExOyhudWxsPT09dGhpcy5fbWF0Y2hOb2RlfHxlPHRoaXMuX21hdGNoRGlzdHx8bnVsbCE9PXRoaXMuX21hdGNoTm9kZSYmZT09PXRoaXMuX21hdGNoRGlzdCYmdC5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuX21hdGNoTm9kZS5nZXRDb29yZGluYXRlKCkpPDEpJiYobj0hMCksbiYmKHRoaXMuX21hdGNoTm9kZT10LHRoaXMuX21hdGNoRGlzdD1lKX1xdWVyeUVudmVsb3BlKCl7Y29uc3QgdD1uZXcgTyh0aGlzLl9wKTtyZXR1cm4gdC5leHBhbmRCeSh0aGlzLl90b2xlcmFuY2UpLHR9Z2V0Tm9kZSgpe3JldHVybiB0aGlzLl9tYXRjaE5vZGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2hzXX19Z3MuQmVzdE1hdGNoVmlzaXRvcj1kczt2YXIgX3M9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsS2RUcmVlOmdzfSk7Y2xhc3MgcHN7Y29uc3RydWN0b3IoKXtwcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pdGVtcz1uZXcgTCx0aGlzLl9zdWJub2RlPW5ldyBBcnJheSg0KS5maWxsKG51bGwpfXN0YXRpYyBnZXRTdWJub2RlSW5kZXgodCxlLG4pe2xldCBzPS0xO3JldHVybiB0LmdldE1pblgoKT49ZSYmKHQuZ2V0TWluWSgpPj1uJiYocz0zKSx0LmdldE1heFkoKTw9biYmKHM9MSkpLHQuZ2V0TWF4WCgpPD1lJiYodC5nZXRNaW5ZKCk+PW4mJihzPTIpLHQuZ2V0TWF4WSgpPD1uJiYocz0wKSksc31oYXNDaGlsZHJlbigpe2ZvcihsZXQgdD0wO3Q8NDt0KyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbdF0pcmV0dXJuITA7cmV0dXJuITF9aXNQcnVuYWJsZSgpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfWFkZEFsbEl0ZW1zKHQpe3QuYWRkQWxsKHRoaXMuX2l0ZW1zKTtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiZ0aGlzLl9zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fWdldE5vZGVDb3VudCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmKHQrPXRoaXMuX3N1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCsxfXNpemUoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJih0Kz10aGlzLl9zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5faXRlbXMuc2l6ZSgpfWFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDtlLmFkZEFsbCh0aGlzLl9pdGVtcyk7Zm9yKGxldCBuPTA7bjw0O24rKyludWxsIT09dGhpcy5fc3Vibm9kZVtuXSYmdGhpcy5fc3Vibm9kZVtuXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpfXZpc2l0SXRlbXModCxlKXtmb3IobGV0IHQ9dGhpcy5faXRlbXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspZS52aXNpdEl0ZW0odC5uZXh0KCkpfWhhc0l0ZW1zKCl7cmV0dXJuIXRoaXMuX2l0ZW1zLmlzRW1wdHkoKX1yZW1vdmUodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2xldCBuPSExO2ZvcihsZXQgcz0wO3M8NDtzKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbc10mJihuPXRoaXMuX3N1Ym5vZGVbc10ucmVtb3ZlKHQsZSksbikpe3RoaXMuX3N1Ym5vZGVbc10uaXNQcnVuYWJsZSgpJiYodGhpcy5fc3Vibm9kZVtzXT1udWxsKTticmVha31yZXR1cm4gbnx8KG49dGhpcy5faXRlbXMucmVtb3ZlKGUpLG4pfXZpc2l0KHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDt0aGlzLnZpc2l0SXRlbXModCxlKTtmb3IobGV0IG49MDtuPDQ7bisrKW51bGwhPT10aGlzLl9zdWJub2RlW25dJiZ0aGlzLl9zdWJub2RlW25dLnZpc2l0KHQsZSl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9ZGVwdGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0pe2NvbnN0IG49dGhpcy5fc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX1pc0VtcHR5KCl7bGV0IHQ9ITA7aWYodGhpcy5faXRlbXMuaXNFbXB0eSgpKXtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYhdGhpcy5fc3Vibm9kZVtlXS5pc0VtcHR5KCkpe3Q9ITE7YnJlYWt9fWVsc2UgdD0hMTtyZXR1cm4gdH1hZGQodCl7dGhpcy5faXRlbXMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjXX19ZnVuY3Rpb24gbXMoKXt9bXMuZXhwb25lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7bGV0IG4scyxpLHI7Y29uc3Qgbz17MzI6e2Q6MTI3LGM6MTI4LGI6MCxhOjB9LDY0OntkOjMyNzUyLGM6MCxiOjAsYTowfX0sbD17MzI6OCw2NDoxMX1bdF07cnx8KG49ZTwwfHwxL2U8MCxpc0Zpbml0ZShlKXx8KHI9b1t0XSxuJiYoci5kKz0xPDx0LzQtMSkscz1NYXRoLnBvdygyLGwpLTEsaT0wKSk7aWYoIXIpe2ZvcihzPXszMjoxMjcsNjQ6MTAyM31bdF0saT1NYXRoLmFicyhlKTtpPj0yOylzKyssaS89Mjtmb3IoO2k8MSYmcz4wOylzLS0saSo9MjtzPD0wJiYoaS89MiksMzI9PT10JiZzPjI1NCYmKHI9e2Q6bj8yNTU6MTI3LGM6MTI4LGI6MCxhOjB9LHM9TWF0aC5wb3coMixsKS0xLGk9MCl9cmV0dXJuIHN9KDY0LHQpLTEwMjN9LG1zLnBvd2VyT2YyPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQpfTtjbGFzcyBmc3tjb25zdHJ1Y3Rvcigpe2ZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0PW5ldyBtLHRoaXMuX2xldmVsPTAsdGhpcy5fZW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfXN0YXRpYyBjb21wdXRlUXVhZExldmVsKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKSxzPWU+bj9lOm47cmV0dXJuIG1zLmV4cG9uZW50KHMpKzF9Z2V0TGV2ZWwoKXtyZXR1cm4gdGhpcy5fbGV2ZWx9Y29tcHV0ZUtleSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IodGhpcy5fbGV2ZWw9ZnMuY29tcHV0ZVF1YWRMZXZlbCh0KSx0aGlzLl9lbnY9bmV3IE8sdGhpcy5jb21wdXRlS2V5KHRoaXMuX2xldmVsLHQpOyF0aGlzLl9lbnYuY29udGFpbnModCk7KXRoaXMuX2xldmVsKz0xLHRoaXMuY29tcHV0ZUtleSh0aGlzLl9sZXZlbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW1zLnBvd2VyT2YyKHQpO3RoaXMuX3B0Lng9TWF0aC5mbG9vcihlLmdldE1pblgoKS9uKSpuLHRoaXMuX3B0Lnk9TWF0aC5mbG9vcihlLmdldE1pblkoKS9uKSpuLHRoaXMuX2Vudi5pbml0KHRoaXMuX3B0LngsdGhpcy5fcHQueCtuLHRoaXMuX3B0LnksdGhpcy5fcHQueStuKX19Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5fZW52fWdldENlbnRyZSgpe3JldHVybiBuZXcgbSgodGhpcy5fZW52LmdldE1pblgoKSt0aGlzLl9lbnYuZ2V0TWF4WCgpKS8yLCh0aGlzLl9lbnYuZ2V0TWluWSgpK3RoaXMuX2Vudi5nZXRNYXhZKCkpLzIpfWdldFBvaW50KCl7cmV0dXJuIHRoaXMuX3B0fX1sZXQgeXM9Y2xhc3MgZXh0ZW5kcyBwc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZW52PW51bGwsdGhpcy5fY2VudHJleD1udWxsLHRoaXMuX2NlbnRyZXk9bnVsbCx0aGlzLl9sZXZlbD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Vudj10LHRoaXMuX2xldmVsPWUsdGhpcy5fY2VudHJleD0odC5nZXRNaW5YKCkrdC5nZXRNYXhYKCkpLzIsdGhpcy5fY2VudHJleT0odC5nZXRNaW5ZKCkrdC5nZXRNYXhZKCkpLzJ9c3RhdGljIGNyZWF0ZU5vZGUodCl7Y29uc3QgZT1uZXcgZnModCk7cmV0dXJuIG5ldyB5cyhlLmdldEVudmVsb3BlKCksZS5nZXRMZXZlbCgpKX1zdGF0aWMgY3JlYXRlRXhwYW5kZWQodCxlKXtjb25zdCBuPW5ldyBPKGUpO251bGwhPT10JiZuLmV4cGFuZFRvSW5jbHVkZSh0Ll9lbnYpO2NvbnN0IHM9eXMuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJnMuaW5zZXJ0Tm9kZSh0KSxzfWZpbmQodCl7Y29uc3QgZT1wcy5nZXRTdWJub2RlSW5kZXgodCx0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKC0xPT09ZSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSl7cmV0dXJuIHRoaXMuX3N1Ym5vZGVbZV0uZmluZCh0KX1yZXR1cm4gdGhpc31pc1NlYXJjaE1hdGNoKHQpe3JldHVybiBudWxsIT09dCYmdGhpcy5fZW52LmludGVyc2VjdHModCl9Z2V0U3Vibm9kZSh0KXtyZXR1cm4gbnVsbD09PXRoaXMuX3N1Ym5vZGVbdF0mJih0aGlzLl9zdWJub2RlW3RdPXRoaXMuY3JlYXRlU3Vibm9kZSh0KSksdGhpcy5fc3Vibm9kZVt0XX1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLl9lbnZ9Z2V0Tm9kZSh0KXtjb25zdCBlPXBzLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYoLTEhPT1lKXtyZXR1cm4gdGhpcy5nZXRTdWJub2RlKGUpLmdldE5vZGUodCl9cmV0dXJuIHRoaXN9Y3JlYXRlU3Vibm9kZSh0KXtsZXQgZT0wLG49MCxzPTAsaT0wO3N3aXRjaCh0KXtjYXNlIDA6ZT10aGlzLl9lbnYuZ2V0TWluWCgpLG49dGhpcy5fY2VudHJleCxzPXRoaXMuX2Vudi5nZXRNaW5ZKCksaT10aGlzLl9jZW50cmV5O2JyZWFrO2Nhc2UgMTplPXRoaXMuX2NlbnRyZXgsbj10aGlzLl9lbnYuZ2V0TWF4WCgpLHM9dGhpcy5fZW52LmdldE1pblkoKSxpPXRoaXMuX2NlbnRyZXk7YnJlYWs7Y2FzZSAyOmU9dGhpcy5fZW52LmdldE1pblgoKSxuPXRoaXMuX2NlbnRyZXgscz10aGlzLl9jZW50cmV5LGk9dGhpcy5fZW52LmdldE1heFkoKTticmVhaztjYXNlIDM6ZT10aGlzLl9jZW50cmV4LG49dGhpcy5fZW52LmdldE1heFgoKSxzPXRoaXMuX2NlbnRyZXksaT10aGlzLl9lbnYuZ2V0TWF4WSgpfWNvbnN0IHI9bmV3IE8oZSxuLHMsaSk7cmV0dXJuIG5ldyB5cyhyLHRoaXMuX2xldmVsLTEpfWluc2VydE5vZGUodCl7Zy5pc1RydWUobnVsbD09PXRoaXMuX2Vudnx8dGhpcy5fZW52LmNvbnRhaW5zKHQuX2VudikpO2NvbnN0IGU9cHMuZ2V0U3Vibm9kZUluZGV4KHQuX2Vudix0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKHQuX2xldmVsPT09dGhpcy5fbGV2ZWwtMSl0aGlzLl9zdWJub2RlW2VdPXQ7ZWxzZXtjb25zdCBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydE5vZGUodCksdGhpcy5fc3Vibm9kZVtlXT1ufX19O2NsYXNzIHhze3N0YXRpYyBpc1plcm9XaWR0aCh0LGUpe2NvbnN0IG49ZS10O2lmKDA9PT1uKXJldHVybiEwO2NvbnN0IHM9bi9NYXRoLm1heChNYXRoLmFicyh0KSxNYXRoLmFicyhlKSk7cmV0dXJuIG1zLmV4cG9uZW50KHMpPD14cy5NSU5fQklOQVJZX0VYUE9ORU5UfX14cy5NSU5fQklOQVJZX0VYUE9ORU5UPS01MDtjbGFzcyBFcyBleHRlbmRzIHBze2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1pbnNlcnQodCxlKXtjb25zdCBuPXBzLmdldFN1Ym5vZGVJbmRleCh0LEVzLm9yaWdpbi54LEVzLm9yaWdpbi55KTtpZigtMT09PW4pcmV0dXJuIHRoaXMuYWRkKGUpLG51bGw7Y29uc3Qgcz10aGlzLl9zdWJub2RlW25dO2lmKG51bGw9PT1zfHwhcy5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKHQpKXtjb25zdCBlPXlzLmNyZWF0ZUV4cGFuZGVkKHMsdCk7dGhpcy5fc3Vibm9kZVtuXT1lfXRoaXMuaW5zZXJ0Q29udGFpbmVkKHRoaXMuX3N1Ym5vZGVbbl0sdCxlKX1pc1NlYXJjaE1hdGNoKHQpe3JldHVybiEwfWluc2VydENvbnRhaW5lZCh0LGUsbil7Zy5pc1RydWUodC5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKGUpKTtjb25zdCBzPXhzLmlzWmVyb1dpZHRoKGUuZ2V0TWluWCgpLGUuZ2V0TWF4WCgpKSxpPXhzLmlzWmVyb1dpZHRoKGUuZ2V0TWluWSgpLGUuZ2V0TWF4WSgpKTtsZXQgcj1udWxsO3I9c3x8aT90LmZpbmQoZSk6dC5nZXROb2RlKGUpLHIuYWRkKG4pfX1Fcy5vcmlnaW49bmV3IG0oMCwwKTtjbGFzcyBJc3tpbnNlcnQodCxlKXt9cmVtb3ZlKHQsZSl7fXF1ZXJ5KCl7fX1jbGFzcyBOc3tjb25zdHJ1Y3Rvcigpe05zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9taW5FeHRlbnQ9MSx0aGlzLl9yb290PW5ldyBFc31zdGF0aWMgZW5zdXJlRXh0ZW50KHQsZSl7bGV0IG49dC5nZXRNaW5YKCkscz10LmdldE1heFgoKSxpPXQuZ2V0TWluWSgpLHI9dC5nZXRNYXhZKCk7cmV0dXJuIG4hPT1zJiZpIT09cj90OihuPT09cyYmKG4tPWUvMixzKz1lLzIpLGk9PT1yJiYoaS09ZS8yLHIrPWUvMiksbmV3IE8obixzLGkscikpfXNpemUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3Jvb3Q/dGhpcy5fcm9vdC5zaXplKCk6MH1pbnNlcnQodCxlKXt0aGlzLmNvbGxlY3RTdGF0cyh0KTtjb25zdCBuPU5zLmVuc3VyZUV4dGVudCh0LHRoaXMuX21pbkV4dGVudCk7dGhpcy5fcm9vdC5pbnNlcnQobixlKX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBZZTtyZXR1cm4gdGhpcy5xdWVyeSh0LGUpLGUuZ2V0SXRlbXMoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcm9vdC52aXNpdCh0LGUpfX1xdWVyeUFsbCgpe2NvbnN0IHQ9bmV3IEw7cmV0dXJuIHRoaXMuX3Jvb3QuYWRkQWxsSXRlbXModCksdH1yZW1vdmUodCxlKXtjb25zdCBuPU5zLmVuc3VyZUV4dGVudCh0LHRoaXMuX21pbkV4dGVudCk7cmV0dXJuIHRoaXMuX3Jvb3QucmVtb3ZlKG4sZSl9Y29sbGVjdFN0YXRzKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5fbWluRXh0ZW50JiZlPjAmJih0aGlzLl9taW5FeHRlbnQ9ZSk7Y29uc3Qgbj10LmdldEhlaWdodCgpO248dGhpcy5fbWluRXh0ZW50JiZuPjAmJih0aGlzLl9taW5FeHRlbnQ9bil9ZGVwdGgoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3Jvb3Q/dGhpcy5fcm9vdC5kZXB0aCgpOjB9aXNFbXB0eSgpe3JldHVybiBudWxsPT09dGhpcy5fcm9vdHx8dGhpcy5fcm9vdC5pc0VtcHR5KCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0lzLGNdfX12YXIgd3M9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUXVhZHRyZWU6TnN9KTtjbGFzcyBDc3tnZXRCb3VuZHMoKXt9fWNsYXNzIFNze2NvbnN0cnVjdG9yKCl7U3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fYm91bmRzPW51bGwsdGhpcy5faXRlbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2JvdW5kcz10LHRoaXMuX2l0ZW09ZX1nZXRJdGVtKCl7cmV0dXJuIHRoaXMuX2l0ZW19Z2V0Qm91bmRzKCl7cmV0dXJuIHRoaXMuX2JvdW5kc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQ3MsY119fWNsYXNzIExze2NvbnN0cnVjdG9yKCl7THMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2l6ZT1udWxsLHRoaXMuX2l0ZW1zPW51bGwsdGhpcy5fc2l6ZT0wLHRoaXMuX2l0ZW1zPW5ldyBMLHRoaXMuX2l0ZW1zLmFkZChudWxsKX1wb2xsKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLl9pdGVtcy5nZXQoMSk7cmV0dXJuIHRoaXMuX2l0ZW1zLnNldCgxLHRoaXMuX2l0ZW1zLmdldCh0aGlzLl9zaXplKSksdGhpcy5fc2l6ZS09MSx0aGlzLnJlb3JkZXIoMSksdH1zaXplKCl7cmV0dXJuIHRoaXMuX3NpemV9cmVvcmRlcih0KXtsZXQgZT1udWxsO2NvbnN0IG49dGhpcy5faXRlbXMuZ2V0KHQpO2Zvcig7Mip0PD10aGlzLl9zaXplJiYoZT0yKnQsZSE9PXRoaXMuX3NpemUmJnRoaXMuX2l0ZW1zLmdldChlKzEpLmNvbXBhcmVUbyh0aGlzLl9pdGVtcy5nZXQoZSkpPDAmJmUrKyx0aGlzLl9pdGVtcy5nZXQoZSkuY29tcGFyZVRvKG4pPDApO3Q9ZSl0aGlzLl9pdGVtcy5zZXQodCx0aGlzLl9pdGVtcy5nZXQoZSkpO3RoaXMuX2l0ZW1zLnNldCh0LG4pfWNsZWFyKCl7dGhpcy5fc2l6ZT0wLHRoaXMuX2l0ZW1zLmNsZWFyKCl9cGVlaygpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3JldHVybiB0aGlzLl9pdGVtcy5nZXQoMSl9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fc2l6ZX1hZGQodCl7dGhpcy5faXRlbXMuYWRkKG51bGwpLHRoaXMuX3NpemUrPTE7bGV0IGU9dGhpcy5fc2l6ZTtmb3IodGhpcy5faXRlbXMuc2V0KDAsdCk7dC5jb21wYXJlVG8odGhpcy5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoZS8yKSkpPDA7ZS89Mil0aGlzLl9pdGVtcy5zZXQoZSx0aGlzLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk7dGhpcy5faXRlbXMuc2V0KGUsdCl9fWNsYXNzIFRze2NvbnN0cnVjdG9yKCl7VHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fY2hpbGRCb3VuZGFibGVzPW5ldyBMLHRoaXMuX2JvdW5kcz1udWxsLHRoaXMuX2xldmVsPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xldmVsPXR9fWdldExldmVsKCl7cmV0dXJuIHRoaXMuX2xldmVsfXNpemUoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLnNpemUoKX1nZXRDaGlsZEJvdW5kYWJsZXMoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzfWFkZENoaWxkQm91bmRhYmxlKHQpe2cuaXNUcnVlKG51bGw9PT10aGlzLl9ib3VuZHMpLHRoaXMuX2NoaWxkQm91bmRhYmxlcy5hZGQodCl9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpfWdldEJvdW5kcygpe3JldHVybiBudWxsPT09dGhpcy5fYm91bmRzJiYodGhpcy5fYm91bmRzPXRoaXMuY29tcHV0ZUJvdW5kcygpKSx0aGlzLl9ib3VuZHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NzLGNdfX1jbGFzcyBSc3tzdGF0aWMgbWF4RGlzdGFuY2UodCxlLG4scyxpLHIsbyxsKXtsZXQgYT1Scy5kaXN0YW5jZSh0LGUsaSxyKTtyZXR1cm4gYT1NYXRoLm1heChhLFJzLmRpc3RhbmNlKHQsZSxvLGwpKSxhPU1hdGgubWF4KGEsUnMuZGlzdGFuY2UobixzLGkscikpLGE9TWF0aC5tYXgoYSxScy5kaXN0YW5jZShuLHMsbyxsKSksYX1zdGF0aWMgZGlzdGFuY2UodCxlLG4scyl7Y29uc3QgaT1uLXQscj1zLWU7cmV0dXJuIE1hdGguc3FydChpKmkrcipyKX1zdGF0aWMgbWF4aW11bURpc3RhbmNlKHQsZSl7Y29uc3Qgbj1NYXRoLm1pbih0LmdldE1pblgoKSxlLmdldE1pblgoKSkscz1NYXRoLm1pbih0LmdldE1pblkoKSxlLmdldE1pblkoKSksaT1NYXRoLm1heCh0LmdldE1heFgoKSxlLmdldE1heFgoKSkscj1NYXRoLm1heCh0LmdldE1heFkoKSxlLmdldE1heFkoKSk7cmV0dXJuIFJzLmRpc3RhbmNlKG4scyxpLHIpfXN0YXRpYyBtaW5NYXhEaXN0YW5jZSh0LGUpe2NvbnN0IG49dC5nZXRNaW5YKCkscz10LmdldE1pblkoKSxpPXQuZ2V0TWF4WCgpLHI9dC5nZXRNYXhZKCksbz1lLmdldE1pblgoKSxsPWUuZ2V0TWluWSgpLGE9ZS5nZXRNYXhYKCksYz1lLmdldE1heFkoKTtsZXQgaD1Scy5tYXhEaXN0YW5jZShuLHMsbixyLG8sbCxvLGMpO3JldHVybiBoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UobixzLG4scixvLGwsYSxsKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKG4scyxuLHIsYSxjLG8sYykpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShuLHMsbixyLGEsYyxhLGwpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UobixzLGkscyxvLGwsbyxjKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKG4scyxpLHMsbyxsLGEsbCkpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShuLHMsaSxzLGEsYyxvLGMpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UobixzLGkscyxhLGMsYSxsKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixuLHIsbyxsLG8sYykpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsbixyLG8sbCxhLGwpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLG4scixhLGMsbyxjKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixuLHIsYSxjLGEsbCkpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsaSxzLG8sbCxvLGMpKSxoPU1hdGgubWluKGgsUnMubWF4RGlzdGFuY2UoaSxyLGkscyxvLGwsYSxsKSksaD1NYXRoLm1pbihoLFJzLm1heERpc3RhbmNlKGkscixpLHMsYSxjLG8sYykpLGg9TWF0aC5taW4oaCxScy5tYXhEaXN0YW5jZShpLHIsaSxzLGEsYyxhLGwpKSxofX1jbGFzcyBQc3tjb25zdHJ1Y3Rvcigpe1BzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2JvdW5kYWJsZTE9bnVsbCx0aGlzLl9ib3VuZGFibGUyPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9pdGVtRGlzdGFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ib3VuZGFibGUxPXQsdGhpcy5fYm91bmRhYmxlMj1lLHRoaXMuX2l0ZW1EaXN0YW5jZT1uLHRoaXMuX2Rpc3RhbmNlPXRoaXMuZGlzdGFuY2UoKX1zdGF0aWMgYXJlYSh0KXtyZXR1cm4gdC5nZXRCb3VuZHMoKS5nZXRBcmVhKCl9c3RhdGljIGlzQ29tcG9zaXRlKHQpe3JldHVybiB0IGluc3RhbmNlb2YgVHN9bWF4aW11bURpc3RhbmNlKCl7cmV0dXJuIFJzLm1heGltdW1EaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUxLmdldEJvdW5kcygpLHRoaXMuX2JvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpfWV4cGFuZFRvUXVldWUodCxlKXtjb25zdCBuPVBzLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpLGk9UHMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMik7aWYobiYmaSlyZXR1cm4gUHMuYXJlYSh0aGlzLl9ib3VuZGFibGUxKT5Qcy5hcmVhKHRoaXMuX2JvdW5kYWJsZTIpPyh0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIsITEsdCxlKSxudWxsKToodGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMix0aGlzLl9ib3VuZGFibGUxLCEwLHQsZSksbnVsbCk7aWYobilyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyLCExLHQsZSksbnVsbDtpZihpKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLHRoaXMuX2JvdW5kYWJsZTEsITAsdCxlKSxudWxsO3Rocm93IG5ldyBzKFwibmVpdGhlciBib3VuZGFibGUgaXMgY29tcG9zaXRlXCIpfWlzTGVhdmVzKCl7cmV0dXJuIShQcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKXx8UHMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMikpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlPGUuX2Rpc3RhbmNlPy0xOnRoaXMuX2Rpc3RhbmNlPmUuX2Rpc3RhbmNlPzE6MH1leHBhbmQodCxlLG4scyxpKXtmb3IobGV0IHI9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7Y29uc3QgdD1yLm5leHQoKTtsZXQgbz1udWxsO289bj9uZXcgUHMoZSx0LHRoaXMuX2l0ZW1EaXN0YW5jZSk6bmV3IFBzKHQsZSx0aGlzLl9pdGVtRGlzdGFuY2UpLG8uZ2V0RGlzdGFuY2UoKTxpJiZzLmFkZChvKX19Z2V0Qm91bmRhYmxlKHQpe3JldHVybiAwPT09dD90aGlzLl9ib3VuZGFibGUxOnRoaXMuX2JvdW5kYWJsZTJ9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9ZGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5pc0xlYXZlcygpP3RoaXMuX2l0ZW1EaXN0YW5jZS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIpOnRoaXMuX2JvdW5kYWJsZTEuZ2V0Qm91bmRzKCkuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMi5nZXRCb3VuZHMoKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBPc3tjb25zdHJ1Y3Rvcigpe09zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9idWlsdD0hMSx0aGlzLl9pdGVtQm91bmRhYmxlcz1uZXcgTCx0aGlzLl9ub2RlQ2FwYWNpdHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClPcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLE9zLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zy5pc1RydWUodD4xLFwiTm9kZSBjYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXCIpLHRoaXMuX25vZGVDYXBhY2l0eT10fX1zdGF0aWMgY29tcGFyZURvdWJsZXModCxlKXtyZXR1cm4gdD5lPzE6dDxlPy0xOjB9cXVlcnlJbnRlcm5hbCgpe2lmKEkoYXJndW1lbnRzWzJdLERlKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzFdLmdldENoaWxkQm91bmRhYmxlcygpO2ZvcihsZXQgcz0wO3M8bi5zaXplKCk7cysrKXtjb25zdCBpPW4uZ2V0KHMpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhpLmdldEJvdW5kcygpLHQpJiYoaSBpbnN0YW5jZW9mIFRzP3RoaXMucXVlcnlJbnRlcm5hbCh0LGksZSk6aSBpbnN0YW5jZW9mIFNzP2UudmlzaXRJdGVtKGkuZ2V0SXRlbSgpKTpnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCkpfX1lbHNlIGlmKEkoYXJndW1lbnRzWzJdLEMpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBUcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbMV0uZ2V0Q2hpbGRCb3VuZGFibGVzKCk7Zm9yKGxldCBzPTA7czxuLnNpemUoKTtzKyspe2NvbnN0IGk9bi5nZXQocyk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGkuZ2V0Qm91bmRzKCksdCkmJihpIGluc3RhbmNlb2YgVHM/dGhpcy5xdWVyeUludGVybmFsKHQsaSxlKTppIGluc3RhbmNlb2YgU3M/ZS5hZGQoaS5nZXRJdGVtKCkpOmcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fX1nZXROb2RlQ2FwYWNpdHkoKXtyZXR1cm4gdGhpcy5fbm9kZUNhcGFjaXR5fWxhc3ROb2RlKHQpe3JldHVybiB0LmdldCh0LnNpemUoKS0xKX1zaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLnNpemUodGhpcy5fcm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7biBpbnN0YW5jZW9mIFRzP3QrPXRoaXMuc2l6ZShuKTpuIGluc3RhbmNlb2YgU3MmJih0Kz0xKX1yZXR1cm4gdH19cmVtb3ZlSXRlbSh0LGUpe2xldCBuPW51bGw7Zm9yKGxldCBzPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dCBpbnN0YW5jZW9mIFNzJiZ0LmdldEl0ZW0oKT09PWUmJihuPXQpfXJldHVybiBudWxsIT09biYmKHQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKG4pLCEwKX1pdGVtc1RyZWUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5idWlsZCgpO2NvbnN0IHQ9dGhpcy5pdGVtc1RyZWUodGhpcy5fcm9vdCk7cmV0dXJuIG51bGw9PT10P25ldyBMOnR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7Zm9yKGxldCBuPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodCBpbnN0YW5jZW9mIFRzKXtjb25zdCBuPXRoaXMuaXRlbXNUcmVlKHQpO251bGwhPT1uJiZlLmFkZChuKX1lbHNlIHQgaW5zdGFuY2VvZiBTcz9lLmFkZCh0LmdldEl0ZW0oKSk6Zy5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBlLnNpemUoKTw9MD9udWxsOmV9fWluc2VydCh0LGUpe2cuaXNUcnVlKCF0aGlzLl9idWlsdCxcIkNhbm5vdCBpbnNlcnQgaXRlbXMgaW50byBhbiBTVFIgcGFja2VkIFItdHJlZSBhZnRlciBpdCBoYXMgYmVlbiBidWlsdC5cIiksdGhpcy5faXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBTcyh0LGUpKX1ib3VuZGFibGVzQXRMZXZlbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO3JldHVybiB0aGlzLmJvdW5kYWJsZXNBdExldmVsKHQsdGhpcy5fcm9vdCxlKSxlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihnLmlzVHJ1ZSh0Pi0yKSxlLmdldExldmVsKCk9PT10KXJldHVybiBuLmFkZChlKSxudWxsO2ZvcihsZXQgcz1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBlPXMubmV4dCgpO2UgaW5zdGFuY2VvZiBUcz90aGlzLmJvdW5kYWJsZXNBdExldmVsKHQsZSxuKTooZy5pc1RydWUoZSBpbnN0YW5jZW9mIFNzKSwtMT09PXQmJm4uYWRkKGUpKX1yZXR1cm4gbnVsbH19cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5idWlsZCgpO2NvbnN0IGU9bmV3IEw7cmV0dXJuIHRoaXMuaXNFbXB0eSgpfHx0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeUludGVybmFsKHQsdGhpcy5fcm9vdCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmJ1aWxkKCksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnlJbnRlcm5hbCh0LHRoaXMuX3Jvb3QsZSl9fWJ1aWxkKCl7aWYodGhpcy5fYnVpbHQpcmV0dXJuIG51bGw7dGhpcy5fcm9vdD10aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCk/dGhpcy5jcmVhdGVOb2RlKDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKHRoaXMuX2l0ZW1Cb3VuZGFibGVzLC0xKSx0aGlzLl9pdGVtQm91bmRhYmxlcz1udWxsLHRoaXMuX2J1aWx0PSEwfWdldFJvb3QoKXtyZXR1cm4gdGhpcy5idWlsZCgpLHRoaXMuX3Jvb3R9cmVtb3ZlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmJ1aWxkKCksISF0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5yZW1vdmUodCx0aGlzLl9yb290LGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtsZXQgcz10aGlzLnJlbW92ZUl0ZW0oZSxuKTtpZihzKXJldHVybiEwO2xldCBpPW51bGw7Zm9yKGxldCByPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe2NvbnN0IGU9ci5uZXh0KCk7aWYodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGUuZ2V0Qm91bmRzKCksdCkmJihlIGluc3RhbmNlb2YgVHMmJihzPXRoaXMucmVtb3ZlKHQsZSxuKSxzKSkpe2k9ZTticmVha319cmV0dXJuIG51bGwhPT1pJiZpLmdldENoaWxkQm91bmRhYmxlcygpLmlzRW1wdHkoKSYmZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUoaSksc319Y3JlYXRlSGlnaGVyTGV2ZWxzKHQsZSl7Zy5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPXRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUrMSk7cmV0dXJuIDE9PT1uLnNpemUoKT9uLmdldCgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyhuLGUrMSl9ZGVwdGgoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuZGVwdGgodGhpcy5fcm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobiBpbnN0YW5jZW9mIFRzKXtjb25zdCBlPXRoaXMuZGVwdGgobik7ZT50JiYodD1lKX19cmV0dXJuIHQrMX19Y3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUpe2cuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj1uZXcgTDtuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpO2NvbnN0IHM9bmV3IEwodCk7eGUuc29ydChzLHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtmb3IobGV0IHQ9cy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgcz10Lm5leHQoKTt0aGlzLmxhc3ROb2RlKG4pLmdldENoaWxkQm91bmRhYmxlcygpLnNpemUoKT09PXRoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkmJm4uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSksdGhpcy5sYXN0Tm9kZShuKS5hZGRDaGlsZEJvdW5kYWJsZShzKX1yZXR1cm4gbn1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX2J1aWx0P3RoaXMuX3Jvb3QuaXNFbXB0eSgpOnRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bY119fU9zLkludGVyc2VjdHNPcD1mdW5jdGlvbigpe30sT3MuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwO2NsYXNzIHZze2Rpc3RhbmNlKHQsZSl7fX1jbGFzcyBicyBleHRlbmRzIE9ze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxicy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClicy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGJzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07T3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19c3RhdGljIGNlbnRyZVgodCl7cmV0dXJuIGJzLmF2Zyh0LmdldE1pblgoKSx0LmdldE1heFgoKSl9c3RhdGljIGF2Zyh0LGUpe3JldHVybih0K2UpLzJ9c3RhdGljIGdldEl0ZW1zKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBuPTA7Zm9yKDshdC5pc0VtcHR5KCk7KXtjb25zdCBzPXQucG9sbCgpO2Vbbl09cy5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLG4rK31yZXR1cm4gZX1zdGF0aWMgY2VudHJlWSh0KXtyZXR1cm4gYnMuYXZnKHQuZ2V0TWluWSgpLHQuZ2V0TWF4WSgpKX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKHQsZSl7Zy5pc1RydWUodC5sZW5ndGg+MCk7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyluLmFkZEFsbCh0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSh0W3NdLGUpKTtyZXR1cm4gbn1uZWFyZXN0TmVpZ2hib3VySygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VySyh0LHIuUE9TSVRJVkVfSU5GSU5JVFksZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdO2xldCBuPWFyZ3VtZW50c1sxXTtjb25zdCBzPW5ldyBMcztzLmFkZCh0KTtjb25zdCBpPW5ldyBMcztmb3IoOyFzLmlzRW1wdHkoKSYmbj49MDspe2NvbnN0IHQ9cy5wb2xsKCkscj10LmdldERpc3RhbmNlKCk7aWYocj49bilicmVhaztpZih0LmlzTGVhdmVzKCkpaWYoaS5zaXplKCk8ZSlpLmFkZCh0KTtlbHNle2kucGVlaygpLmdldERpc3RhbmNlKCk+ciYmKGkucG9sbCgpLGkuYWRkKHQpKTtuPWkucGVlaygpLmdldERpc3RhbmNlKCl9ZWxzZSB0LmV4cGFuZFRvUXVldWUocyxuKX1yZXR1cm4gYnMuZ2V0SXRlbXMoaSl9fWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyBNcyh0KX1zaXplKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP3N1cGVyLnNpemUuY2FsbCh0aGlzKTpzdXBlci5zaXplLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnQoKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKSlyZXR1cm4gc3VwZXIuaW5zZXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5pc051bGwoKSlyZXR1cm4gbnVsbDtzdXBlci5pbnNlcnQuY2FsbCh0aGlzLHQsZSl9fWdldEludGVyc2VjdHNPcCgpe3JldHVybiBicy5pbnRlcnNlY3RzT3B9dmVydGljYWxTbGljZXModCxlKXtjb25zdCBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL2UpKSxzPW5ldyBBcnJheShlKS5maWxsKG51bGwpLGk9dC5pdGVyYXRvcigpO2ZvcihsZXQgdD0wO3Q8ZTt0Kyspe3NbdF09bmV3IEw7bGV0IGU9MDtmb3IoO2kuaGFzTmV4dCgpJiZlPG47KXtjb25zdCBuPWkubmV4dCgpO3NbdF0uYWRkKG4pLGUrK319cmV0dXJuIHN9cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHN1cGVyLnF1ZXJ5LmNhbGwodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07c3VwZXIucXVlcnkuY2FsbCh0aGlzLHQsZSl9fWdldENvbXBhcmF0b3IoKXtyZXR1cm4gYnMueUNvbXBhcmF0b3J9Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHQsZSl7cmV0dXJuIHN1cGVyLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMuY2FsbCh0aGlzLHQsZSl9cmVtb3ZlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBzdXBlci5yZW1vdmUuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLnJlbW92ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZGVwdGgoKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/c3VwZXIuZGVwdGguY2FsbCh0aGlzKTpzdXBlci5kZXB0aC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUpe2cuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj1NYXRoLnRydW5jKE1hdGguY2VpbCh0LnNpemUoKS90aGlzLmdldE5vZGVDYXBhY2l0eSgpKSkscz1uZXcgTCh0KTt4ZS5zb3J0KHMsYnMueENvbXBhcmF0b3IpO2NvbnN0IGk9dGhpcy52ZXJ0aWNhbFNsaWNlcyhzLE1hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGguc3FydChuKSkpKTtyZXR1cm4gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKGksZSl9bmVhcmVzdE5laWdoYm91cigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSx2cykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IFBzKHRoaXMuZ2V0Um9vdCgpLHRoaXMuZ2V0Um9vdCgpLHQpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoZSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQcyl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9ci5QT1NJVElWRV9JTkZJTklUWSxuPW51bGw7Y29uc3Qgcz1uZXcgTHM7Zm9yKHMuYWRkKHQpOyFzLmlzRW1wdHkoKSYmZT4wOyl7Y29uc3QgdD1zLnBvbGwoKSxpPXQuZ2V0RGlzdGFuY2UoKTtpZihpPj1lKWJyZWFrO3QuaXNMZWF2ZXMoKT8oZT1pLG49dCk6dC5leHBhbmRUb1F1ZXVlKHMsZSl9cmV0dXJuIG51bGw9PT1uP251bGw6W24uZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSxuLmdldEJvdW5kYWJsZSgxKS5nZXRJdGVtKCldfX1lbHNle2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmlzRW1wdHkoKXx8dC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgUHModGhpcy5nZXRSb290KCksdC5nZXRSb290KCksZSk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMl0sZT1uZXcgU3MoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSksbj1uZXcgUHModGhpcy5nZXRSb290KCksZSx0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKG4pWzBdfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1syXSxlPWFyZ3VtZW50c1szXSxuPW5ldyBTcyhhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKSxzPW5ldyBQcyh0aGlzLmdldFJvb3QoKSxuLHQpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXJLKHMsZSl9fX1pc1dpdGhpbkRpc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPXIuUE9TSVRJVkVfSU5GSU5JVFk7Y29uc3Qgcz1uZXcgTHM7Zm9yKHMuYWRkKHQpOyFzLmlzRW1wdHkoKTspe2NvbnN0IHQ9cy5wb2xsKCksaT10LmdldERpc3RhbmNlKCk7aWYoaT5lKXJldHVybiExO2lmKHQubWF4aW11bURpc3RhbmNlKCk8PWUpcmV0dXJuITA7aWYodC5pc0xlYXZlcygpKXtpZihuPWksbjw9ZSlyZXR1cm4hMH1lbHNlIHQuZXhwYW5kVG9RdWV1ZShzLG4pfXJldHVybiExfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBQcyh0aGlzLmdldFJvb3QoKSx0LmdldFJvb3QoKSxlKTtyZXR1cm4gdGhpcy5pc1dpdGhpbkRpc3RhbmNlKHMsbil9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltJcyxjXX19Y2xhc3MgTXMgZXh0ZW5kcyBUc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF07VHMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1jb21wdXRlQm91bmRzKCl7bGV0IHQ9bnVsbDtmb3IobGV0IGU9dGhpcy5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtudWxsPT09dD90PW5ldyBPKG4uZ2V0Qm91bmRzKCkpOnQuZXhwYW5kVG9JbmNsdWRlKG4uZ2V0Qm91bmRzKCkpfXJldHVybiB0fX1icy5TVFJ0cmVlTm9kZT1Ncyxicy54Q29tcGFyYXRvcj1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfWNvbXBhcmUodCxlKXtyZXR1cm4gT3MuY29tcGFyZURvdWJsZXMoYnMuY2VudHJlWCh0LmdldEJvdW5kcygpKSxicy5jZW50cmVYKGUuZ2V0Qm91bmRzKCkpKX19LGJzLnlDb21wYXJhdG9yPW5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19Y29tcGFyZSh0LGUpe3JldHVybiBPcy5jb21wYXJlRG91Ymxlcyhicy5jZW50cmVZKHQuZ2V0Qm91bmRzKCkpLGJzLmNlbnRyZVkoZS5nZXRCb3VuZHMoKSkpfX0sYnMuaW50ZXJzZWN0c09wPW5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSW50ZXJzZWN0c09wXX1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0cyhlKX19LGJzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMDt2YXIgRHM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsU1RSdHJlZTpic30pLEFzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGtkdHJlZTpfcyxxdWFkdHJlZTp3cyxzdHJ0cmVlOkRzfSk7Y29uc3QgRnM9W1wiUG9pbnRcIixcIk11bHRpUG9pbnRcIixcIkxpbmVTdHJpbmdcIixcIk11bHRpTGluZVN0cmluZ1wiLFwiUG9seWdvblwiLFwiTXVsdGlQb2x5Z29uXCJdO2NsYXNzIEdze2NvbnN0cnVjdG9yKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBMdH1yZWFkKHQpe2xldCBlO2U9XCJzdHJpbmdcIj09dHlwZW9mIHQ/SlNPTi5wYXJzZSh0KTp0O2NvbnN0IG49ZS50eXBlO2lmKCFxc1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrZS50eXBlKTtyZXR1cm4tMSE9PUZzLmluZGV4T2Yobik/cXNbbl0uY2FsbCh0aGlzLGUuY29vcmRpbmF0ZXMpOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT1uP3FzW25dLmNhbGwodGhpcyxlLmdlb21ldHJpZXMpOnFzW25dLmNhbGwodGhpcyxlKX13cml0ZSh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlUeXBlKCk7aWYoIUJzW2VdKXRocm93IG5ldyBFcnJvcihcIkdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIEJzW2VdLmNhbGwodGhpcyx0KX19Y29uc3QgcXM9e0ZlYXR1cmU6ZnVuY3Rpb24odCl7Y29uc3QgZT17fTtmb3IoY29uc3QgbiBpbiB0KWVbbl09dFtuXTtpZih0Lmdlb21ldHJ5KXtjb25zdCBuPXQuZ2VvbWV0cnkudHlwZTtpZighcXNbbl0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK3QudHlwZSk7ZS5nZW9tZXRyeT10aGlzLnJlYWQodC5nZW9tZXRyeSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD1xcy5iYm94LmNhbGwodGhpcyx0LmJib3gpKSxlfSxGZWF0dXJlQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPXt9O2lmKHQuZmVhdHVyZXMpe2UuZmVhdHVyZXM9W107Zm9yKGxldCBuPTA7bjx0LmZlYXR1cmVzLmxlbmd0aDsrK24pZS5mZWF0dXJlcy5wdXNoKHRoaXMucmVhZCh0LmZlYXR1cmVzW25dKSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD10aGlzLnBhcnNlLmJib3guY2FsbCh0aGlzLHQuYmJveCkpLGV9LGNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2gobmV3IG0oLi4ucykpfXJldHVybiBlfSxiYm94OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgbSh0WzBdLHRbMV0pLG5ldyBtKHRbMl0sdFsxXSksbmV3IG0odFsyXSx0WzNdKSxuZXcgbSh0WzBdLHRbM10pLG5ldyBtKHRbMF0sdFsxXSldKX0sUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgbSguLi50KTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSl9LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbillLnB1c2gocXMuUG9pbnQuY2FsbCh0aGlzLHRbbl0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPXFzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyx0KTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlKX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKHFzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHRbbl0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9cXMuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLHRbMF0pLG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhlKSxzPVtdO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7KytlKXtjb25zdCBuPXRbZV0saT1xcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsbikscj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGkpO3MucHVzaChyKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLHMpfSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaChxcy5Qb2x5Z29uLmNhbGwodGhpcyxzKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2godGhpcy5yZWFkKHMpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0sQnM9e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7Y29uc3QgZT1bdC54LHQueV07cmV0dXJuIHQueiYmZS5wdXNoKHQueiksdC5tJiZlLnB1c2godC5tKSxlfSxQb2ludDpmdW5jdGlvbih0KXtyZXR1cm57dHlwZTpcIlBvaW50XCIsY29vcmRpbmF0ZXM6QnMuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5nZXRDb29yZGluYXRlKCkpfX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ccy5Qb2ludC5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2ludFwiLGNvb3JkaW5hdGVzOmV9fSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W10sbj10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDsrK3Qpe2NvbnN0IHM9blt0XTtlLnB1c2goQnMuY29vcmRpbmF0ZS5jYWxsKHRoaXMscykpfXJldHVybnt0eXBlOlwiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9QnMuTGluZVN0cmluZy5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LFBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXSxuPUJzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHQuX3NoZWxsKTtlLnB1c2gobi5jb29yZGluYXRlcyk7Zm9yKGxldCBuPTA7bjx0Ll9ob2xlcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2hvbGVzW25dLGk9QnMuTGluZVN0cmluZy5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9QnMuUG9seWdvbi5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1zLmdldEdlb21ldHJ5VHlwZSgpO2UucHVzaChCc1tpXS5jYWxsKHRoaXMscykpfXJldHVybnt0eXBlOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsZ2VvbWV0cmllczplfX19O2Z1bmN0aW9uIFlzKHQpe3JldHVyblt0LngsdC55XX12YXIgVnM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvSlNPTlJlYWRlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgR3ModHx8bmV3IEx0KX1yZWFkKHQpe3JldHVybiB0aGlzLnBhcnNlci5yZWFkKHQpfX0sR2VvSlNPTldyaXRlcjpjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMucGFyc2VyPW5ldyBHcyh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9d3JpdGUodCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0sT0wzUGFyc2VyOmNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEx0LHRoaXMub2w9ZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG9sJiZvbH1pbmplY3QodCxlLG4scyxpLHIsbyxsKXt0aGlzLm9sPXtnZW9tOntQb2ludDp0LExpbmVTdHJpbmc6ZSxMaW5lYXJSaW5nOm4sUG9seWdvbjpzLE11bHRpUG9pbnQ6aSxNdWx0aUxpbmVTdHJpbmc6cixNdWx0aVBvbHlnb246byxHZW9tZXRyeUNvbGxlY3Rpb246bH19fXJlYWQodCl7Y29uc3QgZT10aGlzLm9sO3JldHVybiB0IGluc3RhbmNlb2YgZS5nZW9tLlBvaW50P3RoaXMuY29udmVydEZyb21Qb2ludCh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5MaW5lYXJSaW5nP3RoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9pbnQodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aUxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uP3RoaXMuY29udmVydEZyb21Db2xsZWN0aW9uKHQpOnZvaWQgMH1jb252ZXJ0RnJvbVBvaW50KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgbShlWzBdLGVbMV0pKX1jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBtKHRbMF0sdFsxXSl9KSkpfWNvbnZlcnRGcm9tTGluZWFyUmluZyh0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IG0odFswXSx0WzFdKX0pKSl9Y29udmVydEZyb21Qb2x5Z29uKHQpe2NvbnN0IGU9dC5nZXRMaW5lYXJSaW5ncygpO2xldCBuPW51bGw7Y29uc3Qgcz1bXTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgaT10aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyhlW3RdKTswPT09dD9uPWk6cy5wdXNoKGkpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4scyl9Y29udmVydEZyb21NdWx0aVBvaW50KHQpe2NvbnN0IGU9dC5nZXRQb2ludHMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9pbnQodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX1jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KXtjb25zdCBlPXQuZ2V0TGluZVN0cmluZ3MoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9Y29udmVydEZyb21NdWx0aVBvbHlnb24odCl7Y29uc3QgZT10LmdldFBvbHlnb25zKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfWNvbnZlcnRGcm9tQ29sbGVjdGlvbih0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cmllcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZCh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9d3JpdGUodCl7cmV0dXJuXCJQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTpcIkxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQpOlwiTGluZWFyUmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVhclJpbmcodCk6XCJQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9seWdvbih0KTpcIk11bHRpUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvaW50KHQpOlwiTXVsdGlMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlMaW5lU3RyaW5nKHQpOlwiTXVsdGlQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2x5Z29uKHQpOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvQ29sbGVjdGlvbih0KTp2b2lkIDB9Y29udmVydFRvUG9pbnQodCl7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uUG9pbnQoW3QueCx0LnldKX1jb252ZXJ0VG9MaW5lU3RyaW5nKHQpe2NvbnN0IGU9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoWXMpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLkxpbmVTdHJpbmcoZSl9Y29udmVydFRvTGluZWFyUmluZyh0KXtjb25zdCBlPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFlzKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5MaW5lYXJSaW5nKGUpfWNvbnZlcnRUb1BvbHlnb24odCl7Y29uc3QgZT1bdC5fc2hlbGwuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKFlzKV07Zm9yKGxldCBuPTA7bjx0Ll9ob2xlcy5sZW5ndGg7bisrKWUucHVzaCh0Ll9ob2xlc1tuXS5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoWXMpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5Qb2x5Z29uKGUpfWNvbnZlcnRUb011bHRpUG9pbnQodCl7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlQb2ludCh0LmdldENvb3JkaW5hdGVzKCkubWFwKFlzKSl9Y29udmVydFRvTXVsdGlMaW5lU3RyaW5nKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvTGluZVN0cmluZyh0Ll9nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmcoZSl9Y29udmVydFRvTXVsdGlQb2x5Z29uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvUG9seWdvbih0Ll9nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aVBvbHlnb24oZSl9Y29udmVydFRvQ29sbGVjdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl07ZS5wdXNoKHRoaXMud3JpdGUocykpfXJldHVybiBuZXcgdGhpcy5vbC5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbihlKX19LFdLVFJlYWRlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgSHQodHx8bmV3IEx0KX1yZWFkKHQpe3JldHVybiB0aGlzLnBhcnNlci5yZWFkKHQpfX0sV0tUV3JpdGVyOld0fSk7Y2xhc3MgenN7c3RhdGljIHJlbGF0aXZlU2lnbih0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6MH1zdGF0aWMgY29tcGFyZSh0LGUsbil7aWYoZS5lcXVhbHMyRChuKSlyZXR1cm4gMDtjb25zdCBzPXpzLnJlbGF0aXZlU2lnbihlLngsbi54KSxpPXpzLnJlbGF0aXZlU2lnbihlLnksbi55KTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB6cy5jb21wYXJlVmFsdWUocyxpKTtjYXNlIDE6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZShpLHMpO2Nhc2UgMjpyZXR1cm4genMuY29tcGFyZVZhbHVlKGksLXMpO2Nhc2UgMzpyZXR1cm4genMuY29tcGFyZVZhbHVlKC1zLGkpO2Nhc2UgNDpyZXR1cm4genMuY29tcGFyZVZhbHVlKC1zLC1pKTtjYXNlIDU6cmV0dXJuIHpzLmNvbXBhcmVWYWx1ZSgtaSwtcyk7Y2FzZSA2OnJldHVybiB6cy5jb21wYXJlVmFsdWUoLWkscyk7Y2FzZSA3OnJldHVybiB6cy5jb21wYXJlVmFsdWUocywtaSl9cmV0dXJuIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJpbnZhbGlkIG9jdGFudCB2YWx1ZVwiKSwwfXN0YXRpYyBjb21wYXJlVmFsdWUodCxlKXtyZXR1cm4gdDwwPy0xOnQ+MD8xOmU8MD8tMTplPjA/MTowfX1jbGFzcyBYc3tjb25zdHJ1Y3Rvcigpe1hzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NlZ1N0cmluZz1udWxsLHRoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuX3NlZ21lbnRPY3RhbnQ9bnVsbCx0aGlzLl9pc0ludGVyaW9yPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fc2VnU3RyaW5nPXQsdGhpcy5jb29yZD1uZXcgbShlKSx0aGlzLnNlZ21lbnRJbmRleD1uLHRoaXMuX3NlZ21lbnRPY3RhbnQ9cyx0aGlzLl9pc0ludGVyaW9yPSFlLmVxdWFsczJEKHQuZ2V0Q29vcmRpbmF0ZShuKSl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvb3JkfXByaW50KHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDxlLnNlZ21lbnRJbmRleD8tMTp0aGlzLnNlZ21lbnRJbmRleD5lLnNlZ21lbnRJbmRleD8xOnRoaXMuY29vcmQuZXF1YWxzMkQoZS5jb29yZCk/MDp0aGlzLl9pc0ludGVyaW9yP2UuX2lzSW50ZXJpb3I/enMuY29tcGFyZSh0aGlzLl9zZWdtZW50T2N0YW50LHRoaXMuY29vcmQsZS5jb29yZCk6MTotMX1pc0VuZFBvaW50KHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJiF0aGlzLl9pc0ludGVyaW9yfHx0aGlzLnNlZ21lbnRJbmRleD09PXR9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXgrXCI6XCIrdGhpcy5jb29yZC50b1N0cmluZygpfWlzSW50ZXJpb3IoKXtyZXR1cm4gdGhpcy5faXNJbnRlcmlvcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIGtze2NvbnN0cnVjdG9yKCl7a3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZU1hcD1uZXcgV24sdGhpcy5fZWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2U9dH1nZXRTcGxpdENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgUjt0aGlzLmFkZEVuZHBvaW50cygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpO3RoaXMuYWRkRWRnZUNvb3JkaW5hdGVzKG4scyx0KSxuPXN9cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX1hZGRDb2xsYXBzZWROb2Rlcygpe2NvbnN0IHQ9bmV3IEw7dGhpcy5maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXModCksdGhpcy5maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXModCk7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCkuaW50VmFsdWUoKTt0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUodCksdCl9fWNyZWF0ZVNwbGl0RWRnZVB0cyh0LGUpe2xldCBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzI7aWYoMj09PW4pcmV0dXJuW25ldyBtKHQuY29vcmQpLG5ldyBtKGUuY29vcmQpXTtjb25zdCBzPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCksaT1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQocyk7aXx8bi0tO2NvbnN0IHI9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7bGV0IG89MDtyW28rK109bmV3IG0odC5jb29yZCk7Zm9yKGxldCBuPXQuc2VnbWVudEluZGV4KzE7bjw9ZS5zZWdtZW50SW5kZXg7bisrKXJbbysrXT10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUobik7cmV0dXJuIGkmJihyW29dPW5ldyBtKGUuY29vcmQpKSxyfXByaW50KHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19ZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZS5zaXplKCktMjtlKyspe2NvbnN0IG49dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUpO3RoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKzEpO2NvbnN0IHM9dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUrMik7bi5lcXVhbHMyRChzKSYmdC5hZGQoYi52YWx1ZU9mKGUrMSkpfX1hZGRFZGdlQ29vcmRpbmF0ZXModCxlLG4pe2NvbnN0IHM9dGhpcy5jcmVhdGVTcGxpdEVkZ2VQdHModCxlKTtuLmFkZChzLCExKX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9YWRkU3BsaXRFZGdlcyh0KXt0aGlzLmFkZEVuZHBvaW50cygpLHRoaXMuYWRkQ29sbGFwc2VkTm9kZXMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4scyk7dC5hZGQoaSksbj1zfX1maW5kQ29sbGFwc2VJbmRleCh0LGUsbil7aWYoIXQuY29vcmQuZXF1YWxzMkQoZS5jb29yZCkpcmV0dXJuITE7bGV0IHM9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXg7cmV0dXJuIGUuaXNJbnRlcmlvcigpfHxzLS0sMT09PXMmJihuWzBdPXQuc2VnbWVudEluZGV4KzEsITApfWZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyh0KXtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5pdGVyYXRvcigpO2xldCBzPW4ubmV4dCgpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBpPW4ubmV4dCgpO3RoaXMuZmluZENvbGxhcHNlSW5kZXgocyxpLGUpJiZ0LmFkZChiLnZhbHVlT2YoZVswXSkpLHM9aX19Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWFkZEVuZHBvaW50cygpe2NvbnN0IHQ9dGhpcy5fZWRnZS5zaXplKCktMTt0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoMCksMCksdGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfWNyZWF0ZVNwbGl0RWRnZSh0LGUpe2NvbnN0IG49dGhpcy5jcmVhdGVTcGxpdEVkZ2VQdHModCxlKTtyZXR1cm4gbmV3IFpzKG4sdGhpcy5fZWRnZS5nZXREYXRhKCkpfWFkZCh0LGUpe2NvbnN0IG49bmV3IFhzKHRoaXMuX2VkZ2UsdCxlLHRoaXMuX2VkZ2UuZ2V0U2VnbWVudE9jdGFudChlKSkscz10aGlzLl9ub2RlTWFwLmdldChuKTtyZXR1cm4gbnVsbCE9PXM/KGcuaXNUcnVlKHMuY29vcmQuZXF1YWxzMkQodCksXCJGb3VuZCBlcXVhbCBub2RlcyB3aXRoIGRpZmZlcmVudCBjb29yZGluYXRlc1wiKSxzKToodGhpcy5fbm9kZU1hcC5wdXQobixuKSxuKX1jaGVja1NwbGl0RWRnZXNDb3JyZWN0bmVzcyh0KXtjb25zdCBlPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZXMoKSxuPXQuZ2V0KDApLmdldENvb3JkaW5hdGUoMCk7aWYoIW4uZXF1YWxzMkQoZVswXSkpdGhyb3cgbmV3IGgoXCJiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCBcIituKTtjb25zdCBzPXQuZ2V0KHQuc2l6ZSgpLTEpLmdldENvb3JkaW5hdGVzKCksaT1zW3MubGVuZ3RoLTFdO2lmKCFpLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pKXRocm93IG5ldyBoKFwiYmFkIHNwbGl0IGVkZ2UgZW5kIHBvaW50IGF0IFwiK2kpfX1jbGFzcyBVc3tzdGF0aWMgb2N0YW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBzKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7Y29uc3Qgbj1NYXRoLmFicyh0KSxpPU1hdGguYWJzKGUpO3JldHVybiB0Pj0wP2U+PTA/bj49aT8wOjE6bj49aT83OjY6ZT49MD9uPj1pPzM6MjpuPj1pPzQ6NX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1lLngtdC54LGk9ZS55LXQueTtpZigwPT09biYmMD09PWkpdGhyb3cgbmV3IHMoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIit0KTtyZXR1cm4gVXMub2N0YW50KG4saSl9fX1jbGFzcyBIc3tnZXRDb29yZGluYXRlcygpe31zaXplKCl7fWdldENvb3JkaW5hdGUodCl7fWlzQ2xvc2VkKCl7fXNldERhdGEodCl7fWdldERhdGEoKXt9fWNsYXNzIFdze2FkZEludGVyc2VjdGlvbih0LGUpe31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSHNdfX1jbGFzcyBac3tjb25zdHJ1Y3Rvcigpe1pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVMaXN0PW5ldyBrcyh0aGlzKSx0aGlzLl9wdHM9bnVsbCx0aGlzLl9kYXRhPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fZGF0YT1lfXN0YXRpYyBnZXROb2RlZFN1YnN0cmluZ3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtyZXR1cm4gWnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKHQpfX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRzfXNpemUoKXtyZXR1cm4gdGhpcy5fcHRzLmxlbmd0aH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHNbdF19aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aC0xXSl9Z2V0U2VnbWVudE9jdGFudCh0KXtyZXR1cm4gdD09PXRoaXMuX3B0cy5sZW5ndGgtMT8tMTp0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1zYWZlT2N0YW50KHQsZSl7cmV0dXJuIHQuZXF1YWxzMkQoZSk/MDpVcy5vY3RhbnQodCxlKX1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9YWRkSW50ZXJzZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzNdLG49bmV3IG0oYXJndW1lbnRzWzBdLmdldEludGVyc2VjdGlvbihlKSk7dGhpcy5hZGRJbnRlcnNlY3Rpb24obix0KX19dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKG5ldyBtdCh0aGlzLl9wdHMpKX1nZXROb2RlTGlzdCgpe3JldHVybiB0aGlzLl9ub2RlTGlzdH1hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl7bGV0IG49ZTtjb25zdCBzPW4rMTtpZihzPHRoaXMuX3B0cy5sZW5ndGgpe2NvbnN0IGU9dGhpcy5fcHRzW3NdO3QuZXF1YWxzMkQoZSkmJihuPXMpfXJldHVybiB0aGlzLl9ub2RlTGlzdC5hZGQodCxuKX1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltXc119fWNsYXNzIGpze2NvbnN0cnVjdG9yKCl7anMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3ZlcmxhcFNlZzE9bmV3IEt0LHRoaXMuX292ZXJsYXBTZWcyPW5ldyBLdH1vdmVybGFwKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdO2FyZ3VtZW50c1swXS5nZXRMaW5lU2VnbWVudCh0LHRoaXMuX292ZXJsYXBTZWcxKSxlLmdldExpbmVTZWdtZW50KG4sdGhpcy5fb3ZlcmxhcFNlZzIpLHRoaXMub3ZlcmxhcCh0aGlzLl9vdmVybGFwU2VnMSx0aGlzLl9vdmVybGFwU2VnMil9fX1jbGFzcyBLc3tjb25zdHJ1Y3Rvcigpe0tzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3N0YXJ0PW51bGwsdGhpcy5fZW5kPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5fY29udGV4dD1udWxsLHRoaXMuX2lkPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fcHRzPXQsdGhpcy5fc3RhcnQ9ZSx0aGlzLl9lbmQ9bix0aGlzLl9jb250ZXh0PXN9Z2V0TGluZVNlZ21lbnQodCxlKXtlLnAwPXRoaXMuX3B0c1t0XSxlLnAxPXRoaXMuX3B0c1t0KzFdfWNvbXB1dGVTZWxlY3QodCxlLG4scyl7Y29uc3QgaT10aGlzLl9wdHNbZV0scj10aGlzLl9wdHNbbl07aWYobi1lPT0xKXJldHVybiBzLnNlbGVjdCh0aGlzLGUpLG51bGw7aWYoIXQuaW50ZXJzZWN0cyhpLHIpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygoZStuKS8yKTtlPG8mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LGUsbyxzKSxvPG4mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LG8sbixzKX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2VuZC10aGlzLl9zdGFydCsxKS5maWxsKG51bGwpO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuX3N0YXJ0O248PXRoaXMuX2VuZDtuKyspdFtlKytdPXRoaXMuX3B0c1tuXTtyZXR1cm4gdH1jb21wdXRlT3ZlcmxhcHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5jb21wdXRlT3ZlcmxhcHModGhpcy5fc3RhcnQsdGhpcy5fZW5kLHQsdC5fc3RhcnQsdC5fZW5kLGUpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO2lmKGUtdD09MSYmaS1zPT0xKXJldHVybiByLm92ZXJsYXAodGhpcyx0LG4scyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixsLGkscikpLG88ZSYmKHM8bCYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4sbCxpLHIpKX19c2V0SWQodCl7dGhpcy5faWQ9dH1zZWxlY3QodCxlKXt0aGlzLmNvbXB1dGVTZWxlY3QodCx0aGlzLl9zdGFydCx0aGlzLl9lbmQsZSl9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXtjb25zdCB0PXRoaXMuX3B0c1t0aGlzLl9zdGFydF0sZT10aGlzLl9wdHNbdGhpcy5fZW5kXTt0aGlzLl9lbnY9bmV3IE8odCxlKX1yZXR1cm4gdGhpcy5fZW52fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE8uaW50ZXJzZWN0cyh0aGlzLl9wdHNbdF0sdGhpcy5fcHRzW2VdLG4uX3B0c1tzXSxuLl9wdHNbaV0pfWdldEVuZEluZGV4KCl7cmV0dXJuIHRoaXMuX2VuZH1nZXRTdGFydEluZGV4KCl7cmV0dXJuIHRoaXMuX3N0YXJ0fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fY29udGV4dH1nZXRJZCgpe3JldHVybiB0aGlzLl9pZH19Y2xhc3MgUXN7c3RhdGljIGZpbmRDaGFpbkVuZCh0LGUpe2xldCBuPWU7Zm9yKDtuPHQubGVuZ3RoLTEmJnRbbl0uZXF1YWxzMkQodFtuKzFdKTspbisrO2lmKG4+PXQubGVuZ3RoLTEpcmV0dXJuIHQubGVuZ3RoLTE7Y29uc3Qgcz1Dbi5xdWFkcmFudCh0W25dLHRbbisxXSk7bGV0IGk9ZSsxO2Zvcig7aTx0Lmxlbmd0aDspe2lmKCF0W2ktMV0uZXF1YWxzMkQodFtpXSkpe2lmKENuLnF1YWRyYW50KHRbaS0xXSx0W2ldKSE9PXMpYnJlYWt9aSsrfXJldHVybiBpLTF9c3RhdGljIGdldENoYWlucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gUXMuZ2V0Q2hhaW5zKHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7bGV0IHM9MDtkb3tjb25zdCBpPVFzLmZpbmRDaGFpbkVuZCh0LHMpLHI9bmV3IEtzKHQscyxpLGUpO24uYWRkKHIpLHM9aX13aGlsZShzPHQubGVuZ3RoLTEpO3JldHVybiBufX19Y2xhc3MgSnN7Y29tcHV0ZU5vZGVzKHQpe31nZXROb2RlZFN1YnN0cmluZ3MoKXt9fWNsYXNzICRze2NvbnN0cnVjdG9yKCl7JHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc2VnSW50PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0U2VnbWVudEludGVyc2VjdG9yKHQpfX1zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl7dGhpcy5fc2VnSW50PXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0pzXX19Y2xhc3MgdGkgZXh0ZW5kcyAkc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbW9ub0NoYWlucz1uZXcgTCx0aGlzLl9pbmRleD1uZXcgYnMsdGhpcy5faWRDb3VudGVyPTAsdGhpcy5fbm9kZWRTZWdTdHJpbmdzPW51bGwsdGhpcy5fbk92ZXJsYXBzPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdOyRzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fWdldE1vbm90b25lQ2hhaW5zKCl7cmV0dXJuIHRoaXMuX21vbm9DaGFpbnN9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7cmV0dXJuIFpzLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpfWdldEluZGV4KCl7cmV0dXJuIHRoaXMuX2luZGV4fWFkZCh0KXtmb3IobGV0IGU9UXMuZ2V0Q2hhaW5zKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldElkKHRoaXMuX2lkQ291bnRlcisrKSx0aGlzLl9pbmRleC5pbnNlcnQodC5nZXRFbnZlbG9wZSgpLHQpLHRoaXMuX21vbm9DaGFpbnMuYWRkKHQpfX1jb21wdXRlTm9kZXModCl7dGhpcy5fbm9kZWRTZWdTdHJpbmdzPXQ7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3RoaXMuaW50ZXJzZWN0Q2hhaW5zKCl9aW50ZXJzZWN0Q2hhaW5zKCl7Y29uc3QgdD1uZXcgZWkodGhpcy5fc2VnSW50KTtmb3IobGV0IGU9dGhpcy5fbW9ub0NoYWlucy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtmb3IobGV0IGU9dGhpcy5faW5kZXgucXVlcnkobi5nZXRFbnZlbG9wZSgpKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKTtpZihzLmdldElkKCk+bi5nZXRJZCgpJiYobi5jb21wdXRlT3ZlcmxhcHMocyx0KSx0aGlzLl9uT3ZlcmxhcHMrKyksdGhpcy5fc2VnSW50LmlzRG9uZSgpKXJldHVybiBudWxsfX19fWNsYXNzIGVpIGV4dGVuZHMganN7Y29uc3RydWN0b3IoKXtzdXBlcigpLGVpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2k9dH1vdmVybGFwKCl7aWYoNCE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHN1cGVyLm92ZXJsYXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXSxzPWFyZ3VtZW50c1swXS5nZXRDb250ZXh0KCksaT1lLmdldENvbnRleHQoKTt0aGlzLl9zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhzLHQsaSxuKX19fXRpLlNlZ21lbnRPdmVybGFwQWN0aW9uPWVpO2NsYXNzIG5pe2NvbnN0cnVjdG9yKCl7bmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbm9kZXI9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX29mZnNldFg9bnVsbCx0aGlzLl9vZmZzZXRZPW51bGwsdGhpcy5faXNTY2FsZWQ9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO25pLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLDAsMCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbm9kZXI9dCx0aGlzLl9zY2FsZUZhY3Rvcj1lLHRoaXMuX2lzU2NhbGVkPSF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpfX1yZXNjYWxlKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5yZXNjYWxlKGUuZ2V0Q29vcmRpbmF0ZXMoKSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXS54PXRbZV0ueC90aGlzLl9zY2FsZUZhY3Rvcit0aGlzLl9vZmZzZXRYLHRbZV0ueT10W2VdLnkvdGhpcy5fc2NhbGVGYWN0b3IrdGhpcy5fb2Zmc2V0WTsyPT09dC5sZW5ndGgmJnRbMF0uZXF1YWxzMkQodFsxXSkmJlkub3V0LnByaW50bG4odCl9fXNjYWxlKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEwodC5zaXplKCkpO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBacyh0aGlzLnNjYWxlKHQuZ2V0Q29vcmRpbmF0ZXMoKSksdC5nZXREYXRhKCkpKX1yZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllW25dPW5ldyBtKE1hdGgucm91bmQoKHRbbl0ueC10aGlzLl9vZmZzZXRYKSp0aGlzLl9zY2FsZUZhY3RvciksTWF0aC5yb3VuZCgodFtuXS55LXRoaXMuX29mZnNldFkpKnRoaXMuX3NjYWxlRmFjdG9yKSx0W25dLmdldFooKSk7cmV0dXJuIF90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKGUpfX1pc0ludGVnZXJQcmVjaXNpb24oKXtyZXR1cm4gMT09PXRoaXMuX3NjYWxlRmFjdG9yfWdldE5vZGVkU3Vic3RyaW5ncygpe2NvbnN0IHQ9dGhpcy5fbm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7cmV0dXJuIHRoaXMuX2lzU2NhbGVkJiZ0aGlzLnJlc2NhbGUodCksdH1jb21wdXRlTm9kZXModCl7bGV0IGU9dDt0aGlzLl9pc1NjYWxlZCYmKGU9dGhpcy5zY2FsZSh0KSksdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKGUpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKc119fXZhciBzaT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxNQ0luZGV4Tm9kZXI6dGksU2NhbGVkTm9kZXI6bmksU2VnbWVudFN0cmluZzpIc30pO2NsYXNzIGlpe2NvbnN0cnVjdG9yKCl7aWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbT1udWxsLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fYm5SdWxlPW51bGwsdGhpcy5fZW5kcG9pbnRNYXA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGduLk1PRDJfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbT10LHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpLHRoaXMuX2JuUnVsZT1lfX1zdGF0aWMgZ2V0Qm91bmRhcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBpaShhcmd1bWVudHNbMF0pLmdldEJvdW5kYXJ5KCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgaWkoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkuZ2V0Qm91bmRhcnkoKX19Ym91bmRhcnlNdWx0aUxpbmVTdHJpbmcodCl7aWYodGhpcy5fZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7Y29uc3QgZT10aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpO3JldHVybiAxPT09ZS5sZW5ndGg/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoZVswXSk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoZSl9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5fZ2VvbSBpbnN0YW5jZW9mICQ/dGhpcy5ib3VuZGFyeUxpbmVTdHJpbmcodGhpcy5fZ2VvbSk6dGhpcy5fZ2VvbSBpbnN0YW5jZW9mIFN0P3RoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5fZ2VvbSk6dGhpcy5fZ2VvbS5nZXRCb3VuZGFyeSgpfWJvdW5kYXJ5TGluZVN0cmluZyh0KXtpZih0aGlzLl9nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTtpZih0LmlzQ2xvc2VkKCkpe3JldHVybiB0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KDIpP3QuZ2V0U3RhcnRQb2ludCgpOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX1yZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludChbdC5nZXRTdGFydFBvaW50KCksdC5nZXRFbmRQb2ludCgpXSl9Z2V0RW1wdHlNdWx0aVBvaW50KCl7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX1jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBMO3RoaXMuX2VuZHBvaW50TWFwPW5ldyBXbjtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTswIT09bi5nZXROdW1Qb2ludHMoKSYmKHRoaXMuYWRkRW5kcG9pbnQobi5nZXRDb29yZGluYXRlTigwKSksdGhpcy5hZGRFbmRwb2ludChuLmdldENvb3JkaW5hdGVOKG4uZ2V0TnVtUG9pbnRzKCktMSkpKX1mb3IobGV0IHQ9dGhpcy5fZW5kcG9pbnRNYXAuZW50cnlTZXQoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0VmFsdWUoKS5jb3VudDt0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KHMpJiZlLmFkZChuLmdldEtleSgpKX1yZXR1cm4gX3QudG9Db29yZGluYXRlQXJyYXkoZSl9YWRkRW5kcG9pbnQodCl7bGV0IGU9dGhpcy5fZW5kcG9pbnRNYXAuZ2V0KHQpO251bGw9PT1lJiYoZT1uZXcgcmksdGhpcy5fZW5kcG9pbnRNYXAucHV0KHQsZSkpLGUuY291bnQrK319bGV0IHJpPWNsYXNze2NvbnN0cnVjdG9yKCl7cmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5jb3VudD1udWxsfX07Y2xhc3Mgb2l7Y29uc3RydWN0b3IoKXtvaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9ITAsdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSFlLmlzSW5Cb3VuZGFyeSgyKX19c3RhdGljIGlzU2ltcGxlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgb2koYXJndW1lbnRzWzBdKS5pc1NpbXBsZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IG9pKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLmlzU2ltcGxlKCl9fWlzU2ltcGxlTXVsdGlQb2ludCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtjb25zdCBlPW5ldyBhdDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKS5nZXRDb29yZGluYXRlKCk7aWYoZS5jb250YWlucyhzKSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249cywhMTtlLmFkZChzKX1yZXR1cm4hMH1pc1NpbXBsZVBvbHlnb25hbCh0KXtmb3IobGV0IGU9eWUuZ2V0TGluZXModCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYoIXRoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KSlyZXR1cm4hMX1yZXR1cm4hMH1oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbih0KXtjb25zdCBlPW5ldyBXbjtmb3IobGV0IG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkscz10LmlzQ2xvc2VkKCksaT10LmdldENvb3JkaW5hdGUoMCk7dGhpcy5hZGRFbmRwb2ludChlLGkscyk7Y29uc3Qgcj10LmdldENvb3JkaW5hdGUodC5nZXROdW1Qb2ludHMoKS0xKTt0aGlzLmFkZEVuZHBvaW50KGUscixzKX1mb3IobGV0IHQ9ZS52YWx1ZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtpZihlLmlzQ2xvc2VkJiYyIT09ZS5kZWdyZWUpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPWUuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfWdldE5vblNpbXBsZUxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9ufWlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Y29uc3QgZT1uZXcgYXMoMCx0KSxuPW5ldyBqdCxzPWUuY29tcHV0ZVNlbGZOb2RlcyhuLCEwKTtyZXR1cm4hcy5oYXNJbnRlcnNlY3Rpb24oKXx8KHMuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXMuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6IXRoaXMuaGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSkmJighdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yfHwhdGhpcy5oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbihlKSkpfWhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpO2ZvcihsZXQgZT10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYoIXQuaXNFbmRQb2ludChuKSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249dC5nZXRDb29yZGluYXRlKCksITB9fXJldHVybiExfWFkZEVuZHBvaW50KHQsZSxuKXtsZXQgcz10LmdldChlKTtudWxsPT09cyYmKHM9bmV3IGxpKGUpLHQucHV0KGUscykpLHMuYWRkRW5kcG9pbnQobil9Y29tcHV0ZVNpbXBsZSh0KXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCwhIXQuaXNFbXB0eSgpfHwodCBpbnN0YW5jZW9mICR8fHQgaW5zdGFuY2VvZiBTdD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIHV0P3RoaXMuaXNTaW1wbGVNdWx0aVBvaW50KHQpOkkodCxpdCk/dGhpcy5pc1NpbXBsZVBvbHlnb25hbCh0KTohKHQgaW5zdGFuY2VvZiBodCl8fHRoaXMuaXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCkpfWlzU2ltcGxlKCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsdGhpcy5jb21wdXRlU2ltcGxlKHRoaXMuX2lucHV0R2VvbSl9aXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuY29tcHV0ZVNpbXBsZShuKSlyZXR1cm4hMX1yZXR1cm4hMH19Y2xhc3MgbGl7Y29uc3RydWN0b3IoKXtsaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnB0PW51bGwsdGhpcy5pc0Nsb3NlZD1udWxsLHRoaXMuZGVncmVlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wdD10LHRoaXMuaXNDbG9zZWQ9ITEsdGhpcy5kZWdyZWU9MH1hZGRFbmRwb2ludCh0KXt0aGlzLmRlZ3JlZSsrLHRoaXMuaXNDbG9zZWR8PXR9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLnB0fX1vaS5FbmRwb2ludEluZm89bGk7Y2xhc3MgYWl7Y29uc3RydWN0b3IoKXthaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPWFpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMsdGhpcy5fZW5kQ2FwU3R5bGU9YWkuQ0FQX1JPVU5ELHRoaXMuX2pvaW5TdHlsZT1haS5KT0lOX1JPVU5ELHRoaXMuX21pdHJlTGltaXQ9YWkuREVGQVVMVF9NSVRSRV9MSU1JVCx0aGlzLl9pc1NpbmdsZVNpZGVkPSExLHRoaXMuX3NpbXBsaWZ5RmFjdG9yPWFpLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpLHRoaXMuc2V0RW5kQ2FwU3R5bGUoZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpLHRoaXMuc2V0RW5kQ2FwU3R5bGUoZSksdGhpcy5zZXRKb2luU3R5bGUobiksdGhpcy5zZXRNaXRyZUxpbWl0KHMpfX1zdGF0aWMgYnVmZmVyRGlzdGFuY2VFcnJvcih0KXtjb25zdCBlPU1hdGguUEkvMi90O3JldHVybiAxLU1hdGguY29zKGUvMil9Z2V0RW5kQ2FwU3R5bGUoKXtyZXR1cm4gdGhpcy5fZW5kQ2FwU3R5bGV9aXNTaW5nbGVTaWRlZCgpe3JldHVybiB0aGlzLl9pc1NpbmdsZVNpZGVkfXNldFF1YWRyYW50U2VnbWVudHModCl7dGhpcy5fcXVhZHJhbnRTZWdtZW50cz10LDA9PT10aGlzLl9xdWFkcmFudFNlZ21lbnRzJiYodGhpcy5fam9pblN0eWxlPWFpLkpPSU5fQkVWRUwpLHRoaXMuX3F1YWRyYW50U2VnbWVudHM8MCYmKHRoaXMuX2pvaW5TdHlsZT1haS5KT0lOX01JVFJFLHRoaXMuX21pdHJlTGltaXQ9TWF0aC5hYnModGhpcy5fcXVhZHJhbnRTZWdtZW50cykpLHQ8PTAmJih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPTEpLHRoaXMuX2pvaW5TdHlsZSE9PWFpLkpPSU5fUk9VTkQmJih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPWFpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMpfWdldEpvaW5TdHlsZSgpe3JldHVybiB0aGlzLl9qb2luU3R5bGV9c2V0Sm9pblN0eWxlKHQpe3RoaXMuX2pvaW5TdHlsZT10fXNldFNpbXBsaWZ5RmFjdG9yKHQpe3RoaXMuX3NpbXBsaWZ5RmFjdG9yPXQ8MD8wOnR9Z2V0U2ltcGxpZnlGYWN0b3IoKXtyZXR1cm4gdGhpcy5fc2ltcGxpZnlGYWN0b3J9Z2V0UXVhZHJhbnRTZWdtZW50cygpe3JldHVybiB0aGlzLl9xdWFkcmFudFNlZ21lbnRzfXNldEVuZENhcFN0eWxlKHQpe3RoaXMuX2VuZENhcFN0eWxlPXR9Z2V0TWl0cmVMaW1pdCgpe3JldHVybiB0aGlzLl9taXRyZUxpbWl0fXNldE1pdHJlTGltaXQodCl7dGhpcy5fbWl0cmVMaW1pdD10fXNldFNpbmdsZVNpZGVkKHQpe3RoaXMuX2lzU2luZ2xlU2lkZWQ9dH19YWkuQ0FQX1JPVU5EPTEsYWkuQ0FQX0ZMQVQ9MixhaS5DQVBfU1FVQVJFPTMsYWkuSk9JTl9ST1VORD0xLGFpLkpPSU5fTUlUUkU9MixhaS5KT0lOX0JFVkVMPTMsYWkuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUz04LGFpLkRFRkFVTFRfTUlUUkVfTElNSVQ9NSxhaS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUj0uMDE7Y2xhc3MgY2l7Y29uc3RydWN0b3IoKXtjaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9taW5JbmRleD0tMSx0aGlzLl9taW5Db29yZD1udWxsLHRoaXMuX21pbkRlPW51bGwsdGhpcy5fb3JpZW50ZWREZT1udWxsfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fbWluQ29vcmR9Z2V0UmlnaHRtb3N0U2lkZSh0LGUpe2xldCBuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUpO3JldHVybiBuPDAmJihuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUtMSkpLG48MCYmKHRoaXMuX21pbkNvb3JkPW51bGwsdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCkpLG59ZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpe2NvbnN0IHQ9dGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zy5pc1RydWUodGhpcy5fbWluSW5kZXg+MCYmdGhpcy5fbWluSW5kZXg8dC5sZW5ndGgsXCJyaWdodG1vc3QgcG9pbnQgZXhwZWN0ZWQgdG8gYmUgaW50ZXJpb3IgdmVydGV4IG9mIGVkZ2VcIik7Y29uc3QgZT10W3RoaXMuX21pbkluZGV4LTFdLG49dFt0aGlzLl9taW5JbmRleCsxXSxzPXEuaW5kZXgodGhpcy5fbWluQ29vcmQsbixlKTtsZXQgaT0hMTsoZS55PHRoaXMuX21pbkNvb3JkLnkmJm4ueTx0aGlzLl9taW5Db29yZC55JiZzPT09cS5DT1VOVEVSQ0xPQ0tXSVNFfHxlLnk+dGhpcy5fbWluQ29vcmQueSYmbi55PnRoaXMuX21pbkNvb3JkLnkmJnM9PT1xLkNMT0NLV0lTRSkmJihpPSEwKSxpJiYodGhpcy5fbWluSW5kZXg9dGhpcy5fbWluSW5kZXgtMSl9Z2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUpe2NvbnN0IG49dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlPDB8fGUrMT49bi5sZW5ndGgpcmV0dXJuLTE7aWYobltlXS55PT09bltlKzFdLnkpcmV0dXJuLTE7bGV0IHM9Ym4uTEVGVDtyZXR1cm4gbltlXS55PG5bZSsxXS55JiYocz1ibi5SSUdIVCksc31nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX29yaWVudGVkRGV9Y2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpe2NvbnN0IGU9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoLTE7bisrKShudWxsPT09dGhpcy5fbWluQ29vcmR8fGVbbl0ueD50aGlzLl9taW5Db29yZC54KSYmKHRoaXMuX21pbkRlPXQsdGhpcy5fbWluSW5kZXg9bix0aGlzLl9taW5Db29yZD1lW25dKX1maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpe2NvbnN0IHQ9dGhpcy5fbWluRGUuZ2V0Tm9kZSgpLmdldEVkZ2VzKCk7dGhpcy5fbWluRGU9dC5nZXRSaWdodG1vc3RFZGdlKCksdGhpcy5fbWluRGUuaXNGb3J3YXJkKCl8fCh0aGlzLl9taW5EZT10aGlzLl9taW5EZS5nZXRTeW0oKSx0aGlzLl9taW5JbmRleD10aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSl9ZmluZEVkZ2UodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5pc0ZvcndhcmQoKSYmdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCl9Zy5pc1RydWUoMCE9PXRoaXMuX21pbkluZGV4fHx0aGlzLl9taW5Db29yZC5lcXVhbHModGhpcy5fbWluRGUuZ2V0Q29vcmRpbmF0ZSgpKSxcImluY29uc2lzdGVuY3kgaW4gcmlnaHRtb3N0IHByb2Nlc3NpbmdcIiksMD09PXRoaXMuX21pbkluZGV4P3RoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKTp0aGlzLmZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKSx0aGlzLl9vcmllbnRlZERlPXRoaXMuX21pbkRlO3RoaXMuZ2V0UmlnaHRtb3N0U2lkZSh0aGlzLl9taW5EZSx0aGlzLl9taW5JbmRleCk9PT1ibi5MRUZUJiYodGhpcy5fb3JpZW50ZWREZT10aGlzLl9taW5EZS5nZXRTeW0oKSl9fWNsYXNzIGhpe2NvbnN0cnVjdG9yKCl7dGhpcy5hcnJheT1bXX1hZGRMYXN0KHQpe3RoaXMuYXJyYXkucHVzaCh0KX1yZW1vdmVGaXJzdCgpe3JldHVybiB0aGlzLmFycmF5LnNoaWZ0KCl9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9fWNsYXNzIHVpe2NvbnN0cnVjdG9yKCl7dWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmluZGVyPW51bGwsdGhpcy5fZGlyRWRnZUxpc3Q9bmV3IEwsdGhpcy5fbm9kZXM9bmV3IEwsdGhpcy5fcmlnaHRNb3N0Q29vcmQ9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLl9maW5kZXI9bmV3IGNpfWNsZWFyVmlzaXRlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRWaXNpdGVkKCExKX19Z2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZH1jb21wdXRlTm9kZURlcHRoKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzVmlzaXRlZCgpfHx0LmdldFN5bSgpLmlzVmlzaXRlZCgpKXtlPXQ7YnJlYWt9fWlmKG51bGw9PT1lKXRocm93IG5ldyBpcyhcInVuYWJsZSB0byBmaW5kIGVkZ2UgdG8gY29tcHV0ZSBkZXB0aHMgYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpO3QuZ2V0RWRnZXMoKS5jb21wdXRlRGVwdGhzKGUpO2ZvcihsZXQgZT10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLmNvcHlTeW1EZXB0aHModCl9fWNvbXB1dGVEZXB0aCh0KXt0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9maW5kZXIuZ2V0RWRnZSgpO2UuZ2V0Tm9kZSgpLGUuZ2V0TGFiZWwoKSxlLnNldEVkZ2VEZXB0aHMoYm4uUklHSFQsdCksdGhpcy5jb3B5U3ltRGVwdGhzKGUpLHRoaXMuY29tcHV0ZURlcHRocyhlKX1jcmVhdGUodCl7dGhpcy5hZGRSZWFjaGFibGUodCksdGhpcy5fZmluZGVyLmZpbmRFZGdlKHRoaXMuX2RpckVkZ2VMaXN0KSx0aGlzLl9yaWdodE1vc3RDb29yZD10aGlzLl9maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpfWZpbmRSZXN1bHRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmdldERlcHRoKGJuLlJJR0hUKT49MSYmZS5nZXREZXB0aChibi5MRUZUKTw9MCYmIWUuaXNJbnRlcmlvckFyZWFFZGdlKCkmJmUuc2V0SW5SZXN1bHQoITApfX1jb21wdXRlRGVwdGhzKHQpe2NvbnN0IGU9bmV3IEV0LG49bmV3IGhpLHM9dC5nZXROb2RlKCk7Zm9yKG4uYWRkTGFzdChzKSxlLmFkZChzKSx0LnNldFZpc2l0ZWQoITApOyFuLmlzRW1wdHkoKTspe2NvbnN0IHQ9bi5yZW1vdmVGaXJzdCgpO2UuYWRkKHQpLHRoaXMuY29tcHV0ZU5vZGVEZXB0aCh0KTtmb3IobGV0IHM9dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLmdldFN5bSgpO2lmKHQuaXNWaXNpdGVkKCkpY29udGludWU7Y29uc3QgaT10LmdldE5vZGUoKTtlLmNvbnRhaW5zKGkpfHwobi5hZGRMYXN0KGkpLGUuYWRkKGkpKX19fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX3JpZ2h0TW9zdENvb3JkLng8ZS5fcmlnaHRNb3N0Q29vcmQueD8tMTp0aGlzLl9yaWdodE1vc3RDb29yZC54PmUuX3JpZ2h0TW9zdENvb3JkLng/MTowfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7Y29uc3QgdD1uZXcgTztmb3IobGV0IGU9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aC0xO2UrKyl0LmV4cGFuZFRvSW5jbHVkZShuW2VdKX10aGlzLl9lbnY9dH1yZXR1cm4gdGhpcy5fZW52fWFkZFJlYWNoYWJsZSh0KXtjb25zdCBlPW5ldyBlbjtmb3IoZS5hZGQodCk7IWUuZW1wdHkoKTspe2NvbnN0IHQ9ZS5wb3AoKTt0aGlzLmFkZCh0LGUpfX1jb3B5U3ltRGVwdGhzKHQpe2NvbnN0IGU9dC5nZXRTeW0oKTtlLnNldERlcHRoKGJuLkxFRlQsdC5nZXREZXB0aChibi5SSUdIVCkpLGUuc2V0RGVwdGgoYm4uUklHSFQsdC5nZXREZXB0aChibi5MRUZUKSl9YWRkKHQsZSl7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLl9ub2Rlcy5hZGQodCk7Zm9yKGxldCBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9kaXJFZGdlTGlzdC5hZGQodCk7Y29uc3Qgcz10LmdldFN5bSgpLmdldE5vZGUoKTtzLmlzVmlzaXRlZCgpfHxlLnB1c2gocyl9fWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWdldERpcmVjdGVkRWRnZXMoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZUxpc3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1sZXQgZ2k9Y2xhc3N7Y29uc3RydWN0b3IoKXtnaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zdGFydERlPW51bGwsdGhpcy5fbWF4Tm9kZURlZ3JlZT0tMSx0aGlzLl9lZGdlcz1uZXcgTCx0aGlzLl9wdHM9bmV3IEwsdGhpcy5fbGFiZWw9bmV3IEJuKFF0Lk5PTkUpLHRoaXMuX3Jpbmc9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2hvbGVzPW5ldyBMLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLmNvbXB1dGVQb2ludHModCksdGhpcy5jb21wdXRlUmluZygpfX1jb21wdXRlUmluZygpe2lmKG51bGwhPT10aGlzLl9yaW5nKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX3B0cy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wdHMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuX3B0cy5nZXQoZSk7dGhpcy5fcmluZz10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KSx0aGlzLl9pc0hvbGU9cS5pc0NDVyh0aGlzLl9yaW5nLmdldENvb3JkaW5hdGVzKCkpfWlzSXNvbGF0ZWQoKXtyZXR1cm4gMT09PXRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKX1jb21wdXRlUG9pbnRzKHQpe3RoaXMuX3N0YXJ0RGU9dDtsZXQgZT10LG49ITA7ZG97aWYobnVsbD09PWUpdGhyb3cgbmV3IGlzKFwiRm91bmQgbnVsbCBEaXJlY3RlZEVkZ2VcIik7aWYoZS5nZXRFZGdlUmluZygpPT09dGhpcyl0aHJvdyBuZXcgaXMoXCJEaXJlY3RlZCBFZGdlIHZpc2l0ZWQgdHdpY2UgZHVyaW5nIHJpbmctYnVpbGRpbmcgYXQgXCIrZS5nZXRDb29yZGluYXRlKCkpO3RoaXMuX2VkZ2VzLmFkZChlKTtjb25zdCB0PWUuZ2V0TGFiZWwoKTtnLmlzVHJ1ZSh0LmlzQXJlYSgpKSx0aGlzLm1lcmdlTGFiZWwodCksdGhpcy5hZGRQb2ludHMoZS5nZXRFZGdlKCksZS5pc0ZvcndhcmQoKSxuKSxuPSExLHRoaXMuc2V0RWRnZVJpbmcoZSx0aGlzKSxlPXRoaXMuZ2V0TmV4dChlKX13aGlsZShlIT09dGhpcy5fc3RhcnREZSl9Z2V0TGluZWFyUmluZygpe3JldHVybiB0aGlzLl9yaW5nfWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0cy5nZXQodCl9Y29tcHV0ZU1heE5vZGVEZWdyZWUoKXt0aGlzLl9tYXhOb2RlRGVncmVlPTA7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3tjb25zdCBlPXQuZ2V0Tm9kZSgpLmdldEVkZ2VzKCkuZ2V0T3V0Z29pbmdEZWdyZWUodGhpcyk7ZT50aGlzLl9tYXhOb2RlRGVncmVlJiYodGhpcy5fbWF4Tm9kZURlZ3JlZT1lKSx0PXRoaXMuZ2V0TmV4dCh0KX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSk7dGhpcy5fbWF4Tm9kZURlZ3JlZSo9Mn1hZGRQb2ludHModCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpO2lmKGUpe2xldCB0PTE7biYmKHQ9MCk7Zm9yKGxldCBlPXQ7ZTxzLmxlbmd0aDtlKyspdGhpcy5fcHRzLmFkZChzW2VdKX1lbHNle2xldCB0PXMubGVuZ3RoLTI7biYmKHQ9cy5sZW5ndGgtMSk7Zm9yKGxldCBlPXQ7ZT49MDtlLS0pdGhpcy5fcHRzLmFkZChzW2VdKX19aXNIb2xlKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX1zZXRJblJlc3VsdCgpe2xldCB0PXRoaXMuX3N0YXJ0RGU7ZG97dC5nZXRFZGdlKCkuc2V0SW5SZXN1bHQoITApLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpfWNvbnRhaW5zUG9pbnQodCl7Y29uc3QgZT10aGlzLmdldExpbmVhclJpbmcoKTtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuY29udGFpbnModCkpcmV0dXJuITE7aWYoIVVlLmlzSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKSlyZXR1cm4hMTtmb3IobGV0IGU9dGhpcy5faG9sZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITF9cmV0dXJuITB9YWRkSG9sZSh0KXt0aGlzLl9ob2xlcy5hZGQodCl9aXNTaGVsbCgpe3JldHVybiBudWxsPT09dGhpcy5fc2hlbGx9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9Z2V0TWF4Tm9kZURlZ3JlZSgpe3JldHVybiB0aGlzLl9tYXhOb2RlRGVncmVlPDAmJnRoaXMuY29tcHV0ZU1heE5vZGVEZWdyZWUoKSx0aGlzLl9tYXhOb2RlRGVncmVlfWdldFNoZWxsKCl7cmV0dXJuIHRoaXMuX3NoZWxsfW1lcmdlTGFiZWwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQsMCksdGhpcy5tZXJnZUxhYmVsKHQsMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0uZ2V0TG9jYXRpb24odCxibi5SSUdIVCk7aWYoZT09PVF0Lk5PTkUpcmV0dXJuIG51bGw7aWYodGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24odCk9PT1RdC5OT05FKXJldHVybiB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUpLG51bGx9fXNldFNoZWxsKHQpe3RoaXMuX3NoZWxsPXQsbnVsbCE9PXQmJnQuYWRkSG9sZSh0aGlzKX10b1BvbHlnb24odCl7Y29uc3QgZT1uZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMuc2l6ZSgpO3QrKyllW3RdPXRoaXMuX2hvbGVzLmdldCh0KS5nZXRMaW5lYXJSaW5nKCk7cmV0dXJuIHQuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSxlKX19O2NsYXNzIGRpIGV4dGVuZHMgZ2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLGRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2dpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1zZXRFZGdlUmluZyh0LGUpe3Quc2V0TWluRWRnZVJpbmcoZSl9Z2V0TmV4dCh0KXtyZXR1cm4gdC5nZXROZXh0TWluKCl9fWNsYXNzIF9pIGV4dGVuZHMgZ2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLF9pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2dpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1idWlsZE1pbmltYWxSaW5ncygpe2NvbnN0IHQ9bmV3IEw7bGV0IGU9dGhpcy5fc3RhcnREZTtkb3tpZihudWxsPT09ZS5nZXRNaW5FZGdlUmluZygpKXtjb25zdCBuPW5ldyBkaShlLHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7dC5hZGQobil9ZT1lLmdldE5leHQoKX13aGlsZShlIT09dGhpcy5fc3RhcnREZSk7cmV0dXJuIHR9c2V0RWRnZVJpbmcodCxlKXt0LnNldEVkZ2VSaW5nKGUpfWxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpe2xldCB0PXRoaXMuX3N0YXJ0RGU7ZG97dC5nZXROb2RlKCkuZ2V0RWRnZXMoKS5saW5rTWluaW1hbERpcmVjdGVkRWRnZXModGhpcyksdD10LmdldE5leHQoKX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSl9Z2V0TmV4dCh0KXtyZXR1cm4gdC5nZXROZXh0KCl9fWNsYXNzIHBpe2NvbnN0cnVjdG9yKCl7cGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5fc2hlbGxMaXN0PW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21ldHJ5RmFjdG9yeT10fXN0YXRpYyBmaW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSl7Y29uc3Qgbj10LmdldExpbmVhclJpbmcoKSxzPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2xldCBpPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscj1udWxsLG89bnVsbDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxsPWUuZ2V0TGluZWFyUmluZygpLGE9bC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoYS5lcXVhbHMocykpY29udGludWU7aWYoIWEuY29udGFpbnMocykpY29udGludWU7aT1fdC5wdE5vdEluTGlzdChuLmdldENvb3JkaW5hdGVzKCksbC5nZXRDb29yZGluYXRlcygpKTtsZXQgYz0hMTtVZS5pc0luUmluZyhpLGwuZ2V0Q29vcmRpbmF0ZXMoKSkmJihjPSEwKSxjJiYobnVsbD09PXJ8fG8uY29udGFpbnMoYSkpJiYocj1lLG89ci5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1yZXR1cm4gcn1zb3J0U2hlbGxzQW5kSG9sZXModCxlLG4pe2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNIb2xlKCk/bi5hZGQodCk6ZS5hZGQodCl9fWNvbXB1dGVQb2x5Z29ucyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLnRvUG9seWdvbih0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKHQpfXJldHVybiBlfXBsYWNlRnJlZUhvbGVzKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7aWYobnVsbD09PWUuZ2V0U2hlbGwoKSl7Y29uc3Qgbj1waS5maW5kRWRnZVJpbmdDb250YWluaW5nKGUsdCk7aWYobnVsbD09PW4pdGhyb3cgbmV3IGlzKFwidW5hYmxlIHRvIGFzc2lnbiBob2xlIHRvIGEgc2hlbGxcIixlLmdldENvb3JkaW5hdGUoMCkpO2Uuc2V0U2hlbGwobil9fX1idWlsZE1pbmltYWxFZGdlUmluZ3ModCxlLG4pe2NvbnN0IHM9bmV3IEw7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCk7aWYodC5nZXRNYXhOb2RlRGVncmVlKCk+Mil7dC5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTtjb25zdCBzPXQuYnVpbGRNaW5pbWFsUmluZ3MoKSxpPXRoaXMuZmluZFNoZWxsKHMpO251bGwhPT1pPyh0aGlzLnBsYWNlUG9seWdvbkhvbGVzKGkscyksZS5hZGQoaSkpOm4uYWRkQWxsKHMpfWVsc2Ugcy5hZGQodCl9cmV0dXJuIHN9YnVpbGRNYXhpbWFsRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc0luUmVzdWx0KCkmJnQuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmbnVsbD09PXQuZ2V0RWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgX2kodCx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKG4pLG4uc2V0SW5SZXN1bHQoKX19cmV0dXJuIGV9cGxhY2VQb2x5Z29uSG9sZXModCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtlLmlzSG9sZSgpJiZlLnNldFNoZWxsKHQpfX1nZXRQb2x5Z29ucygpe3JldHVybiB0aGlzLmNvbXB1dGVQb2x5Z29ucyh0aGlzLl9zaGVsbExpc3QpfWZpbmRTaGVsbCh0KXtsZXQgZT0wLG49bnVsbDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzSG9sZSgpfHwobj10LGUrKyl9cmV0dXJuIGcuaXNUcnVlKGU8PTEsXCJmb3VuZCB0d28gc2hlbGxzIGluIE1pbmltYWxFZGdlUmluZyBsaXN0XCIpLG59YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQuZ2V0RWRnZUVuZHMoKSx0LmdldE5vZGVzKCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xzLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKGUpO2NvbnN0IG49dGhpcy5idWlsZE1heGltYWxFZGdlUmluZ3ModCkscz1uZXcgTCxpPXRoaXMuYnVpbGRNaW5pbWFsRWRnZVJpbmdzKG4sdGhpcy5fc2hlbGxMaXN0LHMpO3RoaXMuc29ydFNoZWxsc0FuZEhvbGVzKGksdGhpcy5fc2hlbGxMaXN0LHMpLHRoaXMucGxhY2VGcmVlSG9sZXModGhpcy5fc2hlbGxMaXN0LHMpfX19Y2xhc3MgbWl7Y29uc3RydWN0b3IoKXttaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dExpbmU9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbD1udWxsLHRoaXMuX2lzRGVsZXRlZD1udWxsLHRoaXMuX2FuZ2xlT3JpZW50YXRpb249cS5DT1VOVEVSQ0xPQ0tXSVNFO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0TGluZT10fXN0YXRpYyBzaW1wbGlmeSh0LGUpe3JldHVybiBuZXcgbWkodCkuc2ltcGxpZnkoZSl9aXNEZWxldGFibGUodCxlLG4scyl7Y29uc3QgaT10aGlzLl9pbnB1dExpbmVbdF0scj10aGlzLl9pbnB1dExpbmVbZV0sbz10aGlzLl9pbnB1dExpbmVbbl07cmV0dXJuISF0aGlzLmlzQ29uY2F2ZShpLHIsbykmJighIXRoaXMuaXNTaGFsbG93KGkscixvLHMpJiZ0aGlzLmlzU2hhbGxvd1NhbXBsZWQoaSxyLHQsbixzKSl9ZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCl7bGV0IHQ9MSxlPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpLHM9ITE7Zm9yKDtuPHRoaXMuX2lucHV0TGluZS5sZW5ndGg7KXtsZXQgaT0hMTt0aGlzLmlzRGVsZXRhYmxlKHQsZSxuLHRoaXMuX2Rpc3RhbmNlVG9sKSYmKHRoaXMuX2lzRGVsZXRlZFtlXT1taS5ERUxFVEUsaT0hMCxzPSEwKSx0PWk/bjplLGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSl9cmV0dXJuIHN9aXNTaGFsbG93Q29uY2F2aXR5KHQsZSxuLHMpe2lmKCEocS5pbmRleCh0LGUsbik9PT10aGlzLl9hbmdsZU9yaWVudGF0aW9uKSlyZXR1cm4hMTtyZXR1cm4gei5wb2ludFRvU2VnbWVudChlLHQsbik8c31pc1NoYWxsb3dTYW1wbGVkKHQsZSxuLHMsaSl7bGV0IHI9TWF0aC50cnVuYygocy1uKS9taS5OVU1fUFRTX1RPX0NIRUNLKTtyPD0wJiYocj0xKTtmb3IobGV0IG89bjtvPHM7bys9cilpZighdGhpcy5pc1NoYWxsb3codCxlLHRoaXMuX2lucHV0TGluZVtvXSxpKSlyZXR1cm4hMTtyZXR1cm4hMH1pc0NvbmNhdmUodCxlLG4pe3JldHVybiBxLmluZGV4KHQsZSxuKT09PXRoaXMuX2FuZ2xlT3JpZW50YXRpb259c2ltcGxpZnkodCl7dGhpcy5fZGlzdGFuY2VUb2w9TWF0aC5hYnModCksdDwwJiYodGhpcy5fYW5nbGVPcmllbnRhdGlvbj1xLkNMT0NLV0lTRSksdGhpcy5faXNEZWxldGVkPW5ldyBBcnJheSh0aGlzLl9pbnB1dExpbmUubGVuZ3RoKS5maWxsKG51bGwpO2xldCBlPSExO2Rve2U9dGhpcy5kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMoKX13aGlsZShlKTtyZXR1cm4gdGhpcy5jb2xsYXBzZUxpbmUoKX1maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KXtsZXQgZT10KzE7Zm9yKDtlPHRoaXMuX2lucHV0TGluZS5sZW5ndGgmJnRoaXMuX2lzRGVsZXRlZFtlXT09PW1pLkRFTEVURTspZSsrO3JldHVybiBlfWlzU2hhbGxvdyh0LGUsbixzKXtyZXR1cm4gei5wb2ludFRvU2VnbWVudChlLHQsbik8c31jb2xsYXBzZUxpbmUoKXtjb25zdCB0PW5ldyBSO2ZvcihsZXQgZT0wO2U8dGhpcy5faW5wdXRMaW5lLmxlbmd0aDtlKyspdGhpcy5faXNEZWxldGVkW2VdIT09bWkuREVMRVRFJiZ0LmFkZCh0aGlzLl9pbnB1dExpbmVbZV0pO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9fW1pLklOSVQ9MCxtaS5ERUxFVEU9MSxtaS5LRUVQPTEsbWkuTlVNX1BUU19UT19DSEVDSz0xMDtjbGFzcyBmaXtjb25zdHJ1Y3Rvcigpe2ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0TGlzdD1udWxsLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlPTAsdGhpcy5fcHRMaXN0PW5ldyBMfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0TGlzdC50b0FycmF5KGZpLkNPT1JESU5BVEVfQVJSQVlfVFlQRSl9c2V0UHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fcHJlY2lzaW9uTW9kZWw9dH1hZGRQdCh0KXtjb25zdCBlPW5ldyBtKHQpO2lmKHRoaXMuX3ByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGUpLHRoaXMuaXNSZWR1bmRhbnQoZSkpcmV0dXJuIG51bGw7dGhpcy5fcHRMaXN0LmFkZChlKX1yZXZlcnNlKCl7fWFkZFB0cyh0LGUpe2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdGhpcy5hZGRQdCh0W2VdKTtlbHNlIGZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXRoaXMuYWRkUHQodFtlXSl9aXNSZWR1bmRhbnQodCl7aWYodGhpcy5fcHRMaXN0LnNpemUoKTwxKXJldHVybiExO2NvbnN0IGU9dGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTEpO3JldHVybiB0LmRpc3RhbmNlKGUpPHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZX10b1N0cmluZygpe3JldHVybihuZXcgTHQpLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKS50b1N0cmluZygpfWNsb3NlUmluZygpe2lmKHRoaXMuX3B0TGlzdC5zaXplKCk8MSlyZXR1cm4gbnVsbDtjb25zdCB0PW5ldyBtKHRoaXMuX3B0TGlzdC5nZXQoMCkpLGU9dGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTEpO2lmKHQuZXF1YWxzKGUpKXJldHVybiBudWxsO3RoaXMuX3B0TGlzdC5hZGQodCl9c2V0TWluaW11bVZlcnRleERpc3RhbmNlKHQpe3RoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZT10fX1maS5DT09SRElOQVRFX0FSUkFZX1RZUEU9bmV3IEFycmF5KDApLmZpbGwobnVsbCk7Y2xhc3MgeWl7Y29uc3RydWN0b3IoKXt5aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9tYXhDdXJ2ZVNlZ21lbnRFcnJvcj0wLHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bT1udWxsLHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3I9MSx0aGlzLl9zZWdMaXN0PW51bGwsdGhpcy5fZGlzdGFuY2U9MCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2J1ZlBhcmFtcz1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5fczA9bnVsbCx0aGlzLl9zMT1udWxsLHRoaXMuX3MyPW51bGwsdGhpcy5fc2VnMD1uZXcgS3QsdGhpcy5fc2VnMT1uZXcgS3QsdGhpcy5fb2Zmc2V0MD1uZXcgS3QsdGhpcy5fb2Zmc2V0MT1uZXcgS3QsdGhpcy5fc2lkZT0wLHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wcmVjaXNpb25Nb2RlbD10LHRoaXMuX2J1ZlBhcmFtcz1lLHRoaXMuX2xpPW5ldyBqdCx0aGlzLl9maWxsZXRBbmdsZVF1YW50dW09TWF0aC5QSS8yL2UuZ2V0UXVhZHJhbnRTZWdtZW50cygpLGUuZ2V0UXVhZHJhbnRTZWdtZW50cygpPj04JiZlLmdldEpvaW5TdHlsZSgpPT09YWkuSk9JTl9ST1VORCYmKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3I9eWkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1IpLHRoaXMuaW5pdChuKX1hZGROZXh0U2VnbWVudCh0LGUpe2lmKHRoaXMuX3MwPXRoaXMuX3MxLHRoaXMuX3MxPXRoaXMuX3MyLHRoaXMuX3MyPXQsdGhpcy5fc2VnMC5zZXRDb29yZGluYXRlcyh0aGlzLl9zMCx0aGlzLl9zMSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcwLHRoaXMuX3NpZGUsdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MCksdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyh0aGlzLl9zMSx0aGlzLl9zMiksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLHRoaXMuX3NpZGUsdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MSksdGhpcy5fczEuZXF1YWxzKHRoaXMuX3MyKSlyZXR1cm4gbnVsbDtjb25zdCBuPXEuaW5kZXgodGhpcy5fczAsdGhpcy5fczEsdGhpcy5fczIpLHM9bj09PXEuQ0xPQ0tXSVNFJiZ0aGlzLl9zaWRlPT09Ym4uTEVGVHx8bj09PXEuQ09VTlRFUkNMT0NLV0lTRSYmdGhpcy5fc2lkZT09PWJuLlJJR0hUOzA9PT1uP3RoaXMuYWRkQ29sbGluZWFyKGUpOnM/dGhpcy5hZGRPdXRzaWRlVHVybihuLGUpOnRoaXMuYWRkSW5zaWRlVHVybihuLGUpfWFkZExpbmVFbmRDYXAodCxlKXtjb25zdCBuPW5ldyBLdCh0LGUpLHM9bmV3IEt0O3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixibi5MRUZULHRoaXMuX2Rpc3RhbmNlLHMpO2NvbnN0IGk9bmV3IEt0O3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixibi5SSUdIVCx0aGlzLl9kaXN0YW5jZSxpKTtjb25zdCByPWUueC10Lngsbz1lLnktdC55LGw9TWF0aC5hdGFuMihvLHIpO3N3aXRjaCh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBhaS5DQVBfUk9VTkQ6dGhpcy5fc2VnTGlzdC5hZGRQdChzLnAxKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KGUsbCtNYXRoLlBJLzIsbC1NYXRoLlBJLzIscS5DTE9DS1dJU0UsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoaS5wMSk7YnJlYWs7Y2FzZSBhaS5DQVBfRkxBVDp0aGlzLl9zZWdMaXN0LmFkZFB0KHMucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoaS5wMSk7YnJlYWs7Y2FzZSBhaS5DQVBfU1FVQVJFOmNvbnN0IHQ9bmV3IG07dC54PU1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSpNYXRoLmNvcyhsKSx0Lnk9TWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKk1hdGguc2luKGwpO2NvbnN0IG49bmV3IG0ocy5wMS54K3QueCxzLnAxLnkrdC55KSxyPW5ldyBtKGkucDEueCt0LngsaS5wMS55K3QueSk7dGhpcy5fc2VnTGlzdC5hZGRQdChuKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHIpfX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9zZWdMaXN0LmdldENvb3JkaW5hdGVzKCl9YWRkTWl0cmVKb2luKHQsZSxuLHMpe2NvbnN0IGk9Qi5pbnRlcnNlY3Rpb24oZS5wMCxlLnAxLG4ucDAsbi5wMSk7aWYobnVsbCE9PWkpe2lmKChzPD0wPzE6aS5kaXN0YW5jZSh0KS9NYXRoLmFicyhzKSk8PXRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpcmV0dXJuIHRoaXMuX3NlZ0xpc3QuYWRkUHQoaSksbnVsbH10aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4oZSxuLHMsdGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSl9YWRkT3V0c2lkZVR1cm4odCxlKXtpZih0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApPHRoaXMuX2Rpc3RhbmNlKnlpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SKXJldHVybiB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLG51bGw7dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09YWkuSk9JTl9NSVRSRT90aGlzLmFkZE1pdHJlSm9pbih0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLHRoaXMuX29mZnNldDEsdGhpcy5fZGlzdGFuY2UpOnRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWFpLkpPSU5fQkVWRUw/dGhpcy5hZGRCZXZlbEpvaW4odGhpcy5fb2Zmc2V0MCx0aGlzLl9vZmZzZXQxKTooZSYmdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLmFkZENvcm5lckZpbGxldCh0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsdCx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKSl9Y3JlYXRlU3F1YXJlKHQpe3RoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IG0odC54K3RoaXMuX2Rpc3RhbmNlLHQueSt0aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IG0odC54K3RoaXMuX2Rpc3RhbmNlLHQueS10aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IG0odC54LXRoaXMuX2Rpc3RhbmNlLHQueS10aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IG0odC54LXRoaXMuX2Rpc3RhbmNlLHQueSt0aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9YWRkU2VnbWVudHModCxlKXt0aGlzLl9zZWdMaXN0LmFkZFB0cyh0LGUpfWFkZEZpcnN0U2VnbWVudCgpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCl9YWRkQ29ybmVyRmlsbGV0KHQsZSxuLHMsaSl7Y29uc3Qgcj1lLngtdC54LG89ZS55LXQueTtsZXQgbD1NYXRoLmF0YW4yKG8scik7Y29uc3QgYT1uLngtdC54LGM9bi55LXQueSxoPU1hdGguYXRhbjIoYyxhKTtzPT09cS5DTE9DS1dJU0U/bDw9aCYmKGwrPTIqTWF0aC5QSSk6bD49aCYmKGwtPTIqTWF0aC5QSSksdGhpcy5fc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KHQsbCxoLHMsaSksdGhpcy5fc2VnTGlzdC5hZGRQdChuKX1hZGRMYXN0U2VnbWVudCgpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMSl9aW5pdFNpZGVTZWdtZW50cyh0LGUsbil7dGhpcy5fczE9dCx0aGlzLl9zMj1lLHRoaXMuX3NpZGU9bix0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHQsZSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLG4sdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MSl9YWRkTGltaXRlZE1pdHJlSm9pbih0LGUsbixzKXtjb25zdCBpPXRoaXMuX3NlZzAucDEscj0kdC5hbmdsZShpLHRoaXMuX3NlZzAucDApLG89JHQuYW5nbGVCZXR3ZWVuT3JpZW50ZWQodGhpcy5fc2VnMC5wMCxpLHRoaXMuX3NlZzEucDEpLzIsbD0kdC5ub3JtYWxpemUocitvKSxhPSR0Lm5vcm1hbGl6ZShsK01hdGguUEkpLGM9cypuLGg9bi1jKk1hdGguYWJzKE1hdGguc2luKG8pKSx1PWkueCtjKk1hdGguY29zKGEpLGc9aS55K2MqTWF0aC5zaW4oYSksZD1uZXcgbSh1LGcpLF89bmV3IEt0KGksZCkscD1fLnBvaW50QWxvbmdPZmZzZXQoMSxoKSxmPV8ucG9pbnRBbG9uZ09mZnNldCgxLC1oKTt0aGlzLl9zaWRlPT09Ym4uTEVGVD8odGhpcy5fc2VnTGlzdC5hZGRQdChwKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGYpKToodGhpcy5fc2VnTGlzdC5hZGRQdChmKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHApKX1hZGREaXJlY3RlZEZpbGxldCh0LGUsbixzLGkpe2NvbnN0IHI9cz09PXEuQ0xPQ0tXSVNFPy0xOjEsbz1NYXRoLmFicyhlLW4pLGw9TWF0aC50cnVuYyhvL3RoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bSsuNSk7aWYobDwxKXJldHVybiBudWxsO2NvbnN0IGE9by9sLGM9bmV3IG07Zm9yKGxldCBuPTA7bjxsO24rKyl7Y29uc3Qgcz1lK3IqbiphO2MueD10LngraSpNYXRoLmNvcyhzKSxjLnk9dC55K2kqTWF0aC5zaW4ocyksdGhpcy5fc2VnTGlzdC5hZGRQdChjKX19Y29tcHV0ZU9mZnNldFNlZ21lbnQodCxlLG4scyl7Y29uc3QgaT1lPT09Ym4uTEVGVD8xOi0xLHI9dC5wMS54LXQucDAueCxvPXQucDEueS10LnAwLnksbD1NYXRoLnNxcnQocipyK28qbyksYT1pKm4qci9sLGM9aSpuKm8vbDtzLnAwLng9dC5wMC54LWMscy5wMC55PXQucDAueSthLHMucDEueD10LnAxLngtYyxzLnAxLnk9dC5wMS55K2F9YWRkSW5zaWRlVHVybih0LGUpe2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fb2Zmc2V0MC5wMCx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsdGhpcy5fb2Zmc2V0MS5wMSksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkpO2Vsc2UgaWYodGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSEwLHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCk8dGhpcy5fZGlzdGFuY2UqeWkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKXRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7ZWxzZXtpZih0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3I+MCl7Y29uc3QgdD1uZXcgbSgodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQwLnAxLngrdGhpcy5fczEueCkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MC5wMS55K3RoaXMuX3MxLnkpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLl9zZWdMaXN0LmFkZFB0KHQpO2NvbnN0IGU9bmV3IG0oKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MS5wMC54K3RoaXMuX3MxLngpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDEucDAueSt0aGlzLl9zMS55KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5fc2VnTGlzdC5hZGRQdChlKX1lbHNlIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fczEpO3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCl9fWNyZWF0ZUNpcmNsZSh0KXtjb25zdCBlPW5ldyBtKHQueCt0aGlzLl9kaXN0YW5jZSx0LnkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGREaXJlY3RlZEZpbGxldCh0LDAsMipNYXRoLlBJLC0xLHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWFkZEJldmVsSm9pbih0LGUpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodC5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdChlLnAwKX1pbml0KHQpe3RoaXMuX2Rpc3RhbmNlPXQsdGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3I9dCooMS1NYXRoLmNvcyh0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0vMikpLHRoaXMuX3NlZ0xpc3Q9bmV3IGZpLHRoaXMuX3NlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcHJlY2lzaW9uTW9kZWwpLHRoaXMuX3NlZ0xpc3Quc2V0TWluaW11bVZlcnRleERpc3RhbmNlKHQqeWkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKX1hZGRDb2xsaW5lYXIodCl7dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9zMCx0aGlzLl9zMSx0aGlzLl9zMSx0aGlzLl9zMik7dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk+PTImJih0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1haS5KT0lOX0JFVkVMfHx0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1haS5KT0lOX01JVFJFPyh0JiZ0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCkpOnRoaXMuYWRkQ29ybmVyRmlsbGV0KHRoaXMuX3MxLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCxxLkNMT0NLV0lTRSx0aGlzLl9kaXN0YW5jZSkpfWNsb3NlUmluZygpe3RoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9aGFzTmFycm93Q29uY2F2ZUFuZ2xlKCl7cmV0dXJuIHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZX19eWkuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1I9LjAwMSx5aS5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I9LjAwMSx5aS5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I9MWUtNix5aS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUj04MDtjbGFzcyB4aXtjb25zdHJ1Y3Rvcigpe3hpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Rpc3RhbmNlPTAsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9idWZQYXJhbXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wcmVjaXNpb25Nb2RlbD10LHRoaXMuX2J1ZlBhcmFtcz1lfXN0YXRpYyBjb3B5Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT1uZXcgbSh0W25dKTtyZXR1cm4gZX1nZXRPZmZzZXRDdXJ2ZSh0LGUpe2lmKHRoaXMuX2Rpc3RhbmNlPWUsMD09PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj1lPDAscz1NYXRoLmFicyhlKSxpPXRoaXMuZ2V0U2VnR2VuKHMpO3QubGVuZ3RoPD0xP3RoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxpKTp0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZSh0LG4saSk7Y29uc3Qgcj1pLmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIG4mJl90LnJldmVyc2Uocikscn1jb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSh0LGUsbil7Y29uc3Qgcz10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtpZihlKXtuLmFkZFNlZ21lbnRzKHQsITApO2NvbnN0IGU9bWkuc2ltcGxpZnkodCwtcyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlW2ldLGVbaS0xXSxibi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD1pLTI7dD49MDt0LS0pbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1lbHNle24uYWRkU2VnbWVudHModCwhMSk7Y29uc3QgZT1taS5zaW1wbGlmeSh0LHMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVswXSxlWzFdLGJuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PTI7dDw9aTt0Kyspbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1uLmFkZExhc3RTZWdtZW50KCksbi5jbG9zZVJpbmcoKX1jb21wdXRlUmluZ0J1ZmZlckN1cnZlKHQsZSxuKXtsZXQgcz10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtlPT09Ym4uUklHSFQmJihzPS1zKTtjb25zdCBpPW1pLnNpbXBsaWZ5KHQscykscj1pLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhpW3ItMV0saVswXSxlKTtmb3IobGV0IHQ9MTt0PD1yO3QrKyl7Y29uc3QgZT0xIT09dDtuLmFkZE5leHRTZWdtZW50KGlbdF0sZSl9bi5jbG9zZVJpbmcoKX1jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQsZSl7Y29uc3Qgbj10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKSxzPW1pLnNpbXBsaWZ5KHQsbiksaT1zLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhzWzBdLHNbMV0sYm4uTEVGVCk7Zm9yKGxldCB0PTI7dDw9aTt0KyspZS5hZGROZXh0U2VnbWVudChzW3RdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKHNbaS0xXSxzW2ldKTtjb25zdCByPW1pLnNpbXBsaWZ5KHQsLW4pLG89ci5sZW5ndGgtMTtlLmluaXRTaWRlU2VnbWVudHMocltvXSxyW28tMV0sYm4uTEVGVCk7Zm9yKGxldCB0PW8tMjt0Pj0wO3QtLSllLmFkZE5leHRTZWdtZW50KHJbdF0sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAoclsxXSxyWzBdKSxlLmNsb3NlUmluZygpfWNvbXB1dGVQb2ludEN1cnZlKHQsZSl7c3dpdGNoKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIGFpLkNBUF9ST1VORDplLmNyZWF0ZUNpcmNsZSh0KTticmVhaztjYXNlIGFpLkNBUF9TUVVBUkU6ZS5jcmVhdGVTcXVhcmUodCl9fWdldExpbmVDdXJ2ZSh0LGUpe2lmKHRoaXMuX2Rpc3RhbmNlPWUsdGhpcy5pc0xpbmVPZmZzZXRFbXB0eShlKSlyZXR1cm4gbnVsbDtjb25zdCBuPU1hdGguYWJzKGUpLHM9dGhpcy5nZXRTZWdHZW4obik7aWYodC5sZW5ndGg8PTEpdGhpcy5jb21wdXRlUG9pbnRDdXJ2ZSh0WzBdLHMpO2Vsc2UgaWYodGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSl7Y29uc3Qgbj1lPDA7dGhpcy5jb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSh0LG4scyl9ZWxzZSB0aGlzLmNvbXB1dGVMaW5lQnVmZmVyQ3VydmUodCxzKTtyZXR1cm4gcy5nZXRDb29yZGluYXRlcygpfWdldEJ1ZmZlclBhcmFtZXRlcnMoKXtyZXR1cm4gdGhpcy5fYnVmUGFyYW1zfXNpbXBsaWZ5VG9sZXJhbmNlKHQpe3JldHVybiB0KnRoaXMuX2J1ZlBhcmFtcy5nZXRTaW1wbGlmeUZhY3RvcigpfWdldFJpbmdDdXJ2ZSh0LGUsbil7aWYodGhpcy5fZGlzdGFuY2U9bix0Lmxlbmd0aDw9MilyZXR1cm4gdGhpcy5nZXRMaW5lQ3VydmUodCxuKTtpZigwPT09bilyZXR1cm4geGkuY29weUNvb3JkaW5hdGVzKHQpO2NvbnN0IHM9dGhpcy5nZXRTZWdHZW4obik7cmV0dXJuIHRoaXMuY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSh0LGUscykscy5nZXRDb29yZGluYXRlcygpfWNvbXB1dGVPZmZzZXRDdXJ2ZSh0LGUsbil7Y29uc3Qgcz10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtpZihlKXtjb25zdCBlPW1pLnNpbXBsaWZ5KHQsLXMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVtpXSxlW2ktMV0sYm4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9aS0yO3Q+PTA7dC0tKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9ZWxzZXtjb25zdCBlPW1pLnNpbXBsaWZ5KHQscyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlWzBdLGVbMV0sYm4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfW4uYWRkTGFzdFNlZ21lbnQoKX1pc0xpbmVPZmZzZXRFbXB0eSh0KXtyZXR1cm4gMD09PXR8fHQ8MCYmIXRoaXMuX2J1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCl9Z2V0U2VnR2VuKHQpe3JldHVybiBuZXcgeWkodGhpcy5fcHJlY2lzaW9uTW9kZWwsdGhpcy5fYnVmUGFyYW1zLHQpfX1jbGFzcyBFaXtjb25zdHJ1Y3Rvcigpe0VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3N1YmdyYXBocz1udWxsLHRoaXMuX3NlZz1uZXcgS3Q7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZ3JhcGhzPXR9ZmluZFN0YWJiZWRTZWdtZW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO2ZvcihsZXQgbj10aGlzLl9zdWJncmFwaHMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCksaT1zLmdldEVudmVsb3BlKCk7dC55PGkuZ2V0TWluWSgpfHx0Lnk+aS5nZXRNYXhZKCl8fHRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LHMuZ2V0RGlyZWN0ZWRFZGdlcygpLGUpfXJldHVybiBlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKEkoYXJndW1lbnRzWzJdLEMpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgcnMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGk9MDtpPHMubGVuZ3RoLTE7aSsrKXt0aGlzLl9zZWcucDA9c1tpXSx0aGlzLl9zZWcucDE9c1tpKzFdLHRoaXMuX3NlZy5wMC55PnRoaXMuX3NlZy5wMS55JiZ0aGlzLl9zZWcucmV2ZXJzZSgpO2lmKE1hdGgubWF4KHRoaXMuX3NlZy5wMC54LHRoaXMuX3NlZy5wMS54KTx0LngpY29udGludWU7aWYodGhpcy5fc2VnLmlzSG9yaXpvbnRhbCgpKWNvbnRpbnVlO2lmKHQueTx0aGlzLl9zZWcucDAueXx8dC55PnRoaXMuX3NlZy5wMS55KWNvbnRpbnVlO2lmKHEuaW5kZXgodGhpcy5fc2VnLnAwLHRoaXMuX3NlZy5wMSx0KT09PXEuUklHSFQpY29udGludWU7bGV0IHI9ZS5nZXREZXB0aChibi5MRUZUKTt0aGlzLl9zZWcucDAuZXF1YWxzKHNbaV0pfHwocj1lLmdldERlcHRoKGJuLlJJR0hUKSk7Y29uc3Qgbz1uZXcgSWkodGhpcy5fc2VnLHIpO24uYWRkKG8pfX1lbHNlIGlmKEkoYXJndW1lbnRzWzJdLEMpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJkkoYXJndW1lbnRzWzFdLEMpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXTtmb3IobGV0IG49YXJndW1lbnRzWzFdLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MuaXNGb3J3YXJkKCkmJnRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LHMsZSl9fX1nZXREZXB0aCh0KXtjb25zdCBlPXRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0KTtpZigwPT09ZS5zaXplKCkpcmV0dXJuIDA7cmV0dXJuIHhlLm1pbihlKS5fbGVmdERlcHRofX1jbGFzcyBJaXtjb25zdHJ1Y3Rvcigpe0lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Vwd2FyZFNlZz1udWxsLHRoaXMuX2xlZnREZXB0aD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3Vwd2FyZFNlZz1uZXcgS3QodCksdGhpcy5fbGVmdERlcHRoPWV9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtpZih0aGlzLl91cHdhcmRTZWcubWluWCgpPj1lLl91cHdhcmRTZWcubWF4WCgpKXJldHVybiAxO2lmKHRoaXMuX3Vwd2FyZFNlZy5tYXhYKCk8PWUuX3Vwd2FyZFNlZy5taW5YKCkpcmV0dXJuLTE7bGV0IG49dGhpcy5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgoZS5fdXB3YXJkU2VnKTtyZXR1cm4gMCE9PW4/bjoobj0tMSplLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleCh0aGlzLl91cHdhcmRTZWcpLDAhPT1uP246dGhpcy5fdXB3YXJkU2VnLmNvbXBhcmVUbyhlLl91cHdhcmRTZWcpKX1jb21wYXJlWCh0LGUpe2NvbnN0IG49dC5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dC5wMS5jb21wYXJlVG8oZS5wMSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fdXB3YXJkU2VnLnRvU3RyaW5nKCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1FaS5EZXB0aFNlZ21lbnQ9SWk7Y2xhc3MgTml7Y29uc3RydWN0b3IoKXtOaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2N1cnZlQnVpbGRlcj1udWxsLHRoaXMuX2N1cnZlTGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9kaXN0YW5jZT1lLHRoaXMuX2N1cnZlQnVpbGRlcj1ufWFkZFJpbmdTaWRlKHQsZSxuLHMsaSl7aWYoMD09PWUmJnQubGVuZ3RoPGd0Lk1JTklNVU1fVkFMSURfU0laRSlyZXR1cm4gbnVsbDtsZXQgcj1zLG89aTt0Lmxlbmd0aD49Z3QuTUlOSU1VTV9WQUxJRF9TSVpFJiZxLmlzQ0NXKHQpJiYocj1pLG89cyxuPWJuLm9wcG9zaXRlKG4pKTtjb25zdCBsPXRoaXMuX2N1cnZlQnVpbGRlci5nZXRSaW5nQ3VydmUodCxuLGUpO3RoaXMuYWRkQ3VydmUobCxyLG8pfWFkZFJpbmdCb3RoU2lkZXModCxlKXt0aGlzLmFkZFJpbmdTaWRlKHQsZSxibi5MRUZULFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKSx0aGlzLmFkZFJpbmdTaWRlKHQsZSxibi5SSUdIVCxRdC5JTlRFUklPUixRdC5FWFRFUklPUil9YWRkUG9pbnQodCl7aWYodGhpcy5fZGlzdGFuY2U8PTApcmV0dXJuIG51bGw7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCksbj10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5fZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUobixRdC5FWFRFUklPUixRdC5JTlRFUklPUil9YWRkUG9seWdvbih0KXtsZXQgZT10aGlzLl9kaXN0YW5jZSxuPWJuLkxFRlQ7dGhpcy5fZGlzdGFuY2U8MCYmKGU9LXRoaXMuX2Rpc3RhbmNlLG49Ym4uUklHSFQpO2NvbnN0IHM9dC5nZXRFeHRlcmlvclJpbmcoKSxpPV90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHMuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYodGhpcy5fZGlzdGFuY2U8MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkocyx0aGlzLl9kaXN0YW5jZSkpcmV0dXJuIG51bGw7aWYodGhpcy5fZGlzdGFuY2U8PTAmJmkubGVuZ3RoPDMpcmV0dXJuIG51bGw7dGhpcy5hZGRSaW5nU2lkZShpLGUsbixRdC5FWFRFUklPUixRdC5JTlRFUklPUik7Zm9yKGxldCBzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKyl7Y29uc3QgaT10LmdldEludGVyaW9yUmluZ04ocykscj1fdC5yZW1vdmVSZXBlYXRlZFBvaW50cyhpLmdldENvb3JkaW5hdGVzKCkpO3RoaXMuX2Rpc3RhbmNlPjAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KGksLXRoaXMuX2Rpc3RhbmNlKXx8dGhpcy5hZGRSaW5nU2lkZShyLGUsYm4ub3Bwb3NpdGUobiksUXQuSU5URVJJT1IsUXQuRVhURVJJT1IpfX1pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseSh0LGUpe2NvbnN0IG49bmV3IG5lKHRbMF0sdFsxXSx0WzJdKSxzPW4uaW5DZW50cmUoKTtyZXR1cm4gei5wb2ludFRvU2VnbWVudChzLG4ucDAsbi5wMSk8TWF0aC5hYnMoZSl9YWRkTGluZVN0cmluZyh0KXtpZih0aGlzLl9jdXJ2ZUJ1aWxkZXIuaXNMaW5lT2Zmc2V0RW1wdHkodGhpcy5fZGlzdGFuY2UpKXJldHVybiBudWxsO2NvbnN0IGU9X3QucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihfdC5pc1JpbmcoZSkmJiF0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSl0aGlzLmFkZFJpbmdCb3RoU2lkZXMoZSx0aGlzLl9kaXN0YW5jZSk7ZWxzZXtjb25zdCB0PXRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLl9kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZSh0LFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKX19YWRkQ3VydmUodCxlLG4pe2lmKG51bGw9PT10fHx0Lmxlbmd0aDwyKXJldHVybiBudWxsO2NvbnN0IHM9bmV3IFpzKHQsbmV3IEJuKDAsUXQuQk9VTkRBUlksZSxuKSk7dGhpcy5fY3VydmVMaXN0LmFkZChzKX1nZXRDdXJ2ZXMoKXtyZXR1cm4gdGhpcy5hZGQodGhpcy5faW5wdXRHZW9tKSx0aGlzLl9jdXJ2ZUxpc3R9YWRkKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBydCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgJCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZXQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB1dCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHl0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIGh0KSl0aHJvdyBuZXcgSyh0LmdldEdlb21ldHJ5VHlwZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fWlzRXJvZGVkQ29tcGxldGVseSh0LGUpe2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpO2lmKG4ubGVuZ3RoPDQpcmV0dXJuIGU8MDtpZig0PT09bi5sZW5ndGgpcmV0dXJuIHRoaXMuaXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkobixlKTtjb25zdCBzPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9TWF0aC5taW4ocy5nZXRIZWlnaHQoKSxzLmdldFdpZHRoKCkpO3JldHVybiBlPDAmJjIqTWF0aC5hYnMoZSk+aX1hZGRDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX19Y2xhc3Mgd2l7Y29uc3RydWN0b3IoKXt3aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lZGdlTWFwPW5ldyBXbix0aGlzLl9lZGdlTGlzdD1udWxsLHRoaXMuX3B0SW5BcmVhTG9jYXRpb249W1F0Lk5PTkUsUXQuTk9ORV19Z2V0TmV4dENXKHQpe3RoaXMuZ2V0RWRnZXMoKTtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmluZGV4T2YodCk7bGV0IG49ZS0xO3JldHVybiAwPT09ZSYmKG49dGhpcy5fZWRnZUxpc3Quc2l6ZSgpLTEpLHRoaXMuX2VkZ2VMaXN0LmdldChuKX1wcm9wYWdhdGVTaWRlTGFiZWxzKHQpe2xldCBlPVF0Lk5PTkU7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCkuZ2V0TGFiZWwoKTtzLmlzQXJlYSh0KSYmcy5nZXRMb2NhdGlvbih0LGJuLkxFRlQpIT09UXQuTk9ORSYmKGU9cy5nZXRMb2NhdGlvbih0LGJuLkxFRlQpKX1pZihlPT09UXQuTk9ORSlyZXR1cm4gbnVsbDtsZXQgbj1lO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpLGk9cy5nZXRMYWJlbCgpO2lmKGkuZ2V0TG9jYXRpb24odCxibi5PTik9PT1RdC5OT05FJiZpLnNldExvY2F0aW9uKHQsYm4uT04sbiksaS5pc0FyZWEodCkpe2NvbnN0IGU9aS5nZXRMb2NhdGlvbih0LGJuLkxFRlQpLHI9aS5nZXRMb2NhdGlvbih0LGJuLlJJR0hUKTtpZihyIT09UXQuTk9ORSl7aWYociE9PW4pdGhyb3cgbmV3IGlzKFwic2lkZSBsb2NhdGlvbiBjb25mbGljdFwiLHMuZ2V0Q29vcmRpbmF0ZSgpKTtlPT09UXQuTk9ORSYmZy5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHNpbmdsZSBudWxsIHNpZGUgKGF0IFwiK3MuZ2V0Q29vcmRpbmF0ZSgpK1wiKVwiKSxuPWV9ZWxzZSBnLmlzVHJ1ZShpLmdldExvY2F0aW9uKHQsYm4uTEVGVCk9PT1RdC5OT05FLFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZVwiKSxpLnNldExvY2F0aW9uKHQsYm4uUklHSFQsbiksaS5zZXRMb2NhdGlvbih0LGJuLkxFRlQsbil9fX1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD10aGlzLml0ZXJhdG9yKCk7aWYoIXQuaGFzTmV4dCgpKXJldHVybiBudWxsO3JldHVybiB0Lm5leHQoKS5nZXRDb29yZGluYXRlKCl9cHJpbnQodCl7WS5vdXQucHJpbnRsbihcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodCl7cmV0dXJuIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModC5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCgwKX1jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KHQpe2NvbnN0IGU9dGhpcy5nZXRFZGdlcygpO2lmKGUuc2l6ZSgpPD0wKXJldHVybiEwO2NvbnN0IG49ZS5zaXplKCktMSxzPWUuZ2V0KG4pLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCxibi5MRUZUKTtnLmlzVHJ1ZShzIT09UXQuTk9ORSxcIkZvdW5kIHVubGFiZWxsZWQgYXJlYSBlZGdlXCIpO2xldCBpPXM7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0TGFiZWwoKTtnLmlzVHJ1ZShuLmlzQXJlYSh0KSxcIkZvdW5kIG5vbi1hcmVhIGVkZ2VcIik7Y29uc3Qgcz1uLmdldExvY2F0aW9uKHQsYm4uTEVGVCkscj1uLmdldExvY2F0aW9uKHQsYm4uUklHSFQpO2lmKHM9PT1yKXJldHVybiExO2lmKHIhPT1pKXJldHVybiExO2k9c31yZXR1cm4hMH1maW5kSW5kZXgodCl7dGhpcy5pdGVyYXRvcigpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZUxpc3Quc2l6ZSgpO2UrKyl7aWYodGhpcy5fZWRnZUxpc3QuZ2V0KGUpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pdGVyYXRvcigpe3JldHVybiB0aGlzLmdldEVkZ2VzKCkuaXRlcmF0b3IoKX1nZXRFZGdlcygpe3JldHVybiBudWxsPT09dGhpcy5fZWRnZUxpc3QmJih0aGlzLl9lZGdlTGlzdD1uZXcgTCh0aGlzLl9lZGdlTWFwLnZhbHVlcygpKSksdGhpcy5fZWRnZUxpc3R9Z2V0TG9jYXRpb24odCxlLG4pe3JldHVybiB0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdPT09UXQuTk9ORSYmKHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF09WmUubG9jYXRlKGUsblt0XS5nZXRHZW9tZXRyeSgpKSksdGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHY7dC5hcHBlbmQoXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSksdC5hcHBlbmQoXCJcXG5cIik7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5hcHBlbmQobiksdC5hcHBlbmQoXCJcXG5cIil9cmV0dXJuIHQudG9TdHJpbmcoKX1jb21wdXRlRWRnZUVuZExhYmVscyh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuY29tcHV0ZUxhYmVsKHQpfX1jb21wdXRlTGFiZWxsaW5nKHQpe3RoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModFswXS5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygwKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMSk7Y29uc3QgZT1bITEsITFdO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLmdldExhYmVsKCk7Zm9yKGxldCB0PTA7dDwyO3QrKyluLmlzTGluZSh0KSYmbi5nZXRMb2NhdGlvbih0KT09PVF0LkJPVU5EQVJZJiYoZVt0XT0hMCl9Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCksaT1zLmdldExhYmVsKCk7Zm9yKGxldCBuPTA7bjwyO24rKylpZihpLmlzQW55TnVsbChuKSl7bGV0IHI9UXQuTk9ORTtpZihlW25dKXI9UXQuRVhURVJJT1I7ZWxzZXtjb25zdCBlPXMuZ2V0Q29vcmRpbmF0ZSgpO3I9dGhpcy5nZXRMb2NhdGlvbihuLGUsdCl9aS5zZXRBbGxMb2NhdGlvbnNJZk51bGwobixyKX19fWdldERlZ3JlZSgpe3JldHVybiB0aGlzLl9lZGdlTWFwLnNpemUoKX1pbnNlcnRFZGdlRW5kKHQsZSl7dGhpcy5fZWRnZU1hcC5wdXQodCxlKSx0aGlzLl9lZGdlTGlzdD1udWxsfX1sZXQgQ2k9Y2xhc3MgZXh0ZW5kcyB3aXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQ2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0PW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc9MSx0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HPTJ9bGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKXt0aGlzLmdldFJlc3VsdEFyZWFFZGdlcygpO2xldCB0PW51bGwsZT1udWxsLG49dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO2ZvcihsZXQgcz0wO3M8dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTtzKyspe2NvbnN0IGk9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChzKSxyPWkuZ2V0U3ltKCk7aWYoaS5nZXRMYWJlbCgpLmlzQXJlYSgpKXN3aXRjaChudWxsPT09dCYmaS5pc0luUmVzdWx0KCkmJih0PWkpLG4pe2Nhc2UgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKCFyLmlzSW5SZXN1bHQoKSljb250aW51ZTtlPXIsbj10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORzppZighaS5pc0luUmVzdWx0KCkpY29udGludWU7ZS5zZXROZXh0KGkpLG49dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1pZihuPT09dGhpcy5fTElOS0lOR19UT19PVVRHT0lORyl7aWYobnVsbD09PXQpdGhyb3cgbmV3IGlzKFwibm8gb3V0Z29pbmcgZGlyRWRnZSBmb3VuZFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtnLmlzVHJ1ZSh0LmlzSW5SZXN1bHQoKSxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxlLnNldE5leHQodCl9fWluc2VydCh0KXtjb25zdCBlPXQ7dGhpcy5pbnNlcnRFZGdlRW5kKGUsZSl9Z2V0UmlnaHRtb3N0RWRnZSgpe2NvbnN0IHQ9dGhpcy5nZXRFZGdlcygpLGU9dC5zaXplKCk7aWYoZTwxKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXQoMCk7aWYoMT09PWUpcmV0dXJuIG47Y29uc3Qgcz10LmdldChlLTEpLGk9bi5nZXRRdWFkcmFudCgpLHI9cy5nZXRRdWFkcmFudCgpO3JldHVybiBDbi5pc05vcnRoZXJuKGkpJiZDbi5pc05vcnRoZXJuKHIpP246Q24uaXNOb3J0aGVybihpKXx8Q24uaXNOb3J0aGVybihyKT8wIT09bi5nZXREeSgpP246MCE9PXMuZ2V0RHkoKT9zOihnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgdHdvIGhvcml6b250YWwgZWRnZXMgaW5jaWRlbnQgb24gbm9kZVwiKSxudWxsKTpzfXByaW50KHQpe1kub3V0LnByaW50bG4oXCJEaXJlY3RlZEVkZ2VTdGFyOiBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5wcmludChcIm91dCBcIiksbi5wcmludCh0KSx0LnByaW50bG4oKSx0LnByaW50KFwiaW4gXCIpLG4uZ2V0U3ltKCkucHJpbnQodCksdC5wcmludGxuKCl9fWdldFJlc3VsdEFyZWFFZGdlcygpe2lmKG51bGwhPT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QpcmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdDt0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q9bmV3IEw7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7KGUuaXNJblJlc3VsdCgpfHxlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkmJnRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5hZGQoZSl9cmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdH11cGRhdGVMYWJlbGxpbmcodCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0TGFiZWwoKTtuLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQuZ2V0TG9jYXRpb24oMCkpLG4uc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdC5nZXRMb2NhdGlvbigxKSl9fWxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl7dGhpcy5nZXRFZGdlcygpO2xldCB0PW51bGwsZT1udWxsO2ZvcihsZXQgbj10aGlzLl9lZGdlTGlzdC5zaXplKCktMTtuPj0wO24tLSl7Y29uc3Qgcz10aGlzLl9lZGdlTGlzdC5nZXQobiksaT1zLmdldFN5bSgpO251bGw9PT1lJiYoZT1pKSxudWxsIT09dCYmaS5zZXROZXh0KHQpLHQ9c31lLnNldE5leHQodCl9Y29tcHV0ZURlcHRocygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZmluZEluZGV4KHQpLG49dC5nZXREZXB0aChibi5MRUZUKSxzPXQuZ2V0RGVwdGgoYm4uUklHSFQpLGk9dGhpcy5jb21wdXRlRGVwdGhzKGUrMSx0aGlzLl9lZGdlTGlzdC5zaXplKCksbik7aWYodGhpcy5jb21wdXRlRGVwdGhzKDAsZSxpKSE9PXMpdGhyb3cgbmV3IGlzKFwiZGVwdGggbWlzbWF0Y2ggYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2xldCBlPWFyZ3VtZW50c1syXTtmb3IobGV0IG49YXJndW1lbnRzWzBdO248dDtuKyspe2NvbnN0IHQ9dGhpcy5fZWRnZUxpc3QuZ2V0KG4pO3Quc2V0RWRnZURlcHRocyhibi5SSUdIVCxlKSxlPXQuZ2V0RGVwdGgoYm4uTEVGVCl9cmV0dXJuIGV9fW1lcmdlU3ltTGFiZWxzKCl7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5nZXRMYWJlbCgpLm1lcmdlKGUuZ2V0U3ltKCkuZ2V0TGFiZWwoKSl9fWxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0KXtsZXQgZT1udWxsLG49bnVsbCxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztmb3IobGV0IGk9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKS0xO2k+PTA7aS0tKXtjb25zdCByPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSksbz1yLmdldFN5bSgpO3N3aXRjaChudWxsPT09ZSYmci5nZXRFZGdlUmluZygpPT09dCYmKGU9cikscyl7Y2FzZSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoby5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuPW8scz10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORzppZihyLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO24uc2V0TmV4dE1pbihyKSxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlOR319cz09PXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcmJihnLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2VcIiksZy5pc1RydWUoZS5nZXRFZGdlUmluZygpPT09dCxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxuLnNldE5leHRNaW4oZSkpfWdldE91dGdvaW5nRGVncmVlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmlzSW5SZXN1bHQoKSYmdCsrfXJldHVybiB0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXRFZGdlUmluZygpPT09dCYmZSsrfXJldHVybiBlfX1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1maW5kQ292ZXJlZExpbmVFZGdlcygpe2xldCB0PVF0Lk5PTkU7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldFN5bSgpO2lmKCFuLmlzTGluZUVkZ2UoKSl7aWYobi5pc0luUmVzdWx0KCkpe3Q9UXQuSU5URVJJT1I7YnJlYWt9aWYocy5pc0luUmVzdWx0KCkpe3Q9UXQuRVhURVJJT1I7YnJlYWt9fX1pZih0PT09UXQuTk9ORSlyZXR1cm4gbnVsbDtsZXQgZT10O2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRTeW0oKTtuLmlzTGluZUVkZ2UoKT9uLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKGU9PT1RdC5JTlRFUklPUik6KG4uaXNJblJlc3VsdCgpJiYoZT1RdC5FWFRFUklPUikscy5pc0luUmVzdWx0KCkmJihlPVF0LklOVEVSSU9SKSl9fWNvbXB1dGVMYWJlbGxpbmcodCl7c3VwZXIuY29tcHV0ZUxhYmVsbGluZy5jYWxsKHRoaXMsdCksdGhpcy5fbGFiZWw9bmV3IEJuKFF0Lk5PTkUpO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLmdldEVkZ2UoKS5nZXRMYWJlbCgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspe2NvbnN0IG49ZS5nZXRMb2NhdGlvbih0KTtuIT09UXQuSU5URVJJT1ImJm4hPT1RdC5CT1VOREFSWXx8dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxRdC5JTlRFUklPUil9fX19O2NsYXNzIFNpIGV4dGVuZHMgb3N7Y29uc3RydWN0b3IoKXtzdXBlcigpfWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyBlcyh0LG5ldyBDaSl9fWNsYXNzIExpe2NvbnN0cnVjdG9yKCl7TGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fb3JpZW50YXRpb249bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dCx0aGlzLl9vcmllbnRhdGlvbj1MaS5vcmllbnRhdGlvbih0KX1zdGF0aWMgb3JpZW50YXRpb24odCl7cmV0dXJuIDE9PT1fdC5pbmNyZWFzaW5nRGlyZWN0aW9uKHQpfXN0YXRpYyBjb21wYXJlT3JpZW50ZWQodCxlLG4scyl7Y29uc3QgaT1lPzE6LTEscj1zPzE6LTEsbz1lP3QubGVuZ3RoOi0xLGw9cz9uLmxlbmd0aDotMTtsZXQgYT1lPzA6dC5sZW5ndGgtMSxjPXM/MDpuLmxlbmd0aC0xO2Zvcig7Oyl7Y29uc3QgZT10W2FdLmNvbXBhcmVUbyhuW2NdKTtpZigwIT09ZSlyZXR1cm4gZTthKz1pLGMrPXI7Y29uc3Qgcz1hPT09byxoPWM9PT1sO2lmKHMmJiFoKXJldHVybi0xO2lmKCFzJiZoKXJldHVybiAxO2lmKHMmJmgpcmV0dXJuIDB9fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIExpLmNvbXBhcmVPcmllbnRlZCh0aGlzLl9wdHMsdGhpcy5fb3JpZW50YXRpb24sZS5fcHRzLGUuX29yaWVudGF0aW9uKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIFRpe2NvbnN0cnVjdG9yKCl7VGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZWRnZXM9bmV3IEwsdGhpcy5fb2NhTWFwPW5ldyBXbn1wcmludCh0KXt0LnByaW50KFwiTVVMVElMSU5FU1RSSU5HICggXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7ZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KFwiKFwiKTtjb25zdCBzPW4uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoc1tlXS54K1wiIFwiK3NbZV0ueSk7dC5wcmludGxuKFwiKVwiKX10LnByaW50KFwiKSAgXCIpfWFkZEFsbCh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSl9ZmluZEVkZ2VJbmRleCh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspaWYodGhpcy5fZWRnZXMuZ2V0KGUpLmVxdWFscyh0KSlyZXR1cm4gZTtyZXR1cm4tMX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfWdldCh0KXtyZXR1cm4gdGhpcy5fZWRnZXMuZ2V0KHQpfWZpbmRFcXVhbEVkZ2UodCl7Y29uc3QgZT1uZXcgTGkodC5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gdGhpcy5fb2NhTWFwLmdldChlKX1hZGQodCl7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IGU9bmV3IExpKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fb2NhTWFwLnB1dChlLHQpfX1jbGFzcyBSaXtwcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXt9aXNEb25lKCl7fX1jbGFzcyBQaXtjb25zdHJ1Y3Rvcigpe1BpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9oYXNQcm9wZXI9ITEsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5faGFzSW50ZXJpb3I9ITEsdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMubnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXR9c3RhdGljIGlzQWRqYWNlbnRTZWdtZW50cyh0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX1pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl7aWYodD09PW4mJjE9PT10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoUGkuaXNBZGphY2VudFNlZ21lbnRzKGUscykpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXtjb25zdCBuPXQuc2l6ZSgpLTE7aWYoMD09PWUmJnM9PT1ufHwwPT09cyYmZT09PW4pcmV0dXJuITB9fXJldHVybiExfWdldFByb3BlckludGVyc2VjdGlvblBvaW50KCl7cmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50fWhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yfWdldExpbmVJbnRlcnNlY3Rvcigpe3JldHVybiB0aGlzLl9saX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyc2VjdGlvbnMrKyx0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrLHRoaXMuX2hhc0ludGVyaW9yPSEwKSx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCx0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKSx0aGlzLl9saS5pc1Byb3BlcigpJiYodGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zKyssdGhpcy5faGFzUHJvcGVyPSEwLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSEwKSkpfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuITF9aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJpb3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1JpXX19Y2xhc3MgT2l7Y29uc3RydWN0b3IoKXtPaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9idWZQYXJhbXM9bnVsbCx0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl93b3JraW5nTm9kZXI9bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZWRnZUxpc3Q9bmV3IFRpO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2J1ZlBhcmFtcz10fXN0YXRpYyBkZXB0aERlbHRhKHQpe2NvbnN0IGU9dC5nZXRMb2NhdGlvbigwLGJuLkxFRlQpLG49dC5nZXRMb2NhdGlvbigwLGJuLlJJR0hUKTtyZXR1cm4gZT09PVF0LklOVEVSSU9SJiZuPT09UXQuRVhURVJJT1I/MTplPT09UXQuRVhURVJJT1ImJm49PT1RdC5JTlRFUklPUj8tMTowfXN0YXRpYyBjb252ZXJ0U2VnU3RyaW5ncyh0KXtjb25zdCBlPW5ldyBMdCxuPW5ldyBMO2Zvcig7dC5oYXNOZXh0KCk7KXtjb25zdCBzPXQubmV4dCgpLGk9ZS5jcmVhdGVMaW5lU3RyaW5nKHMuZ2V0Q29vcmRpbmF0ZXMoKSk7bi5hZGQoaSl9cmV0dXJuIGUuYnVpbGRHZW9tZXRyeShuKX1zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsPXR9aW5zZXJ0VW5pcXVlRWRnZSh0KXtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe2NvbnN0IG49ZS5nZXRMYWJlbCgpO2xldCBzPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChzPW5ldyBCbih0LmdldExhYmVsKCkpLHMuZmxpcCgpKSxuLm1lcmdlKHMpO2NvbnN0IGk9T2kuZGVwdGhEZWx0YShzKSxyPWUuZ2V0RGVwdGhEZWx0YSgpK2k7ZS5zZXREZXB0aERlbHRhKHIpfWVsc2UgdGhpcy5fZWRnZUxpc3QuYWRkKHQpLHQuc2V0RGVwdGhEZWx0YShPaS5kZXB0aERlbHRhKHQuZ2V0TGFiZWwoKSkpfWJ1aWxkU3ViZ3JhcGhzKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPXQuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpLHI9bmV3IEVpKG4pLmdldERlcHRoKGkpO3QuY29tcHV0ZURlcHRoKHIpLHQuZmluZFJlc3VsdEVkZ2VzKCksbi5hZGQodCksZS5hZGQodC5nZXREaXJlY3RlZEVkZ2VzKCksdC5nZXROb2RlcygpKX19Y3JlYXRlU3ViZ3JhcGhzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZighdC5pc1Zpc2l0ZWQoKSl7Y29uc3Qgbj1uZXcgdWk7bi5jcmVhdGUodCksZS5hZGQobil9fXJldHVybiB4ZS5zb3J0KGUseGUucmV2ZXJzZU9yZGVyKCkpLGV9Y3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCl9Z2V0Tm9kZXIodCl7aWYobnVsbCE9PXRoaXMuX3dvcmtpbmdOb2RlcilyZXR1cm4gdGhpcy5fd29ya2luZ05vZGVyO2NvbnN0IGU9bmV3IHRpLG49bmV3IGp0O3JldHVybiBuLnNldFByZWNpc2lvbk1vZGVsKHQpLGUuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBQaShuKSksZX1idWZmZXIodCxlKXtsZXQgbj10aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw7bnVsbD09PW4mJihuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCk7Y29uc3Qgcz1uZXcgeGkobix0aGlzLl9idWZQYXJhbXMpLGk9bmV3IE5pKHQsZSxzKS5nZXRDdXJ2ZXMoKTtpZihpLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dGhpcy5jb21wdXRlTm9kZWRFZGdlcyhpLG4pLHRoaXMuX2dyYXBoPW5ldyBscyhuZXcgU2kpLHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpO2NvbnN0IHI9dGhpcy5jcmVhdGVTdWJncmFwaHModGhpcy5fZ3JhcGgpLG89bmV3IHBpKHRoaXMuX2dlb21GYWN0KTt0aGlzLmJ1aWxkU3ViZ3JhcGhzKHIsbyk7Y29uc3QgbD1vLmdldFBvbHlnb25zKCk7aWYobC5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3JldHVybiB0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGwpfWNvbXB1dGVOb2RlZEVkZ2VzKHQsZSl7Y29uc3Qgbj10aGlzLmdldE5vZGVyKGUpO24uY29tcHV0ZU5vZGVzKHQpO2ZvcihsZXQgdD1uLmdldE5vZGVkU3Vic3RyaW5ncygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRDb29yZGluYXRlcygpO2lmKDI9PT1uLmxlbmd0aCYmblswXS5lcXVhbHMyRChuWzFdKSljb250aW51ZTtjb25zdCBzPWUuZ2V0RGF0YSgpLGk9bmV3IHRzKGUuZ2V0Q29vcmRpbmF0ZXMoKSxuZXcgQm4ocykpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZShpKX19c2V0Tm9kZXIodCl7dGhpcy5fd29ya2luZ05vZGVyPXR9fWNsYXNzIHZpe2NvbnN0cnVjdG9yKCl7dmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX3NlZ1N0cmluZ3M9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWdTdHJpbmdzPXR9Y2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKS5nZXRDb29yZGluYXRlcygpO3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoZVswXSx0aGlzLl9zZWdTdHJpbmdzKSx0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKGVbZS5sZW5ndGgtMV0sdGhpcy5fc2VnU3RyaW5ncyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPWFyZ3VtZW50c1sxXS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0xO2U8bi5sZW5ndGgtMTtlKyspaWYobltlXS5lcXVhbHModCkpdGhyb3cgbmV3IGgoXCJmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggXCIrZStcIiA6cHQgXCIrdCl9fX1jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2ZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoZSxuKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldENvb3JkaW5hdGVzKCkscz1lLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBpPTA7aTxuLmxlbmd0aC0xO2krKylmb3IobGV0IG49MDtuPHMubGVuZ3RoLTE7bisrKXRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnModCxpLGUsbil9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5fbGkuaXNQcm9wZXIoKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSxpLHIpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLG8sbCkpKXRocm93IG5ldyBoKFwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBhdCBcIitpK1wiLVwiK3IrXCIgYW5kIFwiK28rXCItXCIrbCl9fWNoZWNrVmFsaWQoKXt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tDb2xsYXBzZXMoKX1jaGVja0NvbGxhcHNlcygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuY2hlY2tDb2xsYXBzZXMoZSl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKXRoaXMuY2hlY2tDb2xsYXBzZSh0W2VdLHRbZSsxXSx0W2UrMl0pfX1oYXNJbnRlcmlvckludGVyc2VjdGlvbih0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl7Y29uc3QgaT10LmdldEludGVyc2VjdGlvbihzKTtpZighaS5lcXVhbHMoZSkmJiFpLmVxdWFscyhuKSlyZXR1cm4hMH1yZXR1cm4hMX1jaGVja0NvbGxhcHNlKHQsZSxuKXtpZih0LmVxdWFscyhuKSl0aHJvdyBuZXcgaChcImZvdW5kIG5vbi1ub2RlZCBjb2xsYXBzZSBhdCBcIit2aS5mYWN0LmNyZWF0ZUxpbmVTdHJpbmcoW3QsZSxuXSkpfX12aS5mYWN0PW5ldyBMdDtjbGFzcyBiaXtjb25zdHJ1Y3Rvcigpe2JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW51bGwsdGhpcy5fcHQ9bnVsbCx0aGlzLl9vcmlnaW5hbFB0PW51bGwsdGhpcy5fcHRTY2FsZWQ9bnVsbCx0aGlzLl9wMFNjYWxlZD1udWxsLHRoaXMuX3AxU2NhbGVkPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9taW54PW51bGwsdGhpcy5fbWF4eD1udWxsLHRoaXMuX21pbnk9bnVsbCx0aGlzLl9tYXh5PW51bGwsdGhpcy5fY29ybmVyPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX3NhZmVFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLl9vcmlnaW5hbFB0PXQsdGhpcy5fcHQ9dCx0aGlzLl9zY2FsZUZhY3Rvcj1lLHRoaXMuX2xpPW4sZTw9MCl0aHJvdyBuZXcgcyhcIlNjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpOzEhPT1lJiYodGhpcy5fcHQ9bmV3IG0odGhpcy5zY2FsZSh0LngpLHRoaXMuc2NhbGUodC55KSksdGhpcy5fcDBTY2FsZWQ9bmV3IG0sdGhpcy5fcDFTY2FsZWQ9bmV3IG0pLHRoaXMuaW5pdENvcm5lcnModGhpcy5fcHQpfWludGVyc2VjdHNTY2FsZWQodCxlKXtjb25zdCBuPU1hdGgubWluKHQueCxlLngpLHM9TWF0aC5tYXgodC54LGUueCksaT1NYXRoLm1pbih0LnksZS55KSxyPU1hdGgubWF4KHQueSxlLnkpLG89dGhpcy5fbWF4eDxufHx0aGlzLl9taW54PnN8fHRoaXMuX21heHk8aXx8dGhpcy5fbWlueT5yO2lmKG8pcmV0dXJuITE7Y29uc3QgbD10aGlzLmludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKTtyZXR1cm4gZy5pc1RydWUoIShvJiZsKSxcIkZvdW5kIGJhZCBlbnZlbG9wZSB0ZXN0XCIpLGx9aW5pdENvcm5lcnModCl7Y29uc3QgZT0uNTt0aGlzLl9taW54PXQueC1lLHRoaXMuX21heHg9dC54K2UsdGhpcy5fbWlueT10LnktZSx0aGlzLl9tYXh5PXQueStlLHRoaXMuX2Nvcm5lclswXT1uZXcgbSh0aGlzLl9tYXh4LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsxXT1uZXcgbSh0aGlzLl9taW54LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsyXT1uZXcgbSh0aGlzLl9taW54LHRoaXMuX21pbnkpLHRoaXMuX2Nvcm5lclszXT1uZXcgbSh0aGlzLl9tYXh4LHRoaXMuX21pbnkpfWludGVyc2VjdHModCxlKXtyZXR1cm4gMT09PXRoaXMuX3NjYWxlRmFjdG9yP3RoaXMuaW50ZXJzZWN0c1NjYWxlZCh0LGUpOih0aGlzLmNvcHlTY2FsZWQodCx0aGlzLl9wMFNjYWxlZCksdGhpcy5jb3B5U2NhbGVkKGUsdGhpcy5fcDFTY2FsZWQpLHRoaXMuaW50ZXJzZWN0c1NjYWxlZCh0aGlzLl9wMFNjYWxlZCx0aGlzLl9wMVNjYWxlZCkpfXNjYWxlKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqdGhpcy5fc2NhbGVGYWN0b3IpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fb3JpZ2luYWxQdH1jb3B5U2NhbGVkKHQsZSl7ZS54PXRoaXMuc2NhbGUodC54KSxlLnk9dGhpcy5zY2FsZSh0LnkpfWdldFNhZmVFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9zYWZlRW52KXtjb25zdCB0PWJpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IvdGhpcy5fc2NhbGVGYWN0b3I7dGhpcy5fc2FmZUVudj1uZXcgTyh0aGlzLl9vcmlnaW5hbFB0LngtdCx0aGlzLl9vcmlnaW5hbFB0LngrdCx0aGlzLl9vcmlnaW5hbFB0LnktdCx0aGlzLl9vcmlnaW5hbFB0LnkrdCl9cmV0dXJuIHRoaXMuX3NhZmVFbnZ9aW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSh0LGUpe3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzFdLHRoaXMuX2Nvcm5lclsyXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbM10sdGhpcy5fY29ybmVyWzBdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSkpfWludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKXtsZXQgbj0hMSxzPSExO3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMV0sdGhpcy5fY29ybmVyWzJdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKG49ITApLHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYocz0hMCksdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzNdLHRoaXMuX2Nvcm5lclswXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwoISghbnx8IXMpfHwoISF0LmVxdWFscyh0aGlzLl9wdCl8fCEhZS5lcXVhbHModGhpcy5fcHQpKSkpKSl9YWRkU25hcHBlZE5vZGUodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZShlKSxzPXQuZ2V0Q29vcmRpbmF0ZShlKzEpO3JldHVybiEhdGhpcy5pbnRlcnNlY3RzKG4scykmJih0LmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSxlKSwhMCl9fWJpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1I9Ljc1O2NsYXNzIE1pe2NvbnN0cnVjdG9yKCl7TWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5zZWxlY3RlZFNlZ21lbnQ9bmV3IEt0fXNlbGVjdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMF0uZ2V0TGluZVNlZ21lbnQodCx0aGlzLnNlbGVjdGVkU2VnbWVudCksdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpfX19Y2xhc3MgRGl7Y29uc3RydWN0b3IoKXtEaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2luZGV4PXR9c25hcCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zbmFwKHQsbnVsbCwtMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9dC5nZXRTYWZlRW52ZWxvcGUoKSxpPW5ldyBBaSh0LGUsbik7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHMsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltEZV19dmlzaXRJdGVtKHQpe3Quc2VsZWN0KHMsaSl9fSksaS5pc05vZGVBZGRlZCgpfX19Y2xhc3MgQWkgZXh0ZW5kcyBNaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faG90UGl4ZWw9bnVsbCx0aGlzLl9wYXJlbnRFZGdlPW51bGwsdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleD1udWxsLHRoaXMuX2lzTm9kZUFkZGVkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2hvdFBpeGVsPXQsdGhpcy5fcGFyZW50RWRnZT1lLHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXg9bn1pc05vZGVBZGRlZCgpe3JldHVybiB0aGlzLl9pc05vZGVBZGRlZH1zZWxlY3QoKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3MpKXJldHVybiBzdXBlci5zZWxlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXS5nZXRDb250ZXh0KCk7aWYodGhpcy5fcGFyZW50RWRnZT09PWUmJih0PT09dGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleHx8dCsxPT09dGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleCkpcmV0dXJuIG51bGw7dGhpcy5faXNOb2RlQWRkZWR8PXRoaXMuX2hvdFBpeGVsLmFkZFNuYXBwZWROb2RlKGUsdCl9fX1EaS5Ib3RQaXhlbFNuYXBBY3Rpb249QWk7Y2xhc3MgRml7Y29uc3RydWN0b3IoKXtGaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1udWxsLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXQsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zPW5ldyBMfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpO3QrKyl0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnMuYWRkKHRoaXMuX2xpLmdldEludGVyc2VjdGlvbih0KSk7dC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSl9fWlzRG9uZSgpe3JldHVybiExfWdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1JpXX19Y2xhc3MgR2l7Y29uc3RydWN0b3IoKXtHaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wbT1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3BvaW50U25hcHBlcj1udWxsLHRoaXMuX25vZGVkU2VnU3RyaW5ncz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BtPXQsdGhpcy5fbGk9bmV3IGp0LHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHQpLHRoaXMuX3NjYWxlRmFjdG9yPXQuZ2V0U2NhbGUoKX1jaGVja0NvcnJlY3RuZXNzKHQpe2NvbnN0IGU9WnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQpLHM9bmV3IHZpKGUpO3RyeXtzLmNoZWNrVmFsaWQoKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBuKSl0aHJvdyB0O3QucHJpbnRTdGFja1RyYWNlKCl9fWdldE5vZGVkU3Vic3RyaW5ncygpe3JldHVybiBacy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKX1zbmFwUm91bmQodCxlKXtjb25zdCBuPXRoaXMuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzKG4pLHRoaXMuY29tcHV0ZVZlcnRleFNuYXBzKHQpfWZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKXtjb25zdCBuPW5ldyBGaShlKTtyZXR1cm4gdGhpcy5fbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKG4pLHRoaXMuX25vZGVyLmNvbXB1dGVOb2Rlcyh0KSxuLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpfWNvbXB1dGVWZXJ0ZXhTbmFwcygpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuY29tcHV0ZVZlcnRleFNuYXBzKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWnMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCBzPW5ldyBiaShlW25dLHRoaXMuX3NjYWxlRmFjdG9yLHRoaXMuX2xpKTt0aGlzLl9wb2ludFNuYXBwZXIuc25hcChzLHQsbikmJnQuYWRkSW50ZXJzZWN0aW9uKGVbbl0sbil9fX1jb21wdXRlTm9kZXModCl7dGhpcy5fbm9kZWRTZWdTdHJpbmdzPXQsdGhpcy5fbm9kZXI9bmV3IHRpLHRoaXMuX3BvaW50U25hcHBlcj1uZXcgRGkodGhpcy5fbm9kZXIuZ2V0SW5kZXgoKSksdGhpcy5zbmFwUm91bmQodCx0aGlzLl9saSl9Y29tcHV0ZUludGVyc2VjdGlvblNuYXBzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49bmV3IGJpKHQsdGhpcy5fc2NhbGVGYWN0b3IsdGhpcy5fbGkpO3RoaXMuX3BvaW50U25hcHBlci5zbmFwKG4pfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSnNdfX1jbGFzcyBxaXtjb25zdHJ1Y3Rvcigpe3FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2FyZ0dlb209bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2J1ZlBhcmFtcz1uZXcgYWksdGhpcy5fcmVzdWx0R2VvbWV0cnk9bnVsbCx0aGlzLl9zYXZlRXhjZXB0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZ0dlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9hcmdHZW9tPXQsdGhpcy5fYnVmUGFyYW1zPWV9fXN0YXRpYyBidWZmZXJPcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHFpKGFyZ3VtZW50c1swXSkuZ2V0UmVzdWx0R2VvbWV0cnkodCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPW5ldyBxaShhcmd1bWVudHNbMF0pO24uc2V0UXVhZHJhbnRTZWdtZW50cyhlKTtyZXR1cm4gbi5nZXRSZXN1bHRHZW9tZXRyeSh0KX1pZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIGFpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgcWkoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1syXSkuZ2V0UmVzdWx0R2VvbWV0cnkodCl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdLHM9bmV3IHFpKGFyZ3VtZW50c1swXSk7cy5zZXRRdWFkcmFudFNlZ21lbnRzKGUpLHMuc2V0RW5kQ2FwU3R5bGUobik7cmV0dXJuIHMuZ2V0UmVzdWx0R2VvbWV0cnkodCl9fXN0YXRpYyBwcmVjaXNpb25TY2FsZUZhY3Rvcih0LGUsbil7Y29uc3Qgcz10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPVYubWF4KE1hdGguYWJzKHMuZ2V0TWF4WCgpKSxNYXRoLmFicyhzLmdldE1heFkoKSksTWF0aC5hYnMocy5nZXRNaW5YKCkpLE1hdGguYWJzKHMuZ2V0TWluWSgpKSkrMiooZT4wP2U6MCkscj1uLU1hdGgudHJ1bmMoTWF0aC5sb2coaSkvTWF0aC5sb2coMTApKzEpO3JldHVybiBNYXRoLnBvdygxMCxyKX1idWZmZXJGaXhlZFByZWNpc2lvbih0KXtjb25zdCBlPW5ldyBuaShuZXcgR2kobmV3IHd0KDEpKSx0LmdldFNjYWxlKCkpLG49bmV3IE9pKHRoaXMuX2J1ZlBhcmFtcyk7bi5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCksbi5zZXROb2RlcihlKSx0aGlzLl9yZXN1bHRHZW9tZXRyeT1uLmJ1ZmZlcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlKX1idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD1xaS5NQVhfUFJFQ0lTSU9OX0RJR0lUUzt0Pj0wO3QtLSl7dHJ5e3RoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbih0KX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBpcykpdGhyb3cgdDt0aGlzLl9zYXZlRXhjZXB0aW9uPXR9aWYobnVsbCE9PXRoaXMuX3Jlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsfXRocm93IHRoaXMuX3NhdmVFeGNlcHRpb259aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9cWkucHJlY2lzaW9uU2NhbGVGYWN0b3IodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSx0KSxuPW5ldyB3dChlKTt0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKG4pfX1jb21wdXRlR2VvbWV0cnkoKXtpZih0aGlzLmJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCksbnVsbCE9PXRoaXMuX3Jlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5fYXJnR2VvbS5nZXRGYWN0b3J5KCkuZ2V0UHJlY2lzaW9uTW9kZWwoKTt0LmdldFR5cGUoKT09PXd0LkZJWEVEP3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24odCk6dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl9c2V0UXVhZHJhbnRTZWdtZW50cyh0KXt0aGlzLl9idWZQYXJhbXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpe3RyeXtjb25zdCB0PW5ldyBPaSh0aGlzLl9idWZQYXJhbXMpO3RoaXMuX3Jlc3VsdEdlb21ldHJ5PXQuYnVmZmVyKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7dGhpcy5fc2F2ZUV4Y2VwdGlvbj10fX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5fZGlzdGFuY2U9dCx0aGlzLmNvbXB1dGVHZW9tZXRyeSgpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5fXNldEVuZENhcFN0eWxlKHQpe3RoaXMuX2J1ZlBhcmFtcy5zZXRFbmRDYXBTdHlsZSh0KX19cWkuQ0FQX1JPVU5EPWFpLkNBUF9ST1VORCxxaS5DQVBfQlVUVD1haS5DQVBfRkxBVCxxaS5DQVBfRkxBVD1haS5DQVBfRkxBVCxxaS5DQVBfU1FVQVJFPWFpLkNBUF9TUVVBUkUscWkuTUFYX1BSRUNJU0lPTl9ESUdJVFM9MTI7dmFyIEJpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEJ1ZmZlck9wOnFpLEJ1ZmZlclBhcmFtZXRlcnM6YWl9KTtjbGFzcyBZaXtjb25zdHJ1Y3Rvcigpe1lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2NvbXBvbmVudD1udWxsLHRoaXMuX3NlZ0luZGV4PW51bGwsdGhpcy5fcHQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07WWkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LFlpLklOU0lERV9BUkVBLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2NvbXBvbmVudD10LHRoaXMuX3NlZ0luZGV4PWUsdGhpcy5fcHQ9bn19Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9aXNJbnNpZGVBcmVhKCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4PT09WWkuSU5TSURFX0FSRUF9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50LmdldEdlb21ldHJ5VHlwZSgpK1wiW1wiK3RoaXMuX3NlZ0luZGV4K1wiXS1cIitXdC50b1BvaW50KHRoaXMuX3B0KX1nZXRHZW9tZXRyeUNvbXBvbmVudCgpe3JldHVybiB0aGlzLl9jb21wb25lbnR9fVlpLklOU0lERV9BUkVBPS0xO2NsYXNzIFZpe2NvbnN0cnVjdG9yKCl7VmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbG9jYXRpb25zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbG9jYXRpb25zPXR9c3RhdGljIGdldExvY2F0aW9ucyh0KXtjb25zdCBlPW5ldyBMO3JldHVybiB0LmFwcGx5KG5ldyBWaShlKSksZX1maWx0ZXIodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7KHQgaW5zdGFuY2VvZiBldHx8dCBpbnN0YW5jZW9mICR8fHQgaW5zdGFuY2VvZiBydCkmJnRoaXMuX2xvY2F0aW9ucy5hZGQobmV3IFlpKHQsMCx0LmdldENvb3JkaW5hdGUoKSkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltKXX19Y2xhc3Mgeml7Y29uc3RydWN0b3IoKXt6aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fdGVybWluYXRlRGlzdGFuY2U9MCx0aGlzLl9wdExvY2F0b3I9bmV3IGZuLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb249bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07emkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lLHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlPW59fXN0YXRpYyBkaXN0YW5jZSh0LGUpe3JldHVybiBuZXcgemkodCxlKS5kaXN0YW5jZSgpfXN0YXRpYyBpc1dpdGhpbkRpc3RhbmNlKHQsZSxuKXtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+bilyZXR1cm4hMTtyZXR1cm4gbmV3IHppKHQsZSxuKS5kaXN0YW5jZSgpPD1ufXN0YXRpYyBuZWFyZXN0UG9pbnRzKHQsZSl7cmV0dXJuIG5ldyB6aSh0LGUpLm5lYXJlc3RQb2ludHMoKX1jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMCx0KSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fZ2VvbVt0XTtpZihuLmdldERpbWVuc2lvbigpPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz0xLXQsaT1JZS5nZXRQb2x5Z29ucyhuKTtpZihpLnNpemUoKT4wKXtjb25zdCBuPVZpLmdldExvY2F0aW9ucyh0aGlzLl9nZW9tW3NdKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKG4saSxlKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bc109ZVswXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3RdPWVbMV0sbnVsbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZJKGFyZ3VtZW50c1swXSxDKSYmSShhcmd1bWVudHNbMV0sQykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKWlmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoaSxlLmdldCh0KSxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBZaSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBydCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmdldENvb3JkaW5hdGUoKTtpZihRdC5FWFRFUklPUiE9PXRoaXMuX3B0TG9jYXRvci5sb2NhdGUocyxlKSlyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U9MCxuWzBdPXQsblsxXT1uZXcgWWkoZSxzKSxudWxsfX1jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWNvbXB1dGVGYWNldERpc3RhbmNlKCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxlPXllLmdldExpbmVzKHRoaXMuX2dlb21bMF0pLG49eWUuZ2V0TGluZXModGhpcy5fZ2VvbVsxXSkscz1FZS5nZXRQb2ludHModGhpcy5fZ2VvbVswXSksaT1FZS5nZXRQb2ludHModGhpcy5fZ2VvbVsxXSk7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMoZSxuLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhlLGksdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKG4scyx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITApLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHMsaSx0KSx2b2lkIHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSkpKSl9bmVhcmVzdExvY2F0aW9ucygpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb259dXBkYXRlTWluRGlzdGFuY2UodCxlKXtpZihudWxsPT09dFswXSlyZXR1cm4gbnVsbDtlPyh0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMV0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzBdKToodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXT10WzBdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV09dFsxXSl9bmVhcmVzdFBvaW50cygpe3RoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7cmV0dXJuW3RoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV0uZ2V0Q29vcmRpbmF0ZSgpXX1jb21wdXRlTWluRGlzdGFuY2UoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7aWYobnVsbCE9PXRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb24pcmV0dXJuIG51bGw7aWYodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUZhY2V0RGlzdGFuY2UoKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBldCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMuX21pbkRpc3RhbmNlKXJldHVybiBudWxsO2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlKCk7Zm9yKGxldCByPTA7cjxzLmxlbmd0aC0xO3IrKyl7Y29uc3Qgbz16LnBvaW50VG9TZWdtZW50KGksc1tyXSxzW3IrMV0pO2lmKG88dGhpcy5fbWluRGlzdGFuY2Upe3RoaXMuX21pbkRpc3RhbmNlPW87Y29uc3QgbD1uZXcgS3Qoc1tyXSxzW3IrMV0pLmNsb3Nlc3RQb2ludChpKTtuWzBdPW5ldyBZaSh0LHIsbCksblsxXT1uZXcgWWkoZSwwLGkpfWlmKHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgJCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMuX21pbkRpc3RhbmNlKXJldHVybiBudWxsO2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgcj0wO3I8cy5sZW5ndGgtMTtyKyspe2NvbnN0IG89bmV3IE8oc1tyXSxzW3IrMV0pO2lmKCEoby5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpKWZvcihsZXQgbD0wO2w8aS5sZW5ndGgtMTtsKyspe2NvbnN0IGE9bmV3IE8oaVtsXSxpW2wrMV0pO2lmKG8uZGlzdGFuY2UoYSk+dGhpcy5fbWluRGlzdGFuY2UpY29udGludWU7Y29uc3QgYz16LnNlZ21lbnRUb1NlZ21lbnQoc1tyXSxzW3IrMV0saVtsXSxpW2wrMV0pO2lmKGM8dGhpcy5fbWluRGlzdGFuY2Upe3RoaXMuX21pbkRpc3RhbmNlPWM7Y29uc3Qgbz1uZXcgS3Qoc1tyXSxzW3IrMV0pLGE9bmV3IEt0KGlbbF0saVtsKzFdKSxoPW8uY2xvc2VzdFBvaW50cyhhKTtuWzBdPW5ldyBZaSh0LHIsaFswXSksblsxXT1uZXcgWWkoZSxsLGhbMV0pfWlmKHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fX1jb21wdXRlTWluRGlzdGFuY2VQb2ludHModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpLHI9aS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2Uocy5nZXRDb29yZGluYXRlKCkpO2lmKHI8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9taW5EaXN0YW5jZT1yLG5bMF09bmV3IFlpKGksMCxpLmdldENvb3JkaW5hdGUoKSksblsxXT1uZXcgWWkocywwLHMuZ2V0Q29vcmRpbmF0ZSgpKSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19ZGlzdGFuY2UoKXtpZihudWxsPT09dGhpcy5fZ2VvbVswXXx8bnVsbD09PXRoaXMuX2dlb21bMV0pdGhyb3cgbmV3IHMoXCJudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuX2dlb21bMF0uaXNFbXB0eSgpfHx0aGlzLl9nZW9tWzFdLmlzRW1wdHkoKT8wOih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlKX1jb21wdXRlTWluRGlzdGFuY2VMaW5lcyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fX12YXIgWGk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGlzdGFuY2VPcDp6aX0pO2NsYXNzIGtpe2NvbnN0cnVjdG9yKCl7a2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2RpcmVjdGVkRWRnZXM9bmV3IEwsdGhpcy5fY29vcmRpbmF0ZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9Z2V0Q29vcmRpbmF0ZXMoKXtpZihudWxsPT09dGhpcy5fY29vcmRpbmF0ZXMpe2xldCB0PTAsZT0wO2NvbnN0IG49bmV3IFI7Zm9yKGxldCBzPXRoaXMuX2RpcmVjdGVkRWRnZXMuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCk7aS5nZXRFZGdlRGlyZWN0aW9uKCk/dCsrOmUrKyxuLmFkZChpLmdldEVkZ2UoKS5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSwhMSxpLmdldEVkZ2VEaXJlY3Rpb24oKSl9dGhpcy5fY29vcmRpbmF0ZXM9bi50b0Nvb3JkaW5hdGVBcnJheSgpLGU+dCYmX3QucmV2ZXJzZSh0aGlzLl9jb29yZGluYXRlcyl9cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfXRvTGluZVN0cmluZygpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKX1hZGQodCl7dGhpcy5fZGlyZWN0ZWRFZGdlcy5hZGQodCl9fWNsYXNzIFVpe2NvbnN0cnVjdG9yKCl7VWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNNYXJrZWQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuX2RhdGE9bnVsbH1zdGF0aWMgZ2V0Q29tcG9uZW50V2l0aFZpc2l0ZWRTdGF0ZSh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO2lmKG4uaXNWaXNpdGVkKCk9PT1lKXJldHVybiBufXJldHVybiBudWxsfXN0YXRpYyBzZXRWaXNpdGVkKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3QubmV4dCgpLnNldFZpc2l0ZWQoZSl9fXN0YXRpYyBzZXRNYXJrZWQodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0TWFya2VkKGUpfX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fWlzTWFya2VkKCl7cmV0dXJuIHRoaXMuX2lzTWFya2VkfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1zZXRNYXJrZWQodCl7dGhpcy5faXNNYXJrZWQ9dH1nZXRDb250ZXh0KCl7cmV0dXJuIHRoaXMuX2RhdGF9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH1zZXRDb250ZXh0KHQpe3RoaXMuX2RhdGE9dH19Y2xhc3MgSGkgZXh0ZW5kcyBVaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcGFyZW50RWRnZT1udWxsLHRoaXMuX2Zyb209bnVsbCx0aGlzLl90bz1udWxsLHRoaXMuX3AwPW51bGwsdGhpcy5fcDE9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9lZGdlRGlyZWN0aW9uPW51bGwsdGhpcy5fcXVhZHJhbnQ9bnVsbCx0aGlzLl9hbmdsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9mcm9tPXQsdGhpcy5fdG89ZSx0aGlzLl9lZGdlRGlyZWN0aW9uPXMsdGhpcy5fcDA9dC5nZXRDb29yZGluYXRlKCksdGhpcy5fcDE9bjtjb25zdCBpPXRoaXMuX3AxLngtdGhpcy5fcDAueCxyPXRoaXMuX3AxLnktdGhpcy5fcDAueTt0aGlzLl9xdWFkcmFudD1Dbi5xdWFkcmFudChpLHIpLHRoaXMuX2FuZ2xlPU1hdGguYXRhbjIocixpKX19c3RhdGljIHRvRWRnZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmFkZChuLm5leHQoKS5fcGFyZW50RWRnZSk7cmV0dXJuIGV9aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9wYXJlbnRFZGdlfWNvbXBhcmVEaXJlY3Rpb24odCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50PnQuX3F1YWRyYW50PzE6dGhpcy5fcXVhZHJhbnQ8dC5fcXVhZHJhbnQ/LTE6cS5pbmRleCh0Ll9wMCx0Ll9wMSx0aGlzLl9wMSl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9mcm9tLmdldENvb3JkaW5hdGUoKX1wcmludCh0KXtjb25zdCBlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKSxzPWUuc3Vic3RyaW5nKG4rMSk7dC5wcmludChcIiAgXCIrcytcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIit0aGlzLl9hbmdsZSl9Z2V0RGlyZWN0aW9uUHQoKXtyZXR1cm4gdGhpcy5fcDF9Z2V0QW5nbGUoKXtyZXR1cm4gdGhpcy5fYW5nbGV9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpfWdldEZyb21Ob2RlKCl7cmV0dXJuIHRoaXMuX2Zyb219Z2V0U3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1zZXRFZGdlKHQpe3RoaXMuX3BhcmVudEVkZ2U9dH1yZW1vdmUoKXt0aGlzLl9zeW09bnVsbCx0aGlzLl9wYXJlbnRFZGdlPW51bGx9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9wYXJlbnRFZGdlfWdldFF1YWRyYW50KCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50fXNldFN5bSh0KXt0aGlzLl9zeW09dH1nZXRUb05vZGUoKXtyZXR1cm4gdGhpcy5fdG99Z2V0RWRnZURpcmVjdGlvbigpe3JldHVybiB0aGlzLl9lZGdlRGlyZWN0aW9ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgV2kgZXh0ZW5kcyBIaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksV2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107SGkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixzKX1nZXROZXh0KCl7cmV0dXJuIDIhPT10aGlzLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpP251bGw6dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApPT09dGhpcy5nZXRTeW0oKT90aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk6KGcuaXNUcnVlKHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKT09PXRoaXMuZ2V0U3ltKCkpLHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKSl9fWNsYXNzIFppIGV4dGVuZHMgVWl7Y29uc3RydWN0b3IoKXtzdXBlcigpLFppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2RpckVkZ2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXREaXJlY3RlZEVkZ2VzKHQsZSl9fWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fZGlyRWRnZX1zZXREaXJlY3RlZEVkZ2VzKHQsZSl7dGhpcy5fZGlyRWRnZT1bdCxlXSx0LnNldEVkZ2UodGhpcyksZS5zZXRFZGdlKHRoaXMpLHQuc2V0U3ltKGUpLGUuc2V0U3ltKHQpLHQuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKHQpLGUuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKGUpfWdldERpckVkZ2UoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlW3RdfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS2kpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMF06dGhpcy5fZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzFdOm51bGx9fXJlbW92ZSgpe3RoaXMuX2RpckVkZ2U9bnVsbH1nZXRPcHBvc2l0ZU5vZGUodCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVswXS5nZXRUb05vZGUoKTp0aGlzLl9kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMV0uZ2V0VG9Ob2RlKCk6bnVsbH19Y2xhc3Mgaml7Y29uc3RydWN0b3IoKXtqaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vdXRFZGdlcz1uZXcgTCx0aGlzLl9zb3J0ZWQ9ITF9Z2V0TmV4dEVkZ2UodCl7Y29uc3QgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLl9vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlKzEpKX1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD10aGlzLml0ZXJhdG9yKCk7aWYoIXQuaGFzTmV4dCgpKXJldHVybiBudWxsO3JldHVybiB0Lm5leHQoKS5nZXRDb29yZGluYXRlKCl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLl9vdXRFZGdlcy5pdGVyYXRvcigpfXNvcnRFZGdlcygpe3RoaXMuX3NvcnRlZHx8KHhlLnNvcnQodGhpcy5fb3V0RWRnZXMpLHRoaXMuX3NvcnRlZD0hMCl9cmVtb3ZlKHQpe3RoaXMuX291dEVkZ2VzLnJlbW92ZSh0KX1nZXRFZGdlcygpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMuX291dEVkZ2VzfWdldE5leHRDV0VkZ2UodCl7Y29uc3QgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLl9vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlLTEpKX1nZXRJbmRleCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9vdXRFZGdlcy5zaXplKCk7ZSsrKXtpZih0aGlzLl9vdXRFZGdlcy5nZXQoZSkuZ2V0RWRnZSgpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEhpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2ZvcihsZXQgZT0wO2U8dGhpcy5fb3V0RWRnZXMuc2l6ZSgpO2UrKyl7aWYodGhpcy5fb3V0RWRnZXMuZ2V0KGUpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2xldCB0PWFyZ3VtZW50c1swXSV0aGlzLl9vdXRFZGdlcy5zaXplKCk7cmV0dXJuIHQ8MCYmKHQrPXRoaXMuX291dEVkZ2VzLnNpemUoKSksdH19YWRkKHQpe3RoaXMuX291dEVkZ2VzLmFkZCh0KSx0aGlzLl9zb3J0ZWQ9ITF9Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX291dEVkZ2VzLnNpemUoKX19Y2xhc3MgS2kgZXh0ZW5kcyBVaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksS2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcHQ9bnVsbCx0aGlzLl9kZVN0YXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07S2kuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG5ldyBqaSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHQ9dCx0aGlzLl9kZVN0YXI9ZX19c3RhdGljIGdldEVkZ2VzQmV0d2Vlbih0LGUpe2NvbnN0IG49SGkudG9FZGdlcyh0LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSkscz1uZXcgRXQobiksaT1IaS50b0VkZ2VzKGUuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKTtyZXR1cm4gcy5yZXRhaW5BbGwoaSksc31pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3B0fWFkZE91dEVkZ2UodCl7dGhpcy5fZGVTdGFyLmFkZCh0KX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fWdldE91dEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2RlU3Rhcn1yZW1vdmUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9wdD1udWxsO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RlU3Rhci5yZW1vdmUodCl9fWdldEluZGV4KHQpe3JldHVybiB0aGlzLl9kZVN0YXIuZ2V0SW5kZXgodCl9Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2RlU3Rhci5nZXREZWdyZWUoKX19Y2xhc3MgUWkgZXh0ZW5kcyBaaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2xpbmV9fWNsYXNzIEppe2NvbnN0cnVjdG9yKCl7SmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZU1hcD1uZXcgV259ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5nZXQodCl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfXJlbW92ZSh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5yZW1vdmUodCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCl9YWRkKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0fX1jbGFzcyAkaXtjb25zdHJ1Y3RvcigpeyRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2VkZ2VzPW5ldyBFdCx0aGlzLl9kaXJFZGdlcz1uZXcgRXQsdGhpcy5fbm9kZU1hcD1uZXcgSml9ZmluZE5vZGVzT2ZEZWdyZWUodCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dGhpcy5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5nZXREZWdyZWUoKT09PXQmJmUuYWRkKHMpfXJldHVybiBlfWRpckVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpfWVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfXJlbW92ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDEpKSx0aGlzLl9lZGdlcy5yZW1vdmUodCksdC5yZW1vdmUoKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRTeW0oKTtudWxsIT09ZSYmZS5zZXRTeW0obnVsbCksdC5nZXRGcm9tTm9kZSgpLnJlbW92ZSh0KSx0LnJlbW92ZSgpLHRoaXMuX2RpckVkZ2VzLnJlbW92ZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS2kpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0U3ltKCk7bnVsbCE9PW4mJnRoaXMucmVtb3ZlKG4pLHRoaXMuX2RpckVkZ2VzLnJlbW92ZSh0KTtjb25zdCBzPXQuZ2V0RWRnZSgpO251bGwhPT1zJiZ0aGlzLl9lZGdlcy5yZW1vdmUocyl9dGhpcy5fbm9kZU1hcC5yZW1vdmUodC5nZXRDb29yZGluYXRlKCkpLHQucmVtb3ZlKCl9fWZpbmROb2RlKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLmZpbmQodCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9bm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuaXRlcmF0b3IoKX1jb250YWlucygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWmkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9lZGdlcy5jb250YWlucyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEhpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuY29udGFpbnModCl9fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS2kpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25vZGVNYXAuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBaaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZXMuYWRkKHQpLHRoaXMuYWRkKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5hZGQodC5nZXREaXJFZGdlKDEpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RpckVkZ2VzLmFkZCh0KX19Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKX19Y2xhc3MgdHIgZXh0ZW5kcyAkaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9YWRkRWRnZSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPV90LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8PTEpcmV0dXJuIG51bGw7Y29uc3Qgbj1lWzBdLHM9ZVtlLmxlbmd0aC0xXSxpPXRoaXMuZ2V0Tm9kZShuKSxyPXRoaXMuZ2V0Tm9kZShzKSxvPW5ldyBXaShpLHIsZVsxXSwhMCksbD1uZXcgV2kocixpLGVbZS5sZW5ndGgtMl0sITEpLGE9bmV3IFFpKHQpO2Euc2V0RGlyZWN0ZWRFZGdlcyhvLGwpLHRoaXMuYWRkKGEpfWdldE5vZGUodCl7bGV0IGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBLaSh0KSx0aGlzLmFkZChlKSksZX19Y2xhc3MgZXJ7Y29uc3RydWN0b3IoKXtlci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1uZXcgdHIsdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZWRnZVN0cmluZ3M9bnVsbH1idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuaXNNYXJrZWQoKXx8KGcuaXNUcnVlKDI9PT1lLmdldERlZ3JlZSgpKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fWJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTsyIT09ZS5nZXREZWdyZWUoKSYmKHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19YnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzKCl9Z2V0TWVyZ2VkTGluZVN0cmluZ3MoKXtyZXR1cm4gdGhpcy5tZXJnZSgpLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzfWJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KHQpe2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5nZXRFZGdlKCkuaXNNYXJrZWQoKXx8dGhpcy5fZWRnZVN0cmluZ3MuYWRkKHRoaXMuYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKHQpKX19bWVyZ2UoKXtpZihudWxsIT09dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3MpcmV0dXJuIG51bGw7VWkuc2V0TWFya2VkKHRoaXMuX2dyYXBoLm5vZGVJdGVyYXRvcigpLCExKSxVaS5zZXRNYXJrZWQodGhpcy5fZ3JhcGguZWRnZUl0ZXJhdG9yKCksITEpLHRoaXMuX2VkZ2VTdHJpbmdzPW5ldyBMLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzPW5ldyBMO2ZvcihsZXQgdD10aGlzLl9lZGdlU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncy5hZGQoZS50b0xpbmVTdHJpbmcoKSl9fWFkZExpbmVTdHJpbmcodCl7bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpfWJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aCh0KXtjb25zdCBlPW5ldyBraSh0aGlzLl9mYWN0b3J5KTtsZXQgbj10O2Rve2UuYWRkKG4pLG4uZ2V0RWRnZSgpLnNldE1hcmtlZCghMCksbj1uLmdldE5leHQoKX13aGlsZShudWxsIT09biYmbiE9PXQpO3JldHVybiBlfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7biBpbnN0YW5jZW9mICQmJnRoaXMuYWRkTGluZVN0cmluZyhuKX19ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bnVsbDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmFkZCh0KX19fWJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlcygpfX1jbGFzcyBucntjb25zdHJ1Y3Rvcigpe25yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BhcmVudEdyYXBoPW51bGwsdGhpcy5fZWRnZXM9bmV3IEV0LHRoaXMuX2RpckVkZ2VzPW5ldyBMLHRoaXMuX25vZGVNYXA9bmV3IEppO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudEdyYXBoPXR9ZGlyRWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCl9ZWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudEdyYXBofW5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLml0ZXJhdG9yKCl9Y29udGFpbnModCl7cmV0dXJuIHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpfWFkZCh0KXtpZih0aGlzLl9lZGdlcy5jb250YWlucyh0KSlyZXR1cm4gbnVsbDt0aGlzLl9lZGdlcy5hZGQodCksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5fbm9kZU1hcC5hZGQodC5nZXREaXJFZGdlKDApLmdldEZyb21Ob2RlKCkpLHRoaXMuX25vZGVNYXAuYWRkKHQuZ2V0RGlyRWRnZSgxKS5nZXRGcm9tTm9kZSgpKX19Y2xhc3Mgc3J7Y29uc3RydWN0b3IoKXtzci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dyYXBoPXR9YWRkUmVhY2hhYmxlKHQsZSl7Y29uc3Qgbj1uZXcgZW47Zm9yKG4uYWRkKHQpOyFuLmVtcHR5KCk7KXtjb25zdCB0PW4ucG9wKCk7dGhpcy5hZGRFZGdlcyh0LG4sZSl9fWZpbmRTdWJncmFwaCh0KXtjb25zdCBlPW5ldyBucih0aGlzLl9ncmFwaCk7cmV0dXJuIHRoaXMuYWRkUmVhY2hhYmxlKHQsZSksZX1nZXRDb25uZWN0ZWRTdWJncmFwaHMoKXtjb25zdCB0PW5ldyBMO1VpLnNldFZpc2l0ZWQodGhpcy5fZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpO2ZvcihsZXQgZT10aGlzLl9ncmFwaC5lZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0RGlyRWRnZSgwKS5nZXRGcm9tTm9kZSgpO24uaXNWaXNpdGVkKCl8fHQuYWRkKHRoaXMuZmluZFN1YmdyYXBoKG4pKX1yZXR1cm4gdH1hZGRFZGdlcyh0LGUsbil7dC5zZXRWaXNpdGVkKCEwKTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO24uYWRkKHQuZ2V0RWRnZSgpKTtjb25zdCBpPXQuZ2V0VG9Ob2RlKCk7aS5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKGkpfX19Y2xhc3MgaXJ7Y29uc3RydWN0b3IoKXtpci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1uZXcgdHIsdGhpcy5fZmFjdG9yeT1uZXcgTHQsdGhpcy5fbGluZUNvdW50PTAsdGhpcy5faXNSdW49ITEsdGhpcy5fc2VxdWVuY2VkR2VvbWV0cnk9bnVsbCx0aGlzLl9pc1NlcXVlbmNlYWJsZT0hMX1zdGF0aWMgZmluZFVudmlzaXRlZEJlc3RPcmllbnRlZERFKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5nZXRFZGdlKCkuaXNWaXNpdGVkKCl8fChuPXQsdC5nZXRFZGdlRGlyZWN0aW9uKCkmJihlPXQpKX1yZXR1cm4gbnVsbCE9PWU/ZTpufXN0YXRpYyBmaW5kTG93ZXN0RGVncmVlTm9kZSh0KXtsZXQgZT1iLk1BWF9WQUxVRSxuPW51bGw7Zm9yKGxldCBzPXQubm9kZUl0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpOyhudWxsPT09bnx8dC5nZXREZWdyZWUoKTxlKSYmKGU9dC5nZXREZWdyZWUoKSxuPXQpfXJldHVybiBufXN0YXRpYyBpc1NlcXVlbmNlZCh0KXtpZighKHQgaW5zdGFuY2VvZiBTdCkpcmV0dXJuITA7Y29uc3QgZT10LG49bmV3IGF0O2xldCBzPW51bGw7Y29uc3QgaT1uZXcgTDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3Qgcj1lLmdldEdlb21ldHJ5Tih0KSxvPXIuZ2V0Q29vcmRpbmF0ZU4oMCksbD1yLmdldENvb3JkaW5hdGVOKHIuZ2V0TnVtUG9pbnRzKCktMSk7aWYobi5jb250YWlucyhvKSlyZXR1cm4hMTtpZihuLmNvbnRhaW5zKGwpKXJldHVybiExO251bGwhPT1zJiYoby5lcXVhbHMocyl8fChuLmFkZEFsbChpKSxpLmNsZWFyKCkpKSxpLmFkZChvKSxpLmFkZChsKSxzPWx9cmV0dXJuITB9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCksbj1uZXcgQXJyYXkoZS5sZW5ndGgpLmZpbGwobnVsbCkscz1lLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHM7dCsrKW5bcy0xLXRdPW5ldyBtKGVbdF0pO3JldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKG4pfXN0YXRpYyBzZXF1ZW5jZSh0KXtjb25zdCBlPW5ldyBpcjtyZXR1cm4gZS5hZGQodCksZS5nZXRTZXF1ZW5jZWRMaW5lU3RyaW5ncygpfWFkZExpbmUodCl7bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpLHRoaXMuX2xpbmVDb3VudCsrfWhhc1NlcXVlbmNlKHQpe2xldCBlPTA7Zm9yKGxldCBuPXQubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXREZWdyZWUoKSUyPT0xJiZlKyt9cmV0dXJuIGU8PTJ9Y29tcHV0ZVNlcXVlbmNlKCl7aWYodGhpcy5faXNSdW4pcmV0dXJuIG51bGw7dGhpcy5faXNSdW49ITA7Y29uc3QgdD10aGlzLmZpbmRTZXF1ZW5jZXMoKTtpZihudWxsPT09dClyZXR1cm4gbnVsbDt0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeT10aGlzLmJ1aWxkU2VxdWVuY2VkR2VvbWV0cnkodCksdGhpcy5faXNTZXF1ZW5jZWFibGU9ITA7Y29uc3QgZT10aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeS5nZXROdW1HZW9tZXRyaWVzKCk7Zy5pc1RydWUodGhpcy5fbGluZUNvdW50PT09ZSxcIkxpbmVzIHdlcmUgbWlzc2luZyBmcm9tIHJlc3VsdFwiKSxnLmlzVHJ1ZSh0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeSBpbnN0YW5jZW9mICR8fHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5IGluc3RhbmNlb2YgU3QsXCJSZXN1bHQgaXMgbm90IGxpbmVhbFwiKX1maW5kU2VxdWVuY2VzKCl7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9bmV3IHNyKHRoaXMuX2dyYXBoKS5nZXRDb25uZWN0ZWRTdWJncmFwaHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZighdGhpcy5oYXNTZXF1ZW5jZShuKSlyZXR1cm4gbnVsbDt7Y29uc3QgZT10aGlzLmZpbmRTZXF1ZW5jZShuKTt0LmFkZChlKX19cmV0dXJuIHR9YWRkUmV2ZXJzZVN1YnBhdGgodCxlLG4pe2NvbnN0IHM9dC5nZXRUb05vZGUoKTtsZXQgaT1udWxsO2Zvcig7Oyl7ZS5hZGQodC5nZXRTeW0oKSksdC5nZXRFZGdlKCkuc2V0VmlzaXRlZCghMCksaT10LmdldEZyb21Ob2RlKCk7Y29uc3Qgbj1pci5maW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUoaSk7aWYobnVsbD09PW4pYnJlYWs7dD1uLmdldFN5bSgpfW4mJmcuaXNUcnVlKGk9PT1zLFwicGF0aCBub3QgY29udGlndW91c1wiKX1maW5kU2VxdWVuY2UodCl7VWkuc2V0VmlzaXRlZCh0LmVkZ2VJdGVyYXRvcigpLCExKTtjb25zdCBlPWlyLmZpbmRMb3dlc3REZWdyZWVOb2RlKHQpLmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0U3ltKCksbj1uZXcgaGkscz1uLmxpc3RJdGVyYXRvcigpO2Zvcih0aGlzLmFkZFJldmVyc2VTdWJwYXRoKGUscywhMSk7cy5oYXNQcmV2aW91cygpOyl7Y29uc3QgdD1zLnByZXZpb3VzKCksZT1pci5maW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUodC5nZXRGcm9tTm9kZSgpKTtudWxsIT09ZSYmdGhpcy5hZGRSZXZlcnNlU3VicGF0aChlLmdldFN5bSgpLHMsITApfXJldHVybiB0aGlzLm9yaWVudChuKX1yZXZlcnNlKHQpe2NvbnN0IGU9bmV3IGhpO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkRmlyc3QodC5nZXRTeW0oKSl9cmV0dXJuIGV9b3JpZW50KHQpe2NvbnN0IGU9dC5nZXQoMCksbj10LmdldCh0LnNpemUoKS0xKSxzPWUuZ2V0RnJvbU5vZGUoKSxpPW4uZ2V0VG9Ob2RlKCk7bGV0IHI9ITE7aWYoMT09PXMuZ2V0RGVncmVlKCl8fDE9PT1pLmdldERlZ3JlZSgpKXtsZXQgdD0hMTsxPT09bi5nZXRUb05vZGUoKS5nZXREZWdyZWUoKSYmITE9PT1uLmdldEVkZ2VEaXJlY3Rpb24oKSYmKHQ9ITAscj0hMCksMT09PWUuZ2V0RnJvbU5vZGUoKS5nZXREZWdyZWUoKSYmITA9PT1lLmdldEVkZ2VEaXJlY3Rpb24oKSYmKHQ9ITAscj0hMSksdHx8MT09PWUuZ2V0RnJvbU5vZGUoKS5nZXREZWdyZWUoKSYmKHI9ITApfXJldHVybiByP3RoaXMucmV2ZXJzZSh0KTp0fWJ1aWxkU2VxdWVuY2VkR2VvbWV0cnkodCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Zm9yKGxldCB0PW4ubmV4dCgpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRFZGdlKCkuZ2V0TGluZSgpO2xldCBpPXM7bi5nZXRFZGdlRGlyZWN0aW9uKCl8fHMuaXNDbG9zZWQoKXx8KGk9aXIucmV2ZXJzZShzKSksZS5hZGQoaSl9fXJldHVybiAwPT09ZS5zaXplKCk/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobmV3IEFycmF5KDApLmZpbGwobnVsbCkpOnRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShlKX1nZXRTZXF1ZW5jZWRMaW5lU3RyaW5ncygpe3JldHVybiB0aGlzLmNvbXB1dGVTZXF1ZW5jZSgpLHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5fWlzU2VxdWVuY2VhYmxlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVNlcXVlbmNlKCksdGhpcy5faXNTZXF1ZW5jZWFibGV9YWRkKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGQoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXthcmd1bWVudHNbMF0uYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mICQmJnRoaXMuYWRkTGluZSh0KX19KX19fXZhciBycj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMaW5lTWVyZ2VyOmVyLExpbmVTZXF1ZW5jZXI6aXJ9KTtjbGFzcyBvcntjb25zdHJ1Y3Rvcigpe29yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3NuYXBUb2xlcmFuY2U9MCx0aGlzLl9zcmNQdHM9bnVsbCx0aGlzLl9zZWc9bmV3IEt0LHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPSExLHRoaXMuX2lzQ2xvc2VkPSExLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07b3IuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGVzKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9zcmNQdHM9dCx0aGlzLl9pc0Nsb3NlZD1vci5pc0Nsb3NlZCh0KSx0aGlzLl9zbmFwVG9sZXJhbmNlPWV9fXN0YXRpYyBpc0Nsb3NlZCh0KXtyZXR1cm4hKHQubGVuZ3RoPD0xKSYmdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX1zbmFwVmVydGljZXModCxlKXtjb25zdCBuPXRoaXMuX2lzQ2xvc2VkP3Quc2l6ZSgpLTE6dC5zaXplKCk7Zm9yKGxldCBzPTA7czxuO3MrKyl7Y29uc3Qgbj10LmdldChzKSxpPXRoaXMuZmluZFNuYXBGb3JWZXJ0ZXgobixlKTtudWxsIT09aSYmKHQuc2V0KHMsbmV3IG0oaSkpLDA9PT1zJiZ0aGlzLl9pc0Nsb3NlZCYmdC5zZXQodC5zaXplKCktMSxuZXcgbShpKSkpfX1maW5kU25hcEZvclZlcnRleCh0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtpZih0LmVxdWFsczJEKGVbbl0pKXJldHVybiBudWxsO2lmKHQuZGlzdGFuY2UoZVtuXSk8dGhpcy5fc25hcFRvbGVyYW5jZSlyZXR1cm4gZVtuXX1yZXR1cm4gbnVsbH1zbmFwVG8odCl7Y29uc3QgZT1uZXcgUih0aGlzLl9zcmNQdHMpO3RoaXMuc25hcFZlcnRpY2VzKGUsdCksdGhpcy5zbmFwU2VnbWVudHMoZSx0KTtyZXR1cm4gZS50b0Nvb3JkaW5hdGVBcnJheSgpfXNuYXBTZWdtZW50cyh0LGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDtsZXQgbj1lLmxlbmd0aDtlWzBdLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pJiYobj1lLmxlbmd0aC0xKTtmb3IobGV0IHM9MDtzPG47cysrKXtjb25zdCBuPWVbc10saT10aGlzLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAobix0KTtpPj0wJiZ0LmFkZChpKzEsbmV3IG0obiksITEpfX1maW5kU2VnbWVudEluZGV4VG9TbmFwKHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz0tMTtmb3IobGV0IGk9MDtpPGUuc2l6ZSgpLTE7aSsrKXtpZih0aGlzLl9zZWcucDA9ZS5nZXQoaSksdGhpcy5fc2VnLnAxPWUuZ2V0KGkrMSksdGhpcy5fc2VnLnAwLmVxdWFsczJEKHQpfHx0aGlzLl9zZWcucDEuZXF1YWxzMkQodCkpe2lmKHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKWNvbnRpbnVlO3JldHVybi0xfWNvbnN0IHI9dGhpcy5fc2VnLmRpc3RhbmNlKHQpO3I8dGhpcy5fc25hcFRvbGVyYW5jZSYmcjxuJiYobj1yLHM9aSl9cmV0dXJuIHN9c2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModCl7dGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9dH19Y2xhc3MgbHJ7Y29uc3RydWN0b3IoKXtsci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zcmNHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3JjR2VvbT10fXN0YXRpYyBzbmFwKHQsZSxuKXtjb25zdCBzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGk9bmV3IGxyKHQpO3NbMF09aS5zbmFwVG8oZSxuKTtjb25zdCByPW5ldyBscihlKTtyZXR1cm4gc1sxXT1yLnNuYXBUbyhzWzBdLG4pLHN9c3RhdGljIGNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1sci5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KTtjb25zdCBuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKTtpZihuLmdldFR5cGUoKT09PXd0LkZJWEVEKXtjb25zdCB0PTEvbi5nZXRTY2FsZSgpKjIvMS40MTU7dD5lJiYoZT10KX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIE1hdGgubWluKGxyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0KSxsci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UoZSkpfX1zdGF0aWMgY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gTWF0aC5taW4oZS5nZXRIZWlnaHQoKSxlLmdldFdpZHRoKCkpKmxyLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUn1zdGF0aWMgc25hcFRvU2VsZih0LGUsbil7cmV0dXJuIG5ldyBscih0KS5zbmFwVG9TZWxmKGUsbil9c25hcFRvKHQsZSl7Y29uc3Qgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KTtyZXR1cm4gbmV3IGFyKGUsbikudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pfXNuYXBUb1NlbGYodCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHRoaXMuX3NyY0dlb20pLHM9bmV3IGFyKHQsbiwhMCkudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pO2xldCBpPXM7cmV0dXJuIGUmJkkoaSxpdCkmJihpPXMuYnVmZmVyKDApKSxpfWNvbXB1dGVTbmFwVG9sZXJhbmNlKHQpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KS8xMH1leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgYXQsbj10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0KyspZS5hZGQoblt0XSk7cmV0dXJuIGUudG9BcnJheShuZXcgQXJyYXkoMCkuZmlsbChudWxsKSl9Y29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpe2xldCBlPXIuTUFYX1ZBTFVFO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspe2NvbnN0IHM9dFtuXS5kaXN0YW5jZSh0W24rMV0pO3M8ZSYmKGU9cyl9cmV0dXJuIGV9fWxyLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUj0xZS05O2NsYXNzIGFyIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGFyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3NuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLl9zbmFwUHRzPW51bGwsdGhpcy5faXNTZWxmU25hcD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fc25hcFRvbGVyYW5jZT10LHRoaXMuX3NuYXBQdHM9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9zbmFwVG9sZXJhbmNlPXQsdGhpcy5fc25hcFB0cz1lLHRoaXMuX2lzU2VsZlNuYXA9bn19c25hcExpbmUodCxlKXtjb25zdCBuPW5ldyBvcih0LHRoaXMuX3NuYXBUb2xlcmFuY2UpO3JldHVybiBuLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHRoaXMuX2lzU2VsZlNuYXApLG4uc25hcFRvKGUpfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCkscz10aGlzLnNuYXBMaW5lKG4sdGhpcy5fc25hcFB0cyk7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX19dmFyIGNyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5U25hcHBlcjpscixMaW5lU3RyaW5nU25hcHBlcjpvcn0pO2NsYXNzIGhye2NvbnN0cnVjdG9yKCl7aHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fZGF0YT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX2RhdGE9ZX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdHN9c2l6ZSgpe3JldHVybiB0aGlzLl9wdHMubGVuZ3RofWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0c1t0XX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoLTFdKX1nZXRTZWdtZW50T2N0YW50KHQpe3JldHVybiB0PT09dGhpcy5fcHRzLmxlbmd0aC0xPy0xOlVzLm9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcobmV3IG10KHRoaXMuX3B0cykpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIc119fWNsYXNzIHVye2NvbnN0cnVjdG9yKCl7dXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seT0hMSx0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucz0hMCx0aGlzLl9pc0ludGVyaW9ySW50ZXJzZWN0aW9uc09ubHk9ITEsdGhpcy5fbGk9bnVsbCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj1udWxsLHRoaXMuX2ludFNlZ21lbnRzPW51bGwsdGhpcy5faW50ZXJzZWN0aW9ucz1uZXcgTCx0aGlzLl9pbnRlcnNlY3Rpb25Db3VudD0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXQsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbH1zdGF0aWMgY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlcih0KXtjb25zdCBlPW5ldyB1cih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZX1zdGF0aWMgaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbigpe2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1szXTtyZXR1cm4oIWFyZ3VtZW50c1syXXx8IW4pJiYhIXQuZXF1YWxzMkQoZSl9aWYoOD09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdLG89YXJndW1lbnRzWzZdLGw9YXJndW1lbnRzWzddO3JldHVybiEhdXIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbih0LG4saSxvKXx8KCEhdXIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbih0LHMsaSxsKXx8KCEhdXIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbihlLG4scixvKXx8ISF1ci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKGUscyxyLGwpKSl9fXN0YXRpYyBjcmVhdGVJbnRlcmlvckludGVyc2VjdGlvbkNvdW50ZXIodCl7Y29uc3QgZT1uZXcgdXIodCk7cmV0dXJuIGUuc2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seSghMCksZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX1zdGF0aWMgY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlcih0KXtjb25zdCBlPW5ldyB1cih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX1zdGF0aWMgaXNFbmRTZWdtZW50KHQsZSl7cmV0dXJuIDA9PT1lfHxlPj10LnNpemUoKS0yfXN0YXRpYyBjcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIodCl7cmV0dXJuIG5ldyB1cih0KX1zdGF0aWMgY3JlYXRlSW50ZXJpb3JJbnRlcnNlY3Rpb25zRmluZGVyKHQpe2NvbnN0IGU9bmV3IHVyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEludGVyaW9ySW50ZXJzZWN0aW9uc09ubHkoITApLGV9c2V0Q2hlY2tFbmRTZWdtZW50c09ubHkodCl7dGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seT10fWdldEludGVyc2VjdGlvblNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX2ludFNlZ21lbnRzfWNvdW50KCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50fWdldEludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uc31zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz10fXNldEtlZXBJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2tlZXBJbnRlcnNlY3Rpb25zPXR9Z2V0SW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ufXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKCF0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyYmdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4gbnVsbDtjb25zdCBpPXQ9PT1uO2lmKGkmJmU9PT1zKXJldHVybiBudWxsO2lmKHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkpe2lmKCEodXIuaXNFbmRTZWdtZW50KHQsZSl8fHVyLmlzRW5kU2VnbWVudChuLHMpKSlyZXR1cm4gbnVsbH1jb25zdCByPXQuZ2V0Q29vcmRpbmF0ZShlKSxvPXQuZ2V0Q29vcmRpbmF0ZShlKzEpLGw9bi5nZXRDb29yZGluYXRlKHMpLGE9bi5nZXRDb29yZGluYXRlKHMrMSksYz0wPT09ZSxoPWUrMj09PXQuc2l6ZSgpLHU9MD09PXMsZz1zKzI9PT1uLnNpemUoKTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIsbyxsLGEpO2NvbnN0IGQ9dGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKTtsZXQgXz0hMTtpZighdGhpcy5faXNJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5KXtfPSEoaSYmTWF0aC5hYnMocy1lKTw9MSkmJnVyLmlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24ocixvLGwsYSxjLGgsdSxnKX0oZHx8XykmJih0aGlzLl9pbnRTZWdtZW50cz1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLl9pbnRTZWdtZW50c1swXT1yLHRoaXMuX2ludFNlZ21lbnRzWzFdPW8sdGhpcy5faW50U2VnbWVudHNbMl09bCx0aGlzLl9pbnRTZWdtZW50c1szXT1hLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPXRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKSx0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucyYmdGhpcy5faW50ZXJzZWN0aW9ucy5hZGQodGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24pLHRoaXMuX2ludGVyc2VjdGlvbkNvdW50KyspfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zJiZudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259c2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seSh0KXt0aGlzLl9pc0ludGVyaW9ySW50ZXJzZWN0aW9uc09ubHk9dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUmldfX1jbGFzcyBncntjb25zdHJ1Y3Rvcigpe2dyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9zZWdTdHJpbmdzPW51bGwsdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5fc2VnSW50PW51bGwsdGhpcy5faXNWYWxpZD0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWdTdHJpbmdzPXR9c3RhdGljIGNvbXB1dGVJbnRlcnNlY3Rpb25zKHQpe2NvbnN0IGU9bmV3IGdyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLmlzVmFsaWQoKSxlLmdldEludGVyc2VjdGlvbnMoKX1leGVjdXRlKCl7aWYobnVsbCE9PXRoaXMuX3NlZ0ludClyZXR1cm4gbnVsbDt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5leGVjdXRlKCksdGhpcy5faXNWYWxpZH1zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz10fWNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7dGhpcy5faXNWYWxpZD0hMCx0aGlzLl9zZWdJbnQ9bmV3IHVyKHRoaXMuX2xpKSx0aGlzLl9zZWdJbnQuc2V0RmluZEFsbEludGVyc2VjdGlvbnModGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMpO2NvbnN0IHQ9bmV3IHRpO2lmKHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuX3NlZ0ludCksdC5jb21wdXRlTm9kZXModGhpcy5fc2VnU3RyaW5ncyksdGhpcy5fc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpKXJldHVybiB0aGlzLl9pc1ZhbGlkPSExLG51bGx9Y2hlY2tWYWxpZCgpe2lmKHRoaXMuZXhlY3V0ZSgpLCF0aGlzLl9pc1ZhbGlkKXRocm93IG5ldyBpcyh0aGlzLmdldEVycm9yTWVzc2FnZSgpLHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb24oKSl9Z2V0RXJyb3JNZXNzYWdlKCl7aWYodGhpcy5faXNWYWxpZClyZXR1cm5cIm5vIGludGVyc2VjdGlvbnMgZm91bmRcIjtjb25zdCB0PXRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpO3JldHVyblwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBiZXR3ZWVuIFwiK1d0LnRvTGluZVN0cmluZyh0WzBdLHRbMV0pK1wiIGFuZCBcIitXdC50b0xpbmVTdHJpbmcodFsyXSx0WzNdKX19Y2xhc3MgZHJ7Y29uc3RydWN0b3IoKXtkci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9udj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX252PW5ldyBncihkci50b1NlZ21lbnRTdHJpbmdzKHQpKX1zdGF0aWMgdG9TZWdtZW50U3RyaW5ncyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBocih0LmdldENvb3JkaW5hdGVzKCksdCkpfXJldHVybiBlfXN0YXRpYyBjaGVja1ZhbGlkKHQpe25ldyBkcih0KS5jaGVja1ZhbGlkKCl9Y2hlY2tWYWxpZCgpe3RoaXMuX252LmNoZWNrVmFsaWQoKX19Y2xhc3MgX3J7Y29uc3RydWN0b3IoKXtfci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vcD1udWxsLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3B0TG9jYXRvcj1udWxsLHRoaXMuX2xpbmVFZGdlc0xpc3Q9bmV3IEwsdGhpcy5fcmVzdWx0TGluZUxpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLl9wdExvY2F0b3I9bn1jb2xsZWN0TGluZXModCl7Zm9yKGxldCBlPXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmNvbGxlY3RMaW5lRWRnZShuLHQsdGhpcy5fbGluZUVkZ2VzTGlzdCksdGhpcy5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2Uobix0LHRoaXMuX2xpbmVFZGdlc0xpc3QpfX1sYWJlbElzb2xhdGVkTGluZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9vcC5nZXRBcmdHZW9tZXRyeShlKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9YnVpbGQodCl7cmV0dXJuIHRoaXMuZmluZENvdmVyZWRMaW5lRWRnZXMoKSx0aGlzLmNvbGxlY3RMaW5lcyh0KSx0aGlzLmJ1aWxkTGluZXModCksdGhpcy5fcmVzdWx0TGluZUxpc3R9Y29sbGVjdExpbmVFZGdlKHQsZSxuKXtjb25zdCBzPXQuZ2V0TGFiZWwoKSxpPXQuZ2V0RWRnZSgpO3QuaXNMaW5lRWRnZSgpJiYodC5pc1Zpc2l0ZWQoKXx8IXdyLmlzUmVzdWx0T2ZPcChzLGUpfHxpLmlzQ292ZXJlZCgpfHwobi5hZGQoaSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKX1maW5kQ292ZXJlZExpbmVFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuZmluZENvdmVyZWRMaW5lRWRnZXMoKX1mb3IobGV0IHQ9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRFZGdlKCk7aWYoZS5pc0xpbmVFZGdlKCkmJiFuLmlzQ292ZXJlZFNldCgpKXtjb25zdCB0PXRoaXMuX29wLmlzQ292ZXJlZEJ5QShlLmdldENvb3JkaW5hdGUoKSk7bi5zZXRDb3ZlcmVkKHQpfX19bGFiZWxJc29sYXRlZExpbmVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRMYWJlbCgpO3QuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTGluZSh0LDApOnRoaXMubGFiZWxJc29sYXRlZExpbmUodCwxKSl9fWJ1aWxkTGluZXModCl7Zm9yKGxldCB0PXRoaXMuX2xpbmVFZGdlc0xpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlLmdldENvb3JkaW5hdGVzKCkpO3RoaXMuX3Jlc3VsdExpbmVMaXN0LmFkZChuKSxlLnNldEluUmVzdWx0KCEwKX19Y29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKHQsZSxuKXtjb25zdCBzPXQuZ2V0TGFiZWwoKTtyZXR1cm4gdC5pc0xpbmVFZGdlKCl8fHQuaXNWaXNpdGVkKCl8fHQuaXNJbnRlcmlvckFyZWFFZGdlKCl8fHQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKT9udWxsOihnLmlzVHJ1ZSghKHQuaXNJblJlc3VsdCgpfHx0LmdldFN5bSgpLmlzSW5SZXN1bHQoKSl8fCF0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpLHZvaWQod3IuaXNSZXN1bHRPZk9wKHMsZSkmJmU9PT13ci5JTlRFUlNFQ1RJT04mJihuLmFkZCh0LmdldEVkZ2UoKSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKSl9fWNsYXNzIHBye2NvbnN0cnVjdG9yKCl7cHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3A9bnVsbCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9yZXN1bHRQb2ludExpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZX1maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoKTtpZighdGhpcy5fb3AuaXNDb3ZlcmVkQnlMQShlKSl7Y29uc3QgdD10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSk7dGhpcy5fcmVzdWx0UG9pbnRMaXN0LmFkZCh0KX19ZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKCFuLmlzSW5SZXN1bHQoKSYmKCFuLmlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKSYmKDA9PT1uLmdldEVkZ2VzKCkuZ2V0RGVncmVlKCl8fHQ9PT13ci5JTlRFUlNFQ1RJT04pKSl7Y29uc3QgZT1uLmdldExhYmVsKCk7d3IuaXNSZXN1bHRPZk9wKGUsdCkmJnRoaXMuZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50KG4pfX19YnVpbGQodCl7cmV0dXJuIHRoaXMuZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KSx0aGlzLl9yZXN1bHRQb2ludExpc3R9fWNsYXNzIG1ye2NvbnN0cnVjdG9yKCl7dGhpcy5faXNGaXJzdD0hMCx0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudD01Myx0aGlzLl9jb21tb25CaXRzPW5ldyBpLHRoaXMuX2NvbW1vblNpZ25FeHA9bnVsbH1nZXRDb21tb24oKXtyZXR1cm4gci5sb25nQml0c1RvRG91YmxlKHRoaXMuX2NvbW1vbkJpdHMpfWFkZCh0KXtjb25zdCBlPXIuZG91YmxlVG9Mb25nQml0cyh0KTtpZih0aGlzLl9pc0ZpcnN0KXJldHVybiB0aGlzLl9jb21tb25CaXRzPWUsdGhpcy5fY29tbW9uU2lnbkV4cD1tci5zaWduRXhwQml0cyh0aGlzLl9jb21tb25CaXRzKSx0aGlzLl9pc0ZpcnN0PSExLG51bGw7aWYobXIuc2lnbkV4cEJpdHMoZSkhPT10aGlzLl9jb21tb25TaWduRXhwKXJldHVybiB0aGlzLl9jb21tb25CaXRzLmhpZ2g9MCx0aGlzLl9jb21tb25CaXRzLmxvdz0wLG51bGw7dGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9bXIubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0aGlzLl9jb21tb25CaXRzLGUpLHRoaXMuX2NvbW1vbkJpdHM9bXIuemVyb0xvd2VyQml0cyh0aGlzLl9jb21tb25CaXRzLDY0LSgxMit0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudCkpfXRvU3RyaW5nKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9ci5sb25nQml0c1RvRG91YmxlKHQpLG49XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIraS50b0JpbmFyeVN0cmluZyh0KSxzPW4uc3Vic3RyaW5nKG4ubGVuZ3RoLTY0KTtyZXR1cm4gcy5zdWJzdHJpbmcoMCwxKStcIiAgXCIrcy5zdWJzdHJpbmcoMSwxMikrXCIoZXhwKSBcIitzLnN1YnN0cmluZygxMikrXCIgWyBcIitlK1wiIF1cIn19Z2V0Q2xhc3MoKXtyZXR1cm4gbXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119c3RhdGljIGdldEJpdCh0LGUpe2NvbnN0IG49MTw8ZSUzMjtyZXR1cm4gZTwzMj8wIT0odC5sb3cmbik/MTowOjAhPSh0LmhpZ2gmbik/MTowfXN0YXRpYyBzaWduRXhwQml0cyh0KXtyZXR1cm4gdC5oaWdoPj4+MjB9c3RhdGljIHplcm9Mb3dlckJpdHModCxlKXtsZXQgbj1cImxvd1wiO2lmKGU+MzImJih0Lmxvdz0wLGUlPTMyLG49XCJoaWdoXCIpLGU+MCl7Y29uc3Qgcz1lPDMyP34oKDE8PGUpLTEpOjA7dFtuXSY9c31yZXR1cm4gdH1zdGF0aWMgbnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0LGUpe2xldCBuPTA7Zm9yKGxldCBzPTUyO3M+PTA7cy0tKXtpZihtci5nZXRCaXQodCxzKSE9PW1yLmdldEJpdChlLHMpKXJldHVybiBuO24rK31yZXR1cm4gNTJ9fWNsYXNzIGZye2NvbnN0cnVjdG9yKCl7ZnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29tbW9uQ29vcmQ9bnVsbCx0aGlzLl9jY0ZpbHRlcj1uZXcgeXJ9YWRkQ29tbW9uQml0cyh0KXtjb25zdCBlPW5ldyB4cih0aGlzLl9jb21tb25Db29yZCk7dC5hcHBseShlKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpfXJlbW92ZUNvbW1vbkJpdHModCl7aWYoMD09PXRoaXMuX2NvbW1vbkNvb3JkLngmJjA9PT10aGlzLl9jb21tb25Db29yZC55KXJldHVybiB0O2NvbnN0IGU9bmV3IG0odGhpcy5fY29tbW9uQ29vcmQpO2UueD0tZS54LGUueT0tZS55O2NvbnN0IG49bmV3IHhyKGUpO3JldHVybiB0LmFwcGx5KG4pLHQuZ2VvbWV0cnlDaGFuZ2VkKCksdH1nZXRDb21tb25Db29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2NvbW1vbkNvb3JkfWFkZCh0KXt0LmFwcGx5KHRoaXMuX2NjRmlsdGVyKSx0aGlzLl9jb21tb25Db29yZD10aGlzLl9jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCl9fWNsYXNzIHlye2NvbnN0cnVjdG9yKCl7eXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29tbW9uQml0c1g9bmV3IG1yLHRoaXMuX2NvbW1vbkJpdHNZPW5ldyBtcn1maWx0ZXIodCl7dGhpcy5fY29tbW9uQml0c1guYWRkKHQueCksdGhpcy5fY29tbW9uQml0c1kuYWRkKHQueSl9Z2V0Q29tbW9uQ29vcmRpbmF0ZSgpe3JldHVybiBuZXcgbSh0aGlzLl9jb21tb25CaXRzWC5nZXRDb21tb24oKSx0aGlzLl9jb21tb25CaXRzWS5nZXRDb21tb24oKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hdfX1jbGFzcyB4cntjb25zdHJ1Y3Rvcigpe3hyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMudHJhbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRyYW5zPXR9ZmlsdGVyKHQsZSl7Y29uc3Qgbj10LmdldE9yZGluYXRlKGUsMCkrdGhpcy50cmFucy54LHM9dC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMudHJhbnMueTt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX1pc0RvbmUoKXtyZXR1cm4hMX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiEwfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltQXX19ZnIuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlcj15cixmci5UcmFuc2xhdGVyPXhyO2NsYXNzIEVye2NvbnN0cnVjdG9yKCl7RXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5fY2JyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZSx0aGlzLmNvbXB1dGVTbmFwVG9sZXJhbmNlKCl9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyBFcih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBFci5vdmVybGF5T3AodCxlLHdyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsd3IuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe3JldHVybiBFci5vdmVybGF5T3AodCxlLHdyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsd3IuRElGRkVSRU5DRSl9c2VsZlNuYXAodCl7cmV0dXJuIG5ldyBscih0KS5zbmFwVG8odCx0aGlzLl9zbmFwVG9sZXJhbmNlKX1yZW1vdmVDb21tb25CaXRzKHQpe3RoaXMuX2Nicj1uZXcgZnIsdGhpcy5fY2JyLmFkZCh0WzBdKSx0aGlzLl9jYnIuYWRkKHRbMV0pO2NvbnN0IGU9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIGVbMF09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModFswXS5jb3B5KCkpLGVbMV09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModFsxXS5jb3B5KCkpLGV9cHJlcGFyZVJlc3VsdCh0KXtyZXR1cm4gdGhpcy5fY2JyLmFkZENvbW1vbkJpdHModCksdH1nZXRSZXN1bHRHZW9tZXRyeSh0KXtjb25zdCBlPXRoaXMuc25hcCh0aGlzLl9nZW9tKSxuPXdyLm92ZXJsYXlPcChlWzBdLGVbMV0sdCk7cmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChuKX1jaGVja1ZhbGlkKHQpe3QuaXNWYWxpZCgpfHxZLm91dC5wcmludGxuKFwiU25hcHBlZCBnZW9tZXRyeSBpcyBpbnZhbGlkXCIpfWNvbXB1dGVTbmFwVG9sZXJhbmNlKCl7dGhpcy5fc25hcFRvbGVyYW5jZT1sci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdKX1zbmFwKHQpe2NvbnN0IGU9dGhpcy5yZW1vdmVDb21tb25CaXRzKHQpO3JldHVybiBsci5zbmFwKGVbMF0sZVsxXSx0aGlzLl9zbmFwVG9sZXJhbmNlKX19Y2xhc3MgSXJ7Y29uc3RydWN0b3IoKXtJci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWV9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyBJcih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe3JldHVybiBJci5vdmVybGF5T3AodCxlLHdyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuRElGRkVSRU5DRSl9Z2V0UmVzdWx0R2VvbWV0cnkodCl7bGV0IGU9bnVsbCxuPSExLHM9bnVsbDt0cnl7ZT13ci5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdLHQpOyEwJiYobj0hMCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDtzPXR9aWYoIW4pdHJ5e2U9RXIub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSx0KX1jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgaD9zOnR9cmV0dXJuIGV9fWNsYXNzIE5ye2NvbnN0cnVjdG9yKCl7TnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGk9bmV3IGp0LHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYXJnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBhcygwLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO05yLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLGduLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dC5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhlLmdldFByZWNpc2lvbk1vZGVsKCkpPj0wP3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKTp0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fYXJnPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2FyZ1swXT1uZXcgYXMoMCx0LG4pLHRoaXMuX2FyZ1sxXT1uZXcgYXMoMSxlLG4pfX1nZXRBcmdHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5fYXJnW3RdLmdldEdlb21ldHJ5KCl9c2V0Q29tcHV0YXRpb25QcmVjaXNpb24odCl7dGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9saS5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbCl9fWNsYXNzIHdyIGV4dGVuZHMgTnJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLHdyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0TG9jYXRvcj1uZXcgZm4sdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9yZXN1bHRHZW9tPW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9lZGdlTGlzdD1uZXcgVGksdGhpcy5fcmVzdWx0UG9seUxpc3Q9bmV3IEwsdGhpcy5fcmVzdWx0TGluZUxpc3Q9bmV3IEwsdGhpcy5fcmVzdWx0UG9pbnRMaXN0PW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO05yLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9ncmFwaD1uZXcgbHMobmV3IFNpKSx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IHdyKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIHdyLmNyZWF0ZUVtcHR5UmVzdWx0KHdyLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1pZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSlyZXR1cm4gd3IuY3JlYXRlRW1wdHlSZXN1bHQod3IuSU5URVJTRUNUSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXtjb25zdCBuPWU7cmV0dXJuIGNlLm1hcCh0LG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bTWFwT3BdfW1hcCh0KXtyZXR1cm4gd3IuaW50ZXJzZWN0aW9uKHQsbil9fSl9cmV0dXJuIElyLm92ZXJsYXlPcCh0LGUsd3IuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiB3ci5jcmVhdGVFbXB0eVJlc3VsdCh3ci5TWU1ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1pZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgcmVzdWx0RGltZW5zaW9uKHQsZSxuKXtjb25zdCBzPWUuZ2V0RGltZW5zaW9uKCksaT1uLmdldERpbWVuc2lvbigpO2xldCByPS0xO3N3aXRjaCh0KXtjYXNlIHdyLklOVEVSU0VDVElPTjpyPU1hdGgubWluKHMsaSk7YnJlYWs7Y2FzZSB3ci5VTklPTjpyPU1hdGgubWF4KHMsaSk7YnJlYWs7Y2FzZSB3ci5ESUZGRVJFTkNFOnI9czticmVhaztjYXNlIHdyLlNZTURJRkZFUkVOQ0U6cj1NYXRoLm1heChzLGkpfXJldHVybiByfXN0YXRpYyBjcmVhdGVFbXB0eVJlc3VsdCh0LGUsbixzKXtjb25zdCBpPXdyLnJlc3VsdERpbWVuc2lvbih0LGUsbik7cmV0dXJuIHMuY3JlYXRlRW1wdHkoaSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gd3IuY3JlYXRlRW1wdHlSZXN1bHQod3IuRElGRkVSRU5DRSx0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5ESUZGRVJFTkNFKX1zdGF0aWMgaXNSZXN1bHRPZk9wKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRMb2NhdGlvbigwKSxzPXQuZ2V0TG9jYXRpb24oMSk7cmV0dXJuIHdyLmlzUmVzdWx0T2ZPcChuLHMsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtzd2l0Y2godD09PVF0LkJPVU5EQVJZJiYodD1RdC5JTlRFUklPUiksZT09PVF0LkJPVU5EQVJZJiYoZT1RdC5JTlRFUklPUiksbil7Y2FzZSB3ci5JTlRFUlNFQ1RJT046cmV0dXJuIHQ9PT1RdC5JTlRFUklPUiYmZT09PVF0LklOVEVSSU9SO2Nhc2Ugd3IuVU5JT046cmV0dXJuIHQ9PT1RdC5JTlRFUklPUnx8ZT09PVF0LklOVEVSSU9SO2Nhc2Ugd3IuRElGRkVSRU5DRTpyZXR1cm4gdD09PVF0LklOVEVSSU9SJiZlIT09UXQuSU5URVJJT1I7Y2FzZSB3ci5TWU1ESUZGRVJFTkNFOnJldHVybiB0PT09UXQuSU5URVJJT1ImJmUhPT1RdC5JTlRFUklPUnx8dCE9PVF0LklOVEVSSU9SJiZlPT09UXQuSU5URVJJT1J9cmV0dXJuITF9fWluc2VydFVuaXF1ZUVkZ2UodCl7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXtjb25zdCBuPWUuZ2V0TGFiZWwoKTtsZXQgcz10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwocz1uZXcgQm4odC5nZXRMYWJlbCgpKSxzLmZsaXAoKSk7Y29uc3QgaT1lLmdldERlcHRoKCk7aS5pc051bGwoKSYmaS5hZGQobiksaS5hZGQocyksbi5tZXJnZShzKX1lbHNlIHRoaXMuX2VkZ2VMaXN0LmFkZCh0KX1nZXRHcmFwaCgpe3JldHVybiB0aGlzLl9ncmFwaH1jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRTeW0oKTtlLmlzSW5SZXN1bHQoKSYmbi5pc0luUmVzdWx0KCkmJihlLnNldEluUmVzdWx0KCExKSxuLnNldEluUmVzdWx0KCExKSl9fWlzQ292ZXJlZEJ5TEEodCl7cmV0dXJuISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdExpbmVMaXN0KXx8ISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0KX1jb21wdXRlR2VvbWV0cnkodCxlLG4scyl7Y29uc3QgaT1uZXcgTDtyZXR1cm4gaS5hZGRBbGwodCksaS5hZGRBbGwoZSksaS5hZGRBbGwobiksaS5pc0VtcHR5KCk/d3IuY3JlYXRlRW1wdHlSZXN1bHQocyx0aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKSx0aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKSx0aGlzLl9nZW9tRmFjdCk6dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShpKX1tZXJnZVN5bUxhYmVscygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLm1lcmdlU3ltTGFiZWxzKCl9fWlzQ292ZXJlZCh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2lmKHRoaXMuX3B0TG9jYXRvci5sb2NhdGUodCxlKSE9PVF0LkVYVEVSSU9SKXJldHVybiEwfXJldHVybiExfXJlcGxhY2VDb2xsYXBzZWRFZGdlcygpe2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPXRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24uaXNDb2xsYXBzZWQoKSYmKGUucmVtb3ZlKCksdC5hZGQobi5nZXRDb2xsYXBzZWRFZGdlKCkpKX10aGlzLl9lZGdlTGlzdC5hZGRBbGwodCl9dXBkYXRlTm9kZUxhYmVsbGluZygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRFZGdlcygpLmdldExhYmVsKCk7ZS5nZXRMYWJlbCgpLm1lcmdlKG4pfX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5jb21wdXRlT3ZlcmxheSh0KSx0aGlzLl9yZXN1bHRHZW9tfWluc2VydFVuaXF1ZUVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZSh0KX19Y29tcHV0ZU92ZXJsYXkodCl7dGhpcy5jb3B5UG9pbnRzKDApLHRoaXMuY29weVBvaW50cygxKSx0aGlzLl9hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5fYXJnWzFdLHRoaXMuX2xpLCEwKTtjb25zdCBlPW5ldyBMO3RoaXMuX2FyZ1swXS5jb21wdXRlU3BsaXRFZGdlcyhlKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5pbnNlcnRVbmlxdWVFZGdlcyhlKSx0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCksdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKSxkci5jaGVja1ZhbGlkKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuY29tcHV0ZUxhYmVsbGluZygpLHRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZXMoKSx0aGlzLmZpbmRSZXN1bHRBcmVhRWRnZXModCksdGhpcy5jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpO2NvbnN0IG49bmV3IHBpKHRoaXMuX2dlb21GYWN0KTtuLmFkZCh0aGlzLl9ncmFwaCksdGhpcy5fcmVzdWx0UG9seUxpc3Q9bi5nZXRQb2x5Z29ucygpO2NvbnN0IHM9bmV3IF9yKHRoaXMsdGhpcy5fZ2VvbUZhY3QsdGhpcy5fcHRMb2NhdG9yKTt0aGlzLl9yZXN1bHRMaW5lTGlzdD1zLmJ1aWxkKHQpO2NvbnN0IGk9bmV3IHByKHRoaXMsdGhpcy5fZ2VvbUZhY3QsdGhpcy5fcHRMb2NhdG9yKTt0aGlzLl9yZXN1bHRQb2ludExpc3Q9aS5idWlsZCh0KSx0aGlzLl9yZXN1bHRHZW9tPXRoaXMuY29tcHV0ZUdlb21ldHJ5KHRoaXMuX3Jlc3VsdFBvaW50TGlzdCx0aGlzLl9yZXN1bHRMaW5lTGlzdCx0aGlzLl9yZXN1bHRQb2x5TGlzdCx0KX1sYWJlbEluY29tcGxldGVOb2RlKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2FyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX1jb3B5UG9pbnRzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuX2dyYXBoLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19ZmluZFJlc3VsdEFyZWFFZGdlcyh0KXtmb3IobGV0IGU9dGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKTtzLmlzQXJlYSgpJiYhbi5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmd3IuaXNSZXN1bHRPZk9wKHMuZ2V0TG9jYXRpb24oMCxibi5SSUdIVCkscy5nZXRMb2NhdGlvbigxLGJuLlJJR0hUKSx0KSYmbi5zZXRJblJlc3VsdCghMCl9fWNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCl7Zm9yKGxldCB0PXRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpLHM9ZS5nZXREZXB0aCgpO2lmKCFzLmlzTnVsbCgpKXtzLm5vcm1hbGl6ZSgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspbi5pc051bGwodCl8fCFuLmlzQXJlYSgpfHxzLmlzTnVsbCh0KXx8KDA9PT1zLmdldERlbHRhKHQpP24udG9MaW5lKHQpOihnLmlzVHJ1ZSghcy5pc051bGwodCxibi5MRUZUKSxcImRlcHRoIG9mIExFRlQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbih0LGJuLkxFRlQscy5nZXRMb2NhdGlvbih0LGJuLkxFRlQpKSxnLmlzVHJ1ZSghcy5pc051bGwodCxibi5SSUdIVCksXCJkZXB0aCBvZiBSSUdIVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHQsYm4uUklHSFQscy5nZXRMb2NhdGlvbih0LGJuLlJJR0hUKSkpKX19fWNvbXB1dGVMYWJlbGxpbmcoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuX2FyZyl9dGhpcy5tZXJnZVN5bUxhYmVscygpLHRoaXMudXBkYXRlTm9kZUxhYmVsbGluZygpfWxhYmVsSW5jb21wbGV0ZU5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7ZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUoZSwwKTp0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUoZSwxKSksZS5nZXRFZGdlcygpLnVwZGF0ZUxhYmVsbGluZyhuKX19aXNDb3ZlcmVkQnlBKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRQb2x5TGlzdCl9fXdyLklOVEVSU0VDVElPTj0xLHdyLlVOSU9OPTIsd3IuRElGRkVSRU5DRT0zLHdyLlNZTURJRkZFUkVOQ0U9NDt2YXIgQ3I9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsc25hcDpjcixPdmVybGF5T3A6d3J9KTtjbGFzcyBTciBleHRlbmRzIEhpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxTci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lZGdlUmluZz1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9sYWJlbD0tMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtIaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLHMpfWdldE5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1pc0luUmluZygpe3JldHVybiBudWxsIT09dGhpcy5fZWRnZVJpbmd9c2V0UmluZyh0KXt0aGlzLl9lZGdlUmluZz10fXNldExhYmVsKHQpe3RoaXMuX2xhYmVsPXR9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9Z2V0UmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ319Y2xhc3MgTHIgZXh0ZW5kcyBaaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2xpbmV9fWNsYXNzIFRye2NvbnN0cnVjdG9yKCl7VHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW5ldyBMdCx0aGlzLl9nZW9tR3JhcGg9bnVsbCx0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tR3JhcGg9dH1zdGF0aWMgZmluZERpZmZlcmVudFBvaW50KHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGUpKXJldHVybiB0W25dO3JldHVybiBudWxsfXZpc2l0SW50ZXJpb3JSaW5nKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCkscz1uWzBdLGk9VHIuZmluZERpZmZlcmVudFBvaW50KG4scykscj1lLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHMsaSksbz1lLmZpbmRFZGdlRW5kKHIpO2xldCBsPW51bGw7by5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsYm4uUklHSFQpPT09UXQuSU5URVJJT1I/bD1vOm8uZ2V0U3ltKCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGJuLlJJR0hUKT09PVF0LklOVEVSSU9SJiYobD1vLmdldFN5bSgpKSxnLmlzVHJ1ZShudWxsIT09bCxcInVuYWJsZSB0byBmaW5kIGRpckVkZ2Ugd2l0aCBJbnRlcmlvciBvbiBSSFNcIiksdGhpcy52aXNpdExpbmtlZERpcmVjdGVkRWRnZXMobCl9dmlzaXRTaGVsbEludGVyaW9ycyh0LGUpe2lmKHQgaW5zdGFuY2VvZiBydCl7Y29uc3Qgbj10O3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX1pZih0IGluc3RhbmNlb2YgeXQpe2NvbnN0IG49dDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5Tih0KTt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKHMuZ2V0RXh0ZXJpb3JSaW5nKCksZSl9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZH1zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQodCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxibi5SSUdIVCk9PT1RdC5JTlRFUklPUiYmdC5zZXRJblJlc3VsdCghMCl9fXZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyh0KXtjb25zdCBlPXQ7bGV0IG49dDtkb3tnLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgRGlyZWN0ZWQgRWRnZVwiKSxuLnNldFZpc2l0ZWQoITApLG49bi5nZXROZXh0KCl9d2hpbGUobiE9PWUpfWJ1aWxkRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc0luUmVzdWx0KCkmJm51bGw9PT10LmdldEVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IF9pKHQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtuLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9bi5idWlsZE1pbmltYWxSaW5ncygpO2UuYWRkQWxsKHMpfX1yZXR1cm4gZX1oYXNVbnZpc2l0ZWRTaGVsbEVkZ2UodCl7Zm9yKGxldCBlPTA7ZTx0LnNpemUoKTtlKyspe2NvbnN0IG49dC5nZXQoZSk7aWYobi5pc0hvbGUoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0RWRnZXMoKTtsZXQgaT1zLmdldCgwKTtpZihpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxibi5SSUdIVCk9PT1RdC5JTlRFUklPUilmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKylpZihpPXMuZ2V0KHQpLCFpLmlzVmlzaXRlZCgpKXJldHVybiB0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmQ9aS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9aXNJbnRlcmlvcnNDb25uZWN0ZWQoKXtjb25zdCB0PW5ldyBMO3RoaXMuX2dlb21HcmFwaC5jb21wdXRlU3BsaXRFZGdlcyh0KTtjb25zdCBlPW5ldyBscyhuZXcgU2kpO2UuYWRkRWRnZXModCksdGhpcy5zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQoZSksZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpO2NvbnN0IG49dGhpcy5idWlsZEVkZ2VSaW5ncyhlLmdldEVkZ2VFbmRzKCkpO3JldHVybiB0aGlzLnZpc2l0U2hlbGxJbnRlcmlvcnModGhpcy5fZ2VvbUdyYXBoLmdldEdlb21ldHJ5KCksZSksIXRoaXMuaGFzVW52aXNpdGVkU2hlbGxFZGdlKG4pfX1jbGFzcyBScntjcmVhdGVFZGdlRW5kRm9yTmV4dCh0LGUsbixzKXtjb25zdCBpPW4uc2VnbWVudEluZGV4KzE7aWYoaT49dC5nZXROdW1Qb2ludHMoKSYmbnVsbD09PXMpcmV0dXJuIG51bGw7bGV0IHI9dC5nZXRDb29yZGluYXRlKGkpO251bGwhPT1zJiZzLnNlZ21lbnRJbmRleD09PW4uc2VnbWVudEluZGV4JiYocj1zLmNvb3JkKTtjb25zdCBvPW5ldyBzcyh0LG4uY29vcmQscixuZXcgQm4odC5nZXRMYWJlbCgpKSk7ZS5hZGQobyl9Y3JlYXRlRWRnZUVuZEZvclByZXYodCxlLG4scyl7bGV0IGk9bi5zZWdtZW50SW5kZXg7aWYoMD09PW4uZGlzdCl7aWYoMD09PWkpcmV0dXJuIG51bGw7aS0tfWxldCByPXQuZ2V0Q29vcmRpbmF0ZShpKTtudWxsIT09cyYmcy5zZWdtZW50SW5kZXg+PWkmJihyPXMuY29vcmQpO2NvbnN0IG89bmV3IEJuKHQuZ2V0TGFiZWwoKSk7by5mbGlwKCk7Y29uc3QgbD1uZXcgc3ModCxuLmNvb3JkLHIsbyk7ZS5hZGQobCl9Y29tcHV0ZUVkZ2VFbmRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7Zm9yKGxldCBuPXQ7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuY29tcHV0ZUVkZ2VFbmRzKHQsZSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpO24uYWRkRW5kcG9pbnRzKCk7Y29uc3Qgcz1uLml0ZXJhdG9yKCk7bGV0IGk9bnVsbCxyPW51bGw7aWYoIXMuaGFzTmV4dCgpKXJldHVybiBudWxsO2xldCBvPXMubmV4dCgpO2Rve2k9cixyPW8sbz1udWxsLHMuaGFzTmV4dCgpJiYobz1zLm5leHQoKSksbnVsbCE9PXImJih0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JQcmV2KHQsZSxyLGkpLHRoaXMuY3JlYXRlRWRnZUVuZEZvck5leHQodCxlLHIsbykpfXdoaWxlKG51bGwhPT1yKX19fWNsYXNzIFByIGV4dGVuZHMgc3N7Y29uc3RydWN0b3IoKXtzdXBlcigpLFByLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2VkZ2VFbmRzPW5ldyBMLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtQci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG51bGwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07c3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldEVkZ2UoKSx0LmdldENvb3JkaW5hdGUoKSx0LmdldERpcmVjdGVkQ29vcmRpbmF0ZSgpLG5ldyBCbih0LmdldExhYmVsKCkpKSx0aGlzLmluc2VydCh0KX19aW5zZXJ0KHQpe3RoaXMuX2VkZ2VFbmRzLmFkZCh0KX1wcmludCh0KXt0LnByaW50bG4oXCJFZGdlRW5kQnVuZGxlLS1cXHgzZSBMYWJlbDogXCIrdGhpcy5fbGFiZWwpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KSx0LnByaW50bG4oKX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZHMuaXRlcmF0b3IoKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kc31jb21wdXRlTGFiZWxPbih0LGUpe2xldCBuPTAscz0hMTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgaT1lLm5leHQoKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2k9PT1RdC5CT1VOREFSWSYmbisrLGk9PT1RdC5JTlRFUklPUiYmKHM9ITApfWxldCBpPVF0Lk5PTkU7cyYmKGk9UXQuSU5URVJJT1IpLG4+MCYmKGk9YXMuZGV0ZXJtaW5lQm91bmRhcnkoZSxuKSksdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxpKX1jb21wdXRlTGFiZWxTaWRlKHQsZSl7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocy5nZXRMYWJlbCgpLmlzQXJlYSgpKXtjb25zdCBuPXMuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGUpO2lmKG49PT1RdC5JTlRFUklPUilyZXR1cm4gdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLFF0LklOVEVSSU9SKSxudWxsO249PT1RdC5FWFRFUklPUiYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLFF0LkVYVEVSSU9SKX19fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbFNpZGVzKHQpe3RoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LGJuLkxFRlQpLHRoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LGJuLlJJR0hUKX11cGRhdGVJTSh0KXt0cy51cGRhdGVJTSh0aGlzLl9sYWJlbCx0KX1jb21wdXRlTGFiZWwodCl7bGV0IGU9ITE7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldExhYmVsKCkuaXNBcmVhKCkmJihlPSEwKX10aGlzLl9sYWJlbD1lP25ldyBCbihRdC5OT05FLFF0Lk5PTkUsUXQuTk9ORSk6bmV3IEJuKFF0Lk5PTkUpO2ZvcihsZXQgbj0wO248MjtuKyspdGhpcy5jb21wdXRlTGFiZWxPbihuLHQpLGUmJnRoaXMuY29tcHV0ZUxhYmVsU2lkZXMobil9fWNsYXNzIE9yIGV4dGVuZHMgd2l7Y29uc3RydWN0b3IoKXtzdXBlcigpfXVwZGF0ZUlNKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS51cGRhdGVJTSh0KX19aW5zZXJ0KHQpe2xldCBlPXRoaXMuX2VkZ2VNYXAuZ2V0KHQpO251bGw9PT1lPyhlPW5ldyBQcih0KSx0aGlzLmluc2VydEVkZ2VFbmQodCxlKSk6ZS5pbnNlcnQodCl9fWNsYXNzIHZyIGV4dGVuZHMgZXN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2VzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX11cGRhdGVJTUZyb21FZGdlcyh0KXt0aGlzLl9lZGdlcy51cGRhdGVJTSh0KX1jb21wdXRlSU0odCl7dC5zZXRBdExlYXN0SWZWYWxpZCh0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbigwKSx0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbigxKSwwKX19Y2xhc3MgYnIgZXh0ZW5kcyBvc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IHZyKHQsbmV3IE9yKX19Y2xhc3MgTXJ7Y29uc3RydWN0b3IoKXtNci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2Rlcz1uZXcgbnMobmV3IGJyKX1pbnNlcnRFZGdlRW5kcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGQodCl9fWdldE5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpfWNvcHlOb2Rlc0FuZExhYmVscyh0LGUpe2ZvcihsZXQgbj10LmdldE5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGROb2RlKHQuZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbChlLHQuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSl9fWJ1aWxkKHQpe3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQsMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHModCwwKTtjb25zdCBlPShuZXcgUnIpLmNvbXB1dGVFZGdlRW5kcyh0LmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKGUpfWNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LGUpe2ZvcihsZXQgbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxzPXQuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKTtmb3IobGV0IG49dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLGk9dGhpcy5fbm9kZXMuYWRkTm9kZSh0LmNvb3JkKTtzPT09UXQuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KGUpOmkuZ2V0TGFiZWwoKS5pc051bGwoZSkmJmkuc2V0TGFiZWwoZSxRdC5JTlRFUklPUil9fX19Y2xhc3MgRHJ7Y29uc3RydWN0b3IoKXtEci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fZ2VvbUdyYXBoPW51bGwsdGhpcy5fbm9kZUdyYXBoPW5ldyBNcix0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tR3JhcGg9dH1pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtpZighZS5nZXRFZGdlcygpLmlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodGhpcy5fZ2VvbUdyYXBoKSlyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50PWUuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKSwhMX1yZXR1cm4hMH1nZXRJbnZhbGlkUG9pbnQoKXtyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50fWhhc0R1cGxpY2F0ZVJpbmdzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2ZvcihsZXQgZT10Lm5leHQoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHQuZ2V0RWRnZUVuZHMoKS5zaXplKCk+MSlyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50PXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGUoMCksITB9fXJldHVybiExfWlzTm9kZUNvbnNpc3RlbnRBcmVhKCl7Y29uc3QgdD10aGlzLl9nZW9tR3JhcGguY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMCwhMCk7cmV0dXJuIHQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuX2ludmFsaWRQb2ludD10LmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOih0aGlzLl9ub2RlR3JhcGguYnVpbGQodGhpcy5fZ2VvbUdyYXBoKSx0aGlzLmlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpKX19Y2xhc3MgQXJ7Y29uc3RydWN0b3IoKXtBci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1udWxsLHRoaXMuX3JpbmdzPW5ldyBMLHRoaXMuX3RvdGFsRW52PW5ldyBPLHRoaXMuX2luZGV4PW51bGwsdGhpcy5fbmVzdGVkUHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ncmFwaD10fWJ1aWxkSW5kZXgoKXt0aGlzLl9pbmRleD1uZXcgYnM7Zm9yKGxldCB0PTA7dDx0aGlzLl9yaW5ncy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX3JpbmdzLmdldCh0KSxuPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3RoaXMuX2luZGV4Lmluc2VydChuLGUpfX1nZXROZXN0ZWRQb2ludCgpe3JldHVybiB0aGlzLl9uZXN0ZWRQdH1pc05vbk5lc3RlZCgpe3RoaXMuYnVpbGRJbmRleCgpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcmluZ3Muc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9yaW5ncy5nZXQodCksbj1lLmdldENvb3JkaW5hdGVzKCkscz10aGlzLl9pbmRleC5xdWVyeShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7Zm9yKGxldCB0PTA7dDxzLnNpemUoKTt0Kyspe2NvbnN0IGk9cy5nZXQodCkscj1pLmdldENvb3JkaW5hdGVzKCk7aWYoZT09PWkpY29udGludWU7aWYoIWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoaS5nZXRFbnZlbG9wZUludGVybmFsKCkpKWNvbnRpbnVlO2NvbnN0IG89R3IuZmluZFB0Tm90Tm9kZShuLGksdGhpcy5fZ3JhcGgpO2lmKG51bGw9PT1vKWNvbnRpbnVlO2lmKFVlLmlzSW5SaW5nKG8scikpcmV0dXJuIHRoaXMuX25lc3RlZFB0PW8sITF9fXJldHVybiEwfWFkZCh0KXt0aGlzLl9yaW5ncy5hZGQodCksdGhpcy5fdG90YWxFbnYuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX19Y2xhc3MgRnJ7Y29uc3RydWN0b3IoKXtGci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9lcnJvclR5cGU9bnVsbCx0aGlzLl9wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtGci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZXJyb3JUeXBlPXQsbnVsbCE9PWUmJih0aGlzLl9wdD1lLmNvcHkoKSl9fWdldEVycm9yVHlwZSgpe3JldHVybiB0aGlzLl9lcnJvclR5cGV9Z2V0TWVzc2FnZSgpe3JldHVybiBGci5lcnJNc2dbdGhpcy5fZXJyb3JUeXBlXX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fXRvU3RyaW5nKCl7bGV0IHQ9XCJcIjtyZXR1cm4gbnVsbCE9PXRoaXMuX3B0JiYodD1cIiBhdCBvciBuZWFyIHBvaW50IFwiK3RoaXMuX3B0KSx0aGlzLmdldE1lc3NhZ2UoKSt0fX1Gci5FUlJPUj0wLEZyLlJFUEVBVEVEX1BPSU5UPTEsRnIuSE9MRV9PVVRTSURFX1NIRUxMPTIsRnIuTkVTVEVEX0hPTEVTPTMsRnIuRElTQ09OTkVDVEVEX0lOVEVSSU9SPTQsRnIuU0VMRl9JTlRFUlNFQ1RJT049NSxGci5SSU5HX1NFTEZfSU5URVJTRUNUSU9OPTYsRnIuTkVTVEVEX1NIRUxMUz03LEZyLkRVUExJQ0FURV9SSU5HUz04LEZyLlRPT19GRVdfUE9JTlRTPTksRnIuSU5WQUxJRF9DT09SRElOQVRFPTEwLEZyLlJJTkdfTk9UX0NMT1NFRD0xMSxGci5lcnJNc2c9W1wiVG9wb2xvZ3kgVmFsaWRhdGlvbiBFcnJvclwiLFwiUmVwZWF0ZWQgUG9pbnRcIixcIkhvbGUgbGllcyBvdXRzaWRlIHNoZWxsXCIsXCJIb2xlcyBhcmUgbmVzdGVkXCIsXCJJbnRlcmlvciBpcyBkaXNjb25uZWN0ZWRcIixcIlNlbGYtaW50ZXJzZWN0aW9uXCIsXCJSaW5nIFNlbGYtaW50ZXJzZWN0aW9uXCIsXCJOZXN0ZWQgc2hlbGxzXCIsXCJEdXBsaWNhdGUgUmluZ3NcIixcIlRvbyBmZXcgZGlzdGluY3QgcG9pbnRzIGluIGdlb21ldHJ5IGNvbXBvbmVudFwiLFwiSW52YWxpZCBDb29yZGluYXRlXCIsXCJSaW5nIGlzIG5vdCBjbG9zZWRcIl07Y2xhc3MgR3J7Y29uc3RydWN0b3IoKXtHci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wYXJlbnRHZW9tZXRyeT1udWxsLHRoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9ITEsdGhpcy5fdmFsaWRFcnI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnRHZW9tZXRyeT10fXN0YXRpYyBmaW5kUHROb3ROb2RlKHQsZSxuKXtjb25zdCBzPW4uZmluZEVkZ2UoZSkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO2lmKCFzLmlzSW50ZXJzZWN0aW9uKG4pKXJldHVybiBufXJldHVybiBudWxsfXN0YXRpYyBpc1ZhbGlkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtyZXR1cm4gbmV3IEdyKGFyZ3VtZW50c1swXSkuaXNWYWxpZCgpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXIuaXNOYU4odC54KSYmKCFyLmlzSW5maW5pdGUodC54KSYmKCFyLmlzTmFOKHQueSkmJiFyLmlzSW5maW5pdGUodC55KSkpfX1jaGVja0ludmFsaWRDb29yZGluYXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCFHci5pc1ZhbGlkKHRbZV0pKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuSU5WQUxJRF9DT09SRElOQVRFLHRbZV0pLG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1jaGVja0hvbGVzTm90TmVzdGVkKHQsZSl7aWYodC5nZXROdW1JbnRlcmlvclJpbmcoKTw9MClyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBBcihlKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBzPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTtzLmlzRW1wdHkoKXx8bi5hZGQocyl9bi5pc05vbk5lc3RlZCgpfHwodGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLk5FU1RFRF9IT0xFUyxuLmdldE5lc3RlZFBvaW50KCkpKX1jaGVja0NvbnNpc3RlbnRBcmVhKHQpe2NvbnN0IGU9bmV3IERyKHQpO2lmKCFlLmlzTm9kZUNvbnNpc3RlbnRBcmVhKCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5TRUxGX0lOVEVSU0VDVElPTixlLmdldEludmFsaWRQb2ludCgpKSxudWxsO2UuaGFzRHVwbGljYXRlUmluZ3MoKSYmKHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5EVVBMSUNBVEVfUklOR1MsZS5nZXRJbnZhbGlkUG9pbnQoKSkpfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMuX3BhcmVudEdlb21ldHJ5KSxudWxsPT09dGhpcy5fdmFsaWRFcnJ9Y2hlY2tTaGVsbEluc2lkZUhvbGUodCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlcygpLHI9R3IuZmluZFB0Tm90Tm9kZShzLGUsbik7aWYobnVsbCE9PXIpe2lmKCFVZS5pc0luUmluZyhyLGkpKXJldHVybiByfWNvbnN0IG89R3IuZmluZFB0Tm90Tm9kZShpLHQsbik7aWYobnVsbCE9PW8pe3JldHVybiBVZS5pc0luUmluZyhvLHMpP286bnVsbH1yZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZShcInBvaW50cyBpbiBzaGVsbCBhbmQgaG9sZSBhcHBlYXIgdG8gYmUgZXF1YWxcIiksbnVsbH1jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKHQpe2ZvcihsZXQgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyh0LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19Y2hlY2tDb25uZWN0ZWRJbnRlcmlvcnModCl7Y29uc3QgZT1uZXcgVHIodCk7ZS5pc0ludGVyaW9yc0Nvbm5lY3RlZCgpfHwodGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLkRJU0NPTk5FQ1RFRF9JTlRFUklPUixlLmdldENvb3JkaW5hdGUoKSkpfWNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyh0KXtjb25zdCBlPW5ldyBhdDtsZXQgbj0hMDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZihuKW49ITE7ZWxzZXtpZihlLmNvbnRhaW5zKHQuY29vcmQpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuUklOR19TRUxGX0lOVEVSU0VDVElPTix0LmNvb3JkKSxudWxsO2UuYWRkKHQuY29vcmQpfX19Y2hlY2tIb2xlc0luU2hlbGwodCxlKXtpZih0LmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRFeHRlcmlvclJpbmcoKSxzPW4uaXNFbXB0eSgpLGk9bmV3IHplKG4pO2ZvcihsZXQgcj0wO3I8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe2NvbnN0IG89dC5nZXRJbnRlcmlvclJpbmdOKHIpO2xldCBsPW51bGw7aWYoby5pc0VtcHR5KCkpY29udGludWU7aWYobD1Hci5maW5kUHROb3ROb2RlKG8uZ2V0Q29vcmRpbmF0ZXMoKSxuLGUpLG51bGw9PT1sKXJldHVybiBudWxsO2lmKHN8fFF0LkVYVEVSSU9SPT09aS5sb2NhdGUobCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5IT0xFX09VVFNJREVfU0hFTEwsbCksbnVsbH19Y2hlY2tUb29GZXdQb2ludHModCl7aWYodC5oYXNUb29GZXdQb2ludHMoKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEZyKEZyLlRPT19GRVdfUE9JTlRTLHQuZ2V0SW52YWxpZFBvaW50KCkpLG51bGx9Z2V0VmFsaWRhdGlvbkVycm9yKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLl9wYXJlbnRHZW9tZXRyeSksdGhpcy5fdmFsaWRFcnJ9Y2hlY2tWYWxpZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IGFzKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcganQ7ZS5jb21wdXRlU2VsZk5vZGVzKG4sITAsITApLHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgJCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBhcygwLHQpO3RoaXMuY2hlY2tUb29GZXdQb2ludHMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHJ0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3ModCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IGFzKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKHQsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHl0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3MobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWNvbnN0IGU9bmV3IGFzKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpKXJldHVybiBudWxsO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwocyxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKHMsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWlmKHRoaXMuY2hlY2tTaGVsbHNOb3ROZXN0ZWQodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgaHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKHRoaXMuY2hlY2tWYWxpZChuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl92YWxpZEVycj1udWxsLHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBldCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgdXQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGd0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiAkKXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBydCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgeXQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgaHQpKXRocm93IG5ldyBLKHQuZ2V0R2VvbWV0cnlUeXBlKCkpO3RoaXMuY2hlY2tWYWxpZCh0KX19fXNldFNlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkKHQpe3RoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9dH1jaGVja1NoZWxsTm90TmVzdGVkKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0RXh0ZXJpb3JSaW5nKCk7aWYoaS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgcj1pLmdldENvb3JkaW5hdGVzKCksbz1Hci5maW5kUHROb3ROb2RlKHMsaSxuKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDtpZighVWUuaXNJblJpbmcobyxyKSlyZXR1cm4gbnVsbDtpZihlLmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuTkVTVEVEX1NIRUxMUyxvKSxudWxsO2xldCBsPW51bGw7Zm9yKGxldCBzPTA7czxlLmdldE51bUludGVyaW9yUmluZygpO3MrKyl7Y29uc3QgaT1lLmdldEludGVyaW9yUmluZ04ocyk7aWYobD10aGlzLmNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsaSxuKSxudWxsPT09bClyZXR1cm4gbnVsbH10aGlzLl92YWxpZEVycj1uZXcgRnIoRnIuTkVTVEVEX1NIRUxMUyxsKX1jaGVja0Nsb3NlZFJpbmdzKHQpe2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWNoZWNrQ2xvc2VkUmluZyh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZighdC5pc0Nsb3NlZCgpKXtsZXQgZT1udWxsO3QuZ2V0TnVtUG9pbnRzKCk+PTEmJihlPXQuZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuX3ZhbGlkRXJyPW5ldyBGcihGci5SSU5HX05PVF9DTE9TRUQsZSl9fWNoZWNrU2hlbGxzTm90TmVzdGVkKHQsZSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obikuZ2V0RXh0ZXJpb3JSaW5nKCk7Zm9yKGxldCBpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe2lmKG49PT1pKWNvbnRpbnVlO2NvbnN0IHI9dC5nZXRHZW9tZXRyeU4oaSk7aWYodGhpcy5jaGVja1NoZWxsTm90TmVzdGVkKHMscixlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fX19Y2xhc3MgcXJ7Y29uc3RydWN0b3IoKXtxci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZGVMaXN0PW5ldyBMLHRoaXMuX2xvd2VzdEVkZ2U9bnVsbCx0aGlzLl9yaW5nPW51bGwsdGhpcy5fbG9jYXRvcj1udWxsLHRoaXMuX3JpbmdQdHM9bnVsbCx0aGlzLl9ob2xlcz1udWxsLHRoaXMuX3NoZWxsPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5faXNQcm9jZXNzZWQ9ITEsdGhpcy5faXNJbmNsdWRlZFNldD0hMSx0aGlzLl9pc0luY2x1ZGVkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH1zdGF0aWMgZmluZERpckVkZ2VzSW5SaW5nKHQpe2xldCBlPXQ7Y29uc3Qgbj1uZXcgTDtkb3tuLmFkZChlKSxlPWUuZ2V0TmV4dCgpLGcuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGcuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKGUhPT10KTtyZXR1cm4gbn1zdGF0aWMgYWRkRWRnZSh0LGUsbil7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyluLmFkZCh0W2VdLCExKTtlbHNlIGZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKW4uYWRkKHRbZV0sITEpfXN0YXRpYyBmaW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSl7Y29uc3Qgbj10LmdldFJpbmcoKSxzPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2xldCBpPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscj1udWxsLG89bnVsbDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxsPWUuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZihsLmVxdWFscyhzKSljb250aW51ZTtpZighbC5jb250YWlucyhzKSljb250aW51ZTtpPV90LnB0Tm90SW5MaXN0KG4uZ2V0Q29vcmRpbmF0ZXMoKSxlLmdldENvb3JkaW5hdGVzKCkpO2UuaXNJblJpbmcoaSkmJihudWxsPT09cnx8by5jb250YWlucyhsKSkmJihyPWUsbz1yLmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfXJldHVybiByfWlzSW5jbHVkZWQoKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZH1nZXRDb29yZGluYXRlcygpe2lmKG51bGw9PT10aGlzLl9yaW5nUHRzKXtjb25zdCB0PW5ldyBSO2ZvcihsZXQgZT10aGlzLl9kZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldEVkZ2UoKTtxci5hZGRFZGdlKHMuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksbi5nZXRFZGdlRGlyZWN0aW9uKCksdCl9dGhpcy5fcmluZ1B0cz10LnRvQ29vcmRpbmF0ZUFycmF5KCl9cmV0dXJuIHRoaXMuX3JpbmdQdHN9aXNJbmNsdWRlZFNldCgpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkU2V0fWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLCEodGhpcy5fcmluZ1B0cy5sZW5ndGg8PTMpJiYodGhpcy5nZXRSaW5nKCksR3IuaXNWYWxpZCh0aGlzLl9yaW5nKSl9YnVpbGQodCl7bGV0IGU9dDtkb3t0aGlzLmFkZChlKSxlLnNldFJpbmcodGhpcyksZT1lLmdldE5leHQoKSxnLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxnLmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShlIT09dCl9aXNJblJpbmcodCl7cmV0dXJuIFF0LkVYVEVSSU9SIT09dGhpcy5nZXRMb2NhdG9yKCkubG9jYXRlKHQpfWlzT3V0ZXJIb2xlKCl7cmV0dXJuISF0aGlzLl9pc0hvbGUmJiF0aGlzLmhhc1NoZWxsKCl9Z2V0UG9seWdvbigpe2xldCB0PW51bGw7aWYobnVsbCE9PXRoaXMuX2hvbGVzKXt0PW5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5zaXplKCk7ZSsrKXRbZV09dGhpcy5faG9sZXMuZ2V0KGUpfXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24odGhpcy5fcmluZyx0KX1pc0hvbGUoKXtyZXR1cm4gdGhpcy5faXNIb2xlfWlzUHJvY2Vzc2VkKCl7cmV0dXJuIHRoaXMuX2lzUHJvY2Vzc2VkfWFkZEhvbGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGd0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5faG9sZXMmJih0aGlzLl9ob2xlcz1uZXcgTCksdGhpcy5faG9sZXMuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxcil7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5zZXRTaGVsbCh0aGlzKTtjb25zdCBlPXQuZ2V0UmluZygpO251bGw9PT10aGlzLl9ob2xlcyYmKHRoaXMuX2hvbGVzPW5ldyBMKSx0aGlzLl9ob2xlcy5hZGQoZSl9fXNldEluY2x1ZGVkKHQpe3RoaXMuX2lzSW5jbHVkZWQ9dCx0aGlzLl9pc0luY2x1ZGVkU2V0PSEwfWdldE91dGVySG9sZSgpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKGxldCB0PTA7dDx0aGlzLl9kZUxpc3Quc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9kZUxpc3QuZ2V0KHQpLmdldFN5bSgpLmdldFJpbmcoKTtpZihlLmlzT3V0ZXJIb2xlKCkpcmV0dXJuIGV9cmV0dXJuIG51bGx9Y29tcHV0ZUhvbGUoKXtjb25zdCB0PXRoaXMuZ2V0UmluZygpO3RoaXMuX2lzSG9sZT1xLmlzQ0NXKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9aGFzU2hlbGwoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3NoZWxsfWlzT3V0ZXJTaGVsbCgpe3JldHVybiBudWxsIT09dGhpcy5nZXRPdXRlckhvbGUoKX1nZXRMaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5fcmluZ1B0cyl9dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKG5ldyBtdCh0aGlzLmdldENvb3JkaW5hdGVzKCkpKX1nZXRMb2NhdG9yKCl7cmV0dXJuIG51bGw9PT10aGlzLl9sb2NhdG9yJiYodGhpcy5fbG9jYXRvcj1uZXcgemUodGhpcy5nZXRSaW5nKCkpKSx0aGlzLl9sb2NhdG9yfWdldFNoZWxsKCl7cmV0dXJuIHRoaXMuaXNIb2xlKCk/dGhpcy5fc2hlbGw6dGhpc31hZGQodCl7dGhpcy5fZGVMaXN0LmFkZCh0KX1nZXRSaW5nKCl7aWYobnVsbCE9PXRoaXMuX3JpbmcpcmV0dXJuIHRoaXMuX3Jpbmc7dGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMuX3JpbmdQdHMubGVuZ3RoPDMmJlkub3V0LnByaW50bG4odGhpcy5fcmluZ1B0cyk7dHJ5e3RoaXMuX3Jpbmc9dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuX3JpbmdQdHMpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IHQ7WS5vdXQucHJpbnRsbih0aGlzLl9yaW5nUHRzKX1yZXR1cm4gdGhpcy5fcmluZ311cGRhdGVJbmNsdWRlZCgpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKGxldCB0PTA7dDx0aGlzLl9kZUxpc3Quc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9kZUxpc3QuZ2V0KHQpLmdldFN5bSgpLmdldFJpbmcoKS5nZXRTaGVsbCgpO2lmKG51bGwhPT1lJiZlLmlzSW5jbHVkZWRTZXQoKSlyZXR1cm4gdGhpcy5zZXRJbmNsdWRlZCghZS5pc0luY2x1ZGVkKCkpLG51bGx9fXNldFNoZWxsKHQpe3RoaXMuX3NoZWxsPXR9c2V0UHJvY2Vzc2VkKHQpe3RoaXMuX2lzUHJvY2Vzc2VkPXR9fXFyLkVudmVsb3BlQ29tcGFyYXRvcj1jbGFzc3tjb21wYXJlKHQsZSl7Y29uc3Qgbj1lO3JldHVybiB0LmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpLmNvbXBhcmVUbyhuLmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fTtjbGFzcyBCciBleHRlbmRzICRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxCci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9mYWN0b3J5PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fXN0YXRpYyBmaW5kTGFiZWxlZEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyBMO2xldCBuPTE7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYodC5pc01hcmtlZCgpKWNvbnRpbnVlO2lmKHQuZ2V0TGFiZWwoKT49MCljb250aW51ZTtlLmFkZCh0KTtjb25zdCBpPXFyLmZpbmREaXJFZGdlc0luUmluZyh0KTtCci5sYWJlbChpLG4pLG4rK31yZXR1cm4gZX1zdGF0aWMgZ2V0RGVncmVlTm9uRGVsZXRlZCh0KXtsZXQgZT0wO2ZvcihsZXQgbj10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuaXNNYXJrZWQoKXx8ZSsrfXJldHVybiBlfXN0YXRpYyBkZWxldGVBbGxFZGdlcyh0KXtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRNYXJrZWQoITApO2NvbnN0IG49dC5nZXRTeW0oKTtudWxsIT09biYmbi5zZXRNYXJrZWQoITApfX1zdGF0aWMgbGFiZWwodCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuc2V0TGFiZWwoZSl9fXN0YXRpYyBjb21wdXRlTmV4dENXRWRnZXModCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKCF0LmlzTWFya2VkKCkpe2lmKG51bGw9PT1lJiYoZT10KSxudWxsIT09bil7bi5nZXRTeW0oKS5zZXROZXh0KHQpfW49dH19aWYobnVsbCE9PW4pe24uZ2V0U3ltKCkuc2V0TmV4dChlKX19c3RhdGljIGNvbXB1dGVOZXh0Q0NXRWRnZXModCxlKXtsZXQgbj1udWxsLHM9bnVsbDtjb25zdCBpPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpO2ZvcihsZXQgdD1pLnNpemUoKS0xO3Q+PTA7dC0tKXtjb25zdCByPWkuZ2V0KHQpLG89ci5nZXRTeW0oKTtsZXQgbD1udWxsO3IuZ2V0TGFiZWwoKT09PWUmJihsPXIpO2xldCBhPW51bGw7by5nZXRMYWJlbCgpPT09ZSYmKGE9byksbnVsbD09PWwmJm51bGw9PT1hfHwobnVsbCE9PWEmJihzPWEpLG51bGwhPT1sJiYobnVsbCE9PXMmJihzLnNldE5leHQobCkscz1udWxsKSxudWxsPT09biYmKG49bCkpKX1udWxsIT09cyYmKGcuaXNUcnVlKG51bGwhPT1uKSxzLnNldE5leHQobikpfXN0YXRpYyBnZXREZWdyZWUodCxlKXtsZXQgbj0wO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7cy5uZXh0KCkuZ2V0TGFiZWwoKT09PWUmJm4rK31yZXR1cm4gbn1zdGF0aWMgZmluZEludGVyc2VjdGlvbk5vZGVzKHQsZSl7bGV0IG49dCxzPW51bGw7ZG97Y29uc3QgaT1uLmdldEZyb21Ob2RlKCk7QnIuZ2V0RGVncmVlKGksZSk+MSYmKG51bGw9PT1zJiYocz1uZXcgTCkscy5hZGQoaSkpLG49bi5nZXROZXh0KCksZy5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZy5pc1RydWUobj09PXR8fCFuLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUobiE9PXQpO3JldHVybiBzfWZpbmRFZGdlUmluZyh0KXtjb25zdCBlPW5ldyBxcih0aGlzLl9mYWN0b3J5KTtyZXR1cm4gZS5idWlsZCh0KSxlfWNvbXB1dGVEZXB0aFBhcml0eSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcig7OylyZXR1cm4gbnVsbH1jb21wdXRlTmV4dENXRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5ub2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7QnIuY29tcHV0ZU5leHRDV0VkZ2VzKGUpfX1hZGRFZGdlKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IGU9X3QucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO2NvbnN0IG49ZVswXSxzPWVbZS5sZW5ndGgtMV0saT10aGlzLmdldE5vZGUobikscj10aGlzLmdldE5vZGUocyksbz1uZXcgU3IoaSxyLGVbMV0sITApLGw9bmV3IFNyKHIsaSxlW2UubGVuZ3RoLTJdLCExKSxhPW5ldyBMcih0KTthLnNldERpcmVjdGVkRWRnZXMobyxsKSx0aGlzLmFkZChhKX1kZWxldGVDdXRFZGdlcygpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksQnIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5fZGlyRWRnZXMpO2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0U3ltKCk7aWYobi5nZXRMYWJlbCgpPT09cy5nZXRMYWJlbCgpKXtuLnNldE1hcmtlZCghMCkscy5zZXRNYXJrZWQoITApO2NvbnN0IGU9bi5nZXRFZGdlKCk7dC5hZGQoZS5nZXRMaW5lKCkpfX1yZXR1cm4gdH1nZXRFZGdlUmluZ3MoKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLEJyLmxhYmVsKHRoaXMuX2RpckVkZ2VzLC0xKTtjb25zdCB0PUJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuX2RpckVkZ2VzKTt0aGlzLmNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpO2NvbnN0IGU9bmV3IEw7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtpZihuLmlzSW5SaW5nKCkpY29udGludWU7Y29uc3Qgcz10aGlzLmZpbmRFZGdlUmluZyhuKTtlLmFkZChzKX1yZXR1cm4gZX1nZXROb2RlKHQpe2xldCBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgS2kodCksdGhpcy5hZGQoZSkpLGV9Y29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldExhYmVsKCkscz1Cci5maW5kSW50ZXJzZWN0aW9uTm9kZXModCxuKTtpZihudWxsIT09cylmb3IobGV0IHQ9cy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtCci5jb21wdXRlTmV4dENDV0VkZ2VzKGUsbil9fX1kZWxldGVEYW5nbGVzKCl7Y29uc3QgdD10aGlzLmZpbmROb2Rlc09mRGVncmVlKDEpLGU9bmV3IEV0LG49bmV3IGVuO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KW4ucHVzaChlLm5leHQoKSk7Zm9yKDshbi5pc0VtcHR5KCk7KXtjb25zdCB0PW4ucG9wKCk7QnIuZGVsZXRlQWxsRWRnZXModCk7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3Quc2V0TWFya2VkKCEwKTtjb25zdCBpPXQuZ2V0U3ltKCk7bnVsbCE9PWkmJmkuc2V0TWFya2VkKCEwKTtjb25zdCByPXQuZ2V0RWRnZSgpO2UuYWRkKHIuZ2V0TGluZSgpKTtjb25zdCBvPXQuZ2V0VG9Ob2RlKCk7MT09PUJyLmdldERlZ3JlZU5vbkRlbGV0ZWQobykmJm4ucHVzaChvKX19cmV0dXJuIGV9fWNsYXNzIFlye2NvbnN0cnVjdG9yKCl7WXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2hlbGxzPW51bGwsdGhpcy5fc2hlbGxJbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NoZWxscz10LHRoaXMuYnVpbGRJbmRleCgpfXN0YXRpYyBhc3NpZ25Ib2xlc1RvU2hlbGxzKHQsZSl7bmV3IFlyKGUpLmFzc2lnbkhvbGVzVG9TaGVsbHModCl9YXNzaWduSG9sZXNUb1NoZWxscyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmFzc2lnbkhvbGVUb1NoZWxsKHQpfX1idWlsZEluZGV4KCl7dGhpcy5fc2hlbGxJbmRleD1uZXcgYnM7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fc2hlbGxzKXRoaXMuX3NoZWxsSW5kZXguaW5zZXJ0KHQuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSx0KX1xdWVyeU92ZXJsYXBwaW5nU2hlbGxzKHQpe3JldHVybiB0aGlzLl9zaGVsbEluZGV4LnF1ZXJ5KHQpfWZpbmRTaGVsbENvbnRhaW5pbmcodCl7Y29uc3QgZT10LmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCksbj10aGlzLnF1ZXJ5T3ZlcmxhcHBpbmdTaGVsbHMoZSk7cmV0dXJuIHFyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxuKX1hc3NpZ25Ib2xlVG9TaGVsbCh0KXtjb25zdCBlPXRoaXMuZmluZFNoZWxsQ29udGFpbmluZyh0KTtudWxsIT09ZSYmZS5hZGRIb2xlKHQpfX1jbGFzcyBWcntjb25zdHJ1Y3Rvcigpe1ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xpbmVTdHJpbmdBZGRlcj1uZXcgenIodGhpcyksdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9kYW5nbGVzPW5ldyBMLHRoaXMuX2N1dEVkZ2VzPW5ldyBMLHRoaXMuX2ludmFsaWRSaW5nTGluZXM9bmV3IEwsdGhpcy5faG9sZUxpc3Q9bnVsbCx0aGlzLl9zaGVsbExpc3Q9bnVsbCx0aGlzLl9wb2x5TGlzdD1udWxsLHRoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkPSEwLHRoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsPW51bGwsdGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClWci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLCExKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD10fX1zdGF0aWMgZXh0cmFjdFBvbHlnb25zKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTsoZXx8dC5pc0luY2x1ZGVkKCkpJiZuLmFkZCh0LmdldFBvbHlnb24oKSl9cmV0dXJuIG59c3RhdGljIGZpbmRPdXRlclNoZWxscyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0T3V0ZXJIb2xlKCk7bnVsbD09PW58fG4uaXNQcm9jZXNzZWQoKXx8KHQuc2V0SW5jbHVkZWQoITApLG4uc2V0UHJvY2Vzc2VkKCEwKSl9fXN0YXRpYyBmaW5kRGlzam9pbnRTaGVsbHModCl7VnIuZmluZE91dGVyU2hlbGxzKHQpO2xldCBlPW51bGw7ZG97ZT0hMTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0LmlzSW5jbHVkZWRTZXQoKXx8KHQudXBkYXRlSW5jbHVkZWQoKSx0LmlzSW5jbHVkZWRTZXQoKXx8KGU9ITApKX19d2hpbGUoZSl9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2dlb21GYWN0b3J5JiYodGhpcy5fZ2VvbUZhY3Rvcnk9bmV3IEx0KSx0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD90aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMuX3BvbHlMaXN0KTp0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oTHQudG9HZW9tZXRyeUFycmF5KHRoaXMuX3BvbHlMaXN0KSl9Z2V0SW52YWxpZFJpbmdMaW5lcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzfWZpbmRWYWxpZFJpbmdzKHQsZSxuKXtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzVmFsaWQoKT9lLmFkZCh0KTpuLmFkZCh0LmdldExpbmVTdHJpbmcoKSl9fXBvbHlnb25pemUoKXtpZihudWxsIT09dGhpcy5fcG9seUxpc3QpcmV0dXJuIG51bGw7aWYodGhpcy5fcG9seUxpc3Q9bmV3IEwsbnVsbD09PXRoaXMuX2dyYXBoKXJldHVybiBudWxsO3RoaXMuX2RhbmdsZXM9dGhpcy5fZ3JhcGguZGVsZXRlRGFuZ2xlcygpLHRoaXMuX2N1dEVkZ2VzPXRoaXMuX2dyYXBoLmRlbGV0ZUN1dEVkZ2VzKCk7Y29uc3QgdD10aGlzLl9ncmFwaC5nZXRFZGdlUmluZ3MoKTtsZXQgZT1uZXcgTDt0aGlzLl9pbnZhbGlkUmluZ0xpbmVzPW5ldyBMLHRoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkP3RoaXMuZmluZFZhbGlkUmluZ3ModCxlLHRoaXMuX2ludmFsaWRSaW5nTGluZXMpOmU9dCx0aGlzLmZpbmRTaGVsbHNBbmRIb2xlcyhlKSxZci5hc3NpZ25Ib2xlc1RvU2hlbGxzKHRoaXMuX2hvbGVMaXN0LHRoaXMuX3NoZWxsTGlzdCkseGUuc29ydCh0aGlzLl9zaGVsbExpc3QsbmV3IHFyLkVudmVsb3BlQ29tcGFyYXRvcik7bGV0IG49ITA7dGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWwmJihWci5maW5kRGlzam9pbnRTaGVsbHModGhpcy5fc2hlbGxMaXN0KSxuPSExKSx0aGlzLl9wb2x5TGlzdD1Wci5leHRyYWN0UG9seWdvbnModGhpcy5fc2hlbGxMaXN0LG4pfWdldERhbmdsZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fZGFuZ2xlc31nZXRDdXRFZGdlcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9jdXRFZGdlc31nZXRQb2x5Z29ucygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9wb2x5TGlzdH1hZGQoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mICQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLG51bGw9PT10aGlzLl9ncmFwaCYmKHRoaXMuX2dyYXBoPW5ldyBCcih0aGlzLl9nZW9tRmFjdG9yeSkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2FyZ3VtZW50c1swXS5hcHBseSh0aGlzLl9saW5lU3RyaW5nQWRkZXIpfX1zZXRDaGVja1JpbmdzVmFsaWQodCl7dGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ9dH1maW5kU2hlbGxzQW5kSG9sZXModCl7dGhpcy5faG9sZUxpc3Q9bmV3IEwsdGhpcy5fc2hlbGxMaXN0PW5ldyBMO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuY29tcHV0ZUhvbGUoKSx0LmlzSG9sZSgpP3RoaXMuX2hvbGVMaXN0LmFkZCh0KTp0aGlzLl9zaGVsbExpc3QuYWRkKHQpfX19Y2xhc3MgenJ7Y29uc3RydWN0b3IoKXt6ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnA9dH1maWx0ZXIodCl7dCBpbnN0YW5jZW9mICQmJnRoaXMucC5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfX1Wci5MaW5lU3RyaW5nQWRkZXI9enI7dmFyIFhyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFBvbHlnb25pemVyOlZyfSk7Y2xhc3Mga3J7Y29uc3RydWN0b3IoKXtrci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fcHRMb2NhdG9yPW5ldyBmbix0aGlzLl9hcmc9bnVsbCx0aGlzLl9ub2Rlcz1uZXcgbnMobmV3IGJyKSx0aGlzLl9pbT1udWxsLHRoaXMuX2lzb2xhdGVkRWRnZXM9bmV3IEwsdGhpcy5faW52YWxpZFBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJnPXR9aW5zZXJ0RWRnZUVuZHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkKHQpfX1jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0odCxlKXtjb25zdCBuPXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLHM9dGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCksaT10Lmhhc1Byb3BlckludGVyc2VjdGlvbigpLHI9dC5oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpOzI9PT1uJiYyPT09cz9pJiZlLnNldEF0TGVhc3QoXCIyMTIxMDEyMTJcIik6Mj09PW4mJjE9PT1zPyhpJiZlLnNldEF0TGVhc3QoXCJGRkYwRkZGRjJcIiksciYmZS5zZXRBdExlYXN0KFwiMUZGRkZGMUZGXCIpKToxPT09biYmMj09PXM/KGkmJmUuc2V0QXRMZWFzdChcIkYwRkZGRkZGMlwiKSxyJiZlLnNldEF0TGVhc3QoXCIxRjFGRkZGRkZcIikpOjE9PT1uJiYxPT09cyYmciYmZS5zZXRBdExlYXN0KFwiMEZGRkZGRkZGXCIpfWxhYmVsSXNvbGF0ZWRFZGdlcyh0LGUpe2ZvcihsZXQgbj10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3QuaXNJc29sYXRlZCgpJiYodGhpcy5sYWJlbElzb2xhdGVkRWRnZSh0LGUsdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpLHRoaXMuX2lzb2xhdGVkRWRnZXMuYWRkKHQpKX19bGFiZWxJc29sYXRlZEVkZ2UodCxlLG4pe2lmKG4uZ2V0RGltZW5zaW9uKCk+MCl7Y29uc3Qgcz10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLG4pO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxzKX1lbHNlIHQuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxRdC5FWFRFUklPUil9Y29tcHV0ZUlNKCl7Y29uc3QgdD1uZXcgSnQ7aWYodC5zZXQoUXQuRVhURVJJT1IsUXQuRVhURVJJT1IsMiksIXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuIHRoaXMuY29tcHV0ZURpc2pvaW50SU0odCksdDt0aGlzLl9hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpO2NvbnN0IGU9dGhpcy5fYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLl9hcmdbMV0sdGhpcy5fbGksITEpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDApLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDEpLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDEpLHRoaXMubGFiZWxJc29sYXRlZE5vZGVzKCksdGhpcy5jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0oZSx0KTtjb25zdCBuPW5ldyBScixzPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuX2FyZ1swXS5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhzKTtjb25zdCBpPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuX2FyZ1sxXS5nZXRFZGdlSXRlcmF0b3IoKSk7cmV0dXJuIHRoaXMuaW5zZXJ0RWRnZUVuZHMoaSksdGhpcy5sYWJlbE5vZGVFZGdlcygpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDAsMSksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMSwwKSx0aGlzLnVwZGF0ZUlNKHQpLHR9bGFiZWxOb2RlRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLl9hcmcpfX1jb3B5Tm9kZXNBbmRMYWJlbHModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX1sYWJlbEludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2ZvcihsZXQgZT1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCksaT10aGlzLl9ub2Rlcy5maW5kKG4uY29vcmQpO2kuZ2V0TGFiZWwoKS5pc051bGwodCkmJihzPT09UXQuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KHQpOmkuc2V0TGFiZWwodCxRdC5JTlRFUklPUikpfX19bGFiZWxJc29sYXRlZE5vZGUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxuKX1jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxpPXRoaXMuX25vZGVzLmFkZE5vZGUobi5jb29yZCk7cz09PVF0LkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeSh0KTppLmdldExhYmVsKCkuaXNOdWxsKHQpJiZpLnNldExhYmVsKHQsUXQuSU5URVJJT1IpfX19bGFiZWxJc29sYXRlZE5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO2cuaXNUcnVlKG4uZ2V0R2VvbWV0cnlDb3VudCgpPjAsXCJub2RlIHdpdGggZW1wdHkgbGFiZWwgZm91bmRcIiksZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMCk6dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDEpKX19dXBkYXRlSU0odCl7Zm9yKGxldCBlPXRoaXMuX2lzb2xhdGVkRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnVwZGF0ZUlNKHQpfWZvcihsZXQgZT10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuLnVwZGF0ZUlNKHQpLG4udXBkYXRlSU1Gcm9tRWRnZXModCl9fWNvbXB1dGVEaXNqb2ludElNKHQpe2NvbnN0IGU9dGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCk7ZS5pc0VtcHR5KCl8fCh0LnNldChRdC5JTlRFUklPUixRdC5FWFRFUklPUixlLmdldERpbWVuc2lvbigpKSx0LnNldChRdC5CT1VOREFSWSxRdC5FWFRFUklPUixlLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKTtjb25zdCBuPXRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpO24uaXNFbXB0eSgpfHwodC5zZXQoUXQuRVhURVJJT1IsUXQuSU5URVJJT1Isbi5nZXREaW1lbnNpb24oKSksdC5zZXQoUXQuRVhURVJJT1IsUXQuQk9VTkRBUlksbi5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSl9fWNsYXNzIFVye2NvbnN0cnVjdG9yKCl7VXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdEVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9c3RhdGljIGNvbnRhaW5zKHQsZSl7cmV0dXJuIG5ldyBVcih0KS5jb250YWlucyhlKX1pc0NvbnRhaW5lZEluQm91bmRhcnkodCl7aWYodCBpbnN0YW5jZW9mIHJ0KXJldHVybiExO2lmKHQgaW5zdGFuY2VvZiBldClyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0IGluc3RhbmNlb2YgJClyZXR1cm4gdGhpcy5pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeShuKSlyZXR1cm4hMX1yZXR1cm4hMH1pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LGUpe2lmKHQuZXF1YWxzKGUpKXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQueD09PWUueCl7aWYodC54PT09dGhpcy5fcmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpKXJldHVybiEwfWVsc2UgaWYodC55PT09ZS55JiYodC55PT09dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpKSlyZXR1cm4hMDtyZXR1cm4hMX1pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPW5ldyBtLHM9bmV3IG07Zm9yKGxldCB0PTA7dDxlLnNpemUoKS0xO3QrKylpZihlLmdldENvb3JkaW5hdGUodCxuKSxlLmdldENvb3JkaW5hdGUodCsxLHMpLCF0aGlzLmlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KG4scykpcmV0dXJuITE7cmV0dXJuITB9aXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGV0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LmdldENvb3JkaW5hdGUoKSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC54PT09dGhpcy5fcmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNYXhZKCl9fWNvbnRhaW5zKHQpe3JldHVybiEhdGhpcy5fcmVjdEVudi5jb250YWlucyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJiF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KX19Y2xhc3MgSHJ7Y29uc3RydWN0b3IoKXtIci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2RpYWdVcDA9bnVsbCx0aGlzLl9kaWFnVXAxPW51bGwsdGhpcy5fZGlhZ0Rvd24wPW51bGwsdGhpcy5fZGlhZ0Rvd24xPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LHRoaXMuX2RpYWdVcDA9bmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuX2RpYWdVcDE9bmV3IG0odC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLHRoaXMuX2RpYWdEb3duMD1uZXcgbSh0LmdldE1pblgoKSx0LmdldE1heFkoKSksdGhpcy5fZGlhZ0Rvd24xPW5ldyBtKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKX1pbnRlcnNlY3RzKHQsZSl7Y29uc3Qgbj1uZXcgTyh0LGUpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMobikpcmV0dXJuITE7aWYodGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKHQpKXJldHVybiEwO2lmKHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4hMDtpZih0LmNvbXBhcmVUbyhlKT4wKXtjb25zdCBuPXQ7dD1lLGU9bn1sZXQgcz0hMTtyZXR1cm4gZS55PnQueSYmKHM9ITApLHM/dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fZGlhZ0Rvd24wLHRoaXMuX2RpYWdEb3duMSk6dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fZGlhZ1VwMCx0aGlzLl9kaWFnVXAxKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfX1jbGFzcyBXcntjb25zdHJ1Y3Rvcigpe1dyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RhbmdsZT1udWxsLHRoaXMuX3JlY3RFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0YW5nbGU9dCx0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfXN0YXRpYyBpbnRlcnNlY3RzKHQsZSl7cmV0dXJuIG5ldyBXcih0KS5pbnRlcnNlY3RzKGUpfWludGVyc2VjdHModCl7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuITE7Y29uc3QgZT1uZXcgWnIodGhpcy5fcmVjdEVudik7aWYoZS5hcHBseVRvKHQpLGUuaW50ZXJzZWN0cygpKXJldHVybiEwO2NvbnN0IG49bmV3IGpyKHRoaXMuX3JlY3RhbmdsZSk7aWYobi5hcHBseVRvKHQpLG4uY29udGFpbnNQb2ludCgpKXJldHVybiEwO2NvbnN0IHM9bmV3IEtyKHRoaXMuX3JlY3RhbmdsZSk7cmV0dXJuIHMuYXBwbHlUbyh0KSwhIXMuaW50ZXJzZWN0cygpfX1jbGFzcyBaciBleHRlbmRzIE5le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxaci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5faW50ZXJzZWN0cz0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXR9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9pbnRlcnNlY3RzfXZpc2l0KHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKT90aGlzLl9yZWN0RW52LmNvbnRhaW5zKGUpfHxlLmdldE1pblgoKT49dGhpcy5fcmVjdEVudi5nZXRNaW5YKCkmJmUuZ2V0TWF4WCgpPD10aGlzLl9yZWN0RW52LmdldE1heFgoKXx8ZS5nZXRNaW5ZKCk+PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpJiZlLmdldE1heFkoKTw9dGhpcy5fcmVjdEVudi5nZXRNYXhZKCk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6dm9pZCAwOm51bGx9aW50ZXJzZWN0cygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzfX1jbGFzcyBqciBleHRlbmRzIE5le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxqci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0U2VxPW51bGwsdGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdFNlcT10LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHRoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9jb250YWluc1BvaW50fXZpc2l0KHQpe2lmKCEodCBpbnN0YW5jZW9mIHJ0KSlyZXR1cm4gbnVsbDtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgbTtmb3IobGV0IHM9MDtzPDQ7cysrKWlmKHRoaXMuX3JlY3RTZXEuZ2V0Q29vcmRpbmF0ZShzLG4pLGUuY29udGFpbnMobikmJlplLmNvbnRhaW5zUG9pbnRJblBvbHlnb24obix0KSlyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD0hMCxudWxsfWNvbnRhaW5zUG9pbnQoKXtyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludH19Y2xhc3MgS3IgZXh0ZW5kcyBOZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksS3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1udWxsLHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9wMD1uZXcgbSx0aGlzLl9wMT1uZXcgbTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1uZXcgSHIodGhpcy5fcmVjdEVudil9aW50ZXJzZWN0cygpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9oYXNJbnRlcnNlY3Rpb259dmlzaXQodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO2NvbnN0IG49eWUuZ2V0TGluZXModCk7dGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5ncyhuKX1jaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5ncyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKHQpLHRoaXMuX2hhc0ludGVyc2VjdGlvbilyZXR1cm4gbnVsbH19Y2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHModCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKWlmKGUuZ2V0Q29vcmRpbmF0ZSh0LTEsdGhpcy5fcDApLGUuZ2V0Q29vcmRpbmF0ZSh0LHRoaXMuX3AxKSx0aGlzLl9yZWN0SW50ZXJzZWN0b3IuaW50ZXJzZWN0cyh0aGlzLl9wMCx0aGlzLl9wMSkpcmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCxudWxsfX1jbGFzcyBRciBleHRlbmRzIE5ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxRci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9yZWxhdGU9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07TnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX3JlbGF0ZT1uZXcga3IodGhpcy5fYXJnKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtOci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuKSx0aGlzLl9yZWxhdGU9bmV3IGtyKHRoaXMuX2FyZyl9fXN0YXRpYyBjb3ZlcnModCxlKXtyZXR1cm4hKDI9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDIpJiYoISgxPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwxJiZlLmdldExlbmd0aCgpPjApJiYoISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb3ZlcnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYoISF0LmlzUmVjdGFuZ2xlKCl8fG5ldyBRcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ292ZXJzKCkpKSl9c3RhdGljIGludGVyc2VjdHModCxlKXtpZighdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuITE7aWYodC5pc1JlY3RhbmdsZSgpKXJldHVybiBXci5pbnRlcnNlY3RzKHQsZSk7aWYoZS5pc1JlY3RhbmdsZSgpKXJldHVybiBXci5pbnRlcnNlY3RzKGUsdCk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWZvcihsZXQgcz0wO3M8ZS5nZXROdW1HZW9tZXRyaWVzKCk7cysrKWlmKHQuZ2V0R2VvbWV0cnlOKG4pLmludGVyc2VjdHMoZS5nZXRHZW9tZXRyeU4ocykpKXJldHVybiEwO3JldHVybiExfXJldHVybiBuZXcgUXIodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0ludGVyc2VjdHMoKX1zdGF0aWMgdG91Y2hlcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBRcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzVG91Y2hlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBlcXVhbHNUb3BvKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5lcXVhbHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZRci5yZWxhdGUodCxlKS5pc0VxdWFscyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyByZWxhdGUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBRcihhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBRcihhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCl9fXN0YXRpYyBvdmVybGFwcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBRcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzT3ZlcmxhcHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgY3Jvc3Nlcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBRcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ3Jvc3Nlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBjb250YWlucyh0LGUpe3JldHVybiEoMj09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MikmJighKDE9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDEmJmUuZ2V0TGVuZ3RoKCk+MCkmJighIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvbnRhaW5zKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKHQuaXNSZWN0YW5nbGUoKT9Vci5jb250YWlucyh0LGUpOm5ldyBRcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ29udGFpbnMoKSkpKX1nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKXtyZXR1cm4gdGhpcy5fcmVsYXRlLmNvbXB1dGVJTSgpfX12YXIgSnI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUmVsYXRlT3A6UXJ9KTtjbGFzcyAkcntjb25zdHJ1Y3RvcigpeyRyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BvaW50R2VvbT1udWxsLHRoaXMuX290aGVyR2VvbT1udWxsLHRoaXMuX2dlb21GYWN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcG9pbnRHZW9tPXQsdGhpcy5fb3RoZXJHZW9tPWUsdGhpcy5fZ2VvbUZhY3Q9ZS5nZXRGYWN0b3J5KCl9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIG5ldyAkcih0LGUpLnVuaW9uKCl9dW5pb24oKXtjb25zdCB0PW5ldyBmbixlPW5ldyBhdDtmb3IobGV0IG49MDtuPHRoaXMuX3BvaW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXRoaXMuX3BvaW50R2VvbS5nZXRHZW9tZXRyeU4obikuZ2V0Q29vcmRpbmF0ZSgpO3QubG9jYXRlKHMsdGhpcy5fb3RoZXJHZW9tKT09PVF0LkVYVEVSSU9SJiZlLmFkZChzKX1pZigwPT09ZS5zaXplKCkpcmV0dXJuIHRoaXMuX290aGVyR2VvbTtsZXQgbj1udWxsO2NvbnN0IHM9X3QudG9Db29yZGluYXRlQXJyYXkoZSk7cmV0dXJuIG49MT09PXMubGVuZ3RoP3RoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KHNbMF0pOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKHMpLGhlLmNvbWJpbmUobix0aGlzLl9vdGhlckdlb20pfX1jbGFzcyB0b3tjb25zdHJ1Y3Rvcigpe3RvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5fcG9seWdvbnM9bmV3IEwsdGhpcy5fbGluZXM9bmV3IEwsdGhpcy5fcG9pbnRzPW5ldyBMLHRoaXMuX2RpbWVuc2lvbj1RLkZBTFNFfXN0YXRpYyBleHRyYWN0KCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHRvO3JldHVybiBlLmFkZCh0KSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgdG87cmV0dXJuIGUuYWRkKHQpLGV9fWdldEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fZ2VvbUZhY3Rvcnl9cmVjb3JkRGltZW5zaW9uKHQpe3Q+dGhpcy5fZGltZW5zaW9uJiYodGhpcy5fZGltZW5zaW9uPXQpfWdldERpbWVuc2lvbigpe3JldHVybiB0aGlzLl9kaW1lbnNpb259ZmlsdGVyKHQpe3JldHVybiB0aGlzLnJlY29yZERpbWVuc2lvbih0LmdldERpbWVuc2lvbigpKSx0IGluc3RhbmNlb2YgaHR8fHQuaXNFbXB0eSgpP251bGw6dCBpbnN0YW5jZW9mIHJ0Pyh0aGlzLl9wb2x5Z29ucy5hZGQodCksbnVsbCk6dCBpbnN0YW5jZW9mICQ/KHRoaXMuX2xpbmVzLmFkZCh0KSxudWxsKTp0IGluc3RhbmNlb2YgZXQ/KHRoaXMuX3BvaW50cy5hZGQodCksbnVsbCk6dm9pZCBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5oYW5kbGVkIGdlb21ldHJ5IHR5cGU6IFwiK3QuZ2V0R2VvbWV0cnlUeXBlKCkpfWdldEV4dHJhY3QodCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdGhpcy5fcG9pbnRzO2Nhc2UgMTpyZXR1cm4gdGhpcy5fbGluZXM7Y2FzZSAyOnJldHVybiB0aGlzLl9wb2x5Z29uc31yZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZShcIkludmFsaWQgZGltZW5zaW9uOiBcIit0KSxudWxsfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fcG9seWdvbnMuaXNFbXB0eSgpJiZ0aGlzLl9saW5lcy5pc0VtcHR5KCkmJnRoaXMuX3BvaW50cy5pc0VtcHR5KCl9YWRkKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2Zvcihjb25zdCBlIG9mIHQpdGhpcy5hZGQoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9nZW9tRmFjdG9yeSYmKHRoaXMuX2dlb21GYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0LmFwcGx5KHRoaXMpfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSl19fWNsYXNzIGVve3N0YXRpYyB1bmlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiB3ci5jcmVhdGVFbXB0eVJlc3VsdCh3ci5VTklPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9cmV0dXJuIFUuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksVS5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxJci5vdmVybGF5T3AodCxlLHdyLlVOSU9OKX19Y2xhc3Mgbm97Y29uc3RydWN0b3IoKXtuby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX2cwPW51bGwsdGhpcy5fZzE9bnVsbCx0aGlzLl9pc1VuaW9uU2FmZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2cwPXQsdGhpcy5fZzE9ZSx0aGlzLl9nZW9tRmFjdG9yeT10LmdldEZhY3RvcnkoKX1zdGF0aWMgY29udGFpbnNQcm9wZXJseSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdC5pc051bGwoKSYmKGUuZ2V0WCgpPnQuZ2V0TWluWCgpJiZlLmdldFgoKTx0LmdldE1heFgoKSYmZS5nZXRZKCk+dC5nZXRNaW5ZKCkmJmUuZ2V0WSgpPHQuZ2V0TWF4WSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5vLmNvbnRhaW5zUHJvcGVybHkodCxlKSYmbm8uY29udGFpbnNQcm9wZXJseSh0LG4pfX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gbmV3IG5vKHQsZSkudW5pb24oKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUsbil7cmV0dXJuIHQuaW50ZXJzZWN0cyhlKXx8dC5pbnRlcnNlY3RzKG4pfXN0YXRpYyBvdmVybGFwRW52ZWxvcGUodCxlKXtjb25zdCBuPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHM9ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIG4uaW50ZXJzZWN0aW9uKHMpfXN0YXRpYyBleHRyYWN0Qm9yZGVyU2VnbWVudHModCxlLG4pe3QuYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltQXX1maWx0ZXIodCxzKXtpZihzPD0wKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlKHMtMSkscj10LmdldENvb3JkaW5hdGUocyk7aWYobm8uaW50ZXJzZWN0cyhlLGkscikmJiFuby5jb250YWluc1Byb3Blcmx5KGUsaSxyKSl7Y29uc3QgdD1uZXcgS3QoaSxyKTtuLmFkZCh0KX19aXNEb25lKCl7cmV0dXJuITF9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMX19KX1zdGF0aWMgdW5pb25CdWZmZXIodCxlKXtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFt0LGVdKS5idWZmZXIoMCl9aXNCb3JkZXJTZWdtZW50c1NhbWUodCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdEJvcmRlclNlZ21lbnRzKHRoaXMuX2cwLHRoaXMuX2cxLGUpLHM9bmV3IEw7cmV0dXJuIG5vLmV4dHJhY3RCb3JkZXJTZWdtZW50cyh0LGUscyksdGhpcy5pc0VxdWFsKG4scyl9ZXh0cmFjdEJ5RW52ZWxvcGUodCxlLG4pe2NvbnN0IHM9bmV3IEw7Zm9yKGxldCBpPTA7aTxlLmdldE51bUdlb21ldHJpZXMoKTtpKyspe2NvbnN0IHI9ZS5nZXRHZW9tZXRyeU4oaSk7aWYoci5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KSlzLmFkZChyKTtlbHNle2NvbnN0IHQ9ci5jb3B5KCk7bi5hZGQodCl9fXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHMpfWlzRXF1YWwodCxlKXtpZih0LnNpemUoKSE9PWUuc2l6ZSgpKXJldHVybiExO2NvbnN0IG49bmV3IEV0KHQpO2Zvcihjb25zdCB0IG9mIGUpaWYoIW4uY29udGFpbnModCkpcmV0dXJuITE7cmV0dXJuITB9dW5pb24oKXtjb25zdCB0PW5vLm92ZXJsYXBFbnZlbG9wZSh0aGlzLl9nMCx0aGlzLl9nMSk7aWYodC5pc051bGwoKSl7Y29uc3QgdD10aGlzLl9nMC5jb3B5KCksZT10aGlzLl9nMS5jb3B5KCk7cmV0dXJuIGhlLmNvbWJpbmUodCxlKX1jb25zdCBlPW5ldyBMLG49dGhpcy5leHRyYWN0QnlFbnZlbG9wZSh0LHRoaXMuX2cwLGUpLHM9dGhpcy5leHRyYWN0QnlFbnZlbG9wZSh0LHRoaXMuX2cxLGUpLGk9dGhpcy51bmlvbkZ1bGwobixzKTtsZXQgcj1udWxsO3JldHVybiB0aGlzLl9pc1VuaW9uU2FmZT10aGlzLmlzQm9yZGVyU2VnbWVudHNTYW1lKGksdCkscj10aGlzLl9pc1VuaW9uU2FmZT90aGlzLmNvbWJpbmUoaSxlKTp0aGlzLnVuaW9uRnVsbCh0aGlzLl9nMCx0aGlzLl9nMSkscn1jb21iaW5lKHQsZSl7aWYoZS5zaXplKCk8PTApcmV0dXJuIHQ7ZS5hZGQodCk7cmV0dXJuIGhlLmNvbWJpbmUoZSl9dW5pb25GdWxsKHQsZSl7dHJ5e3JldHVybiBlby51bmlvbih0LGUpfWNhdGNoKG4pe2lmKG4gaW5zdGFuY2VvZiBpcylyZXR1cm4gbm8udW5pb25CdWZmZXIodCxlKTt0aHJvdyBufX1leHRyYWN0Qm9yZGVyU2VnbWVudHModCxlLG4pe2NvbnN0IHM9bmV3IEw7cmV0dXJuIG5vLmV4dHJhY3RCb3JkZXJTZWdtZW50cyh0LG4scyksbnVsbCE9PWUmJm5vLmV4dHJhY3RCb3JkZXJTZWdtZW50cyhlLG4scyksc31pc1VuaW9uT3B0aW1pemVkKCl7cmV0dXJuIHRoaXMuX2lzVW5pb25TYWZlfX1jbGFzcyBzb3tjb25zdHJ1Y3Rvcigpe3NvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0UG9seXM9bnVsbCx0aGlzLl9nZW9tRmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0UG9seXM9dCxudWxsPT09dGhpcy5faW5wdXRQb2x5cyYmKHRoaXMuX2lucHV0UG9seXM9bmV3IEwpfXN0YXRpYyByZXN0cmljdFRvUG9seWdvbnModCl7aWYoSSh0LGl0KSlyZXR1cm4gdDtjb25zdCBlPUllLmdldFBvbHlnb25zKHQpO3JldHVybiAxPT09ZS5zaXplKCk/ZS5nZXQoMCk6dC5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKEx0LnRvUG9seWdvbkFycmF5KGUpKX1zdGF0aWMgZ2V0R2VvbWV0cnkodCxlKXtyZXR1cm4gZT49dC5zaXplKCk/bnVsbDp0LmdldChlKX1zdGF0aWMgdW5pb24odCl7cmV0dXJuIG5ldyBzbyh0KS51bmlvbigpfXJlZHVjZVRvR2VvbWV0cmllcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2xldCBzPW51bGw7SSh0LEMpP3M9dGhpcy51bmlvblRyZWUodCk6dCBpbnN0YW5jZW9mIFUmJihzPXQpLGUuYWRkKHMpfXJldHVybiBlfXVuaW9uKCl7aWYobnVsbD09PXRoaXMuX2lucHV0UG9seXMpdGhyb3cgbmV3IEQoXCJ1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlXCIpO2lmKHRoaXMuX2lucHV0UG9seXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuX2dlb21GYWN0b3J5PXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO2NvbnN0IHQ9bmV3IGJzKHNvLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWSk7Zm9yKGxldCBlPXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5pbnNlcnQobi5nZXRFbnZlbG9wZUludGVybmFsKCksbil9dGhpcy5faW5wdXRQb2x5cz1udWxsO2NvbnN0IGU9dC5pdGVtc1RyZWUoKTtyZXR1cm4gdGhpcy51bmlvblRyZWUoZSl9YmluYXJ5VW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24odCwwLHQuc2l6ZSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYobi1lPD0xKXtjb25zdCBuPXNvLmdldEdlb21ldHJ5KHQsZSk7cmV0dXJuIHRoaXMudW5pb25TYWZlKG4sbnVsbCl9aWYobi1lPT0yKXJldHVybiB0aGlzLnVuaW9uU2FmZShzby5nZXRHZW9tZXRyeSh0LGUpLHNvLmdldEdlb21ldHJ5KHQsZSsxKSk7e2NvbnN0IHM9TWF0aC50cnVuYygobitlKS8yKSxpPXRoaXMuYmluYXJ5VW5pb24odCxlLHMpLHI9dGhpcy5iaW5hcnlVbmlvbih0LHMsbik7cmV0dXJuIHRoaXMudW5pb25TYWZlKGkscil9fX1yZXBlYXRlZFVuaW9uKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZT1udWxsPT09ZT90LmNvcHkoKTplLnVuaW9uKHQpfXJldHVybiBlfXVuaW9uU2FmZSh0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09dD9lLmNvcHkoKTpudWxsPT09ZT90LmNvcHkoKTp0aGlzLnVuaW9uQWN0dWFsKHQsZSl9dW5pb25BY3R1YWwodCxlKXtjb25zdCBuPW5vLnVuaW9uKHQsZSk7cmV0dXJuIHNvLnJlc3RyaWN0VG9Qb2x5Z29ucyhuKX11bmlvblRyZWUodCl7Y29uc3QgZT10aGlzLnJlZHVjZVRvR2VvbWV0cmllcyh0KTtyZXR1cm4gdGhpcy5iaW5hcnlVbmlvbihlKX1idWZmZXJVbmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXQoMCkuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkodCkuYnVmZmVyKDApfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFt0LGVdKS5idWZmZXIoMCl9fX1zby5TVFJUUkVFX05PREVfQ0FQQUNJVFk9NDtjbGFzcyBpb3tjb25zdHJ1Y3Rvcigpe2lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fZXh0cmFjdGVyPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbUZhY3Q9ZSx0aGlzLmV4dHJhY3QodCl9fXN0YXRpYyB1bmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7cmV0dXJuIG5ldyBpbyhhcmd1bWVudHNbMF0pLnVuaW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtyZXR1cm4gbmV3IGlvKGFyZ3VtZW50c1swXSkudW5pb24oKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBpbyhhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS51bmlvbigpfX11bmlvbk5vT3B0KHQpe2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoKTtyZXR1cm4gSXIub3ZlcmxheU9wKHQsZSx3ci5VTklPTil9dW5pb25XaXRoTnVsbCh0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09ZT90Om51bGw9PT10P2U6d3IudW5pb24odCxlKX1leHRyYWN0KCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2V4dHJhY3Rlcj10by5leHRyYWN0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9leHRyYWN0ZXI9dG8uZXh0cmFjdCh0KX19dW5pb24oKXtpZihudWxsPT09dGhpcy5fZ2VvbUZhY3QmJih0aGlzLl9nZW9tRmFjdD10aGlzLl9leHRyYWN0ZXIuZ2V0RmFjdG9yeSgpKSxudWxsPT09dGhpcy5fZ2VvbUZhY3QpcmV0dXJuIG51bGw7aWYodGhpcy5fZXh0cmFjdGVyLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlRW1wdHkodGhpcy5fZXh0cmFjdGVyLmdldERpbWVuc2lvbigpKTtjb25zdCB0PXRoaXMuX2V4dHJhY3Rlci5nZXRFeHRyYWN0KDApLGU9dGhpcy5fZXh0cmFjdGVyLmdldEV4dHJhY3QoMSksbj10aGlzLl9leHRyYWN0ZXIuZ2V0RXh0cmFjdCgyKTtsZXQgcz1udWxsO2lmKHQuc2l6ZSgpPjApe2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0KTtzPXRoaXMudW5pb25Ob09wdChlKX1sZXQgaT1udWxsO2lmKGUuc2l6ZSgpPjApe2NvbnN0IHQ9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShlKTtpPXRoaXMudW5pb25Ob09wdCh0KX1sZXQgcj1udWxsO24uc2l6ZSgpPjAmJihyPXNvLnVuaW9uKG4pKTtjb25zdCBvPXRoaXMudW5pb25XaXRoTnVsbChpLHIpO2xldCBsPW51bGw7cmV0dXJuIGw9bnVsbD09PXM/bzpudWxsPT09bz9zOiRyLnVuaW9uKHMsbyksbnVsbD09PWw/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6bH19dmFyIHJvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFVuYXJ5VW5pb25PcDppb30pLG9vPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLElzVmFsaWRPcDpHcixDb25zaXN0ZW50QXJlYVRlc3RlcjpEcn0pLGxvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEJvdW5kYXJ5T3A6aWksSXNTaW1wbGVPcDpvaSxidWZmZXI6QmksZGlzdGFuY2U6WGksbGluZW1lcmdlOnJyLG92ZXJsYXk6Q3IscG9seWdvbml6ZTpYcixyZWxhdGU6SnIsdW5pb246cm8sdmFsaWQ6b299KTtjbGFzcyBhb3tjb25zdHJ1Y3Rvcigpe2FvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3JldHVyblRvT3JpZ2luYWxQcmVjaXNpb249ITAsdGhpcy5fY2JyPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpYW8uY29uc3RydWN0b3JfLmNhbGwodGhpcywhMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmV0dXJuVG9PcmlnaW5hbFByZWNpc2lvbj10fX1jb21wdXRlUmVzdWx0UHJlY2lzaW9uKHQpe3JldHVybiB0aGlzLl9yZXR1cm5Ub09yaWdpbmFsUHJlY2lzaW9uJiZ0aGlzLl9jYnIuYWRkQ29tbW9uQml0cyh0KSx0fXVuaW9uKHQsZSl7Y29uc3Qgbj10aGlzLnJlbW92ZUNvbW1vbkJpdHModCxlKTtyZXR1cm4gdGhpcy5jb21wdXRlUmVzdWx0UHJlY2lzaW9uKG5bMF0udW5pb24oblsxXSkpfWludGVyc2VjdGlvbih0LGUpe2NvbnN0IG49dGhpcy5yZW1vdmVDb21tb25CaXRzKHQsZSk7cmV0dXJuIHRoaXMuY29tcHV0ZVJlc3VsdFByZWNpc2lvbihuWzBdLmludGVyc2VjdGlvbihuWzFdKSl9cmVtb3ZlQ29tbW9uQml0cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jYnI9bmV3IGZyLHRoaXMuX2Nici5hZGQodCk7cmV0dXJuIHRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHQuY29weSgpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY2JyPW5ldyBmcix0aGlzLl9jYnIuYWRkKHQpLHRoaXMuX2Nici5hZGQoZSk7Y29uc3Qgbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gblswXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0LmNvcHkoKSksblsxXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyhlLmNvcHkoKSksbn19YnVmZmVyKHQsZSl7Y29uc3Qgbj10aGlzLnJlbW92ZUNvbW1vbkJpdHModCk7cmV0dXJuIHRoaXMuY29tcHV0ZVJlc3VsdFByZWNpc2lvbihuLmJ1ZmZlcihlKSl9c3ltRGlmZmVyZW5jZSh0LGUpe2NvbnN0IG49dGhpcy5yZW1vdmVDb21tb25CaXRzKHQsZSk7cmV0dXJuIHRoaXMuY29tcHV0ZVJlc3VsdFByZWNpc2lvbihuWzBdLnN5bURpZmZlcmVuY2UoblsxXSkpfWRpZmZlcmVuY2UodCxlKXtjb25zdCBuPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0LGUpO3JldHVybiB0aGlzLmNvbXB1dGVSZXN1bHRQcmVjaXNpb24oblswXS5kaWZmZXJlbmNlKG5bMV0pKX19Y2xhc3MgY28gZXh0ZW5kcyB1ZS5Db29yZGluYXRlT3BlcmF0aW9ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxjby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90YXJnZXRQTT1udWxsLHRoaXMuX3JlbW92ZUNvbGxhcHNlZD0hMDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl90YXJnZXRQTT10LHRoaXMuX3JlbW92ZUNvbGxhcHNlZD1lfWVkaXQoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBVJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IHM9bmV3IG0odFtlXSk7dGhpcy5fdGFyZ2V0UE0ubWFrZVByZWNpc2UocyksbltlXT1zfWNvbnN0IHM9bmV3IFIobiwhMSkudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgaT0wO2UgaW5zdGFuY2VvZiAkJiYoaT0yKSxlIGluc3RhbmNlb2YgZ3QmJihpPTQpO2xldCByPW47cmV0dXJuIHRoaXMuX3JlbW92ZUNvbGxhcHNlZCYmKHI9bnVsbCkscy5sZW5ndGg8aT9yOnN9cmV0dXJuIHN1cGVyLmVkaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX1jbGFzcyBob3tjb25zdHJ1Y3Rvcigpe2hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3RhcmdldFBNPW51bGwsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPSEwLHRoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsPSExLHRoaXMuX2lzUG9pbnR3aXNlPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3RhcmdldFBNPXR9c3RhdGljIHJlZHVjZSh0LGUpe3JldHVybiBuZXcgaG8oZSkucmVkdWNlKHQpfXN0YXRpYyByZWR1Y2VQb2ludHdpc2UodCxlKXtjb25zdCBuPW5ldyBobyhlKTtyZXR1cm4gbi5zZXRQb2ludHdpc2UoITApLG4ucmVkdWNlKHQpfWZpeFBvbHlnb25hbFRvcG9sb2d5KHQpe2xldCBlPXQ7dGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChlPXRoaXMuY2hhbmdlUE0odCx0aGlzLl90YXJnZXRQTSkpO3JldHVybiBxaS5idWZmZXJPcChlLDApfXJlZHVjZVBvaW50d2lzZSh0KXtsZXQgZT1udWxsO2lmKHRoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsKXtjb25zdCBuPXRoaXMuY3JlYXRlRmFjdG9yeSh0LmdldEZhY3RvcnkoKSx0aGlzLl90YXJnZXRQTSk7ZT1uZXcgdWUobil9ZWxzZSBlPW5ldyB1ZTtsZXQgbj10aGlzLl9yZW1vdmVDb2xsYXBzZWQ7dC5nZXREaW1lbnNpb24oKT49MiYmKG49ITApO3JldHVybiBlLmVkaXQodCxuZXcgY28odGhpcy5fdGFyZ2V0UE0sbikpfWNoYW5nZVBNKHQsZSl7cmV0dXJuIHRoaXMuY3JlYXRlRWRpdG9yKHQuZ2V0RmFjdG9yeSgpLGUpLmVkaXQodCxuZXcgdWUuTm9PcEdlb21ldHJ5T3BlcmF0aW9uKX1zZXRSZW1vdmVDb2xsYXBzZWRDb21wb25lbnRzKHQpe3RoaXMuX3JlbW92ZUNvbGxhcHNlZD10fWNyZWF0ZUZhY3RvcnkodCxlKXtyZXR1cm4gbmV3IEx0KGUsdC5nZXRTUklEKCksdC5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfXNldENoYW5nZVByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsPXR9cmVkdWNlKHQpe2NvbnN0IGU9dGhpcy5yZWR1Y2VQb2ludHdpc2UodCk7cmV0dXJuIHRoaXMuX2lzUG9pbnR3aXNlP2U6SShlLGl0KT9Hci5pc1ZhbGlkKGUpP2U6dGhpcy5maXhQb2x5Z29uYWxUb3BvbG9neShlKTplfXNldFBvaW50d2lzZSh0KXt0aGlzLl9pc1BvaW50d2lzZT10fWNyZWF0ZUVkaXRvcih0LGUpe2lmKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKT09PWUpcmV0dXJuIG5ldyB1ZTtjb25zdCBuPXRoaXMuY3JlYXRlRmFjdG9yeSh0LGUpO3JldHVybiBuZXcgdWUobil9fWNsYXNzIHVve2NvbnN0cnVjdG9yKCl7dW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbT1udWxsLHRoaXMuX3B0cz1udWxsLHRoaXMuX3N0YXJ0PW51bGwsdGhpcy5fZW5kPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX3N0YXJ0PWUsdGhpcy5fZW5kPWUrMX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wdHM9dCx0aGlzLl9zdGFydD1lLHRoaXMuX2VuZD1ufWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX2dlb209dCx0aGlzLl9wdHM9ZSx0aGlzLl9zdGFydD1uLHRoaXMuX2VuZD1zfX1jb21wdXRlRGlzdGFuY2VMaW5lTGluZSh0LGUpe2xldCBuPXIuTUFYX1ZBTFVFO2ZvcihsZXQgcz10aGlzLl9zdGFydDtzPHRoaXMuX2VuZC0xO3MrKyl7Y29uc3QgaT10aGlzLl9wdHMuZ2V0Q29vcmRpbmF0ZShzKSxyPXRoaXMuX3B0cy5nZXRDb29yZGluYXRlKHMrMSk7Zm9yKGxldCBvPXQuX3N0YXJ0O288dC5fZW5kLTE7bysrKXtjb25zdCBsPXQuX3B0cy5nZXRDb29yZGluYXRlKG8pLGE9dC5fcHRzLmdldENvb3JkaW5hdGUobysxKSxjPXouc2VnbWVudFRvU2VnbWVudChpLHIsbCxhKTtpZihjPG4mJihuPWMsbnVsbCE9PWUmJnRoaXMudXBkYXRlTmVhcmVzdExvY2F0aW9uc0xpbmVMaW5lKHMsaSxyLHQsbyxsLGEsZSksbjw9MCkpcmV0dXJuIG59fXJldHVybiBufXVwZGF0ZU5lYXJlc3RMb2NhdGlvbnNQb2ludExpbmUodCxlLG4scyxpLHIpe3JbMF09bmV3IFlpKHRoaXMuX2dlb20sdGhpcy5fc3RhcnQsbmV3IG0odCkpO2NvbnN0IG89bmV3IEt0KHMsaSkuY2xvc2VzdFBvaW50KHQpO3JbMV09bmV3IFlpKGUuX2dlb20sbixuZXcgbShvKSl9c2l6ZSgpe3JldHVybiB0aGlzLl9lbmQtdGhpcy5fc3RhcnR9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzLmdldENvb3JkaW5hdGUodGhpcy5fc3RhcnQrdCl9bmVhcmVzdExvY2F0aW9ucyh0KXtjb25zdCBlPXRoaXMuaXNQb2ludCgpLG49dC5pc1BvaW50KCkscz1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZihlJiZuKXtjb25zdCBlPXRoaXMuX3B0cy5nZXRDb29yZGluYXRlKHRoaXMuX3N0YXJ0KSxuPXQuX3B0cy5nZXRDb29yZGluYXRlKHQuX3N0YXJ0KTtzWzBdPW5ldyBZaSh0aGlzLl9nZW9tLHRoaXMuX3N0YXJ0LG5ldyBtKGUpKSxzWzFdPW5ldyBZaSh0Ll9nZW9tLHQuX3N0YXJ0LG5ldyBtKG4pKX1lbHNlIGlmKGUpe2NvbnN0IGU9dGhpcy5fcHRzLmdldENvb3JkaW5hdGUodGhpcy5fc3RhcnQpO3RoaXMuY29tcHV0ZURpc3RhbmNlUG9pbnRMaW5lKGUsdCxzKX1lbHNlIGlmKG4pe2NvbnN0IGU9dC5fcHRzLmdldENvb3JkaW5hdGUodC5fc3RhcnQpO3RoaXMuY29tcHV0ZURpc3RhbmNlUG9pbnRMaW5lKGUsdGhpcyxzKTtjb25zdCBuPXNbMF07c1swXT1zWzFdLHNbMV09bn1lbHNlIHRoaXMuY29tcHV0ZURpc3RhbmNlTGluZUxpbmUodCxzKTtyZXR1cm4gc31nZXRFbnZlbG9wZSgpe2NvbnN0IHQ9bmV3IE87Zm9yKGxldCBlPXRoaXMuX3N0YXJ0O2U8dGhpcy5fZW5kO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9wdHMuZ2V0WChlKSx0aGlzLl9wdHMuZ2V0WShlKSk7cmV0dXJuIHR9dXBkYXRlTmVhcmVzdExvY2F0aW9uc0xpbmVMaW5lKHQsZSxuLHMsaSxyLG8sbCl7Y29uc3QgYT1uZXcgS3QoZSxuKSxjPW5ldyBLdChyLG8pLGg9YS5jbG9zZXN0UG9pbnRzKGMpO2xbMF09bmV3IFlpKHRoaXMuX2dlb20sdCxuZXcgbShoWzBdKSksbFsxXT1uZXcgWWkocy5fZ2VvbSxpLG5ldyBtKGhbMV0pKX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHY7dC5hcHBlbmQoXCJMSU5FU1RSSU5HICggXCIpO2NvbnN0IGU9bmV3IG07Zm9yKGxldCBuPXRoaXMuX3N0YXJ0O248dGhpcy5fZW5kO24rKyluPnRoaXMuX3N0YXJ0JiZ0LmFwcGVuZChcIiwgXCIpLHRoaXMuX3B0cy5nZXRDb29yZGluYXRlKG4sZSksdC5hcHBlbmQoZS54K1wiIFwiK2UueSk7cmV0dXJuIHQuYXBwZW5kKFwiIClcIiksdC50b1N0cmluZygpfWNvbXB1dGVEaXN0YW5jZVBvaW50TGluZSh0LGUsbil7bGV0IHM9ci5NQVhfVkFMVUU7Zm9yKGxldCBpPWUuX3N0YXJ0O2k8ZS5fZW5kLTE7aSsrKXtjb25zdCByPWUuX3B0cy5nZXRDb29yZGluYXRlKGkpLG89ZS5fcHRzLmdldENvb3JkaW5hdGUoaSsxKSxsPXoucG9pbnRUb1NlZ21lbnQodCxyLG8pO2lmKGw8cyYmKHM9bCxudWxsIT09biYmdGhpcy51cGRhdGVOZWFyZXN0TG9jYXRpb25zUG9pbnRMaW5lKHQsZSxpLHIsbyxuKSxzPD0wKSlyZXR1cm4gc31yZXR1cm4gc31pc1BvaW50KCl7cmV0dXJuIHRoaXMuX2VuZC10aGlzLl9zdGFydD09MX1kaXN0YW5jZSh0KXtjb25zdCBlPXRoaXMuaXNQb2ludCgpLG49dC5pc1BvaW50KCk7bGV0IHM9bnVsbDtpZihlJiZuKXtjb25zdCBlPXRoaXMuX3B0cy5nZXRDb29yZGluYXRlKHRoaXMuX3N0YXJ0KSxuPXQuX3B0cy5nZXRDb29yZGluYXRlKHQuX3N0YXJ0KTtzPWUuZGlzdGFuY2Uobil9ZWxzZSBpZihlKXtjb25zdCBlPXRoaXMuX3B0cy5nZXRDb29yZGluYXRlKHRoaXMuX3N0YXJ0KTtzPXRoaXMuY29tcHV0ZURpc3RhbmNlUG9pbnRMaW5lKGUsdCxudWxsKX1lbHNlIGlmKG4pe2NvbnN0IGU9dC5fcHRzLmdldENvb3JkaW5hdGUodC5fc3RhcnQpO3M9dGhpcy5jb21wdXRlRGlzdGFuY2VQb2ludExpbmUoZSx0aGlzLG51bGwpfWVsc2Ugcz10aGlzLmNvbXB1dGVEaXN0YW5jZUxpbmVMaW5lKHQsbnVsbCk7cmV0dXJuIHN9fWNsYXNzIGdve3N0YXRpYyBhZGRGYWNldFNlcXVlbmNlcyh0LGUsbil7bGV0IHM9MDtjb25zdCBpPWUuc2l6ZSgpO2Zvcig7czw9aS0xOyl7bGV0IHI9cytnby5GQUNFVF9TRVFVRU5DRV9TSVpFKzE7cj49aS0xJiYocj1pKTtjb25zdCBvPW5ldyB1byh0LGUscyxyKTtuLmFkZChvKSxzKz1nby5GQUNFVF9TRVFVRU5DRV9TSVpFfX1zdGF0aWMgY29tcHV0ZUZhY2V0U2VxdWVuY2VzKHQpe2NvbnN0IGU9bmV3IEw7cmV0dXJuIHQuYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX1maWx0ZXIodCl7bGV0IG49bnVsbDsodCBpbnN0YW5jZW9mICR8fHQgaW5zdGFuY2VvZiBldCkmJihuPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksZ28uYWRkRmFjZXRTZXF1ZW5jZXModCxuLGUpKX19KSxlfXN0YXRpYyBidWlsZCh0KXtjb25zdCBlPW5ldyBicyhnby5TVFJfVFJFRV9OT0RFX0NBUEFDSVRZKTtmb3IobGV0IG49Z28uY29tcHV0ZUZhY2V0U2VxdWVuY2VzKHQpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuaW5zZXJ0KHQuZ2V0RW52ZWxvcGUoKSx0KX1yZXR1cm4gZS5idWlsZCgpLGV9fWdvLkZBQ0VUX1NFUVVFTkNFX1NJWkU9Nixnby5TVFJfVFJFRV9OT0RFX0NBUEFDSVRZPTQ7Y2xhc3MgX297Y29uc3RydWN0b3IoKXtfby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9taW5DbGVhcmFuY2U9bnVsbCx0aGlzLl9taW5DbGVhcmFuY2VQdHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgZ2V0TGluZSh0KXtyZXR1cm4gbmV3IF9vKHQpLmdldExpbmUoKX1zdGF0aWMgZ2V0RGlzdGFuY2UodCl7cmV0dXJuIG5ldyBfbyh0KS5nZXREaXN0YW5jZSgpfWdldExpbmUoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksbnVsbD09PXRoaXMuX21pbkNsZWFyYW5jZVB0c3x8bnVsbD09PXRoaXMuX21pbkNsZWFyYW5jZVB0c1swXT90aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTp0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5fbWluQ2xlYXJhbmNlUHRzKX1jb21wdXRlKCl7aWYobnVsbCE9PXRoaXMuX21pbkNsZWFyYW5jZVB0cylyZXR1cm4gbnVsbDtpZih0aGlzLl9taW5DbGVhcmFuY2VQdHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fbWluQ2xlYXJhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgdD1nby5idWlsZCh0aGlzLl9pbnB1dEdlb20pLm5lYXJlc3ROZWlnaGJvdXIobmV3IHBvKSxlPW5ldyBwbzt0aGlzLl9taW5DbGVhcmFuY2U9ZS5kaXN0YW5jZSh0WzBdLHRbMV0pLHRoaXMuX21pbkNsZWFyYW5jZVB0cz1lLmdldENvb3JkaW5hdGVzKCl9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fbWluQ2xlYXJhbmNlfX1jbGFzcyBwb3tjb25zdHJ1Y3Rvcigpe3BvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21pbkRpc3Q9ci5NQVhfVkFMVUUsdGhpcy5fbWluUHRzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpfXZlcnRleERpc3RhbmNlKHQsZSl7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspZm9yKGxldCBzPTA7czxlLnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXRDb29yZGluYXRlKG4pLHI9ZS5nZXRDb29yZGluYXRlKHMpO2lmKCFpLmVxdWFsczJEKHIpKXtjb25zdCB0PWkuZGlzdGFuY2Uocik7aWYodDx0aGlzLl9taW5EaXN0JiYodGhpcy5fbWluRGlzdD10LHRoaXMuX21pblB0c1swXT1pLHRoaXMuX21pblB0c1sxXT1yLDA9PT10KSlyZXR1cm4gdH19cmV0dXJuIHRoaXMuX21pbkRpc3R9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fbWluUHRzfXNlZ21lbnREaXN0YW5jZSh0LGUpe2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKWZvcihsZXQgcz0xO3M8ZS5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZShuKSxyPWUuZ2V0Q29vcmRpbmF0ZShzLTEpLG89ZS5nZXRDb29yZGluYXRlKHMpO2lmKCFpLmVxdWFsczJEKHIpJiYhaS5lcXVhbHMyRChvKSl7Y29uc3QgdD16LnBvaW50VG9TZWdtZW50KGkscixvKTtpZih0PHRoaXMuX21pbkRpc3QmJih0aGlzLl9taW5EaXN0PXQsdGhpcy51cGRhdGVQdHMoaSxyLG8pLDA9PT10KSlyZXR1cm4gdH19cmV0dXJuIHRoaXMuX21pbkRpc3R9ZGlzdGFuY2UoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFNzJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFNzKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXS5nZXRJdGVtKCksbj10LmdldEl0ZW0oKTtyZXR1cm4gdGhpcy5fbWluRGlzdD1yLk1BWF9WQUxVRSx0aGlzLmRpc3RhbmNlKGUsbil9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB1byYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiB1byl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMudmVydGV4RGlzdGFuY2UodCxlKSwxPT09dC5zaXplKCkmJjE9PT1lLnNpemUoKT90aGlzLl9taW5EaXN0OnRoaXMuX21pbkRpc3Q8PTA/dGhpcy5fbWluRGlzdDoodGhpcy5zZWdtZW50RGlzdGFuY2UodCxlKSx0aGlzLl9taW5EaXN0PD0wfHx0aGlzLnNlZ21lbnREaXN0YW5jZShlLHQpLHRoaXMuX21pbkRpc3QpfX11cGRhdGVQdHModCxlLG4pe3RoaXMuX21pblB0c1swXT10O2NvbnN0IHM9bmV3IEt0KGUsbik7dGhpcy5fbWluUHRzWzFdPW5ldyBtKHMuY2xvc2VzdFBvaW50KHQpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bdnNdfX1fby5NaW5DbGVhcmFuY2VEaXN0YW5jZT1wbztjbGFzcyBtb3tjb25zdHJ1Y3Rvcigpe21vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX21pbkNsZWFyYW5jZT1udWxsLHRoaXMuX21pbkNsZWFyYW5jZVB0cz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBnZXRMaW5lKHQpe3JldHVybiBuZXcgbW8odCkuZ2V0TGluZSgpfXN0YXRpYyBnZXREaXN0YW5jZSh0KXtyZXR1cm4gbmV3IG1vKHQpLmdldERpc3RhbmNlKCl9Z2V0TGluZSgpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5fbWluQ2xlYXJhbmNlUHRzKX11cGRhdGVDbGVhcmFuY2UoKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dDx0aGlzLl9taW5DbGVhcmFuY2UmJih0aGlzLl9taW5DbGVhcmFuY2U9dCx0aGlzLl9taW5DbGVhcmFuY2VQdHNbMF09bmV3IG0oZSksdGhpcy5fbWluQ2xlYXJhbmNlUHRzWzFdPW5ldyBtKG4pKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtpZih0PHRoaXMuX21pbkNsZWFyYW5jZSl7dGhpcy5fbWluQ2xlYXJhbmNlPXQsdGhpcy5fbWluQ2xlYXJhbmNlUHRzWzBdPW5ldyBtKGUpO2NvbnN0IGk9bmV3IEt0KG4scyk7dGhpcy5fbWluQ2xlYXJhbmNlUHRzWzFdPW5ldyBtKGkuY2xvc2VzdFBvaW50KGUpKX19fWNvbXB1dGUoKXtpZihudWxsIT09dGhpcy5fbWluQ2xlYXJhbmNlUHRzKXJldHVybiBudWxsO3RoaXMuX21pbkNsZWFyYW5jZVB0cz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9taW5DbGVhcmFuY2U9ci5NQVhfVkFMVUUsdGhpcy5faW5wdXRHZW9tLmFwcGx5KG5ldyBmbyh0aGlzKSl9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fbWluQ2xlYXJhbmNlfX1jbGFzcyBmb3tjb25zdHJ1Y3Rvcigpe2ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuc21jPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zbWM9dH1maWx0ZXIodCl7dGhpcy5zbWMuX2lucHV0R2VvbS5hcHBseShuZXcgeW8odGhpcy5zbWMsdCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIXX19Y2xhc3MgeW97Y29uc3RydWN0b3IoKXt5by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnNtYz1udWxsLHRoaXMuX3F1ZXJ5UHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNtYz10LHRoaXMuX3F1ZXJ5UHQ9ZX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiExfWNoZWNrVmVydGV4RGlzdGFuY2UodCl7Y29uc3QgZT10LmRpc3RhbmNlKHRoaXMuX3F1ZXJ5UHQpO2U+MCYmdGhpcy5zbWMudXBkYXRlQ2xlYXJhbmNlKGUsdGhpcy5fcXVlcnlQdCx0KX1maWx0ZXIodCxlKXt0aGlzLmNoZWNrVmVydGV4RGlzdGFuY2UodC5nZXRDb29yZGluYXRlKGUpKSxlPjAmJnRoaXMuY2hlY2tTZWdtZW50RGlzdGFuY2UodC5nZXRDb29yZGluYXRlKGUtMSksdC5nZXRDb29yZGluYXRlKGUpKX1jaGVja1NlZ21lbnREaXN0YW5jZSh0LGUpe2lmKHRoaXMuX3F1ZXJ5UHQuZXF1YWxzMkQodCl8fHRoaXMuX3F1ZXJ5UHQuZXF1YWxzMkQoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj16LnBvaW50VG9TZWdtZW50KHRoaXMuX3F1ZXJ5UHQsZSx0KTtuPjAmJnRoaXMuc21jLnVwZGF0ZUNsZWFyYW5jZShuLHRoaXMuX3F1ZXJ5UHQsZSx0KX1pc0RvbmUoKXtyZXR1cm4hMX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUF19fW1vLlZlcnRleENvb3JkaW5hdGVGaWx0ZXI9Zm8sbW8uQ29tcHV0ZU1DQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyPXlvO3ZhciB4bz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb21tb25CaXRzOm1yLENvbW1vbkJpdHNPcDphbyxDb21tb25CaXRzUmVtb3ZlcjpmcixFbmhhbmNlZFByZWNpc2lvbk9wOmNsYXNze3N0YXRpYyB1bmlvbih0LGUpe2xldCBuPW51bGw7dHJ5e3JldHVybiB0LnVuaW9uKGUpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7bj10fXRyeXtjb25zdCBzPW5ldyBhbyghMCkudW5pb24odCxlKTtpZighcy5pc1ZhbGlkKCkpdGhyb3cgbjtyZXR1cm4gc31jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgaD9uOnR9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtsZXQgbj1udWxsO3RyeXtyZXR1cm4gdC5pbnRlcnNlY3Rpb24oZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDtuPXR9dHJ5e2NvbnN0IHM9bmV3IGFvKCEwKS5pbnRlcnNlY3Rpb24odCxlKTtpZighcy5pc1ZhbGlkKCkpdGhyb3cgbjtyZXR1cm4gc31jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgaD9uOnR9fXN0YXRpYyBidWZmZXIodCxlKXtsZXQgbj1udWxsO3RyeXtyZXR1cm4gdC5idWZmZXIoZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDtuPXR9dHJ5e2NvbnN0IHM9bmV3IGFvKCEwKS5idWZmZXIodCxlKTtpZighcy5pc1ZhbGlkKCkpdGhyb3cgbjtyZXR1cm4gc31jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgaD9uOnR9fXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7bGV0IG49bnVsbDt0cnl7cmV0dXJuIHQuc3ltRGlmZmVyZW5jZShlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O249dH10cnl7Y29uc3Qgcz1uZXcgYW8oITApLnN5bURpZmZlcmVuY2UodCxlKTtpZighcy5pc1ZhbGlkKCkpdGhyb3cgbjtyZXR1cm4gc31jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgaD9uOnR9fXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7bGV0IG49bnVsbDt0cnl7cmV0dXJuIHQuZGlmZmVyZW5jZShlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O249dH10cnl7Y29uc3Qgcz1uZXcgYW8oITApLmRpZmZlcmVuY2UodCxlKTtpZighcy5pc1ZhbGlkKCkpdGhyb3cgbjtyZXR1cm4gc31jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgaD9uOnR9fX0sR2VvbWV0cnlQcmVjaXNpb25SZWR1Y2VyOmhvLE1pbmltdW1DbGVhcmFuY2U6X28sU2ltcGxlTWluaW11bUNsZWFyYW5jZTptb30pO2NsYXNzIEVve2NvbnN0cnVjdG9yKCl7RW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fdXNlUHQ9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX3NlZz1uZXcgS3Q7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgRW8odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5zaW1wbGlmeSgpfXNpbXBsaWZ5U2VjdGlvbih0LGUpe2lmKHQrMT09PWUpcmV0dXJuIG51bGw7dGhpcy5fc2VnLnAwPXRoaXMuX3B0c1t0XSx0aGlzLl9zZWcucDE9dGhpcy5fcHRzW2VdO2xldCBuPS0xLHM9dDtmb3IobGV0IGk9dCsxO2k8ZTtpKyspe2NvbnN0IHQ9dGhpcy5fc2VnLmRpc3RhbmNlKHRoaXMuX3B0c1tpXSk7dD5uJiYobj10LHM9aSl9aWYobjw9dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpZm9yKGxldCBuPXQrMTtuPGU7bisrKXRoaXMuX3VzZVB0W25dPSExO2Vsc2UgdGhpcy5zaW1wbGlmeVNlY3Rpb24odCxzKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihzLGUpfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnkoKXt0aGlzLl91c2VQdD1uZXcgQXJyYXkodGhpcy5fcHRzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3B0cy5sZW5ndGg7dCsrKXRoaXMuX3VzZVB0W3RdPSEwO3RoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5fcHRzLmxlbmd0aC0xKTtjb25zdCB0PW5ldyBSO2ZvcihsZXQgZT0wO2U8dGhpcy5fcHRzLmxlbmd0aDtlKyspdGhpcy5fdXNlUHRbZV0mJnQuYWRkKG5ldyBtKHRoaXMuX3B0c1tlXSkpO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9fWNsYXNzIElve2NvbnN0cnVjdG9yKCl7SW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgSW8odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfXNldEVuc3VyZVZhbGlkKHQpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10fWdldFJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCk/dGhpcy5faW5wdXRHZW9tLmNvcHkoKTpuZXcgTm8odGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PDApdGhyb3cgbmV3IHMoXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH19Y2xhc3MgTm8gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9ZX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgeXQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IHM9bnVsbDtyZXR1cm4gcz0wPT09bi5sZW5ndGg/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6RW8uc2ltcGxpZnkobix0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj1lIGluc3RhbmNlb2YgcnQscz1zdXBlci50cmFuc2Zvcm1MaW5lYXJSaW5nLmNhbGwodGhpcyx0LGUpO3JldHVybiFufHxzIGluc3RhbmNlb2YgZ3Q/czpudWxsfX1Jby5EUFRyYW5zZm9ybWVyPU5vO2NsYXNzIHdvIGV4dGVuZHMgS3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLHdvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BhcmVudD1udWxsLHRoaXMuX2luZGV4PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3dvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG51bGwsLTEpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO0t0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9wYXJlbnQ9bix0aGlzLl9pbmRleD1zfX1nZXRJbmRleCgpe3JldHVybiB0aGlzLl9pbmRleH1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50fX1jbGFzcyBDb3tjb25zdHJ1Y3Rvcigpe0NvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BhcmVudExpbmU9bnVsbCx0aGlzLl9zZWdzPW51bGwsdGhpcy5fcmVzdWx0U2Vncz1uZXcgTCx0aGlzLl9taW5pbXVtU2l6ZT1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtDby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcGFyZW50TGluZT10LHRoaXMuX21pbmltdW1TaXplPWUsdGhpcy5pbml0KCl9fXN0YXRpYyBleHRyYWN0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkrMSkuZmlsbChudWxsKTtsZXQgbj1udWxsO2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKW49dC5nZXQocyksZVtzXT1uLnAwO3JldHVybiBlW2UubGVuZ3RoLTFdPW4ucDEsZX1hZGRUb1Jlc3VsdCh0KXt0aGlzLl9yZXN1bHRTZWdzLmFkZCh0KX1hc0xpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhDby5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2VncykpfWdldFJlc3VsdFNpemUoKXtjb25zdCB0PXRoaXMuX3Jlc3VsdFNlZ3Muc2l6ZSgpO3JldHVybiAwPT09dD8wOnQrMX1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZX1nZXRTZWdtZW50KHQpe3JldHVybiB0aGlzLl9zZWdzW3RdfWdldFBhcmVudENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKX1nZXRNaW5pbXVtU2l6ZSgpe3JldHVybiB0aGlzLl9taW5pbXVtU2l6ZX1hc0xpbmVhclJpbmcoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhDby5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2VncykpfWdldFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3NlZ3N9aW5pdCgpe2NvbnN0IHQ9dGhpcy5fcGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpO3RoaXMuX3NlZ3M9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0xO2UrKyl7Y29uc3Qgbj1uZXcgd28odFtlXSx0W2UrMV0sdGhpcy5fcGFyZW50TGluZSxlKTt0aGlzLl9zZWdzW2VdPW59fWdldFJlc3VsdENvb3JkaW5hdGVzKCl7cmV0dXJuIENvLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKX19Y2xhc3MgU297Y29uc3RydWN0b3IoKXtTby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbmRleD1uZXcgTnN9cmVtb3ZlKHQpe3RoaXMuX2luZGV4LnJlbW92ZShuZXcgTyh0LnAwLHQucDEpLHQpfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQ28pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldFNlZ21lbnRzKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49dFtlXTt0aGlzLmFkZChuKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbmRleC5pbnNlcnQobmV3IE8odC5wMCx0LnAxKSx0KX19cXVlcnkodCl7Y29uc3QgZT1uZXcgTyh0LnAwLHQucDEpLG49bmV3IExvKHQpO3RoaXMuX2luZGV4LnF1ZXJ5KGUsbik7cmV0dXJuIG4uZ2V0SXRlbXMoKX19Y2xhc3MgTG97Y29uc3RydWN0b3IoKXtMby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9xdWVyeVNlZz1udWxsLHRoaXMuX2l0ZW1zPW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3F1ZXJ5U2VnPXR9dmlzaXRJdGVtKHQpe2NvbnN0IGU9dDtPLmludGVyc2VjdHMoZS5wMCxlLnAxLHRoaXMuX3F1ZXJ5U2VnLnAwLHRoaXMuX3F1ZXJ5U2VnLnAxKSYmdGhpcy5faXRlbXMuYWRkKHQpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltEZV19fWNsYXNzIFRve2NvbnN0cnVjdG9yKCl7VG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX2lucHV0SW5kZXg9bmV3IFNvLHRoaXMuX291dHB1dEluZGV4PW5ldyBTbyx0aGlzLl9saW5lPW51bGwsdGhpcy5fbGluZVB0cz1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRJbmRleD10LHRoaXMuX291dHB1dEluZGV4PWV9c3RhdGljIGlzSW5MaW5lU2VjdGlvbih0LGUsbil7aWYobi5nZXRQYXJlbnQoKSE9PXQuZ2V0UGFyZW50KCkpcmV0dXJuITE7Y29uc3Qgcz1uLmdldEluZGV4KCk7cmV0dXJuIHM+PWVbMF0mJnM8ZVsxXX1mbGF0dGVuKHQsZSl7Y29uc3Qgbj10aGlzLl9saW5lUHRzW3RdLHM9dGhpcy5fbGluZVB0c1tlXSxpPW5ldyBLdChuLHMpO3JldHVybiB0aGlzLnJlbW92ZSh0aGlzLl9saW5lLHQsZSksdGhpcy5fb3V0cHV0SW5kZXguYWRkKGkpLGl9aGFzQmFkSW50ZXJzZWN0aW9uKHQsZSxuKXtyZXR1cm4hIXRoaXMuaGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKG4pfHwhIXRoaXMuaGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnlTZWN0aW9uKHQsZSxuKXtuKz0xO2NvbnN0IHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodCsxPT09ZSl7Y29uc3QgZT10aGlzLl9saW5lLmdldFNlZ21lbnQodCk7cmV0dXJuIHRoaXMuX2xpbmUuYWRkVG9SZXN1bHQoZSksbnVsbH1sZXQgaT0hMDtpZih0aGlzLl9saW5lLmdldFJlc3VsdFNpemUoKTx0aGlzLl9saW5lLmdldE1pbmltdW1TaXplKCkpe24rMTx0aGlzLl9saW5lLmdldE1pbmltdW1TaXplKCkmJihpPSExKX1jb25zdCByPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG89dGhpcy5maW5kRnVydGhlc3RQb2ludCh0aGlzLl9saW5lUHRzLHQsZSxyKTtyWzBdPnRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlJiYoaT0hMSk7Y29uc3QgbD1uZXcgS3Q7aWYobC5wMD10aGlzLl9saW5lUHRzW3RdLGwucDE9dGhpcy5fbGluZVB0c1tlXSxzWzBdPXQsc1sxXT1lLHRoaXMuaGFzQmFkSW50ZXJzZWN0aW9uKHRoaXMuX2xpbmUscyxsKSYmKGk9ITEpLGkpe2NvbnN0IG49dGhpcy5mbGF0dGVuKHQsZSk7cmV0dXJuIHRoaXMuX2xpbmUuYWRkVG9SZXN1bHQobiksbnVsbH10aGlzLnNpbXBsaWZ5U2VjdGlvbih0LG8sbiksdGhpcy5zaW1wbGlmeVNlY3Rpb24obyxlLG4pfWhhc0JhZE91dHB1dEludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dGhpcy5fb3V0cHV0SW5kZXgucXVlcnkodCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihuLHQpKXJldHVybiEwfXJldHVybiExfWZpbmRGdXJ0aGVzdFBvaW50KHQsZSxuLHMpe2NvbnN0IGk9bmV3IEt0O2kucDA9dFtlXSxpLnAxPXRbbl07bGV0IHI9LTEsbz1lO2ZvcihsZXQgcz1lKzE7czxuO3MrKyl7Y29uc3QgZT10W3NdLG49aS5kaXN0YW5jZShlKTtuPnImJihyPW4sbz1zKX1yZXR1cm4gc1swXT1yLG99c2ltcGxpZnkodCl7dGhpcy5fbGluZT10LHRoaXMuX2xpbmVQdHM9dC5nZXRQYXJlbnRDb29yZGluYXRlcygpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5fbGluZVB0cy5sZW5ndGgtMSwwKX1yZW1vdmUodCxlLG4pe2ZvcihsZXQgcz1lO3M8bjtzKyspe2NvbnN0IGU9dC5nZXRTZWdtZW50KHMpO3RoaXMuX2lucHV0SW5kZXgucmVtb3ZlKGUpfX1oYXNJbnRlcmlvckludGVyc2VjdGlvbih0LGUpe3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQucDAsdC5wMSxlLnAwLGUucDEpLHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKX1oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil7Zm9yKGxldCBzPXRoaXMuX2lucHV0SW5kZXgucXVlcnkobikuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihpLG4pKXtpZihUby5pc0luTGluZVNlY3Rpb24odCxlLGkpKWNvbnRpbnVlO3JldHVybiEwfX1yZXR1cm4hMX19Y2xhc3MgUm97Y29uc3RydWN0b3IoKXtSby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEluZGV4PW5ldyBTbyx0aGlzLl9vdXRwdXRJbmRleD1uZXcgU28sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9MH1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5KHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuX2lucHV0SW5kZXguYWRkKGUubmV4dCgpKTtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1uZXcgVG8odGhpcy5faW5wdXRJbmRleCx0aGlzLl9vdXRwdXRJbmRleCk7dC5zZXREaXN0YW5jZVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdC5zaW1wbGlmeShlLm5leHQoKSl9fX1jbGFzcyBQb3tjb25zdHJ1Y3Rvcigpe1BvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2xpbmVTaW1wbGlmaWVyPW5ldyBSbyx0aGlzLl9saW5lc3RyaW5nTWFwPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgUG8odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfWdldFJlc3VsdEdlb21ldHJ5KCl7aWYodGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmNvcHkoKTt0aGlzLl9saW5lc3RyaW5nTWFwPW5ldyBOdCx0aGlzLl9pbnB1dEdlb20uYXBwbHkobmV3IHZvKHRoaXMpKSx0aGlzLl9saW5lU2ltcGxpZmllci5zaW1wbGlmeSh0aGlzLl9saW5lc3RyaW5nTWFwLnZhbHVlcygpKTtyZXR1cm4gbmV3IE9vKHRoaXMuX2xpbmVzdHJpbmdNYXApLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgcyhcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9saW5lU2ltcGxpZmllci5zZXREaXN0YW5jZVRvbGVyYW5jZSh0KX19Y2xhc3MgT28gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksT28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZXN0cmluZ01hcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVzdHJpbmdNYXA9dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2lmKDA9PT10LnNpemUoKSlyZXR1cm4gbnVsbDtpZihlIGluc3RhbmNlb2YgJCl7Y29uc3QgdD10aGlzLl9saW5lc3RyaW5nTWFwLmdldChlKTtyZXR1cm4gdGhpcy5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UodC5nZXRSZXN1bHRDb29yZGluYXRlcygpKX1yZXR1cm4gc3VwZXIudHJhbnNmb3JtQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQsZSl9fWNsYXNzIHZve2NvbnN0cnVjdG9yKCl7dm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy50cHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRwcz10fWZpbHRlcih0KXtpZih0IGluc3RhbmNlb2YgJCl7Y29uc3QgZT10O2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49ZS5pc0Nsb3NlZCgpPzQ6MixzPW5ldyBDbyhlLG4pO3RoaXMudHBzLl9saW5lc3RyaW5nTWFwLnB1dChlLHMpfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119fVBvLkxpbmVTdHJpbmdUcmFuc2Zvcm1lcj1PbyxQby5MaW5lU3RyaW5nTWFwQnVpbGRlckZpbHRlcj12bztjbGFzcyBib3tjb25zdHJ1Y3Rvcigpe2JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX3RvbGVyYW5jZT1lKmV9c3RhdGljIHNpbXBsaWZ5KHQsZSl7cmV0dXJuIG5ldyBibyh0LGUpLnNpbXBsaWZ5KCl9c2ltcGxpZnlWZXJ0ZXgodCl7bGV0IGU9dCxuPWUuZ2V0QXJlYSgpLHM9bnVsbDtmb3IoO251bGwhPT1lOyl7Y29uc3QgdD1lLmdldEFyZWEoKTt0PG4mJihuPXQscz1lKSxlPWUuX25leHR9cmV0dXJuIG51bGwhPT1zJiZuPHRoaXMuX3RvbGVyYW5jZSYmcy5yZW1vdmUoKSx0LmlzTGl2ZSgpP246LTF9c2ltcGxpZnkoKXtjb25zdCB0PU1vLmJ1aWxkTGluZSh0aGlzLl9wdHMpO2xldCBlPXRoaXMuX3RvbGVyYW5jZTtkb3tlPXRoaXMuc2ltcGxpZnlWZXJ0ZXgodCl9d2hpbGUoZTx0aGlzLl90b2xlcmFuY2UpO2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBuLmxlbmd0aDwyP1tuWzBdLG5ldyBtKG5bMF0pXTpufX1jbGFzcyBNb3tjb25zdHJ1Y3Rvcigpe01vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0PW51bGwsdGhpcy5fcHJldj1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9hcmVhPU1vLk1BWF9BUkVBLHRoaXMuX2lzTGl2ZT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdD10fXN0YXRpYyBidWlsZExpbmUodCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IGk9bmV3IE1vKHRbc10pO251bGw9PT1lJiYoZT1pKSxpLnNldFByZXYobiksbnVsbCE9PW4mJihuLnNldE5leHQoaSksbi51cGRhdGVBcmVhKCkpLG49aX1yZXR1cm4gZX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IFI7bGV0IGU9dGhpcztkb3t0LmFkZChlLl9wdCwhMSksZT1lLl9uZXh0fXdoaWxlKG51bGwhPT1lKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldEFyZWEoKXtyZXR1cm4gdGhpcy5fYXJlYX11cGRhdGVBcmVhKCl7aWYobnVsbD09PXRoaXMuX3ByZXZ8fG51bGw9PT10aGlzLl9uZXh0KXJldHVybiB0aGlzLl9hcmVhPU1vLk1BWF9BUkVBLG51bGw7dGhpcy5fYXJlYT1NYXRoLmFicyhuZS5hcmVhKHRoaXMuX3ByZXYuX3B0LHRoaXMuX3B0LHRoaXMuX25leHQuX3B0KSl9cmVtb3ZlKCl7Y29uc3QgdD10aGlzLl9wcmV2LGU9dGhpcy5fbmV4dDtsZXQgbj1udWxsO3JldHVybiBudWxsIT09dGhpcy5fcHJldiYmKHRoaXMuX3ByZXYuc2V0TmV4dChlKSx0aGlzLl9wcmV2LnVwZGF0ZUFyZWEoKSxuPXRoaXMuX3ByZXYpLG51bGwhPT10aGlzLl9uZXh0JiYodGhpcy5fbmV4dC5zZXRQcmV2KHQpLHRoaXMuX25leHQudXBkYXRlQXJlYSgpLG51bGw9PT1uJiYobj10aGlzLl9uZXh0KSksdGhpcy5faXNMaXZlPSExLG59aXNMaXZlKCl7cmV0dXJuIHRoaXMuX2lzTGl2ZX1zZXRQcmV2KHQpe3RoaXMuX3ByZXY9dH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH19TW8uTUFYX0FSRUE9ci5NQVhfVkFMVUUsYm8uVldWZXJ0ZXg9TW87Y2xhc3MgRG97Y29uc3RydWN0b3IoKXtEby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBEbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9c2V0RW5zdXJlVmFsaWQodCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLl9pbnB1dEdlb20uY29weSgpOm5ldyBBbyh0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgcyhcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fX1jbGFzcyBBbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxBby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITAsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1lfXRyYW5zZm9ybVBvbHlnb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiB5dD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1udWxsO3JldHVybiBzPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpiby5zaW1wbGlmeShuLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPWUgaW5zdGFuY2VvZiBydCxzPXN1cGVyLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fHMgaW5zdGFuY2VvZiBndD9zOm51bGx9fURvLlZXVHJhbnNmb3JtZXI9QW87dmFyIEZvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERvdWdsYXNQZXVja2VyU2ltcGxpZmllcjpJbyxUb3BvbG9neVByZXNlcnZpbmdTaW1wbGlmaWVyOlBvLFZXU2ltcGxpZmllcjpEb30pO2NsYXNzIEdve2NvbnN0cnVjdG9yKCl7R28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2VnPW51bGwsdGhpcy5fc2VnTGVuPW51bGwsdGhpcy5fc3BsaXRQdD1udWxsLHRoaXMuX21pbmltdW1MZW49MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWc9dCx0aGlzLl9zZWdMZW49dC5nZXRMZW5ndGgoKX1zdGF0aWMgcG9pbnRBbG9uZ1JldmVyc2UodCxlKXtjb25zdCBuPW5ldyBtO3JldHVybiBuLng9dC5wMS54LWUqKHQucDEueC10LnAwLngpLG4ueT10LnAxLnktZSoodC5wMS55LXQucDAueSksbn1zcGxpdEF0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fbWluaW11bUxlbi90aGlzLl9zZWdMZW47aWYodC5kaXN0YW5jZSh0aGlzLl9zZWcucDApPHRoaXMuX21pbmltdW1MZW4pcmV0dXJuIHRoaXMuX3NwbGl0UHQ9dGhpcy5fc2VnLnBvaW50QWxvbmcoZSksbnVsbDtpZih0LmRpc3RhbmNlKHRoaXMuX3NlZy5wMSk8dGhpcy5fbWluaW11bUxlbilyZXR1cm4gdGhpcy5fc3BsaXRQdD1Hby5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLl9zZWcsZSksbnVsbDt0aGlzLl9zcGxpdFB0PXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLmdldENvbnN0cmFpbmVkTGVuZ3RoKHQpL3RoaXMuX3NlZ0xlbjtlLmVxdWFsczJEKHRoaXMuX3NlZy5wMCk/dGhpcy5fc3BsaXRQdD10aGlzLl9zZWcucG9pbnRBbG9uZyhuKTp0aGlzLl9zcGxpdFB0PUdvLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuX3NlZyxuKX19c2V0TWluaW11bUxlbmd0aCh0KXt0aGlzLl9taW5pbXVtTGVuPXR9Z2V0Q29uc3RyYWluZWRMZW5ndGgodCl7cmV0dXJuIHQ8dGhpcy5fbWluaW11bUxlbj90aGlzLl9taW5pbXVtTGVuOnR9Z2V0U3BsaXRQb2ludCgpe3JldHVybiB0aGlzLl9zcGxpdFB0fX1jbGFzcyBxb3tmaW5kU3BsaXRQb2ludCh0LGUpe319Y2xhc3MgQm97c3RhdGljIHByb2plY3RlZFNwbGl0UG9pbnQodCxlKXtyZXR1cm4gdC5nZXRMaW5lU2VnbWVudCgpLnByb2plY3QoZSl9ZmluZFNwbGl0UG9pbnQodCxlKXtjb25zdCBuPXQuZ2V0TGluZVNlZ21lbnQoKSxzPW4uZ2V0TGVuZ3RoKCkvMixpPW5ldyBHbyhuKSxyPUJvLnByb2plY3RlZFNwbGl0UG9pbnQodCxlKTtsZXQgbz0yKnIuZGlzdGFuY2UoZSkqLjg7cmV0dXJuIG8+cyYmKG89cyksaS5zZXRNaW5pbXVtTGVuZ3RoKG8pLGkuc3BsaXRBdChyKSxpLmdldFNwbGl0UG9pbnQoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcW9dfX1jbGFzcyBZb3tzdGF0aWMgdHJpQXJlYSh0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0oZS55LXQueSkqKG4ueC10LngpfXN0YXRpYyBpc0luQ2lyY2xlREROb3JtYWxpemVkKHQsZSxuLHMpe2NvbnN0IGk9QS52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KHMueCkscj1BLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qocy55KSxvPUEudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdChzLngpLGw9QS52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHMueSksYT1BLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3Qocy54KSxjPUEudmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdChzLnkpLGg9aS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoby5tdWx0aXBseShyKSksdT1vLm11bHRpcGx5KGMpLnNlbGZTdWJ0cmFjdChhLm11bHRpcGx5KGwpKSxnPWEubXVsdGlwbHkocikuc2VsZlN1YnRyYWN0KGkubXVsdGlwbHkoYykpLGQ9aS5tdWx0aXBseShpKS5zZWxmQWRkKHIubXVsdGlwbHkocikpLF89by5tdWx0aXBseShvKS5zZWxmQWRkKGwubXVsdGlwbHkobCkpLHA9YS5tdWx0aXBseShhKS5zZWxmQWRkKGMubXVsdGlwbHkoYykpO3JldHVybiBkLnNlbGZNdWx0aXBseSh1KS5zZWxmQWRkKF8uc2VsZk11bHRpcGx5KGcpKS5zZWxmQWRkKHAuc2VsZk11bHRpcGx5KGgpKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGNoZWNrUm9idXN0SW5DaXJjbGUodCxlLG4scyl7Y29uc3QgaT1Zby5pc0luQ2lyY2xlTm9uUm9idXN0KHQsZSxuLHMpLHI9WW8uaXNJbkNpcmNsZUREU2xvdyh0LGUsbixzKSxvPVlvLmlzSW5DaXJjbGVDQyh0LGUsbixzKSxsPW5lLmNpcmN1bWNlbnRyZSh0LGUsbik7WS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCktdC5kaXN0YW5jZShsKSkvdC5kaXN0YW5jZShsKSksaT09PXImJmk9PT1vfHwoWS5vdXQucHJpbnRsbihcImluQ2lyY2xlIHJvYnVzdG5lc3MgZmFpbHVyZSAoZG91YmxlIHJlc3VsdCA9IFwiK2krXCIsIEREIHJlc3VsdCA9IFwiK3IrXCIsIENDIHJlc3VsdCA9IFwiK28rXCIpXCIpLFkub3V0LnByaW50bG4oV3QudG9MaW5lU3RyaW5nKG5ldyBtdChbdCxlLG4sc10pKSksWS5vdXQucHJpbnRsbihcIkNpcmN1bWNlbnRyZSA9IFwiK1d0LnRvUG9pbnQobCkrXCIgcmFkaXVzID0gXCIrdC5kaXN0YW5jZShsKSksWS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvdC5kaXN0YW5jZShsKS0xKSksWS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYiA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvZS5kaXN0YW5jZShsKS0xKSksWS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYyA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvbi5kaXN0YW5jZShsKS0xKSksWS5vdXQucHJpbnRsbigpKX1zdGF0aWMgaXNJbkNpcmNsZURERmFzdCh0LGUsbixzKXtjb25zdCBpPUEuc3FyKHQueCkuc2VsZkFkZChBLnNxcih0LnkpKS5zZWxmTXVsdGlwbHkoWW8udHJpQXJlYURERmFzdChlLG4scykpLHI9QS5zcXIoZS54KS5zZWxmQWRkKEEuc3FyKGUueSkpLnNlbGZNdWx0aXBseShZby50cmlBcmVhRERGYXN0KHQsbixzKSksbz1BLnNxcihuLngpLnNlbGZBZGQoQS5zcXIobi55KSkuc2VsZk11bHRpcGx5KFlvLnRyaUFyZWFEREZhc3QodCxlLHMpKSxsPUEuc3FyKHMueCkuc2VsZkFkZChBLnNxcihzLnkpKS5zZWxmTXVsdGlwbHkoWW8udHJpQXJlYURERmFzdCh0LGUsbikpO3JldHVybiBpLnNlbGZTdWJ0cmFjdChyKS5zZWxmQWRkKG8pLnNlbGZTdWJ0cmFjdChsKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGlzSW5DaXJjbGVDQyh0LGUsbixzKXtjb25zdCBpPW5lLmNpcmN1bWNlbnRyZSh0LGUsbikscj10LmRpc3RhbmNlKGkpO3JldHVybiBzLmRpc3RhbmNlKGkpLXI8PTB9c3RhdGljIGlzSW5DaXJjbGVOb3JtYWxpemVkKHQsZSxuLHMpe2NvbnN0IGk9dC54LXMueCxyPXQueS1zLnksbz1lLngtcy54LGw9ZS55LXMueSxhPW4ueC1zLngsYz1uLnktcy55O3JldHVybihpKmkrcipyKSoobypjLWEqbCkrKG8qbytsKmwpKihhKnItaSpjKSsoYSphK2MqYykqKGkqbC1vKnIpPjB9c3RhdGljIGlzSW5DaXJjbGVERFNsb3codCxlLG4scyl7Y29uc3QgaT1BLnZhbHVlT2Yocy54KSxyPUEudmFsdWVPZihzLnkpLG89QS52YWx1ZU9mKHQueCksbD1BLnZhbHVlT2YodC55KSxhPUEudmFsdWVPZihlLngpLGM9QS52YWx1ZU9mKGUueSksaD1BLnZhbHVlT2Yobi54KSx1PUEudmFsdWVPZihuLnkpLGc9by5tdWx0aXBseShvKS5hZGQobC5tdWx0aXBseShsKSkubXVsdGlwbHkoWW8udHJpQXJlYUREU2xvdyhhLGMsaCx1LGkscikpLGQ9YS5tdWx0aXBseShhKS5hZGQoYy5tdWx0aXBseShjKSkubXVsdGlwbHkoWW8udHJpQXJlYUREU2xvdyhvLGwsaCx1LGkscikpLF89aC5tdWx0aXBseShoKS5hZGQodS5tdWx0aXBseSh1KSkubXVsdGlwbHkoWW8udHJpQXJlYUREU2xvdyhvLGwsYSxjLGkscikpLHA9aS5tdWx0aXBseShpKS5hZGQoci5tdWx0aXBseShyKSkubXVsdGlwbHkoWW8udHJpQXJlYUREU2xvdyhvLGwsYSxjLGgsdSkpO3JldHVybiBnLnN1YnRyYWN0KGQpLmFkZChfKS5zdWJ0cmFjdChwKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4scyl7cmV0dXJuKHQueCp0LngrdC55KnQueSkqWW8udHJpQXJlYShlLG4scyktKGUueCplLngrZS55KmUueSkqWW8udHJpQXJlYSh0LG4scykrKG4ueCpuLngrbi55Km4ueSkqWW8udHJpQXJlYSh0LGUscyktKHMueCpzLngrcy55KnMueSkqWW8udHJpQXJlYSh0LGUsbik+MH1zdGF0aWMgaXNJbkNpcmNsZVJvYnVzdCh0LGUsbixzKXtyZXR1cm4gWW8uaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4scyl9c3RhdGljIHRyaUFyZWFERFNsb3codCxlLG4scyxpLHIpe3JldHVybiBuLnN1YnRyYWN0KHQpLm11bHRpcGx5KHIuc3VidHJhY3QoZSkpLnN1YnRyYWN0KHMuc3VidHJhY3QoZSkubXVsdGlwbHkoaS5zdWJ0cmFjdCh0KSkpfXN0YXRpYyB0cmlBcmVhRERGYXN0KHQsZSxuKXtjb25zdCBzPUEudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShBLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3QodC55KSksaT1BLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KS5zZWxmTXVsdGlwbHkoQS52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KHQueCkpO3JldHVybiBzLnNlbGZTdWJ0cmFjdChpKX19Y2xhc3MgVm97Y29uc3RydWN0b3IoKXtWby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3A9bmV3IG0odCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD1uZXcgbSh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3A9bmV3IG0odCxlLG4pfX1zdGF0aWMgaW50ZXJwb2xhdGVaKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5kaXN0YW5jZShuKSxpPXQuZGlzdGFuY2UoZSkscj1uLmdldFooKS1lLmdldFooKTtyZXR1cm4gZS5nZXRaKCkrciooaS9zKX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1lLngscj1lLnksbz1uLngtaSxsPXMueC1pLGE9bi55LXIsYz1zLnktcixoPW8qYy1sKmEsdT10LngtaSxnPXQueS1yLGQ9KGMqdS1sKmcpL2gsXz0oLWEqdStvKmcpL2g7cmV0dXJuIGUuZ2V0WigpK2QqKG4uZ2V0WigpLWUuZ2V0WigpKStfKihzLmdldFooKS1lLmdldFooKSl9fWNpcmNsZUNlbnRlcih0LGUpe2NvbnN0IG49bmV3IFZvKHRoaXMuZ2V0WCgpLHRoaXMuZ2V0WSgpKSxzPXRoaXMuYmlzZWN0b3Iobix0KSxpPXRoaXMuYmlzZWN0b3IodCxlKSxyPW5ldyBlZShzLGkpO2xldCBvPW51bGw7dHJ5e289bmV3IFZvKHIuZ2V0WCgpLHIuZ2V0WSgpKX1jYXRjaChzKXtpZighKHMgaW5zdGFuY2VvZiB0ZSkpdGhyb3cgcztZLmVyci5wcmludGxuKFwiYTogXCIrbitcIiAgYjogXCIrdCtcIiAgYzogXCIrZSksWS5lcnIucHJpbnRsbihzKX1yZXR1cm4gb31kb3QodCl7cmV0dXJuIHRoaXMuX3AueCp0LmdldFgoKSt0aGlzLl9wLnkqdC5nZXRZKCl9bWFnbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy5fcC54KnRoaXMuX3AueCt0aGlzLl9wLnkqdGhpcy5fcC55KX1nZXRaKCl7cmV0dXJuIHRoaXMuX3AuZ2V0WigpfWJpc2VjdG9yKHQsZSl7Y29uc3Qgbj1lLmdldFgoKS10LmdldFgoKSxzPWUuZ2V0WSgpLXQuZ2V0WSgpLGk9bmV3IGVlKHQuZ2V0WCgpK24vMix0LmdldFkoKStzLzIsMSkscj1uZXcgZWUodC5nZXRYKCktcytuLzIsdC5nZXRZKCkrbitzLzIsMSk7cmV0dXJuIG5ldyBlZShpLHIpfWVxdWFscygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fcC54PT09dC5nZXRYKCkmJnRoaXMuX3AueT09PXQuZ2V0WSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fcC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSk8ZX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wfWlzSW5DaXJjbGUodCxlLG4pe3JldHVybiBZby5pc0luQ2lyY2xlUm9idXN0KHQuX3AsZS5fcCxuLl9wLHRoaXMuX3ApfWludGVycG9sYXRlWlZhbHVlKHQsZSxuKXtjb25zdCBzPXQuZ2V0WCgpLGk9dC5nZXRZKCkscj1lLmdldFgoKS1zLG89bi5nZXRYKCktcyxsPWUuZ2V0WSgpLWksYT1uLmdldFkoKS1pLGM9ciphLW8qbCxoPXRoaXMuZ2V0WCgpLXMsdT10aGlzLmdldFkoKS1pLGc9KGEqaC1vKnUpL2MsZD0oLWwqaCtyKnUpL2M7cmV0dXJuIHQuZ2V0WigpK2cqKGUuZ2V0WigpLXQuZ2V0WigpKStkKihuLmdldFooKS10LmdldFooKSl9bWlkUG9pbnQodCl7Y29uc3QgZT0odGhpcy5fcC54K3QuZ2V0WCgpKS8yLG49KHRoaXMuX3AueSt0LmdldFkoKSkvMixzPSh0aGlzLl9wLmdldFooKSt0LmdldFooKSkvMjtyZXR1cm4gbmV3IFZvKGUsbixzKX1yaWdodE9mKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQuZGVzdCgpLHQub3JpZygpKX1pc0NDVyh0LGUpe3JldHVybih0Ll9wLngtdGhpcy5fcC54KSooZS5fcC55LXRoaXMuX3AueSktKHQuX3AueS10aGlzLl9wLnkpKihlLl9wLngtdGhpcy5fcC54KT4wfWdldFgoKXtyZXR1cm4gdGhpcy5fcC54fWNyb3NzUHJvZHVjdCh0KXtyZXR1cm4gdGhpcy5fcC54KnQuZ2V0WSgpLXRoaXMuX3AueSp0LmdldFgoKX1zZXRaKHQpe3RoaXMuX3Auc2V0Wih0KX10aW1lcyh0KXtyZXR1cm4gbmV3IFZvKHQqdGhpcy5fcC54LHQqdGhpcy5fcC55KX1jcm9zcygpe3JldHVybiBuZXcgVm8odGhpcy5fcC55LC10aGlzLl9wLngpfWxlZnRPZih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0Lm9yaWcoKSx0LmRlc3QoKSl9dG9TdHJpbmcoKXtyZXR1cm5cIlBPSU5UIChcIit0aGlzLl9wLngrXCIgXCIrdGhpcy5fcC55K1wiKVwifXN1Yih0KXtyZXR1cm4gbmV3IFZvKHRoaXMuX3AueC10LmdldFgoKSx0aGlzLl9wLnktdC5nZXRZKCkpfWdldFkoKXtyZXR1cm4gdGhpcy5fcC55fWNsYXNzaWZ5KHQsZSl7Y29uc3Qgbj10aGlzLHM9ZS5zdWIodCksaT1uLnN1Yih0KSxyPXMuY3Jvc3NQcm9kdWN0KGkpO3JldHVybiByPjA/Vm8uTEVGVDpyPDA/Vm8uUklHSFQ6cy5nZXRYKCkqaS5nZXRYKCk8MHx8cy5nZXRZKCkqaS5nZXRZKCk8MD9Wby5CRUhJTkQ6cy5tYWduKCk8aS5tYWduKCk/Vm8uQkVZT05EOnQuZXF1YWxzKG4pP1ZvLk9SSUdJTjplLmVxdWFscyhuKT9Wby5ERVNUSU5BVElPTjpWby5CRVRXRUVOfXN1bSh0KXtyZXR1cm4gbmV3IFZvKHRoaXMuX3AueCt0LmdldFgoKSx0aGlzLl9wLnkrdC5nZXRZKCkpfWRpc3RhbmNlKHQsZSl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlLmdldFgoKS10LmdldFgoKSwyKStNYXRoLnBvdyhlLmdldFkoKS10LmdldFkoKSwyKSl9Y2lyY3VtUmFkaXVzUmF0aW8odCxlKXtjb25zdCBuPXRoaXMuY2lyY2xlQ2VudGVyKHQsZSkscz10aGlzLmRpc3RhbmNlKG4sdCk7bGV0IGk9dGhpcy5kaXN0YW5jZSh0aGlzLHQpLHI9dGhpcy5kaXN0YW5jZSh0LGUpO3JldHVybiByPGkmJihpPXIpLHI9dGhpcy5kaXN0YW5jZShlLHRoaXMpLHI8aSYmKGk9cikscy9pfX1Wby5MRUZUPTAsVm8uUklHSFQ9MSxWby5CRVlPTkQ9MixWby5CRUhJTkQ9MyxWby5CRVRXRUVOPTQsVm8uT1JJR0lOPTUsVm8uREVTVElOQVRJT049NjtjbGFzcyB6byBleHRlbmRzIFZve2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx6by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc09uQ29uc3RyYWludD1udWxsLHRoaXMuX2NvbnN0cmFpbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTtWby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWdldENvbnN0cmFpbnQoKXtyZXR1cm4gdGhpcy5fY29uc3RyYWludH1zZXRPbkNvbnN0cmFpbnQodCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9dH1tZXJnZSh0KXt0Ll9pc09uQ29uc3RyYWludCYmKHRoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuX2NvbnN0cmFpbnQ9dC5fY29uc3RyYWludCl9aXNPbkNvbnN0cmFpbnQoKXtyZXR1cm4gdGhpcy5faXNPbkNvbnN0cmFpbnR9c2V0Q29uc3RyYWludCh0KXt0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLl9jb25zdHJhaW50PXR9fWNsYXNzIFhve2NvbnN0cnVjdG9yKCl7WG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcm90PW51bGwsdGhpcy5fdmVydGV4PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1zdGF0aWMgbWFrZUVkZ2UodCxlKXtjb25zdCBuPW5ldyBYbyxzPW5ldyBYbyxpPW5ldyBYbyxyPW5ldyBYbztuLl9yb3Q9cyxzLl9yb3Q9aSxpLl9yb3Q9cixyLl9yb3Q9bixuLnNldE5leHQobikscy5zZXROZXh0KHIpLGkuc2V0TmV4dChpKSxyLnNldE5leHQocyk7Y29uc3Qgbz1uO3JldHVybiBvLnNldE9yaWcodCksby5zZXREZXN0KGUpLG99c3RhdGljIHN3YXAodCl7Y29uc3QgZT10Lm9QcmV2KCksbj10LnN5bSgpLm9QcmV2KCk7WG8uc3BsaWNlKHQsZSksWG8uc3BsaWNlKHQuc3ltKCksbiksWG8uc3BsaWNlKHQsZS5sTmV4dCgpKSxYby5zcGxpY2UodC5zeW0oKSxuLmxOZXh0KCkpLHQuc2V0T3JpZyhlLmRlc3QoKSksdC5zZXREZXN0KG4uZGVzdCgpKX1zdGF0aWMgc3BsaWNlKHQsZSl7Y29uc3Qgbj10Lm9OZXh0KCkucm90KCkscz1lLm9OZXh0KCkucm90KCksaT1lLm9OZXh0KCkscj10Lm9OZXh0KCksbz1zLm9OZXh0KCksbD1uLm9OZXh0KCk7dC5zZXROZXh0KGkpLGUuc2V0TmV4dChyKSxuLnNldE5leHQobykscy5zZXROZXh0KGwpfXN0YXRpYyBjb25uZWN0KHQsZSl7Y29uc3Qgbj1Yby5tYWtlRWRnZSh0LmRlc3QoKSxlLm9yaWcoKSk7cmV0dXJuIFhvLnNwbGljZShuLHQubE5leHQoKSksWG8uc3BsaWNlKG4uc3ltKCksZSksbn1lcXVhbHNOb25PcmllbnRlZCh0KXtyZXR1cm4hIXRoaXMuZXF1YWxzT3JpZW50ZWQodCl8fCEhdGhpcy5lcXVhbHNPcmllbnRlZCh0LnN5bSgpKX10b0xpbmVTZWdtZW50KCl7cmV0dXJuIG5ldyBLdCh0aGlzLl92ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9ZGVzdCgpe3JldHVybiB0aGlzLnN5bSgpLm9yaWcoKX1vTmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fWVxdWFsc09yaWVudGVkKHQpe3JldHVybiEoIXRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCkpfHwhdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSkpfWROZXh0KCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKS5zeW0oKX1sUHJldigpe3JldHVybiB0aGlzLl9uZXh0LnN5bSgpfXJQcmV2KCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKX1yb3QoKXtyZXR1cm4gdGhpcy5fcm90fW9QcmV2KCl7cmV0dXJuIHRoaXMuX3JvdC5fbmV4dC5fcm90fXN5bSgpe3JldHVybiB0aGlzLl9yb3QuX3JvdH1zZXRPcmlnKHQpe3RoaXMuX3ZlcnRleD10fWxOZXh0KCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5yb3QoKX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9aW52Um90KCl7cmV0dXJuIHRoaXMuX3JvdC5zeW0oKX1zZXREZXN0KHQpe3RoaXMuc3ltKCkuc2V0T3JpZyh0KX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9ZGVsZXRlKCl7dGhpcy5fcm90PW51bGx9b3JpZygpe3JldHVybiB0aGlzLl92ZXJ0ZXh9ck5leHQoKXtyZXR1cm4gdGhpcy5fcm90Ll9uZXh0LmludlJvdCgpfXRvU3RyaW5nKCl7Y29uc3QgdD10aGlzLl92ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLGU9dGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpO3JldHVybiBXdC50b0xpbmVTdHJpbmcodCxlKX1pc0xpdmUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3JvdH1nZXRQcmltYXJ5KCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTw9MD90aGlzOnRoaXMuc3ltKCl9ZFByZXYoKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLmludlJvdCgpfXNldE5leHQodCl7dGhpcy5fbmV4dD10fX1jbGFzcyBrb3tjb25zdHJ1Y3Rvcigpe2tvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2lzVXNpbmdUb2xlcmFuY2U9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZGl2PXQsdGhpcy5faXNVc2luZ1RvbGVyYW5jZT10LmdldFRvbGVyYW5jZSgpPjB9aW5zZXJ0U2l0ZSh0KXtsZXQgZT10aGlzLl9zdWJkaXYubG9jYXRlKHQpO2lmKHRoaXMuX3N1YmRpdi5pc1ZlcnRleE9mRWRnZShlLHQpKXJldHVybiBlO3RoaXMuX3N1YmRpdi5pc09uRWRnZShlLHQuZ2V0Q29vcmRpbmF0ZSgpKSYmKGU9ZS5vUHJldigpLHRoaXMuX3N1YmRpdi5kZWxldGUoZS5vTmV4dCgpKSk7bGV0IG49dGhpcy5fc3ViZGl2Lm1ha2VFZGdlKGUub3JpZygpLHQpO1hvLnNwbGljZShuLGUpO2NvbnN0IHM9bjtkb3tuPXRoaXMuX3N1YmRpdi5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCl9d2hpbGUoZS5sTmV4dCgpIT09cyk7Zm9yKDs7KXtjb25zdCBpPWUub1ByZXYoKTtpZihpLmRlc3QoKS5yaWdodE9mKGUpJiZ0LmlzSW5DaXJjbGUoZS5vcmlnKCksaS5kZXN0KCksZS5kZXN0KCkpKVhvLnN3YXAoZSksZT1lLm9QcmV2KCk7ZWxzZXtpZihlLm9OZXh0KCk9PT1zKXJldHVybiBuO2U9ZS5vTmV4dCgpLmxQcmV2KCl9fX1pbnNlcnRTaXRlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUodCl9fX1jbGFzcyBVb3tsb2NhdGUodCl7fX1jbGFzcyBIb3tjb25zdHJ1Y3Rvcigpe0hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2xhc3RFZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZGl2PXQsdGhpcy5pbml0KCl9aW5pdCgpe3RoaXMuX2xhc3RFZGdlPXRoaXMuZmluZEVkZ2UoKX1sb2NhdGUodCl7dGhpcy5fbGFzdEVkZ2UuaXNMaXZlKCl8fHRoaXMuaW5pdCgpO2NvbnN0IGU9dGhpcy5fc3ViZGl2LmxvY2F0ZUZyb21FZGdlKHQsdGhpcy5fbGFzdEVkZ2UpO3JldHVybiB0aGlzLl9sYXN0RWRnZT1lLGV9ZmluZEVkZ2UoKXtyZXR1cm4gdGhpcy5fc3ViZGl2LmdldEVkZ2VzKCkuaXRlcmF0b3IoKS5uZXh0KCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1VvXX19Y2xhc3MgV28gZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxXby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zZWc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFwiTG9jYXRlIGZhaWxlZCB0byBjb252ZXJnZSAoYXQgZWRnZTogXCIrdCtcIikuICBQb3NzaWJsZSBjYXVzZXMgaW5jbHVkZSBpbnZhbGlkIFN1YmRpdmlzaW9uIHRvcG9sb2d5IG9yIHZlcnkgY2xvc2Ugc2l0ZXNcIiksdGhpcy5fc2VnPW5ldyBLdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFdvLm1zZ1dpdGhTcGF0aWFsKHQsZSkpLHRoaXMuX3NlZz1uZXcgS3QoZSl9fXN0YXRpYyBtc2dXaXRoU3BhdGlhbCh0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrZStcIiBdXCI6dH1nZXRTZWdtZW50KCl7cmV0dXJuIHRoaXMuX3NlZ319Y2xhc3MgWm97dmlzaXQodCl7fX1jbGFzcyBqb3tjb25zdHJ1Y3Rvcigpe2pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Zpc2l0ZWRLZXk9MCx0aGlzLl9xdWFkRWRnZXM9bmV3IEwsdGhpcy5fc3RhcnRpbmdFZGdlPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGwsdGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5fZnJhbWVWZXJ0ZXg9bmV3IEFycmF5KDMpLmZpbGwobnVsbCksdGhpcy5fZnJhbWVFbnY9bnVsbCx0aGlzLl9sb2NhdG9yPW51bGwsdGhpcy5fc2VnPW5ldyBLdCx0aGlzLl90cmlFZGdlcz1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl90b2xlcmFuY2U9ZSx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9ZS9qby5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1IsdGhpcy5jcmVhdGVGcmFtZSh0KSx0aGlzLl9zdGFydGluZ0VkZ2U9dGhpcy5pbml0U3ViZGl2KCksdGhpcy5fbG9jYXRvcj1uZXcgSG8odGhpcyl9c3RhdGljIGdldFRyaWFuZ2xlRWRnZXModCxlKXtpZihlWzBdPXQsZVsxXT1lWzBdLmxOZXh0KCksZVsyXT1lWzFdLmxOZXh0KCksZVsyXS5sTmV4dCgpIT09ZVswXSl0aHJvdyBuZXcgcyhcIkVkZ2VzIGRvIG5vdCBmb3JtIGEgdHJpYW5nbGVcIil9Z2V0VHJpYW5nbGVWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBKbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcygpfWlzRnJhbWVWZXJ0ZXgodCl7cmV0dXJuISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFswXSl8fCghIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzFdKXx8ISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFsyXSkpfWlzVmVydGV4T2ZFZGdlKHQsZSl7cmV0dXJuISghZS5lcXVhbHModC5vcmlnKCksdGhpcy5fdG9sZXJhbmNlKSYmIWUuZXF1YWxzKHQuZGVzdCgpLHRoaXMuX3RvbGVyYW5jZSkpfWNvbm5lY3QodCxlKXtjb25zdCBuPVhvLmNvbm5lY3QodCxlKTtyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzLmFkZChuKSxufWdldFZvcm9ub2lDZWxsUG9seWdvbih0LGUpe2NvbnN0IG49bmV3IEwscz10O2Rve2NvbnN0IGU9dC5yb3QoKS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpO24uYWRkKGUpLHQ9dC5vUHJldigpfXdoaWxlKHQhPT1zKTtjb25zdCBpPW5ldyBSO2kuYWRkQWxsKG4sITEpLGkuY2xvc2VSaW5nKCksaS5zaXplKCk8NCYmKFkub3V0LnByaW50bG4oaSksaS5hZGQoaS5nZXQoaS5zaXplKCktMSksITApKTtjb25zdCByPWkudG9Db29yZGluYXRlQXJyYXkoKSxvPWUuY3JlYXRlUG9seWdvbihlLmNyZWF0ZUxpbmVhclJpbmcocikpLGw9cy5vcmlnKCk7cmV0dXJuIG8uc2V0VXNlckRhdGEobC5nZXRDb29yZGluYXRlKCkpLG99c2V0TG9jYXRvcih0KXt0aGlzLl9sb2NhdG9yPXR9aW5pdFN1YmRpdigpe2NvbnN0IHQ9dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFswXSx0aGlzLl9mcmFtZVZlcnRleFsxXSksZT10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzFdLHRoaXMuX2ZyYW1lVmVydGV4WzJdKTtYby5zcGxpY2UodC5zeW0oKSxlKTtjb25zdCBuPXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMl0sdGhpcy5fZnJhbWVWZXJ0ZXhbMF0pO3JldHVybiBYby5zcGxpY2UoZS5zeW0oKSxuKSxYby5zcGxpY2Uobi5zeW0oKSx0KSx0fWlzRnJhbWVCb3JkZXJFZGdlKHQpe2NvbnN0IGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7am8uZ2V0VHJpYW5nbGVFZGdlcyh0LGUpO2NvbnN0IG49bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7am8uZ2V0VHJpYW5nbGVFZGdlcyh0LnN5bSgpLG4pO2NvbnN0IHM9dC5sTmV4dCgpLmRlc3QoKTtpZih0aGlzLmlzRnJhbWVWZXJ0ZXgocykpcmV0dXJuITA7Y29uc3QgaT10LnN5bSgpLmxOZXh0KCkuZGVzdCgpO3JldHVybiEhdGhpcy5pc0ZyYW1lVmVydGV4KGkpfW1ha2VFZGdlKHQsZSl7Y29uc3Qgbj1Yby5tYWtlRWRnZSh0LGUpO3JldHVybiB0aGlzLl9xdWFkRWRnZXMuYWRkKG4pLG59dmlzaXRUcmlhbmdsZXModCxlKXt0aGlzLl92aXNpdGVkS2V5Kys7Y29uc3Qgbj1uZXcgZW47bi5wdXNoKHRoaXMuX3N0YXJ0aW5nRWRnZSk7Y29uc3Qgcz1uZXcgRXQ7Zm9yKDshbi5lbXB0eSgpOyl7Y29uc3QgaT1uLnBvcCgpO2lmKCFzLmNvbnRhaW5zKGkpKXtjb25zdCByPXRoaXMuZmV0Y2hUcmlhbmdsZVRvVmlzaXQoaSxuLGUscyk7bnVsbCE9PXImJnQudmlzaXQocil9fX1pc0ZyYW1lRWRnZSh0KXtyZXR1cm4hKCF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5vcmlnKCkpJiYhdGhpcy5pc0ZyYW1lVmVydGV4KHQuZGVzdCgpKSl9aXNPbkVkZ2UodCxlKXt0aGlzLl9zZWcuc2V0Q29vcmRpbmF0ZXModC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk7cmV0dXJuIHRoaXMuX3NlZy5kaXN0YW5jZShlKTx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2V9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gbmV3IE8odGhpcy5fZnJhbWVFbnYpfWNyZWF0ZUZyYW1lKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKTtsZXQgcz0wO3M9ZT5uPzEwKmU6MTAqbix0aGlzLl9mcmFtZVZlcnRleFswXT1uZXcgVm8oKHQuZ2V0TWF4WCgpK3QuZ2V0TWluWCgpKS8yLHQuZ2V0TWF4WSgpK3MpLHRoaXMuX2ZyYW1lVmVydGV4WzFdPW5ldyBWbyh0LmdldE1pblgoKS1zLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lVmVydGV4WzJdPW5ldyBWbyh0LmdldE1heFgoKStzLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lRW52PW5ldyBPKHRoaXMuX2ZyYW1lVmVydGV4WzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLl9mcmFtZVZlcnRleFsxXS5nZXRDb29yZGluYXRlKCkpLHRoaXMuX2ZyYW1lRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9mcmFtZVZlcnRleFsyXS5nZXRDb29yZGluYXRlKCkpfWdldFRyaWFuZ2xlQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgJG87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlcygpfWdldFZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IEV0O2ZvcihsZXQgbj10aGlzLl9xdWFkRWRnZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCksaT1zLm9yaWcoKTshdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGkpfHxlLmFkZChpKTtjb25zdCByPXMuZGVzdCgpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKHIpfXJldHVybiBlfWZldGNoVHJpYW5nbGVUb1Zpc2l0KHQsZSxuLHMpe2xldCBpPXQscj0wLG89ITE7ZG97dGhpcy5fdHJpRWRnZXNbcl09aSx0aGlzLmlzRnJhbWVFZGdlKGkpJiYobz0hMCk7Y29uc3QgdD1pLnN5bSgpO3MuY29udGFpbnModCl8fGUucHVzaCh0KSxzLmFkZChpKSxyKyssaT1pLmxOZXh0KCl9d2hpbGUoaSE9PXQpO3JldHVybiBvJiYhbj9udWxsOnRoaXMuX3RyaUVkZ2VzfWdldEVkZ2VzKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3F1YWRFZGdlcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLmdldFByaW1hcnlFZGdlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7bGV0IHM9MDtmb3IobGV0IGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgZT1pLm5leHQoKTtuW3MrK109dC5jcmVhdGVMaW5lU3RyaW5nKFtlLm9yaWcoKS5nZXRDb29yZGluYXRlKCksZS5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpXSl9cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfX1nZXRWZXJ0ZXhVbmlxdWVFZGdlcyh0KXtjb25zdCBlPW5ldyBMLG49bmV3IEV0O2ZvcihsZXQgcz10aGlzLl9xdWFkRWRnZXMuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCkscj1pLm9yaWcoKTtuLmNvbnRhaW5zKHIpfHwobi5hZGQociksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQoaSkpO2NvbnN0IG89aS5zeW0oKSxsPW8ub3JpZygpO24uY29udGFpbnMobCl8fChuLmFkZChsKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGwpfHxlLmFkZChvKSl9cmV0dXJuIGV9Z2V0VHJpYW5nbGVFZGdlcyh0KXtjb25zdCBlPW5ldyBRbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVFZGdlcygpfWdldFByaW1hcnlFZGdlcyh0KXt0aGlzLl92aXNpdGVkS2V5Kys7Y29uc3QgZT1uZXcgTCxuPW5ldyBlbjtuLnB1c2godGhpcy5fc3RhcnRpbmdFZGdlKTtjb25zdCBzPW5ldyBFdDtmb3IoOyFuLmVtcHR5KCk7KXtjb25zdCBpPW4ucG9wKCk7aWYoIXMuY29udGFpbnMoaSkpe2NvbnN0IHI9aS5nZXRQcmltYXJ5KCk7IXQmJnRoaXMuaXNGcmFtZUVkZ2Uocil8fGUuYWRkKHIpLG4ucHVzaChpLm9OZXh0KCkpLG4ucHVzaChpLnN5bSgpLm9OZXh0KCkpLHMuYWRkKGkpLHMuYWRkKGkuc3ltKCkpfX1yZXR1cm4gZX1kZWxldGUodCl7WG8uc3BsaWNlKHQsdC5vUHJldigpKSxYby5zcGxpY2UodC5zeW0oKSx0LnN5bSgpLm9QcmV2KCkpO2NvbnN0IGU9dC5zeW0oKSxuPXQucm90KCkscz10LnJvdCgpLnN5bSgpO3RoaXMuX3F1YWRFZGdlcy5yZW1vdmUodCksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShlKSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUocyksdC5kZWxldGUoKSxlLmRlbGV0ZSgpLG4uZGVsZXRlKCkscy5kZWxldGUoKX1sb2NhdGVGcm9tRWRnZSh0LGUpe2xldCBuPTA7Y29uc3Qgcz10aGlzLl9xdWFkRWRnZXMuc2l6ZSgpO2xldCBpPWU7Zm9yKDs7KXtpZihuKyssbj5zKXRocm93IG5ldyBXbyhpLnRvTGluZVNlZ21lbnQoKSk7aWYodC5lcXVhbHMoaS5vcmlnKCkpfHx0LmVxdWFscyhpLmRlc3QoKSkpYnJlYWs7aWYodC5yaWdodE9mKGkpKWk9aS5zeW0oKTtlbHNlIGlmKHQucmlnaHRPZihpLm9OZXh0KCkpKXtpZih0LnJpZ2h0T2YoaS5kUHJldigpKSlicmVhaztpPWkuZFByZXYoKX1lbHNlIGk9aS5vTmV4dCgpfXJldHVybiBpfWdldFRvbGVyYW5jZSgpe3JldHVybiB0aGlzLl90b2xlcmFuY2V9Z2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KXt0aGlzLnZpc2l0VHJpYW5nbGVzKG5ldyBLbywhMCk7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dGhpcy5nZXRWZXJ0ZXhVbmlxdWVFZGdlcyghMSkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7ZS5hZGQodGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb24ocyx0KSl9cmV0dXJuIGV9Z2V0Vm9yb25vaURpYWdyYW0odCl7Y29uc3QgZT10aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbnModCk7cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEx0LnRvR2VvbWV0cnlBcnJheShlKSl9Z2V0VHJpYW5nbGVzKHQpe2NvbnN0IGU9dGhpcy5nZXRUcmlhbmdsZUNvb3JkaW5hdGVzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZVBvbHlnb24odC5jcmVhdGVMaW5lYXJSaW5nKGUpKX1yZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9aW5zZXJ0U2l0ZSh0KXtsZXQgZT10aGlzLmxvY2F0ZSh0KTtpZih0LmVxdWFscyhlLm9yaWcoKSx0aGlzLl90b2xlcmFuY2UpfHx0LmVxdWFscyhlLmRlc3QoKSx0aGlzLl90b2xlcmFuY2UpKXJldHVybiBlO2xldCBuPXRoaXMubWFrZUVkZ2UoZS5vcmlnKCksdCk7WG8uc3BsaWNlKG4sZSk7Y29uc3Qgcz1uO2Rve249dGhpcy5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCl9d2hpbGUoZS5sTmV4dCgpIT09cyk7cmV0dXJuIHN9bG9jYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVm8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZShuZXcgVm8odCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX2xvY2F0b3IubG9jYXRlKG5ldyBWbyh0KSk7aWYobnVsbD09PW4pcmV0dXJuIG51bGw7bGV0IHM9bjtuLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodCkmJihzPW4uc3ltKCkpO2xldCBpPXM7ZG97aWYoaS5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKGUpKXJldHVybiBpO2k9aS5vTmV4dCgpfXdoaWxlKGkhPT1zKTtyZXR1cm4gbnVsbH19fWNsYXNzIEtve3Zpc2l0KHQpe2NvbnN0IGU9dFswXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLG49dFsxXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHM9dFsyXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGk9bmUuY2lyY3VtY2VudHJlREQoZSxuLHMpLHI9bmV3IFZvKGkpO2ZvcihsZXQgZT0wO2U8MztlKyspdFtlXS5yb3QoKS5zZXRPcmlnKHIpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltab119fWNsYXNzIFFve2NvbnN0cnVjdG9yKCl7UW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdHJpTGlzdD1uZXcgTH1nZXRUcmlhbmdsZUVkZ2VzKCl7cmV0dXJuIHRoaXMuX3RyaUxpc3R9dmlzaXQodCl7dGhpcy5fdHJpTGlzdC5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1pvXX19Y2xhc3MgSm97Y29uc3RydWN0b3IoKXtKby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90cmlMaXN0PW5ldyBMfXZpc2l0KHQpe3RoaXMuX3RyaUxpc3QuYWRkKFt0WzBdLm9yaWcoKSx0WzFdLm9yaWcoKSx0WzJdLm9yaWcoKV0pfWdldFRyaWFuZ2xlVmVydGljZXMoKXtyZXR1cm4gdGhpcy5fdHJpTGlzdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bWm9dfX1jbGFzcyAkb3tjb25zdHJ1Y3RvcigpeyRvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3JkTGlzdD1uZXcgUix0aGlzLl90cmlDb29yZHM9bmV3IEx9Y2hlY2tUcmlhbmdsZVNpemUodCl7dC5sZW5ndGg+PTI/V3QudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSk6dC5sZW5ndGg+PTEmJld0LnRvUG9pbnQodFswXSl9dmlzaXQodCl7dGhpcy5fY29vcmRMaXN0LmNsZWFyKCk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl7Y29uc3Qgbj10W2VdLm9yaWcoKTt0aGlzLl9jb29yZExpc3QuYWRkKG4uZ2V0Q29vcmRpbmF0ZSgpKX1pZih0aGlzLl9jb29yZExpc3Quc2l6ZSgpPjApe3RoaXMuX2Nvb3JkTGlzdC5jbG9zZVJpbmcoKTtjb25zdCB0PXRoaXMuX2Nvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2lmKDQhPT10Lmxlbmd0aClyZXR1cm4gbnVsbDt0aGlzLl90cmlDb29yZHMuYWRkKHQpfX1nZXRUcmlhbmdsZXMoKXtyZXR1cm4gdGhpcy5fdHJpQ29vcmRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltab119fWpvLlRyaWFuZ2xlQ2lyY3VtY2VudHJlVmlzaXRvcj1Lbyxqby5UcmlhbmdsZUVkZ2VzTGlzdFZpc2l0b3I9UW8sam8uVHJpYW5nbGVWZXJ0ZXhMaXN0VmlzaXRvcj1Kbyxqby5UcmlhbmdsZUNvb3JkaW5hdGVzVmlzaXRvcj0kbyxqby5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1I9MWUzO2NsYXNzIHRse2NvbnN0cnVjdG9yKCl7dGwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbHM9bnVsbCx0aGlzLl9kYXRhPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2xzPW5ldyBLdCh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2xzPW5ldyBLdCh0LGUpLHRoaXMuX2RhdGE9bn1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0bC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBtKHQsZSxuKSxuZXcgbShzLGkscikpfWVsc2UgaWYoNz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdLG89YXJndW1lbnRzWzZdO3RsLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IG0odCxlLG4pLG5ldyBtKHMsaSxyKSxvKX19Z2V0TGluZVNlZ21lbnQoKXtyZXR1cm4gdGhpcy5fbHN9Z2V0RW5kWigpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLmdldFooKX1nZXRTdGFydFooKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS5nZXRaKCl9aW50ZXJzZWN0aW9uKHQpe3JldHVybiB0aGlzLl9scy5pbnRlcnNlY3Rpb24odC5nZXRMaW5lU2VnbWVudCgpKX1nZXRTdGFydCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApfWdldEVuZCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpfWdldEVuZFkoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKS55fWdldFN0YXJ0WCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApLnh9ZXF1YWxzVG9wbyh0KXtyZXR1cm4gdGhpcy5fbHMuZXF1YWxzVG9wbyh0LmdldExpbmVTZWdtZW50KCkpfWdldFN0YXJ0WSgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApLnl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWdldEVuZFgoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKS54fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX2xzLnRvU3RyaW5nKCl9fWNsYXNzIGVsIGV4dGVuZHMgaHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcHQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyxlbC5tc2dXaXRoQ29vcmQodCxlKSksdGhpcy5fcHQ9bmV3IG0oZSl9fXN0YXRpYyBtc2dXaXRoQ29vcmQodCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK1d0LnRvUG9pbnQoZSkrXCIgXVwiOnR9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH19Y2xhc3Mgbmx7Y29uc3RydWN0b3IoKXtubC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbml0aWFsVmVydGljZXM9bnVsbCx0aGlzLl9zZWdWZXJ0aWNlcz1udWxsLHRoaXMuX3NlZ21lbnRzPW5ldyBMLHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2luY0RlbD1udWxsLHRoaXMuX2NvbnZleEh1bGw9bnVsbCx0aGlzLl9zcGxpdEZpbmRlcj1uZXcgQm8sdGhpcy5fa2R0PW51bGwsdGhpcy5fdmVydGV4RmFjdG9yeT1udWxsLHRoaXMuX2NvbXB1dGVBcmVhRW52PW51bGwsdGhpcy5fc3BsaXRQdD1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2luaXRpYWxWZXJ0aWNlcz1uZXcgTCh0KSx0aGlzLl90b2xlcmFuY2U9ZSx0aGlzLl9rZHQ9bmV3IGdzKGUpfXN0YXRpYyBjb21wdXRlVmVydGV4RW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTztmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZSh0LmdldENvb3JkaW5hdGUoKSl9cmV0dXJuIGV9Z2V0SW5pdGlhbFZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX2luaXRpYWxWZXJ0aWNlc31nZXRLRFQoKXtyZXR1cm4gdGhpcy5fa2R0fWVuZm9yY2VDb25zdHJhaW50cygpe3RoaXMuYWRkQ29uc3RyYWludFZlcnRpY2VzKCk7bGV0IHQ9MCxlPTA7ZG97ZT10aGlzLmVuZm9yY2VHYWJyaWVsKHRoaXMuX3NlZ21lbnRzKSx0Kyt9d2hpbGUoZT4wJiZ0PG5sLk1BWF9TUExJVF9JVEVSKTtpZih0PT09bmwuTUFYX1NQTElUX0lURVIpdGhyb3cgbmV3IGVsKFwiVG9vIG1hbnkgc3BsaXR0aW5nIGl0ZXJhdGlvbnMgd2hpbGUgZW5mb3JjaW5nIGNvbnN0cmFpbnRzLiAgTGFzdCBzcGxpdCBwb2ludCB3YXMgYXQ6IFwiLHRoaXMuX3NwbGl0UHQpfWluc2VydFNpdGVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZSh0KX19Z2V0VmVydGV4RmFjdG9yeSgpe3JldHVybiB0aGlzLl92ZXJ0ZXhGYWN0b3J5fWdldFBvaW50QXJyYXkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9pbml0aWFsVmVydGljZXMuc2l6ZSgpK3RoaXMuX3NlZ1ZlcnRpY2VzLnNpemUoKSkuZmlsbChudWxsKTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLl9pbml0aWFsVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7dFtlKytdPXMuZ2V0Q29vcmRpbmF0ZSgpfWZvcihsZXQgbj10aGlzLl9zZWdWZXJ0aWNlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTt0W2UrK109cy5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHR9c2V0Q29uc3RyYWludHModCxlKXt0aGlzLl9zZWdtZW50cz10LHRoaXMuX3NlZ1ZlcnRpY2VzPWV9Y29tcHV0ZUNvbnZleEh1bGwoKXtjb25zdCB0PW5ldyBMdCxlPXRoaXMuZ2V0UG9pbnRBcnJheSgpLG49bmV3IHNuKGUsdCk7dGhpcy5fY29udmV4SHVsbD1uLmdldENvbnZleEh1bGwoKX1hZGRDb25zdHJhaW50VmVydGljZXMoKXt0aGlzLmNvbXB1dGVDb252ZXhIdWxsKCksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLl9zZWdWZXJ0aWNlcyl9ZmluZE5vbkdhYnJpZWxQb2ludCh0KXtjb25zdCBlPXQuZ2V0U3RhcnQoKSxuPXQuZ2V0RW5kKCkscz1uZXcgbSgoZS54K24ueCkvMiwoZS55K24ueSkvMiksaT1lLmRpc3RhbmNlKHMpLG89bmV3IE8ocyk7by5leHBhbmRCeShpKTtjb25zdCBsPXRoaXMuX2tkdC5xdWVyeShvKTtsZXQgYT1udWxsLGM9ci5NQVhfVkFMVUU7Zm9yKGxldCB0PWwuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IHI9dC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpO2lmKHIuZXF1YWxzMkQoZSl8fHIuZXF1YWxzMkQobikpY29udGludWU7Y29uc3Qgbz1zLmRpc3RhbmNlKHIpO2lmKG88aSl7Y29uc3QgdD1vOyhudWxsPT09YXx8dDxjKSYmKGE9cixjPXQpfX1yZXR1cm4gYX1nZXRDb25zdHJhaW50U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fc2VnbWVudHN9c2V0U3BsaXRQb2ludEZpbmRlcih0KXt0aGlzLl9zcGxpdEZpbmRlcj10fWdldENvbnZleEh1bGwoKXtyZXR1cm4gdGhpcy5fY29udmV4SHVsbH1nZXRUb2xlcmFuY2UoKXtyZXR1cm4gdGhpcy5fdG9sZXJhbmNlfWVuZm9yY2VHYWJyaWVsKHQpe2NvbnN0IGU9bmV3IEw7bGV0IG49MDtjb25zdCBzPW5ldyBMO2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpLHI9dGhpcy5maW5kTm9uR2FicmllbFBvaW50KHQpO2lmKG51bGw9PT1yKWNvbnRpbnVlO3RoaXMuX3NwbGl0UHQ9dGhpcy5fc3BsaXRGaW5kZXIuZmluZFNwbGl0UG9pbnQodCxyKTtjb25zdCBvPXRoaXMuY3JlYXRlVmVydGV4KHRoaXMuX3NwbGl0UHQsdCk7dGhpcy5pbnNlcnRTaXRlKG8pLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0aGlzLl9zcGxpdFB0KTtjb25zdCBsPW5ldyB0bCh0LmdldFN0YXJ0WCgpLHQuZ2V0U3RhcnRZKCksdC5nZXRTdGFydFooKSxvLmdldFgoKSxvLmdldFkoKSxvLmdldFooKSx0LmdldERhdGEoKSksYT1uZXcgdGwoby5nZXRYKCksby5nZXRZKCksby5nZXRaKCksdC5nZXRFbmRYKCksdC5nZXRFbmRZKCksdC5nZXRFbmRaKCksdC5nZXREYXRhKCkpO2UuYWRkKGwpLGUuYWRkKGEpLHMuYWRkKHQpLG4rPTF9cmV0dXJuIHQucmVtb3ZlQWxsKHMpLHQuYWRkQWxsKGUpLG59Y3JlYXRlVmVydGV4KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGw7cmV0dXJuIGU9bnVsbCE9PXRoaXMuX3ZlcnRleEZhY3Rvcnk/dGhpcy5fdmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxudWxsKTpuZXcgem8odCksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbDtyZXR1cm4gbj1udWxsIT09dGhpcy5fdmVydGV4RmFjdG9yeT90aGlzLl92ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleCh0LGUpOm5ldyB6byh0KSxuLnNldE9uQ29uc3RyYWludCghMCksbn19Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5fc3ViZGl2fWNvbXB1dGVCb3VuZGluZ0JveCgpe2NvbnN0IHQ9bmwuY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuX2luaXRpYWxWZXJ0aWNlcyksZT1ubC5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5fc2VnVmVydGljZXMpLG49bmV3IE8odCk7bi5leHBhbmRUb0luY2x1ZGUoZSk7Y29uc3Qgcz0uMipuLmdldFdpZHRoKCksaT0uMipuLmdldEhlaWdodCgpLHI9TWF0aC5tYXgocyxpKTt0aGlzLl9jb21wdXRlQXJlYUVudj1uZXcgTyhuKSx0aGlzLl9jb21wdXRlQXJlYUVudi5leHBhbmRCeShyKX1zZXRWZXJ0ZXhGYWN0b3J5KHQpe3RoaXMuX3ZlcnRleEZhY3Rvcnk9dH1mb3JtSW5pdGlhbERlbGF1bmF5KCl7dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLl9zdWJkaXY9bmV3IGpvKHRoaXMuX2NvbXB1dGVBcmVhRW52LHRoaXMuX3RvbGVyYW5jZSksdGhpcy5fc3ViZGl2LnNldExvY2F0b3IobmV3IEhvKHRoaXMuX3N1YmRpdikpLHRoaXMuX2luY0RlbD1uZXcga28odGhpcy5fc3ViZGl2KSx0aGlzLmluc2VydFNpdGVzKHRoaXMuX2luaXRpYWxWZXJ0aWNlcyl9aW5zZXJ0U2l0ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygem8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fa2R0Lmluc2VydCh0LmdldENvb3JkaW5hdGUoKSx0KTtpZihlLmlzUmVwZWF0ZWQoKSl7Y29uc3Qgbj1lLmdldERhdGEoKTtyZXR1cm4gbi5tZXJnZSh0KSxufXJldHVybiB0aGlzLl9pbmNEZWwuaW5zZXJ0U2l0ZSh0KSx0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRTaXRlKHRoaXMuY3JlYXRlVmVydGV4KHQpKX19fW5sLk1BWF9TUExJVF9JVEVSPTk5O2NsYXNzIHNse2NvbnN0cnVjdG9yKCl7c2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsfXN0YXRpYyBleHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl7aWYobnVsbD09PXQpcmV0dXJuIG5ldyBSO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBzbC51bmlxdWUoZSl9c3RhdGljIGVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE87Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUodCl9cmV0dXJuIGV9c3RhdGljIHVuaXF1ZSh0KXtjb25zdCBlPV90LmNvcHlEZWVwKHQpO3N0LnNvcnQoZSk7cmV0dXJuIG5ldyBSKGUsITEpfXN0YXRpYyB0b1ZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IFZvKHQpKX1yZXR1cm4gZX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9c2wuZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3JkcyksZT1zbC50b1ZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpO3RoaXMuX3N1YmRpdj1uZXcgam8odCx0aGlzLl90b2xlcmFuY2UpO25ldyBrbyh0aGlzLl9zdWJkaXYpLmluc2VydFNpdGVzKGUpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRTaXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1zbC5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1zbC51bmlxdWUoX3QudG9Db29yZGluYXRlQXJyYXkodCkpfX1nZXRFZGdlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0RWRnZXModCl9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9Z2V0VHJpYW5nbGVzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRUcmlhbmdsZXModCl9fWNsYXNzIGlse2NvbnN0cnVjdG9yKCl7aWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX2NvbnN0cmFpbnRMaW5lcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXA9bmV3IFdufXN0YXRpYyBjcmVhdGVDb25zdHJhaW50U2VnbWVudHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT15ZS5nZXRMaW5lcyh0KSxuPW5ldyBMO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2lsLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyhlLG4pfXJldHVybiBufWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0xO248ZS5sZW5ndGg7bisrKXQuYWRkKG5ldyB0bChlW24tMV0sZVtuXSkpfX1jcmVhdGVTaXRlVmVydGljZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLmNvbnRhaW5zS2V5KHQpfHxlLmFkZChuZXcgem8odCkpfXJldHVybiBlfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1zbC5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKTtsZXQgZT1uZXcgTDtudWxsIT09dGhpcy5fY29uc3RyYWludExpbmVzJiYodC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29uc3RyYWludExpbmVzLmdldEVudmVsb3BlSW50ZXJuYWwoKSksdGhpcy5jcmVhdGVWZXJ0aWNlcyh0aGlzLl9jb25zdHJhaW50TGluZXMpLGU9aWwuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKHRoaXMuX2NvbnN0cmFpbnRMaW5lcykpO2NvbnN0IG49dGhpcy5jcmVhdGVTaXRlVmVydGljZXModGhpcy5fc2l0ZUNvb3Jkcykscz1uZXcgbmwobix0aGlzLl90b2xlcmFuY2UpO3Muc2V0Q29uc3RyYWludHMoZSxuZXcgTCh0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLnZhbHVlcygpKSkscy5mb3JtSW5pdGlhbERlbGF1bmF5KCkscy5lbmZvcmNlQ29uc3RyYWludHMoKSx0aGlzLl9zdWJkaXY9cy5nZXRTdWJkaXZpc2lvbigpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRDb25zdHJhaW50cyh0KXt0aGlzLl9jb25zdHJhaW50TGluZXM9dH1zZXRTaXRlcyh0KXt0aGlzLl9zaXRlQ29vcmRzPXNsLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1nZXRFZGdlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0RWRnZXModCl9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9Z2V0VHJpYW5nbGVzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRUcmlhbmdsZXModCl9Y3JlYXRlVmVydGljZXModCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IG49bmV3IHpvKGVbdF0pO3RoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAucHV0KGVbdF0sbil9fX1jbGFzcyBybHtjb25zdHJ1Y3Rvcigpe3JsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9jbGlwRW52PW51bGwsdGhpcy5fZGlhZ3JhbUVudj1udWxsfXN0YXRpYyBjbGlwR2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj10LmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KGUpLHM9bmV3IEw7Zm9yKGxldCBpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe2NvbnN0IHI9dC5nZXRHZW9tZXRyeU4oaSk7bGV0IG89bnVsbDtlLmNvbnRhaW5zKHIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9vPXI6ZS5pbnRlcnNlY3RzKHIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKG89d3IuaW50ZXJzZWN0aW9uKG4sciksby5zZXRVc2VyRGF0YShyLmdldFVzZXJEYXRhKCkpKSxudWxsPT09b3x8by5pc0VtcHR5KCl8fHMuYWRkKG8pfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oTHQudG9HZW9tZXRyeUFycmF5KHMpKX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9c2wuZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3Jkcyk7aWYodGhpcy5fZGlhZ3JhbUVudj10aGlzLl9jbGlwRW52LG51bGw9PT10aGlzLl9kaWFncmFtRW52KXt0aGlzLl9kaWFncmFtRW52PXQ7Y29uc3QgZT10aGlzLl9kaWFncmFtRW52LmdldERpYW1ldGVyKCk7dGhpcy5fZGlhZ3JhbUVudi5leHBhbmRCeShlKX1jb25zdCBlPXNsLnRvVmVydGljZXModGhpcy5fc2l0ZUNvb3Jkcyk7dGhpcy5fc3ViZGl2PW5ldyBqbyh0LHRoaXMuX3RvbGVyYW5jZSk7bmV3IGtvKHRoaXMuX3N1YmRpdikuaW5zZXJ0U2l0ZXMoZSl9Z2V0RGlhZ3JhbSh0KXt0aGlzLmNyZWF0ZSgpO2NvbnN0IGU9dGhpcy5fc3ViZGl2LmdldFZvcm9ub2lEaWFncmFtKHQpO3JldHVybiBybC5jbGlwR2VvbWV0cnlDb2xsZWN0aW9uKGUsdGhpcy5fZGlhZ3JhbUVudil9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldFNpdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPXNsLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPXNsLnVuaXF1ZShfdC50b0Nvb3JkaW5hdGVBcnJheSh0KSl9fXNldENsaXBFbnZlbG9wZSh0KXt0aGlzLl9jbGlwRW52PXR9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9fXZhciBsbD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxWZXJ0ZXg6Vm99KSxhbD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb25mb3JtaW5nRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjppbCxEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOnNsLFZvcm9ub2lEaWFncmFtQnVpbGRlcjpybCxxdWFkZWRnZTpsbH0pO2NsYXNzIGNse2NvbnN0cnVjdG9yKCl7Y2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGluZWFyR2VvbT1udWxsLHRoaXMuX251bUxpbmVzPW51bGwsdGhpcy5fY3VycmVudExpbmU9bnVsbCx0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3ZlcnRleEluZGV4PTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2NsLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwwLDApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2NsLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLmdldENvbXBvbmVudEluZGV4KCksY2wuc2VnbWVudEVuZFZlcnRleEluZGV4KGUpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZighSSh0LFopKXRocm93IG5ldyBzKFwiTGluZWFsIGdlb21ldHJ5IGlzIHJlcXVpcmVkXCIpO3RoaXMuX2xpbmVhckdlb209dCx0aGlzLl9udW1MaW5lcz10LmdldE51bUdlb21ldHJpZXMoKSx0aGlzLl9jb21wb25lbnRJbmRleD1lLHRoaXMuX3ZlcnRleEluZGV4PW4sdGhpcy5sb2FkQ3VycmVudExpbmUoKX19c3RhdGljIHNlZ21lbnRFbmRWZXJ0ZXhJbmRleCh0KXtyZXR1cm4gdC5nZXRTZWdtZW50RnJhY3Rpb24oKT4wP3QuZ2V0U2VnbWVudEluZGV4KCkrMTp0LmdldFNlZ21lbnRJbmRleCgpfWdldENvbXBvbmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4fWdldExpbmUoKXtyZXR1cm4gdGhpcy5fY3VycmVudExpbmV9Z2V0VmVydGV4SW5kZXgoKXtyZXR1cm4gdGhpcy5fdmVydGV4SW5kZXh9Z2V0U2VnbWVudEVuZCgpe3JldHVybiB0aGlzLl92ZXJ0ZXhJbmRleDx0aGlzLmdldExpbmUoKS5nZXROdW1Qb2ludHMoKS0xP3RoaXMuX2N1cnJlbnRMaW5lLmdldENvb3JkaW5hdGVOKHRoaXMuX3ZlcnRleEluZGV4KzEpOm51bGx9bmV4dCgpe2lmKCF0aGlzLmhhc05leHQoKSlyZXR1cm4gbnVsbDt0aGlzLl92ZXJ0ZXhJbmRleCsrLHRoaXMuX3ZlcnRleEluZGV4Pj10aGlzLl9jdXJyZW50TGluZS5nZXROdW1Qb2ludHMoKSYmKHRoaXMuX2NvbXBvbmVudEluZGV4KyssdGhpcy5sb2FkQ3VycmVudExpbmUoKSx0aGlzLl92ZXJ0ZXhJbmRleD0wKX1sb2FkQ3VycmVudExpbmUoKXtpZih0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lPW51bGwsbnVsbDt0aGlzLl9jdXJyZW50TGluZT10aGlzLl9saW5lYXJHZW9tLmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCl9Z2V0U2VnbWVudFN0YXJ0KCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLmdldENvb3JkaW5hdGVOKHRoaXMuX3ZlcnRleEluZGV4KX1pc0VuZE9mTGluZSgpe3JldHVybiEodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKSYmISh0aGlzLl92ZXJ0ZXhJbmRleDx0aGlzLl9jdXJyZW50TGluZS5nZXROdW1Qb2ludHMoKS0xKX1oYXNOZXh0KCl7cmV0dXJuISh0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpJiYhKHRoaXMuX2NvbXBvbmVudEluZGV4PT09dGhpcy5fbnVtTGluZXMtMSYmdGhpcy5fdmVydGV4SW5kZXg+PXRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpKX19Y2xhc3MgaGx7Y29uc3RydWN0b3IoKXtobC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fXN0YXRpYyBpbmRleE9mKHQsZSl7cmV0dXJuIG5ldyBobCh0KS5pbmRleE9mKGUpfXN0YXRpYyBpbmRleE9mQWZ0ZXIodCxlLG4pe3JldHVybiBuZXcgaGwodCkuaW5kZXhPZkFmdGVyKGUsbil9aW5kZXhPZih0KXtyZXR1cm4gdGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsLTEpfWluZGV4T2ZGcm9tU3RhcnQodCxlKXtsZXQgbj1yLk1BWF9WQUxVRSxzPWUsaT0wO2NvbnN0IG89bmV3IEt0LGw9bmV3IGNsKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bC5oYXNOZXh0KCk7KXtpZighbC5pc0VuZE9mTGluZSgpKXtvLnAwPWwuZ2V0U2VnbWVudFN0YXJ0KCksby5wMT1sLmdldFNlZ21lbnRFbmQoKTtjb25zdCByPW8uZGlzdGFuY2UodCksYT10aGlzLnNlZ21lbnROZWFyZXN0TWVhc3VyZShvLHQsaSk7cjxuJiZhPmUmJihzPWEsbj1yKSxpKz1vLmdldExlbmd0aCgpfWwubmV4dCgpfXJldHVybiBzfWluZGV4T2ZBZnRlcih0LGUpe2lmKGU8MClyZXR1cm4gdGhpcy5pbmRleE9mKHQpO2NvbnN0IG49dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKTtpZihuPGUpcmV0dXJuIG47Y29uc3Qgcz10aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxlKTtyZXR1cm4gZy5pc1RydWUocz49ZSxcImNvbXB1dGVkIGluZGV4IGlzIGJlZm9yZSBzcGVjaWZpZWQgbWluaW11bSBpbmRleFwiKSxzfXNlZ21lbnROZWFyZXN0TWVhc3VyZSh0LGUsbil7Y29uc3Qgcz10LnByb2plY3Rpb25GYWN0b3IoZSk7cmV0dXJuIHM8PTA/bjpzPD0xP24rcyp0LmdldExlbmd0aCgpOm4rdC5nZXRMZW5ndGgoKX19Y2xhc3MgdWx7Y29uc3RydWN0b3IoKXt1bC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wb25lbnRJbmRleD10Ll9jb21wb25lbnRJbmRleCx0aGlzLl9zZWdtZW50SW5kZXg9dC5fc2VnbWVudEluZGV4LHRoaXMuX3NlZ21lbnRGcmFjdGlvbj10Ll9zZWdtZW50RnJhY3Rpb259ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dWwuY29uc3RydWN0b3JfLmNhbGwodGhpcywwLHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29tcG9uZW50SW5kZXg9dCx0aGlzLl9zZWdtZW50SW5kZXg9ZSx0aGlzLl9zZWdtZW50RnJhY3Rpb249bix0aGlzLm5vcm1hbGl6ZSgpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQsdGhpcy5fc2VnbWVudEluZGV4PWUsdGhpcy5fc2VnbWVudEZyYWN0aW9uPW4scyYmdGhpcy5ub3JtYWxpemUoKX19c3RhdGljIGdldEVuZExvY2F0aW9uKHQpe2NvbnN0IGU9bmV3IHVsO3JldHVybiBlLnNldFRvRW5kKHQpLGV9c3RhdGljIHBvaW50QWxvbmdTZWdtZW50QnlGcmFjdGlvbih0LGUsbil7aWYobjw9MClyZXR1cm4gdDtpZihuPj0xKXJldHVybiBlO2NvbnN0IHM9KGUueC10LngpKm4rdC54LGk9KGUueS10LnkpKm4rdC55LHI9KGUuZ2V0WigpLXQuZ2V0WigpKSpuK3QuZ2V0WigpO3JldHVybiBuZXcgbShzLGkscil9c3RhdGljIGNvbXBhcmVMb2NhdGlvblZhbHVlcyh0LGUsbixzLGkscil7cmV0dXJuIHQ8cz8tMTp0PnM/MTplPGk/LTE6ZT5pPzE6bjxyPy0xOm4+cj8xOjB9c3RhdGljIG51bVNlZ21lbnRzKHQpe2NvbnN0IGU9dC5nZXROdW1Qb2ludHMoKTtyZXR1cm4gZTw9MT8wOmUtMX1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4fWdldENvbXBvbmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4fWlzRW5kcG9pbnQodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj11bC5udW1TZWdtZW50cyhlKTtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4Pj1ufHx0aGlzLl9zZWdtZW50SW5kZXg9PT1uLTEmJnRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MX1pc1ZhbGlkKHQpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4PDB8fHRoaXMuX2NvbXBvbmVudEluZGV4Pj10LmdldE51bUdlb21ldHJpZXMoKSlyZXR1cm4hMTtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTtyZXR1cm4hKHRoaXMuX3NlZ21lbnRJbmRleDwwfHx0aGlzLl9zZWdtZW50SW5kZXg+ZS5nZXROdW1Qb2ludHMoKSkmJigodGhpcy5fc2VnbWVudEluZGV4IT09ZS5nZXROdW1Qb2ludHMoKXx8MD09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbikmJiEodGhpcy5fc2VnbWVudEZyYWN0aW9uPDB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj4xKSl9bm9ybWFsaXplKCl7dGhpcy5fc2VnbWVudEZyYWN0aW9uPDAmJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksdGhpcy5fc2VnbWVudEZyYWN0aW9uPjEmJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MSksdGhpcy5fY29tcG9uZW50SW5kZXg8MCYmKHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fc2VnbWVudEluZGV4PTAsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTApLHRoaXMuX3NlZ21lbnRJbmRleDwwJiYodGhpcy5fc2VnbWVudEluZGV4PTAsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTApLDE9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24mJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MCx0aGlzLl9zZWdtZW50SW5kZXgrPTEpfXRvTG93ZXN0KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49dWwubnVtU2VnbWVudHMoZSk7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleDxuP3RoaXM6bmV3IHVsKHRoaXMuX2NvbXBvbmVudEluZGV4LG4tMSwxLCExKX1nZXRDb29yZGluYXRlKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgpO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49dWwubnVtU2VnbWVudHMoZSkpcmV0dXJuIG47Y29uc3Qgcz1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCsxKTtyZXR1cm4gdWwucG9pbnRBbG9uZ1NlZ21lbnRCeUZyYWN0aW9uKG4scyx0aGlzLl9zZWdtZW50RnJhY3Rpb24pfWdldFNlZ21lbnRGcmFjdGlvbigpe3JldHVybiB0aGlzLl9zZWdtZW50RnJhY3Rpb259Z2V0U2VnbWVudCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KTtpZih0aGlzLl9zZWdtZW50SW5kZXg+PXVsLm51bVNlZ21lbnRzKGUpKXtjb25zdCB0PWUuZ2V0Q29vcmRpbmF0ZU4oZS5nZXROdW1Qb2ludHMoKS0yKTtyZXR1cm4gbmV3IEt0KHQsbil9Y29uc3Qgcz1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCsxKTtyZXR1cm4gbmV3IEt0KG4scyl9Y2xhbXAodCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg+PXQuZ2V0TnVtR2VvbWV0cmllcygpKXJldHVybiB0aGlzLnNldFRvRW5kKHQpLG51bGw7aWYodGhpcy5fc2VnbWVudEluZGV4Pj10LmdldE51bVBvaW50cygpKXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTt0aGlzLl9zZWdtZW50SW5kZXg9dWwubnVtU2VnbWVudHMoZSksdGhpcy5fc2VnbWVudEZyYWN0aW9uPTF9fXNldFRvRW5kKHQpe3RoaXMuX2NvbXBvbmVudEluZGV4PXQuZ2V0TnVtR2VvbWV0cmllcygpLTE7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7dGhpcy5fc2VnbWVudEluZGV4PXVsLm51bVNlZ21lbnRzKGUpLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4PGUuX2NvbXBvbmVudEluZGV4Py0xOnRoaXMuX2NvbXBvbmVudEluZGV4PmUuX2NvbXBvbmVudEluZGV4PzE6dGhpcy5fc2VnbWVudEluZGV4PGUuX3NlZ21lbnRJbmRleD8tMTp0aGlzLl9zZWdtZW50SW5kZXg+ZS5fc2VnbWVudEluZGV4PzE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPGUuX3NlZ21lbnRGcmFjdGlvbj8tMTp0aGlzLl9zZWdtZW50RnJhY3Rpb24+ZS5fc2VnbWVudEZyYWN0aW9uPzE6MH1jb3B5KCl7cmV0dXJuIG5ldyB1bCh0aGlzLl9jb21wb25lbnRJbmRleCx0aGlzLl9zZWdtZW50SW5kZXgsdGhpcy5fc2VnbWVudEZyYWN0aW9uKX10b1N0cmluZygpe3JldHVyblwiTGluZWFyTG9jW1wiK3RoaXMuX2NvbXBvbmVudEluZGV4K1wiLCBcIit0aGlzLl9zZWdtZW50SW5kZXgrXCIsIFwiK3RoaXMuX3NlZ21lbnRGcmFjdGlvbitcIl1cIn1pc09uU2FtZVNlZ21lbnQodCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4PT09dC5fY29tcG9uZW50SW5kZXgmJih0aGlzLl9zZWdtZW50SW5kZXg9PT10Ll9zZWdtZW50SW5kZXh8fCh0Ll9zZWdtZW50SW5kZXgtdGhpcy5fc2VnbWVudEluZGV4PT0xJiYwPT09dC5fc2VnbWVudEZyYWN0aW9ufHx0aGlzLl9zZWdtZW50SW5kZXgtdC5fc2VnbWVudEluZGV4PT0xJiYwPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uKSl9c25hcFRvVmVydGV4KHQsZSl7aWYodGhpcy5fc2VnbWVudEZyYWN0aW9uPD0wfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTEpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLmdldFNlZ21lbnRMZW5ndGgodCkscz10aGlzLl9zZWdtZW50RnJhY3Rpb24qbixpPW4tcztzPD1pJiZzPGU/dGhpcy5fc2VnbWVudEZyYWN0aW9uPTA6aTw9cyYmaTxlJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTEpfWNvbXBhcmVMb2NhdGlvblZhbHVlcyh0LGUsbil7cmV0dXJuIHRoaXMuX2NvbXBvbmVudEluZGV4PHQ/LTE6dGhpcy5fY29tcG9uZW50SW5kZXg+dD8xOnRoaXMuX3NlZ21lbnRJbmRleDxlPy0xOnRoaXMuX3NlZ21lbnRJbmRleD5lPzE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPG4/LTE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPm4/MTowfWdldFNlZ21lbnRMZW5ndGgodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7bGV0IG49dGhpcy5fc2VnbWVudEluZGV4O3RoaXMuX3NlZ21lbnRJbmRleD49dWwubnVtU2VnbWVudHMoZSkmJihuPWUuZ2V0TnVtUG9pbnRzKCktMik7Y29uc3Qgcz1lLmdldENvb3JkaW5hdGVOKG4pLGk9ZS5nZXRDb29yZGluYXRlTihuKzEpO3JldHVybiBzLmRpc3RhbmNlKGkpfWlzVmVydGV4KCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRGcmFjdGlvbjw9MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgZ2x7Y29uc3RydWN0b3IoKXtnbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fXN0YXRpYyBpbmRleE9mKHQsZSl7cmV0dXJuIG5ldyBnbCh0KS5pbmRleE9mKGUpfXN0YXRpYyBpbmRleE9mQWZ0ZXIodCxlLG4pe3JldHVybiBuZXcgZ2wodCkuaW5kZXhPZkFmdGVyKGUsbil9aW5kZXhPZih0KXtyZXR1cm4gdGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsbnVsbCl9aW5kZXhPZkZyb21TdGFydCh0LGUpe2xldCBuPXIuTUFYX1ZBTFVFLHM9MCxpPTAsbz0tMTtjb25zdCBsPW5ldyBLdDtmb3IobGV0IHI9bmV3IGNsKHRoaXMuX2xpbmVhckdlb20pO3IuaGFzTmV4dCgpO3IubmV4dCgpKWlmKCFyLmlzRW5kT2ZMaW5lKCkpe2wucDA9ci5nZXRTZWdtZW50U3RhcnQoKSxsLnAxPXIuZ2V0U2VnbWVudEVuZCgpO2NvbnN0IGE9bC5kaXN0YW5jZSh0KSxjPWwuc2VnbWVudEZyYWN0aW9uKHQpLGg9ci5nZXRDb21wb25lbnRJbmRleCgpLHU9ci5nZXRWZXJ0ZXhJbmRleCgpO2E8biYmKG51bGw9PT1lfHxlLmNvbXBhcmVMb2NhdGlvblZhbHVlcyhoLHUsYyk8MCkmJihzPWgsaT11LG89YyxuPWEpfWlmKG49PT1yLk1BWF9WQUxVRSlyZXR1cm4gbmV3IHVsKGUpO3JldHVybiBuZXcgdWwocyxpLG8pfWluZGV4T2ZBZnRlcih0LGUpe2lmKG51bGw9PT1lKXJldHVybiB0aGlzLmluZGV4T2YodCk7Y29uc3Qgbj11bC5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKTtpZihuLmNvbXBhcmVUbyhlKTw9MClyZXR1cm4gbjtjb25zdCBzPXRoaXMuaW5kZXhPZkZyb21TdGFydCh0LGUpO3JldHVybiBnLmlzVHJ1ZShzLmNvbXBhcmVUbyhlKT49MCxcImNvbXB1dGVkIGxvY2F0aW9uIGlzIGJlZm9yZSBzcGVjaWZpZWQgbWluaW11bSBsb2NhdGlvblwiKSxzfX1jbGFzcyBkbHtjb25zdHJ1Y3Rvcigpe2RsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9c3RhdGljIGluZGljZXNPZih0LGUpe3JldHVybiBuZXcgZGwodCkuaW5kaWNlc09mKGUpfWluZGljZXNPZih0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKDApLmdldENvb3JkaW5hdGVOKDApLG49dC5nZXRHZW9tZXRyeU4odC5nZXROdW1HZW9tZXRyaWVzKCktMSkscz1uLmdldENvb3JkaW5hdGVOKG4uZ2V0TnVtUG9pbnRzKCktMSksaT1uZXcgZ2wodGhpcy5fbGluZWFyR2VvbSkscj1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gclswXT1pLmluZGV4T2YoZSksMD09PXQuZ2V0TGVuZ3RoKCk/clsxXT1yWzBdLmNvcHkoKTpyWzFdPWkuaW5kZXhPZkFmdGVyKHMsclswXSkscn19Y2xhc3MgX2x7Y29uc3RydWN0b3IoKXtfbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fXN0YXRpYyBnZXRMZW5ndGgodCxlKXtyZXR1cm4gbmV3IF9sKHQpLmdldExlbmd0aChlKX1zdGF0aWMgZ2V0TG9jYXRpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBfbChhcmd1bWVudHNbMF0pLmdldExvY2F0aW9uKHQpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IF9sKGFyZ3VtZW50c1swXSkuZ2V0TG9jYXRpb24odCxlKX19Z2V0TGVuZ3RoKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgY2wodGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtuLmhhc05leHQoKTspe2lmKCFuLmlzRW5kT2ZMaW5lKCkpe2NvbnN0IHM9bi5nZXRTZWdtZW50U3RhcnQoKSxpPW4uZ2V0U2VnbWVudEVuZCgpLmRpc3RhbmNlKHMpO2lmKHQuZ2V0Q29tcG9uZW50SW5kZXgoKT09PW4uZ2V0Q29tcG9uZW50SW5kZXgoKSYmdC5nZXRTZWdtZW50SW5kZXgoKT09PW4uZ2V0VmVydGV4SW5kZXgoKSlyZXR1cm4gZStpKnQuZ2V0U2VnbWVudEZyYWN0aW9uKCk7ZSs9aX1uLm5leHQoKX1yZXR1cm4gZX1yZXNvbHZlSGlnaGVyKHQpe2lmKCF0LmlzRW5kcG9pbnQodGhpcy5fbGluZWFyR2VvbSkpcmV0dXJuIHQ7bGV0IGU9dC5nZXRDb21wb25lbnRJbmRleCgpO2lmKGU+PXRoaXMuX2xpbmVhckdlb20uZ2V0TnVtR2VvbWV0cmllcygpLTEpcmV0dXJuIHQ7ZG97ZSsrfXdoaWxlKGU8dGhpcy5fbGluZWFyR2VvbS5nZXROdW1HZW9tZXRyaWVzKCktMSYmMD09PXRoaXMuX2xpbmVhckdlb20uZ2V0R2VvbWV0cnlOKGUpLmdldExlbmd0aCgpKTtyZXR1cm4gbmV3IHVsKGUsMCwwKX1nZXRMb2NhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbih0LCEwKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49dDtpZih0PDApe249dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKSt0fWNvbnN0IHM9dGhpcy5nZXRMb2NhdGlvbkZvcndhcmQobik7cmV0dXJuIGU/czp0aGlzLnJlc29sdmVIaWdoZXIocyl9fWdldExvY2F0aW9uRm9yd2FyZCh0KXtpZih0PD0wKXJldHVybiBuZXcgdWw7bGV0IGU9MDtjb25zdCBuPW5ldyBjbCh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO24uaGFzTmV4dCgpOyl7aWYobi5pc0VuZE9mTGluZSgpKXtpZihlPT09dCl7Y29uc3QgdD1uLmdldENvbXBvbmVudEluZGV4KCksZT1uLmdldFZlcnRleEluZGV4KCk7cmV0dXJuIG5ldyB1bCh0LGUsMCl9fWVsc2V7Y29uc3Qgcz1uLmdldFNlZ21lbnRTdGFydCgpLGk9bi5nZXRTZWdtZW50RW5kKCkuZGlzdGFuY2Uocyk7aWYoZStpPnQpe2NvbnN0IHM9KHQtZSkvaSxyPW4uZ2V0Q29tcG9uZW50SW5kZXgoKSxvPW4uZ2V0VmVydGV4SW5kZXgoKTtyZXR1cm4gbmV3IHVsKHIsbyxzKX1lKz1pfW4ubmV4dCgpfXJldHVybiB1bC5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKX19Y2xhc3MgcGx7Y29uc3RydWN0b3IoKXtwbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2xpbmVzPW5ldyBMLHRoaXMuX2Nvb3JkTGlzdD1udWxsLHRoaXMuX2lnbm9yZUludmFsaWRMaW5lcz0hMSx0aGlzLl9maXhJbnZhbGlkTGluZXM9ITEsdGhpcy5fbGFzdFB0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Q9dH1nZXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLmVuZExpbmUoKSx0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHRoaXMuX2xpbmVzKX1nZXRMYXN0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9sYXN0UHR9ZW5kTGluZSgpe2lmKG51bGw9PT10aGlzLl9jb29yZExpc3QpcmV0dXJuIG51bGw7aWYodGhpcy5faWdub3JlSW52YWxpZExpbmVzJiZ0aGlzLl9jb29yZExpc3Quc2l6ZSgpPDIpcmV0dXJuIHRoaXMuX2Nvb3JkTGlzdD1udWxsLG51bGw7Y29uc3QgdD10aGlzLl9jb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgZT10O3RoaXMuX2ZpeEludmFsaWRMaW5lcyYmKGU9dGhpcy52YWxpZENvb3JkaW5hdGVTZXF1ZW5jZSh0KSksdGhpcy5fY29vcmRMaXN0PW51bGw7bGV0IG49bnVsbDt0cnl7bj10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lU3RyaW5nKGUpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIHMpKXRocm93IHQ7aWYoIXRoaXMuX2lnbm9yZUludmFsaWRMaW5lcyl0aHJvdyB0fW51bGwhPT1uJiZ0aGlzLl9saW5lcy5hZGQobil9c2V0Rml4SW52YWxpZExpbmVzKHQpe3RoaXMuX2ZpeEludmFsaWRMaW5lcz10fWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LCEwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtudWxsPT09dGhpcy5fY29vcmRMaXN0JiYodGhpcy5fY29vcmRMaXN0PW5ldyBSKSx0aGlzLl9jb29yZExpc3QuYWRkKHQsZSksdGhpcy5fbGFzdFB0PXR9fXNldElnbm9yZUludmFsaWRMaW5lcyh0KXt0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXM9dH12YWxpZENvb3JkaW5hdGVTZXF1ZW5jZSh0KXtpZih0Lmxlbmd0aD49MilyZXR1cm4gdDtyZXR1cm5bdFswXSx0WzBdXX19Y2xhc3MgbWx7Y29uc3RydWN0b3IoKXttbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fXN0YXRpYyBleHRyYWN0KHQsZSxuKXtyZXR1cm4gbmV3IG1sKHQpLmV4dHJhY3QoZSxuKX1jb21wdXRlTGluZWFyKHQsZSl7Y29uc3Qgbj1uZXcgcGwodGhpcy5fbGluZS5nZXRGYWN0b3J5KCkpO24uc2V0Rml4SW52YWxpZExpbmVzKCEwKSx0LmlzVmVydGV4KCl8fG4uYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7Zm9yKGxldCBzPW5ldyBjbCh0aGlzLl9saW5lLHQpO3MuaGFzTmV4dCgpJiYhKGUuY29tcGFyZUxvY2F0aW9uVmFsdWVzKHMuZ2V0Q29tcG9uZW50SW5kZXgoKSxzLmdldFZlcnRleEluZGV4KCksMCk8MCk7cy5uZXh0KCkpe2NvbnN0IHQ9cy5nZXRTZWdtZW50U3RhcnQoKTtuLmFkZCh0KSxzLmlzRW5kT2ZMaW5lKCkmJm4uZW5kTGluZSgpfXJldHVybiBlLmlzVmVydGV4KCl8fG4uYWRkKGUuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSksbi5nZXRHZW9tZXRyeSgpfWNvbXB1dGVMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLl9saW5lLmdldENvb3JkaW5hdGVzKCkscz1uZXcgUjtsZXQgaT10LmdldFNlZ21lbnRJbmRleCgpO3QuZ2V0U2VnbWVudEZyYWN0aW9uKCk+MCYmKGkrPTEpO2xldCByPWUuZ2V0U2VnbWVudEluZGV4KCk7MT09PWUuZ2V0U2VnbWVudEZyYWN0aW9uKCkmJihyKz0xKSxyPj1uLmxlbmd0aCYmKHI9bi5sZW5ndGgtMSksdC5pc1ZlcnRleCgpfHxzLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2ZvcihsZXQgdD1pO3Q8PXI7dCsrKXMuYWRkKG5bdF0pO2UuaXNWZXJ0ZXgoKXx8cy5hZGQoZS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKSxzLnNpemUoKTw9MCYmcy5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtsZXQgbz1zLnRvQ29vcmRpbmF0ZUFycmF5KCk7cmV0dXJuIG8ubGVuZ3RoPD0xJiYobz1bb1swXSxvWzBdXSksdGhpcy5fbGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhvKX1leHRyYWN0KHQsZSl7cmV0dXJuIGUuY29tcGFyZVRvKHQpPDA/dGhpcy5yZXZlcnNlKHRoaXMuY29tcHV0ZUxpbmVhcihlLHQpKTp0aGlzLmNvbXB1dGVMaW5lYXIodCxlKX1yZXZlcnNlKHQpe3JldHVybiBJKHQsWik/dC5yZXZlcnNlKCk6KGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJub24tbGluZWFyIGdlb21ldHJ5IGVuY291bnRlcmVkXCIpLG51bGwpfX1jbGFzcyBmbHtjb25zdHJ1Y3Rvcigpe2ZsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9Y2xhbXBJbmRleCh0KXtjb25zdCBlPXRoaXMucG9zaXRpdmVJbmRleCh0KSxuPXRoaXMuZ2V0U3RhcnRJbmRleCgpO2lmKGU8bilyZXR1cm4gbjtjb25zdCBzPXRoaXMuZ2V0RW5kSW5kZXgoKTtyZXR1cm4gZT5zP3M6ZX1sb2NhdGlvbk9mKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBfbC5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gX2wuZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0LGUpfX1wcm9qZWN0KHQpe3JldHVybiBobC5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9cG9zaXRpdmVJbmRleCh0KXtyZXR1cm4gdD49MD90OnRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCkrdH1leHRyYWN0UG9pbnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIF9sLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCkuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lYXJHZW9tKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1fbC5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQpLnRvTG93ZXN0KHRoaXMuX2xpbmVhckdlb20pO3JldHVybiBuLmdldFNlZ21lbnQodGhpcy5fbGluZWFyR2VvbSkucG9pbnRBbG9uZ09mZnNldChuLmdldFNlZ21lbnRGcmFjdGlvbigpLGUpfX1pc1ZhbGlkSW5kZXgodCl7cmV0dXJuIHQ+PXRoaXMuZ2V0U3RhcnRJbmRleCgpJiZ0PD10aGlzLmdldEVuZEluZGV4KCl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gdGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKX1nZXRTdGFydEluZGV4KCl7cmV0dXJuIDB9aW5kZXhPZkFmdGVyKHQsZSl7cmV0dXJuIGhsLmluZGV4T2ZBZnRlcih0aGlzLl9saW5lYXJHZW9tLHQsZSl9ZXh0cmFjdExpbmUodCxlKXtjb25zdCBuPXRoaXMuY2xhbXBJbmRleCh0KSxzPXRoaXMuY2xhbXBJbmRleChlKSxpPW49PT1zLHI9dGhpcy5sb2NhdGlvbk9mKG4saSksbz10aGlzLmxvY2F0aW9uT2Yocyk7cmV0dXJuIG1sLmV4dHJhY3QodGhpcy5fbGluZWFyR2VvbSxyLG8pfWluZGV4T2YodCl7cmV0dXJuIGhsLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1pbmRpY2VzT2YodCl7Y29uc3QgZT1kbC5pbmRpY2VzT2YodGhpcy5fbGluZWFyR2VvbSx0KTtyZXR1cm5bX2wuZ2V0TGVuZ3RoKHRoaXMuX2xpbmVhckdlb20sZVswXSksX2wuZ2V0TGVuZ3RoKHRoaXMuX2xpbmVhckdlb20sZVsxXSldfX1jbGFzcyB5bHtjb25zdHJ1Y3Rvcigpe3lsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXQsdGhpcy5jaGVja0dlb21ldHJ5VHlwZSgpfWNsYW1wSW5kZXgodCl7Y29uc3QgZT10LmNvcHkoKTtyZXR1cm4gZS5jbGFtcCh0aGlzLl9saW5lYXJHZW9tKSxlfXByb2plY3QodCl7cmV0dXJuIGdsLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1jaGVja0dlb21ldHJ5VHlwZSgpe2lmKCEodGhpcy5fbGluZWFyR2VvbSBpbnN0YW5jZW9mICR8fHRoaXMuX2xpbmVhckdlb20gaW5zdGFuY2VvZiBTdCkpdGhyb3cgbmV3IHMoXCJJbnB1dCBnZW9tZXRyeSBtdXN0IGJlIGxpbmVhclwiKX1leHRyYWN0UG9pbnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIGFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmVhckdlb20pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXS50b0xvd2VzdCh0aGlzLl9saW5lYXJHZW9tKTtyZXR1cm4gZS5nZXRTZWdtZW50KHRoaXMuX2xpbmVhckdlb20pLnBvaW50QWxvbmdPZmZzZXQoZS5nZXRTZWdtZW50RnJhY3Rpb24oKSx0KX19aXNWYWxpZEluZGV4KHQpe3JldHVybiB0LmlzVmFsaWQodGhpcy5fbGluZWFyR2VvbSl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gdWwuZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSl9Z2V0U3RhcnRJbmRleCgpe3JldHVybiBuZXcgdWx9aW5kZXhPZkFmdGVyKHQsZSl7cmV0dXJuIGdsLmluZGV4T2ZBZnRlcih0aGlzLl9saW5lYXJHZW9tLHQsZSl9ZXh0cmFjdExpbmUodCxlKXtyZXR1cm4gbWwuZXh0cmFjdCh0aGlzLl9saW5lYXJHZW9tLHQsZSl9aW5kZXhPZih0KXtyZXR1cm4gZ2wuaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWluZGljZXNPZih0KXtyZXR1cm4gZGwuaW5kaWNlc09mKHRoaXMuX2xpbmVhckdlb20sdCl9fXZhciB4bD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMZW5ndGhJbmRleGVkTGluZTpmbCxMZW5ndGhMb2NhdGlvbk1hcDpfbCxMaW5lYXJHZW9tZXRyeUJ1aWxkZXI6cGwsTGluZWFySXRlcmF0b3I6Y2wsTGluZWFyTG9jYXRpb246dWwsTG9jYXRpb25JbmRleGVkTGluZTp5bH0pO2NsYXNzIEVse3N0YXRpYyB0cmFuc2Zvcm0odCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KW4uYWRkKGUuZXhlY3V0ZShzLm5leHQoKSkpO3JldHVybiBufXN0YXRpYyBzZWxlY3QodCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO0Jvb2xlYW4uVFJVRS5lcXVhbHMoZS5leGVjdXRlKHQpKSYmbi5hZGQodCl9cmV0dXJuIG59c3RhdGljIGFwcGx5KHQsZSl7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS5leGVjdXRlKG4ubmV4dCgpKX19RWwuRnVuY3Rpb249ZnVuY3Rpb24oKXt9O2NsYXNzIElse2NvbnN0cnVjdG9yKCl7SWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5wdHM9bnVsbCx0aGlzLm49MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz1uZXcgQXJyYXkodCkuZmlsbChudWxsKX1maWx0ZXIodCl7dGhpcy5wdHNbdGhpcy5uKytdPXR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hdfX1jbGFzcyBObHtjb25zdHJ1Y3Rvcigpe05sLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX249MH1maWx0ZXIodCl7dGhpcy5fbisrfWdldENvdW50KCl7cmV0dXJuIHRoaXMuX259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hdfX1jbGFzcyB3bHtjb25zdHJ1Y3Rvcigpe3dsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvdW50cz1uZXcgTnR9Y291bnQodCl7Y29uc3QgZT10aGlzLl9jb3VudHMuZ2V0KHQpO3JldHVybiBudWxsPT09ZT8wOmUuY291bnQoKX1hZGQodCl7Y29uc3QgZT10aGlzLl9jb3VudHMuZ2V0KHQpO251bGw9PT1lP3RoaXMuX2NvdW50cy5wdXQodCxuZXcgQ2woMSkpOmUuaW5jcmVtZW50KCl9fWNsYXNzIENse2NvbnN0cnVjdG9yKCl7Q2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5jb3VudD0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNvdW50PXR9fWNvdW50KCl7cmV0dXJuIHRoaXMuY291bnR9aW5jcmVtZW50KCl7dGhpcy5jb3VudCsrfX1mdW5jdGlvbiBTbCgpe31mdW5jdGlvbiBMbCgpe31mdW5jdGlvbiBUbCgpe313bC5Db3VudGVyPUNsO2NsYXNzIFJsIGV4dGVuZHMgbnt9ZnVuY3Rpb24gUGwoKXt9Y2xhc3MgT2x7c3RhdGljIGNoYXJzKHQsZSl7Y29uc3Qgbj1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtmb3IobGV0IHM9MDtzPGU7cysrKW5bc109dDtyZXR1cm4gbmV3IFN0cmluZyhuKX1zdGF0aWMgZ2V0U3RhY2tUcmFjZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBUbCxuPW5ldyBTbDtyZXR1cm4gdC5wcmludFN0YWNrVHJhY2UobiksZS50b1N0cmluZygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1cIlwiO25ldyBMbChPbC5nZXRTdGFja1RyYWNlKHQpKTtjb25zdCBzPW5ldyBQbDtmb3IobGV0IHQ9MDt0PGU7dCsrKXRyeXtuKz1zLnJlYWRMaW5lKCkrT2wuTkVXTElORX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBSbCkpdGhyb3cgdDtnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG59fXN0YXRpYyBzcGFjZXModCl7cmV0dXJuIE9sLmNoYXJzKFwiIFwiLHQpfXN0YXRpYyBzcGxpdCh0LGUpe2NvbnN0IG49ZS5sZW5ndGgscz1uZXcgTDtsZXQgaT1cIlwiK3Qscj1pLmluZGV4T2YoZSk7Zm9yKDtyPj0wOyl7Y29uc3QgdD1pLnN1YnN0cmluZygwLHIpO3MuYWRkKHQpLGk9aS5zdWJzdHJpbmcocituKSxyPWkuaW5kZXhPZihlKX1pLmxlbmd0aD4wJiZzLmFkZChpKTtjb25zdCBvPW5ldyBBcnJheShzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKylvW3RdPXMuZ2V0KHQpO3JldHVybiBvfX1PbC5ORVdMSU5FPVkuZ2V0UHJvcGVydHkoXCJsaW5lLnNlcGFyYXRvclwiKTt2YXIgdmw9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29sbGVjdGlvblV0aWw6RWwsQ29vcmRpbmF0ZUFycmF5RmlsdGVyOklsLENvb3JkaW5hdGVDb3VudEZpbHRlcjpObCxHZW9tZXRyaWNTaGFwZUZhY3Rvcnk6d2UsTnVtYmVyVXRpbDplLE9iamVjdENvdW50ZXI6d2wsUHJpb3JpdHlRdWV1ZTpMcyxTdHJpbmdVdGlsOk9sLFVuaXF1ZUNvb3JkaW5hdGVBcnJheUZpbHRlcjpubn0pOyQucHJvdG90eXBlLmdldEJvdW5kYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIGlpLmdldEJvdW5kYXJ5KHRoaXMpfSxTdC5wcm90b3R5cGUuZ2V0Qm91bmRhcnk9ZnVuY3Rpb24oKXtyZXR1cm4gaWkuZ2V0Qm91bmRhcnkodGhpcyl9LFUucHJvdG90eXBlLmVxdWFsc1RvcG89ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmVxdWFsc1RvcG8odGhpcyx0KX0sVS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dCYmUXIuZXF1YWxzVG9wbyh0aGlzLHQpfSxVLnByb3RvdHlwZS51bmlvbj1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBpby51bmlvbih0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGVvLnVuaW9uKHRoaXMsdCl9fSxVLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuIEdyLmlzVmFsaWQodGhpcyl9LFUucHJvdG90eXBlLmludGVyc2VjdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gd3IuaW50ZXJzZWN0aW9uKHRoaXMsdCl9LFUucHJvdG90eXBlLmNvdmVycz1mdW5jdGlvbih0KXtyZXR1cm4gUXIuY292ZXJzKHRoaXMsdCl9LFUucHJvdG90eXBlLmNvdmVyZWRCeT1mdW5jdGlvbih0KXtyZXR1cm4gUXIuY292ZXJzKHQsdGhpcyl9LFUucHJvdG90eXBlLnRvdWNoZXM9ZnVuY3Rpb24odCl7cmV0dXJuIFFyLnRvdWNoZXModGhpcyx0KX0sVS5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbih0KXtyZXR1cm4gUXIuaW50ZXJzZWN0cyh0aGlzLHQpfSxVLnByb3RvdHlwZS53aXRoaW49ZnVuY3Rpb24odCl7cmV0dXJuIFFyLmNvbnRhaW5zKHQsdGhpcyl9LFUucHJvdG90eXBlLm92ZXJsYXBzPWZ1bmN0aW9uKHQpe3JldHVybiBRci5vdmVybGFwcyh0aGlzLHQpfSxVLnByb3RvdHlwZS5kaXNqb2ludD1mdW5jdGlvbih0KXtyZXR1cm4gUXIuZGlzam9pbnQodGhpcyx0KX0sVS5wcm90b3R5cGUuY3Jvc3Nlcz1mdW5jdGlvbih0KXtyZXR1cm4gUXIuY3Jvc3Nlcyh0aGlzLHQpfSxVLnByb3RvdHlwZS5idWZmZXI9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHFpLmJ1ZmZlck9wKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBxaS5idWZmZXJPcCh0aGlzLHQsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBxaS5idWZmZXJPcCh0aGlzLHQsZSxuKX19LFUucHJvdG90eXBlLmNvbnZleEh1bGw9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHNuKHRoaXMpLmdldENvbnZleEh1bGwoKX0sVS5wcm90b3R5cGUucmVsYXRlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBRci5yZWxhdGUodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIFFyLnJlbGF0ZSh0aGlzLHQpLm1hdGNoZXMoZSl9fSxVLnByb3RvdHlwZS5nZXRDZW50cm9pZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KCk7Y29uc3QgdD0kZS5nZXRDZW50cm9pZCh0aGlzKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsdGhpcyl9LFUucHJvdG90eXBlLmdldEludGVyaW9yUG9pbnQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCgpO2xldCB0PW51bGw7Y29uc3QgZT10aGlzLmdldERpbWVuc2lvbigpO3Q9MD09PWU/bmV3IHVuKHRoaXMpOjE9PT1lP25ldyBobih0aGlzKTpuZXcgb24odGhpcyk7Y29uc3Qgbj10LmdldEludGVyaW9yUG9pbnQoKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKG4sdGhpcyl9LFUucHJvdG90eXBlLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHdyLnN5bURpZmZlcmVuY2UodGhpcyx0KX0sVS5wcm90b3R5cGUuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZD1mdW5jdGlvbih0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9LFUucHJvdG90eXBlLnRvVGV4dD1mdW5jdGlvbigpe3JldHVybihuZXcgV3QpLndyaXRlKHRoaXMpfSxVLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvVGV4dCgpfSxVLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtyZXR1cm4gUXIuY29udGFpbnModGhpcyx0KX0sVS5wcm90b3R5cGUuZGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gd3IuZGlmZmVyZW5jZSh0aGlzLHQpfSxVLnByb3RvdHlwZS5pc1NpbXBsZT1mdW5jdGlvbigpe3JldHVybiBuZXcgb2kodGhpcykuaXNTaW1wbGUoKX0sVS5wcm90b3R5cGUuaXNXaXRoaW5EaXN0YW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiEodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UodC5nZXRFbnZlbG9wZUludGVybmFsKCkpPmUpJiZ6aS5pc1dpdGhpbkRpc3RhbmNlKHRoaXMsdCxlKX0sVS5wcm90b3R5cGUuZGlzdGFuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHppLmRpc3RhbmNlKHRoaXMsdCl9O3QuYWxnb3JpdGhtPUVuLHQuZGVuc2lmeT13bix0LmRpc3NvbHZlPXZuLHQuZ2VvbT1UZSx0Lmdlb21ncmFwaD1jcyx0LmluZGV4PUFzLHQuaW89VnMsdC5saW5lYXJyZWY9eGwsdC5ub2Rpbmc9c2ksdC5vcGVyYXRpb249bG8sdC5wcmVjaXNpb249eG8sdC5zaW1wbGlmeT1Gbyx0LnRyaWFuZ3VsYXRlPWFsLHQudXRpbD12bCx0LnZlcnNpb249XCIyLjkuM1wifSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN0cy5taW4uanMubWFwXG4iLCIhZnVuY3Rpb24odCxpKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1pKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShpKToodD10fHxzZWxmKS5SQnVzaD1pKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQscixlLGEsaCl7IWZ1bmN0aW9uIHQobixyLGUsYSxoKXtmb3IoO2E+ZTspe2lmKGEtZT42MDApe3ZhciBvPWEtZSsxLHM9ci1lKzEsbD1NYXRoLmxvZyhvKSxmPS41Kk1hdGguZXhwKDIqbC8zKSx1PS41Kk1hdGguc3FydChsKmYqKG8tZikvbykqKHMtby8yPDA/LTE6MSksbT1NYXRoLm1heChlLE1hdGguZmxvb3Ioci1zKmYvbyt1KSksYz1NYXRoLm1pbihhLE1hdGguZmxvb3Iocisoby1zKSpmL28rdSkpO3QobixyLG0sYyxoKX12YXIgcD1uW3JdLGQ9ZSx4PWE7Zm9yKGkobixlLHIpLGgoblthXSxwKT4wJiZpKG4sZSxhKTtkPHg7KXtmb3IoaShuLGQseCksZCsrLHgtLTtoKG5bZF0scCk8MDspZCsrO2Zvcig7aChuW3hdLHApPjA7KXgtLX0wPT09aChuW2VdLHApP2kobixlLHgpOmkobiwrK3gsYSkseDw9ciYmKGU9eCsxKSxyPD14JiYoYT14LTEpfX0odCxyLGV8fDAsYXx8dC5sZW5ndGgtMSxofHxuKX1mdW5jdGlvbiBpKHQsaSxuKXt2YXIgcj10W2ldO3RbaV09dFtuXSx0W25dPXJ9ZnVuY3Rpb24gbih0LGkpe3JldHVybiB0PGk/LTE6dD5pPzE6MH12YXIgcj1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD05KSx0aGlzLl9tYXhFbnRyaWVzPU1hdGgubWF4KDQsdCksdGhpcy5fbWluRW50cmllcz1NYXRoLm1heCgyLE1hdGguY2VpbCguNCp0aGlzLl9tYXhFbnRyaWVzKSksdGhpcy5jbGVhcigpfTtmdW5jdGlvbiBlKHQsaSxuKXtpZighbilyZXR1cm4gaS5pbmRleE9mKHQpO2Zvcih2YXIgcj0wO3I8aS5sZW5ndGg7cisrKWlmKG4odCxpW3JdKSlyZXR1cm4gcjtyZXR1cm4tMX1mdW5jdGlvbiBhKHQsaSl7aCh0LDAsdC5jaGlsZHJlbi5sZW5ndGgsaSx0KX1mdW5jdGlvbiBoKHQsaSxuLHIsZSl7ZXx8KGU9cChudWxsKSksZS5taW5YPTEvMCxlLm1pblk9MS8wLGUubWF4WD0tMS8wLGUubWF4WT0tMS8wO2Zvcih2YXIgYT1pO2E8bjthKyspe3ZhciBoPXQuY2hpbGRyZW5bYV07byhlLHQubGVhZj9yKGgpOmgpfXJldHVybiBlfWZ1bmN0aW9uIG8odCxpKXtyZXR1cm4gdC5taW5YPU1hdGgubWluKHQubWluWCxpLm1pblgpLHQubWluWT1NYXRoLm1pbih0Lm1pblksaS5taW5ZKSx0Lm1heFg9TWF0aC5tYXgodC5tYXhYLGkubWF4WCksdC5tYXhZPU1hdGgubWF4KHQubWF4WSxpLm1heFkpLHR9ZnVuY3Rpb24gcyh0LGkpe3JldHVybiB0Lm1pblgtaS5taW5YfWZ1bmN0aW9uIGwodCxpKXtyZXR1cm4gdC5taW5ZLWkubWluWX1mdW5jdGlvbiBmKHQpe3JldHVybih0Lm1heFgtdC5taW5YKSoodC5tYXhZLXQubWluWSl9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gdC5tYXhYLXQubWluWCsodC5tYXhZLXQubWluWSl9ZnVuY3Rpb24gbSh0LGkpe3JldHVybiB0Lm1pblg8PWkubWluWCYmdC5taW5ZPD1pLm1pblkmJmkubWF4WDw9dC5tYXhYJiZpLm1heFk8PXQubWF4WX1mdW5jdGlvbiBjKHQsaSl7cmV0dXJuIGkubWluWDw9dC5tYXhYJiZpLm1pblk8PXQubWF4WSYmaS5tYXhYPj10Lm1pblgmJmkubWF4WT49dC5taW5ZfWZ1bmN0aW9uIHAodCl7cmV0dXJue2NoaWxkcmVuOnQsaGVpZ2h0OjEsbGVhZjohMCxtaW5YOjEvMCxtaW5ZOjEvMCxtYXhYOi0xLzAsbWF4WTotMS8wfX1mdW5jdGlvbiBkKGksbixyLGUsYSl7Zm9yKHZhciBoPVtuLHJdO2gubGVuZ3RoOylpZighKChyPWgucG9wKCkpLShuPWgucG9wKCkpPD1lKSl7dmFyIG89bitNYXRoLmNlaWwoKHItbikvZS8yKSplO3QoaSxvLG4scixhKSxoLnB1c2gobixvLG8scil9fXJldHVybiByLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSxbXSl9LHIucHJvdG90eXBlLnNlYXJjaD1mdW5jdGlvbih0KXt2YXIgaT10aGlzLmRhdGEsbj1bXTtpZighYyh0LGkpKXJldHVybiBuO2Zvcih2YXIgcj10aGlzLnRvQkJveCxlPVtdO2k7KXtmb3IodmFyIGE9MDthPGkuY2hpbGRyZW4ubGVuZ3RoO2ErKyl7dmFyIGg9aS5jaGlsZHJlblthXSxvPWkubGVhZj9yKGgpOmg7Yyh0LG8pJiYoaS5sZWFmP24ucHVzaChoKTptKHQsbyk/dGhpcy5fYWxsKGgsbik6ZS5wdXNoKGgpKX1pPWUucG9wKCl9cmV0dXJuIG59LHIucHJvdG90eXBlLmNvbGxpZGVzPWZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZGF0YTtpZighYyh0LGkpKXJldHVybiExO2Zvcih2YXIgbj1bXTtpOyl7Zm9yKHZhciByPTA7cjxpLmNoaWxkcmVuLmxlbmd0aDtyKyspe3ZhciBlPWkuY2hpbGRyZW5bcl0sYT1pLmxlYWY/dGhpcy50b0JCb3goZSk6ZTtpZihjKHQsYSkpe2lmKGkubGVhZnx8bSh0LGEpKXJldHVybiEwO24ucHVzaChlKX19aT1uLnBvcCgpfXJldHVybiExfSxyLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKHQpe2lmKCF0fHwhdC5sZW5ndGgpcmV0dXJuIHRoaXM7aWYodC5sZW5ndGg8dGhpcy5fbWluRW50cmllcyl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspdGhpcy5pbnNlcnQodFtpXSk7cmV0dXJuIHRoaXN9dmFyIG49dGhpcy5fYnVpbGQodC5zbGljZSgpLDAsdC5sZW5ndGgtMSwwKTtpZih0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKWlmKHRoaXMuZGF0YS5oZWlnaHQ9PT1uLmhlaWdodCl0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLG4pO2Vsc2V7aWYodGhpcy5kYXRhLmhlaWdodDxuLmhlaWdodCl7dmFyIHI9dGhpcy5kYXRhO3RoaXMuZGF0YT1uLG49cn10aGlzLl9pbnNlcnQobix0aGlzLmRhdGEuaGVpZ2h0LW4uaGVpZ2h0LTEsITApfWVsc2UgdGhpcy5kYXRhPW47cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLmluc2VydD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5faW5zZXJ0KHQsdGhpcy5kYXRhLmhlaWdodC0xKSx0aGlzfSxyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGE9cChbXSksdGhpc30sci5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQsaSl7aWYoIXQpcmV0dXJuIHRoaXM7Zm9yKHZhciBuLHIsYSxoPXRoaXMuZGF0YSxvPXRoaXMudG9CQm94KHQpLHM9W10sbD1bXTtofHxzLmxlbmd0aDspe2lmKGh8fChoPXMucG9wKCkscj1zW3MubGVuZ3RoLTFdLG49bC5wb3AoKSxhPSEwKSxoLmxlYWYpe3ZhciBmPWUodCxoLmNoaWxkcmVuLGkpO2lmKC0xIT09ZilyZXR1cm4gaC5jaGlsZHJlbi5zcGxpY2UoZiwxKSxzLnB1c2goaCksdGhpcy5fY29uZGVuc2UocyksdGhpc31hfHxoLmxlYWZ8fCFtKGgsbyk/cj8obisrLGg9ci5jaGlsZHJlbltuXSxhPSExKTpoPW51bGw6KHMucHVzaChoKSxsLnB1c2gobiksbj0wLHI9aCxoPWguY2hpbGRyZW5bMF0pfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS50b0JCb3g9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHIucHJvdG90eXBlLmNvbXBhcmVNaW5YPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQubWluWC1pLm1pblh9LHIucHJvdG90eXBlLmNvbXBhcmVNaW5ZPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQubWluWS1pLm1pbll9LHIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LHIucHJvdG90eXBlLmZyb21KU09OPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGE9dCx0aGlzfSxyLnByb3RvdHlwZS5fYWxsPWZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBuPVtdO3Q7KXQubGVhZj9pLnB1c2guYXBwbHkoaSx0LmNoaWxkcmVuKTpuLnB1c2guYXBwbHkobix0LmNoaWxkcmVuKSx0PW4ucG9wKCk7cmV0dXJuIGl9LHIucHJvdG90eXBlLl9idWlsZD1mdW5jdGlvbih0LGksbixyKXt2YXIgZSxoPW4taSsxLG89dGhpcy5fbWF4RW50cmllcztpZihoPD1vKXJldHVybiBhKGU9cCh0LnNsaWNlKGksbisxKSksdGhpcy50b0JCb3gpLGU7cnx8KHI9TWF0aC5jZWlsKE1hdGgubG9nKGgpL01hdGgubG9nKG8pKSxvPU1hdGguY2VpbChoL01hdGgucG93KG8sci0xKSkpLChlPXAoW10pKS5sZWFmPSExLGUuaGVpZ2h0PXI7dmFyIHM9TWF0aC5jZWlsKGgvbyksbD1zKk1hdGguY2VpbChNYXRoLnNxcnQobykpO2QodCxpLG4sbCx0aGlzLmNvbXBhcmVNaW5YKTtmb3IodmFyIGY9aTtmPD1uO2YrPWwpe3ZhciB1PU1hdGgubWluKGYrbC0xLG4pO2QodCxmLHUscyx0aGlzLmNvbXBhcmVNaW5ZKTtmb3IodmFyIG09ZjttPD11O20rPXMpe3ZhciBjPU1hdGgubWluKG0rcy0xLHUpO2UuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZCh0LG0sYyxyLTEpKX19cmV0dXJuIGEoZSx0aGlzLnRvQkJveCksZX0sci5wcm90b3R5cGUuX2Nob29zZVN1YnRyZWU9ZnVuY3Rpb24odCxpLG4scil7Zm9yKDtyLnB1c2goaSksIWkubGVhZiYmci5sZW5ndGgtMSE9PW47KXtmb3IodmFyIGU9MS8wLGE9MS8wLGg9dm9pZCAwLG89MDtvPGkuY2hpbGRyZW4ubGVuZ3RoO28rKyl7dmFyIHM9aS5jaGlsZHJlbltvXSxsPWYocyksdT0obT10LGM9cywoTWF0aC5tYXgoYy5tYXhYLG0ubWF4WCktTWF0aC5taW4oYy5taW5YLG0ubWluWCkpKihNYXRoLm1heChjLm1heFksbS5tYXhZKS1NYXRoLm1pbihjLm1pblksbS5taW5ZKSktbCk7dTxhPyhhPXUsZT1sPGU/bDplLGg9cyk6dT09PWEmJmw8ZSYmKGU9bCxoPXMpfWk9aHx8aS5jaGlsZHJlblswXX12YXIgbSxjO3JldHVybiBpfSxyLnByb3RvdHlwZS5faW5zZXJ0PWZ1bmN0aW9uKHQsaSxuKXt2YXIgcj1uP3Q6dGhpcy50b0JCb3godCksZT1bXSxhPXRoaXMuX2Nob29zZVN1YnRyZWUocix0aGlzLmRhdGEsaSxlKTtmb3IoYS5jaGlsZHJlbi5wdXNoKHQpLG8oYSxyKTtpPj0wJiZlW2ldLmNoaWxkcmVuLmxlbmd0aD50aGlzLl9tYXhFbnRyaWVzOyl0aGlzLl9zcGxpdChlLGkpLGktLTt0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMocixlLGkpfSxyLnByb3RvdHlwZS5fc3BsaXQ9ZnVuY3Rpb24odCxpKXt2YXIgbj10W2ldLHI9bi5jaGlsZHJlbi5sZW5ndGgsZT10aGlzLl9taW5FbnRyaWVzO3RoaXMuX2Nob29zZVNwbGl0QXhpcyhuLGUscik7dmFyIGg9dGhpcy5fY2hvb3NlU3BsaXRJbmRleChuLGUsciksbz1wKG4uY2hpbGRyZW4uc3BsaWNlKGgsbi5jaGlsZHJlbi5sZW5ndGgtaCkpO28uaGVpZ2h0PW4uaGVpZ2h0LG8ubGVhZj1uLmxlYWYsYShuLHRoaXMudG9CQm94KSxhKG8sdGhpcy50b0JCb3gpLGk/dFtpLTFdLmNoaWxkcmVuLnB1c2gobyk6dGhpcy5fc3BsaXRSb290KG4sbyl9LHIucHJvdG90eXBlLl9zcGxpdFJvb3Q9ZnVuY3Rpb24odCxpKXt0aGlzLmRhdGE9cChbdCxpXSksdGhpcy5kYXRhLmhlaWdodD10LmhlaWdodCsxLHRoaXMuZGF0YS5sZWFmPSExLGEodGhpcy5kYXRhLHRoaXMudG9CQm94KX0sci5wcm90b3R5cGUuX2Nob29zZVNwbGl0SW5kZXg9ZnVuY3Rpb24odCxpLG4pe2Zvcih2YXIgcixlLGEsbyxzLGwsdSxtPTEvMCxjPTEvMCxwPWk7cDw9bi1pO3ArKyl7dmFyIGQ9aCh0LDAscCx0aGlzLnRvQkJveCkseD1oKHQscCxuLHRoaXMudG9CQm94KSx2PShlPWQsYT14LG89dm9pZCAwLHM9dm9pZCAwLGw9dm9pZCAwLHU9dm9pZCAwLG89TWF0aC5tYXgoZS5taW5YLGEubWluWCkscz1NYXRoLm1heChlLm1pblksYS5taW5ZKSxsPU1hdGgubWluKGUubWF4WCxhLm1heFgpLHU9TWF0aC5taW4oZS5tYXhZLGEubWF4WSksTWF0aC5tYXgoMCxsLW8pKk1hdGgubWF4KDAsdS1zKSksTT1mKGQpK2YoeCk7djxtPyhtPXYscj1wLGM9TTxjP006Yyk6dj09PW0mJk08YyYmKGM9TSxyPXApfXJldHVybiByfHxuLWl9LHIucHJvdG90eXBlLl9jaG9vc2VTcGxpdEF4aXM9ZnVuY3Rpb24odCxpLG4pe3ZhciByPXQubGVhZj90aGlzLmNvbXBhcmVNaW5YOnMsZT10LmxlYWY/dGhpcy5jb21wYXJlTWluWTpsO3RoaXMuX2FsbERpc3RNYXJnaW4odCxpLG4scik8dGhpcy5fYWxsRGlzdE1hcmdpbih0LGksbixlKSYmdC5jaGlsZHJlbi5zb3J0KHIpfSxyLnByb3RvdHlwZS5fYWxsRGlzdE1hcmdpbj1mdW5jdGlvbih0LGksbixyKXt0LmNoaWxkcmVuLnNvcnQocik7Zm9yKHZhciBlPXRoaXMudG9CQm94LGE9aCh0LDAsaSxlKSxzPWgodCxuLWksbixlKSxsPXUoYSkrdShzKSxmPWk7ZjxuLWk7ZisrKXt2YXIgbT10LmNoaWxkcmVuW2ZdO28oYSx0LmxlYWY/ZShtKTptKSxsKz11KGEpfWZvcih2YXIgYz1uLWktMTtjPj1pO2MtLSl7dmFyIHA9dC5jaGlsZHJlbltjXTtvKHMsdC5sZWFmP2UocCk6cCksbCs9dShzKX1yZXR1cm4gbH0sci5wcm90b3R5cGUuX2FkanVzdFBhcmVudEJCb3hlcz1mdW5jdGlvbih0LGksbil7Zm9yKHZhciByPW47cj49MDtyLS0pbyhpW3JdLHQpfSxyLnByb3RvdHlwZS5fY29uZGVuc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBpPXQubGVuZ3RoLTEsbj12b2lkIDA7aT49MDtpLS0pMD09PXRbaV0uY2hpbGRyZW4ubGVuZ3RoP2k+MD8obj10W2ktMV0uY2hpbGRyZW4pLnNwbGljZShuLmluZGV4T2YodFtpXSksMSk6dGhpcy5jbGVhcigpOmEodFtpXSx0aGlzLnRvQkJveCl9LHJ9KTtcbiIsIi8vQHRzLWNoZWNrXG5cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEFnZW50UG9pbnQge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBzeD0wLCBzeT0wKSB7XG5cbiAgICAgICAgLy9wb3NpdGlvblxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5XG5cbiAgICAgICAgLy9zcGVlZFxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnN4ID0gc3hcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc3kgPSBzeVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zID0gdW5kZWZpbmVkXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNhID0gdW5kZWZpbmVkXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FnZW50UG9pbnR9IGFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgdG8gYW5vdGhlciBhZ2VudC5cbiAgICAgKi9cbiAgICBkKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZFAoYS54LCBhLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSB0byBhIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGRQKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguaHlwb3QoKHggLSB0aGlzLngpLCAoeSAtIHRoaXMueSkpO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAqIFNldCByYW5kb20gc3BlZWRcbiAgICAqIFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWRcbiAgICAqL1xuICAgIHNldFJhbmRvbVNwZWVkKG1pblNwZWVkID0gMCwgbWF4U3BlZWQgPSAwLjEpIHtcbiAgICAgICAgdGhpcy5zID0gbWluU3BlZWQgKyBNYXRoLnJhbmRvbSgpICogKG1heFNwZWVkIC0gbWluU3BlZWQpO1xuICAgICAgICB0aGlzLnNhID0gMiAqIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJO1xuICAgICAgICB0aGlzLnN4ID0gdGhpcy5zICogTWF0aC5jb3ModGhpcy5zYSlcbiAgICAgICAgdGhpcy5zeSA9IHRoaXMucyAqIE1hdGguc2luKHRoaXMuc2EpXG4gICAgfVxuXG4gICAgLyoqICovXG4gICAgY29tcHV0ZVNwZWVkKCkge1xuICAgICAgICB0aGlzLnMgPSBNYXRoLmh5cG90KHRoaXMuc3gsIHRoaXMuc3kpO1xuICAgICAgICByZXR1cm4gdGhpcy5zXG4gICAgfVxuXG4gICAgLyoqICovXG4gICAgY29tcHV0ZVNwZWVkQW5nbGUoKSB7XG4gICAgICAgIHRoaXMuc2EgPSBNYXRoLmF0YW4yKHRoaXMuc3ksIHRoaXMuc3gpO1xuICAgICAgICByZXR1cm4gdGhpcy5zYVxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbi8qKiBAdHlwZWRlZiB7IHt4TWluOiBudW1iZXIsIHhNYXg6IG51bWJlciwgeU1pbjogbnVtYmVyLCB5TWF4OiBudW1iZXJ9IH0gRW52ZWxvcGUgKi9cblxuaW1wb3J0IHsgem9vbSBhcyBkM3pvb20sIHpvb21JZGVudGl0eSB9IGZyb20gXCJkMy16b29tXCI7XG5pbXBvcnQgeyBzZWxlY3QgYXMgZDNzZWxlY3QgfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbi8qKlxuICogQSBIVE1MIGNhbnZhcyBmb3IgZ2VvIGRhdGEgZGlzcGxheSwgZW5oYW5jZWQgd2l0aCB6b29tIGFuZCBwYW4gY2FwYWJpbGl0aWVzLlxuICogXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBHZW9DYW52YXMge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNlbnRlciBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6ZiBUaGUgem9vbSBmYWN0b3IgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhc0lkID0gXCJ2YWNhbnZhc1wiLCBjZW50ZXIgPSB1bmRlZmluZWQsIHpmID0gMSkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLnc7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaDtcblxuICAgICAgICAvKipAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAvLyBzZXQgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXJcbiAgICAgICAgdGhpcy5zZXRDZW50ZXIoY2VudGVyIHx8IHsgeDogdGhpcy53ICogMC41LCB5OiB0aGlzLmggKiAwLjUgfSlcblxuICAgICAgICAvLyBzZXQgem9vbSBmYWN0b3I6IHBpeGVsIHNpemUsIGluIG0vcGl4XG4gICAgICAgIHRoaXMuc2V0WmYoemYpO1xuXG4gICAgICAgIC8vZXh0ZW50XG4gICAgICAgIC8qKiBAdHlwZSB7RW52ZWxvcGV9ICovXG4gICAgICAgIHRoaXMuZXh0R2VvID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG5cbiAgICAgICAgLy9yZWx5IG9uIGQzIHpvb20gZm9yIHBhbi96b29tXG4gICAgICAgIGxldCB0UCA9IHpvb21JZGVudGl0eVxuICAgICAgICBkM3NlbGVjdCh0aGlzLmNhbnZhcykuY2FsbChcbiAgICAgICAgICAgIGQzem9vbSgpLm9uKFwiem9vbVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSB0UC5rIC8gdC5rXG4gICAgICAgICAgICAgICAgaWYgKGYgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3BhblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHRQLnggLSB0LnhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSB0UC55IC0gdC55XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFuKGR4ICogdGhpcy5nZXRaZigpLCAtZHkgKiB0aGlzLmdldFpmKCkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2UgPSBlLnNvdXJjZUV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2UgaW5zdGFuY2VvZiBXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3pvb20gYXQgdGhlIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20oZiwgdGhpcy5waXhUb0dlb1goZS5zb3VyY2VFdmVudC5vZmZzZXRYKSwgdGhpcy5waXhUb0dlb1koZS5zb3VyY2VFdmVudC5vZmZzZXRZKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSB0b3VjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHggPSAwLCB0eSA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR0IG9mIHNlLnRhcmdldFRvdWNoZXMpIHsgdHggKz0gdHQuY2xpZW50WDsgdHkgKz0gdHQuY2xpZW50WSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCAvPSBzZS50YXJnZXRUb3VjaGVzLmxlbmd0aDsgdHkgLz0gc2UudGFyZ2V0VG91Y2hlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vem9vbSBhdCB0aGlzIGF2ZXJhZ2UgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbShmLCB0aGlzLnBpeFRvR2VvWCh0eCksIHRoaXMucGl4VG9HZW9ZKHR5KSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0UCA9IHRcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSB2IEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyICovXG4gICAgc2V0Q2VudGVyKHYpIHsgdGhpcy5jZW50ZXIgPSB2OyB9XG4gICAgLyoqIEByZXR1cm5zIHt7eDpudW1iZXIseTpudW1iZXJ9fSBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciAqL1xuICAgIGdldENlbnRlcigpIHsgcmV0dXJuIHRoaXMuY2VudGVyOyB9XG5cbiAgICAvKiogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHpvb20gZmFjdG9yIChwaXhlbCBzaXplLCBpbiBncm91bmQgbSkgKi9cbiAgICBzZXRaZih2KSB7IHRoaXMuemYgPSB2OyB9XG4gICAgLyoqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pICovXG4gICAgZ2V0WmYoKSB7IHJldHVybiB0aGlzLnpmOyB9XG5cblxuXG5cbiAgICAvKiogSW5pdGlhbGlzZSBjYW52YXMgdHJhbnNmb3JtIHdpdGggaWRlbnRpdHkgdHJhbnNmb3JtYXRpb24uICovXG4gICAgaW5pdENhbnZhc1RyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIH1cblxuICAgIC8qKiBJbml0aWFsaXNlIGNhbnZhcyB0cmFuc2Zvcm0gd2l0aCBnZW8gdG8gc2NyZWVuIHRyYW5zZm9ybWF0aW9uLCBzbyB0aGF0IGdlbyBvYmplY3RzIGNhbiBiZSBkcmF3biBkaXJlY3RseSBpbiBnZW8gY29vcmRpbmF0ZXMuICovXG4gICAgc2V0Q2FudmFzVHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBrID0gMSAvIHRoaXMuZ2V0WmYoKTtcbiAgICAgICAgY29uc3QgdHggPSAtdGhpcy5jZW50ZXIueCAvIHRoaXMuZ2V0WmYoKSArIHRoaXMudyAqIDAuNTtcbiAgICAgICAgY29uc3QgdHkgPSB0aGlzLmNlbnRlci55IC8gdGhpcy5nZXRaZigpICsgdGhpcy5oICogMC41O1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oaywgMCwgMCwgLWssIHR4LCB0eSk7XG4gICAgfVxuXG5cbiAgICAvKiogVGhlIGZ1bmN0aW9uIHNwZWNpZnlpbmcgaG93IHRvIGRyYXcgdGhlIG1hcC4gKi9cbiAgICByZWRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIHJlZHJhdyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGFwcCBzY3JlZW4uIFRvIGJlIHVzZWQgYmVmb3JlIGEgcmVkcmF3IGZvciBleGFtcGxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBcbiAgICAgKi9cbiAgICBjbGVhcihjb2xvciA9IFwid2hpdGVcIikge1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpO1xuICAgIH1cblxuICAgIC8vY29udmVyc2lvbiBmdW5jdGlvbnNcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBHZW8geCBjb29yZGluYXRlLCBpbiBtLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNjcmVlbiB4IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAqL1xuICAgIGdlb1RvUGl4WCh4R2VvKSB7IHJldHVybiAoeEdlbyAtIHRoaXMuY2VudGVyLngpIC8gdGhpcy5nZXRaZigpICsgdGhpcy53ICogMC41OyB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlHZW8gR2VvIHkgY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTY3JlZW4geSBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgKi9cbiAgICBnZW9Ub1BpeFkoeUdlbykgeyByZXR1cm4gLSh5R2VvIC0gdGhpcy5jZW50ZXIueSkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLmggKiAwLjU7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBTY3JlZW4geCBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHggY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAqL1xuICAgIHBpeFRvR2VvWCh4KSB7IHJldHVybiAoeCAtIHRoaXMudyAqIDAuNSkgKiB0aGlzLmdldFpmKCkgKyB0aGlzLmNlbnRlci54OyB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgU2NyZWVuIHkgY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEdlbyB5IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgKi9cbiAgICBwaXhUb0dlb1koeSkgeyByZXR1cm4gLSh5IC0gdGhpcy5oICogMC41KSAqIHRoaXMuZ2V0WmYoKSArIHRoaXMuY2VudGVyLnk7IH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeEdlb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeUdlb1xuICAgICAqL1xuICAgIHBhbihkeEdlbywgZHlHZW8pIHtcbiAgICAgICAgLy9UT0RPIGZvcmNlIGV4dGVuZCB0byByZW1haW5cbiAgICAgICAgdGhpcy5jZW50ZXIueCArPSBkeEdlbztcbiAgICAgICAgdGhpcy5jZW50ZXIueSArPSBkeUdlbztcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRHZW8oKVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb20uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYgVGhlIHpvb20gZmFjdG9yLCB3aXRoaW4gXTAsIEluZmluaXR5XS4gMSBpcyBmb3Igbm8gY2hhbmdlLiA8MSB0byB6b29tLWluLCA+MSB0byB6b29tLW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBUaGUgeCBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUdlbyBUaGUgeSBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cbiAgICAgKi9cbiAgICB6b29tKGYgPSAxLCB4R2VvID0gdGhpcy5jZW50ZXIueCwgeUdlbyA9IHRoaXMuY2VudGVyLnkpIHtcbiAgICAgICAgLy9UT0RPIGZvcmNlIGV4dGVuZCB0byByZW1haW5cbiAgICAgICAgdGhpcy5zZXRaZihmICogdGhpcy5nZXRaZigpKTtcbiAgICAgICAgdGhpcy5jZW50ZXIueCArPSAoeEdlbyAtIHRoaXMuY2VudGVyLngpICogKDEgLSBmKVxuICAgICAgICB0aGlzLmNlbnRlci55ICs9ICh5R2VvIC0gdGhpcy5jZW50ZXIueSkgKiAoMSAtIGYpXG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luUHggXG4gICAgICogQHJldHVybnMge0VudmVsb3BlfSBUaGUgZW52ZWxvcGUgb2YgdGhlIHZpZXcsIGluIGdlbyBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICB1cGRhdGVFeHRlbnRHZW8obWFyZ2luUHggPSAyMCkge1xuICAgICAgICB0aGlzLmV4dEdlbyA9IHtcbiAgICAgICAgICAgIHhNaW46IHRoaXMucGl4VG9HZW9YKC1tYXJnaW5QeCksXG4gICAgICAgICAgICB4TWF4OiB0aGlzLnBpeFRvR2VvWCh0aGlzLncgKyBtYXJnaW5QeCksXG4gICAgICAgICAgICB5TWluOiB0aGlzLnBpeFRvR2VvWSh0aGlzLmggKyBtYXJnaW5QeCksXG4gICAgICAgICAgICB5TWF4OiB0aGlzLnBpeFRvR2VvWSgtbWFyZ2luUHgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0R2VvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgaGFzIHRvIGJlIGRyYXduXG4gICAgICogXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBvYmogXG4gICAgICovXG4gICAgdG9EcmF3KG9iaikge1xuICAgICAgICBpZiAob2JqLnggPCB0aGlzLmV4dEdlby54TWluKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvYmoueCA+IHRoaXMuZXh0R2VvLnhNYXgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9iai55IDwgdGhpcy5leHRHZW8ueU1pbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob2JqLnkgPiB0aGlzLmV4dEdlby55TWF4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuXG4vL3NlZSBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaFxuaW1wb3J0IFJCdXNoIGZyb20gJ3JidXNoJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgY2xhc3MgU3BhdGlhbEluZGV4IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjbGFzcyBNeVJCdXNoIGV4dGVuZHMgUkJ1c2gge1xuICAgICAgICAgICAgLyoqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gb2JqICAqL1xuICAgICAgICAgICAgdG9CQm94KG9iaikgeyByZXR1cm4geyBtaW5YOiBvYmoueCwgbWluWTogb2JqLnksIG1heFg6IG9iai54LCBtYXhZOiBvYmoueSB9OyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYSBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYiBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29tcGFyZU1pblgoYSwgYikgeyByZXR1cm4gYS54IC0gYi54OyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYSBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYiBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29tcGFyZU1pblkoYSwgYikgeyByZXR1cm4gYS55IC0gYi55OyB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge015UkJ1c2h9ICovXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBNeVJCdXNoKCk7XG4gICAgfVxuXG4gICAgLy9UT0RPIGJ1bGsgcmVtb3ZlID9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4bWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHltaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5bWF4XG4gICAgICogQHJldHVybiB7QXJyYXkuPFQ+fVxuICAgICAqL1xuICAgIGdldCh4bWluLCB5bWluLCB4bWF4LCB5bWF4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuc2VhcmNoKHtcbiAgICAgICAgICAgIG1pblg6IHhtaW4sXG4gICAgICAgICAgICBtaW5ZOiB5bWluLFxuICAgICAgICAgICAgbWF4WDogeG1heCxcbiAgICAgICAgICAgIG1heFk6IHltYXhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUfSBvYmpcbiAgICAgKi9cbiAgICBpbnNlcnQob2JqKSB7XG4gICAgICAgIHRoaXMudHJlZS5pbnNlcnQob2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWxrIGluc2VydFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBvYmpzXG4gICAgICovXG4gICAgbG9hZChvYmpzKSB7XG4gICAgICAgIHRoaXMudHJlZS5sb2FkKG9ianMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VH0gb2JqXG4gICAgICovXG4gICAgcmVtb3ZlKG9iaikge1xuICAgICAgICB0aGlzLnRyZWUucmVtb3ZlKG9iailcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy50cmVlLmNsZWFyKClcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge09iamVjdC48PywgVD59IG9ialxuICogQHJldHVybnMge0FycmF5LjxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG9ialRvQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIG91dC5wdXNoKG9ialtrZXldKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheS48VD59IGFyclxuICogQHBhcmFtIHtUfSBvYmpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXNnIFxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gZnVuY3Rpb24gKGFyciwgb2JqLCBtc2cgPSB0cnVlKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2Yob2JqKTtcbiAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgZWxzZVxuICAgICAgICBpZiAobXNnKSBjb25zb2xlLmxvZyhcIkltcG9zc2libGUgdG8gcmVtb3ZlIGVsZW1lbnQgbm90IHByZXNlbnQgaW4gYXJyYXkuXCIpO1xufTtcblxuLyoqXG4gKiBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyXG4gKiBAcGFyYW0ge0FycmF5LjxUPn0gb2JqcyBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXNnIFxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRnJvbUFycmF5UyA9IGZ1bmN0aW9uIChhcnIsIG9ianMsIG1zZyA9IHRydWUpIHtcbiAgICBmb3IgKGxldCBvYmogb2Ygb2JqcylcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGFyciwgb2JqLCBtc2cpXG59O1xuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNlYSB9IGZyb20gXCIuL1NlYVwiXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgQWdlbnRQb2ludCB9IGZyb20gXCIuLi9iYXNlL0FnZW50UG9pbnRcIjtcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcblxuLyoqICovXG5leHBvcnQgY2xhc3MgU2FyZGluIGV4dGVuZHMgQWdlbnRQb2ludCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NlYX0gc2VhIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3kgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VhLCB4ID0gc2VhLncgKiBNYXRoLnJhbmRvbSgpLCB5ID0gc2VhLmggKiBNYXRoLnJhbmRvbSgpLCBzeCA9IHVuZGVmaW5lZCwgc3kgPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvL1xuICAgICAgICBzdXBlcih4LCB5LCBzeCwgc3kpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtTZWF9ICovXG4gICAgICAgIHRoaXMuc2VhID0gc2VhO1xuXG4gICAgICAgIC8vcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHggPCAwID8gMCA6IHggPiBzZWEudyA/IHNlYS53IDogeFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geSA8IDAgPyAwIDogeSA+IHNlYS5oID8gc2VhLmggOiB5XG5cbiAgICAgICAgLy9zcGVlZFxuICAgICAgICBpZiAoIXN4ICYmICFzeSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSYW5kb21TcGVlZCgwLCB0aGlzLnNlYS5WX01BWClcblxuICAgICAgICAgICAgLy9hY2NlbGVyYXRpb25cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgdGhpcy5heCA9IDBcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgdGhpcy5heSA9IDBcblxuICAgICAgICAgICAgLy9saXN0IG9mIHNhcmRpbnMgaW4gdmlzaW9uIGZpZWxkXG4gICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICAgICAgdGhpcy5vYnMgPSBbXVxuICAgICAgICAgICAgLy9saXN0IG9mIHNhcmRpbnMgaW4gY29sbGlzaW9uIGZpZWxkXG4gICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICAgICAgdGhpcy5jb2wgPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48U2FyZGluPn0gc2luZGV4IFxuICAgICAqL1xuICAgIG9ic2VydmUoc2luZGV4KSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTZWF9ICovXG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnNlYVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3QgZE8gPSBzLkRfT0JTXG5cbiAgICAgICAgLy9pbml0aWFsaXNlIGxpc3RzXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMub2JzID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMuY29sID0gW107XG5cbiAgICAgICAgLy9nZXQgc2FyZGlucyBhcm91bmQgdXNpbmcgc3BhdGlhbCBpbmRleFxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICBjb25zdCBzcyA9IHNpbmRleC5nZXQodGhpcy54IC0gZE8sIHRoaXMueSAtIGRPLCB0aGlzLnggKyBkTywgdGhpcy55ICsgZE8pO1xuXG4gICAgICAgIC8vZ2V0IHNhcmRpbnMgaW4gb2JzZXJ2YXRpb24gYW5kIGNvbGxpc2lvbiBmaWVsZHNcbiAgICAgICAgZm9yIChsZXQgZiBvZiBzcykge1xuICAgICAgICAgICAgaWYgKGYgPT0gdGhpcykgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5kKGYpIDw9IHMuRF9DT0wpXG4gICAgICAgICAgICAgICAgdGhpcy5jb2wucHVzaChmKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmQoZikgPD0gZE8pIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGFuZ2xlXG4gICAgICAgICAgICAgICAgbGV0IGRhID0gTWF0aC5hdGFuMihmLnkgLSB0aGlzLnksIGYueCAtIHRoaXMueCkgLSB0aGlzLnNhO1xuICAgICAgICAgICAgICAgIGlmIChkYSA+IE1hdGguUEkpIGRhIC09IDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhIDw9IC1NYXRoLlBJKSBkYSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgICAgICAgICBkYSA9IE1hdGguYWJzKGRhKTtcbiAgICAgICAgICAgICAgICBpZiAoZGEgPiBzLkFfT0JTICogMC41KSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9icy5wdXNoKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9pbml0aWFsaXNlIGFjY2VsZXJhdGlvblxuICAgICAgICB0aGlzLmF4ID0gMDsgdGhpcy5heSA9IDA7XG5cbiAgICAgICAgLy9jb2xsaXNpb246IHJlcHVsc2lvblxuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuY29sKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5kKGYpO1xuICAgICAgICAgICAgY29uc3QgYSA9IDEuMCAqICgxIC8gKGQgKiBkKSAtIDEgLyAocy5EX0NPTCAqIHMuRF9DT0wpKTtcbiAgICAgICAgICAgIHRoaXMuYXggKz0gYSAqICh0aGlzLnggLSBmLngpIC8gZDtcbiAgICAgICAgICAgIHRoaXMuYXkgKz0gYSAqICh0aGlzLnkgLSBmLnkpIC8gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvd2FyZCB0YXJnZXQgc3BlZWRcbiAgICAgICAgY29uc3QgZHYgPSAocy5WX1RBUkdFVCAtIHRoaXMucykgKiAwLjAxO1xuICAgICAgICB0aGlzLmF4ICs9IGR2ICogdGhpcy5zeCAvIHRoaXMucztcbiAgICAgICAgdGhpcy5heSArPSBkdiAqIHRoaXMuc3kgLyB0aGlzLnM7XG5cbiAgICAgICAgLy90b3dhcmQgdGhlIG9ic2VydmVkIG1lYW4gcG9zaXRpb25cbiAgICAgICAgLyppZihvYnMuc2l6ZSgpPjEpe1xuICAgICAgICAgICAgZG91YmxlIHhuPTAseW49MDtcbiAgICAgICAgICAgIGZvcihTYXJkaW4gczpvYnMpe1xuICAgICAgICAgICAgICAgIHhuKz1zLng7XG4gICAgICAgICAgICAgICAgeW4rPXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhuPXhuL29icy5zaXplKCk7XG4gICAgICAgICAgICB5bj15bi9vYnMuc2l6ZSgpO1xuICAgICAgICAgICAgZG91YmxlIGQ9TWF0aC5oeXBvdCh4bi14LHluLXkpO1xuICAgICAgICAgICAgYXgrPS0wLjEqKHgteG4pL2Q7XG4gICAgICAgICAgICBheSs9LTAuMSooeS15bikvZDtcbiAgICAgICAgfSovXG5cbiAgICAgICAgLy90b3dhcmQgdGhlIG9ic2VydmVkIHNwZWVkXG4gICAgICAgIGNvbnN0IHQgPSAwLjk7XG4gICAgICAgIGlmICh0aGlzLm9icy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgZHN4ID0gMCwgZHN5ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5vYnMpIHtcbiAgICAgICAgICAgICAgICBkc3ggKz0gcy5zeDtcbiAgICAgICAgICAgICAgICBkc3kgKz0gcy5zeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzeCA9ICh0IC0gMSkgKiB0aGlzLnN4ICsgKDEgLSB0KSAqIGRzeCAvIHRoaXMub2JzLmxlbmd0aDtcbiAgICAgICAgICAgIGRzeSA9ICh0IC0gMSkgKiB0aGlzLnN5ICsgKDEgLSB0KSAqIGRzeSAvIHRoaXMub2JzLmxlbmd0aDtcblxuICAgICAgICAgICAgY29uc3QgYSA9IDAuMTtcbiAgICAgICAgICAgIHRoaXMuYXggKz0gYSAqIGRzeDtcbiAgICAgICAgICAgIHRoaXMuYXkgKz0gYSAqIGRzeTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYXZvaWQgc2hhcmtcbiAgICAgICAgY29uc3Qgc2ggPSBzLnNoYXJrO1xuICAgICAgICBpZiAoc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IE1hdGguaHlwb3QoKHNoLnggLSB0aGlzLngpLCAoc2gueSAtIHRoaXMueSkpO1xuICAgICAgICAgICAgaWYgKGQgPD0gcy5EX09CUykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSA1LjAgKiAoMSAvIChkICogZCkgLSAxIC8gKGRPICogZE8pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF4ICs9IGEgKiAodGhpcy54IC0gc2gueCkgLyBkO1xuICAgICAgICAgICAgICAgIHRoaXMuYXkgKz0gYSAqICh0aGlzLnkgLSBzaC55KSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgbW92ZSh0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHNwZWVkXG4gICAgICAgIHRoaXMuc3ggKz0gdGhpcy5heCAqIHRpbWVTdGVwTXMgKyAoMSAtIDIgKiBNYXRoLnJhbmRvbSgpKSAqIDAuMDI7XG4gICAgICAgIHRoaXMuc3kgKz0gdGhpcy5heSAqIHRpbWVTdGVwTXMgKyAoMSAtIDIgKiBNYXRoLnJhbmRvbSgpKSAqIDAuMDI7XG4gICAgICAgIHRoaXMucyA9IHRoaXMuY29tcHV0ZVNwZWVkKClcbiAgICAgICAgaWYgKHRoaXMucyA+IHRoaXMuc2VhLlZfTUFYKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLnNlYS5WX01BWDtcbiAgICAgICAgICAgIHRoaXMuc3ggPSB0aGlzLnNlYS5WX01BWCAqIE1hdGguY29zKHRoaXMuc2EpO1xuICAgICAgICAgICAgdGhpcy5zeSA9IHRoaXMuc2VhLlZfTUFYICogTWF0aC5zaW4odGhpcy5zYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHBvc2l0aW9uXG4gICAgICAgIHRoaXMueCArPSB0aGlzLnN4ICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuc3kgKiB0aW1lU3RlcE1zO1xuXG4gICAgICAgIC8vbGltaXRcbiAgICAgICAgaWYgKHRoaXMueCA8IDApIHRoaXMueCA9IHRoaXMuc2VhLnc7XG4gICAgICAgIGlmICh0aGlzLnkgPCAwKSB0aGlzLnkgPSB0aGlzLnNlYS5oO1xuICAgICAgICBpZiAodGhpcy54ID4gdGhpcy5zZWEudykgdGhpcy54ID0gMDtcbiAgICAgICAgaWYgKHRoaXMueSA+IHRoaXMuc2VhLmgpIHRoaXMueSA9IDA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGEgc2FyZGluIGJvZHlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5KGNwLCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgY29uc3QgYyA9IE1hdGguZmxvb3IoMjU1ICogTWF0aC5hYnModGhpcy5zYSkgLyBNYXRoLlBJKTtcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcInJnYigyNTUsIDI1NSwgXCIgKyBjICsgXCIpXCJcbiAgICAgICAgY29uc3QgYSA9IGxlbmd0aCAvIHRoaXMucztcbiAgICAgICAgY29uc3QgZHggPSBhICogdGhpcy5zeCAqIDAuNTtcbiAgICAgICAgY29uc3QgZHkgPSBhICogdGhpcy5zeSAqIDAuNTtcblxuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIubW92ZVRvKHRoaXMueCAtIGR4LCB0aGlzLnkgLSBkeSk7XG4gICAgICAgIGMyLmxpbmVUbyh0aGlzLnggKyBkeCwgdGhpcy55ICsgZHkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBzYXJkaW4gdmlzaW9uIGZpZWxkXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5VmlzaW9uRmllbGQoY3AsIGZpbGxTdHlsZSwgbGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5tb3ZlVG8odGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuc2VhLkRfT0JTIC8gY3AuZ2V0WmYoKSxcbiAgICAgICAgICAgIHRoaXMuc2EgLSB0aGlzLnNlYS5BX09CUyAqIDAuNSxcbiAgICAgICAgICAgIHRoaXMuc2EgKyB0aGlzLnNlYS5BX09CUyAqIDAuNVxuICAgICAgICApO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuZmlsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgc2FyZGluIHZpc2lvbiBsaW5rc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5VmlzaW9uTGlua3MoY3AsIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBmb3IgKGxldCBzYTIgb2YgdGhpcy5vYnMpIHtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIubW92ZVRvKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGMyLmxpbmVUbyhzYTIueCwgc2EyLnkpO1xuICAgICAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgc2FyZGluIGNvbGxpc2lvbiBmaWVsZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5Q29sbGlzaW9uRmllbGQoY3AsIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIuYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnNlYS5EX0NPTCAqIDAuNSAvIGNwLmdldFpmKCksIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLnN0cm9rZSgpO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNhcmRpbiB9IGZyb20gJy4vU2FyZGluJztcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcbmltcG9ydCB7IHJlbW92ZUZyb21BcnJheSB9IGZyb20gJy4uL2Jhc2UvbGliJztcblxuLyoqICovXG5leHBvcnQgY2xhc3MgU2VhIHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoIFxuICAgICAqLyAgICAgICAgLy9nZXQgMTAgcmFuZG9tIGxvY2F0aW9uc1xuXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8vVE9ETyBzaG91bGQgYmVjb21lIHN0YXRpYyBhdHRyaWJ1dGVzIG9mIFNhcmRpbiBjbGFzc1xuXG4gICAgICAgIC8vb2JzZXJ2YXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuRF9PQlMgPSA1MFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5BX09CUyA9IDIwMCAqIE1hdGguUEkgLyAxODBcblxuICAgICAgICAvL2NvbGxpc2lvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5EX0NPTCA9IDEwXG5cbiAgICAgICAgLy9zcGVlZFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5WX1RBUkdFVCA9IDAuM1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5WX01BWCA9IDAuNlxuXG4gICAgICAgIC8vc2hhcmtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuRF9TSEFSS19FQVQgPSAxMlxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5FQVRFTl9TQVJESU5fTkIgPSAwXG5cblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5maXNoID0gW11cblxuICAgICAgICAvL1RPRE9cbiAgICAgICAgdGhpcy5zaGFyayA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5raWxsZWQgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBzdGVwKHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vaW5pXG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5maXNoKSB7XG4gICAgICAgICAgICBmLmNvbXB1dGVTcGVlZCgpXG4gICAgICAgICAgICBmLmNvbXB1dGVTcGVlZEFuZ2xlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbWFrZSBzcGF0aWFsIGluZGV4XG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxTYXJkaW4+fSAqL1xuICAgICAgICBjb25zdCBzaW5kZXggPSBuZXcgU3BhdGlhbEluZGV4KCk7XG4gICAgICAgIHNpbmRleC5sb2FkKHRoaXMuZmlzaClcblxuICAgICAgICAvL29ic2VydmVcbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmZpc2gpXG4gICAgICAgICAgICBmLm9ic2VydmUoc2luZGV4KTtcblxuICAgICAgICAvL3NoYXJrIGVhdCBmaXNoXG4gICAgICAgIHRoaXMuc2hhcmtFYXQoc2luZGV4KTtcblxuICAgICAgICAvL2Rpc3Bvc2Ugc3BhdGlhbCBpbmRleFxuICAgICAgICAvL3NpbmRleC5jbGVhcigpXG5cbiAgICAgICAgLy9tb3ZlXG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5maXNoKVxuICAgICAgICAgICAgZi5tb3ZlKHRpbWVTdGVwTXMpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPFNhcmRpbj59IHNpbmRleCBcbiAgICAgKi9cbiAgICBzaGFya0VhdChzaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hhcmsgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMua2lsbGVkID0gW107XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuc2hhcmsueCwgeSA9IHRoaXMuc2hhcmsueTtcbiAgICAgICAgY29uc3Qgc3MgPSBzaW5kZXguZ2V0KHggLSB0aGlzLkRfU0hBUktfRUFULCB5IC0gdGhpcy5EX1NIQVJLX0VBVCwgeCArIHRoaXMuRF9TSEFSS19FQVQsIHkgKyB0aGlzLkRfU0hBUktfRUFUKTtcbiAgICAgICAgZm9yIChsZXQgcyBvZiBzcykge1xuICAgICAgICAgICAgY29uc3QgZCA9IE1hdGguaHlwb3QoKHggLSBzLngpLCAoeSAtIHMueSkpO1xuICAgICAgICAgICAgaWYgKGQgPiB0aGlzLkRfU0hBUktfRUFUKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMua2lsbGVkLnB1c2gocyk7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5maXNoLCBzKVxuICAgICAgICAgICAgLy9zaW5kZXgucmVtb3ZlKHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRUFURU5fU0FSRElOX05CICs9IHRoaXMua2lsbGVkLmxlbmd0aDtcbiAgICAgICAgLy9lYXRlbkZpc2hOYi5zZXRUZXh0KFwiRWF0ZW4gZmlzaDogXCIgKyBFQVRFTl9TQVJESU5fTkIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZmlzaFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBhZGRGaXNoKG5iID0gMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspXG4gICAgICAgICAgICB0aGlzLmZpc2gucHVzaChuZXcgU2FyZGluKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcmFuZG9tIHNwZWVkIGZvciBhbGwgZmlzaFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFJhbmRvbVNwZWVkKCkge1xuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuZmlzaClcbiAgICAgICAgICAgIGYuc2V0UmFuZG9tU3BlZWQoKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNlYSB9IGZyb20gJy4vU2VhJztcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4uL2Jhc2UvR2VvQ2FudmFzJztcblxuY2xhc3MgRmlzaFNpbXVsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy9UT0RPXG4gICAgICAgIC8vYWRkIGVhdGVuIGZpc2ggbmIgbGFiZWxcblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dGaXNoVmlzaW9uRmllbGQgPSBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd0Zpc2hWaXNpb25MaW5rcyA9IGZhbHNlXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zaG93RmlzaENvbGxpc2lvbkZpZWxkID0gZmFsc2VcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuICAgICAgICAgICAgY29uc3QgcyA9IHRoLnNlYVxuXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL2NsZWFyXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJnYmEoMTIwLDEyMCwyNTUsMC42KVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9zaG93IHZpc2lvbiBmaWVsZFxuICAgICAgICAgICAgaWYgKHRoLnNob3dGaXNoVmlzaW9uRmllbGQpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5maXNoKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoc2EpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2EuZGlzcGxheVZpc2lvbkZpZWxkKHRoaXMsIFwicmdiYSgyMDAsMjAwLDIwMCwwLjE1KVwiLCAxKVxuICAgICAgICAgICAgLy9zaG93IHZpc2lvbiBsaW5rc1xuICAgICAgICAgICAgaWYgKHRoLnNob3dGaXNoVmlzaW9uTGlua3MpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5maXNoKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoc2EpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2EuZGlzcGxheVZpc2lvbkxpbmtzKHRoaXMsIFwicmdiYSgyNTUsMTAwLDEwMCwwLjMpXCIsIDEpXG4gICAgICAgICAgICAvL3Nob3cgY29sbGlzaW9uIGZpZWxkXG4gICAgICAgICAgICBpZiAodGguc2hvd0Zpc2hDb2xsaXNpb25GaWVsZClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzYS5kaXNwbGF5Q29sbGlzaW9uRmllbGQodGhpcywgXCJwdXJwbGVcIiwgMSlcblxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgc2FyZGluc1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMlxuICAgICAgICAgICAgY29uc3Qgc2FyZGluTGVuZ3RoID0gN1xuICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5maXNoKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgIHNhLmRpc3BsYXkodGhpcywgc2FyZGluTGVuZ3RoKVxuXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBzaGFya1xuICAgICAgICAgICAgaWYgKHMuc2hhcmsgIT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgYzIubGluZVdpZHRoID0gNFxuICAgICAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJibGFja1wiXG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGFya0xlbmd0aCA9IDEyXG4gICAgICAgICAgICAgICAgY29uc3QgZHggPSBzaGFya0xlbmd0aCAqIE1hdGguY29zKHMuc2hhcmsuYW5nbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gc2hhcmtMZW5ndGggKiBNYXRoLnNpbihzLnNoYXJrLmFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLm1vdmVUbyhzLnNoYXJrLngsIHMuc2hhcmsueSk7XG4gICAgICAgICAgICAgICAgYzIubGluZVRvKHMuc2hhcmsueCAtIGR4LCBzLnNoYXJrLnkgKyBkeSk7XG4gICAgICAgICAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBibG9vZCBzcG90XG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMVxuICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5tb3ZlVG8oc2EueCwgc2EueSk7XG4gICAgICAgICAgICAgICAgYzIuYXJjKHNhLngsIHNhLnksIDQsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5maWxsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZnJhbWVcbiAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJkYXJrZ3JheVwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMSAqIHRoLmNwbHVzLmdldFpmKCk7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLnJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jcGx1cy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoLnNlYS5zaGFyayA9IHsgeDogdGguY3BsdXMucGl4VG9HZW9YKGUub2Zmc2V0WCksIHk6IHRoLmNwbHVzLnBpeFRvR2VvWShlLm9mZnNldFkpLCBhbmdsZTogMCB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNwbHVzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgeEcgPSB0aC5jcGx1cy5waXhUb0dlb1goZS5vZmZzZXRYKTtcbiAgICAgICAgICAgIGNvbnN0IHlHID0gdGguY3BsdXMucGl4VG9HZW9ZKGUub2Zmc2V0WSk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoLXlHICsgdGguc2VhLnNoYXJrLnksIHhHIC0gdGguc2VhLnNoYXJrLngpO1xuICAgICAgICAgICAgdGguc2VhLnNoYXJrID0geyB4OiB4RywgeTogeUcsIGFuZ2xlOiBhbmdsZSB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNwbHVzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZSA9PiB7XG4gICAgICAgICAgICB0aC5zZWEuc2hhcmsgPSBudWxsO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7U2VhfSAqL1xuICAgICAgICB0aGlzLnNlYSA9IG5ldyBTZWEodGhpcy53LCB0aGlzLmgpXG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZW5zaXR5IFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGluaXRSYW5kb20oZGVuc2l0eSA9IDAuMDAxKSB7XG4gICAgICAgIHRoaXMuc2VhLmFkZEZpc2goZGVuc2l0eSAqIHRoaXMuc2VhLncgKiB0aGlzLnNlYS5oKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmJJdGVyYXRpb25zIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0YXJ0KHRpbWVTdGVwTXMgPSAxMCwgbmJJdGVyYXRpb25zID0gLTEpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCB0ID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdC5zZWEuc3RlcCh0aW1lU3RlcE1zKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpc2ggPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgRmlzaFNpbXVsYXRpb24ob3B0cylcbn1cbiIsIi8vQHRzLWNoZWNrXG5cbi8qKlxuICogXG4gKi9cbmV4cG9ydCBjbGFzcyBDZWxsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBuYj0wKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm5iID0gbmJcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBvYmpUb0FycmF5IH0gZnJvbSAnLi4vYmFzZS9saWInO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbCc7XG5cbi8qKlxuICogXG4gKi9cbmV4cG9ydCBjbGFzcyBVbml2ZXJzZSB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsQ2VsbD59ICovXG4gICAgICAgIHRoaXMucG9wdWxhdGlvbkkgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge0NlbGx8bnVsbH1cbiAgICAgKi9cbiAgICBhZGQoeCwgeSkge1xuXG4gICAgICAgIC8vZmluZCBjZWxsIGF0IGxvY2F0aW9uXG4gICAgICAgIC8qKkB0eXBlIHtzdHJpbmd9Ki9cbiAgICAgICAgY29uc3QgaWQgPSB4ICsgXCJfXCIgKyB5O1xuICAgICAgICBpZiAodGhpcy5wb3B1bGF0aW9uSVtpZF0pIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vY3JlYXRlIG5ldyBjZWxsXG4gICAgICAgIC8qKkB0eXBlIHtDZWxsfSAqL1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGwoeCwgeSwgMClcbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uLnB1c2goY2VsbClcbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uSVtpZF0gPSBjZWxsXG4gICAgICAgIHJldHVybiBjZWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RlcCgpIHtcblxuICAgICAgICAvL1RPRE8gZG91YmxlIGluZGV4aW5nPyBieSByYXcgYW5kIHRoZW4gY29sdW1uID9cbiAgICAgICAgLy9wb3B1bGF0ZSBjZWxsIHN1cnJvdW5kaW5nc1xuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBDZWxsPn1cbiAgICAgICAgICogQGRpY3QgKi9cbiAgICAgICAgY29uc3Qgc3VySSA9IHt9O1xuICAgICAgICAvL2dvIHRocm91Z2ggbGlzdCBvZiBjZWxsc1xuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHRoaXMucG9wdWxhdGlvbikge1xuICAgICAgICAgICAgLy8gKzEgc3Vycm91bmRpbmcgY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IHNycyA9IFVuaXZlcnNlLmdldENlbGxTdXJyb3VuZGluZyhjZWxsLCB0aGlzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHN1ciBvZiBzcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBzdXIueCArIFwiX1wiICsgc3VyLnk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VyXyA9IHN1cklba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc3VyXykge1xuICAgICAgICAgICAgICAgICAgICBzdXJfLm5iKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VyLm5iID0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3VySVtrZXldID0gc3VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vQjMvUzIzXG4gICAgICAgIC8va2lsbCBjZWxsc1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cbiAgICAgICAgY29uc3QgY2VsbHNUb0tlZXAgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQ2VsbD59XG4gICAgICAgICAqIEBkaWN0ICovXG4gICAgICAgIGNvbnN0IGNlbGxzVG9LZWVwSSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHRoaXMucG9wdWxhdGlvbikge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY2VsbC54ICsgXCJfXCIgKyBjZWxsLnk7XG4gICAgICAgICAgICBjb25zdCBjZWxsXyA9IHN1cklba2V5XTtcbiAgICAgICAgICAgIGlmICghY2VsbF8pIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy9pZiAobmI8MiBvciBuYj4zKSAtPiBraWxsXG4gICAgICAgICAgICBpZiAoY2VsbF8ubmIgPCAyIHx8IGNlbGxfLm5iID4gMykgY29udGludWU7XG4gICAgICAgICAgICBjZWxsc1RvS2VlcC5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgY2VsbHNUb0tlZXBJW2tleV0gPSBjZWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wdWxhdGlvbiA9IGNlbGxzVG9LZWVwO1xuICAgICAgICB0aGlzLnBvcHVsYXRpb25JID0gY2VsbHNUb0tlZXBJO1xuXG4gICAgICAgIC8vY3JlYXRlIG5ldyBjZWxsc1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cbiAgICAgICAgY29uc3Qgc3VycyA9IG9ialRvQXJyYXkoc3VySSk7XG4gICAgICAgIGZvciAobGV0IHN1ciBvZiBzdXJzKSB7XG5cbiAgICAgICAgICAgIGlmIChzdXIubmIgIT09IDMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL2NoZWNrIGlmIGFscmVhZHkgYWxpdmVcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHN1ci54ICsgXCJfXCIgKyBzdXIueTtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wb3B1bGF0aW9uSVtrZXldO1xuICAgICAgICAgICAgaWYgKGNlbGwpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL2NyZWF0ZSBuZXcgY2VsbFxuICAgICAgICAgICAgdGhpcy5wb3B1bGF0aW9uLnB1c2goc3VyKTtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGlvbklba2V5XSA9IHN1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TVNcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3BsdXNcbiAgICAgKiBAcmV0dXJuIHtVbml2ZXJzZX1cbiAgICAgKi9cbiAgICBzdGFydChuYiwgdGltZW91dE1TLCBjcGx1cykge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHVuaSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaSk7XG4gICAgICAgICAgICB1bmkuc3RlcCgpO1xuICAgICAgICAgICAgY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmIgPiAwICYmIGkrKyA+IG5iKSByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgdGltZW91dE1TKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW5naW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2VsbH0gY2VsbFxuICAgICAqIEBwYXJhbSB7VW5pdmVyc2V9IHVuaVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxDZWxsPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2VsbFN1cnJvdW5kaW5nKGNlbGwsIHVuaSkge1xuICAgICAgICBjb25zdCB4MSA9IGNlbGwueCA9PT0gMCA/IHVuaS53IC0gMSA6IGNlbGwueCAtIDE7XG4gICAgICAgIGNvbnN0IHgyID0gY2VsbC54ID09PSB1bmkudyAtIDEgPyAwIDogY2VsbC54ICsgMTtcbiAgICAgICAgY29uc3QgeTEgPSBjZWxsLnkgPT09IDAgPyB1bmkuaCAtIDEgOiBjZWxsLnkgLSAxO1xuICAgICAgICBjb25zdCB5MiA9IGNlbGwueSA9PT0gdW5pLmggLSAxID8gMCA6IGNlbGwueSArIDE7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MSwgeTEpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDEsIGNlbGwueSksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MSwgeTIpLFxuICAgICAgICAgICAgbmV3IENlbGwoY2VsbC54LCB5MSksXG4gICAgICAgICAgICBuZXcgQ2VsbChjZWxsLngsIHkyKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgyLCB5MSksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MiwgY2VsbC55KSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgyLCB5MiksXG4gICAgICAgIF07XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuaW1wb3J0IHsgVW5pdmVyc2UgfSBmcm9tICcuL1VuaXZlcnNlJztcbmltcG9ydCB7IENlbGwgfSBmcm9tICcuL0NlbGwnO1xuXG4vL1RPRE8gem9vbS9wYW4sIHdpdGggY2FudmFzIHRyYW5zZm9ybTogYmV0dGVyIHVuaXZlcnNlIGxpbWl0c1xuLy9UT0RPIGJ1dHRvbnMgKHBsYXksIHN0b3AsIHNwZWVkLCBkcmF3LCBwYW4pXG4vL1RPRE8gY2hlY2sgY2FudmFzIGFuaW1hdGlvblxuXG5cbmNsYXNzIEdvTFNpbXVsYXRpb24ge1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtHZW9DYW52YXN9ICovXG4gICAgICAgIHRoaXMuY3BsdXMgPSBuZXcgR2VvQ2FudmFzKCk7XG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgLy9jbGVhclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuXG4gICAgICAgICAgICAvL2RyYXcgY2VsbHNcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwiYmx1ZVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgY2VsbCBvZiB0aC51bmkucG9wdWxhdGlvbilcbiAgICAgICAgICAgICAgICBjMi5maWxsUmVjdCgoY2VsbC54KSwgKGNlbGwueSksIDEsIDEpO1xuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bmkgPSBuZXcgVW5pdmVyc2UodGhpcy53LCB0aGlzLmgpO1xuICAgIH1cblxuXG4gICAgLy9cbiAgICBpbml0UmFuZG9tKGRlbnNpdHkgPSAwLjA1KSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGNvbnN0IG5iID0gdGhpcy51bmkudyAqIHRoaXMudW5pLmggKiBkZW5zaXR5O1xuICAgICAgICB3aGlsZSAoaSA8IG5iKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh0aGlzLnVuaS53ICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh0aGlzLnVuaS5oICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICAvKiogQHR5cGUge0NlbGx9ICovXG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy51bmkuYWRkKHgsIHkpO1xuICAgICAgICAgICAgaWYgKGNlbGwpIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8vXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudW5pLnN0YXJ0KC0xLCAwLCB0aGlzLmNwbHVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cblxuZXhwb3J0IGNvbnN0IGdhbWVPZkxpZmUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgR29MU2ltdWxhdGlvbihvcHRzKVxufVxuIiwiLy9AdHMtY2hlY2tcblxuZXhwb3J0ICogZnJvbSBcIi4vcGxhbmV0cy9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi9nb2wvaW5kZXhcIlxuZXhwb3J0ICogZnJvbSBcIi4vZmlzaC9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi9wcC9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi91cmJhbi9pbmRleFwiXG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgVW5pdmVyc2UgfSBmcm9tIFwiLi9Vbml2ZXJzZVwiO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCJcbmltcG9ydCB7IEFnZW50UG9pbnQgfSBmcm9tIFwiLi4vYmFzZS9BZ2VudFBvaW50XCI7XG5cbmV4cG9ydCBjbGFzcyBQbGFuZXQgZXh0ZW5kcyBBZ2VudFBvaW50IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7VW5pdmVyc2V9IHUgVGhlIHVuaXZlcnNlIHRoZSBwbGFuZXQgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgbWFzc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ggVGhlIHNwZWVkIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3kgVGhlIHNwZWVkIHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1LCBtLCB4LCB5LCBzeCA9IDAsIHN5ID0gMCkge1xuXG4gICAgICAgIC8vXG4gICAgICAgIHN1cGVyKHgsIHksIHN4LCBzeSlcblxuICAgICAgICAvKiogQHR5cGUge1VuaXZlcnNlfSAqL1xuICAgICAgICB0aGlzLnUgPSB1O1xuICAgICAgICB1LnBzLnB1c2godGhpcylcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5tID0gbTtcblxuICAgICAgICAvL2NvbXB1dGUgcmFkaXVzXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBjb25zdCByID0gdGhpcy5yKCk7XG5cbiAgICAgICAgLy9zZXQgcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHggPCByID8gciA6IHggPiB1LncgLSByID8gdS53IC0gciA6IHg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5IDwgciA/IHIgOiB5ID4gdS5oIC0gciA/IHUuaCAtIHIgOiB5O1xuXG4gICAgICAgIC8vYWNjZWxlcmF0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmF4ID0gMDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXkgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZm9yY2UsIGJhc2VkIG9uIHRoZSBncmF2aXR5IG9mIG90aGVyIHBsYW5ldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAgICovXG4gICAgb2JzZXJ2ZShleHBvbmVudCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBncmF2aXR5IGZpZWxkIGF0IHBsYW5ldCBsb2NhdGlvblxuICAgICAgICBjb25zdCBnID0gdGhpcy51LmdldEdyYXZpdHlGaWVsZCh0aGlzLngsIHRoaXMueSwgdGhpcywgZXhwb25lbnQpO1xuXG4gICAgICAgIC8vc2V0IGFjY2VsZXJhdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5heCA9IGcuZ3g7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmF5ID0gZy5neTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJhZGl1cyBvZiB0aGUgcGxhbmV0LCBkZXBlbmRpbmcgb24gaXRzIG1hc3MuXG4gICAgICovXG4gICAgcigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMubSAvIE1hdGguUEksIDAuNSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvdW5jZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgY2hhbmdlKGJvdW5jZSA9IGZhbHNlLCBtYXhTcGVlZCA9IDAuOCwgdGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9jb21wdXRlIG5ldyBzcGVlZFxuICAgICAgICB0aGlzLnN4ICs9IHRoaXMuYXggKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnN5ICs9IHRoaXMuYXkgKiB0aW1lU3RlcE1zO1xuXG4gICAgICAgIC8vY2hlY2sgdm1heFxuICAgICAgICBpZiAobWF4U3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIGNvbnN0IHYgPSBNYXRoLnNxcnQodGhpcy5zeCAqIHRoaXMuc3ggKyB0aGlzLnN5ICogdGhpcy5zeSk7XG4gICAgICAgICAgICBpZiAodiA+IG1heFNwZWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zeCA9IG1heFNwZWVkICogdGhpcy5zeCAvIHY7XG4gICAgICAgICAgICAgICAgdGhpcy5zeSA9IG1heFNwZWVkICogdGhpcy5zeSAvIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHBvc2l0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgbnggPSB0aGlzLnggKyB0aGlzLnN4ICogdGltZVN0ZXBNcztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBueSA9IHRoaXMueSArIHRoaXMuc3kgKiB0aW1lU3RlcE1zO1xuXG4gICAgICAgIC8vaGFuZGxlIHBvc2l0aW9uIGxpbWl0XG4gICAgICAgIGlmIChib3VuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSAxO1xuICAgICAgICAgICAgaWYgKG54IDwgcikgeyBueCA9IHI7IHRoaXMuc3ggPSAtdGhpcy5zeCAqIGU7IH1cbiAgICAgICAgICAgIGlmIChueSA8IHIpIHsgbnkgPSByOyB0aGlzLnN5ID0gLXRoaXMuc3kgKiBlOyB9XG4gICAgICAgICAgICBpZiAobnggPiB0aGlzLnUudyAtIHIpIHsgbnggPSB0aGlzLnUudyAtIHI7IHRoaXMuc3ggPSAtdGhpcy5zeCAqIGU7IH1cbiAgICAgICAgICAgIGlmIChueSA+IHRoaXMudS5oIC0gcikgeyBueSA9IHRoaXMudS5oIC0gcjsgdGhpcy5zeSA9IC10aGlzLnN5ICogZTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG54IDwgMCkgeyBueCA9IHRoaXMudS53OyB9XG4gICAgICAgICAgICBpZiAobnkgPCAwKSB7IG55ID0gdGhpcy51Lmg7IH1cbiAgICAgICAgICAgIGlmIChueCA+IHRoaXMudS53KSB7IG54ID0gMDsgfVxuICAgICAgICAgICAgaWYgKG55ID4gdGhpcy51LmgpIHsgbnkgPSAwOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvL21vdmVcbiAgICAgICAgdGhpcy54ID0gbng7XG4gICAgICAgIHRoaXMueSA9IG55O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBwbGFuZXRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGxTdHlsZSBcbiAgICAgKi9cbiAgICBkaXNwbGF5KGNwLCBmaWxsU3R5bGUpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIuYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnIoKSAvIGNwLmdldFpmKCksIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLmZpbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHBsYW5ldCBhY2NlbGVyYXRpb25cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cm9rZVN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciBcbiAgICAgKi9cbiAgICBkaXNwbGF5QWNjZWxlcmF0aW9uKGNwLCBzdHJva2VTdHlsZSA9IFwiY3lhblwiLCBsaW5lV2lkdGggPSAxLCBmYWN0b3IgPSA1MDAwKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGMyLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIubW92ZVRvKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgYzIubGluZVRvKHRoaXMueCArIGZhY3RvciAqIHRoaXMuYXgsIHRoaXMueSArIGZhY3RvciAqIHRoaXMuYXkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgcmVtb3ZlRnJvbUFycmF5IH0gZnJvbSAnLi4vYmFzZS9saWInO1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgUGxhbmV0IH0gZnJvbSAnLi9QbGFuZXQnO1xuXG5leHBvcnQgY2xhc3MgVW5pdmVyc2Uge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHcsIGgpIHtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48UGxhbmV0Pn0gKi9cbiAgICAgICAgdGhpcy5wcyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG1hc3Mgb2YgdGhlIHVuaXZlcnNlLCBhcyB0aGUgc3VtIG9mIHRoZSBtYXNzIG9mIGl0cyBwbGFuZXRzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbSgpIHtcbiAgICAgICAgbGV0IG0gPSAwO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBtICs9IHAubTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcElnbm9yZSBBIHBsYW5ldCB0byBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAgICAgKiBAcmV0dXJucyB7e2d4Om51bWJlcixneTpudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldEdyYXZpdHlGaWVsZCh4LCB5LCBwSWdub3JlID0gdW5kZWZpbmVkLCBleHBvbmVudCA9IDIpIHtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IGd4ID0gMFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IGd5ID0gMFxuXG4gICAgICAgIC8vZ290aHJvdWdoIGFsbCBwbGFuZXRzIGluIHRoZSB1bml2ZXJzZVxuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpIHtcblxuICAgICAgICAgICAgLy9pZ25vcmUgcGxhbmV0XG4gICAgICAgICAgICBpZiAocElnbm9yZSAmJiBwID09IHBJZ25vcmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBkaXN0YW5jZVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICBsZXQgZCA9IHAuZFAoeCwgeSk7XG4gICAgICAgICAgICBpZiAoZCA9PT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy9jb21wdXRlIGFuZCBhZGQgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBkID0gZCAqIE1hdGgucG93KGQsIGV4cG9uZW50KTtcbiAgICAgICAgICAgIGd4ICs9IDAuMDEgKiAocC54IC0geCkgKiBwLm0gLyBkO1xuICAgICAgICAgICAgZ3kgKz0gMC4wMSAqIChwLnkgLSB5KSAqIHAubSAvIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ3g6IGd4LCBneTogZ3kgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlIHR3byBwbGFuZXRzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtQbGFuZXR9IHAxXG4gICAgICogQHBhcmFtIHtQbGFuZXR9IHAyXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPFBsYW5ldD59IHNpbmRleFxuICAgICAqIEByZXR1cm5zIHtQbGFuZXR9XG4gICAgICovXG4gICAgYWdncmVnYXRlKHAxLCBwMiwgc2luZGV4KSB7XG4gICAgICAgIGNvbnN0IG0gPSBwMS5tICsgcDIubTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQbGFuZXQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIChwMS54ICogcDEubSArIHAyLnggKiBwMi5tKSAvIG0sXG4gICAgICAgICAgICAocDEueSAqIHAxLm0gKyBwMi55ICogcDIubSkgLyBtLFxuICAgICAgICAgICAgKHAxLnN4ICogcDEubSArIHAyLnN4ICogcDIubSkgLyBtLFxuICAgICAgICAgICAgKHAxLnN5ICogcDEubSArIHAyLnN5ICogcDIubSkgLyBtXG4gICAgICAgICk7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLnBzLCBwMSk7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLnBzLCBwMik7XG5cbiAgICAgICAgaWYgKHNpbmRleCkge1xuICAgICAgICAgICAgc2luZGV4LnJlbW92ZShwMSlcbiAgICAgICAgICAgIHNpbmRleC5yZW1vdmUocDIpXG4gICAgICAgICAgICBzaW5kZXguaW5zZXJ0KHApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPFBsYW5ldD59IHNpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xsaXNpb25GYWN0b3JcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFBsYW5ldD59XG4gICAgICovXG4gICAgZmluZENvbGxpc2lvbihzaW5kZXgsIGNvbGxpc2lvbkZhY3RvciA9IDEpIHtcbiAgICAgICAgZm9yIChsZXQgcGkgb2YgdGhpcy5wcykge1xuXG4gICAgICAgICAgICBjb25zdCB3ID0gMiAqIHBpLnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmQgPSBzaW5kZXguZ2V0KHBpLnggLSB3LCBwaS55IC0gdywgcGkueCArIHcsIHBpLnkgKyB3KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcGogb2YgY2FuZCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBpID09IHBqKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGQxID0gcGkuZChwaik7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICAgICAgY29uc3QgZDIgPSAocGkucigpICsgcGoucigpKSAqIGNvbGxpc2lvbkZhY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwaSwgcGpdO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcGxhbmV0cyB3aXRoIHJhbmRvbSBzcGVlZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkUGxhbmV0cyhuYiA9IDEsIG1pID0gMC41LCBtaW5TcGVlZCA9IDAsIG1heFNwZWVkID0gMC4xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQbGFuZXQodGhpcywgbWksIHRoaXMudyAqIE1hdGgucmFuZG9tKCksIHRoaXMuaCAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgcC5zZXRSYW5kb21TcGVlZChtaW5TcGVlZCwgbWF4U3BlZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvdW5jZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdm1heCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpc2lvbkZhY3RvciBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGVwKGJvdW5jZSA9IGZhbHNlLCB2bWF4ID0gMC44LCBleHBvbmVudCA9IDIsIGNvbGxpc2lvbkZhY3RvciA9IDEsIHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vb2JzZXJ2YXRpb25cbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKVxuICAgICAgICAgICAgcC5vYnNlcnZlKGV4cG9uZW50KTtcblxuICAgICAgICAvL2FjdGlvblxuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBwLmNoYW5nZShib3VuY2UsIHZtYXgsIHRpbWVTdGVwTXMpO1xuXG5cbiAgICAgICAgLy9jb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIHRoaXMuZGV0ZWN0Q29sbGlzaW9ucyhjb2xsaXNpb25GYWN0b3IpXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpc2lvbkZhY3RvciBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBkZXRlY3RDb2xsaXNpb25zKGNvbGxpc2lvbkZhY3RvciA9IDEpIHtcblxuICAgICAgICAvKiogQHR5cGUge1NwYXRpYWxJbmRleC48UGxhbmV0Pn0gKi9cbiAgICAgICAgY29uc3Qgc2luZGV4ID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuICAgICAgICBzaW5kZXgubG9hZCh0aGlzLnBzKVxuXG4gICAgICAgIC8vZmluZCBmaXJzdCBjb2xsaXNpb25cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48UGxhbmV0Pn0gKi9cbiAgICAgICAgbGV0IHBhaXIgPSB0aGlzLmZpbmRDb2xsaXNpb24oc2luZGV4LCBjb2xsaXNpb25GYWN0b3IpO1xuICAgICAgICB3aGlsZSAocGFpciAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAvL2FnZ3JlZ2F0ZVxuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuYWdncmVnYXRlKHBhaXJbMF0sIHBhaXJbMV0sIHNpbmRleClcblxuICAgICAgICAgICAgLy9maW5kIG5leHQgY29sbGlzaW9uXG4gICAgICAgICAgICBwYWlyID0gdGhpcy5maW5kQ29sbGlzaW9uKHNpbmRleCwgY29sbGlzaW9uRmFjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIHJhbmRvbSBzcGVlZCB0byBhbGwgcGxhbmV0c1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0UmFuZG9tU3BlZWQobWluU3BlZWQgPSAwLCBtYXhTcGVlZCA9IDAuMSkge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBwLnNldFJhbmRvbVNwZWVkKG1pblNwZWVkLCBtYXhTcGVlZClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UGxhbmV0fSBUaGUgbGFyZ2VzdCBwbGFuZXQgb2YgdGhlIHVuaXZlcnNlLCB1c3VhbGx5IHRoZSBzdGFyLlxuICAgICAqL1xuICAgIGdldExhcmdlc3RQbGFuZXQoKSB7XG4gICAgICAgIGxldCBwTSA9IG51bGwsIG1NID0gMDtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKVxuICAgICAgICAgICAgaWYgKHAubSA+IG1NKSB7IHBNID0gcDsgbU0gPSBwLm0gfVxuICAgICAgICByZXR1cm4gcE1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGFyZ2VzdCBwbGFuZXQgYW5kIGV4cGxvZGUgaXQuXG4gICAgICovXG4gICAgZXhwbG9kZUxhcmdlc3RQbGFuZXQoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldExhcmdlc3RQbGFuZXQoKVxuICAgICAgICB0aGlzLmV4cGxvZGUocClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBsb2RlIGEgcGxhbmV0IGludG8gcGllY2VzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtQbGFuZXR9IHAgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCBcbiAgICAgKi9cbiAgICBleHBsb2RlKHAsIG5iID0gLTEsIG1pblNwZWVkID0gMC44LCBtYXhTcGVlZCA9IDEuNSwgcmFkID0gLTEpIHtcbiAgICAgICAgaWYgKG5iIDw9IDApIG5iID0gTWF0aC5mbG9vcihwLm0pO1xuICAgICAgICBpZiAobmIgPD0gMCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhbmdsZVN0ZXAgPSAyICogTWF0aC5QSSAvIG5iO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIC8vY3JlYXRlIHBsYW5ldFxuXG4gICAgICAgICAgICAvL3Bvc2l0aW9uXG4gICAgICAgICAgICBpZiAocmFkIDwgMCkgcmFkID0gMiAqIHAucigpXG4gICAgICAgICAgICBjb25zdCBkID0gcmFkICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBpICogYW5nbGVTdGVwO1xuICAgICAgICAgICAgY29uc3QgeCA9IGQgKiBNYXRoLmNvcyhhKSwgeSA9IGQgKiBNYXRoLnNpbihhKTtcblxuICAgICAgICAgICAgLy9zcGVlZFxuICAgICAgICAgICAgY29uc3Qgc3BlZWQgPSBtaW5TcGVlZCArIE1hdGgucmFuZG9tKCkgKiAobWF4U3BlZWQgLSBtaW5TcGVlZCk7XG4gICAgICAgICAgICBjb25zdCBhUyA9IGEgKyAyICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMiAqIE1hdGguUEkgLyAzO1xuICAgICAgICAgICAgY29uc3Qgc3ggPSBzcGVlZCAqIE1hdGguY29zKGFTKSwgc3kgPSBzcGVlZCAqIE1hdGguc2luKGFTKTtcblxuICAgICAgICAgICAgbmV3IFBsYW5ldCh0aGlzLCBwLm0gLyBuYiwgcC54ICsgeCwgcC55ICsgeSwgcC5zeCArIHN4LCBwLnN5ICsgc3kpXG4gICAgICAgIH1cbiAgICAgICAgLy9yZW1vdmUgcCBmcm9tIHVuaXZlcnNlXG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLnBzLCBwKTtcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBVbml2ZXJzZSB9IGZyb20gJy4vVW5pdmVyc2UnO1xuaW1wb3J0IHsgUGxhbmV0IH0gZnJvbSAnLi9QbGFuZXQnO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuXG4vKiogICovXG5jbGFzcyBQbGFuZXRTaW11bGF0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgb3B0cy5jYW52YXNJZCA9IG9wdHMuY2FudmFzSWQgfHwgXCJ2YWNhbnZhc1wiO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRzLmNhbnZhc0lkKTtcbiAgICAgICAgaWYgKGNhbnZhcyA9PSBudWxsKSB0aHJvdyBcIk5vIGNhbnZhcyBcIiArIG9wdHMuY2FudmFzSWQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5tYXhTcGVlZCA9IG9wdHMubWF4U3BlZWQgfHwgMC44O1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuYm91bmNlID0gb3B0cy5ib3VuY2UgfHwgZmFsc2VcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSBvcHRzLmV4cG9uZW50IHx8IDI7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmNvbGxpc2lvbkZhY3RvciA9IG9wdHMuY29sbGlzaW9uRmFjdG9yIHx8IDE7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dQbGFuZXRBY2NlbGVyYXRpb24gPSBmYWxzZVxuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy5zaG93RmllbGQgPSB1bmRlZmluZWRcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZmllbGRSZXMgPSAyMFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5maWVsZEZhY3RvciA9IDEwMDBcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZmllbGRTdHJva2VTdHlsZSA9IFwiIzk5YmJmZlwiO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnRhaWxpbmdzID0gb3B0cy50YWlsaW5ncyB8fCAwLjE7XG5cblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIC8vY2xlYXIsIHdpdGggdHJhbnNwYXJlbmN5XG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJnYmEoMCwwLDAsXCIgKyB0aC50YWlsaW5ncyArIFwiKVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICAvL2MyLmZpbGxSZWN0KC0xZTIwLCAtMWUyMCwgMmUyMCwgMmUyMCk7IC8vdG9kb1xuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgZ3Jhdml0eSBmaWVsZFxuICAgICAgICAgICAgaWYgKHRoLnNob3dGaWVsZCA9PT0gXCJmXCIpXG4gICAgICAgICAgICAgICAgdGguZGlzcGxheUdyYXZpdHlGaWVsZCh0aGlzLCB0cnVlKVxuICAgICAgICAgICAgZWxzZSBpZiAodGguc2hvd0ZpZWxkID09PSBcImlcIilcbiAgICAgICAgICAgICAgICB0aC5kaXNwbGF5R3Jhdml0eUZpZWxkKHRoaXMsIGZhbHNlKVxuXG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9kaXNwbGF5IHBsYW5ldHNcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGgudW5pLnBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhwKSkgY29udGludWVcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gcC5tIC8gdGgudW5pLm0oKTtcbiAgICAgICAgICAgICAgICBwLmRpc3BsYXkodGhpcywgXCJyZ2IoMjU1LDI1NSxcIiArIE1hdGguZmxvb3IoMjU1ICogKDEgLSB0KSkgKyBcIilcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kaXNwbGF5IHBsYW5ldHMgYWNjZWxlcmF0aW9uXG4gICAgICAgICAgICBpZiAodGguc2hvd1BsYW5ldEFjY2VsZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGgudW5pLnBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50b0RyYXcocCkpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIHAuZGlzcGxheUFjY2VsZXJhdGlvbih0aGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogQHR5cGUge1VuaXZlcnNlfSAqL1xuICAgICAgICB0aGlzLnVuaSA9IG5ldyBVbml2ZXJzZSh0aGlzLncsIHRoaXMuaClcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpZWxkIFxuICAgICAqL1xuICAgIGRpc3BsYXlHcmF2aXR5RmllbGQoY3AsIGZpZWxkID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmZpZWxkUmVzXG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLmZpZWxkRmFjdG9yXG4gICAgICAgIGNvbnN0IGZfID0gZmllbGQgPyAwLjMgKiByZXMgOiAwLjYgKiByZXM7XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gdGhpcy5maWVsZFN0cm9rZVN0eWxlXG4gICAgICAgIGZvciAobGV0IHggPSByZXMgKiAwLjU7IHggPCB0aGlzLnc7IHggKz0gcmVzKSB7XG4gICAgICAgICAgICBjb25zdCB4RyA9IGNwLnBpeFRvR2VvWCh4KTtcbiAgICAgICAgICAgIGlmICh4RyA+IHRoaXMudW5pLncgfHwgeEcgPCAwKSBjb250aW51ZVxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHJlcyAvIDI7IHkgPCB0aGlzLmg7IHkgKz0gcmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeUcgPSBjcC5waXhUb0dlb1koeSk7XG4gICAgICAgICAgICAgICAgaWYgKHlHID4gdGhpcy51bmkuaCB8fCB5RyA8IDApIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgLy9nZXQgZ3Jhdml0eSBmaWVsZFxuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaS5nZXRHcmF2aXR5RmllbGQoeEcsIHlHLCB1bmRlZmluZWQsIHRoaXMuZXhwb25lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdfID0gTWF0aC5oeXBvdChnLmd4LCBnLmd5KVxuXG4gICAgICAgICAgICAgICAgYzIubGluZVdpZHRoID0gTWF0aC5taW4oZiAqIGdfLCAwLjMgKiByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gZl8gKiBnLmd4IC8gZ18sIGR5ID0gZl8gKiBnLmd5IC8gZ19cblxuICAgICAgICAgICAgICAgIC8vZHJhd1xuICAgICAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAvL2dyYXZpdHkgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgYzIubW92ZVRvKHggLSBkeCwgeSArIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgYzIubGluZVRvKHggKyBkeCwgeSAtIGR5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2lzb3BvdGVudGlhbCBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBjMi5tb3ZlVG8oeCArIGR5LCB5ICsgZHgpO1xuICAgICAgICAgICAgICAgICAgICBjMi5saW5lVG8oeCAtIGR5LCB5IC0gZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSB3aXRoIHJhbmRvbSBwbGFuZXRzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGluaXRSYW5kb20obmIgPSAxMDAwLCBtaSA9IDAuNSwgbWluU3BlZWQgPSAwLCBtYXhTcGVlZCA9IDAuMSkge1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICB0aGlzLnVuaS5wcyA9IFtdO1xuICAgICAgICB0aGlzLnVuaS5hZGRQbGFuZXRzKG5iLCBtaSwgbWluU3BlZWQsIG1heFNwZWVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSB3aXRoIGJpZyBiYW5nIHNldHVwXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWQgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdEJpZ0JhbmcobmIgPSAxMDAwLCBtaSA9IDEsIG1pblNwZWVkID0gMC4zNSwgbWF4U3BlZWQgPSAwLjcsIHJhZCA9IDEwMCkge1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICB0aGlzLnVuaS5wcyA9IFtdO1xuICAgICAgICAvL2NyZWF0ZSBiaWcgcGxhbmV0IGluIHRoZSBtaWRkbGVcbiAgICAgICAgY29uc3QgY3ggPSB0aGlzLncgKiAwLjUsIGN5ID0gdGhpcy5oICogMC41O1xuICAgICAgICBjb25zdCBwID0gbmV3IFBsYW5ldCh0aGlzLnVuaSwgbmIgKiBtaSwgY3gsIGN5LCAwLCAwKTtcbiAgICAgICAgLy9leHBsb2RlIGl0XG4gICAgICAgIHRoaXMudW5pLmV4cGxvZGUocCwgbmIsIG1pblNwZWVkLCBtYXhTcGVlZCwgcmFkKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBzaW11bGF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQudW5pLnN0ZXAodC5ib3VuY2UsIHQubWF4U3BlZWQsIHQuZXhwb25lbnQsIHQuY29sbGlzaW9uRmFjdG9yLCB0aW1lU3RlcE1zKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9zdG9wXG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy9UT0RPXG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCBwbGFuZXRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFBsYW5ldFNpbXVsYXRpb24ob3B0cylcbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBMYW5kIH0gZnJvbSBcIi4vTGFuZFwiXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgQWdlbnRQb2ludCB9IGZyb20gXCIuLi9iYXNlL0FnZW50UG9pbnRcIlxuXG4vKiogKi9cbmV4cG9ydCBjbGFzcyBBbmltYWwgZXh0ZW5kcyBBZ2VudFBvaW50IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFxuICAgICAqIEBwYXJhbSB7TGFuZH0gbCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsLCB4ID0gMCwgeSA9IDApIHtcblxuICAgICAgICBzdXBlcih4LCB5KVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKiogQHR5cGUge0xhbmR9ICovXG4gICAgICAgIHRoaXMubCA9IGw7XG5cbiAgICAgICAgLy9wb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geCA8IDAgPyAwIDogeCA+IGwudyA/IGwudyA6IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHkgPCAwID8gMCA6IHkgPiBsLmggPyBsLmggOiB5XG5cbiAgICAgICAgLy90aGUgb3RoZXIgYW5pbWFscyBhcm91bmRcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5wcmVkYXRvcnMgPSBbXVxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLnByZXlzID0gW11cblxuICAgICAgICAvL2FkZCB0byB0aGUgc3BhdGlhbCBpbmRleFxuICAgICAgICBsLmdyaWQuaW5zZXJ0KHRoaXMpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIG1vdmUodGltZVN0ZXBNcyA9IDEwKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxcbiAgICAgICAgbC5ncmlkLnJlbW92ZSh0aGlzKTtcblxuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgciA9IDAuMDEgKiBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIHRoaXMuc3ggKz0gciAqIE1hdGguY29zKGFuZ2xlKSAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMuc3ggPSB0aGlzLnN4ID4gbC5WX01BWCA/IGwuVl9NQVggOiB0aGlzLnN4IDwgLWwuVl9NQVggPyAtbC5WX01BWCA6IHRoaXMuc3hcblxuICAgICAgICB0aGlzLnN5ICs9IHIgKiBNYXRoLnNpbihhbmdsZSkgKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnN5ID0gdGhpcy5zeSA+IGwuVl9NQVggPyBsLlZfTUFYIDogdGhpcy5zeSA8IC1sLlZfTUFYID8gLWwuVl9NQVggOiB0aGlzLnN5XG5cbiAgICAgICAgdGhpcy54ICs9IHRoaXMuc3ggKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnggPSB0aGlzLnggPCAwID8gbC53IDogdGhpcy54ID4gbC53ID8gMCA6IHRoaXMueFxuXG4gICAgICAgIHRoaXMueSArPSB0aGlzLnN5ICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy55ID0gdGhpcy55IDwgMCA/IGwuaCA6IHRoaXMueSA+IGwuaCA/IDAgOiB0aGlzLnlcblxuICAgICAgICBsLmdyaWQuaW5zZXJ0KHRoaXMpO1xuICAgIH1cblxuXG4gICAgLyoqIE9ic2VydmUgKi9cbiAgICBvYnNlcnZlKCkge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sXG5cbiAgICAgICAgLy9nZXQgYW5pbWFscyBhcm91bmRcbiAgICAgICAgY29uc3QgYXMgPSBsLmdyaWQuZ2V0KHRoaXMueCAtIGwuZCwgdGhpcy55IC0gbC5kLCB0aGlzLnggKyBsLmQsIHRoaXMueSArIGwuZCk7XG5cbiAgICAgICAgdGhpcy5wcmV5cyA9IFtdO1xuICAgICAgICB0aGlzLnByZWRhdG9ycyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGEgb2YgYXMpIHtcbiAgICAgICAgICAgIGlmIChhID09IHRoaXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZChhKSA+IGwuZCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoYS50eXBlID09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV5cy5wdXNoKGEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucHJlZGF0b3JzLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHJldHVybnMge0FuaW1hbH0gKi9cbiAgICBtYWtlQ2hpbGQoKSB7XG4gICAgICAgIC8vZG8gYmV0dGVyOiBtYWtlIGNoaWxkIGFyb3VuZFxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hbCh0aGlzLnR5cGUsIHRoaXMubCwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGFuaW1hbFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsbFN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGZpbGxTdHlsZSA9IFwiYmx1ZVwiLCBzaXplID0gMikge1xuICAgICAgICBjcC5jdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjcC5jdHguZmlsbFJlY3QodGhpcy54LCB0aGlzLnksIHNpemUsIHNpemUpO1xuICAgICAgICAvKmMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmMoYS54LCBhLnksIDAuNSwgMCwgMipNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLmZpbGwoKTsqL1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcbmltcG9ydCB7IHJlbW92ZUZyb21BcnJheVMgfSBmcm9tICcuLi9iYXNlL2xpYic7XG5pbXBvcnQge0FuaW1hbH0gZnJvbSBcIi4vQW5pbWFsXCJcblxuZXhwb3J0IGNsYXNzIExhbmQge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8vdGhlIG1heCBzcGVlZFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5WX01BWCA9IDAuMVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnAgPSAwLjAyIC8vcHJlZGF0b3IgZGVhdGggcHJvYmFiaWxpdHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucSA9IDAuMSAvL3ByZXkgcmVwcm9kdWN0aW9uIHByb2JhYmlsaXR5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnIgPSAwLjUgLy9lYXRlbiBwcmV5IHRyYW5zZm9ybWF0aW9uIHByb2JhYmlsaXR5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm5iID0gMyAvL25laWdoYm9ycyBudW1iZXJcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gd1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaFxuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMucHJlZGF0b3JzID0gW11cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5wcmV5cyA9IFtdXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZCA9IDEwXG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgU3BhdGlhbEluZGV4KCk7XG5cbiAgICAgICAgLyppbnRbXVtdIGhpc3RvO1xuICAgICAgICBpbnQgaW5kZXg9MDtcbiAgICAgICAgdGhpcy5jMkNoYXJ0PWMyQ2hhcnQ7XG4gICAgICAgIHRoaXMuaENoYXJ0PWhDaGFydDtcbiAgICAgICAgdGhpcy5oaXN0bz1uZXcgaW50W3dDaGFydF1bXTtcbiAgICAgICAgZm9yKGludCBpPTA7aTx3Q2hhcnQ7aSsrKVxuICAgICAgICAgICAgaGlzdG9baV09bmV3IGludFtdezAsMH07Ki9cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIHN0ZXAodGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9vYnNlcnZlXG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5wcmV5cykgYS5vYnNlcnZlKCk7XG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5wcmVkYXRvcnMpIGEub2JzZXJ2ZSgpO1xuXG4gICAgICAgIGNvbnN0IHByZXlzVG9Cb3JuID0gW11cbiAgICAgICAgY29uc3QgcHJleXNUb0RpZSA9IFtdXG4gICAgICAgIGNvbnN0IHByZWRzVG9Cb3JuID0gW11cbiAgICAgICAgY29uc3QgcHJlZHNUb0RpZSA9IFtdXG5cbiAgICAgICAgLy9wcmV5XG4gICAgICAgIGZvciAobGV0IHByZXkgb2YgdGhpcy5wcmV5cykge1xuICAgICAgICAgICAgLy9yZXByb2R1Y3Rpb24gaWYgbm8gcHJlZGF0b3IgYXJvdW5kXG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IHRoaXMucSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocHJleS5wcmVkYXRvcnMubGVuZ3RoICE9IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByZXkucHJleXMubGVuZ3RoID49IHRoaXMubmIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcHJleXNUb0Jvcm4ucHVzaChwcmV5Lm1ha2VDaGlsZCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcHJlZGF0b3JcbiAgICAgICAgZm9yIChsZXQgcHJlZCBvZiB0aGlzLnByZWRhdG9ycykge1xuICAgICAgICAgICAgLy9ubyBwcmV5IGFyb3VuZDogcHJlZGF0b3IgZGllcyB3aXRoIHByb2JhYmlsaXR5IHBcbiAgICAgICAgICAgIGlmIChwcmVkLnByZXlzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCB0aGlzLnApIHByZWRzVG9EaWUucHVzaChwcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcHJleSBhcm91bmRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZWF0IHByZXlcbiAgICAgICAgICAgICAgICAvL2Nob29zZSByYW5kb21seVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXlUb0VhdCA9IHByZWQucHJleXNbTWF0aC5mbG9vcihwcmVkLnByZXlzLmxlbmd0aCAqIE1hdGgucmFuZG9tKCkpXTtcbiAgICAgICAgICAgICAgICBwcmV5c1RvRGllLnB1c2gocHJleVRvRWF0KTtcblxuICAgICAgICAgICAgICAgIC8vcHJlZGF0b3IgcmVwcm9kdWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiB0aGlzLnIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkLnByZWRhdG9ycy5sZW5ndGggPj0gdGhpcy5uYikgY29udGludWU7XG4gICAgICAgICAgICAgICAgcHJlZHNUb0Jvcm4ucHVzaChwcmVkLm1ha2VDaGlsZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJleXMucHVzaCguLi5wcmV5c1RvQm9ybik7XG4gICAgICAgIHRoaXMucHJlZGF0b3JzLnB1c2goLi4ucHJlZHNUb0Jvcm4pO1xuXG4gICAgICAgIHJlbW92ZUZyb21BcnJheVModGhpcy5wcmV5cywgcHJleXNUb0RpZSwgZmFsc2UpXG4gICAgICAgIGZvciAobGV0IGEgb2YgcHJleXNUb0RpZSkgdGhpcy5ncmlkLnJlbW92ZShhKTtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5Uyh0aGlzLnByZWRhdG9ycywgcHJlZHNUb0RpZSwgZmFsc2UpXG4gICAgICAgIGZvciAobGV0IGEgb2YgcHJlZHNUb0RpZSkgdGhpcy5ncmlkLnJlbW92ZShhKTtcblxuICAgICAgICAvL21vdmVcbiAgICAgICAgZm9yIChsZXQgYSBvZiB0aGlzLnByZXlzKVxuICAgICAgICAgICAgYS5tb3ZlKHRpbWVTdGVwTXMpO1xuICAgICAgICBmb3IgKGxldCBhIG9mIHRoaXMucHJlZGF0b3JzKVxuICAgICAgICAgICAgYS5tb3ZlKHRpbWVTdGVwTXMpO1xuXG4gICAgICAgIC8qL2hpc3RvXG4gICAgICAgIGhpc3RvW2luZGV4XSA9IG5ldyBpbnRbXXsgcHJleXMuc2l6ZSgpLCBwcmVkYXRvcnMuc2l6ZSgpIH07XG4gICAgICAgIGlmIChpbmRleCA9PSBoaXN0by5sZW5ndGggLSAxKSBpbmRleCA9IDA7XG4gICAgICAgIGVsc2UgaW5kZXgrKzsqL1xuXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IExhbmQgfSBmcm9tICcuL0xhbmQnO1xuaW1wb3J0IHsgQW5pbWFsIH0gZnJvbSAnLi9BbmltYWwnO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuXG4vKiogKi9cbmNsYXNzIFByZXlQcmVkYXRvclNpbXVsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtHZW9DYW52YXN9ICovXG4gICAgICAgIHRoaXMuY3BsdXMgPSBuZXcgR2VvQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpO1xuXG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgLy90cmFuc3BhcmVuY3lcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBhbmltYWxzXG4gICAgICAgICAgICB0aGlzLnNldENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICBmb3IgKGxldCBhIG9mIHRoLmxhbmQucHJleXMpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KGEpKVxuICAgICAgICAgICAgICAgICAgICBhLmRpc3BsYXkodGhpcywgXCJibHVlXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgYSBvZiB0aC5sYW5kLnByZWRhdG9ycylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoYSkpXG4gICAgICAgICAgICAgICAgICAgIGEuZGlzcGxheSh0aGlzLCBcInJlZFwiKTtcblxuICAgICAgICAgICAgLyovbGFiZWxcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwibGlnaHRncmF5XCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCA2NSwgMTMpO1xuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAgICAgYzIuZmlsbFRleHQocHJleXMubGVuZ3RoICsgXCIvXCIgKyBwcmVkYXRvcnMubGVuZ3RoLCAyLCAxMCk7Ki9cblxuICAgICAgICAgICAgLy9jaGFydFxuICAgICAgICAgICAgLy9jMkNoYXJ0LnNldEZpbGxTdHlsZShiYWNrQ29sb3IyKTtcbiAgICAgICAgICAgIC8vYzJDaGFydC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICAgICAgLy9kb3VibGUgbWF4ID0gZ2V0TWF4SGlzdG8oKTtcbiAgICAgICAgICAgIC8qcHVibGljIGludCBnZXRNYXhIaXN0bygpIHtcbiAgICAgICAgICAgICAgICBpbnQgbWF4PTA7XG4gICAgICAgICAgICAgICAgZm9yKGludCBpPTA7aTxoaXN0by5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGlzdG9baV1bMF0+bWF4KSBtYXg9aGlzdG9baV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGlmKGhpc3RvW2ldWzFdPm1heCkgbWF4PWhpc3RvW2ldWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlIGgxLCBoMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGhpc3RvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgxID0gaENoYXJ0ICogaGlzdG9baV1bMF0gLyBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gaENoYXJ0ICogaGlzdG9baV1bMV0gLyBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuc2V0RmlsbFN0eWxlKHByZXlDb2xvcjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LmZpbGxSZWN0KGksIGhDaGFydCAtIGgxLCAxLCBoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuc2V0RmlsbFN0eWxlKHByZWRhdG9yQ29sb3IyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5maWxsUmVjdChpLCBoQ2hhcnQgLSBoMiwgMSwgaDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuc2V0RmlsbFN0eWxlKENzc0NvbG9yLm1ha2UoMjU1LCAyNTUsIDI1NSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5maWxsUmVjdChpbmRleCwgMCwgMSwgaENoYXJ0KTtcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vZnJhbWVcbiAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJkYXJrZ3JheVwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMSAqIHRoLmNwbHVzLmdldFpmKCk7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLnJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7TGFuZH0gKi9cbiAgICAgICAgdGhpcy5sYW5kID0gbmV3IExhbmQodGhpcy53LCB0aGlzLmgpXG5cbiAgICB9XG5cblxuXG4gICAgLy9UT0RPIHRlc3QgaW5pdCBpbiBhIGJ1YmJsZSA/XG4gICAgLy9UT0RPIHVzZSBkZW5zaXR5IGFzIGlucHV0IHBhcmFtZXRlcnMgaW5zdGVhZCBvZiBuYlxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByZXlEZW5zaXR5IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVkYXRvckRlbnNpdHkgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdFJhbmRvbShwcmV5RGVuc2l0eSA9IDAuMDAzLCBwcmVkYXRvckRlbnNpdHkgPSAwLjAwMykge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sYW5kXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJleURlbnNpdHkgKiBsLncgKiBsLmg7IGkrKylcbiAgICAgICAgICAgIGwucHJleXMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgQW5pbWFsKDAsIGwsIGwudyAqIE1hdGgucmFuZG9tKCksIGwuaCAqIE1hdGgucmFuZG9tKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWRhdG9yRGVuc2l0eSAqIGwudyAqIGwuaDsgaSsrKVxuICAgICAgICAgICAgbC5wcmVkYXRvcnMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgQW5pbWFsKDEsIGwsIGwudyAqIE1hdGgucmFuZG9tKCksIGwuaCAqIE1hdGgucmFuZG9tKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYkl0ZXJhdGlvbnMgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RhcnQodGltZVN0ZXBNcyA9IDEwLCBuYkl0ZXJhdGlvbnMgPSAtMSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0LmxhbmQuc3RlcCh0aW1lU3RlcE1zKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAqL1xuZXhwb3J0IGNvbnN0IHByZXlQcmVkYXRvciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcmV5UHJlZGF0b3JTaW11bGF0aW9uKG9wdHMpXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCJcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gXCIuLi9iYXNlL1NwYXRpYWxJbmRleFwiXG5cbmV4cG9ydCBjbGFzcyBCdWlsZGluZyB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZWEgVGhlIGFyZWFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBhcmVhKSB7XG5cbiAgICAgICAgLy9zZXQgcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXJlYSA9IGFyZWFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7IG51bWJlciB9XG4gICAgICovXG4gICAgcigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmFyZWEgLyBNYXRoLlBJKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QnVpbGRpbmd9IGIgXG4gICAgICovXG4gICAgb3ZlcmxhcChiKSB7XG4gICAgICAgIGNvbnN0IGQxID0gYi5yKCkgKyB0aGlzLnIoKVxuICAgICAgICBjb25zdCBkMiA9IE1hdGguaHlwb3QoKGIueCAtIHRoaXMueCksIChiLnkgLSB0aGlzLnkpKTtcbiAgICAgICAgcmV0dXJuIGQyIDwgZDFcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPEJ1aWxkaW5nPn0gc2luZGV4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzRGlzdGFuY2UgXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2hlY2tDb2xsaXNpb24oc2luZGV4LCBzRGlzdGFuY2UpIHtcblxuICAgICAgICAvL2dldCBidWlsZGluZ3MgYXJvdW5kIHVzaW5nIHNwYXRpYWwgaW5kZXhcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QnVpbGRpbmc+fSAqL1xuICAgICAgICBjb25zdCBzcyA9IHNpbmRleC5nZXQodGhpcy54IC0gc0Rpc3RhbmNlLCB0aGlzLnkgLSBzRGlzdGFuY2UsIHRoaXMueCArIHNEaXN0YW5jZSwgdGhpcy55ICsgc0Rpc3RhbmNlKTtcblxuICAgICAgICBmb3IgKGxldCBiIG9mIHNzKSB7XG4gICAgICAgICAgICBpZiAoYiA9PSB0aGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXAoYikpIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGxTdHlsZSBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICovXG4gICAgZGlzcGxheShjcCwgZmlsbFN0eWxlLCBzdHJva2VTdHlsZSwgbGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIuYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnIoKSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuZmlsbCgpO1xuICAgICAgICBjMi5zdHJva2UoKTtcbiAgICB9XG5cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcbmltcG9ydCB7IEJ1aWxkaW5nIH0gZnJvbSAnLi9CdWlsZGluZyc7XG5pbXBvcnQganN0cyBmcm9tICdqc3RzJztcblxuZXhwb3J0IGNsYXNzIE1hcCB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxCdWlsZGluZz59ICovXG4gICAgICAgIHRoaXMuYnMgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPEJ1aWxkaW5nPn0gKi9cbiAgICAgICAgdGhpcy5idUluZGV4ID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgLy90ZXN0IHR1cmZcbiAgICAgICAgICAgICAgICB2YXIgbHMgPSB0dXJmLmxpbmVTdHJpbmcoW1sxMDAwLCAwXSwgWzEwMDAsIDEwMDBdXSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobHMpXG4gICAgICAgICAgICAgICAgLy92YXIgcHQgPSB0dXJmLnBvaW50KFsxMDAwLCAxMDAwXSk7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmYgPSB0dXJmLmJ1ZmZlcihscywgMTAsICdkZWdyZWVzJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYnVmZilcbiAgICAgICAgKi9cblxuICAgICAgICAvL3Rlc3QganN0c1xuICAgICAgICAvL2h0dHBzOi8vYmpvcm5oYXJydGVsbC5naXRodWIuaW8vanN0cy9cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLldLVFJlYWRlcigpXG4gICAgICAgIHZhciBhID0gcmVhZGVyLnJlYWQoJ1BPSU5UICgtMjAgMCknKVxuICAgICAgICBjb25zb2xlLmxvZyhyZWFkZXIpXG4gICAgICAgIGNvbnNvbGUubG9nKGEpXG4gICAgICAgIGEgPSBhLmJ1ZmZlcig0MClcbiAgICAgICAgY29uc29sZS5sb2coYSlcbiAgICAgICAgdmFyIHcgPSBuZXcganN0cy5pby5XS1RXcml0ZXIoKVxuICAgICAgICBjb25zb2xlLmxvZyh3LndyaXRlKGEpKVxuICAgIH1cblxuICAgIC8qKiAqL1xuICAgIGFkZEJ1aWxkaW5nKCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBjYW5kaWRhdGUgbG9jYXRpb24sIHNpemUgYW5kIHR5cGUgZm9yIG5leHQgYnVpbGRpbmdcbiAgICAgICAgLy9UT0RPIGxvdyBsb2NhbCBjb25nZXN0aW9uIEFORCBnbyB0byBoaWdoIGRlbnNpdHkgKHdpdGggZ29vZCBhY2Nlc3MgdG8gb3RoZXIgc3R1ZmYpXG5cbiAgICAgICAgLy9tYWtlIHJhbmRvbSBidWlsZGluZ1xuICAgICAgICBjb25zdCBtYWtlUmFuZG9tQnVpbGRpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy53ICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmggKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IDQwICsgMjAwICogTWF0aC5yYW5kb20oKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWlsZGluZyh4LCB5LCBhcmVhKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPIHNob3VsZCBub3Qgb3ZlcmxhcCB3aXRoIG90aGVyIGVudGl0aWVzIChyb2FkcywgYnVpbGRpbmcpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGNvbnN0IHNEaXN0YW5jZSA9IDEwMDtcbiAgICAgICAgLyoqIEB0eXBlIHtCdWlsZGluZ30gKi9cbiAgICAgICAgbGV0IGJ1ID0gbWFrZVJhbmRvbUJ1aWxkaW5nKCk7XG4gICAgICAgIHdoaWxlIChidS5jaGVja0NvbGxpc2lvbih0aGlzLmJ1SW5kZXgsIHNEaXN0YW5jZSkpIHtcbiAgICAgICAgICAgIGJ1ID0gbWFrZVJhbmRvbUJ1aWxkaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2FkZCBidWlsZGluZ1xuICAgICAgICB0aGlzLmJzLnB1c2goYnUpO1xuICAgICAgICB0aGlzLmJ1SW5kZXgubG9hZChbYnVdKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0ZXAoKSB7XG5cbiAgICAgICAgLy9jb21wdXRlIGJ1aWxkaW5nIG5lZWRcbiAgICAgICAgY29uc3QgYnVOZWVkID0gMTA7XG5cbiAgICAgICAgLy91cmJhbmlzZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1TmVlZDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEJ1aWxkaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2V4dGVuZCByb2FkIG5ldHdvcmtcbiAgICAgICAgLy9UT0RPXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuaW1wb3J0IHsgTWFwIH0gZnJvbSBcIi4vTWFwXCI7XG5cbi8qKiAgKi9cbmNsYXNzIFVyYmFuU2ltdWxhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG4gICAgICAgIGlmIChjYW52YXMgPT0gbnVsbCkgdGhyb3cgXCJObyBjYW52YXMgXCIgKyBvcHRzLmNhbnZhc0lkO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIC8vY2xlYXJcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuXG4gICAgICAgICAgICB0aGlzLnNldENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBidWlsZGluZ3NcbiAgICAgICAgICAgIGZvciAobGV0IGIgb2YgdGgubWFwLmJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhiKSkgY29udGludWVcbiAgICAgICAgICAgICAgICBiLmRpc3BsYXkodGhpcywgXCJsaWdodGdyYXlcIiwgXCJibGFja1wiLCAyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7TWFwfSAqL1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAodGhpcy53LCB0aGlzLmgpXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBzaW11bGF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubWFwLnN0ZXAoKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9zdG9wXG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy9UT0RPXG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCB1cmJhbiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBVcmJhblNpbXVsYXRpb24ob3B0cylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=