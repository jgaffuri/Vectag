(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vectag"] = factory();
	else
		root["vectag"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/index.js ***!
  \********************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: radians, degrees */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "./node_modules/d3-dispatch/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-dispatch/src/index.js ***!
  \***********************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassive"])
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view)
      .on("mousemove.drag", mousemoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"])
      .on("mouseup.drag", mouseupped, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"]);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(event.view, mousemoving);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"]("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-drag/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/index.js ***!
  \*******************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _drag_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });





/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nonpassive, nonpassivecapture, nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassive", function() { return nonpassive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassivecapture", function() { return nonpassivecapture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-(--t)) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-t) * Math.sin((s - t) / p)
        : 2 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


function expIn(t) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - +t);
}

function expOut(t) {
  return 1 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - t) : 2 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t - 1)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/index.js ***!
  \*******************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _linear_js__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _cubic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic.js */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _poly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./poly.js */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _sin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sin.js */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _exp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exp.js */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circle.js */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _bounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bounce.js */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _back_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./back.js */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _elastic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elastic.js */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });






















/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
const linear = t => +t;


/***/ }),

/***/ "./node_modules/d3-ease/src/math.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/math.js ***!
  \******************************************/
/*! exports provided: tpmt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tpmt", function() { return tpmt; });
// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default, genericArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genericArray", function() { return genericArray; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return (Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_1__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/discrete.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/discrete.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hue.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hue.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["hue"])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/index.js ***!
  \**************************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateNumberArray, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _value_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _array_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _date_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "./node_modules/d3-interpolate/src/discrete.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return _discrete_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "./node_modules/d3-interpolate/src/hue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return _hue_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _number_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _object_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _round_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _string_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformSvg"]; });

/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasisClosed"]; });

/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["hslLong"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["hclLong"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["cubehelixLong"]; });

/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _piecewise_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _quantize_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });
























/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/*! exports provided: default, isNumberArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumberArray", function() { return isNumberArray; });
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"] : Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_6__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_8__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__["genericArray"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ __webpack_exports__["default"] = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return array; });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return Object(_select_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/index.js ***!
  \************************************************/
/*! exports provided: create, creator, local, matcher, namespace, namespaces, pointer, pointers, select, selectAll, selection, selector, selectorAll, style, window */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create.js */ "./node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _creator_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local.js */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _local_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _namespace_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _namespaces_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointer", function() { return _pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _pointers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pointers.js */ "./node_modules/d3-selection/src/pointers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointers", function() { return _pointers_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _select_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _selectAll_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _selection_index_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector.js */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _selector_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _selection_style_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _selection_style_js__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./window.js */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _window_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });


















/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default, childMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "childMatcher", function() { return childMatcher; });
/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
});


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(event, node) {
  event = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointers.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/pointers.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(events, node) {
  if (events.target) { // i.e., instanceof Event, not TouchList or iterable
    events = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(events);
    if (node === undefined) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, event => Object(_pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event, node));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ __webpack_exports__["default"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return !this.node();
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function*() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(lower);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Array.from(this);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(raise);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(remove);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = Object(_selectorAll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(update) {
  return new Array(update.length);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),

/***/ "./node_modules/d3-timer/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/index.js ***!
  \********************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timeout.js */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _timeout_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _interval_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });








/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? Object(_timer_js__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"];
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return this.each(function() {
    Object(_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]
      : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");



var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["default"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        string1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["set"])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_3__["tweenValue"])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(_tween_js__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity, ZoomTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["Transform"]; });





/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved(event) {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(event.view, g.moved);
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
});


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/jsts/dist/jsts.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * @license
 */
!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class n extends Error{constructor(t){super(t),this.name=Object.keys({Exception:n})[0]}toString(){return this.message}}class s extends n{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:s})[0]}}class i{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function r(){}function o(){}function l(){}function a(){}function c(){}r.NaN=NaN,r.isNaN=t=>Number.isNaN(t),r.isInfinite=t=>!Number.isFinite(t),r.MAX_VALUE=Number.MAX_VALUE,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,e=new Float64Array(1),n=new Int32Array(e.buffer);r.doubleToLongBits=function(s){e[0]=s;let r=0|n[0],o=0|n[1];return(o&t)===t&&0!=(1048575&o)&&0!==r&&(r=0,o=2146959360),new i(o,r)},r.longBitsToDouble=function(t){return n[0]=t.low,n[1]=t.high,e[0]}}():function(){const t=1023,e=Math.log2,n=Math.floor,s=Math.pow,o=function(){for(let t=53;t>0;t--){const i=s(2,t)-1;if(n(e(i))+1===t)return i}return 0}();r.doubleToLongBits=function(r){let l,a,c,h,u,g,d,_,p;if(r<0||1/r===Number.NEGATIVE_INFINITY?(g=1<<31,r=-r):g=0,0===r)return p=0,_=g,new i(_,p);if(r===1/0)return p=0,_=2146435072|g,new i(_,p);if(r!=r)return p=0,_=2146959360,new i(_,p);if(h=0,p=0,l=n(r),l>1)if(l<=o)h=n(e(l)),h<=20?(p=0,_=l<<20-h&1048575):(c=h-20,a=s(2,c),p=l%a<<32-c,_=l/a&1048575);else for(c=l,p=0;a=c/2,c=n(a),0!==c;)h++,p>>>=1,p|=(1&_)<<31,_>>>=1,a!==c&&(_|=524288);if(d=h+t,u=0===l,l=r-l,h<52&&0!==l)for(c=0;;){if(a=2*l,a>=1?(l=a-1,u?(d--,u=!1):(c<<=1,c|=1,h++)):(l=a,u?0==--d&&(h++,u=!1):(c<<=1,h++)),20===h)_|=c,c=0;else if(52===h){p|=c;break}if(1===a){h<20?_|=c<<20-h:h<52&&(p|=c<<52-h);break}}return _|=d<<20,_|=g,new i(_,p)},r.longBitsToDouble=function(e){let n,i,r,o;const l=e.high,a=e.low,c=l&1<<31?-1:1;for(r=((2146435072&l)>>20)-t,o=0,i=1<<19,n=1;n<=20;n++)l&i&&(o+=s(2,-n)),i>>>=1;for(i=1<<31,n=21;n<=52;n++)a&i&&(o+=s(2,-n)),i>>>=1;if(-1023===r){if(0===o)return 0*c;r=-1022}else{if(1024===r)return 0===o?c/0:NaN;o+=1}return c*o*s(2,r)}}();class h extends n{constructor(t){super(t),this.name=Object.keys({RuntimeException:h})[0]}}class u extends h{constructor(){super(),u.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)h.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}}}class g{static shouldNeverReachHere(){if(0===arguments.length)g.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new u("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];g.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new u:new u(t)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];g.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new u("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}const d=new ArrayBuffer(8),_=new Float64Array(d),p=new Int32Array(d);class m{constructor(){m.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)m.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];m.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return _[0]=t,p[0]^p[1]}getM(){return r.NaN}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.setZ(e);break;default:throw new s("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}setM(t){throw new s("Invalid ordinate index: "+m.M)}getZ(){return this.z}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ()}throw new s("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||r.isNaN(this.getZ())&&r.isNaN(t.getZ()))}equals(t){return t instanceof m&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.getZ(),t.getZ(),n)}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return g.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new m(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+s*s)}getY(){return this.y}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this.x),t=37*t+m.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[o,l,c]}}class f{constructor(){f.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)f.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new s("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0}compare(t,e){const n=f.compare(t.x,e.x);if(0!==n)return n;const s=f.compare(t.y,e.y);if(0!==s)return s;if(this._dimensionsToTest<=2)return 0;return f.compare(t.getZ(),e.getZ())}get interfaces_(){return[a]}}m.DimensionalComparator=f,m.NULL_ORDINATE=r.NaN,m.X=0,m.Y=1,m.Z=2,m.M=3;class y extends m{constructor(){super(),y.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)m.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof y){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case y.X:this.x=e;break;case y.Y:this.y=e;break;default:throw new s("Invalid ordinate index: "+t)}}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case y.X:return this.x;case y.Y:return this.y}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new y(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}}y.X=0,y.Y=1,y.Z=-1,y.M=-1;class x extends m{constructor(){super(),x.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof x){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];m.constructor_.call(this,t,e,m.NULL_ORDINATE),this._m=n}}getM(){return this._m}setOrdinate(t,e){switch(t){case x.X:this.x=e;break;case x.Y:this.y=e;break;case x.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case x.X:return this.x;case x.Y:return this.y;case x.M:return this._m}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new x(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}x.X=0,x.Y=1,x.Z=-1,x.M=2;class E extends m{constructor(){super(),E.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof E){const t=arguments[0];m.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];m.constructor_.call(this,t,e,n),this._m=s}}getM(){return this._m}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.z=e;break;case m.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ();case m.M:return this.getM()}throw new s("Invalid ordinate index: "+t)}copy(){return new E(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}function I(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}class N{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class S extends n{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:S})[0]}}class w extends N{get(){}set(){}isEmpty(){}}class C extends n{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:C})[0]}}class L extends w{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}get interfaces_(){return[w,N]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new T(this)}get(t){if(t<0||t>=this.size())throw new S;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort(((e,n)=>t.compare(e,n))):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}class T{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new C;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}}class R extends L{constructor(){super(),R.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&I(arguments[0],N)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){if(0===arguments.length)return this.toArray(R.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(R.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof m&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}}R.coordArrayType=new Array(0).fill(null);class P{filter(t,e){}isDone(){}isGeometryChanged(){}}class O{constructor(){O.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof O))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new O;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new O(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof m){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new O(this)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new m((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this._minx),t=37*t+m.hashCode(this._maxx),t=37*t+m.hashCode(this._miny),t=37*t+m.hashCode(this._maxy),t}get interfaces_(){return[o,c]}}class v{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class M{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new M(t)}}class b{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class D{constructor(){D.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof D){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];D.constructor_.call(this,D.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return D.determinant(D.valueOf(t),D.valueOf(e),D.valueOf(n),D.valueOf(s))}if(arguments[3]instanceof D&&arguments[2]instanceof D&&arguments[0]instanceof D&&arguments[1]instanceof D){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return D.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return D.parse(t)}if("number"==typeof arguments[0]){return new D(arguments[0])}}static sqrt(t){return D.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;b.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new D;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,b.isDigit(n)){const t=n-"0";i.selfMultiply(D.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=M.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=i;a||(o=r);const h=r-o-l;if(0===h)c=i;else if(h>0){const t=D.TEN.pow(h);c=i.divide(t)}else if(h<0){const t=D.TEN.pow(-h);c=i.multiply(t)}return s?c.negate():c}static createNaN(){return new D(r.NaN,r.NaN)}static copy(t){return new D(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new v;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=D.magnitude(n._hi);const i=D.TEN.pow(s);n=n.divide(i),n.gt(D.TEN)?(n=n.divide(D.TEN),s+=1):n.lt(D.ONE)&&(n=n.multiply(D.TEN),s-=1);const r=s+1,o=new v,l=D.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(D.valueOf(s)).multiply(D.TEN),i&&n.selfAdd(D.TEN);let c=!0;const h=D.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof D){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof D){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof D){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=D.SPLIT*o,n=l-o,c=D.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof D){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=D.SPLIT*r,e=o-r,a=D.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new D(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?D.createNaN():D.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return D.valueOf(1);let e=new D(this),n=D.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return D.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new D(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof D){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return D.valueOf(0);if(this.isNegative())return D.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=D.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=D.SPLIT*this._hi,n=o-this._hi,l=D.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return D.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new D(t,e)}negate(){return this.isNaN()?this:new D(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof D){const t=arguments[0];return t.isNaN()?D.createNaN():D.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?D.createNaN():D.copy(this).selfMultiply(t,0)}}isNaN(){return r.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=D.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+D.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+D.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=D.SPLIT*i,t=r-i,l=D.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new D(a,i-a+r)}toSciNotation(){if(this.isZero())return D.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=D.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?D.NaN:this.isNegative()?this.negate():new D(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof D){const t=arguments[0];return D.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return D.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof D){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?D.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[c,o,l]}}D.PI=new D(3.141592653589793,12246467991473532e-32),D.TWO_PI=new D(6.283185307179586,24492935982947064e-32),D.PI_2=new D(1.5707963267948966,6123233995736766e-32),D.E=new D(2.718281828459045,14456468917292502e-32),D.NaN=new D(r.NaN,r.NaN),D.EPS=123259516440783e-46,D.SPLIT=134217729,D.MAX_PRINT_DIGITS=32,D.TEN=D.valueOf(10),D.ONE=D.valueOf(1),D.SCI_NOT_EXPONENT_CHAR="E",D.SCI_NOT_ZERO="0.0E0";class A{static orientationIndex(t,e,n){const s=A.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=D.valueOf(e.x).selfAdd(-t.x),r=D.valueOf(e.y).selfAdd(-t.y),o=D.valueOf(n.x).selfAdd(-e.x),l=D.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof D&&arguments[2]instanceof D&&arguments[0]instanceof D&&arguments[1]instanceof D){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=D.valueOf(t),r=D.valueOf(e),o=D.valueOf(n),l=D.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=new D(t.y).selfSubtract(e.y),o=new D(e.x).selfSubtract(t.x),l=new D(t.x).selfMultiply(e.y).selfSubtract(new D(e.x).selfMultiply(t.y)),a=new D(n.y).selfSubtract(s.y),c=new D(s.x).selfSubtract(n.x),h=new D(n.x).selfMultiply(s.y).selfSubtract(new D(s.x).selfMultiply(n.y)),u=o.multiply(h).selfSubtract(c.multiply(l)),g=a.multiply(l).selfSubtract(i.multiply(h)),d=i.multiply(c).selfSubtract(a.multiply(o)),_=u.selfDivide(d).doubleValue(),p=g.selfDivide(d).doubleValue();return r.isNaN(_)||r.isInfinite(_)||r.isNaN(p)||r.isInfinite(p)?null:new m(_,p)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return A.signum(o);s=i+r}else{if(!(i<0))return A.signum(o);if(r>=0)return A.signum(o);s=-i-r}const l=A.DP_SAFE_EPSILON*s;return o>=l||-o>=l?A.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}A.DP_SAFE_EPSILON=1e-15;class F{getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return r.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):r.NaN}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}get interfaces_(){return[l]}}F.X=0,F.Y=1,F.Z=2,F.M=3;class G{static index(t,e,n){return A.orientationIndex(t,e,n)}static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(n)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(n)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(n)||a.equals2D(n)||l.equals2D(a))return!1;const c=G.index(l,n,a);let h=null;return h=0===c?l.x>a.x:c>0,h}if(I(arguments[0],F)){const t=arguments[0],e=t.size()-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let r=null,o=i;do{o-=1,o<0&&(o=e),r=t.getCoordinate(o)}while(r.equals2D(n)&&o!==i);let l=null,a=i;do{a=(a+1)%e,l=t.getCoordinate(a)}while(l.equals2D(n)&&a!==i);if(r.equals2D(n)||l.equals2D(n)||r.equals2D(l))return!1;const c=G.index(r,n,l);let h=null;return h=0===c?r.x>l.x:c>0,h}}}G.CLOCKWISE=-1,G.RIGHT=G.CLOCKWISE,G.COUNTERCLOCKWISE=1,G.LEFT=G.COUNTERCLOCKWISE,G.COLLINEAR=0,G.STRAIGHT=G.COLLINEAR;class q{static intersection(t,e,n,s){const i=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((i>c?i:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2,p=t.x-d,f=t.y-_,y=e.x-d,x=e.y-_,E=n.x-d,I=n.y-_,N=s.x-d,S=s.y-_,w=f-x,C=y-p,L=p*x-y*f,T=I-S,R=N-E,P=E*S-N*I,O=w*R-T*C,v=(C*P-R*L)/O,M=(T*L-w*P)/O;return r.isNaN(v)||r.isInfinite(v)||r.isNaN(M)||r.isInfinite(M)?null:new m(v+d,M+_)}}class B{static arraycopy(t,e,n,s,i){let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class Y{static log10(t){const e=Math.log(t);return r.isInfinite(e)||r.isNaN(e)?e:e/Y.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let s=arguments[0];return t>s&&(s=t),e>s&&(s=e),n>s&&(s=n),s}}static average(t,e){return(t+e)/2}}Y.LOG_10=Math.log(10);class V{static segmentToSegment(t,e,n,s){if(t.equals(e))return V.pointToSegment(t,n,s);if(n.equals(s))return V.pointToSegment(s,t,e);let i=!1;if(O.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?Y.min(V.pointToSegment(t,n,s),V.pointToSegment(e,n,s),V.pointToSegment(n,t,e),V.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new s("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let s=0;s<e.length-1;s++){const i=V.pointToSegment(t,e[s],e[s+1]);i<n&&(n=i)}return n}}class z{create(){if(1===arguments.length)arguments[0]instanceof Array||I(arguments[0],F);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class k{filter(t){}}class X{constructor(){X.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===X.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(X.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}checkNotGeometryCollection(t){if(t.getTypeCode()===X.TYPECODE_GEOMETRYCOLLECTION)throw new s("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new O(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getClass()===t.getClass()}isGeometryCollectionOrDerived(){return this.getTypeCode()===X.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===X.TYPECODE_MULTIPOINT||this.getTypeCode()===X.TYPECODE_MULTILINESTRING||this.getTypeCode()===X.TYPECODE_MULTIPOLYGON}get interfaces_(){return[l,o,c]}getClass(){return X}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}X.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},X.TYPECODE_POINT=0,X.TYPECODE_MULTIPOINT=1,X.TYPECODE_LINESTRING=2,X.TYPECODE_LINEARRING=3,X.TYPECODE_MULTILINESTRING=4,X.TYPECODE_POLYGON=5,X.TYPECODE_MULTIPOLYGON=6,X.TYPECODE_GEOMETRYCOLLECTION=7,X.TYPENAME_POINT="Point",X.TYPENAME_MULTIPOINT="MultiPoint",X.TYPENAME_LINESTRING="LineString",X.TYPENAME_LINEARRING="LinearRing",X.TYPENAME_MULTILINESTRING="MultiLineString",X.TYPENAME_POLYGON="Polygon",X.TYPENAME_MULTIPOLYGON="MultiPolygon",X.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",X.geometryChangedFilter={get interfaces_(){return[k]},filter(t){t.geometryChangedAction()}};class U{filter(t){}}class H{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new m;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}}class W{}class Z{static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,F.X)===t.getOrdinate(e-1,F.X)&&t.getOrdinate(0,F.Y)===t.getOrdinate(e-1,F.Y))}static scroll(){if(2===arguments.length){if(I(arguments[0],F)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];Z.scroll(t,e,Z.isRing(t))}else if(I(arguments[0],F)&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=Z.indexOf(e,t);if(n<=0)return null;Z.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const s=t.copy(),i=n?t.size()-1:t.size();for(let n=0;n<i;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,s.getOrdinate((e+n)%i,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(i,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let i=0;i<n;i++)for(let n=0;n<s;n++){const s=t.getOrdinate(i,n),o=e.getOrdinate(i,n);if(t.getOrdinate(i,n)!==e.getOrdinate(i,n)&&(!r.isNaN(s)||!r.isNaN(o)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return Z.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,s=null;for(let i=arguments[1];i<=e;i++){const e=t.getCoordinate(i);(null===s||s.compareTo(e)>0)&&(s=e,n=i)}return n}}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(Z.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)Z.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)Z.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)Z.copyCoord(t,e+r,n,s+r)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return Z.createClosedRing(t,e,4);return e.getOrdinate(0,F.X)===e.getOrdinate(n-1,F.X)&&e.getOrdinate(0,F.Y)===e.getOrdinate(n-1,F.Y)?e:Z.createClosedRing(t,e,n+1)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,F.X)&&t.y===e.getOrdinate(n,F.Y))return n;return-1}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();Z.copy(e,0,s,0,i);for(let t=i;t<n;t++)Z.copy(e,0,s,t,1);return s}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const s=t.getCoordinate(n);(null===e||e.compareTo(s)>0)&&(e=s)}return e}}class j extends n{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:j})[0]}}class K{static toDimensionSymbol(t){switch(t){case K.FALSE:return K.SYM_FALSE;case K.TRUE:return K.SYM_TRUE;case K.DONTCARE:return K.SYM_DONTCARE;case K.P:return K.SYM_P;case K.L:return K.SYM_L;case K.A:return K.SYM_A}throw new s("Unknown dimension value: "+t)}static toDimensionValue(t){switch(b.toUpperCase(t)){case K.SYM_FALSE:return K.FALSE;case K.SYM_TRUE:return K.TRUE;case K.SYM_DONTCARE:return K.DONTCARE;case K.SYM_P:return K.P;case K.SYM_L:return K.L;case K.SYM_A:return K.A}throw new s("Unknown dimension symbol: "+t)}}K.P=0,K.L=1,K.A=2,K.FALSE=-1,K.TRUE=-2,K.DONTCARE=-3,K.SYM_FALSE="F",K.SYM_TRUE="T",K.SYM_DONTCARE="*",K.SYM_P="0",K.SYM_L="1",K.SYM_A="2";class Q{filter(t){}}class J extends X{constructor(){super(),J.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];X.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new O:this._points.expandEnvelope(new O)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new J(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Z.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?K.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return Z.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return X.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return H.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(I(arguments[0],U)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){throw new j}isEquivalentClass(t){return t instanceof J}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return X.TYPENAME_LINESTRING}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new s("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}get interfaces_(){return[W]}}class ${}class tt extends X{constructor(){super(),tt.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];X.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new O;const t=new O;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new tt(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return K.FALSE}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return X.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(I(arguments[0],U)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(I(arguments[0],P)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return X.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),g.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}get interfaces_(){return[$]}}class et{static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(et.ofRingSigned(t))}if(I(arguments[0],F)){const t=arguments[0];return Math.abs(et.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(I(arguments[0],F)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new m,s=new m,i=new m;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}}class nt{static sort(){const t=arguments[0];if(1===arguments.length)t.sort(((t,e)=>t.compareTo(e)));else if(2===arguments.length)t.sort(((t,e)=>arguments[1].compare(t,e)));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort(((t,e)=>arguments[3].compare(t,e)));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new L;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class st{}class it extends X{constructor(){super(),it.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(X.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),X.hasNullElements(e))throw new s("holes must not contain null elements");if(t.isEmpty()&&X.hasNonEmptyElements(e))throw new s("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=et.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=et.ofRing(this._holes[e].getCoordinateSequence());return t}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new it(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);nt.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),s=Z.minCoordinateIndex(n,0,n.size()-2);Z.scroll(n,s,!0),G.isCCW(n)===e&&Z.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return X.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,s=e._shell,i=n.compareToSameClass(s,t);if(0!==i)return i;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),s=e.getInteriorRingN(l),i=n.compareToSameClass(s,t);if(0!==i)return i;l++}return l<r?1:l<o?-1:0}}apply(){if(I(arguments[0],U)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){arguments[0].filter(this)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return X.TYPENAME_POLYGON}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[st]}}class rt extends N{contains(){}}class ot extends rt{}class lt extends ot{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new j}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new at(this.array)}}class at{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new C;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new j}}class ct extends X{constructor(){super(),ct.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(X.constructor_.call(this,e),null===t&&(t=[]),X.hasNullElements(t))throw new s("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new O;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ct(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();nt.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=K.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}reverseInternal(){const t=this._geometries.length,e=new L(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return X.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=K.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new lt(nt.asList(this._geometries)),n=new lt(nt.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),s=e.getNumGeometries();let i=0;for(;i<n&&i<s;){const n=this.getGeometryN(i),s=e.getGeometryN(i),r=n.compareToSameClass(s,t);if(0!==r)return r;i++}return i<n?1:i<s?-1:0}}apply(){if(I(arguments[0],U)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return X.checkNotGeometryCollection(this),g.shouldNeverReachHere(),null}getGeometryType(){return X.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}}class ht extends ct{constructor(){super(),ht.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ct.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ht(t,this._factory)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return K.FALSE}getTypeCode(){return X.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return X.TYPENAME_MULTIPOINT}get interfaces_(){return[$]}}class ut extends J{constructor(){super(),ut.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];J.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new ut(this._points.copy(),this._factory)}getBoundaryDimension(){return K.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return Z.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return X.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new s("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<ut.MINIMUM_VALID_SIZE)throw new s("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return X.TYPENAME_LINEARRING}}ut.MINIMUM_VALID_SIZE=4;class gt{static measures(t){return t instanceof y?0:t instanceof x||t instanceof E?1:0}static dimension(t){return t instanceof y?2:t instanceof x?3:t instanceof E?4:3}static create(){if(1===arguments.length){const t=arguments[0];return gt.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new y:3===t&&0===e?new m:3===t&&1===e?new x:4===t&&1===e?new E:new m}}}class dt{static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(dt.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=dt.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);B.arraycopy(t,n,s,0,t.length-n),B.arraycopy(t,0,s,t.length-n,n),B.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new R;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,gt.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!dt.hasRepeatedPoints(t))return t;return new R(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new O;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(dt.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,gt.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=Y.clamp(e,0,t.length);let s=(n=Y.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}}dt.ForwardComparator=class{compare(t,e){const n=t,s=e;return dt.compare(n,s)}get interfaces_(){return[a]}},dt.BidirectionalComparator=class{compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=dt.compare(n,s);return dt.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=dt.increasingDirection(n),r=dt.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}get interfaces_(){return[a]}},dt.coordArrayType=new Array(0).fill(null);class _t{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class pt{constructor(){pt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];pt.constructor_.call(this,t,dt.dimension(t),dt.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new m}else if(I(arguments[0],F)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];pt.constructor_.call(this,t,e,dt.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=gt.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getM(t){return this.hasM()?this._coordinates[t].getM():r.NaN}setOrdinate(t,e,n){switch(e){case F.X:this._coordinates[t].x=n;break;case F.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():r.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case F.X:return this._coordinates[t].x;case F.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return gt.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new pt(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new _t(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}get interfaces_(){return[F,c]}}class mt{static instance(){return mt.instanceObject}readResolve(){return mt.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new pt(arguments[0])}if(I(arguments[0],F)){return new pt(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new pt(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new pt(arguments[0],e+t,t)}}}get interfaces_(){return[z,c]}}mt.instanceObject=new mt;class ft extends ct{constructor(){super(),ft.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ct.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ft(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return X.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new L;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return X.TYPENAME_MULTIPOLYGON}get interfaces_(){return[st]}}class yt{get(){}put(){}size(){}values(){}entrySet(){}}class xt extends rt{constructor(t){super(),this.map=new Map,t instanceof N&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new j}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new Et(this.map)}[Symbol.iterator](){return this.map}}class Et{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new C;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new j}}class It extends yt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new L,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new xt;return this.map.entries().forEach((e=>t.add(e))),t}size(){return this.map.size()}}class Nt{constructor(){Nt.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=Nt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof St){const t=arguments[0];this._modelType=t,t===Nt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=Nt.FIXED,this.setScale(t)}else if(arguments[0]instanceof Nt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof Nt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return M.compare(n,s)}getScale(){return this._scale}isFloating(){return this._modelType===Nt.FLOATING||this._modelType===Nt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===Nt.FLOATING?t="Floating":this._modelType===Nt.FLOATING_SINGLE?t="Floating-Single":this._modelType===Nt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(r.isNaN(t))return t;if(this._modelType===Nt.FLOATING_SINGLE){return t}return this._modelType===Nt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof m){const t=arguments[0];if(this._modelType===Nt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===Nt.FLOATING?t=16:this._modelType===Nt.FLOATING_SINGLE?t=6:this._modelType===Nt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}get interfaces_(){return[c,o]}}class St{constructor(){St.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,St.nameToTypeMap.put(t,this)}readResolve(){return St.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[c]}}St.nameToTypeMap=new It,Nt.Type=St,Nt.FIXED=new St("FIXED"),Nt.FLOATING=new St("FLOATING"),Nt.FLOATING_SINGLE=new St("FLOATING SINGLE"),Nt.maximumPreciseValue=9007199254740992;class wt extends ct{constructor(){super(),wt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ct.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new wt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?K.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return X.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new j}getGeometryType(){return X.TYPENAME_MULTILINESTRING}get interfaces_(){return[W]}}class Ct{constructor(){Ct.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Ct.constructor_.call(this,new Nt,0);else if(1===arguments.length){if(I(arguments[0],z)){const t=arguments[0];Ct.constructor_.call(this,new Nt,0,t)}else if(arguments[0]instanceof Nt){const t=arguments[0];Ct.constructor_.call(this,t,0,Ct.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ct.constructor_.call(this,t,e,Ct.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return mt.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new s("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new m(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new m(t.getMinX(),t.getMinY()),new m(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new m(t.getMinX(),t.getMinY()),new m(t.getMinX(),t.getMaxY()),new m(t.getMaxX(),t.getMaxY()),new m(t.getMaxX(),t.getMinY()),new m(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],F)){return new J(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new wt(null,this);if(1===arguments.length){return new wt(arguments[0],this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof ct&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Ct.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof it)return this.createMultiPolygon(Ct.toPolygonArray(t));if(i instanceof J)return this.createMultiLineString(Ct.toLineStringArray(t));if(i instanceof tt)return this.createMultiPoint(Ct.toPointArray(t));g.shouldNeverReachHere("Unhandled geometry type: "+i.getGeometryType())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(I(arguments[0],F)){return new tt(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(I(arguments[0],F)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof ut){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new it(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new ct(null,this);if(1===arguments.length){return new ct(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],F)){return new ut(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){return new ft(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new ht(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new ht(arguments[0],this)}if(I(arguments[0],F)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());Z.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}get interfaces_(){return[c]}}const Lt="XY",Tt="XYZ",Rt="XYM",Pt="XYZM",Ot={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},vt="EMPTY",Mt=1,bt=2,Dt=3,At=4,Ft=5,Gt=6,qt={};for(const t in Ot)qt[t]=Ot[t].toUpperCase();class Bt{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,s=t;if("("==t)n=bt;else if(","==t)n=Ft;else if(")"==t)n=Dt;else if(this.isNumeric_(t)||"-"==t)n=At,s=this.readNumber_();else if(this.isAlpha_(t))n=Mt,s=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=Gt}return{position:e,value:s,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,s=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(s=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!s&&("e"==t||"E"==t)||s&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class Yt{constructor(t,e){this.lexer_=t,this.token_,this.layout_=Lt,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){this.consume_();return this.parseGeometry_()}parseGeometryLayout_(){let t=Lt;const e=this.token_;if(this.isTokenType(Mt)){const n=e.value;"Z"===n?t=Tt:"M"===n?t=Rt:"ZM"===n&&(t=Pt),t!==Lt&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(bt)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(Ft));if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(bt)){const t=this.parsePoint_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(bt)){const t=this.parsePointList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(bt)){const t=this.parseLineStringTextList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(bt)){let t;if(t=this.token_.type==bt?this.parsePointTextList_():this.parsePointList_(),this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(bt)){const t=this.parseLineStringTextList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(bt)){const t=this.parsePolygonTextList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(At))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(Ft);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(Ft);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(Ft);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(Ft);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(Mt)&&this.token_.value==vt;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>new m(...t),n=n=>{const s=n.map((n=>t.createLinearRing(n.map(e))));return s.length>1?t.createPolygon(s[0],s.slice(1)):t.createPolygon(s[0])},s=this.token_;if(this.match(Mt)){const i=s.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==i){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(i){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new m(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const s=n.map(e).map((e=>t.createPoint(e)));return t.createMultiPoint(s)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map((n=>t.createLineString(n.map(e))));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const s=e.map(n);return t.createMultiPolygon(s)}default:throw new Error("Invalid geometry type: "+i)}}throw new Error(this.formatErrorMessage_())}}function Vt(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return e.z&&n.push(e.z),e.m&&n.push(e.m),n.join(" ")}function zt(t){const e=t.getCoordinates().map((t=>[t.x,t.y])),n=[];for(let t=0,s=e.length;t<s;++t)n.push(e[t].join(" "));return n.join(", ")}function kt(t){const e=[];e.push("("+zt(t.getExteriorRing())+")");for(let n=0,s=t.getNumInteriorRing();n<s;++n)e.push("("+zt(t.getInteriorRingN(n))+")");return e.join(", ")}const Xt={Point:Vt,LineString:zt,LinearRing:zt,Polygon:kt,MultiPoint:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Vt(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+zt(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+kt(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push(Ut(t.getGeometryN(n)));return e.join(", ")}};function Ut(t){let e=t.getGeometryType();const n=Xt[e];e=e.toUpperCase();const s=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return n.z&&(e+="Z"),n.m&&(e+="M"),e}(t);if(s.length>0&&(e+=" "+s),t.isEmpty())return e+" "+vt;return e+" ("+n(t)+")"}class Ht{constructor(t){this.geometryFactory=t||new Ct,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new Bt(t);return new Yt(e,this.geometryFactory).parse()}write(t){return Ut(t)}}class Wt{constructor(t){this.parser=new Ht(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class Zt{constructor(){Zt.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map((()=>Array(2))),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new m,this._intPt[1]=new m,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return g.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return g.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new _t;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map((()=>Array(2))),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Zt.NO_INTERSECTION}getEdgeDistance(t,e){return Zt.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Zt.COLLINEAR_INTERSECTION}toString(){return Wt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Wt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Zt.DONT_INTERSECT=0,Zt.DO_INTERSECT=1,Zt.COLLINEAR=2,Zt.NO_INTERSECTION=0,Zt.POINT_INTERSECTION=1,Zt.COLLINEAR_INTERSECTION=2;class jt extends Zt{constructor(){super()}static nearestEndpoint(t,e,n,s){let i=t,r=V.pointToSegment(t,n,s),o=V.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=V.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=V.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new O(this._inputLines[0][0],this._inputLines[0][1]),n=new O(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,O.intersects(e,n,t)&&0===G.index(e,n,t)&&0===G.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Zt.POINT_INTERSECTION,null;this._result=Zt.NO_INTERSECTION}}intersection(t,e,n,s){let i=this.intersectionSafe(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new m(jt.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}checkDD(t,e,n,s,i){const r=A.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);B.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&B.out.println("Distance = "+i.distance(r))}intersectionSafe(t,e,n,s){let i=q.intersection(t,e,n,s);return null===i&&(i=jt.nearestEndpoint(t,e,n,s)),i}computeCollinearIntersection(t,e,n,s){const i=O.intersects(t,e,n),r=O.intersects(t,e,s),o=O.intersects(n,s,t),l=O.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,Zt.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Zt.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):Zt.NO_INTERSECTION}computeIntersect(t,e,n,s){if(this._isProper=!1,!O.intersects(t,e,n,s))return Zt.NO_INTERSECTION;const i=G.index(t,e,n),r=G.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return Zt.NO_INTERSECTION;const o=G.index(n,s,t),l=G.index(n,s,e);if(o>0&&l>0||o<0&&l<0)return Zt.NO_INTERSECTION;return 0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new m(n):0===r?this._intPt[0]=new m(s):0===o?this._intPt[0]=new m(t):0===l&&(this._intPt[0]=new m(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),Zt.POINT_INTERSECTION)}}class Kt{constructor(){Kt.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)Kt.constructor_.call(this,new m,new m);else if(1===arguments.length){const t=arguments[0];Kt.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,new m(t,e),new m(n,s))}}static midPoint(t,e){return new m((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof Kt){const t=arguments[0],e=G.index(this.p0,this.p1,t.p0),n=G.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof m){const t=arguments[0];return G.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof Kt))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new jt;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof m){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new m(t);const e=this.projectionFactor(t),n=new m;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof Kt){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new Kt(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return V.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return Kt.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;if(s<=0)return r.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=r.MAX_VALUE,i=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);i=l.distance(t.p1),i<s&&(s=i,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);i=a.distance(this.p0),i<s&&(s=i,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return i=c.distance(this.p1),i<s&&(s=i,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return q.intersection(this.p0,this.p1,t.p0,t.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new m(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||r.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),s=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),i=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new m((-r*o-2*e*n*l-2*e*s)/i,(r*l-2*e*n*o-2*n*s)/i)}distance(){if(arguments[0]instanceof Kt){const t=arguments[0];return V.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof m){const t=arguments[0];return V.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new m;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=r.doubleToLongBits(this.p0.x);t^=31*r.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=r.doubleToLongBits(this.p1.x);n^=31*r.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))}get interfaces_(){return[o,c]}}class Qt{static toLocationSymbol(t){switch(t){case Qt.EXTERIOR:return"e";case Qt.BOUNDARY:return"b";case Qt.INTERIOR:return"i";case Qt.NONE:return"-"}throw new s("Unknown location value: "+t)}}Qt.INTERIOR=0,Qt.BOUNDARY=1,Qt.EXTERIOR=2,Qt.NONE=-1;class Jt{constructor(){Jt.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map((()=>Array(3))),this.setAll(K.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Jt.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Jt){const t=arguments[0];Jt.constructor_.call(this),this._matrix[Qt.INTERIOR][Qt.INTERIOR]=t._matrix[Qt.INTERIOR][Qt.INTERIOR],this._matrix[Qt.INTERIOR][Qt.BOUNDARY]=t._matrix[Qt.INTERIOR][Qt.BOUNDARY],this._matrix[Qt.INTERIOR][Qt.EXTERIOR]=t._matrix[Qt.INTERIOR][Qt.EXTERIOR],this._matrix[Qt.BOUNDARY][Qt.INTERIOR]=t._matrix[Qt.BOUNDARY][Qt.INTERIOR],this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]=t._matrix[Qt.BOUNDARY][Qt.BOUNDARY],this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]=t._matrix[Qt.BOUNDARY][Qt.EXTERIOR],this._matrix[Qt.EXTERIOR][Qt.INTERIOR]=t._matrix[Qt.EXTERIOR][Qt.INTERIOR],this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]=t._matrix[Qt.EXTERIOR][Qt.BOUNDARY],this._matrix[Qt.EXTERIOR][Qt.EXTERIOR]=t._matrix[Qt.EXTERIOR][Qt.EXTERIOR]}}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===K.SYM_DONTCARE||(e===K.SYM_TRUE&&(t>=0||t===K.TRUE)||(e===K.SYM_FALSE&&t===K.FALSE||(e===K.SYM_P&&t===K.P||(e===K.SYM_L&&t===K.L||e===K.SYM_A&&t===K.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Jt(arguments[0]).matches(t)}}static isTrue(t){return t>=0||t===K.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===K.FALSE}isCoveredBy(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===K.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=K.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===K.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,K.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===K.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===K.A&&e===K.A||t===K.L&&e===K.L||t===K.L&&e===K.A||t===K.P&&e===K.A||t===K.P&&e===K.L)&&(this._matrix[Qt.INTERIOR][Qt.INTERIOR]===K.FALSE&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY])))}isOverlaps(t,e){return t===K.P&&e===K.P||t===K.A&&e===K.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===K.L&&e===K.L&&(1===this._matrix[Qt.INTERIOR][Qt.INTERIOR]&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]))}isEquals(t,e){return t===e&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===K.FALSE)}toString(){const t=new _t("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,K.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new s("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Jt.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[Qt.INTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.INTERIOR][Qt.BOUNDARY]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]===K.FALSE}isCrosses(t,e){return t===K.P&&e===K.L||t===K.P&&e===K.A||t===K.L&&e===K.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR]):t===K.L&&e===K.P||t===K.A&&e===K.P||t===K.A&&e===K.L?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===K.L&&e===K.L&&0===this._matrix[Qt.INTERIOR][Qt.INTERIOR]}get interfaces_(){return[l]}}class $t{static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=$t.PI_TIMES_2;for(;t<=-Math.PI;)t+=$t.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=$t.PI_TIMES_2;t>=$t.PI_TIMES_2&&(t=0)}else{for(;t>=$t.PI_TIMES_2;)t-=$t.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return $t.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?$t.COUNTERCLOCKWISE:n<0?$t.CLOCKWISE:$t.NONE}static angleBetweenOriented(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n)-s;return i<=-Math.PI?i+$t.PI_TIMES_2:i>Math.PI?i-$t.PI_TIMES_2:i}}$t.PI_TIMES_2=2*Math.PI,$t.PI_OVER_2=Math.PI/2,$t.PI_OVER_4=Math.PI/4,$t.COUNTERCLOCKWISE=G.COUNTERCLOCKWISE,$t.CLOCKWISE=G.CLOCKWISE,$t.NONE=G.COLLINEAR;class te extends n{constructor(){super(),te.constructor_.apply(this,arguments)}static constructor_(){n.constructor_.call(this,"Projective point not representable on the Cartesian plane.")}}class ee{constructor(){ee.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof ee&&arguments[1]instanceof ee){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}}getY(){const t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getX(){const t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getCoordinate(){const t=new m;return t.x=this.getX(),t.y=this.getY(),t}}class ne{constructor(){ne.constructor_.apply(this,arguments)}static constructor_(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static circumcentreDD(t,e,n){const s=D.valueOf(t.x).subtract(n.x),i=D.valueOf(t.y).subtract(n.y),r=D.valueOf(e.x).subtract(n.x),o=D.valueOf(e.y).subtract(n.y),l=D.determinant(s,i,r,o).multiply(2),a=s.sqr().add(i.sqr()),c=r.sqr().add(o.sqr()),h=D.determinant(i,a,o,c),u=D.determinant(s,a,r,c),g=D.valueOf(n.x).subtract(h.divide(l)).doubleValue(),d=D.valueOf(n.y).add(u.divide(l)).doubleValue();return new m(g,d)}static isAcute(t,e,n){return!!$t.isAcute(t,e,n)&&(!!$t.isAcute(e,n,t)&&!!$t.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*ne.det(r,o,l,a),h=ne.det(o,r*r+o*o,a,l*l+a*a),u=ne.det(r,r*r+o*o,l,l*l+a*a);return new m(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new ee(t.x+n/2,t.y+s/2,1),r=new ee(t.x-s+n/2,t.y+n+s/2,1);return new ee(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new m(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.getZ()-t.getZ(),o=n.x-t.x,l=n.y-t.y,a=n.getZ()-t.getZ(),c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new m(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new m(l,a)}area(){return ne.area(this.p0,this.p1,this.p2)}signedArea(){return ne.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new s("Supplied point is null.");return ne.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return ne.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return ne.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return ne.circumcentre(this.p0,this.p1,this.p2)}area3D(){return ne.area3D(this.p0,this.p1,this.p2)}centroid(){return ne.centroid(this.p0,this.p1,this.p2)}inCentre(){return ne.inCentre(this.p0,this.p1,this.p2)}}class se extends n{constructor(){super(),se.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)n.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];n.constructor_.call(this,t)}}}class ie{constructor(){ie.constructor_.apply(this,arguments)}static constructor_(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof ie){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}}static translationInstance(t,e){const n=new ie;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new ie;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return ie.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return ie.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,n,i){if(t===n&&e===i)throw new s("Reflection line points must be distinct");const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new se("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new ie(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof ie))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(ie.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(ie.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(ie.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.rotationInstance(t,e,n,s)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof n))throw t;g.shouldNeverReachHere()}return null}translate(t,e){return this.compose(ie.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const n=Math.sqrt(t*t+e*e),i=e/n,r=t/n;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];if(t===n&&e===i)throw new s("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(ie.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(I(arguments[0],F)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.reflectionInstance(t,e,n,s)),this}}get interfaces_(){return[l,P]}}class re{static solve(t,e){const n=e.length;if(t.length!==n||t[0].length!==n)throw new s("Matrix A is incorrectly sized");for(let s=0;s<n;s++){let i=s;for(let e=s+1;e<n;e++)Math.abs(t[e][s])>Math.abs(t[i][s])&&(i=e);if(0===t[i][s])return null;re.swapRows(t,s,i),re.swapRows(e,s,i);for(let i=s+1;i<n;i++){const r=t[i][s]/t[s][s];for(let e=n-1;e>=s;e--)t[i][e]-=t[s][e]*r;e[i]-=e[s]*r}}const i=new Array(n).fill(null);for(let s=n-1;s>=0;s--){let r=0;for(let e=s+1;e<n;e++)r+=t[s][e]*i[e];i[s]=(e[s]-r)/t[s][s]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}}class oe{constructor(){oe.constructor_.apply(this,arguments)}static constructor_(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return re.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new ie(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}}class le{static createFromBaseLines(t,e,n,s){const i=new m(t.x+s.x-n.x,t.y+s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new ie;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return ie.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new s("Src and Dest arrays are not the same length");if(t.length<=0)throw new s("Too few control points");if(t.length>3)throw new s("Too many control points");return 1===t.length?le.createFromControlVectors(t[0],e[0]):2===t.length?le.createFromControlVectors(t[0],t[1],e[0],e[1]):le.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new m(s.x-n.x,s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){return new oe(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]).getTransformation()}}}}class ae{constructor(){ae.constructor_.apply(this,arguments)}static constructor_(){this._coords=null;const t=arguments[0];this._coords=t}static getCoordinates(t){const e=new L;return t.apply(new ae(e)),e}filter(t){(t instanceof J||t instanceof tt)&&this._coords.add(t.getCoordinate())}get interfaces_(){return[k]}}class ce{constructor(){ce.constructor_.apply(this,arguments)}static constructor_(){this._mapOp=null;const t=arguments[0];this._mapOp=t}static map(t,e){return new ce(e).map(t)}map(t){const e=new L;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Ct.toGeometryArray(e))}}class he{constructor(){he.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=he.extractFactory(t),this._inputGeoms=t}static combine(){if(1===arguments.length){return new he(arguments[0]).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new he(he.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new he(he.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new L;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new L;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}}class ue{constructor(){ue.constructor_.apply(this,arguments)}static constructor_(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof ct?this.editGeometryCollection(t,e):t instanceof it?this.editPolygon(t,e):t instanceof tt||t instanceof J?e.edit(t,this._factory):(g.shouldNeverReachHere("Unsupported Geometry type: "+t.getGeometryType()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new L;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getGeometryType()===X.TYPENAME_MULTIPOINT?this._factory.createMultiPoint(s.toArray([])):n.getGeometryType()===X.TYPENAME_MULTILINESTRING?this._factory.createMultiLineString(s.toArray([])):n.getGeometryType()===X.TYPENAME_MULTIPOLYGON?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new L;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}}function ge(){}ue.GeometryEditorOperation=ge;ue.NoOpGeometryOperation=class{edit(t,e){return t}get interfaces_(){return[ge]}},ue.CoordinateOperation=class{edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof ut?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof J?null===n?e.createLineString():e.createLineString(n):t instanceof tt?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}get interfaces_(){return[ge]}},ue.CoordinateSequenceOperation=class{edit(t,e){return t instanceof ut?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof J?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof tt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}get interfaces_(){return[ge]}};class de{constructor(){de.constructor_.apply(this,arguments)}static constructor_(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e}static isOfType(t,e){return t.getGeometryType()===e||e===X.TYPENAME_LINESTRING&&t.getGeometryType()===X.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return de.extract(t,e,new L)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof ct&&t.apply(new de(e,n)),n}}filter(t){(null===this._geometryType||de.isOfType(t,this._geometryType))&&this._comps.add(t)}get interfaces_(){return[Q]}}class _e{static map(){if(arguments[0]instanceof X&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(I(arguments[0],N)&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}}function pe(){}_e.MapOp=pe;class me{constructor(){me.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof ut&&!s.isEmpty()||(n=!1);const i=new L;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof ut||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new L;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Ct.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof tt)return this.transformPoint(t,null);if(t instanceof ht)return this.transformMultiPoint(t,null);if(t instanceof ut)return this.transformLinearRing(t,null);if(t instanceof J)return this.transformLineString(t,null);if(t instanceof wt)return this.transformMultiLineString(t,null);if(t instanceof it)return this.transformPolygon(t,null);if(t instanceof ft)return this.transformMultiPolygon(t,null);if(t instanceof ct)return this.transformGeometryCollection(t,null);throw new s("Unknown Geometry subtype: "+t.getGeometryType())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}}class fe{constructor(){fe.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getGeometry(t){return t.getFactory().buildGeometry(fe.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return fe.getLines(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof J?e.add(t):t instanceof ct&&t.apply(new fe(e)),e}}filter(t){t instanceof J&&this._comps.add(t)}get interfaces_(){return[Q]}}class ye{constructor(){ye.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(ye.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(ye.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,!1)}if(2===arguments.length){if(I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();ye.getLines(n,t)}return t}if(arguments[0]instanceof X&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new L;return t.apply(new ye(n,e)),n}if(arguments[0]instanceof X&&I(arguments[1],N)){const t=arguments[0],e=arguments[1];return t instanceof J?e.add(t):t.apply(new ye(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const s=n.next();ye.getLines(s,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof X&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new ye(t,e)),t}}}filter(t){if(this._isForcedToLineString&&t instanceof ut){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof J&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[k]}}const xe={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return xe.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?nt.sort(n,e):nt.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new L;return e.add(t),e}};class Ee{constructor(){Ee.constructor_.apply(this,arguments)}static constructor_(){this._pts=null;const t=arguments[0];this._pts=t}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof tt?xe.singletonList(t):Ee.getPoints(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof tt?e.add(t):t instanceof ct&&t.apply(new Ee(e)),e}}filter(t){t instanceof tt&&this._pts.add(t)}get interfaces_(){return[Q]}}class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ie.getPolygons(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof it?e.add(t):t instanceof ct&&t.apply(new Ie(e)),e}}filter(t){t instanceof it&&this._comps.add(t)}get interfaces_(){return[Q]}}class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof ct)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class Se{constructor(){Se.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._precModel=null,this._dim=new we,this._nPts=100,this._rotationAngle=0,0===arguments.length)Se.constructor_.call(this,new Ct);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new m(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=ie.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new m(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}}class we{constructor(){we.constructor_.apply(this,arguments)}static constructor_(){this.base=null,this.centre=null,this.width=null,this.height=null}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new m(t.getMinX(),t.getMinY()),this.centre=new m(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new O(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new O(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new O(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new m(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}}Se.Dimensions=we;class Ce extends Se{constructor(){super(),Ce.constructor_.apply(this,arguments)}static constructor_(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)Se.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];Se.constructor_.call(this,t)}}static create(t,e,n,s,i){const r=new Ce;r.setCentre(t),r.setSize(e),r.setNumPoints(n),r.setArmLengthRatio(i),r.setNumArms(s);return r.createSineStar()}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new m(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}}var Le=Object.freeze({__proto__:null,AffineTransformation:ie,AffineTransformationBuilder:oe,AffineTransformationFactory:le,ComponentCoordinateExtracter:ae,GeometryCollectionMapper:ce,GeometryCombiner:he,GeometryEditor:ue,GeometryExtracter:de,GeometryMapper:_e,GeometryTransformer:me,LineStringExtracter:fe,LinearComponentExtracter:ye,PointExtracter:Ee,PolygonExtracter:Ie,ShortCircuitedGeometryVisitor:Ne,SineStarFactory:Ce}),Te=Object.freeze({__proto__:null,Coordinate:m,CoordinateXY:y,CoordinateXYM:x,CoordinateXYZM:E,CoordinateList:R,CoordinateSequenceFilter:P,Envelope:O,LineSegment:Kt,GeometryFactory:Ct,Geometry:X,Point:tt,LineString:J,LinearRing:ut,Polygon:it,GeometryCollection:ct,MultiPoint:ht,MultiLineString:wt,MultiPolygon:ft,Dimension:K,IntersectionMatrix:Jt,PrecisionModel:Nt,Location:Qt,Triangle:ne,util:Le});class Re{constructor(){Re.constructor_.apply(this,arguments)}static constructor_(){this._pt=[new m,new m],this._distance=r.NaN,this._isNull=!0}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Wt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}}class Pe{static computeDistance(){if(arguments[2]instanceof Re&&arguments[0]instanceof J&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Kt,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Re&&arguments[0]instanceof it&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];Pe.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)Pe.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Re&&arguments[0]instanceof X&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof J)Pe.computeDistance(t,e,n);else if(t instanceof it)Pe.computeDistance(t,e,n);else if(t instanceof ct){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);Pe.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Re&&arguments[0]instanceof Kt&&arguments[1]instanceof m){const t=arguments[1],e=arguments[2],n=arguments[0].closestPoint(t);e.setMinimum(n,t)}}}class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static constructor_(){this._g0=null,this._g1=null,this._ptDist=new Re,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e}static distance(){if(2===arguments.length){return new Oe(arguments[0],arguments[1]).distance()}if(3===arguments.length){const t=arguments[2],e=new Oe(arguments[0],arguments[1]);return e.setDensifyFraction(t),e.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new s("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new ve(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new Me(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}}class ve{constructor(){ve.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._euclideanDist=new Pe,this._geom=null;const t=arguments[0];this._geom=t}filter(t){this._minPtDist.initialize(),Pe.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[U]}}class Me{constructor(){Me.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new m(e,s);this._minPtDist.initialize(),Pe.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[P]}}Oe.MaxPointDistanceFilter=ve,Oe.MaxDensifiedByFractionDistanceFilter=Me;var be=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:Pe,PointPairDistance:Re});class De{visitItem(t){}}class Ae{locate(t){}}class Fe{constructor(){Fe.constructor_.apply(this,arguments)}static constructor_(){this._min=r.POSITIVE_INFINITY,this._max=r.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Wt.toLineString(new m(this._min,0),new m(this._max,0))}}Fe.NodeComparator=class{compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}get interfaces_(){return[a]}};class Ge extends Fe{constructor(){super(),Ge.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class qe extends Fe{constructor(){super(),qe.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class Be{constructor(){Be.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new L,this._root=null,this._level=0}buildTree(){xe.sort(this._leaves,new Fe.NodeComparator);let t=this._leaves,e=null,n=new L;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new IllegalStateException("Index cannot be added to once it has been queried");this._leaves.add(new Ge(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){B.out.println(Wt.toLineString(new m(t._min,this._level),new m(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new qe(t.get(n),t.get(n+1));e.add(s)}}}}class Ye{constructor(){Ye.constructor_.apply(this,arguments)}static constructor_(){this._items=new L}visitItem(t){this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class Ve{constructor(){Ve.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof m&&I(arguments[1],F)){const t=arguments[1],e=new Ve(arguments[0]),n=new m,s=new m;for(let i=1;i<t.size();i++)if(t.getCoordinate(i,n),t.getCoordinate(i-1,s),e.countSegment(n,s),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[1],e=new Ve(arguments[0]);for(let n=1;n<t.length;n++){const s=t[n],i=t[n-1];if(e.countSegment(s,i),e.isOnSegment())return e.getLocation()}return e.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=G.index(t,e,this._p);if(n===G.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===G.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==Qt.EXTERIOR}getLocation(){return this._isPointOnSegment?Qt.BOUNDARY:this._crossingCount%2==1?Qt.INTERIOR:Qt.EXTERIOR}isOnSegment(){return this._isPointOnSegment}}class ze{constructor(){ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(I(t,st)||t instanceof ut))throw new s("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new Xe(this._geom),this._geom=null);const e=new Ve(t),n=new ke(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[Ae]}}class ke{constructor(){ke.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[De]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new Be;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new Kt(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new L;const n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}ze.SegmentVisitor=ke,ze.IntervalIndexedGeometry=Xe;class Ue{static isOnLine(){if(arguments[0]instanceof m&&I(arguments[1],F)){const t=arguments[0],e=arguments[1],n=new jt,s=new m,i=new m,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new jt;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ve.locatePointInRing(t,e)}static isInRing(t,e){return Ue.locateInRing(t,e)!==Qt.EXTERIOR}}class He{hasNext(){}next(){}remove(){}}class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof ct)}next(){if(this._atStart)return this._atStart=!1,We.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new C;const t=this._parent.getGeometryN(this._index++);return t instanceof ct?(this._subcollectionIterator=new We(t),this._subcollectionIterator.next()):t}remove(){throw new j(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}get interfaces_(){return[He]}}class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==Qt.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===Qt.BOUNDARY)return Qt.BOUNDARY;if(i===Qt.INTERIOR)return Qt.EXTERIOR}return Qt.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}static containsPointInPolygon(t,e){return Qt.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof it)return Ze.locatePointInPolygon(t,e);if(e instanceof ct){const n=new We(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==Qt.EXTERIOR)return e}}}return Qt.EXTERIOR}static isContained(t,e){return Qt.EXTERIOR!==Ze.locate(t,e)}static locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e.getEnvelopeInternal().intersects(t)?Ze.locateInGeometry(t,e):Qt.EXTERIOR}locate(t){return Ze.locate(t,this._geom)}get interfaces_(){return[Ae]}}var je=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ze,PointOnGeometryLocator:Ae,SimplePointInAreaLocator:Ze});class Ke{measure(t,e){}}class Qe{static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,Qe.DENSIFY_FRACTION),s=new O(t.getEnvelopeInternal());s.expandToInclude(e.getEnvelopeInternal());return 1-n/Qe.diagonalSize(s)}get interfaces_(){return[Ke]}}Qe.DENSIFY_FRACTION=.25;var Je=Object.freeze({__proto__:null,AreaSimilarityMeasure:class{measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}get interfaces_(){return[Ke]}},HausdorffSimilarityMeasure:Qe,SimilarityMeasure:Ke,SimilarityMeasureCombiner:class{static combine(t,e){return Math.min(t,e)}}});class $e{constructor(){$e.constructor_.apply(this,arguments)}static constructor_(){this._areaBasePt=null,this._triangleCent3=new m,this._areasum2=0,this._cg3=new m,this._lineCentSum=new m,this._totalLength=0,this._ptCount=0,this._ptCentSum=new m;const t=arguments[0];this._areaBasePt=null,this.add(t)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new $e(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=G.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new m;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!G.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;$e.centroid3(t,e,n,this._triangleCent3);const r=$e.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof it){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof X){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof tt)this.addPoint(t.getCoordinate());else if(t instanceof J)this.addLineSegments(t.getCoordinates());else if(t instanceof it){const e=t;this.add(e)}else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}}class tn extends n{constructor(t){super(t),this.name=Object.keys({EmptyStackException:tn})[0]}}class en extends w{constructor(){super(),this.array=[]}add(t){return this.array.push(t),!0}get(t){if(t<0||t>=this.size())throw new S;return this.array[t]}push(t){return this.array.push(t),t}pop(){if(0===this.array.length)throw new tn;return this.array.pop()}peek(){if(0===this.array.length)throw new tn;return this.array[this.array.length-1]}empty(){return 0===this.array.length}isEmpty(){return this.empty()}search(t){return this.array.indexOf(t)}size(){return this.array.length}toArray(){return this.array.slice()}}class nn{constructor(){nn.constructor_.apply(this,arguments)}static constructor_(){this._coordSet=new xt,this._list=new L}static filterCoordinates(t){const e=new nn;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this._coordSet.add(t)&&this._list.add(t)}getCoordinates(){const t=new Array(this._list.size()).fill(null);return this._list.toArray(t)}get interfaces_(){return[U]}}class sn{constructor(){sn.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];sn.constructor_.call(this,sn.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=nn.filterCoordinates(t),this._geomFactory=e}}static extractCoordinates(t){const e=new nn;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return nt.sort(t,1,t.length,new rn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new R;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){g.equals(t[0],t[t.length-1]);const e=new L;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==G.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new lt;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)Ue.isInRing(t[s],e)||n.add(t[s]);const s=dt.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new en;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&G.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}}class rn{constructor(){rn.constructor_.apply(this,arguments)}static constructor_(){this._origin=null;const t=arguments[0];this._origin=t}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=G.index(t,e,n);if(l===G.COUNTERCLOCKWISE)return 1;if(l===G.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return rn.polarCompare(this._origin,n,s)}get interfaces_(){return[a]}}sn.RadialComparator=rn;class on{constructor(){on.constructor_.apply(this,arguments)}static constructor_(){this._interiorPoint=null,this._maxWidth=-1;const t=arguments[0];this.process(t)}static getInteriorPoint(t){return new on(t).getInteriorPoint()}static avg(t,e){return(t+e)/2}getInteriorPoint(){return this._interiorPoint}process(t){if(t.isEmpty())return null;if(t instanceof it)this.processPolygon(t);else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.process(e.getGeometryN(t))}}processPolygon(t){const e=new ln(t);e.process();const n=e.getWidth();n>this._maxWidth&&(this._maxWidth=n,this._interiorPoint=e.getInteriorPoint())}}class ln{constructor(){ln.constructor_.apply(this,arguments)}static constructor_(){this._polygon=null,this._interiorPointY=null,this._interiorSectionWidth=0,this._interiorPoint=null;const t=arguments[0];this._polygon=t,this._interiorPointY=cn.getScanLineY(t)}static isEdgeCrossingCounted(t,e,n){const s=t.getY(),i=e.getY();return s!==i&&(!(s===n&&i<n)&&!(i===n&&s<n))}static intersectsHorizontalLine(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!(e<t.getMinY())&&!(e>t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return!(t.getY()>n&&e.getY()>n)&&!(t.getY()<n&&e.getY()<n)}}static intersection(t,e,n){const s=t.getX(),i=e.getX();if(s===i)return s;const r=i-s,o=(e.getY()-t.getY())/r;return s+(n-t.getY())/o}findBestMidpoint(t){if(0===t.size())return null;g.isTrue(0==t.size()%2,"Interior Point robustness failure: odd number of scanline crossings"),t.sort(new an);for(let e=0;e<t.size();e+=2){const n=t.get(e),s=t.get(e+1),i=s-n;if(i>this._interiorSectionWidth){this._interiorSectionWidth=i;const t=on.avg(n,s);this._interiorPoint=new m(t,this._interiorPointY)}}}process(){if(this._polygon.isEmpty())return null;this._interiorPoint=new m(this._polygon.getCoordinate());const t=new L;this.scanRing(this._polygon.getExteriorRing(),t);for(let e=0;e<this._polygon.getNumInteriorRing();e++)this.scanRing(this._polygon.getInteriorRingN(e),t);this.findBestMidpoint(t)}scanRing(t,e){if(!ln.intersectsHorizontalLine(t.getEnvelopeInternal(),this._interiorPointY))return null;const n=t.getCoordinateSequence();for(let t=1;t<n.size();t++){const s=n.getCoordinate(t-1),i=n.getCoordinate(t);this.addEdgeCrossing(s,i,this._interiorPointY,e)}}getWidth(){return this._interiorSectionWidth}getInteriorPoint(){return this._interiorPoint}addEdgeCrossing(t,e,n,s){if(!ln.intersectsHorizontalLine(t,e,n))return null;if(!ln.isEdgeCrossingCounted(t,e,n))return null;const i=ln.intersection(t,e,n);s.add(i)}}class an{compare(t,e){return t<e?-1:t>e?1:0}get interfaces_(){return[a]}}ln.DoubleComparator=an;class cn{constructor(){cn.constructor_.apply(this,arguments)}static constructor_(){this._poly=null,this._centreY=null,this._hiY=r.MAX_VALUE,this._loY=-r.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=on.avg(this._loY,this._hiY)}static getScanLineY(t){return new cn(t).getScanLineY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getScanLineY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return on.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}}on.InteriorPointPolygon=ln,on.ScanLineYOrdinateFinder=cn;class hn{constructor(){hn.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=null:(this._centroid=$e.getCentroid(t),t.getPrecisionModel().makePrecise(this._centroid)),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)}static getInteriorPoint(t){return new hn(t).getInteriorPoint()}addEndpoints(){if(arguments[0]instanceof X){const t=arguments[0];if(t instanceof J)this.addEndpoints(t.getCoordinates());else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof X){const t=arguments[0];if(t instanceof J)this.addInterior(t.getCoordinates());else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}class un{constructor(){un.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=$e.getCentroid(t),this.add(t)}static getInteriorPoint(t){return new un(t).getInteriorPoint()}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof X){const t=arguments[0];if(t instanceof tt)this.add(t.getCoordinate());else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof m){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}}class gn{isInBoundary(t){}}class dn{isInBoundary(t){return t%2==1}get interfaces_(){return[gn]}}class _n{isInBoundary(t){return t>0}get interfaces_(){return[gn]}}class pn{isInBoundary(t){return t>1}get interfaces_(){return[gn]}}class mn{isInBoundary(t){return 1===t}get interfaces_(){return[gn]}}gn.Mod2BoundaryNodeRule=dn,gn.EndPointBoundaryNodeRule=_n,gn.MultiValentEndPointBoundaryNodeRule=pn,gn.MonoValentEndPointBoundaryNodeRule=mn,gn.MOD2_BOUNDARY_RULE=new dn,gn.ENDPOINT_BOUNDARY_RULE=new _n,gn.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new pn,gn.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new mn,gn.OGC_SFS_BOUNDARY_RULE=gn.MOD2_BOUNDARY_RULE;class fn{constructor(){fn.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=gn.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new s("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}intersects(t,e){return this.locate(t,e)!==Qt.EXTERIOR}updateLocationInfo(t){t===Qt.INTERIOR&&(this._isIn=!0),t===Qt.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof tt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof J)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof it)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof wt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof ft){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof ct){const n=new We(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?Qt.INTERIOR:Qt.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return Qt.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?Ue.isOnLine(t,n)?Qt.INTERIOR:Qt.EXTERIOR:Qt.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===Qt.EXTERIOR)return Qt.EXTERIOR;if(s===Qt.BOUNDARY)return Qt.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===Qt.INTERIOR)return Qt.EXTERIOR;if(i===Qt.BOUNDARY)return Qt.BOUNDARY}return Qt.INTERIOR}locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e instanceof J?this.locateOnLineString(t,e):e instanceof it?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?Qt.BOUNDARY:this._numBoundaries>0||this._isIn?Qt.INTERIOR:Qt.EXTERIOR)}}class yn{constructor(){yn.constructor_.apply(this,arguments)}static constructor_(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t}static farthestPoints(t){const e=t[0].distance(t[1]),n=t[1].distance(t[2]),s=t[2].distance(t[0]);return e>=n&&e>=s?[t[0],t[1]]:n>=e&&n>=s?[t[1],t[2]]:[t[2],t[0]]}static pointWitMinAngleWithX(t,e){let n=r.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=r.MAX_VALUE,i=null;for(let r=0;r<t.length;r++){const o=t[r];if(o===e)continue;if(o===n)continue;const l=$t.angleBetween(e,o,n);l<s&&(s=l,i=o)}return i}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new m(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),dt.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=dt.copyDeep(e),null;let n=yn.lowestPoint(e),s=yn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=yn.pointWithMinAngleWithSegment(e,n,s);if($t.isObtuse(n,t,s))return this._extremalPts=[new m(n),new m(s)],null;if($t.isObtuse(t,n,s))n=t;else{if(!$t.isObtuse(t,s,n))return this._extremalPts=[new m(n),new m(s),new m(t)],null;s=t}}g.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}getMaximumDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre);case 2:return this._input.getFactory().createLineString([this._extremalPts[0],this._extremalPts[1]]);default:const t=yn.farthestPoints(this._extremalPts);return this._input.getFactory().createLineString(t)}}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new m((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=ne.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}}class xn{constructor(){xn.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new Kt,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];xn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new xn(t).getDiameter()}static getMinimumRectangle(t){return new xn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new m(0,n/e),i=new m(1,n/e-t/e)):(s=new m(n/t,0),i=new m(n/t-e/t,1)),new Kt(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof it?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=r.MAX_VALUE;let e=1;const n=new Kt;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new sn(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=xn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new Kt(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=r.MAX_VALUE,s=-r.MAX_VALUE,i=r.MAX_VALUE,o=-r.MAX_VALUE;for(let r=0;r<this._convexHullPts.length;r++){const l=xn.computeC(t,e,this._convexHullPts[r]);l>s&&(s=l),l<n&&(n=l);const a=xn.computeC(-e,t,this._convexHullPts[r]);a>o&&(o=a),a<i&&(i=a)}const l=xn.computeSegmentForLine(-t,-e,o),a=xn.computeSegmentForLine(-t,-e,i),c=xn.computeSegmentForLine(-e,t,s),h=xn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),p=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(p)}}var En=Object.freeze({__proto__:null,distance:be,locate:je,match:Je,Angle:$t,Area:et,Centroid:$e,ConvexHull:sn,Distance:V,InteriorPointArea:on,InteriorPointLine:hn,InteriorPointPoint:un,Length:H,Orientation:G,PointLocation:Ue,PointLocator:fn,RobustLineIntersector:jt,MinimumBoundingCircle:yn,MinimumDiameter:xn});class In{constructor(){In.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t}static densifyPoints(t,e,n){const s=new Kt,i=new R;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new In(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new Nn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new s("Tolerance must be positive");this._distanceTolerance=t}}class Nn extends me{constructor(){super(),Nn.constructor_.apply(this,arguments)}static constructor_(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof ft?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=In.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof J&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}}In.DensifyTransformer=Nn;var Sn=Object.freeze({__proto__:null,Densifier:In});class wn{static isNorthern(t){return t===wn.NE||t===wn.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===wn.SE?t===wn.SE||t===wn.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?wn.NE:wn.SE:e>=0?wn.NW:wn.SW}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new s("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?wn.NE:wn.SE:e.y>=t.y?wn.NW:wn.SW}}}wn.NE=0,wn.NW=1,wn.SW=2,wn.SE=3;class Cn{constructor(){Cn.constructor_.apply(this,arguments)}static constructor_(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t}static create(t,e){const n=new Cn(t),s=new Cn(e);return n.link(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}isEdgesSorted(){const t=this.findLowest();let e=t;do{const n=e.oNext();if(n===t)break;if(!(n.compareTo(e)>0))return!1;e=n}while(e!==t);return!0}oNext(){return this._sym._next}directionY(){return this.directionPt().getY()-this._orig.getY()}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;this.insertionEdge(t).insertAfter(t)}insertAfter(t){g.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof m&&arguments[0]instanceof m){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}findLowest(){let t=this,e=this.oNext();do{e.compareTo(t)<0&&(t=e),e=e.oNext()}while(e!==this);return t}directionPt(){return this.dest()}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.directionX(),n=this.directionY(),s=t.directionX(),i=t.directionY();if(e===s&&n===i)return 0;const r=wn.quadrant(e,n),o=wn.quadrant(s,i);if(r>o)return 1;if(r<o)return-1;const l=this.directionPt(),a=t.directionPt();return G.index(t._orig,a,l)}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}directionX(){return this.directionPt().getX()-this._orig.getX()}insertionEdge(t){let e=this;do{const n=e.oNext();if(n.compareTo(e)>0&&t.compareTo(e)>=0&&t.compareTo(n)<=0)return e;if(n.compareTo(e)<=0&&(t.compareTo(n)<=0||t.compareTo(e)>=0))return e;e=n}while(e!==this);return g.shouldNeverReachHere(),null}compareTo(t){const e=t;return this.compareAngularDirection(e)}toStringNode(){const t=this.orig(),e=(this.dest(),new _t);e.append("Node( "+Wt.format(t)+" )\n");let n=this;do{e.append("  -> "+n),e.append("\n"),n=n.oNext()}while(n!==this);return e.toString()}link(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}toStringNodeEdge(){return"  -> ("+Wt.format(this.dest())}setNext(t){this._next=t}}class Ln extends Cn{constructor(){super(),Ln.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1;const t=arguments[0];Cn.constructor_.call(this,t)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}}class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static constructor_(){this._vertexMap=new It}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return n.link(s),n}createEdge(t){return new Cn(t)}addEdge(t,e){if(!Tn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}}class Rn extends Ln{constructor(){super(),Rn.constructor_.apply(this,arguments)}static constructor_(){this._isStart=!1;const t=arguments[0];Ln.constructor_.call(this,t)}setStart(){this._isStart=!0}isStart(){return this._isStart}}class Pn extends Tn{constructor(){super()}createEdge(t){return new Rn(t)}}class On{constructor(){On.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._factory=null,this._graph=null,this._lines=new L,this._nodeEdgeStack=new en,this._ringStartEdge=null,this._graph=new Pn}static dissolve(t){const e=new On;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new R;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new R;let n=t;for(this._ringStartEdge=null,Ln.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Ln.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Ln.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Ln.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Ln.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof X){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof J&&this.add(t)}})}else if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof J){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}}var vn=Object.freeze({__proto__:null,LineDissolver:On});class Mn{static opposite(t){return t===Mn.LEFT?Mn.RIGHT:t===Mn.RIGHT?Mn.LEFT:t}}Mn.ON=0,Mn.LEFT=1,Mn.RIGHT=2;class bn{constructor(){bn.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}}class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=Dn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=Dn.INSERT,this._label=t,this._xValue=e,this._obj=n}}isDelete(){return this._eventType===Dn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===Dn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}get interfaces_(){return[o]}}Dn.INSERT=1,Dn.DELETE=2;class An{constructor(){An.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(An.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}}class Fn extends class{}{constructor(){super(),Fn.constructor_.apply(this,arguments)}static constructor_(){this.events=new L,this.nOverlaps=null}prepareEvents(){xe.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&I(arguments[0],w)&&I(arguments[1],w)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&I(arguments[0],w)&&arguments[1]instanceof An){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new bn(n,t),i=new Dn(e,n.getMinX(t),s);this.events.add(i),this.events.add(new Dn(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class Gn{constructor(){Gn.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[Mn.ON]=t}else if(arguments[0]instanceof Gn){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[Mn.ON]=t,this.location[Mn.LEFT]=e,this.location[Mn.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==Qt.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[Mn.ON]=this.location[Mn.ON],t[Mn.LEFT]=Qt.NONE,t[Mn.RIGHT]=Qt.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[Mn.LEFT];this.location[Mn.LEFT]=this.location[Mn.RIGHT],this.location[Mn.RIGHT]=t}toString(){const t=new v;return this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[Mn.LEFT])),t.append(Qt.toLocationSymbol(this.location[Mn.ON])),this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[Mn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[Mn.ON]=t,this.location[Mn.LEFT]=e,this.location[Mn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:Qt.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===Qt.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(Mn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(Qt.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}}class qn{constructor(){qn.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new Gn(t),this.elt[1]=new Gn(t)}else if(arguments[0]instanceof qn){const t=arguments[0];this.elt[0]=new Gn(t.elt[0]),this.elt[1]=new Gn(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new Gn(Qt.NONE),this.elt[1]=new Gn(Qt.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new Gn(t,e,n),this.elt[1]=new Gn(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new Gn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[1]=new Gn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[t].setLocations(e,n,s)}}static toLineLabel(t){const e=new qn(Qt.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Gn(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(Mn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new v;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(Mn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new Gn(this.elt[t].location[0]))}}class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new m(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[o]}}class Yn extends yt{}function Vn(t){return null==t?0:t.color}function zn(t){return null==t?null:t.parent}function kn(t,e){null!==t&&(t.color=e)}function Xn(t){return null==t?null:t.left}function Un(t){return null==t?null:t.right}class Hn extends Yn{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,s,i=this.root_;do{if(n=i,s=t.compareTo(i.key),s<0)i=i.left;else{if(!(s>0)){const t=i.value;return i.value=e,t}i=i.right}}while(null!==i);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)zn(t)===Xn(zn(zn(t)))?(e=Un(zn(zn(t))),1===Vn(e)?(kn(zn(t),0),kn(e,0),kn(zn(zn(t)),1),t=zn(zn(t))):(t===Un(zn(t))&&(t=zn(t),this.rotateLeft(t)),kn(zn(t),0),kn(zn(zn(t)),1),this.rotateRight(zn(zn(t))))):(e=Xn(zn(zn(t))),1===Vn(e)?(kn(zn(t),0),kn(e,0),kn(zn(zn(t)),1),t=zn(zn(t))):(t===Xn(zn(t))&&(t=zn(t),this.rotateRight(t)),kn(zn(t),0),kn(zn(zn(t)),1),this.rotateLeft(zn(zn(t)))));this.root_.color=0}values(){const t=new L;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=Hn.successor(e));)t.add(e.value);return t}entrySet(){const t=new xt;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=Hn.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class Wn{constructor(){Wn.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Hn,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new $n(r,new qn(this.edge._label))}add(t,e,n){const s=new Bn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}}class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)Zn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),B.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=nt.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return B.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class jn{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new Zn(Math.trunc(t.length/2));n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return n.toArray()}findChainEnd(t,e){const n=wn.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(wn.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}OLDgetChainStartIndices(t){let e=0;const n=new L;n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return jn.toIntArray(n)}}class Kn{constructor(){Kn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new jn;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return O.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}}class Qn{constructor(){Qn.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map((()=>Array(3)));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Qn.NULL_VALUE}static depthAtLocation(t){return t===Qt.EXTERIOR?0:t===Qt.INTERIOR?1:Qn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Qn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Qn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][Mn.RIGHT]-this._depth[t][Mn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?Qt.EXTERIOR:Qt.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==Qt.EXTERIOR&&s!==Qt.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Qn.depthAtLocation(s):this._depth[e][n]+=Qn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===Qt.INTERIOR&&this._depth[t][e]++}}}Qn.NULL_VALUE=-1;class Jn{constructor(){Jn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){g.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}}class $n extends Jn{constructor(){super(),$n.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new Wn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Qn,this._depthDelta=0,1===arguments.length){const t=arguments[0];$n.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Jt&&arguments[0]instanceof qn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,Mn.ON),t.getLocation(1,Mn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,Mn.LEFT),t.getLocation(1,Mn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,Mn.RIGHT),t.getLocation(1,Mn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new $n(t,qn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof $n))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){$n.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Kn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new O;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new m(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new _t;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}}class ts extends Jn{constructor(){super(),ts.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new qn(0,Qt.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=Qt.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==Qt.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new qn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof ts){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof qn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===Qt.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=Qt.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case Qt.BOUNDARY:n=Qt.INTERIOR;break;case Qt.INTERIOR:default:n=Qt.BOUNDARY}this._label.setLocation(t,n)}}class es{constructor(){es.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new Hn,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof m){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof ts){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new L;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===Qt.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}}class ns{constructor(){ns.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ns.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ns.constructor_.call(this,t),this.init(e,n),this._label=s}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:G.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=wn.quadrant(this._dx,this._dy),g.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}get interfaces_(){return[o]}}class ss extends h{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new m(e):void 0,this.name=Object.keys({TopologyException:ss})[0]}getCoordinate(){return this.pt}}class is extends ns{constructor(){super(),is.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(ns.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===Qt.EXTERIOR&&e===Qt.INTERIOR?1:t===Qt.INTERIOR&&e===Qt.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new qn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new ss("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Mn.LEFT)===Qt.INTERIOR&&this._label.getLocation(e,Mn.RIGHT)===Qt.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[Mn.LEFT]+"/"+this._depth[Mn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Qt.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Qt.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===Mn.LEFT&&(s=-1);const i=Mn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}}class rs{createNode(t){return new ts(t,null)}}class os{constructor(){os.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new L,this._nodes=null,this._edgeEndList=new L,0===arguments.length)this._nodes=new es(new rs);else if(1===arguments.length){const t=arguments[0];this._nodes=new es(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof ts){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){B.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===Qt.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(G.index(t,e,s)===G.COLLINEAR&&wn.quadrant(t,e)===wn.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){B.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new is(t,!0),s=new is(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}}class ls extends os{constructor(){super(),ls.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new It,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new fn,2===arguments.length){const t=arguments[0],e=arguments[1];ls.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?Qt.BOUNDARY:Qt.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=Qt.NONE;i=n.getLocation(t,Mn.ON),i===Qt.BOUNDARY&&s++;const r=ls.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new An(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const s=this.createEdgeSetIntersector(),i=this._parentGeom instanceof ut||this._parentGeom instanceof it||this._parentGeom instanceof ft,r=t||!i;return s.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new An(e,n,!0);s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof tt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,Qt.INTERIOR)}else if(arguments[0]instanceof m){const t=arguments[0];this.insertPoint(this._argIndex,t,Qt.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),Qt.EXTERIOR,Qt.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,Qt.INTERIOR,Qt.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],Qt.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],Qt.BOUNDARY)}addLineString(t){const e=dt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new $n(e,new qn(this._argIndex,Qt.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),g.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===Qt.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=dt.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;G.isCCW(s)&&(i=n,r=e);const o=new $n(s,new qn(this._argIndex,Qt.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],Qt.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new qn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Fn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof X))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof ft&&(this._useBoundaryDeterminationRule=!1),t instanceof it)this.addPolygon(t);else if(t instanceof J)this.addLineString(t);else if(t instanceof tt)this.addPoint(t);else if(t instanceof ht)this.addCollection(t);else if(t instanceof wt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else{if(!(t instanceof ct))throw new j(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return I(this._parentGeom,st)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ze(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof J){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}}var as=Object.freeze({__proto__:null,GeometryGraph:ls});class cs{visit(t){}}class hs{constructor(){hs.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e),this._left=null,this._right=null,this._count=1,this._data=n}}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}}class us{constructor(){us.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)us.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return us.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new R;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new hs(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new L;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof O&&I(arguments[1],w)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[cs]}visit(t){e.add(t)}})}else if(arguments[0]instanceof O&&I(arguments[1],cs)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new gs(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new hs(t,e);return r?s.setLeft(o):s.setRight(o),o}}class gs{constructor(){gs.constructor_.apply(this,arguments)}static constructor_(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new O(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}get interfaces_(){return[cs]}}us.BestMatchVisitor=gs;var ds=Object.freeze({__proto__:null,KdTree:us});class _s{constructor(){_s.constructor_.apply(this,arguments)}static constructor_(){this._items=new L,this._subnode=new Array(4).fill(null)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}get interfaces_(){return[c]}}function ps(){}ps.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},ps.powerOf2=function(t){return Math.pow(2,t)};class ms{constructor(){ms.constructor_.apply(this,arguments)}static constructor_(){this._pt=new m,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return ps.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=ms.computeQuadLevel(t),this._env=new O,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ps.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new m((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}}class fs extends _s{constructor(){super(),fs.constructor_.apply(this,arguments)}static constructor_(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2}static createNode(t){const e=new ms(t);return new fs(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new O(e);null!==t&&n.expandToInclude(t._env);const s=fs.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=_s.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=_s.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new O(e,n,s,i);return new fs(r,this._level-1)}insertNode(t){g.isTrue(null===this._env||this._env.contains(t._env));const e=_s.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}}class ys{static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return ps.exponent(s)<=ys.MIN_BINARY_EXPONENT}}ys.MIN_BINARY_EXPONENT=-50;class xs extends _s{constructor(){super()}insert(t,e){const n=_s.getSubnodeIndex(t,xs.origin.x,xs.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=fs.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){g.isTrue(t.getEnvelope().contains(e));const s=ys.isZeroWidth(e.getMinX(),e.getMaxX()),i=ys.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}}xs.origin=new m(0,0);class Es{insert(t,e){}remove(t,e){}query(){}}class Is{constructor(){Is.constructor_.apply(this,arguments)}static constructor_(){this._root=null,this._minExtent=1,this._root=new xs}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s+=e/2),i===r&&(i-=e/2,r+=e/2),new O(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=Is.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new L;return this._root.addAllItems(t),t}remove(t,e){const n=Is.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}get interfaces_(){return[Es,c]}}var Ns=Object.freeze({__proto__:null,Quadtree:Is});class Ss{getBounds(){}}class ws{constructor(){ws.constructor_.apply(this,arguments)}static constructor_(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e}getItem(){return this._item}getBounds(){return this._bounds}get interfaces_(){return[Ss,c]}}class Cs{constructor(){Cs.constructor_.apply(this,arguments)}static constructor_(){this._size=null,this._items=null,this._size=0,this._items=new L,this._items.add(null)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}}class Ls{constructor(){Ls.constructor_.apply(this,arguments)}static constructor_(){if(this._childBoundables=new L,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){g.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}get interfaces_(){return[Ss,c]}}class Ts{static maxDistance(t,e,n,s,i,r,o,l){let a=Ts.distance(t,e,i,r);return a=Math.max(a,Ts.distance(t,e,o,l)),a=Math.max(a,Ts.distance(n,s,i,r)),a=Math.max(a,Ts.distance(n,s,o,l)),a}static distance(t,e,n,s){const i=n-t,r=s-e;return Math.sqrt(i*i+r*r)}static maximumDistance(t,e){const n=Math.min(t.getMinX(),e.getMinX()),s=Math.min(t.getMinY(),e.getMinY()),i=Math.max(t.getMaxX(),e.getMaxX()),r=Math.max(t.getMaxY(),e.getMaxY());return Ts.distance(n,s,i,r)}static minMaxDistance(t,e){const n=t.getMinX(),s=t.getMinY(),i=t.getMaxX(),r=t.getMaxY(),o=e.getMinX(),l=e.getMinY(),a=e.getMaxX(),c=e.getMaxY();let h=Ts.maxDistance(n,s,n,r,o,l,o,c);return h=Math.min(h,Ts.maxDistance(n,s,n,r,o,l,a,l)),h=Math.min(h,Ts.maxDistance(n,s,n,r,a,c,o,c)),h=Math.min(h,Ts.maxDistance(n,s,n,r,a,c,a,l)),h=Math.min(h,Ts.maxDistance(n,s,i,s,o,l,o,c)),h=Math.min(h,Ts.maxDistance(n,s,i,s,o,l,a,l)),h=Math.min(h,Ts.maxDistance(n,s,i,s,a,c,o,c)),h=Math.min(h,Ts.maxDistance(n,s,i,s,a,c,a,l)),h=Math.min(h,Ts.maxDistance(i,r,n,r,o,l,o,c)),h=Math.min(h,Ts.maxDistance(i,r,n,r,o,l,a,l)),h=Math.min(h,Ts.maxDistance(i,r,n,r,a,c,o,c)),h=Math.min(h,Ts.maxDistance(i,r,n,r,a,c,a,l)),h=Math.min(h,Ts.maxDistance(i,r,i,s,o,l,o,c)),h=Math.min(h,Ts.maxDistance(i,r,i,s,o,l,a,l)),h=Math.min(h,Ts.maxDistance(i,r,i,s,a,c,o,c)),h=Math.min(h,Ts.maxDistance(i,r,i,s,a,c,a,l)),h}}class Rs{constructor(){Rs.constructor_.apply(this,arguments)}static constructor_(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof Ls}maximumDistance(){return Ts.maximumDistance(this._boundable1.getBounds(),this._boundable2.getBounds())}expandToQueue(t,e){const n=Rs.isComposite(this._boundable1),i=Rs.isComposite(this._boundable2);if(n&&i)return Rs.area(this._boundable1)>Rs.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,!1,t,e),null):(this.expand(this._boundable2,this._boundable1,!0,t,e),null);if(n)return this.expand(this._boundable1,this._boundable2,!1,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,!0,t,e),null;throw new s("neither boundable is composite")}isLeaves(){return!(Rs.isComposite(this._boundable1)||Rs.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s,i){for(let r=t.getChildBoundables().iterator();r.hasNext();){const t=r.next();let o=null;o=n?new Rs(e,t,this._itemDistance):new Rs(t,e,this._itemDistance),o.getDistance()<i&&s.add(o)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}get interfaces_(){return[o]}}class Ps{constructor(){Ps.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._built=!1,this._itemBoundables=new L,this._nodeCapacity=null,0===arguments.length)Ps.constructor_.call(this,Ps.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];g.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(I(arguments[2],De)&&arguments[0]instanceof Object&&arguments[1]instanceof Ls){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ls?this.queryInternal(t,i,e):i instanceof ws?e.visitItem(i.getItem()):g.shouldNeverReachHere())}}else if(I(arguments[2],w)&&arguments[0]instanceof Object&&arguments[1]instanceof Ls){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ls?this.queryInternal(t,i,e):i instanceof ws?e.add(i.getItem()):g.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof Ls?t+=this.size(n):n instanceof ws&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof ws&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new L:t}if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof Ls){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof ws?e.add(t.getItem()):g.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){g.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new ws(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new L;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(g.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof Ls?this.boundablesAtLevel(t,e,n):(g.isTrue(e instanceof ws),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new L;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof Ls&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){g.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof Ls){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=new L;n.add(this.createNode(e));const s=new L(t);xe.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}get interfaces_(){return[c]}}Ps.IntersectsOp=function(){},Ps.DEFAULT_NODE_CAPACITY=10;class Os{distance(t,e){}}class vs extends Ps{constructor(){super(),vs.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)vs.constructor_.call(this,vs.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];Ps.constructor_.call(this,t)}}static centreX(t){return vs.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return vs.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){g.isTrue(t.length>0);const n=new L;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}nearestNeighbourK(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.nearestNeighbourK(t,r.POSITIVE_INFINITY,e)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=arguments[1];const s=new Cs;s.add(t);const i=new Cs;for(;!s.isEmpty()&&n>=0;){const t=s.poll(),r=t.getDistance();if(r>=n)break;if(t.isLeaves())if(i.size()<e)i.add(t);else{i.peek().getDistance()>r&&(i.poll(),i.add(t));n=i.peek().getDistance()}else t.expandToQueue(s,n)}return vs.getItems(i)}}createNode(t){return new Ms(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return vs.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new L;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return vs.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new L(t);xe.sort(s,vs.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(I(arguments[0],Os)){const t=arguments[0];if(this.isEmpty())return null;const e=new Rs(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof Rs){const t=arguments[0];let e=r.POSITIVE_INFINITY,n=null;const s=new Cs;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return null===n?null:[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}}else{if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isEmpty()||t.isEmpty())return null;const n=new Rs(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(3===arguments.length){const t=arguments[2],e=new ws(arguments[0],arguments[1]),n=new Rs(this.getRoot(),e,t);return this.nearestNeighbour(n)[0]}if(4===arguments.length){const t=arguments[2],e=arguments[3],n=new ws(arguments[0],arguments[1]),s=new Rs(this.getRoot(),n,t);return this.nearestNeighbourK(s,e)}}}isWithinDistance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=r.POSITIVE_INFINITY;const s=new Cs;for(s.add(t);!s.isEmpty();){const t=s.poll(),i=t.getDistance();if(i>e)return!1;if(t.maximumDistance()<=e)return!0;if(t.isLeaves()){if(n=i,n<=e)return!0}else t.expandToQueue(s,n)}return!1}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Rs(this.getRoot(),t.getRoot(),e);return this.isWithinDistance(s,n)}}get interfaces_(){return[Es,c]}}class Ms extends Ls{constructor(){super(),Ms.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0];Ls.constructor_.call(this,t)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new O(n.getBounds()):t.expandToInclude(n.getBounds())}return t}}vs.STRtreeNode=Ms,vs.xComparator=new class{get interfaces_(){return[a]}compare(t,e){return Ps.compareDoubles(vs.centreX(t.getBounds()),vs.centreX(e.getBounds()))}},vs.yComparator=new class{get interfaces_(){return[a]}compare(t,e){return Ps.compareDoubles(vs.centreY(t.getBounds()),vs.centreY(e.getBounds()))}},vs.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},vs.DEFAULT_NODE_CAPACITY=10;var bs=Object.freeze({__proto__:null,STRtree:vs}),Ds=Object.freeze({__proto__:null,kdtree:ds,quadtree:Ns,strtree:bs});const As=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class Fs{constructor(t){this.geometryFactory=t||new Ct}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!Gs[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==As.indexOf(n)?Gs[n].call(this,e.coordinates):"GeometryCollection"===n?Gs[n].call(this,e.geometries):Gs[n].call(this,e)}write(t){const e=t.getGeometryType();if(!qs[e])throw new Error("Geometry is not supported");return qs[e].call(this,t)}}const Gs={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!Gs[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Gs.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new m(s[0],s[1]))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new m(t[0],t[1]),new m(t[2],t[1]),new m(t[2],t[3]),new m(t[0],t[3]),new m(t[0],t[1])])},Point:function(t){const e=new m(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Gs.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=Gs.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Gs.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=Gs.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=Gs.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(Gs.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},qs={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:qs.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=qs.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(qs.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=qs.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=qs.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=qs.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=qs.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(qs[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Bs(t){return[t.x,t.y]}var Ys=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new Fs(t||new Ct)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new Fs(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Ct,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new m(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Bs);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Bs);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Bs)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Bs));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Bs))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Ht(t||new Ct)}read(t){return this.parser.read(t)}},WKTWriter:Wt});class Vs{static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=Vs.relativeSign(e.x,n.x),i=Vs.relativeSign(e.y,n.y);switch(t){case 0:return Vs.compareValue(s,i);case 1:return Vs.compareValue(i,s);case 2:return Vs.compareValue(i,-s);case 3:return Vs.compareValue(-s,i);case 4:return Vs.compareValue(-s,-i);case 5:return Vs.compareValue(-i,-s);case 6:return Vs.compareValue(-i,s);case 7:return Vs.compareValue(s,-i)}return g.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}}class zs{constructor(){zs.constructor_.apply(this,arguments)}static constructor_(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new m(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:this._isInterior?e._isInterior?Vs.compare(this._segmentOctant,this.coord,e.coord):1:-1}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}toString(){return this.segmentIndex+":"+this.coord.toString()}isInterior(){return this._isInterior}get interfaces_(){return[o]}}class ks{constructor(){ks.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Hn,this._edge=null;const t=arguments[0];this._edge=t}getSplitCoordinates(){const t=new R;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new L;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}createSplitEdgePts(t,e){let n=e.segmentIndex-t.segmentIndex+2;if(2===n)return[new m(t.coord),new m(e.coord)];const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new m(e.coord)),r}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e),s=(this._edge.getCoordinate(e+1),this._edge.getCoordinate(e+2));n.equals2D(s)&&t.add(M.valueOf(e+1))}}addEdgeCoordinates(t,e,n){const s=this.createSplitEdgePts(t,e);n.add(s,!1)}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(M.valueOf(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){const n=this.createSplitEdgePts(t,e);return new Ws(n,this._edge.getData())}add(t,e){const n=new zs(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(g.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new h("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new h("bad split edge end point at "+i)}}class Xs{static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the octant for point ( "+t+", "+e+" )");const n=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?n>=i?0:1:n>=i?7:6:e>=0?n>=i?3:2:n>=i?4:5}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,i=e.y-t.y;if(0===n&&0===i)throw new s("Cannot compute the octant for two identical points "+t);return Xs.octant(n,i)}}}class Us{getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}}class Hs{addIntersection(t,e){}get interfaces_(){return[Us]}}class Ws{constructor(){Ws.constructor_.apply(this,arguments)}static constructor_(){this._nodeList=new ks(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new L;return Ws.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){e.next().getNodeList().addSplitEdges(t)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Xs.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[1],e=arguments[3],n=new m(arguments[0].getIntersection(e));this.addIntersection(n,t)}}toString(){return Wt.toLineString(new pt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}get interfaces_(){return[Hs]}}class Zs{constructor(){Zs.constructor_.apply(this,arguments)}static constructor_(){this._overlapSeg1=new Kt,this._overlapSeg2=new Kt}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];arguments[0].getLineSegment(t,this._overlapSeg1),e.getLineSegment(n,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}}class js{constructor(){js.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new O(t,e)}return this._env}overlaps(t,e,n,s,i){return O.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}}class Ks{static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=wn.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(wn.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Ks.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;let s=0;do{const i=Ks.findChainEnd(t,s),r=new js(t,s,i,e);n.add(r),s=i}while(s<t.length-1);return n}}}class Qs{computeNodes(t){}getNodedSubstrings(){}}class Js{constructor(){Js.constructor_.apply(this,arguments)}static constructor_(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}}setSegmentIntersector(t){this._segInt=t}get interfaces_(){return[Qs]}}class $s extends Js{constructor(){super(),$s.constructor_.apply(this,arguments)}static constructor_(){if(this._monoChains=new L,this._index=new vs,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];Js.constructor_.call(this,t)}}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Ws.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Ks.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new ti(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}}class ti extends Zs{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){this._si=null;const t=arguments[0];this._si=t}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[1],e=arguments[2],n=arguments[3],s=arguments[0].getContext(),i=e.getContext();this._si.processIntersections(s,t,i,n)}}}$s.SegmentOverlapAction=ti;class ei{constructor(){ei.constructor_.apply(this,arguments)}static constructor_(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ei.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}}rescale(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&B.out.println(t)}}scale(){if(I(arguments[0],N)){const t=arguments[0],e=new L(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Ws(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new m(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].getZ());return dt.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}get interfaces_(){return[Qs]}}var ni=Object.freeze({__proto__:null,MCIndexNoder:$s,ScaledNoder:ei,SegmentString:Us});class si{constructor(){si.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];si.constructor_.call(this,t,gn.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}}static getBoundary(){if(1===arguments.length){return new si(arguments[0]).getBoundary()}if(2===arguments.length){return new si(arguments[0],arguments[1]).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof J?this.boundaryLineString(this._geom):this._geom instanceof wt?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new L;this._endpointMap=new Hn;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return dt.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new ii,this._endpointMap.put(t,e)),e.count++}}class ii{constructor(){ii.constructor_.apply(this,arguments)}static constructor_(){this.count=null}}class ri{constructor(){ri.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}}static isSimple(){if(1===arguments.length){return new ri(arguments[0]).isSimple()}if(2===arguments.length){return new ri(arguments[0],arguments[1]).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new lt;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new Hn;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.isClosed(),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new ls(0,t),n=new jt,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new oi(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof J||t instanceof wt?this.isSimpleLinearGeometry(t):t instanceof ht?this.isSimpleMultiPoint(t):I(t,st)?this.isSimplePolygonal(t):!(t instanceof ct)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}}class oi{constructor(){oi.constructor_.apply(this,arguments)}static constructor_(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}}ri.EndpointInfo=oi;class li{constructor(){li.constructor_.apply(this,arguments)}static constructor_(){if(this._quadrantSegments=li.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=li.CAP_ROUND,this._joinStyle=li.JOIN_ROUND,this._mitreLimit=li.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=li.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=li.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=li.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==li.JOIN_ROUND&&(this._quadrantSegments=li.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}}li.CAP_ROUND=1,li.CAP_FLAT=2,li.CAP_SQUARE=3,li.JOIN_ROUND=1,li.JOIN_MITRE=2,li.JOIN_BEVEL=3,li.DEFAULT_QUADRANT_SEGMENTS=8,li.DEFAULT_MITRE_LIMIT=5,li.DEFAULT_SIMPLIFY_FACTOR=.01;class ai{constructor(){ai.constructor_.apply(this,arguments)}static constructor_(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();g.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=G.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===G.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===G.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=Mn.LEFT;return n[e].y<n[e+1].y&&(s=Mn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}g.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe;this.getRightmostSide(this._minDe,this._minIndex)===Mn.LEFT&&(this._orientedDe=this._minDe.getSym())}}class ci{constructor(){this.array=[]}addLast(t){this.array.push(t)}removeFirst(){return this.array.shift()}isEmpty(){return 0===this.array.length}}class hi{constructor(){hi.constructor_.apply(this,arguments)}static constructor_(){this._finder=null,this._dirEdgeList=new L,this._nodes=new L,this._rightMostCoord=null,this._env=null,this._finder=new ai}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new ss("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(Mn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(Mn.RIGHT)>=1&&e.getDepth(Mn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new xt,n=new ci,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new O;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new en;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(Mn.LEFT,t.getDepth(Mn.RIGHT)),e.setDepth(Mn.RIGHT,t.getDepth(Mn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}get interfaces_(){return[o]}}class ui{constructor(){ui.constructor_.apply(this,arguments)}static constructor_(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new L,this._pts=new L,this._label=new qn(Qt.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new L,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=G.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new ss("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new ss("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();g.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!Ue.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[1],e=arguments[0].getLocation(t,Mn.RIGHT);if(e===Qt.NONE)return null;if(this._label.getLocation(t)===Qt.NONE)return this._label.setLocation(t,e),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}}class gi extends ui{constructor(){super(),gi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ui.constructor_.call(this,t,e)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}}class di extends ui{constructor(){super(),di.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ui.constructor_.call(this,t,e)}buildMinimalRings(){const t=new L;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new gi(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}}class _i{constructor(){_i.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=null,this._shellList=new L;const t=arguments[0];this._geometryFactory=t}static findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getLinearRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=dt.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;Ue.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getLinearRing().getEnvelopeInternal())}return r}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=_i.findEdgeRingContaining(e,t);if(null===n)throw new ss("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}buildMaximalEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new di(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return g.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];os.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new L,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}}class pi{constructor(){pi.constructor_.apply(this,arguments)}static constructor_(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=G.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t}static simplify(t,e){return new pi(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=pi.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){if(!(G.index(t,e,n)===this._angleOrientation))return!1;return V.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/pi.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return G.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=G.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===pi.DELETE;)e++;return e}isShallow(t,e,n,s){return V.pointToSegment(e,t,n)<s}collapseLine(){const t=new R;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==pi.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}}pi.INIT=0,pi.DELETE=1,pi.KEEP=1,pi.NUM_PTS_TO_CHECK=10;class mi{constructor(){mi.constructor_.apply(this,arguments)}static constructor_(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new L}getCoordinates(){return this._ptList.toArray(mi.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new m(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Ct).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new m(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}}mi.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class fi{constructor(){fi.constructor_.apply(this,arguments)}static constructor_(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new Kt,this._seg1=new Kt,this._offset0=new Kt,this._offset1=new Kt,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new jt,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===li.JOIN_ROUND&&(this._closingSegLengthFactor=fi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=G.index(this._s0,this._s1,this._s2),s=n===G.CLOCKWISE&&this._side===Mn.LEFT||n===G.COUNTERCLOCKWISE&&this._side===Mn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new Kt(t,e),s=new Kt;this.computeOffsetSegment(n,Mn.LEFT,this._distance,s);const i=new Kt;this.computeOffsetSegment(n,Mn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case li.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,G.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case li.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case li.CAP_SQUARE:const t=new m;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new m(s.p1.x+t.x,s.p1.y+t.y),r=new m(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){const i=q.intersection(e.p0,e.p1,n.p0,n.p1);if(null!==i){if((s<=0?1:i.distance(t)/Math.abs(s))<=this._bufParams.getMitreLimit())return this._segList.addPt(i),null}this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*fi.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===li.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===li.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new m(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new m(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===G.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=$t.angle(i,this._seg0.p0),o=$t.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2,l=$t.normalize(r+o),a=$t.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),g=i.y+c*Math.sin(a),d=new m(u,g),_=new Kt(i,d),p=_.pointAlongOffset(1,h),f=_.pointAlongOffset(1,-h);this._side===Mn.LEFT?(this._segList.addPt(p),this._segList.addPt(f)):(this._segList.addPt(f),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===G.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;const a=o/l,c=new m;for(let n=0;n<l;n++){const s=e+r*n*a;c.x=t.x+i*Math.cos(s),c.y=t.y+i*Math.sin(s),this._segList.addPt(c)}}computeOffsetSegment(t,e,n,s){const i=e===Mn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*fi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new m((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new m((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new m(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new mi,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*fi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2);this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===li.JOIN_BEVEL||this._bufParams.getJoinStyle()===li.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,G.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}}fi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,fi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,fi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,fi.MAX_CLOSING_SEG_LEN_FACTOR=80;class yi{constructor(){yi.constructor_.apply(this,arguments)}static constructor_(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new m(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&dt.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=pi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Mn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=pi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Mn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===Mn.RIGHT&&(s=-s);const i=pi.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=pi.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],Mn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=pi.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],Mn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case li.CAP_ROUND:e.createCircle(t);break;case li.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,this.isLineOffsetEmpty(e))return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return yi.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=pi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Mn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=pi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Mn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}isLineOffsetEmpty(t){return 0===t||t<0&&!this._bufParams.isSingleSided()}getSegGen(t){return new fi(this._precisionModel,this._bufParams,t)}}class xi{constructor(){xi.constructor_.apply(this,arguments)}static constructor_(){this._subgraphs=null,this._seg=new Kt;const t=arguments[0];this._subgraphs=t}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(I(arguments[2],w)&&arguments[0]instanceof m&&arguments[1]instanceof is){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse();if(Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(G.index(this._seg.p0,this._seg.p1,t)===G.RIGHT)continue;let r=e.getDepth(Mn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(Mn.RIGHT));const o=new Ei(this._seg,r);n.add(o)}}else if(I(arguments[2],w)&&arguments[0]instanceof m&&I(arguments[1],w)){const t=arguments[0],e=arguments[2];for(let n=arguments[1].iterator();n.hasNext();){const s=n.next();s.isForward()&&this.findStabbedSegments(t,s,e)}}}getDepth(t){const e=this.findStabbedSegments(t);if(0===e.size())return 0;return xe.min(e)._leftDepth}}class Ei{constructor(){Ei.constructor_.apply(this,arguments)}static constructor_(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new Kt(t),this._leftDepth=e}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}get interfaces_(){return[o]}}xi.DepthSegment=Ei;class Ii{constructor(){Ii.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n}addRingSide(t,e,n,s,i){if(0===e&&t.length<ut.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=ut.MINIMUM_VALID_SIZE&&G.isCCW(t)&&(r=i,o=s,n=Mn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}addRingBothSides(t,e){this.addRingSide(t,e,Mn.LEFT,Qt.EXTERIOR,Qt.INTERIOR),this.addRingSide(t,e,Mn.RIGHT,Qt.INTERIOR,Qt.EXTERIOR)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,Qt.EXTERIOR,Qt.INTERIOR)}addPolygon(t){let e=this._distance,n=Mn.LEFT;this._distance<0&&(e=-this._distance,n=Mn.RIGHT);const s=t.getExteriorRing(),i=dt.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addRingSide(i,e,n,Qt.EXTERIOR,Qt.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=dt.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addRingSide(r,e,Mn.opposite(n),Qt.INTERIOR,Qt.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new ne(t[0],t[1],t[2]),s=n.inCentre();return V.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._curveBuilder.isLineOffsetEmpty(this._distance))return null;const e=dt.removeRepeatedPoints(t.getCoordinates());if(dt.isRing(e)&&!this._curveBuilder.getBufferParameters().isSingleSided())this.addRingBothSides(e,this._distance);else{const t=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(t,Qt.EXTERIOR,Qt.INTERIOR)}}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Ws(t,new qn(0,Qt.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}add(t){if(t.isEmpty())return null;if(t instanceof it)this.addPolygon(t);else if(t instanceof J)this.addLineString(t);else if(t instanceof tt)this.addPoint(t);else if(t instanceof ht)this.addCollection(t);else if(t instanceof wt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else{if(!(t instanceof ct))throw new j(t.getGeometryType());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}}class Ni{constructor(){Ni.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new Hn,this._edgeList=null,this._ptInAreaLocation=[Qt.NONE,Qt.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=Qt.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,Mn.LEFT)!==Qt.NONE&&(e=s.getLocation(t,Mn.LEFT))}if(e===Qt.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,Mn.ON)===Qt.NONE&&i.setLocation(t,Mn.ON,n),i.isArea(t)){const e=i.getLocation(t,Mn.LEFT),r=i.getLocation(t,Mn.RIGHT);if(r!==Qt.NONE){if(r!==n)throw new ss("side location conflict",s.getCoordinate());e===Qt.NONE&&g.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else g.isTrue(i.getLocation(t,Mn.LEFT)===Qt.NONE,"found single null side"),i.setLocation(t,Mn.RIGHT,n),i.setLocation(t,Mn.LEFT,n)}}}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}print(t){B.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,Mn.LEFT);g.isTrue(s!==Qt.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();g.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,Mn.LEFT),r=n.getLocation(t,Mn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new L(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===Qt.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new v;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===Qt.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=Qt.NONE;if(e[n])r=Qt.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}}class Si extends Ni{constructor(){super(),Si.constructor_.apply(this,arguments)}static constructor_(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new ss("no outgoing dirEdge found",this.getCoordinate());g.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return wn.isNorthern(i)&&wn.isNorthern(r)?n:wn.isNorthern(i)||wn.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(g.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){B.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new L;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(Mn.LEFT),s=t.getDepth(Mn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new ss("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[1];let e=arguments[2];for(let n=arguments[0];n<t;n++){const t=this._edgeList.get(n);t.setEdgeDepths(Mn.RIGHT,e),e=t.getDepth(Mn.LEFT)}return e}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(g.isTrue(null!==e,"found null for first outgoing dirEdge"),g.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=Qt.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=Qt.INTERIOR;break}if(s.isInResult()){t=Qt.EXTERIOR;break}}}if(t===Qt.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===Qt.INTERIOR):(n.isInResult()&&(e=Qt.EXTERIOR),s.isInResult()&&(e=Qt.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new qn(Qt.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==Qt.INTERIOR&&n!==Qt.BOUNDARY||this._label.setLocation(t,Qt.INTERIOR)}}}}class wi extends rs{constructor(){super()}createNode(t){return new ts(t,new Si)}}class Ci{constructor(){Ci.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=Ci.orientation(t)}static orientation(t){return 1===dt.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return Ci.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}get interfaces_(){return[o]}}class Li{constructor(){Li.constructor_.apply(this,arguments)}static constructor_(){this._edges=new L,this._ocaMap=new Hn}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new Ci(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new Ci(t.getCoordinates());this._ocaMap.put(e,t)}}class Ti{processIntersections(t,e,n,s){}isDone(){}}class Ri{constructor(){Ri.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Ri.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}get interfaces_(){return[Ti]}}class Pi{constructor(){Pi.constructor_.apply(this,arguments)}static constructor_(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Li;const t=arguments[0];this._bufParams=t}static depthDelta(t){const e=t.getLocation(0,Mn.LEFT),n=t.getLocation(0,Mn.RIGHT);return e===Qt.INTERIOR&&n===Qt.EXTERIOR?1:e===Qt.EXTERIOR&&n===Qt.INTERIOR?-1:0}static convertSegStrings(t){const e=new Ct,n=new L;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new qn(t.getLabel()),s.flip()),n.merge(s);const i=Pi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(Pi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new xi(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new L;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new hi;n.create(t),e.add(n)}}return xe.sort(e,xe.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new $s,n=new jt;return n.setPrecisionModel(t),e.setSegmentIntersector(new Ri(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new yi(n,this._bufParams),i=new Ii(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new os(new wi),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new _i(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();if(l.size()<=0)return this.createEmptyResultGeometry();return this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new $n(e.getCoordinates(),new qn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}}class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null;const t=arguments[0];this._segStrings=t}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new h("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new h("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new h("found non-noded collapse at "+Oi.fact.createLineString([t,e,n]))}}Oi.fact=new Ct;class vi{constructor(){vi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new s("Scale factor must be non-zero");1!==e&&(this._pt=new m(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new m,this._p1Scaled=new m),this.initCorners(this._pt)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return g.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){const e=.5;this._minx=t.x-e,this._maxx=t.x+e,this._miny=t.y-e,this._maxy=t.y+e,this._corner[0]=new m(this._maxx,this._maxy),this._corner[1]=new m(this._minx,this._maxy),this._corner[2]=new m(this._minx,this._miny),this._corner[3]=new m(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=vi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new O(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}}vi.SAFE_ENV_EXPANSION_FACTOR=.75;class Mi{constructor(){Mi.constructor_.apply(this,arguments)}static constructor_(){this.selectedSegment=new Kt}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[1];arguments[0].getLineSegment(t,this.selectedSegment),this.select(this.selectedSegment)}}}class bi{constructor(){bi.constructor_.apply(this,arguments)}static constructor_(){this._index=null;const t=arguments[0];this._index=t}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Di(t,e,n);return this._index.query(s,new class{get interfaces_(){return[De]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}}class Di extends Mi{constructor(){super(),Di.constructor_.apply(this,arguments)}static constructor_(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof js))return super.select.apply(this,arguments);{const t=arguments[1],e=arguments[0].getContext();if(this._parentEdge===e&&(t===this._hotPixelVertexIndex||t+1===this._hotPixelVertexIndex))return null;this._isNodeAdded|=this._hotPixel.addSnappedNode(e,t)}}}bi.HotPixelSnapAction=Di;class Ai{constructor(){Ai.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new L}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}get interfaces_(){return[Ti]}}class Fi{constructor(){Fi.constructor_.apply(this,arguments)}static constructor_(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new jt,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()}checkCorrectness(t){const e=Ws.getNodedSubstrings(t),s=new Oi(e);try{s.checkValid()}catch(t){if(!(t instanceof n))throw t;t.printStackTrace()}}getNodedSubstrings(){return Ws.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Ai(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Ws){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new vi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new $s,this._pointSnapper=new bi(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new vi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}get interfaces_(){return[Qs]}}class Gi{constructor(){Gi.constructor_.apply(this,arguments)}static constructor_(){if(this._argGeom=null,this._distance=null,this._bufParams=new li,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}}static bufferOp(){if(2===arguments.length){const t=arguments[1];return new Gi(arguments[0]).getResultGeometry(t)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof X&&"number"==typeof arguments[1]){const t=arguments[1],e=arguments[2],n=new Gi(arguments[0]);n.setQuadrantSegments(e);return n.getResultGeometry(t)}if(arguments[2]instanceof li&&arguments[0]instanceof X&&"number"==typeof arguments[1]){const t=arguments[1];return new Gi(arguments[0],arguments[2]).getResultGeometry(t)}}else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3],s=new Gi(arguments[0]);s.setQuadrantSegments(e),s.setEndCapStyle(n);return s.getResultGeometry(t)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=Y.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ei(new Fi(new Nt(1)),t.getScale()),n=new Pi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=Gi.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof ss))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=Gi.precisionScaleFactor(this._argGeom,this._distance,t),n=new Nt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===Nt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new Pi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof h))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}}Gi.CAP_ROUND=li.CAP_ROUND,Gi.CAP_BUTT=li.CAP_FLAT,Gi.CAP_FLAT=li.CAP_FLAT,Gi.CAP_SQUARE=li.CAP_SQUARE,Gi.MAX_PRECISION_DIGITS=12;var qi=Object.freeze({__proto__:null,BufferOp:Gi,BufferParameters:li});class Bi{constructor(){Bi.constructor_.apply(this,arguments)}static constructor_(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Bi.constructor_.call(this,t,Bi.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}}getSegmentIndex(){return this._segIndex}getCoordinate(){return this._pt}isInsideArea(){return this._segIndex===Bi.INSIDE_AREA}toString(){return this._component.getGeometryType()+"["+this._segIndex+"]-"+Wt.toPoint(this._pt)}getGeometryComponent(){return this._component}}Bi.INSIDE_AREA=-1;class Yi{constructor(){Yi.constructor_.apply(this,arguments)}static constructor_(){this._locations=null;const t=arguments[0];this._locations=t}static getLocations(t){const e=new L;return t.apply(new Yi(e)),e}filter(t){if(t.isEmpty())return null;(t instanceof tt||t instanceof J||t instanceof it)&&this._locations.add(new Bi(t,0,t.getCoordinate()))}get interfaces_(){return[Q]}}class Vi{constructor(){Vi.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new fn,this._minDistanceLocation=null,this._minDistance=r.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];Vi.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}}static distance(t,e){return new Vi(t,e).distance()}static isWithinDistance(t,e,n){if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)return!1;return new Vi(t,e,n).distance()<=n}static nearestPoints(t,e){return new Vi(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ie.getPolygons(n);if(i.size()>0){const n=Yi.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&I(arguments[0],w)&&I(arguments[1],w)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Bi&&arguments[1]instanceof it){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(Qt.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Bi(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=ye.getLines(this._geom[0]),n=ye.getLines(this._geom[1]),s=Ee.getPoints(this._geom[0]),i=Ee.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){this.computeMinDistance();return[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof J&&arguments[1]instanceof tt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=V.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new Kt(s[r],s[r+1]).closestPoint(i);n[0]=new Bi(t,r,l),n[1]=new Bi(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof J&&arguments[1]instanceof J){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++){const o=new O(s[r],s[r+1]);if(!(o.distance(e.getEnvelopeInternal())>this._minDistance))for(let l=0;l<i.length-1;l++){const a=new O(i[l],i[l+1]);if(o.distance(a)>this._minDistance)continue;const c=V.segmentToSegment(s[r],s[r+1],i[l],i[l+1]);if(c<this._minDistance){this._minDistance=c;const o=new Kt(s[r],s[r+1]),a=new Kt(i[l],i[l+1]),h=o.closestPoints(a);n[0]=new Bi(t,r,h[0]),n[1]=new Bi(e,l,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Bi(i,0,i.getCoordinate()),n[1]=new Bi(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new s("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}}var zi=Object.freeze({__proto__:null,DistanceOp:Vi});class ki{constructor(){ki.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._directedEdges=new L,this._coordinates=null;const t=arguments[0];this._factory=t}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new R;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&dt.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}}class Xi{constructor(){Xi.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1,this._isVisited=!1,this._data=null}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}}class Ui extends Xi{constructor(){super(),Ui.constructor_.apply(this,arguments)}static constructor_(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=wn.quadrant(i,r),this._angle=Math.atan2(r,i)}}static toEdges(t){const e=new L;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:G.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}get interfaces_(){return[o]}}class Hi extends Ui{constructor(){super(),Hi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Ui.constructor_.call(this,t,e,n,s)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(g.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}}class Wi extends Xi{constructor(){super(),Wi.constructor_.apply(this,arguments)}static constructor_(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof ji){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}}class Zi{constructor(){Zi.constructor_.apply(this,arguments)}static constructor_(){this._outEdges=new L,this._sorted=!1}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(xe.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Wi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof Ui){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}}class ji extends Xi{constructor(){super(),ji.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];ji.constructor_.call(this,t,new Zi)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}}static getEdgesBetween(t,e){const n=Ui.toEdges(t.getOutEdges().getEdges()),s=new xt(n),i=Ui.toEdges(e.getOutEdges().getEdges());return s.retainAll(i),s}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}}class Ki extends Wi{constructor(){super(),Ki.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Qi{constructor(){Qi.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Hn}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}}class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static constructor_(){this._edges=new xt,this._dirEdges=new xt,this._nodeMap=new Qi}findNodesOfDegree(t){const e=new L;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Wi){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof Ui){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof ji){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Wi){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof Ui){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof ji){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Wi){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof Ui){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}}class $i extends Ji{constructor(){super()}addEdge(t){if(t.isEmpty())return null;const e=dt.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Hi(i,r,e[1],!0),l=new Hi(r,i,e[e.length-2],!1),a=new Ki(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new ji(t),this.add(e)),e}}class tr{constructor(){tr.constructor_.apply(this,arguments)}static constructor_(){this._graph=new $i,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(g.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Xi.setMarked(this._graph.nodeIterator(),!1),Xi.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new L,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new L;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new ki(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof X){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof J&&this.addLineString(n)}}else if(I(arguments[0],N)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}}class er{constructor(){er.constructor_.apply(this,arguments)}static constructor_(){this._parentGraph=null,this._edges=new xt,this._dirEdges=new L,this._nodeMap=new Qi;const t=arguments[0];this._parentGraph=t}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}}class nr{constructor(){nr.constructor_.apply(this,arguments)}static constructor_(){this._graph=null;const t=arguments[0];this._graph=t}addReachable(t,e){const n=new en;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new er(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new L;Xi.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}}class sr{constructor(){sr.constructor_.apply(this,arguments)}static constructor_(){this._graph=new $i,this._factory=new Ct,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=M.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof wt))return!0;const e=t,n=new lt;let s=null;const i=new L;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new m(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new sr;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();g.isTrue(this._lineCount===e,"Lines were missing from result"),g.isTrue(this._sequencedGeometry instanceof J||this._sequencedGeometry instanceof wt,"Result is not lineal")}findSequences(){const t=new L;for(let e=new nr(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=sr.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&g.isTrue(i===s,"path not contiguous")}findSequence(t){Xi.setVisited(t.edgeIterator(),!1);const e=sr.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new ci,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=sr.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new ci;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new L;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=sr.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof X){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof J&&this.addLine(t)}})}}}var ir=Object.freeze({__proto__:null,LineMerger:tr,LineSequencer:sr});class rr{constructor(){rr.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new Kt,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof J&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];rr.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=rr.isClosed(t),this._snapTolerance=e}}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new m(i)),0===s&&this._isClosed&&t.set(t.size()-1,new m(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new R(this._srcPts);this.snapVertices(e,t),this.snapSegments(e,t);return e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new m(n),!1)}}findSegmentIndexToSnap(t,e){let n=r.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}}class or{constructor(){or.constructor_.apply(this,arguments)}static constructor_(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t}static snap(t,e,n){const s=new Array(2).fill(null),i=new or(t);s[0]=i.snapTo(e,n);const r=new or(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=or.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===Nt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(or.computeOverlaySnapTolerance(t),or.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*or.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new or(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new lr(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new lr(t,n,!0).transform(this._srcGeom);let i=s;return e&&I(i,st)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new lt,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=r.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}}or.SNAP_PRECISION_FACTOR=1e-9;class lr extends me{constructor(){super(),lr.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}}snapLine(t,e){const n=new rr(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}}var ar=Object.freeze({__proto__:null,GeometrySnapper:or,LineStringSnapper:rr});class cr{constructor(){cr.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Xs.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Wt.toLineString(new pt(this._pts))}get interfaces_(){return[Us]}}class hr{constructor(){hr.constructor_.apply(this,arguments)}static constructor_(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._keepIntersections=!0,this._isInteriorIntersectionsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new L,this._intersectionCount=0;const t=arguments[0];this._li=t,this._interiorIntersection=null}static createAllIntersectionsFinder(t){const e=new hr(t);return e.setFindAllIntersections(!0),e}static isInteriorVertexIntersection(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3];return(!arguments[2]||!n)&&!!t.equals2D(e)}if(8===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6],l=arguments[7];return!!hr.isInteriorVertexIntersection(t,n,i,o)||(!!hr.isInteriorVertexIntersection(t,s,i,l)||(!!hr.isInteriorVertexIntersection(e,n,r,o)||!!hr.isInteriorVertexIntersection(e,s,r,l)))}}static createInteriorIntersectionCounter(t){const e=new hr(t);return e.setInteriorIntersectionsOnly(!0),e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static createIntersectionCounter(t){const e=new hr(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static isEndSegment(t,e){return 0===e||e>=t.size()-2}static createAnyIntersectionFinder(t){return new hr(t)}static createInteriorIntersectionsFinder(t){const e=new hr(t);return e.setFindAllIntersections(!0),e.setInteriorIntersectionsOnly(!0),e}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}getIntersection(){return this._interiorIntersection}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;const i=t===n;if(i&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(hr.isEndSegment(t,e)||hr.isEndSegment(n,s)))return null}const r=t.getCoordinate(e),o=t.getCoordinate(e+1),l=n.getCoordinate(s),a=n.getCoordinate(s+1),c=0===e,h=e+2===t.size(),u=0===s,g=s+2===n.size();this._li.computeIntersection(r,o,l,a);const d=this._li.hasIntersection()&&this._li.isInteriorIntersection();let _=!1;if(!this._isInteriorIntersectionsOnly){_=!(i&&Math.abs(s-e)<=1)&&hr.isInteriorVertexIntersection(r,o,l,a,c,h,u,g)}(d||_)&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=r,this._intSegments[1]=o,this._intSegments[2]=l,this._intSegments[3]=a,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}setInteriorIntersectionsOnly(t){this._isInteriorIntersectionsOnly=t}get interfaces_(){return[Ti]}}class ur{constructor(){ur.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t}static computeIntersections(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new hr(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new $s;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new ss(this.getErrorMessage(),this._segInt.getIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Wt.toLineString(t[0],t[1])+" and "+Wt.toLineString(t[2],t[3])}}class gr{constructor(){gr.constructor_.apply(this,arguments)}static constructor_(){this._nv=null;const t=arguments[0];this._nv=new ur(gr.toSegmentStrings(t))}static toSegmentStrings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new cr(t.getCoordinates(),t))}return e}static checkValid(t){new gr(t).checkValid()}checkValid(){this._nv.checkValid()}}class dr{constructor(){dr.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new L,this._resultLineList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!Nr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=this._geometryFactory.createLineString(e.getCoordinates());this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(g.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(Nr.isResultOfOp(s,e)&&e===Nr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}}class _r{constructor(){_r.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._resultPointList=new L;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===Nr.INTERSECTION))){const e=n.getLabel();Nr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}}class pr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new i,this._commonSignExp=null}getCommon(){return r.longBitsToDouble(this._commonBits)}add(t){const e=r.doubleToLongBits(t);if(this._isFirst)return this._commonBits=e,this._commonSignExp=pr.signExpBits(this._commonBits),this._isFirst=!1,null;if(pr.signExpBits(e)!==this._commonSignExp)return this._commonBits.high=0,this._commonBits.low=0,null;this._commonMantissaBitsCount=pr.numCommonMostSigMantissaBits(this._commonBits,e),this._commonBits=pr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))}toString(){if(1===arguments.length){const t=arguments[0],e=r.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+i.toBinaryString(t),s=n.substring(n.length-64);return s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]"}}getClass(){return pr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(pr.getBit(t,s)!==pr.getBit(e,s))return n;n++}return 52}}class mr{constructor(){mr.constructor_.apply(this,arguments)}static constructor_(){this._commonCoord=null,this._ccFilter=new fr}addCommonBits(t){const e=new yr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new m(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new yr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}}class fr{constructor(){fr.constructor_.apply(this,arguments)}static constructor_(){this._commonBitsX=new pr,this._commonBitsY=new pr}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new m(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}get interfaces_(){return[U]}}class yr{constructor(){yr.constructor_.apply(this,arguments)}static constructor_(){this.trans=null;const t=arguments[0];this.trans=t}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}get interfaces_(){return[P]}}mr.CommonCoordinateFilter=fr,mr.Translater=yr;class xr{constructor(){xr.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()}static overlayOp(t,e,n){return new xr(t,e).getResultGeometry(n)}static union(t,e){return xr.overlayOp(t,e,Nr.UNION)}static intersection(t,e){return xr.overlayOp(t,e,Nr.INTERSECTION)}static symDifference(t,e){return xr.overlayOp(t,e,Nr.SYMDIFFERENCE)}static difference(t,e){return xr.overlayOp(t,e,Nr.DIFFERENCE)}selfSnap(t){return new or(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new mr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=Nr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||B.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=or.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return or.snap(e[0],e[1],this._snapTolerance)}}class Er{constructor(){Er.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e}static overlayOp(t,e,n){return new Er(t,e).getResultGeometry(n)}static union(t,e){return Er.overlayOp(t,e,Nr.UNION)}static intersection(t,e){return Er.overlayOp(t,e,Nr.INTERSECTION)}static symDifference(t,e){return Er.overlayOp(t,e,Nr.SYMDIFFERENCE)}static difference(t,e){return Er.overlayOp(t,e,Nr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=Nr.overlayOp(this._geom[0],this._geom[1],t); true&&(n=!0)}catch(t){if(!(t instanceof h))throw t;s=t}if(!n)try{e=xr.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof h?s:t}return e}}class Ir{constructor(){Ir.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new jt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new ls(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ir.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new ls(0,t,n),this._arg[1]=new ls(1,e,n)}}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}}class Nr extends Ir{constructor(){super(),Nr.constructor_.apply(this,arguments)}static constructor_(){this._ptLocator=new fn,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new Li,this._resultPolyList=new L,this._resultLineList=new L,this._resultPointList=new L;const t=arguments[0],e=arguments[1];Ir.constructor_.call(this,t,e),this._graph=new os(new wi),this._geomFact=t.getFactory()}static overlayOp(t,e,n){return new Nr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Nr.createEmptyResult(Nr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Er.overlayOp(t,e,Nr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return Nr.createEmptyResult(Nr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ce.map(t,new class{get interfaces_(){return[MapOp]}map(t){return Nr.intersection(t,n)}})}return Er.overlayOp(t,e,Nr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Nr.createEmptyResult(Nr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Er.overlayOp(t,e,Nr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case Nr.INTERSECTION:r=Math.min(s,i);break;case Nr.UNION:r=Math.max(s,i);break;case Nr.DIFFERENCE:r=s;break;case Nr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){const i=Nr.resultDimension(t,e,n);return s.createEmpty(i)}static difference(t,e){if(t.isEmpty())return Nr.createEmptyResult(Nr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Er.overlayOp(t,e,Nr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return Nr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1],n=arguments[2];switch(t===Qt.BOUNDARY&&(t=Qt.INTERIOR),e===Qt.BOUNDARY&&(e=Qt.INTERIOR),n){case Nr.INTERSECTION:return t===Qt.INTERIOR&&e===Qt.INTERIOR;case Nr.UNION:return t===Qt.INTERIOR||e===Qt.INTERIOR;case Nr.DIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR;case Nr.SYMDIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR||t!==Qt.INTERIOR&&e===Qt.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new qn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new L;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?Nr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==Qt.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new L;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new L;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),gr.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new _i(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new dr(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new _r(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&Nr.isResultOfOp(s.getLocation(0,Mn.RIGHT),s.getLocation(1,Mn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(g.isTrue(!s.isNull(t,Mn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,Mn.LEFT,s.getLocation(t,Mn.LEFT)),g.isTrue(!s.isNull(t,Mn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,Mn.RIGHT,s.getLocation(t,Mn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}}Nr.INTERSECTION=1,Nr.UNION=2,Nr.DIFFERENCE=3,Nr.SYMDIFFERENCE=4;var Sr=Object.freeze({__proto__:null,snap:ar,OverlayOp:Nr});class wr extends Ui{constructor(){super(),wr.constructor_.apply(this,arguments)}static constructor_(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Ui.constructor_.call(this,t,e,n,s)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}}class Cr extends Wi{constructor(){super(),Cr.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Lr{constructor(){Lr.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=new Ct,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){if(t.isEmpty())return null;const n=t.getCoordinates(),s=n[0],i=Lr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR&&(l=o.getSym()),g.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof it){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof ft){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{g.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new di(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new L;this._geomGraph.computeSplitEdges(t);const e=new os(new wi);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}}class Tr{createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new ns(t,n.coord,r,new qn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new qn(t.getLabel());o.flip();const l=new ns(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}}class Rr extends ns{constructor(){super(),Rr.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new L,1===arguments.length){const t=arguments[0];Rr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];ns.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new qn(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===Qt.BOUNDARY&&n++,i===Qt.INTERIOR&&(s=!0)}let i=Qt.NONE;s&&(i=Qt.INTERIOR),n>0&&(i=ls.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===Qt.INTERIOR)return this._label.setLocation(t,e,Qt.INTERIOR),null;n===Qt.EXTERIOR&&this._label.setLocation(t,e,Qt.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,Mn.LEFT),this.computeLabelSide(t,Mn.RIGHT)}updateIM(t){$n.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new qn(Qt.NONE,Qt.NONE,Qt.NONE):new qn(Qt.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class Pr extends Ni{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Rr(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class Or extends ts{constructor(){super(),Or.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ts.constructor_.call(this,t,e)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}}class vr extends rs{constructor(){super()}createNode(t){return new Or(t,new Pr)}}class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static constructor_(){this._nodes=new es(new vr)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new Tr).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===Qt.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,Qt.INTERIOR)}}}}class br{constructor(){br.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._geomGraph=null,this._nodeGraph=new Mr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}}class Dr{constructor(){Dr.constructor_.apply(this,arguments)}static constructor_(){this._graph=null,this._rings=new L,this._totalEnv=new O,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t}buildIndex(){this._index=new vs;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Fr.findPtNotNode(n,i,this._graph);if(null===o)continue;if(Ue.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}}class Ar{constructor(){Ar.constructor_.apply(this,arguments)}static constructor_(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Ar.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}}getErrorType(){return this._errorType}getMessage(){return Ar.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}}Ar.ERROR=0,Ar.REPEATED_POINT=1,Ar.HOLE_OUTSIDE_SHELL=2,Ar.NESTED_HOLES=3,Ar.DISCONNECTED_INTERIOR=4,Ar.SELF_INTERSECTION=5,Ar.RING_SELF_INTERSECTION=6,Ar.NESTED_SHELLS=7,Ar.DUPLICATE_RINGS=8,Ar.TOO_FEW_POINTS=9,Ar.INVALID_COORDINATE=10,Ar.RING_NOT_CLOSED=11,Ar.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Fr{constructor(){Fr.constructor_.apply(this,arguments)}static constructor_(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof X){return new Fr(arguments[0]).isValid()}if(arguments[0]instanceof m){const t=arguments[0];return!r.isNaN(t.x)&&(!r.isInfinite(t.x)&&(!r.isNaN(t.y)&&!r.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Fr.isValid(t[e]))return this._validErr=new Ar(Ar.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof it){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){if(t.getNumInteriorRing()<=0)return null;const n=new Dr(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);s.isEmpty()||n.add(s)}n.isNonNested()||(this._validErr=new Ar(Ar.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new br(t);if(!e.isNodeConsistentArea())return this._validErr=new Ar(Ar.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Ar(Ar.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Fr.findPtNotNode(s,e,n);if(null!==r){if(!Ue.isInRing(r,i))return r}const o=Fr.findPtNotNode(i,t,n);if(null!==o){return Ue.isInRing(o,s)?o:null}return g.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new Lr(t);e.isInteriorsConnected()||(this._validErr=new Ar(Ar.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new lt;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Ar(Ar.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){if(t.getNumInteriorRing()<=0)return null;const n=t.getExteriorRing(),s=n.isEmpty(),i=new ze(n);for(let r=0;r<t.getNumInteriorRing();r++){const o=t.getInteriorRingN(r);let l=null;if(o.isEmpty())continue;if(l=Fr.findPtNotNode(o.getCoordinates(),n,e),null===l)return null;if(s||Qt.EXTERIOR===i.locate(l))return this._validErr=new Ar(Ar.HOLE_OUTSIDE_SHELL,l),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Ar(Ar.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof tt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof ht){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof ut){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new ls(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new jt;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof J){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new ls(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof it){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new ls(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof ft){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new ls(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof ct){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof X){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof tt)this.checkValid(t);else if(t instanceof ht)this.checkValid(t);else if(t instanceof ut)this.checkValid(t);else if(t instanceof J)this.checkValid(t);else if(t instanceof it)this.checkValid(t);else if(t instanceof ft)this.checkValid(t);else{if(!(t instanceof ct))throw new j(t.getGeometryType());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing();if(i.isEmpty())return null;const r=i.getCoordinates(),o=Fr.findPtNotNode(s,i,n);if(null===o)return null;if(!Ue.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Ar(Ar.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Ar(Ar.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(t.isEmpty())return null;if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Ar(Ar.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}}class Gr{constructor(){Gr.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._deList=new L,this._lowestEdge=null,this._ring=null,this._locator=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t}static findDirEdgesInRing(t){let e=t;const n=new L;do{n.add(e),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing().getEnvelopeInternal();if(l.equals(s))continue;if(!l.contains(s))continue;i=dt.ptNotInList(n.getCoordinates(),e.getCoordinates());e.isInRing(i)&&(null===r||o.contains(l))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new R;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();Gr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Fr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isInRing(t){return Qt.EXTERIOR!==this.getLocator().locate(t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof ut){const t=arguments[0];null===this._holes&&(this._holes=new L),this._holes.add(t)}else if(arguments[0]instanceof Gr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new L),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=G.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Wt.toLineString(new pt(this.getCoordinates()))}getLocator(){return null===this._locator&&(this._locator=new ze(this.getRing())),this._locator}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&B.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof n))throw t;B.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}}Gr.EnvelopeComparator=class{compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}get interfaces_(){return[a]}};class qr extends Ji{constructor(){super(),qr.constructor_.apply(this,arguments)}static constructor_(){this._factory=null;const t=arguments[0];this._factory=t}static findLabeledEdgeRings(t){const e=new L;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=Gr.findDirEdgesInRing(t);qr.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(g.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();qr.getDegree(i,e)>1&&(null===s&&(s=new L),s.add(i)),n=n.getNext(),g.isTrue(null!==n,"found null DE in ring"),g.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new Gr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();qr.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=dt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new wr(i,r,e[1],!0),l=new wr(r,i,e[e.length-2],!1),a=new Cr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),qr.findLabeledEdgeRings(this._dirEdges);const t=new L;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),qr.label(this._dirEdges,-1);const t=qr.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new L;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new ji(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=qr.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();qr.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new xt,n=new en;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();qr.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===qr.getDegreeNonDeleted(o)&&n.push(o)}}return e}}class Br{constructor(){Br.constructor_.apply(this,arguments)}static constructor_(){this._shells=null,this._shellIndex=null;const t=arguments[0];this._shells=t,this.buildIndex()}static assignHolesToShells(t,e){new Br(e).assignHolesToShells(t)}assignHolesToShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.assignHoleToShell(t)}}buildIndex(){this._shellIndex=new vs;for(const t of this._shells)this._shellIndex.insert(t.getRing().getEnvelopeInternal(),t)}queryOverlappingShells(t){return this._shellIndex.query(t)}findShellContaining(t){const e=t.getRing().getEnvelopeInternal(),n=this.queryOverlappingShells(e);return Gr.findEdgeRingContaining(t,n)}assignHoleToShell(t){const e=this.findShellContaining(t);null!==e&&e.addHole(t)}}class Yr{constructor(){Yr.constructor_.apply(this,arguments)}static constructor_(){if(this._lineStringAdder=new Vr(this),this._graph=null,this._dangles=new L,this._cutEdges=new L,this._invalidRingLines=new L,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Yr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}}static extractPolygons(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static findDisjointShells(t){Yr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Ct),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Ct.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new L,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new L;this._invalidRingLines=new L,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Br.assignHolesToShells(this._holeList,this._shellList),xe.sort(this._shellList,new Gr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Yr.findDisjointShells(this._shellList),n=!1),this._polyList=Yr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof J){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new qr(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof X){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new L,this._shellList=new L;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}}class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static constructor_(){this.p=null;const t=arguments[0];this.p=t}filter(t){t instanceof J&&this.p.add(t)}get interfaces_(){return[k]}}Yr.LineStringAdder=Vr;var zr=Object.freeze({__proto__:null,Polygonizer:Yr});class kr{constructor(){kr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._ptLocator=new fn,this._arg=null,this._nodes=new es(new vr),this._im=null,this._isolatedEdges=new L,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,Qt.EXTERIOR)}computeIM(){const t=new Jt;if(t.set(Qt.EXTERIOR,Qt.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new Tr,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===Qt.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,Qt.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===Qt.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,Qt.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();g.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(Qt.INTERIOR,Qt.EXTERIOR,e.getDimension()),t.set(Qt.BOUNDARY,Qt.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(Qt.EXTERIOR,Qt.INTERIOR,n.getDimension()),t.set(Qt.EXTERIOR,Qt.BOUNDARY,n.getBoundaryDimension()))}}class Xr{constructor(){Xr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new Xr(t).contains(e)}isContainedInBoundary(t){if(t instanceof it)return!1;if(t instanceof tt)return this.isPointContainedInBoundary(t);if(t instanceof J)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new m,s=new m;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof tt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof m){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Ur{constructor(){Ur.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new m(t.getMinX(),t.getMinY()),this._diagUp1=new m(t.getMaxX(),t.getMaxY()),this._diagDown0=new m(t.getMinX(),t.getMaxY()),this._diagDown1=new m(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new O(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Hr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Wr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new Zr(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new jr(this._rectangle);return s.applyTo(t),!!s.intersects()}}class Wr extends Ne{constructor(){super(),Wr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}}class Zr extends Ne{constructor(){super(),Zr.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof it))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new m;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}}class jr extends Ne{constructor(){super(),jr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new m,this._p1=new m;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Ur(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=ye.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class Kr extends Ir{constructor(){super(),Kr.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Ir.constructor_.call(this,t,e),this._relate=new kr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Ir.constructor_.call(this,t,e,n),this._relate=new kr(this._arg)}}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Kr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Hr.intersects(t,e);if(e.isRectangle())return Hr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Kr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Kr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Kr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){return new Kr(arguments[0],arguments[1]).getIntersectionMatrix()}if(3===arguments.length){return new Kr(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Kr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Kr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Xr.contains(t,e):new Kr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}}var Qr=Object.freeze({__proto__:null,RelateOp:Kr});class Jr{constructor(){Jr.constructor_.apply(this,arguments)}static constructor_(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()}static union(t,e){return new Jr(t,e).union()}union(){const t=new fn,e=new lt;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===Qt.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=dt.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),he.combine(n,this._otherGeom)}}class $r{constructor(){$r.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._polygons=new L,this._lines=new L,this._points=new L,this._dimension=K.FALSE}static extract(){if(I(arguments[0],N)){const t=arguments[0],e=new $r;return e.add(t),e}if(arguments[0]instanceof X){const t=arguments[0],e=new $r;return e.add(t),e}}getFactory(){return this._geomFactory}recordDimension(t){t>this._dimension&&(this._dimension=t)}getDimension(){return this._dimension}filter(t){return this.recordDimension(t.getDimension()),t instanceof ct||t.isEmpty()?null:t instanceof it?(this._polygons.add(t),null):t instanceof J?(this._lines.add(t),null):t instanceof tt?(this._points.add(t),null):void g.shouldNeverReachHere("Unhandled geometry type: "+t.getGeometryType())}getExtract(t){switch(t){case 0:return this._points;case 1:return this._lines;case 2:return this._polygons}return g.shouldNeverReachHere("Invalid dimension: "+t),null}isEmpty(){return this._polygons.isEmpty()&&this._lines.isEmpty()&&this._points.isEmpty()}add(){if(I(arguments[0],N)){const t=arguments[0];for(const e of t)this.add(e)}else if(arguments[0]instanceof X){const t=arguments[0];null===this._geomFactory&&(this._geomFactory=t.getFactory()),t.apply(this)}}get interfaces_(){return[Q]}}class to{constructor(){to.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._g0=null,this._g1=null,this._isUnionSafe=null;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e,this._geomFactory=t.getFactory()}static containsProperly(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!t.isNull()&&(e.getX()>t.getMinX()&&e.getX()<t.getMaxX()&&e.getY()>t.getMinY()&&e.getY()<t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return to.containsProperly(t,e)&&to.containsProperly(t,n)}}static union(t,e){return new to(t,e).union()}static intersects(t,e,n){return t.intersects(e)||t.intersects(n)}static overlapEnvelope(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();return n.intersection(s)}static extractBorderSegments(t,e,n){t.apply(new class{get interfaces_(){return[P]}filter(t,s){if(s<=0)return null;const i=t.getCoordinate(s-1),r=t.getCoordinate(s);if(to.intersects(e,i,r)&&!to.containsProperly(e,i,r)){const t=new Kt(i,r);n.add(t)}}isDone(){return!1}isGeometryChanged(){return!1}})}static unionBuffer(t,e){return t.getFactory().createGeometryCollection([t,e]).buffer(0)}isBorderSegmentsSame(t,e){const n=this.extractBorderSegments(this._g0,this._g1,e),s=new L;return to.extractBorderSegments(t,e,s),this.isEqual(n,s)}extractByEnvelope(t,e,n){const s=new L;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);if(r.getEnvelopeInternal().intersects(t))s.add(r);else{const t=r.copy();n.add(t)}}return this._geomFactory.buildGeometry(s)}isEqual(t,e){if(t.size()!==e.size())return!1;const n=new xt(t);for(const t of e)if(!n.contains(t))return!1;return!0}union(){const t=to.overlapEnvelope(this._g0,this._g1);if(t.isNull()){const t=this._g0.copy(),e=this._g1.copy();return he.combine(t,e)}const e=new L,n=this.extractByEnvelope(t,this._g0,e),s=this.extractByEnvelope(t,this._g1,e),i=this.unionFull(n,s);let r=null;return this._isUnionSafe=this.isBorderSegmentsSame(i,t),r=this._isUnionSafe?this.combine(i,e):this.unionFull(this._g0,this._g1),r}combine(t,e){if(e.size()<=0)return t;e.add(t);return he.combine(e)}unionFull(t,e){try{return t.union(e)}catch(n){if(n instanceof ss)return to.unionBuffer(t,e);throw n}}extractBorderSegments(t,e,n){const s=new L;return to.extractBorderSegments(t,n,s),null!==e&&to.extractBorderSegments(e,n,s),s}isUnionOptimized(){return this._isUnionSafe}}class eo{constructor(){eo.constructor_.apply(this,arguments)}static constructor_(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new L)}static restrictToPolygons(t){if(I(t,st))return t;const e=Ie.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Ct.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new eo(t).union()}reduceToGeometries(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;I(t,w)?s=this.unionTree(t):t instanceof X&&(s=t),e.add(s)}return e}union(){if(null===this._inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new vs(eo.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=eo.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(eo.getGeometry(t,e),eo.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionActual(t,e)}unionActual(t,e){const n=to.union(t,e);return eo.restrictToPolygons(n)}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}}eo.STRTREE_NODE_CAPACITY=4;class no{constructor(){no.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._extracter=null,1===arguments.length){if(I(arguments[0],N)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof X){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}}static union(){if(1===arguments.length){if(I(arguments[0],N)){return new no(arguments[0]).union()}if(arguments[0]instanceof X){return new no(arguments[0]).union()}}else if(2===arguments.length){return new no(arguments[0],arguments[1]).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return Er.overlayOp(t,e,Nr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)}extract(){if(I(arguments[0],N)){const t=arguments[0];this._extracter=$r.extract(t)}else if(arguments[0]instanceof X){const t=arguments[0];this._extracter=$r.extract(t)}}union(){if(null===this._geomFact&&(this._geomFact=this._extracter.getFactory()),null===this._geomFact)return null;if(this._extracter.isEmpty())return this._geomFact.createEmpty(this._extracter.getDimension());const t=this._extracter.getExtract(0),e=this._extracter.getExtract(1),n=this._extracter.getExtract(2);let s=null;if(t.size()>0){const e=this._geomFact.buildGeometry(t);s=this.unionNoOpt(e)}let i=null;if(e.size()>0){const t=this._geomFact.buildGeometry(e);i=this.unionNoOpt(t)}let r=null;n.size()>0&&(r=eo.union(n));const o=this.unionWithNull(i,r);let l=null;return l=null===s?o:null===o?s:Jr.union(s,o),null===l?this._geomFact.createGeometryCollection():l}}var so=Object.freeze({__proto__:null,UnaryUnionOp:no}),io=Object.freeze({__proto__:null,IsValidOp:Fr,ConsistentAreaTester:br}),ro=Object.freeze({__proto__:null,BoundaryOp:si,IsSimpleOp:ri,buffer:qi,distance:zi,linemerge:ir,overlay:Sr,polygonize:zr,relate:Qr,union:so,valid:io});class oo extends ue.CoordinateOperation{constructor(){super(),oo.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e}edit(){if(2===arguments.length&&arguments[1]instanceof X&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new m(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new R(n,!1).toCoordinateArray();let i=0;e instanceof J&&(i=2),e instanceof ut&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}}class lo{constructor(){lo.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t}static reduce(t,e){return new lo(e).reduce(t)}static reducePointwise(t,e){const n=new lo(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));return Gi.bufferOp(e,0)}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new ue(n)}else e=new ue;let n=this._removeCollapsed;t.getDimension()>=2&&(n=!0);return e.edit(t,new oo(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new ue.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Ct(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:I(e,st)?Fr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new ue;const n=this.createFactory(t,e);return new ue(n)}}var ao=Object.freeze({__proto__:null,GeometryPrecisionReducer:lo});class co{constructor(){co.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new Kt;const t=arguments[0];this._pts=t}static simplify(t,e){const n=new co(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new R;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new m(this._pts[e]));return t.toCoordinateArray()}}class ho{constructor(){ho.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new ho(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new uo(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class uo extends me{constructor(){super(),uo.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof ft?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):co.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof it,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof ut?s:null}}ho.DPTransformer=uo;class go extends Kt{constructor(){super(),go.constructor_.apply(this,arguments)}static constructor_(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];go.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,t,e),this._parent=n,this._index=s}}getIndex(){return this._index}getParent(){return this._parent}}class _o{constructor(){_o.constructor_.apply(this,arguments)}static constructor_(){if(this._parentLine=null,this._segs=null,this._resultSegs=new L,this._minimumSize=null,1===arguments.length){const t=arguments[0];_o.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(_o.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(_o.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new go(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return _o.extractCoordinates(this._resultSegs)}}class po{constructor(){po.constructor_.apply(this,arguments)}static constructor_(){this._index=new Is}remove(t){this._index.remove(new O(t.p0,t.p1),t)}add(){if(arguments[0]instanceof _o){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof Kt){const t=arguments[0];this._index.insert(new O(t.p0,t.p1),t)}}query(t){const e=new O(t.p0,t.p1),n=new mo(t);this._index.query(e,n);return n.getItems()}}class mo{constructor(){mo.constructor_.apply(this,arguments)}static constructor_(){this._querySeg=null,this._items=new L;const t=arguments[0];this._querySeg=t}visitItem(t){const e=t;O.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class fo{constructor(){fo.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._inputIndex=new po,this._outputIndex=new po,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new Kt(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new Kt;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new Kt;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(fo.isInLineSection(t,e,i))continue;return!0}}return!1}}class yo{constructor(){yo.constructor_.apply(this,arguments)}static constructor_(){this._inputIndex=new po,this._outputIndex=new po,this._distanceTolerance=0}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new fo(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}}class xo{constructor(){xo.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._lineSimplifier=new yo,this._linestringMap=null;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new xo(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();this._linestringMap=new It,this._inputGeom.apply(new Io(this)),this._lineSimplifier.simplify(this._linestringMap.values());return new Eo(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}}class Eo extends me{constructor(){super(),Eo.constructor_.apply(this,arguments)}static constructor_(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof J){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}}class Io{constructor(){Io.constructor_.apply(this,arguments)}static constructor_(){this.tps=null;const t=arguments[0];this.tps=t}filter(t){if(t instanceof J){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new _o(e,n);this.tps._linestringMap.put(e,s)}}get interfaces_(){return[k]}}xo.LineStringTransformer=Eo,xo.LineStringMapBuilderFilter=Io;class No{constructor(){No.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e}static simplify(t,e){return new No(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=So.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new m(n[0])]:n}}class So{constructor(){So.constructor_.apply(this,arguments)}static constructor_(){this._pt=null,this._prev=null,this._next=null,this._area=So.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new So(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new R;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=So.MAX_AREA,null;this._area=Math.abs(ne.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}}So.MAX_AREA=r.MAX_VALUE,No.VWVertex=So;class wo{constructor(){wo.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new wo(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Co(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class Co extends me{constructor(){super(),Co.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof ft?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):No.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof it,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof ut?s:null}}wo.VWTransformer=Co;var Lo=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:ho,TopologyPreservingSimplifier:xo,VWSimplifier:wo});class To{constructor(){To.constructor_.apply(this,arguments)}static constructor_(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()}static pointAlongReverse(t,e){const n=new m;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=To.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=To.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}}class Ro{findSplitPoint(t,e){}}class Po{static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new To(n),r=Po.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}get interfaces_(){return[Ro]}}class Oo{static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=D.valueOf(t.x).selfSubtract(s.x),r=D.valueOf(t.y).selfSubtract(s.y),o=D.valueOf(e.x).selfSubtract(s.x),l=D.valueOf(e.y).selfSubtract(s.y),a=D.valueOf(n.x).selfSubtract(s.x),c=D.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),p=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(p.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=Oo.isInCircleNonRobust(t,e,n,s),r=Oo.isInCircleDDSlow(t,e,n,s),o=Oo.isInCircleCC(t,e,n,s),l=ne.circumcentre(t,e,n);B.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(B.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),B.out.println(Wt.toLineString(new pt([t,e,n,s]))),B.out.println("Circumcentre = "+Wt.toPoint(l)+" radius = "+t.distance(l)),B.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),B.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),B.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),B.out.println())}static isInCircleDDFast(t,e,n,s){const i=D.sqr(t.x).selfAdd(D.sqr(t.y)).selfMultiply(Oo.triAreaDDFast(e,n,s)),r=D.sqr(e.x).selfAdd(D.sqr(e.y)).selfMultiply(Oo.triAreaDDFast(t,n,s)),o=D.sqr(n.x).selfAdd(D.sqr(n.y)).selfMultiply(Oo.triAreaDDFast(t,e,s)),l=D.sqr(s.x).selfAdd(D.sqr(s.y)).selfMultiply(Oo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=ne.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=D.valueOf(s.x),r=D.valueOf(s.y),o=D.valueOf(t.x),l=D.valueOf(t.y),a=D.valueOf(e.x),c=D.valueOf(e.y),h=D.valueOf(n.x),u=D.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(Oo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(Oo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(Oo.triAreaDDSlow(o,l,a,c,i,r)),p=i.multiply(i).add(r.multiply(r)).multiply(Oo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(p).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*Oo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*Oo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*Oo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*Oo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return Oo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=D.valueOf(e.x).selfSubtract(t.x).selfMultiply(D.valueOf(n.y).selfSubtract(t.y)),i=D.valueOf(e.y).selfSubtract(t.y).selfMultiply(D.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}}class vo{constructor(){vo.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new m(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e,n)}}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.getZ()-e.getZ();return e.getZ()+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}}circleCenter(t,e){const n=new vo(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new ee(s,i);let o=null;try{o=new vo(r.getX(),r.getY())}catch(s){if(!(s instanceof te))throw s;B.err.println("a: "+n+"  b: "+t+"  c: "+e),B.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.getZ()}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new ee(t.getX()+n/2,t.getY()+s/2,1),r=new ee(t.getX()-s+n/2,t.getY()+n+s/2,1);return new ee(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return Oo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.getZ()+t.getZ())/2;return new vo(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.setZ(t)}times(t){return new vo(t*this._p.x,t*this._p.y)}cross(){return new vo(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new vo(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=this,s=e.sub(t),i=n.sub(t),r=s.crossProduct(i);return r>0?vo.LEFT:r<0?vo.RIGHT:s.getX()*i.getX()<0||s.getY()*i.getY()<0?vo.BEHIND:s.magn()<i.magn()?vo.BEYOND:t.equals(n)?vo.ORIGIN:e.equals(n)?vo.DESTINATION:vo.BETWEEN}sum(t){return new vo(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}}vo.LEFT=0,vo.RIGHT=1,vo.BEYOND=2,vo.BEHIND=3,vo.BETWEEN=4,vo.ORIGIN=5,vo.DESTINATION=6;class Mo extends vo{constructor(){super(),Mo.constructor_.apply(this,arguments)}static constructor_(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];vo.constructor_.call(this,t)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}}class bo{constructor(){bo.constructor_.apply(this,arguments)}static constructor_(){this._rot=null,this._vertex=null,this._next=null,this._data=null}static makeEdge(t,e){const n=new bo,s=new bo,i=new bo,r=new bo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();bo.splice(t,e),bo.splice(t.sym(),n),bo.splice(t,e.lNext()),bo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=bo.makeEdge(t.dest(),e.orig());return bo.splice(n,t.lNext()),bo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new Kt(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Wt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}}class Do{constructor(){Do.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);bo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))bo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}}class Ao{locate(t){}}class Fo{constructor(){Fo.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}get interfaces_(){return[Ao]}}class Go extends h{constructor(){super(),Go.constructor_.apply(this,arguments)}static constructor_(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];h.constructor_.call(this,t)}else if(arguments[0]instanceof Kt){const t=arguments[0];h.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new Kt(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,Go.msgWithSpatial(t,e)),this._seg=new Kt(e)}}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}}class qo{visit(t){}}class Bo{constructor(){Bo.constructor_.apply(this,arguments)}static constructor_(){this._visitedKey=0,this._quadEdges=new L,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new Kt,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/Bo.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Fo(this)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new s("Edges do not form a triangle")}getTriangleVertices(t){const e=new zo;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=bo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new L,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new R;i.addAll(n,!1),i.closeRing(),i.size()<4&&(B.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);bo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return bo.splice(e.sym(),n),bo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);Bo.getTriangleEdges(t,e);const n=new Array(3).fill(null);Bo.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=bo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new en;n.push(this._startingEdge);const s=new xt;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());return this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new O(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new vo((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new vo(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new vo(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new O(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new ko;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new xt;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new L,n=new xt;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Vo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new L,n=new en;n.push(this._startingEdge);const s=new xt;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){bo.splice(t,t.oPrev()),bo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new Go(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new Yo,!0);const e=new L;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Ct.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);bo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof vo){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._locator.locate(new vo(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new vo(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}}class Yo{visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=ne.circumcentreDD(e,n,s),r=new vo(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}get interfaces_(){return[qo]}}class Vo{constructor(){Vo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}get interfaces_(){return[qo]}}class zo{constructor(){zo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}get interfaces_(){return[qo]}}class ko{constructor(){ko.constructor_.apply(this,arguments)}static constructor_(){this._coordList=new R,this._triCoords=new L}checkTriangleSize(t){let e="";t.length>=2?e=Wt.toLineString(t[0],t[1]):t.length>=1&&(e=Wt.toPoint(t[0]))}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}get interfaces_(){return[qo]}}Bo.TriangleCircumcentreVisitor=Yo,Bo.TriangleEdgesListVisitor=Vo,Bo.TriangleVertexListVisitor=zo,Bo.TriangleCoordinatesVisitor=ko,Bo.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class Xo{constructor(){Xo.constructor_.apply(this,arguments)}static constructor_(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new Kt(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new Kt(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];Xo.constructor_.call(this,new m(t,e,n),new m(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];Xo.constructor_.call(this,new m(t,e,n),new m(s,i,r),o)}}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).getZ()}getStartZ(){return this._ls.getCoordinate(0).getZ()}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}}class Uo extends h{constructor(){super(),Uo.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,Uo.msgWithCoord(t,e)),this._pt=new m(e)}}static msgWithCoord(t,e){return null!==e?t+" [ "+Wt.toPoint(e)+" ]":t}getCoordinate(){return this._pt}}class Ho{constructor(){Ho.constructor_.apply(this,arguments)}static constructor_(){this._initialVertices=null,this._segVertices=null,this._segments=new L,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new Po,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new L(t),this._tolerance=e,this._kdt=new us(e)}static computeVertexEnvelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<Ho.MAX_SPLIT_ITER);if(t===Ho.MAX_SPLIT_ITER)throw new Uo("Too many splitting iterations while enforcing constraints.  Last split point was at: ",this._splitPt)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Ct,e=this.getPointArray(),n=new sn(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new m((e.x+n.x)/2,(e.y+n.y)/2),i=e.distance(s),o=new O(s);o.expandBy(i);const l=this._kdt.query(o);let a=null,c=r.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const r=t.next().getCoordinate();if(r.equals2D(e)||r.equals2D(n))continue;const o=s.distance(r);if(o<i){const t=o;(null===a||t<c)&&(a=r,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new L;let n=0;const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new Xo(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new Xo(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new Mo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new Mo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=Ho.computeVertexEnvelope(this._initialVertices),e=Ho.computeVertexEnvelope(this._segVertices),n=new O(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new O(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new Bo(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Fo(this._subdiv)),this._incDel=new Do(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof Mo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof m){const t=arguments[0];this.insertSite(this.createVertex(t))}}}Ho.MAX_SPLIT_ITER=99;class Wo{constructor(){Wo.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null}static extractUniqueCoordinates(t){if(null===t)return new R;const e=t.getCoordinates();return Wo.unique(e)}static envelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=dt.copyDeep(t);nt.sort(e);return new R(e,!1)}static toVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new vo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Wo.envelope(this._siteCoords),e=Wo.toVertices(this._siteCoords);this._subdiv=new Bo(t,this._tolerance);new Do(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof X){const t=arguments[0];this._siteCoords=Wo.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=Wo.unique(dt.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}}class Zo{constructor(){Zo.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new Hn}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=ye.getLines(t),n=new L;for(let t=e.iterator();t.hasNext();){const e=t.next();Zo.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[1],e=arguments[0].getCoordinates();for(let n=1;n<e.length;n++)t.add(new Xo(e[n-1],e[n]))}}createSiteVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new Mo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Wo.envelope(this._siteCoords);let e=new L;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=Zo.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new Ho(n,this._tolerance);s.setConstraints(e,new L(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=Wo.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new Mo(e[t]);this._constraintVertexMap.put(e[t],n)}}}class jo{constructor(){jo.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new L;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=Nr.intersection(n,r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Ct.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=Wo.envelope(this._siteCoords);if(this._diagramEnv=this._clipEnv,null===this._diagramEnv){this._diagramEnv=t;const e=this._diagramEnv.getDiameter();this._diagramEnv.expandBy(e)}const e=Wo.toVertices(this._siteCoords);this._subdiv=new Bo(t,this._tolerance);new Do(this._subdiv).insertSites(e)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return jo.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof X){const t=arguments[0];this._siteCoords=Wo.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=Wo.unique(dt.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}}var Ko=Object.freeze({__proto__:null,Vertex:vo}),Qo=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:Zo,DelaunayTriangulationBuilder:Wo,VoronoiDiagramBuilder:jo,quadedge:Ko});class Jo{constructor(){Jo.constructor_.apply(this,arguments)}static constructor_(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];Jo.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Jo.constructor_.call(this,t,e.getComponentIndex(),Jo.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!I(t,W))throw new s("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=n,this.loadCurrentLine()}}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}}class $o{constructor(){$o.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new $o(t).indexOf(e)}static indexOfAfter(t,e,n){return new $o(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=e,i=0;const o=new Kt,l=new Jo(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const r=o.distance(t),a=this.segmentNearestMeasure(o,t,i);r<n&&a>e&&(s=a,n=r),i+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}}class tl{constructor(){tl.constructor_.apply(this,arguments)}static constructor_(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];tl.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}}static getEndLocation(t){const e=new tl;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.getZ()-t.getZ())*n+t.getZ();return new m(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}static numSegments(t){const e=t.getNumPoints();return e<=1?0:e-1}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex),n=tl.numSegments(e);return this._segmentIndex>=n||this._segmentIndex===n-1&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex),n=tl.numSegments(e);return this._segmentIndex<n?this:new tl(this._componentIndex,n-1,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=tl.numSegments(e))return n;const s=e.getCoordinateN(this._segmentIndex+1);return tl.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=tl.numSegments(e)){const t=e.getCoordinateN(e.getNumPoints()-2);return new Kt(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new Kt(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=tl.numSegments(e),this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=tl.numSegments(e),this._segmentFraction=0}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new tl(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=tl.numSegments(e)&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}get interfaces_(){return[o]}}class el{constructor(){el.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new el(t).indexOf(e)}static indexOfAfter(t,e,n){return new el(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=0,i=0,o=-1;const l=new Kt;for(let r=new Jo(this._linearGeom);r.hasNext();r.next())if(!r.isEndOfLine()){l.p0=r.getSegmentStart(),l.p1=r.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=r.getComponentIndex(),u=r.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,i=u,o=c,n=a)}if(n===r.MAX_VALUE)return new tl(e);return new tl(s,i,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=tl.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}}class nl{constructor(){nl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indicesOf(t,e){return new nl(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new el(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}}class sl{constructor(){sl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static getLength(t,e){return new sl(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[1];return new sl(arguments[0]).getLocation(t)}if(3===arguments.length){const t=arguments[1],e=arguments[2];return new sl(arguments[0]).getLocation(t,e)}}getLength(t){let e=0;const n=new Jo(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new tl(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new tl;let e=0;const n=new Jo(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new tl(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new tl(r,o,s)}e+=i}n.next()}return tl.getEndLocation(this._linearGeom)}}class il{constructor(){il.constructor_.apply(this,arguments)}static constructor_(){this._geomFact=null,this._lines=new L,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let n=null;try{n=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof s))throw t;if(!this._ignoreInvalidLines)throw t}null!==n&&this._lines.add(n)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new R),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}}class rl{constructor(){rl.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}static extract(t,e,n){return new rl(t).extract(e,n)}computeLinear(t,e){const n=new il(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new Jo(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new R;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return I(t,W)?t.reverse():(g.shouldNeverReachHere("non-linear geometry encountered"),null)}}class ll{constructor(){ll.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return sl.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return sl.getLocation(this._linearGeom,t,e)}}project(t){return $o.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return sl.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=sl.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return $o.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return rl.extract(this._linearGeom,r,o)}indexOf(t){return $o.indexOf(this._linearGeom,t)}indicesOf(t){const e=nl.indicesOf(this._linearGeom,t);return[sl.getLength(this._linearGeom,e[0]),sl.getLength(this._linearGeom,e[1])]}}class al{constructor(){al.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return el.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof J||this._linearGeom instanceof wt))throw new s("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[1],e=arguments[0].toLowest(this._linearGeom);return e.getSegment(this._linearGeom).pointAlongOffset(e.getSegmentFraction(),t)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return tl.getEndLocation(this._linearGeom)}getStartIndex(){return new tl}indexOfAfter(t,e){return el.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return rl.extract(this._linearGeom,t,e)}indexOf(t){return el.indexOf(this._linearGeom,t)}indicesOf(t){return nl.indicesOf(this._linearGeom,t)}}var cl=Object.freeze({__proto__:null,LengthIndexedLine:ll,LengthLocationMap:sl,LinearGeometryBuilder:il,LinearIterator:Jo,LinearLocation:tl,LocationIndexedLine:al});class hl{static transform(t,e){const n=new L;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}}hl.Function=function(){};class ul{constructor(){ul.constructor_.apply(this,arguments)}static constructor_(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}get interfaces_(){return[U]}}class gl{constructor(){gl.constructor_.apply(this,arguments)}static constructor_(){this._n=0}filter(t){this._n++}getCount(){return this._n}get interfaces_(){return[U]}}class dl{constructor(){dl.constructor_.apply(this,arguments)}static constructor_(){this._counts=new It}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new _l(1)):e.increment()}}class _l{constructor(){_l.constructor_.apply(this,arguments)}static constructor_(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}}count(){return this.count}increment(){this.count++}}function pl(){}function ml(){}function fl(){}dl.Counter=_l;class yl extends n{}function xl(){}class El{static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new fl,n=new pl(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";const s=new xl(new ml(El.getStackTrace(t)));for(let t=0;t<e;t++)try{n+=s.readLine()+El.NEWLINE}catch(t){if(!(t instanceof yl))throw t;g.shouldNeverReachHere()}return n}}static spaces(t){return El.chars(" ",t)}static split(t,e){const n=e.length,s=new L;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}}El.NEWLINE=B.getProperty("line.separator");var Il=Object.freeze({__proto__:null,CollectionUtil:hl,CoordinateArrayFilter:ul,CoordinateCountFilter:gl,GeometricShapeFactory:Se,NumberUtil:e,ObjectCounter:dl,PriorityQueue:Cs,StringUtil:El,UniqueCoordinateArrayFilter:nn});class Nl{get interfaces_(){return[]}getClass(){return Nl}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Nr.createEmptyResult(Nr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),Er.overlayOp(t,e,Nr.UNION)}}J.prototype.getBoundary=function(){return si.getBoundary(this)},wt.prototype.getBoundary=function(){return si.getBoundary(this)},X.prototype.equalsTopo=function(t){return Kr.equalsTopo(this,t)},X.prototype.equals=function(t){return null!==t&&Kr.equalsTopo(this,t)},X.prototype.union=function(){if(0===arguments.length)return no.union(this);if(1===arguments.length){const t=arguments[0];return Nl.union(this,t)}},X.prototype.isValid=function(){return Fr.isValid(this)},X.prototype.intersection=function(t){return Nr.intersection(this,t)},X.prototype.covers=function(t){return Kr.covers(this,t)},X.prototype.coveredBy=function(t){return Kr.covers(t,this)},X.prototype.touches=function(t){return Kr.touches(this,t)},X.prototype.intersects=function(t){return Kr.intersects(this,t)},X.prototype.within=function(t){return Kr.contains(t,this)},X.prototype.overlaps=function(t){return Kr.overlaps(this,t)},X.prototype.disjoint=function(t){return Kr.disjoint(this,t)},X.prototype.crosses=function(t){return Kr.crosses(this,t)},X.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return Gi.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Gi.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return Gi.bufferOp(this,t,e,n)}},X.prototype.convexHull=function(){return new sn(this).getConvexHull()},X.prototype.relate=function(){if(1===arguments.length){const t=arguments[0];return Kr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Kr.relate(this,t).matches(e)}},X.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=$e.getCentroid(this);return this.createPointFromInternalCoord(t,this)},X.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new un(this):1===e?new hn(this):new on(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},X.prototype.symDifference=function(t){return Nr.symDifference(this,t)},X.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},X.prototype.toText=function(){return(new Wt).write(this)},X.prototype.toString=function(){this.toText()},X.prototype.contains=function(t){return Kr.contains(this,t)},X.prototype.difference=function(t){return Nr.difference(this,t)},X.prototype.isSimple=function(){return new ri(this).isSimple()},X.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&Vi.isWithinDistance(this,t,e)},X.prototype.distance=function(t){return Vi.distance(this,t)};t.algorithm=En,t.densify=Sn,t.dissolve=vn,t.geom=Te,t.geomgraph=as,t.index=Ds,t.io=Ys,t.linearref=cl,t.noding=ni,t.operation=ro,t.precision=ao,t.simplify=Lo,t.triangulate=Qo,t.util=Il,t.version="2.6.0 (ddae866)",Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=jsts.min.js.map

/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./src/base/AgentPoint.js":
/*!********************************!*\
  !*** ./src/base/AgentPoint.js ***!
  \********************************/
/*! exports provided: AgentPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgentPoint", function() { return AgentPoint; });
//@ts-check

/** */
class AgentPoint {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(x, y, sx=0, sy=0) {

        //position

        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y

        //speed

        /** @type {number} */
        this.sx = sx
        /** @type {number} */
        this.sy = sy
        /** @type {number} */
        this.s = undefined
        /** @type {number} */
        this.sa = undefined
    }


    /**
     * @param {AgentPoint} a
     * @returns {number} The distance to another agent.
     */
    d(a) {
        return this.dP(a.x, a.y);
    }

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @returns {number} The distance to a position.
     */
    dP(x, y) {
        return Math.hypot((x - this.x), (y - this.y));
    }

    /** 
    * Set random speed
    * 
    * @param {number} minSpeed
    * @param {number} maxSpeed
    */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        this.s = minSpeed + Math.random() * (maxSpeed - minSpeed);
        this.sa = 2 * Math.random() * Math.PI;
        this.sx = this.s * Math.cos(this.sa)
        this.sy = this.s * Math.sin(this.sa)
    }

    /** */
    computeSpeed() {
        this.s = Math.hypot(this.sx, this.sy);
        return this.s
    }

    /** */
    computeSpeedAngle() {
        this.sa = Math.atan2(this.sy, this.sx);
        return this.sa
    }

}


/***/ }),

/***/ "./src/base/GeoCanvas.js":
/*!*******************************!*\
  !*** ./src/base/GeoCanvas.js ***!
  \*******************************/
/*! exports provided: GeoCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoCanvas", function() { return GeoCanvas; });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
//@ts-check
/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */




/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 * 
 * @author Julien Gaffuri
 */
class GeoCanvas {

    /**
     * @constructor
     * @param {string} canvasId
     * @param {object} center Geographical coordinates of the center
     * @param {number} zf The zoom factor (pixel size, in ground m)
     */
    constructor(canvasId = "vacanvas", center = undefined, zf = 1) {

        /** @type {object} */
        this.canvas = document.getElementById(canvasId);

        /** @type {number} */
        this.w = this.canvas.offsetWidth;
        /** @type {number} */
        this.h = this.canvas.offsetHeight;

        this.canvas.width = this.w;
        this.canvas.height = this.h;

        /**@type {object} */
        this.ctx = this.canvas.getContext("2d");

        // set geo coordinates of the center
        this.setCenter(center || { x: this.w * 0.5, y: this.h * 0.5 })

        // set zoom factor: pixel size, in m/pix
        this.setZf(zf);

        //extent
        /** @type {Envelope} */
        this.extGeo = undefined;
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoomIdentity"]
        Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(this.canvas).call(
            Object(d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoom"])().on("zoom", (e) => {
                const t = e.transform
                const f = tP.k / t.k
                if (f == 1) {
                    //pan
                    const dx = tP.x - t.x
                    const dy = tP.y - t.y
                    this.pan(dx * this.getZf(), -dy * this.getZf())
                } else {
                    const se = e.sourceEvent;
                    if (se instanceof WheelEvent) {
                        //zoom at the mouse position
                        this.zoom(f, this.pixToGeoX(e.sourceEvent.offsetX), this.pixToGeoY(e.sourceEvent.offsetY))
                    } else if (se instanceof TouchEvent) {
                        //compute average position of the touches
                        let tx = 0, ty = 0
                        for (let tt of se.targetTouches) { tx += tt.clientX; ty += tt.clientY }
                        tx /= se.targetTouches.length; ty /= se.targetTouches.length
                        //zoom at this average position
                        this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                    }
                }
                tP = t
            }));
    }

    /** @param {{x:number,y:number}} v Geographical coordinates of the center */
    setCenter(v) { this.center = v; }
    /** @returns {{x:number,y:number}} Geographical coordinates of the center */
    getCenter() { return this.center; }

    /** @param {number} v The zoom factor (pixel size, in ground m) */
    setZf(v) { this.zf = v; }
    /** @returns {number} The zoom factor (pixel size, in ground m) */
    getZf() { return this.zf; }




    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.getZf();
        const tx = -this.center.x / this.getZf() + this.w * 0.5;
        const ty = this.center.y / this.getZf() + this.h * 0.5;
        this.ctx.setTransform(k, 0, 0, -k, tx, ty);
    }


    /** The function specifying how to draw the map. */
    redraw() {
        throw new Error('Method redraw not implemented.');
    }

    /**
     * Clear the app screen. To be used before a redraw for example.
     * @param {string} color 
     */
    clear(color = "white") {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.w, this.h);
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
    */
    geoToPixX(xGeo) { return (xGeo - this.center.x) / this.getZf() + this.w * 0.5; }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
    */
    geoToPixY(yGeo) { return -(yGeo - this.center.y) / this.getZf() + this.h * 0.5; }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
    */
    pixToGeoX(x) { return (x - this.w * 0.5) * this.getZf() + this.center.x; }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
    */
    pixToGeoY(y) { return -(y - this.h * 0.5) * this.getZf() + this.center.y; }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo, dyGeo) {
        //TODO force extend to remain
        this.center.x += dxGeo;
        this.center.y += dyGeo;
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.center.x, yGeo = this.center.y) {
        //TODO force extend to remain
        this.setZf(f * this.getZf());
        this.center.x += (xGeo - this.center.x) * (1 - f)
        this.center.y += (yGeo - this.center.y) * (1 - f)
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * @param {number} marginPx 
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx)
        }
        return this.extGeo;
    }

    /**
     * Check if the object has to be drawn
     * 
     * @param {{x:number,y:number}} obj 
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false;
        if (obj.x > this.extGeo.xMax) return false;
        if (obj.y < this.extGeo.yMin) return false;
        if (obj.y > this.extGeo.yMax) return false;
        return true
    }

}


/***/ }),

/***/ "./src/base/SpatialIndex.js":
/*!**********************************!*\
  !*** ./src/base/SpatialIndex.js ***!
  \**********************************/
/*! exports provided: SpatialIndex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpatialIndex", function() { return SpatialIndex; });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
//@ts-check

//see https://github.com/mourner/rbush


/**
 * @template T
 */
class SpatialIndex {

    /**
     * @constructor
     */
    constructor() {
        class MyRBush extends rbush__WEBPACK_IMPORTED_MODULE_0___default.a {
            /** @param {{x:number,y:number}} obj  */
            toBBox(obj) { return { minX: obj.x, minY: obj.y, maxX: obj.x, maxY: obj.y }; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinX(a, b) { return a.x - b.x; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinY(a, b) { return a.y - b.y; }
        }

        /** @type {MyRBush} */
        this.tree = new MyRBush();
    }

    //TODO bulk remove ?

    /**
     * @param {number} xmin
     * @param {number} ymin
     * @param {number} xmax
     * @param {number} ymax
     * @return {Array.<T>}
     */
    get(xmin, ymin, xmax, ymax) {
        return this.tree.search({
            minX: xmin,
            minY: ymin,
            maxX: xmax,
            maxY: ymax
        });
    }

    /**
     * @param {T} obj
     */
    insert(obj) {
        this.tree.insert(obj);
    }

    /**
     * Bulk insert
     * 
     * @param {Array.<T>} objs
     */
    load(objs) {
        this.tree.load(objs);
    }

    /**
     * @param {T} obj
     */
    remove(obj) {
        this.tree.remove(obj)
    }

    /**
     */
    clear() {
        this.tree.clear()
    }

}


/***/ }),

/***/ "./src/base/lib.js":
/*!*************************!*\
  !*** ./src/base/lib.js ***!
  \*************************/
/*! exports provided: objToArray, removeFromArray, removeFromArrayS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objToArray", function() { return objToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArray", function() { return removeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArrayS", function() { return removeFromArrayS; });
//@ts-check
/**
 * @template T
 * @param {Object.<?, T>} obj
 * @returns {Array.<T>}
 */
const objToArray = function (obj) {
    var out = [];
    for (var key in obj)
        if (obj.hasOwnProperty(key))
            out.push(obj[key]);
    return out;
};

/**
 * @template T
 * @param {Array.<T>} arr
 * @param {T} obj
 * @param {boolean} msg 
 */
const removeFromArray = function (arr, obj, msg = true) {
    /** @type {number} */
    var index = arr.indexOf(obj);
    if (index > -1)
        arr.splice(index, 1);
    else
        if (msg) console.log("Impossible to remove element not present in array.");
};

/**
 * 
 * @template T
 * @param {Array.<T>} arr
 * @param {Array.<T>} objs 
 * @param {boolean} msg 
 */
const removeFromArrayS = function (arr, objs, msg = true) {
    for (let obj of objs)
        removeFromArray(arr, obj, msg)
};


/***/ }),

/***/ "./src/fish/Sardin.js":
/*!****************************!*\
  !*** ./src/fish/Sardin.js ***!
  \****************************/
/*! exports provided: Sardin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sardin", function() { return Sardin; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check





/** */
class Sardin extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {Sea} sea 
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(sea, x = sea.w * Math.random(), y = sea.h * Math.random(), sx = undefined, sy = undefined) {

        //
        super(x, y, sx, sy)

        /** @type {Sea} */
        this.sea = sea;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > sea.w ? sea.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > sea.h ? sea.h : y

        //speed
        if (!sx && !sy) {
            this.setRandomSpeed(0, this.sea.V_MAX)

            //acceleration
            /** @type {number} */
            this.ax = 0
            /** @type {number} */
            this.ay = 0

            //list of sardins in vision field
            /** @type {Array.<Sardin>} */
            this.obs = []
            //list of sardins in collision field
            /** @type {Array.<Sardin>} */
            this.col = []
        }
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    observe(sindex) {

        /** @type {Sea} */
        const s = this.sea
        /** @type {number} */
        const dO = s.D_OBS

        //initialise lists
        /** @type {Array.<Sardin>} */
        this.obs = [];
        /** @type {Array.<Sardin>} */
        this.col = [];

        //get sardins around using spatial index
        /** @type {Array.<Sardin>} */
        const ss = sindex.get(this.x - dO, this.y - dO, this.x + dO, this.y + dO);

        //get sardins in observation and collision fields
        for (let f of ss) {
            if (f == this) continue;
            if (this.d(f) <= s.D_COL)
                this.col.push(f);
            if (this.d(f) <= dO) {
                //check angle
                let da = Math.atan2(f.y - this.y, f.x - this.x) - this.sa;
                if (da > Math.PI) da -= 2 * Math.PI;
                else if (da <= -Math.PI) da += 2 * Math.PI;
                da = Math.abs(da);
                if (da > s.A_OBS * 0.5) continue;
                this.obs.push(f);
            }
        }

        //initialise acceleration
        this.ax = 0; this.ay = 0;

        //collision: repulsion
        for (let f of this.col) {
            const d = this.d(f);
            const a = 1.0 * (1 / (d * d) - 1 / (s.D_COL * s.D_COL));
            this.ax += a * (this.x - f.x) / d;
            this.ay += a * (this.y - f.y) / d;
        }

        // toward target speed
        const dv = (s.V_TARGET - this.s) * 0.01;
        this.ax += dv * this.sx / this.s;
        this.ay += dv * this.sy / this.s;

        //toward the observed mean position
        /*if(obs.size()>1){
            double xn=0,yn=0;
            for(Sardin s:obs){
                xn+=s.x;
                yn+=s.y;
            }
            xn=xn/obs.size();
            yn=yn/obs.size();
            double d=Math.hypot(xn-x,yn-y);
            ax+=-0.1*(x-xn)/d;
            ay+=-0.1*(y-yn)/d;
        }*/

        //toward the observed speed
        const t = 0.9;
        if (this.obs.length > 1) {
            let dsx = 0, dsy = 0;
            for (let s of this.obs) {
                dsx += s.sx;
                dsy += s.sy;
            }
            dsx = (t - 1) * this.sx + (1 - t) * dsx / this.obs.length;
            dsy = (t - 1) * this.sy + (1 - t) * dsy / this.obs.length;

            const a = 0.1;
            this.ax += a * dsx;
            this.ay += a * dsy;
        }

        //avoid shark
        const sh = s.shark;
        if (sh != null) {
            const d = Math.hypot((sh.x - this.x), (sh.y - this.y));
            if (d <= s.D_OBS) {
                const a = 5.0 * (1 / (d * d) - 1 / (dO * dO));
                this.ax += a * (this.x - sh.x) / d;
                this.ay += a * (this.y - sh.y) / d;
            }
        }

    }


    /**
     * @param {number} timeStepMs 
     */
    move(timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.sy += this.ay * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.s = this.computeSpeed()
        if (this.s > this.sea.V_MAX) {
            this.s = this.sea.V_MAX;
            this.sx = this.sea.V_MAX * Math.cos(this.sa);
            this.sy = this.sea.V_MAX * Math.sin(this.sa);
        }

        //compute new position
        this.x += this.sx * timeStepMs;
        this.y += this.sy * timeStepMs;

        //limit
        if (this.x < 0) this.x = this.sea.w;
        if (this.y < 0) this.y = this.sea.h;
        if (this.x > this.sea.w) this.x = 0;
        if (this.y > this.sea.h) this.y = 0;
    }


    /**
     * Display a sardin body
     * 
     * @param {GeoCanvas} cp 
     * @param {number} length 
     */
    display(cp, length) {
        const c2 = cp.ctx
        const c = Math.floor(255 * Math.abs(this.sa) / Math.PI);
        c2.strokeStyle = "rgb(255, 255, " + c + ")"
        const a = length / this.s;
        const dx = a * this.sx * 0.5;
        const dy = a * this.sy * 0.5;

        c2.beginPath();
        c2.moveTo(this.x - dx, this.y - dy);
        c2.lineTo(this.x + dx, this.y + dy);
        c2.closePath();
        c2.stroke();
    }

    /**
     * Display sardin vision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} lineWidth 
     */
    displayVisionField(cp, fillStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.arc(this.x, this.y, this.sea.D_OBS / cp.getZf(),
            this.sa - this.sea.A_OBS * 0.5,
            this.sa + this.sea.A_OBS * 0.5
        );
        c2.closePath();
        c2.fill();
    }

    /**
     * Display sardin vision links
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayVisionLinks(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        for (let sa2 of this.obs) {
            c2.beginPath();
            c2.moveTo(this.x, this.y);
            c2.lineTo(sa2.x, sa2.y);
            c2.closePath();
            c2.stroke();
        }
    }

    /**
     * Display sardin collision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayCollisionField(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.sea.D_COL * 0.5 / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/fish/Sea.js":
/*!*************************!*\
  !*** ./src/fish/Sea.js ***!
  \*************************/
/*! exports provided: Sea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sea", function() { return Sea; });
/* harmony import */ var _Sardin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sardin */ "./src/fish/Sardin.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
//@ts-check




/** */
class Sea {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */        //get 10 random locations

    constructor(w, h) {

        //TODO should become static attributes of Sardin class

        //observation
        /** @type {number} */
        this.D_OBS = 50
        /** @type {number} */
        this.A_OBS = 200 * Math.PI / 180

        //collision
        /** @type {number} */
        this.D_COL = 10

        //speed
        /** @type {number} */
        this.V_TARGET = 0.3
        /** @type {number} */
        this.V_MAX = 0.6

        //shark
        /** @type {number} */
        this.D_SHARK_EAT = 12
        /** @type {number} */
        this.EATEN_SARDIN_NB = 0


        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Sardin>} */
        this.fish = []

        //TODO
        this.shark = null;

        /** @type {Array.<Sardin>} */
        this.killed = [];
    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //ini
        for (let f of this.fish) {
            f.computeSpeed()
            f.computeSpeedAngle()
        }

        //make spatial index
        /** @type {SpatialIndex.<Sardin>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.fish)

        //observe
        for (let f of this.fish)
            f.observe(sindex);

        //shark eat fish
        this.sharkEat(sindex);

        //dispose spatial index
        //sindex.clear()

        //move
        for (let f of this.fish)
            f.move(timeStepMs);
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    sharkEat(sindex) {
        if (this.shark == null) return;

        /** @type {Array.<Sardin>} */
        this.killed = [];

        const x = this.shark.x, y = this.shark.y;
        const ss = sindex.get(x - this.D_SHARK_EAT, y - this.D_SHARK_EAT, x + this.D_SHARK_EAT, y + this.D_SHARK_EAT);
        for (let s of ss) {
            const d = Math.hypot((x - s.x), (y - s.y));
            if (d > this.D_SHARK_EAT) continue;
            this.killed.push(s);
            Object(_base_lib__WEBPACK_IMPORTED_MODULE_2__["removeFromArray"])(this.fish, s)
            //sindex.remove(s);
        }
        this.EATEN_SARDIN_NB += this.killed.length;
        //eatenFishNb.setText("Eaten fish: " + EATEN_SARDIN_NB);
        return this;
    }

    /**
     * Add fish
     * 
     * @param {number} nb 
     * @returns {this}
     */
    addFish(nb = 1) {
        for (let i = 0; i < nb; i++)
            this.fish.push(new _Sardin__WEBPACK_IMPORTED_MODULE_0__["Sardin"](this));
        return this
    }

    /**
     * Set random speed for all fish
     * @returns {this}
     */
    setRandomSpeed() {
        for (let f of this.fish)
            f.setRandomSpeed()
        return this
    }

}


/***/ }),

/***/ "./src/fish/index.js":
/*!***************************!*\
  !*** ./src/fish/index.js ***!
  \***************************/
/*! exports provided: fish */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return fish; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check



class FishSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        //TODO
        //add eaten fish nb label

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        /** @type {boolean} */
        this.showFishVisionField = false
        /** @type {boolean} */
        this.showFishVisionLinks = false
        /** @type {boolean} */
        this.showFishCollisionField = false

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx
            const s = th.sea

            this.initCanvasTransform()

            //clear
            c2.fillStyle = "rgba(120,120,255,0.6)";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //show vision field
            if (th.showFishVisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionField(this, "rgba(200,200,200,0.15)", 1)
            //show vision links
            if (th.showFishVisionLinks)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionLinks(this, "rgba(255,100,100,0.3)", 1)
            //show collision field
            if (th.showFishCollisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayCollisionField(this, "purple", 1)


            //display sardins
            c2.lineWidth = 2
            const sardinLength = 7
            for (let sa of s.fish)
                if (this.toDraw(sa))
                    sa.display(this, sardinLength)


            //display shark
            if (s.shark != null) {

                c2.lineWidth = 4
                c2.strokeStyle = "black"

                const sharkLength = 12
                const dx = sharkLength * Math.cos(s.shark.angle);
                const dy = sharkLength * Math.sin(s.shark.angle);

                c2.beginPath();
                c2.moveTo(s.shark.x, s.shark.y);
                c2.lineTo(s.shark.x - dx, s.shark.y + dy);
                c2.closePath();
                c2.stroke();
            }

            //display blood spot
            c2.fillStyle = "red";
            c2.lineWidth = 1
            for (let sa of s.killed) {
                c2.beginPath();
                c2.moveTo(sa.x, sa.y);
                c2.arc(sa.x, sa.y, 4, 0, 2 * Math.PI);
                c2.closePath();
                c2.fill();
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        this.cplus.canvas.addEventListener("mouseover", e => {
            th.sea.shark = { x: th.cplus.pixToGeoX(e.offsetX), y: th.cplus.pixToGeoY(e.offsetY), angle: 0 }
        });
        this.cplus.canvas.addEventListener("mousemove", e => {
            const xG = th.cplus.pixToGeoX(e.offsetX);
            const yG = th.cplus.pixToGeoY(e.offsetY);
            const angle = Math.atan2(-yG + th.sea.shark.y, xG - th.sea.shark.x);
            th.sea.shark = { x: xG, y: yG, angle: angle }
        });
        this.cplus.canvas.addEventListener("mouseout", e => {
            th.sea.shark = null;
        });


        /** @type {Sea} */
        this.sea = new _Sea__WEBPACK_IMPORTED_MODULE_0__["Sea"](this.w, this.h)

    }


    /**
     * @param {number} density 
     * @returns {this}
     */
    initRandom(density = 0.001) {
        this.sea.addFish(density * this.sea.w * this.sea.h);
        return this
    }

    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.sea.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this
    }

}

/**
 * @param {Object} opts 
 */
const fish = function (opts) {
    return new FishSimulation(opts)
}


/***/ }),

/***/ "./src/gol/Cell.js":
/*!*************************!*\
  !*** ./src/gol/Cell.js ***!
  \*************************/
/*! exports provided: Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return Cell; });
//@ts-check

/**
 * 
 */
class Cell {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} nb 
     */
    constructor(x, y, nb=0) {
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.nb = nb
    }

}


/***/ }),

/***/ "./src/gol/Universe.js":
/*!*****************************!*\
  !*** ./src/gol/Universe.js ***!
  \*****************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




/**
 * 
 */
class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Cell>} */
        this.population = [];
        /** @type {Object.<string,Cell>} */
        this.populationI = {};
    }

    /**
     * @param {number} x
     * @param {number} y
     * @returns {Cell|null}
     */
    add(x, y) {

        //find cell at location
        /**@type {string}*/
        const id = x + "_" + y;
        if (this.populationI[id]) return null;

        //create new cell
        /**@type {Cell} */
        const cell = new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x, y, 0)
        this.population.push(cell)
        this.populationI[id] = cell
        return cell
    }

    /**
     * @returns {this}
     */
    step() {

        //TODO double indexing? by raw and then column ?
        //populate cell surroundings
        /** @type {Object.<string, Cell>}
         * @dict */
        const surI = {};
        //go through list of cells
        for (let cell of this.population) {
            // +1 surrounding cells
            const srs = Universe.getCellSurrounding(cell, this);
            for (let sur of srs) {
                const key = sur.x + "_" + sur.y;
                const sur_ = surI[key];
                if (sur_) {
                    sur_.nb++;
                } else {
                    sur.nb = 1;
                    surI[key] = sur;
                }
            }
        }

        //B3/S23
        //kill cells
        /** @type {Array.<Cell>} */
        const cellsToKeep = [];
        /** @type {Object.<string, Cell>}
         * @dict */
        const cellsToKeepI = {};
        for (let cell of this.population) {
            const key = cell.x + "_" + cell.y;
            const cell_ = surI[key];
            if (!cell_) continue;
            //if (nb<2 or nb>3) -> kill
            if (cell_.nb < 2 || cell_.nb > 3) continue;
            cellsToKeep.push(cell);
            cellsToKeepI[key] = cell;
        }
        this.population = cellsToKeep;
        this.populationI = cellsToKeepI;

        //create new cells
        /** @type {Array.<Cell>} */
        const surs = Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["objToArray"])(surI);
        for (let sur of surs) {

            if (sur.nb !== 3) continue;

            //check if already alive
            const key = sur.x + "_" + sur.y;
            let cell = this.populationI[key];
            if (cell) continue;

            //create new cell
            this.population.push(sur);
            this.populationI[key] = sur;
        }
        return this;
    }


    /**
     * @param {number} nb
     * @param {number} timeoutMS
     * @param {GeoCanvas} cplus
     * @return {Universe}
     */
    start(nb, timeoutMS, cplus) {
        let i = 0;
        const uni = this;
        const engine = function () {
            //console.log(i);
            uni.step();
            cplus.redraw();
            if (nb > 0 && i++ > nb) return;
            setTimeout(engine, timeoutMS);
        };
        engine();
        return this;
    }

    /**
     * @param {Cell} cell
     * @param {Universe} uni
     * @return {Array.<Cell>}
     */
    static getCellSurrounding(cell, uni) {
        const x1 = cell.x === 0 ? uni.w - 1 : cell.x - 1;
        const x2 = cell.x === uni.w - 1 ? 0 : cell.x + 1;
        const y1 = cell.y === 0 ? uni.h - 1 : cell.y - 1;
        const y2 = cell.y === uni.h - 1 ? 0 : cell.y + 1;
        return [
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y2),
        ];
    }

}


/***/ }),

/***/ "./src/gol/index.js":
/*!**************************!*\
  !*** ./src/gol/index.js ***!
  \**************************/
/*! exports provided: gameOfLife */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return gameOfLife; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Universe */ "./src/gol/Universe.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




//TODO zoom/pan, with canvas transform: better universe limits
//TODO buttons (play, stop, speed, draw, pan)
//TODO check canvas animation


class GoLSimulation {

    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //clear
            this.initCanvasTransform()
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            //draw cells
            this.setCanvasTransform()
            c2.fillStyle = "blue";
            for (let cell of th.uni.population)
                c2.fillRect((cell.x), (cell.y), 1, 1);

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };

        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_1__["Universe"](this.w, this.h);
    }


    //
    initRandom(density = 0.05) {
        let i = 0;
        /** @type {number} */
        const nb = this.uni.w * this.uni.h * density;
        while (i < nb) {
            const x = Math.round(this.uni.w * Math.random());
            const y = Math.round(this.uni.h * Math.random());
            /** @type {Cell} */
            const cell = this.uni.add(x, y);
            if (cell) i++;
        }
        return this;
    }


    //
    start() {
        this.uni.start(-1, 0, this.cplus);
        return this;
    }

}


const gameOfLife = function (opts) {
    return new GoLSimulation(opts)
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: planets, gameOfLife, fish, preyPredator, urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _planets_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planets/index */ "./src/planets/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return _planets_index__WEBPACK_IMPORTED_MODULE_0__["planets"]; });

/* harmony import */ var _gol_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gol/index */ "./src/gol/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return _gol_index__WEBPACK_IMPORTED_MODULE_1__["gameOfLife"]; });

/* harmony import */ var _fish_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fish/index */ "./src/fish/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return _fish_index__WEBPACK_IMPORTED_MODULE_2__["fish"]; });

/* harmony import */ var _pp_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pp/index */ "./src/pp/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return _pp_index__WEBPACK_IMPORTED_MODULE_3__["preyPredator"]; });

/* harmony import */ var _urban_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./urban/index */ "./src/urban/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return _urban_index__WEBPACK_IMPORTED_MODULE_4__["urban"]; });

//@ts-check








/***/ }),

/***/ "./src/planets/Planet.js":
/*!*******************************!*\
  !*** ./src/planets/Planet.js ***!
  \*******************************/
/*! exports provided: Planet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Planet", function() { return Planet; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




class Planet extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @constructor
     * @param {Universe} u The universe the planet belongs to.
     * @param {number} m The mass
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} sx The speed x
     * @param {number} sy The speed y
     */
    constructor(u, m, x, y, sx = 0, sy = 0) {

        //
        super(x, y, sx, sy)

        /** @type {Universe} */
        this.u = u;
        u.ps.push(this)

        /** @type {number} */
        this.m = m;

        //compute radius
        /** @type {number} */
        const r = this.r();

        //set position
        /** @type {number} */
        this.x = x < r ? r : x > u.w - r ? u.w - r : x;
        /** @type {number} */
        this.y = y < r ? r : y > u.h - r ? u.h - r : y;

        //acceleration
        /** @type {number} */
        this.ax = 0;
        /** @type {number} */
        this.ay = 0;
    }

    /**
     * Update the force, based on the gravity of other planets.
     * @param {number} exponent
     */
    observe(exponent) {

        //compute gravity field at planet location
        const g = this.u.getGravityField(this.x, this.y, this, exponent);

        //set acceleration
        /** @type {number} */
        this.ax = g.gx;
        /** @type {number} */
        this.ay = g.gy;
    }


    /**
     * @return {number} The radius of the planet, depending on its mass.
     */
    r() {
        return Math.pow(this.m / Math.PI, 0.5);
    }


    /**
     * 
     * @param {boolean} bounce 
     * @param {number} maxSpeed 
     * @param {number} timeStepMs 
     */
    change(bounce = false, maxSpeed = 0.8, timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs;
        this.sy += this.ay * timeStepMs;

        //check vmax
        if (maxSpeed > 0) {
            /** @type {number} */
            const v = Math.sqrt(this.sx * this.sx + this.sy * this.sy);
            if (v > maxSpeed) {
                this.sx = maxSpeed * this.sx / v;
                this.sy = maxSpeed * this.sy / v;
            }
        }

        //compute new position
        /** @type {number} */
        let nx = this.x + this.sx * timeStepMs;
        /** @type {number} */
        let ny = this.y + this.sy * timeStepMs;

        //handle position limit
        if (bounce) {
            const r = this.r();
            const e = 1;
            if (nx < r) { nx = r; this.sx = -this.sx * e; }
            if (ny < r) { ny = r; this.sy = -this.sy * e; }
            if (nx > this.u.w - r) { nx = this.u.w - r; this.sx = -this.sx * e; }
            if (ny > this.u.h - r) { ny = this.u.h - r; this.sy = -this.sy * e; }
        } else {
            if (nx < 0) { nx = this.u.w; }
            if (ny < 0) { ny = this.u.h; }
            if (nx > this.u.w) { nx = 0; }
            if (ny > this.u.h) { ny = 0; }
        }

        //move
        this.x = nx;
        this.y = ny;
    }


    /**
     * Display planet
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     */
    display(cp, fillStyle) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r() / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
    }

    /**
     * Display planet acceleration
     * 
     * @param {GeoCanvas} cp 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     * @param {number} factor 
     */
    displayAcceleration(cp, strokeStyle = "cyan", lineWidth = 1, factor = 5000) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.lineTo(this.x + factor * this.ax, this.y + factor * this.ay);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/planets/Universe.js":
/*!*********************************!*\
  !*** ./src/planets/Universe.js ***!
  \*********************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
//@ts-check




class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Planet>} */
        this.ps = [];
    }

    /**
     * Compute the mass of the universe, as the sum of the mass of its planets.
     * @returns {number}
     */
    m() {
        let m = 0;
        for (let p of this.ps)
            m += p.m;
        return m;
    }


    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {Planet} pIgnore A planet to ignore
     * @param {number} exponent
     * @returns {{gx:number,gy:number}}
     */
    getGravityField(x, y, pIgnore = undefined, exponent = 2) {

        /** @type {number} */
        let gx = 0
        /** @type {number} */
        let gy = 0

        //gothrough all planets in the universe
        for (let p of this.ps) {

            //ignore planet
            if (pIgnore && p == pIgnore)
                continue;

            //compute distance
            /** @type {number} */
            let d = p.dP(x, y);
            if (d === 0)
                continue;

            //compute and add contribution
            d = d * Math.pow(d, exponent);
            gx += 0.01 * (p.x - x) * p.m / d;
            gy += 0.01 * (p.y - y) * p.m / d;
        }
        return { gx: gx, gy: gy }
    }


    /**
     * Aggregate two planets
     * 
     * @param {Planet} p1
     * @param {Planet} p2
     * @param {SpatialIndex.<Planet>} sindex
     * @returns {Planet}
     */
    aggregate(p1, p2, sindex) {
        const m = p1.m + p2.m;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](
            this,
            m,
            (p1.x * p1.m + p2.x * p2.m) / m,
            (p1.y * p1.m + p2.y * p2.m) / m,
            (p1.sx * p1.m + p2.sx * p2.m) / m,
            (p1.sy * p1.m + p2.sy * p2.m) / m
        );
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p1);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p2);

        if (sindex) {
            sindex.remove(p1)
            sindex.remove(p2)
            sindex.insert(p)
        }

        return p;
    }



    /**
     * @param {SpatialIndex.<Planet>} sindex
     * @param {number} collisionFactor
     * @returns {Array.<Planet>}
     */
    findCollision(sindex, collisionFactor = 1) {
        for (let pi of this.ps) {

            const w = 2 * pi.r();
            const cand = sindex.get(pi.x - w, pi.y - w, pi.x + w, pi.y + w);

            for (let pj of cand) {

                if (pi == pj) continue;

                /** @type {number} */
                const d1 = pi.d(pj);
                /** @type {number} */
                const d2 = (pi.r() + pj.r()) * collisionFactor;
                if (d1 > d2)
                    continue;
                return [pi, pj];

            }
        }
        return null;
    }


    /**
     * Add planets with random speed
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed
     * @param {number} maxSpeed
     * @returns {this}
     */
    addPlanets(nb = 1, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        for (let i = 0; i < nb; i++) {
            const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, mi, this.w * Math.random(), this.h * Math.random());
            p.setRandomSpeed(minSpeed, maxSpeed);
        }
        return this;
    }



    /**
     * 
     * @param {boolean} bounce 
     * @param {number} vmax 
     * @param {number} exponent 
     * @param {number} collisionFactor 
     * @param {number} timeStepMs 
     * @returns {this}
     */
    step(bounce = false, vmax = 0.8, exponent = 2, collisionFactor = 1, timeStepMs = 10) {

        //observation
        for (let p of this.ps)
            p.observe(exponent);

        //action
        for (let p of this.ps)
            p.change(bounce, vmax, timeStepMs);


        //collision detection
        this.detectCollisions(collisionFactor)

        return this;
    }

    /**
     * @param {number} collisionFactor 
     * @returns {this}
     */
    detectCollisions(collisionFactor = 1) {

        /** @type {SpatialIndex.<Planet>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.ps)

        //find first collision
        /** @type {Array.<Planet>} */
        let pair = this.findCollision(sindex, collisionFactor);
        while (pair !== null) {

            //aggregate
            const p = this.aggregate(pair[0], pair[1], sindex)

            //find next collision
            pair = this.findCollision(sindex, collisionFactor);
        }

        return this;
    }


    /**
     * Assign random speed to all planets
     * 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        for (let p of this.ps)
            p.setRandomSpeed(minSpeed, maxSpeed)
        return this
    }

    /**
     * @returns {Planet} The largest planet of the universe, usually the star.
     */
    getLargestPlanet() {
        let pM = null, mM = 0;
        for (let p of this.ps)
            if (p.m > mM) { pM = p; mM = p.m }
        return pM
    }

    /**
     * Get largest planet and explode it.
     */
    explodeLargestPlanet() {
        const p = this.getLargestPlanet()
        this.explode(p)
    }

    /**
     * Explode a planet into pieces
     * 
     * @param {Planet} p 
     * @param {number} nb 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     */
    explode(p, nb = -1, minSpeed = 0.8, maxSpeed = 1.5, rad = -1) {
        if (nb <= 0) nb = Math.floor(p.m);
        if (nb <= 0) return;
        const angleStep = 2 * Math.PI / nb;
        for (let i = 0; i < nb; i++) {
            //create planet

            //position
            if (rad < 0) rad = 2 * p.r()
            const d = rad * Math.random();
            const a = i * angleStep;
            const x = d * Math.cos(a), y = d * Math.sin(a);

            //speed
            const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
            const aS = a + 2 * (Math.random() - 0.5) * 2 * Math.PI / 3;
            const sx = speed * Math.cos(aS), sy = speed * Math.sin(aS);

            new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, p.m / nb, p.x + x, p.y + y, p.sx + sx, p.sy + sy)
        }
        //remove p from universe
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p);
    }

}


/***/ }),

/***/ "./src/planets/index.js":
/*!******************************!*\
  !*** ./src/planets/index.js ***!
  \******************************/
/*! exports provided: planets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return planets; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/**  */
class PlanetSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {number} */
        this.maxSpeed = opts.maxSpeed || 0.8;
        /** @type {boolean} */
        this.bounce = opts.bounce || false
        /** @type {number} */
        this.exponent = opts.exponent || 2;
        /** @type {number} */
        this.collisionFactor = opts.collisionFactor || 1;

        /** @type {boolean} */
        this.showPlanetAcceleration = false

        /** @type {string|undefined} */
        this.showField = undefined
        /** @type {number} */
        this.fieldRes = 20
        /** @type {number} */
        this.fieldFactor = 1000
        /** @type {string} */
        this.fieldStrokeStyle = "#99bbff";

        /** @type {number} */
        this.tailings = opts.tailings || 0.1;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear, with transparency
            c2.fillStyle = "rgba(0,0,0," + th.tailings + ")";
            c2.fillRect(0, 0, th.w, th.h);
            //c2.fillRect(-1e20, -1e20, 2e20, 2e20); //todo

            //display gravity field
            if (th.showField === "f")
                th.displayGravityField(this, true)
            else if (th.showField === "i")
                th.displayGravityField(this, false)


            this.setCanvasTransform()

            //display planets
            for (let p of th.uni.ps) {
                if (!this.toDraw(p)) continue
                const t = p.m / th.uni.m();
                p.display(this, "rgb(255,255," + Math.floor(255 * (1 - t)) + ")")
            }

            //display planets acceleration
            if (th.showPlanetAcceleration) {
                for (let p of th.uni.ps) {
                    if (!this.toDraw(p)) continue
                    p.displayAcceleration(this)
                }
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Universe} */
        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_0__["Universe"](this.w, this.h)
    }


    /**
     * @param {GeoCanvas} cp 
     * @param {boolean} field 
     */
    displayGravityField(cp, field = true) {
        const c2 = cp.ctx
        const res = this.fieldRes
        const f = this.fieldFactor
        const f_ = field ? 0.3 * res : 0.6 * res;
        c2.strokeStyle = this.fieldStrokeStyle
        for (let x = res * 0.5; x < this.w; x += res) {
            const xG = cp.pixToGeoX(x);
            if (xG > this.uni.w || xG < 0) continue
            for (let y = res / 2; y < this.h; y += res) {
                const yG = cp.pixToGeoY(y);
                if (yG > this.uni.h || yG < 0) continue
                //get gravity field
                const g = this.uni.getGravityField(xG, yG, undefined, this.exponent);
                const g_ = Math.hypot(g.gx, g.gy)

                c2.lineWidth = Math.min(f * g_, 0.3 * res);
                const dx = f_ * g.gx / g_, dy = f_ * g.gy / g_

                //draw
                c2.beginPath();
                if (field) {
                    //gravity field
                    c2.moveTo(x - dx, y + dy);
                    c2.lineTo(x + dx, y - dy);
                } else {
                    //isopotential lines
                    c2.moveTo(x + dy, y + dx);
                    c2.lineTo(x - dy, y - dx);
                }
                c2.closePath();
                c2.stroke();
            }
        }
    }


    /**
     * Initialise with random planets
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    initRandom(nb = 1000, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        this.uni.addPlanets(nb, mi, minSpeed, maxSpeed);
        return this;
    }

    /**
     * Initialise with big bang setup
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     * @returns {this}
     */
    initBigBang(nb = 1000, mi = 1, minSpeed = 0.35, maxSpeed = 0.7, rad = 100) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        //create big planet in the middle
        const cx = this.w * 0.5, cy = this.h * 0.5;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_1__["Planet"](this.uni, nb * mi, cx, cy, 0, 0);
        //explode it
        this.uni.explode(p, nb, minSpeed, maxSpeed, rad)
        return this;
    }

    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.uni.step(t.bounce, t.maxSpeed, t.exponent, t.collisionFactor, timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const planets = function (opts) {
    return new PlanetSimulation(opts)
}


/***/ }),

/***/ "./src/pp/Animal.js":
/*!**************************!*\
  !*** ./src/pp/Animal.js ***!
  \**************************/
/*! exports provided: Animal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animal", function() { return Animal; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




/** */
class Animal extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {number} type 
     * @param {Land} l 
     * @param {number} x 
     * @param {number} y 
     */
    constructor(type, l, x = 0, y = 0) {

        super(x, y)

        /** @type {number} */
        this.type = type;
        /** @type {Land} */
        this.l = l;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > l.w ? l.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > l.h ? l.h : y

        //the other animals around
        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        //add to the spatial index
        l.grid.insert(this);
    }


    /**
     * @param {*} timeStepMs 
     */
    move(timeStepMs = 10) {
        const l = this.l
        l.grid.remove(this);

        const angle = Math.random() * 2 * Math.PI;
        const r = 0.01 * Math.random();

        this.sx += r * Math.cos(angle) * timeStepMs;
        this.sx = this.sx > l.V_MAX ? l.V_MAX : this.sx < -l.V_MAX ? -l.V_MAX : this.sx

        this.sy += r * Math.sin(angle) * timeStepMs;
        this.sy = this.sy > l.V_MAX ? l.V_MAX : this.sy < -l.V_MAX ? -l.V_MAX : this.sy

        this.x += this.sx * timeStepMs;
        this.x = this.x < 0 ? l.w : this.x > l.w ? 0 : this.x

        this.y += this.sy * timeStepMs;
        this.y = this.y < 0 ? l.h : this.y > l.h ? 0 : this.y

        l.grid.insert(this);
    }


    /** Observe */
    observe() {
        const l = this.l

        //get animals around
        const as = l.grid.get(this.x - l.d, this.y - l.d, this.x + l.d, this.y + l.d);

        this.preys = [];
        this.predators = [];

        for (let a of as) {
            if (a == this) continue;
            if (this.d(a) > l.d) continue;
            if (a.type == 0)
                this.preys.push(a);
            else
                this.predators.push(a);
        }
    }

    /** @returns {Animal} */
    makeChild() {
        //do better: make child around
        return new Animal(this.type, this.l, this.x, this.y);
    }



    /**
     * Display animal
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} size 
     */
    display(cp, fillStyle = "blue", size = 2) {
        cp.ctx.fillStyle = fillStyle;
        cp.ctx.fillRect(this.x, this.y, size, size);
        /*c2.beginPath();
        c2.arc(a.x, a.y, 0.5, 0, 2*Math.PI);
        c2.closePath();
        c2.fill();*/
    }

}


/***/ }),

/***/ "./src/pp/Land.js":
/*!************************!*\
  !*** ./src/pp/Land.js ***!
  \************************/
/*! exports provided: Land */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Land", function() { return Land; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
//@ts-check




class Land {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */
    constructor(w, h) {

        //the max speed
        /** @type {number} */
        this.V_MAX = 0.1

        /** @type {number} */
        this.p = 0.02 //predator death probability
        /** @type {number} */
        this.q = 0.1 //prey reproduction probability
        /** @type {number} */
        this.r = 0.5 //eaten prey transformation probability
        /** @type {number} */
        this.nb = 3 //neighbors number

        /** @type {number} */
        this.w = w
        /** @type {number} */
        this.h = h

        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        /** @type {number} */
        this.d = 10
        /** @type {SpatialIndex.<Animal>} */
        this.grid = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /*int[][] histo;
        int index=0;
        this.c2Chart=c2Chart;
        this.hChart=hChart;
        this.histo=new int[wChart][];
        for(int i=0;i<wChart;i++)
            histo[i]=new int[]{0,0};*/

    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //observe
        for (let a of this.preys) a.observe();
        for (let a of this.predators) a.observe();

        const preysToBorn = []
        const preysToDie = []
        const predsToBorn = []
        const predsToDie = []

        //prey
        for (let prey of this.preys) {
            //reproduction if no predator around
            if (Math.random() > this.q) continue;
            if (prey.predators.length != 0) continue;
            if (prey.preys.length >= this.nb) continue;
            preysToBorn.push(prey.makeChild());
        }

        //predator
        for (let pred of this.predators) {
            //no prey around: predator dies with probability p
            if (pred.preys.length == 0) {
                if (Math.random() < this.p) predsToDie.push(pred);
            }
            //prey around
            else {
                //eat prey
                //choose randomly
                const preyToEat = pred.preys[Math.floor(pred.preys.length * Math.random())];
                preysToDie.push(preyToEat);

                //predator reproduction
                if (Math.random() > this.r) continue;
                if (pred.predators.length >= this.nb) continue;
                predsToBorn.push(pred.makeChild());
            }
        }

        this.preys.push(...preysToBorn);
        this.predators.push(...predsToBorn);

        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.preys, preysToDie, false)
        for (let a of preysToDie) this.grid.remove(a);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.predators, predsToDie, false)
        for (let a of predsToDie) this.grid.remove(a);

        //move
        for (let a of this.preys)
            a.move(timeStepMs);
        for (let a of this.predators)
            a.move(timeStepMs);

        /*/histo
        histo[index] = new int[]{ preys.size(), predators.size() };
        if (index == histo.length - 1) index = 0;
        else index++;*/

    }
}


/***/ }),

/***/ "./src/pp/index.js":
/*!*************************!*\
  !*** ./src/pp/index.js ***!
  \*************************/
/*! exports provided: preyPredator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return preyPredator; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/** */
class PreyPredatorSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);


        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //transparency
            this.initCanvasTransform()
            c2.fillStyle = "rgba(255,255,255,0.5)";
            c2.fillRect(0, 0, th.w, th.h);

            //display animals
            this.setCanvasTransform()
            for (let a of th.land.preys)
                if (this.toDraw(a))
                    a.display(this, "blue");
            for (let a of th.land.predators)
                if (this.toDraw(a))
                    a.display(this, "red");

            /*/label
            c2.fillStyle = "lightgray";
            c2.fillRect(0, 0, 65, 13);
            c2.fillStyle = "black";
            c2.fillText(preys.length + "/" + predators.length, 2, 10);*/

            //chart
            //c2Chart.setFillStyle(backColor2);
            //c2Chart.fillRect(0, 0, w, h);

            //double max = getMaxHisto();
            /*public int getMaxHisto() {
                int max=0;
                for(int i=0;i<histo.length;i++){
                    if(histo[i][0]>max) max=histo[i][0];
                    if(histo[i][1]>max) max=histo[i][1];
                }
                return max;
            }*/
            /*
                        if (max != 0) {
                            double h1, h2;
                            for (int i = 0; i < histo.length; i++) {
                                h1 = hChart * histo[i][0] / max;
                                h2 = hChart * histo[i][1] / max;
                                c2Chart.setFillStyle(preyColor2);
                                c2Chart.fillRect(i, hChart - h1, 1, h1);
                                c2Chart.setFillStyle(predatorColor2);
                                c2Chart.fillRect(i, hChart - h2, 1, h2);
                            }
                        }
                        c2Chart.setFillStyle(CssColor.make(255, 255, 255));
                        c2Chart.fillRect(index, 0, 1, hChart);
            */

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };


        /** @type {Land} */
        this.land = new _Land__WEBPACK_IMPORTED_MODULE_0__["Land"](this.w, this.h)

    }



    //TODO test init in a bubble ?
    //TODO use density as input parameters instead of nb

    /**
     * 
     * @param {number} preyDensity 
     * @param {number} predatorDensity 
     * @returns {this}
     */
    initRandom(preyDensity = 0.003, predatorDensity = 0.003) {
        const l = this.land
        for (let i = 0; i < preyDensity * l.w * l.h; i++)
            l.preys.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](0, l, l.w * Math.random(), l.h * Math.random())
            );
        for (let i = 0; i < predatorDensity * l.w * l.h; i++)
            l.predators.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](1, l, l.w * Math.random(), l.h * Math.random())
            );
        return this;
    }


    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.land.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

}


/**
 * @param {Object} opts 
 */
const preyPredator = function (opts) {
    return new PreyPredatorSimulation(opts)
}


/***/ }),

/***/ "./src/urban/Building.js":
/*!*******************************!*\
  !*** ./src/urban/Building.js ***!
  \*******************************/
/*! exports provided: Building */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Building", function() { return Building; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check



class Building {

    /**
     * @constructor
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} area The area
     */
    constructor(x, y, area) {

        //set position
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.area = area
    }

    /**
     * @returns { number }
     */
    r() {
        return Math.sqrt(this.area / Math.PI)
    }

    /**
     * @param {Building} b 
     */
    overlap(b) {
        const d1 = b.r() + this.r()
        const d2 = Math.hypot((b.x - this.x), (b.y - this.y));
        return d2 < d1
    }



    /**
     * @param {SpatialIndex.<Building>} sindex 
     * @param {number} sDistance 
     * @returns {boolean}
     */
    checkCollision(sindex, sDistance) {

        //get buildings around using spatial index
        /** @type {Array.<Building>} */
        const ss = sindex.get(this.x - sDistance, this.y - sDistance, this.x + sDistance, this.y + sDistance);

        for (let b of ss) {
            if (b == this) continue;
            if (this.overlap(b)) return true
        }
        return false;
    }




    /**
     * Display
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     */
    display(cp, fillStyle, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
        c2.stroke();
    }


}


/***/ }),

/***/ "./src/urban/Map.js":
/*!**************************!*\
  !*** ./src/urban/Map.js ***!
  \**************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Building__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Building */ "./src/urban/Building.js");
/* harmony import */ var _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RoadNetwork */ "./src/urban/RoadNetwork.js");
//@ts-check




class Map {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Building>} */
        this.bs = [];
        /** @type {SpatialIndex.<Building>} */
        this.buIndex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /** @type {RoadNetwork} */
        this.rn = new _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__["RoadNetwork"](this);

    }

    /** */
    addBuilding() {

        //compute candidate location, size and type for next building
        //TODO low local congestion AND go to high density (with good access to other stuff)

        //make random building
        const makeRandomBuilding = () => {
            const x = this.w * Math.random();
            const y = this.h * Math.random();
            const area = 40 + 200 * Math.random()
            return new _Building__WEBPACK_IMPORTED_MODULE_1__["Building"](x, y, area)
        }

        //TODO should not overlap with other entities (roads, building)

        /** @type {number} */
        const sDistance = 100;
        /** @type {Building} */
        let bu = makeRandomBuilding();
        while (bu.checkCollision(this.buIndex, sDistance)) {
            bu = makeRandomBuilding();
        }

        //add building
        this.bs.push(bu);
        this.buIndex.load([bu])
    }

    /**
     * @returns {this}
     */
    step() {

        //compute building need
        const buNeed = 10;

        //urbanise
        for (let i = 0; i < buNeed; i++) {
            this.addBuilding();
        }

        //extend road network
        //TODO

        return this;
    }

}


/***/ }),

/***/ "./src/urban/Road.js":
/*!***************************!*\
  !*** ./src/urban/Road.js ***!
  \***************************/
/*! exports provided: Road */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Road", function() { return Road; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check


class Road {

    /**
     * 
     * @param {object} geom 
     * @param {number} width 
     */
    constructor(geom, width) {

        this.geom = geom
        /** @type {number} */
        this.width = width

    }


    /**
     * Display
     * 
     * @param {GeoCanvas} cp 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     */
    display(cp, strokeStyle, lineWidth) {
        const cs = this.geom.getCoordinates();
        if (cs.length == 0) return;

        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;

        //move to first point
        let c = cs[0]
        c2.moveTo(c.x, c.y);

        //trace line
        c2.beginPath();
        for (let i = 1; i < cs.length; i++) {
            c = cs[i]
            c2.lineTo(c.x, c.y);
        }
        c2.stroke();

    }

}


/***/ }),

/***/ "./src/urban/RoadNetwork.js":
/*!**********************************!*\
  !*** ./src/urban/RoadNetwork.js ***!
  \**********************************/
/*! exports provided: RoadNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoadNetwork", function() { return RoadNetwork; });
/* harmony import */ var _Road__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Road */ "./src/urban/Road.js");
/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map */ "./src/urban/Map.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jsts__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check





class RoadNetwork {

    /**
     * @param {Map} map 
     */
    constructor(map) {

        /** @type {Map} */
        this.map = map

        /** @type {Array.<Road>} */
        this.sections = []


        //add test road
        //https://github.com/bjornharrtell/jsts
        //http://bjornharrtell.github.io/jsts/
        var reader = new jsts__WEBPACK_IMPORTED_MODULE_2___default.a.io.WKTReader()
        var g = reader.read('LINESTRING (30 10, 10 300, 400 400)')
        this.sections.push(new _Road__WEBPACK_IMPORTED_MODULE_0__["Road"](g, 7));
    }

    buildRandom() {

        const w = this.map.w
        const h = this.map.h

        //const r = 2 * w + 2 * h * Math.random();



    }

    /**
     * Display
     * @param {GeoCanvas} cp 
     */
    display(cp) {
        for (let r of this.sections)
            r.display(cp, "black", r.width);
        for (let r of this.sections)
            r.display(cp, "yellow", r.width - 3);
    }
}


/***/ }),

/***/ "./src/urban/index.js":
/*!****************************!*\
  !*** ./src/urban/index.js ***!
  \****************************/
/*! exports provided: urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return urban; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map */ "./src/urban/Map.js");
//@ts-check



/**  */
class UrbanSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //display road network
            th.map.rn.display(this);

            //display buildings
            for (let b of th.map.bs) {
                if (!this.toDraw(b)) continue
                b.display(this, "lightgray", "black", 2)
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Map} */
        this.map = new _Map__WEBPACK_IMPORTED_MODULE_1__["Map"](this.w, this.h)
    }


    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.map.step();
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const urban = function (opts) {
    return new UrbanSimulation(opts)
}


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZWN0YWcvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3ZlY3RhZy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY3ViZWhlbGl4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2RyYWcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9iYWNrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9ib3VuY2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2V4cC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcG9seS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvc2luLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kaXNjcmV0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hjbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hzbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2h1ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbGFiLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JvdW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRvci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9sb2NhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tYXRjaGVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlcnMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2xvd2VyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZXMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvd2luZG93LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW50ZXJydXB0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0clR3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2RlbGF5LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZVZhcnlpbmcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2NoZWR1bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3R3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2pzdHMvZGlzdC9qc3RzLm1pbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvcmJ1c2gvcmJ1c2gubWluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL0FnZW50UG9pbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Jhc2UvR2VvQ2FudmFzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL1NwYXRpYWxJbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvYmFzZS9saWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Zpc2gvU2FyZGluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9maXNoL1NlYS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZmlzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL0NlbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2dvbC9Vbml2ZXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcGxhbmV0cy9QbGFuZXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvVW5pdmVyc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BwL0FuaW1hbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvTGFuZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL0J1aWxkaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9NYXAuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWROZXR3b3JrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDOztBQUVwQzs7QUFFQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBTSxXQUFXLHlEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FB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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUM3UEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ2tDO0FBQ2tCO0FBQ047O0FBRTlDO0FBQ087O0FBRVA7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7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QVU7QUFDN0IseUJBQXlCLHlEQUFTO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLElBQUk7QUFDdkIsdUJBQXVCLHdDQUFHO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ087QUFDUDtBQUNBIiwiZmlsZSI6InZlY3RhZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInZlY3RhZ1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJ2ZWN0YWdcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiYnVpbGQvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2xvcigpIHt9XG5cbmV4cG9ydCB2YXIgZGFya2VyID0gMC43O1xuZXhwb3J0IHZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4ID0gL14jKFswLTlhLWZdezMsOH0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlSSwgcmVJLCByZUldICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlUCwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVJLCByZUksIHJlSSwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlUCwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xhXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIik7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGNvcHk6IGZ1bmN0aW9uKGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHRoaXMuY29uc3RydWN0b3IsIHRoaXMsIGNoYW5uZWxzKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogY29sb3JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IGNvbG9yX2Zvcm1hdEhleCxcbiAgZm9ybWF0SHNsOiBjb2xvcl9mb3JtYXRIc2wsXG4gIGZvcm1hdFJnYjogY29sb3JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogY29sb3JfZm9ybWF0UmdiXG59KTtcblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SHNsKCkge1xuICByZXR1cm4gaHNsQ29udmVydCh0aGlzKS5mb3JtYXRIc2woKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0UmdiKCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRSZ2IoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtLCBsO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4LmV4ZWMoZm9ybWF0KSkgPyAobCA9IG1bMV0ubGVuZ3RoLCBtID0gcGFyc2VJbnQobVsxXSwgMTYpLCBsID09PSA2ID8gcmdibihtKSAvLyAjZmYwMDAwXG4gICAgICA6IGwgPT09IDMgPyBuZXcgUmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpIC8vICNmMDBcbiAgICAgIDogbCA9PT0gOCA/IHJnYmEobSA+PiAyNCAmIDB4ZmYsIG0gPj4gMTYgJiAweGZmLCBtID4+IDggJiAweGZmLCAobSAmIDB4ZmYpIC8gMHhmZikgLy8gI2ZmMDAwMDAwXG4gICAgICA6IGwgPT09IDQgPyByZ2JhKChtID4+IDEyICYgMHhmKSB8IChtID4+IDggJiAweGYwKSwgKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKCgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZikpIC8gMHhmZikgLy8gI2YwMDBcbiAgICAgIDogbnVsbCkgLy8gaW52YWxpZCBoZXhcbiAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcbiAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgMSkgLy8gcmdiKDEwMCUsIDAlLCAwJSlcbiAgICAgIDogKG0gPSByZVJnYmFJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pIC8vIHJnYmEoMjU1LCAwLCAwLCAxKVxuICAgICAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcbiAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgMSkgLy8gaHNsKDEyMCwgNTAlLCA1MCUpXG4gICAgICA6IChtID0gcmVIc2xhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCBtWzRdKSAvLyBoc2xhKDEyMCwgNTAlLCA1MCUsIDEpXG4gICAgICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICA6IGZvcm1hdCA9PT0gXCJ0cmFuc3BhcmVudFwiID8gbmV3IFJnYihOYU4sIE5hTiwgTmFOLCAwKVxuICAgICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiByZ2JuKG4pIHtcbiAgcmV0dXJuIG5ldyBSZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmLCAxKTtcbn1cblxuZnVuY3Rpb24gcmdiYShyLCBnLCBiLCBhKSB7XG4gIGlmIChhIDw9IDApIHIgPSBnID0gYiA9IE5hTjtcbiAgcmV0dXJuIG5ldyBSZ2IociwgZywgYiwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5yID0gK3I7XG4gIHRoaXMuZyA9ICtnO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShSZ2IsIHJnYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKC0wLjUgPD0gdGhpcy5yICYmIHRoaXMuciA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmcgJiYgdGhpcy5nIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuYiAmJiB0aGlzLmIgPCAyNTUuNSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgaGV4OiByZ2JfZm9ybWF0SGV4LCAvLyBEZXByZWNhdGVkISBVc2UgY29sb3IuZm9ybWF0SGV4LlxuICBmb3JtYXRIZXg6IHJnYl9mb3JtYXRIZXgsXG4gIGZvcm1hdFJnYjogcmdiX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IHJnYl9mb3JtYXRSZ2Jcbn0pKTtcblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIFwiI1wiICsgaGV4KHRoaXMucikgKyBoZXgodGhpcy5nKSArIGhleCh0aGlzLmIpO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0UmdiKCkge1xuICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgcmV0dXJuIChhID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCIpXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLnIpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5nKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuYikgfHwgMCkpXG4gICAgICArIChhID09PSAxID8gXCIpXCIgOiBcIiwgXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodmFsdWUpIHx8IDApKTtcbiAgcmV0dXJuICh2YWx1ZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIHZhbHVlLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gaHNsYShoLCBzLCBsLCBhKSB7XG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcbiAgZWxzZSBpZiAobCA8PSAwIHx8IGwgPj0gMSkgaCA9IHMgPSBOYU47XG4gIGVsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBmb3JtYXRIc2w6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICAgIHJldHVybiAoYSA9PT0gMSA/IFwiaHNsKFwiIDogXCJoc2xhKFwiKVxuICAgICAgICArICh0aGlzLmggfHwgMCkgKyBcIiwgXCJcbiAgICAgICAgKyAodGhpcy5zIHx8IDApICogMTAwICsgXCIlLCBcIlxuICAgICAgICArICh0aGlzLmwgfHwgMCkgKiAxMDAgKyBcIiVcIlxuICAgICAgICArIChhID09PSAxID8gXCIpXCIgOiBcIiwgXCIgKyBhICsgXCIpXCIpO1xuICB9XG59KSk7XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdiLCBkYXJrZXIsIGJyaWdodGVyfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWdyZWVzLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbnZhciBBID0gLTAuMTQ4NjEsXG4gICAgQiA9ICsxLjc4Mjc3LFxuICAgIEMgPSAtMC4yOTIyNyxcbiAgICBEID0gLTAuOTA2NDksXG4gICAgRSA9ICsxLjk3Mjk0LFxuICAgIEVEID0gRSAqIEQsXG4gICAgRUIgPSBFICogQixcbiAgICBCQ19EQSA9IEIgKiBDIC0gRCAqIEE7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEN1YmVoZWxpeCkgcmV0dXJuIG5ldyBDdWJlaGVsaXgoby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbCA9IChCQ19EQSAqIGIgKyBFRCAqIHIgLSBFQiAqIGcpIC8gKEJDX0RBICsgRUQgLSBFQiksXG4gICAgICBibCA9IGIgLSBsLFxuICAgICAgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBELFxuICAgICAgcyA9IE1hdGguc3FydChrICogayArIGJsICogYmwpIC8gKEUgKiBsICogKDEgLSBsKSksIC8vIE5hTiBpZiBsPTAgb3IgbD0xXG4gICAgICBoID0gcyA/IE1hdGguYXRhbjIoaywgYmwpICogZGVncmVlcyAtIDEyMCA6IE5hTjtcbiAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCA8IDAgPyBoICsgMzYwIDogaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjdWJlaGVsaXhDb252ZXJ0KGgpIDogbmV3IEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEN1YmVoZWxpeCwgY3ViZWhlbGl4LCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gaXNOYU4odGhpcy5oKSA/IDAgOiAodGhpcy5oICsgMTIwKSAqIHJhZGlhbnMsXG4gICAgICAgIGwgPSArdGhpcy5sLFxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcbiAgICAgICAgY29zaCA9IE1hdGguY29zKGgpLFxuICAgICAgICBzaW5oID0gTWF0aC5zaW4oaCk7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICAyNTUgKiAobCArIGEgKiAoQSAqIGNvc2ggKyBCICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEMgKiBjb3NoICsgRCAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG4gIHJldHVybiBwcm90b3R5cGU7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgY29sb3IsIHJnYiwgaHNsfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGxhYiwgaGNsLCBsY2gsIGdyYXl9IGZyb20gXCIuL2xhYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1YmVoZWxpeH0gZnJvbSBcIi4vY3ViZWhlbGl4LmpzXCI7XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcbmltcG9ydCB7Q29sb3IsIHJnYkNvbnZlcnQsIFJnYn0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmltcG9ydCB7ZGVncmVlcywgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG4vLyBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL2xhYi1hbmQtcmdiXG5jb25zdCBLID0gMTgsXG4gICAgWG4gPSAwLjk2NDIyLFxuICAgIFluID0gMSxcbiAgICBabiA9IDAuODI1MjEsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIGhjbDJsYWIobyk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSByZ2IybHJnYihvLnIpLFxuICAgICAgZyA9IHJnYjJscmdiKG8uZyksXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIyMjUwNDUgKiByICsgMC43MTY4Nzg2ICogZyArIDAuMDYwNjE2OSAqIGIpIC8gWW4pLCB4LCB6O1xuICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB4ID0geiA9IHk7IGVsc2Uge1xuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xuICAgIHogPSB4eXoybGFiKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZyArIDAuNzE0MTczMyAqIGIpIC8gWm4pO1xuICB9XG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXkobCwgb3BhY2l0eSkge1xuICByZXR1cm4gbmV3IExhYihsLCAwLCAwLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwIDwgby5sICYmIG8ubCA8IDEwMCA/IDAgOiBOYU4sIG8ubCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBNYXRoLmF0YW4yKG8uYiwgby5hKSAqIGRlZ3JlZXM7XG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmZ1bmN0aW9uIGhjbDJsYWIobykge1xuICBpZiAoaXNOYU4oby5oKSkgcmV0dXJuIG5ldyBMYWIoby5sLCAwLCAwLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IG8uaCAqIHJhZGlhbnM7XG4gIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBoY2wybGFiKHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG4iLCJleHBvcnQgY29uc3QgcmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgY29uc3QgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogKCkgPT4ge319O1xuXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykgfHwgL1tcXHMuXS8udGVzdCh0KSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBkaXNwYXRjaH0gZnJvbSBcIi4vZGlzcGF0Y2guanNcIjtcbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtzZWxlY3QsIHBvaW50ZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2RyYWcsIHt5ZXNkcmFnfSBmcm9tIFwiLi9ub2RyYWcuanNcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9ucGFzc2l2ZSwgbm9ucGFzc2l2ZWNhcHR1cmUsIG5vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IERyYWdFdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoZXZlbnQpIHtcbiAgcmV0dXJuICFldmVudC5jdHJsS2V5ICYmICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGV2ZW50LCBkKSB7XG4gIHJldHVybiBkID09IG51bGwgPyB7eDogZXZlbnQueCwgeTogZXZlbnQueX0gOiBkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBjb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IGRlZmF1bHRTdWJqZWN0LFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIGdlc3R1cmVzID0ge30sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImVuZFwiKSxcbiAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICBtb3VzZWRvd254LFxuICAgICAgbW91c2Vkb3dueSxcbiAgICAgIG1vdXNlbW92aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZCwgbm9ucGFzc2l2ZSlcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKGV2ZW50LCBkKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuY2FsbCh0aGlzLCBldmVudCwgZCkpIHJldHVybjtcbiAgICB2YXIgZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KHRoaXMsIGNvbnRhaW5lci5jYWxsKHRoaXMsIGV2ZW50LCBkKSwgZXZlbnQsIGQsIFwibW91c2VcIik7XG4gICAgaWYgKCFnZXN0dXJlKSByZXR1cm47XG4gICAgc2VsZWN0KGV2ZW50LnZpZXcpXG4gICAgICAub24oXCJtb3VzZW1vdmUuZHJhZ1wiLCBtb3VzZW1vdmVkLCBub25wYXNzaXZlY2FwdHVyZSlcbiAgICAgIC5vbihcIm1vdXNldXAuZHJhZ1wiLCBtb3VzZXVwcGVkLCBub25wYXNzaXZlY2FwdHVyZSk7XG4gICAgbm9kcmFnKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIG1vdXNlbW92aW5nID0gZmFsc2U7XG4gICAgbW91c2Vkb3dueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgbW91c2Vkb3dueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgZ2VzdHVyZShcInN0YXJ0XCIsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoZXZlbnQpIHtcbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XG4gICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0gbW91c2Vkb3dueCwgZHkgPSBldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNldXBwZWQoZXZlbnQpIHtcbiAgICBzZWxlY3QoZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIiwgbnVsbCk7XG4gICAgeWVzZHJhZyhldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZ2VzdHVyZXMubW91c2UoXCJlbmRcIiwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKGV2ZW50LCBkKSB7XG4gICAgaWYgKCFmaWx0ZXIuY2FsbCh0aGlzLCBldmVudCwgZCkpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmNhbGwodGhpcywgZXZlbnQsIGQpLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KHRoaXMsIGMsIGV2ZW50LCBkLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHRvdWNoZXNbaV0pKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBnZXN0dXJlKFwic3RhcnRcIiwgZXZlbnQsIHRvdWNoZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICAgIGdlc3R1cmUoXCJkcmFnXCIsIGV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKGV2ZW50KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBnZXN0dXJlKFwiZW5kXCIsIGV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVzdGFydCh0aGF0LCBjb250YWluZXIsIGV2ZW50LCBkLCBpZGVudGlmaWVyLCB0b3VjaCkge1xuICAgIHZhciBkaXNwYXRjaCA9IGxpc3RlbmVycy5jb3B5KCksXG4gICAgICAgIHAgPSBwb2ludGVyKHRvdWNoIHx8IGV2ZW50LCBjb250YWluZXIpLCBkeCwgZHksXG4gICAgICAgIHM7XG5cbiAgICBpZiAoKHMgPSBzdWJqZWN0LmNhbGwodGhhdCwgbmV3IERyYWdFdmVudChcImJlZm9yZXN0YXJ0XCIsIHtcbiAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgICB0YXJnZXQ6IGRyYWcsXG4gICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgeDogcFswXSxcbiAgICAgICAgeTogcFsxXSxcbiAgICAgICAgZHg6IDAsXG4gICAgICAgIGR5OiAwLFxuICAgICAgICBkaXNwYXRjaFxuICAgICAgfSksIGQpKSA9PSBudWxsKSByZXR1cm47XG5cbiAgICBkeCA9IHMueCAtIHBbMF0gfHwgMDtcbiAgICBkeSA9IHMueSAtIHBbMV0gfHwgMDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBnZXN0dXJlKHR5cGUsIGV2ZW50LCB0b3VjaCkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRlbnRpZmllcl0gPSBnZXN0dXJlLCBuID0gYWN0aXZlKys7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5kXCI6IGRlbGV0ZSBnZXN0dXJlc1tpZGVudGlmaWVyXSwgLS1hY3RpdmU7IC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSBcImRyYWdcIjogcCA9IHBvaW50ZXIodG91Y2ggfHwgZXZlbnQsIGNvbnRhaW5lciksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2guY2FsbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhhdCxcbiAgICAgICAgbmV3IERyYWdFdmVudCh0eXBlLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHN1YmplY3Q6IHMsXG4gICAgICAgICAgdGFyZ2V0OiBkcmFnLFxuICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgYWN0aXZlOiBuLFxuICAgICAgICAgIHg6IHBbMF0gKyBkeCxcbiAgICAgICAgICB5OiBwWzFdICsgZHksXG4gICAgICAgICAgZHg6IHBbMF0gLSBwMFswXSxcbiAgICAgICAgICBkeTogcFsxXSAtIHAwWzFdLFxuICAgICAgICAgIGRpc3BhdGNoXG4gICAgICAgIH0pLFxuICAgICAgICBkXG4gICAgICApO1xuICAgIH07XG4gIH1cblxuICBkcmFnLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogZmlsdGVyO1xuICB9O1xuXG4gIGRyYWcuY29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogY29udGFpbmVyO1xuICB9O1xuXG4gIGRyYWcuc3ViamVjdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdWJqZWN0ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBzdWJqZWN0O1xuICB9O1xuXG4gIGRyYWcudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgZHJhZy5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBkcmFnIDogdmFsdWU7XG4gIH07XG5cbiAgZHJhZy5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCBkcmFnKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIGRyYWc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnRXZlbnQodHlwZSwge1xuICBzb3VyY2VFdmVudCxcbiAgc3ViamVjdCxcbiAgdGFyZ2V0LFxuICBpZGVudGlmaWVyLFxuICBhY3RpdmUsXG4gIHgsIHksIGR4LCBkeSxcbiAgZGlzcGF0Y2hcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHt2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzb3VyY2VFdmVudDoge3ZhbHVlOiBzb3VyY2VFdmVudCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzdWJqZWN0OiB7dmFsdWU6IHN1YmplY3QsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdGFyZ2V0OiB7dmFsdWU6IHRhcmdldCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBpZGVudGlmaWVyOiB7dmFsdWU6IGlkZW50aWZpZXIsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgYWN0aXZlOiB7dmFsdWU6IGFjdGl2ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB4OiB7dmFsdWU6IHgsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgeToge3ZhbHVlOiB5LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIGR4OiB7dmFsdWU6IGR4LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIGR5OiB7dmFsdWU6IGR5LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIF86IHt2YWx1ZTogZGlzcGF0Y2h9XG4gIH0pO1xufVxuXG5EcmFnRXZlbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IHRoaXMuXy5vbi5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gIHJldHVybiB2YWx1ZSA9PT0gdGhpcy5fID8gdGhpcyA6IHZhbHVlO1xufTtcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBkcmFnfSBmcm9tIFwiLi9kcmFnLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZHJhZ0Rpc2FibGUsIHllc2RyYWcgYXMgZHJhZ0VuYWJsZX0gZnJvbSBcIi4vbm9kcmFnLmpzXCI7XG4iLCJpbXBvcnQge3NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IG5vZXZlbnQsIHtub25wYXNzaXZlY2FwdHVyZX0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fX25vc2VsZWN0ID0gcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0O1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuIiwiLy8gVGhlc2UgYXJlIHR5cGljYWxseSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggbm9ldmVudCB0byBlbnN1cmUgdGhhdCB3ZSBjYW5cbi8vIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudC5cbmV4cG9ydCBjb25zdCBub25wYXNzaXZlID0ge3Bhc3NpdmU6IGZhbHNlfTtcbmV4cG9ydCBjb25zdCBub25wYXNzaXZlY2FwdHVyZSA9IHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZX07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsInZhciBvdmVyc2hvb3QgPSAxLjcwMTU4O1xuXG5leHBvcnQgdmFyIGJhY2tJbiA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja0luKHQpIHtcbiAgICByZXR1cm4gKHQgPSArdCkgKiB0ICogKHMgKiAodCAtIDEpICsgdCk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW47XG59KShvdmVyc2hvb3QpO1xuXG5leHBvcnQgdmFyIGJhY2tPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogKCh0ICsgMSkgKiBzICsgdCkgKyAxO1xuICB9XG5cbiAgYmFja091dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tPdXQ7XG59KShvdmVyc2hvb3QpO1xuXG5leHBvcnQgdmFyIGJhY2tJbk91dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDwgMSA/IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykgOiAodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpIC8gMjtcbiAgfVxuXG4gIGJhY2tJbk91dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tJbk91dDtcbn0pKG92ZXJzaG9vdCk7XG4iLCJ2YXIgYjEgPSA0IC8gMTEsXG4gICAgYjIgPSA2IC8gMTEsXG4gICAgYjMgPSA4IC8gMTEsXG4gICAgYjQgPSAzIC8gNCxcbiAgICBiNSA9IDkgLyAxMSxcbiAgICBiNiA9IDEwIC8gMTEsXG4gICAgYjcgPSAxNSAvIDE2LFxuICAgIGI4ID0gMjEgLyAyMixcbiAgICBiOSA9IDYzIC8gNjQsXG4gICAgYjAgPSAxIC8gYjEgLyBiMTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcbiAgcmV0dXJuIDEgLSBib3VuY2VPdXQoMSAtIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gYm91bmNlT3V0KDEgLSB0KSA6IGJvdW5jZU91dCh0IC0gMSkgKyAxKSAvIDI7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY2lyY2xlSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KSA6IE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpIC8gMjtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufVxuIiwiaW1wb3J0IHt0cG10fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbnZhciB0YXUgPSAyICogTWF0aC5QSSxcbiAgICBhbXBsaXR1ZGUgPSAxLFxuICAgIHBlcmlvZCA9IDAuMztcblxuZXhwb3J0IHZhciBlbGFzdGljSW4gPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gYSAqIHRwbXQoLSgtLXQpKSAqIE1hdGguc2luKChzIC0gdCkgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNJbi5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbi5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbjtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxuZXhwb3J0IHZhciBlbGFzdGljT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAxIC0gYSAqIHRwbXQodCA9ICt0KSAqIE1hdGguc2luKCh0ICsgcykgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNPdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljT3V0LnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY091dDtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxuZXhwb3J0IHZhciBlbGFzdGljSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ID0gdCAqIDIgLSAxKSA8IDBcbiAgICAgICAgPyBhICogdHBtdCgtdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcClcbiAgICAgICAgOiAyIC0gYSAqIHRwbXQodCkgKiBNYXRoLnNpbigocyArIHQpIC8gcCkpIC8gMjtcbiAgfVxuXG4gIGVsYXN0aWNJbk91dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbk91dC5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbk91dDtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcbiIsImltcG9ydCB7dHBtdH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwSW4odCkge1xuICByZXR1cm4gdHBtdCgxIC0gK3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwT3V0KHQpIHtcbiAgcmV0dXJuIDEgLSB0cG10KHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0cG10KDEgLSB0KSA6IDIgLSB0cG10KHQgLSAxKSkgLyAyO1xufVxuIiwiZXhwb3J0IHtcbiAgbGluZWFyIGFzIGVhc2VMaW5lYXJcbn0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5cbmV4cG9ydCB7XG4gIHF1YWRJbk91dCBhcyBlYXNlUXVhZCxcbiAgcXVhZEluIGFzIGVhc2VRdWFkSW4sXG4gIHF1YWRPdXQgYXMgZWFzZVF1YWRPdXQsXG4gIHF1YWRJbk91dCBhcyBlYXNlUXVhZEluT3V0XG59IGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IHtcbiAgY3ViaWNJbk91dCBhcyBlYXNlQ3ViaWMsXG4gIGN1YmljSW4gYXMgZWFzZUN1YmljSW4sXG4gIGN1YmljT3V0IGFzIGVhc2VDdWJpY091dCxcbiAgY3ViaWNJbk91dCBhcyBlYXNlQ3ViaWNJbk91dFxufSBmcm9tIFwiLi9jdWJpYy5qc1wiO1xuXG5leHBvcnQge1xuICBwb2x5SW5PdXQgYXMgZWFzZVBvbHksXG4gIHBvbHlJbiBhcyBlYXNlUG9seUluLFxuICBwb2x5T3V0IGFzIGVhc2VQb2x5T3V0LFxuICBwb2x5SW5PdXQgYXMgZWFzZVBvbHlJbk91dFxufSBmcm9tIFwiLi9wb2x5LmpzXCI7XG5cbmV4cG9ydCB7XG4gIHNpbkluT3V0IGFzIGVhc2VTaW4sXG4gIHNpbkluIGFzIGVhc2VTaW5JbixcbiAgc2luT3V0IGFzIGVhc2VTaW5PdXQsXG4gIHNpbkluT3V0IGFzIGVhc2VTaW5Jbk91dFxufSBmcm9tIFwiLi9zaW4uanNcIjtcblxuZXhwb3J0IHtcbiAgZXhwSW5PdXQgYXMgZWFzZUV4cCxcbiAgZXhwSW4gYXMgZWFzZUV4cEluLFxuICBleHBPdXQgYXMgZWFzZUV4cE91dCxcbiAgZXhwSW5PdXQgYXMgZWFzZUV4cEluT3V0XG59IGZyb20gXCIuL2V4cC5qc1wiO1xuXG5leHBvcnQge1xuICBjaXJjbGVJbk91dCBhcyBlYXNlQ2lyY2xlLFxuICBjaXJjbGVJbiBhcyBlYXNlQ2lyY2xlSW4sXG4gIGNpcmNsZU91dCBhcyBlYXNlQ2lyY2xlT3V0LFxuICBjaXJjbGVJbk91dCBhcyBlYXNlQ2lyY2xlSW5PdXRcbn0gZnJvbSBcIi4vY2lyY2xlLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGJvdW5jZU91dCBhcyBlYXNlQm91bmNlLFxuICBib3VuY2VJbiBhcyBlYXNlQm91bmNlSW4sXG4gIGJvdW5jZU91dCBhcyBlYXNlQm91bmNlT3V0LFxuICBib3VuY2VJbk91dCBhcyBlYXNlQm91bmNlSW5PdXRcbn0gZnJvbSBcIi4vYm91bmNlLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGJhY2tJbk91dCBhcyBlYXNlQmFjayxcbiAgYmFja0luIGFzIGVhc2VCYWNrSW4sXG4gIGJhY2tPdXQgYXMgZWFzZUJhY2tPdXQsXG4gIGJhY2tJbk91dCBhcyBlYXNlQmFja0luT3V0XG59IGZyb20gXCIuL2JhY2suanNcIjtcblxuZXhwb3J0IHtcbiAgZWxhc3RpY091dCBhcyBlYXNlRWxhc3RpYyxcbiAgZWxhc3RpY0luIGFzIGVhc2VFbGFzdGljSW4sXG4gIGVsYXN0aWNPdXQgYXMgZWFzZUVsYXN0aWNPdXQsXG4gIGVsYXN0aWNJbk91dCBhcyBlYXNlRWxhc3RpY0luT3V0XG59IGZyb20gXCIuL2VsYXN0aWMuanNcIjtcbiIsImV4cG9ydCBjb25zdCBsaW5lYXIgPSB0ID0+ICt0O1xuIiwiLy8gdHBtdCBpcyB0d28gcG93ZXIgbWludXMgdGVuIHRpbWVzIHQgc2NhbGVkIHRvIFswLDFdXG5leHBvcnQgZnVuY3Rpb24gdHBtdCh4KSB7XG4gIHJldHVybiAoTWF0aC5wb3coMiwgLTEwICogeCkgLSAwLjAwMDk3NjU2MjUpICogMS4wMDA5Nzc1MTcxMDY1NDk0O1xufVxuIiwidmFyIGV4cG9uZW50ID0gMztcblxuZXhwb3J0IHZhciBwb2x5SW4gPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICB9XG5cbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW47XG59KShleHBvbmVudCk7XG5cbmV4cG9ydCB2YXIgcG9seU91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seU91dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgZSk7XG4gIH1cblxuICBwb2x5T3V0LmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5T3V0O1xufSkoZXhwb25lbnQpO1xuXG5leHBvcnQgdmFyIHBvbHlJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdyh0LCBlKSA6IDIgLSBNYXRoLnBvdygyIC0gdCwgZSkpIC8gMjtcbiAgfVxuXG4gIHBvbHlJbk91dC5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seUluT3V0O1xufSkoZXhwb25lbnQpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbih0KSB7XG4gIHJldHVybiB0ICogdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICByZXR1cm4gdCAqICgyIC0gdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCA6IC0tdCAqICgyIC0gdCkgKyAxKSAvIDI7XG59XG4iLCJ2YXIgcGkgPSBNYXRoLlBJLFxuICAgIGhhbGZQaSA9IHBpIC8gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuICgrdCA9PT0gMSkgPyAxIDogMSAtIE1hdGguY29zKHQgKiBoYWxmUGkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc2luKHQgKiBoYWxmUGkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luSW5PdXQodCkge1xuICByZXR1cm4gKDEgLSBNYXRoLmNvcyhwaSAqIHQpKSAvIDI7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIChpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXkgOiBnZW5lcmljQXJyYXkpKGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJpY0FycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYSksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxuICAgICAgICB2MSA9IHZhbHVlc1tpXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbaSArIDFdLFxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxuICAgICAgICB2MyA9IGkgPCBuIC0gMSA/IHZhbHVlc1tpICsgMl0gOiAyICogdjIgLSB2MTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jhc2lzfSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIHQgKiBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XG4gIHJldHVybiBhID0gTWF0aC5wb3coYSwgeSksIGIgPSBNYXRoLnBvdyhiLCB5KSAtIGEsIHkgPSAxIC8geSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhhICsgdCAqIGIsIHkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVlKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImltcG9ydCB7Y3ViZWhlbGl4IGFzIGNvbG9yQ3ViZWhlbGl4fSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gY3ViZWhlbGl4KGh1ZSkge1xuICByZXR1cm4gKGZ1bmN0aW9uIGN1YmVoZWxpeEdhbW1hKHkpIHtcbiAgICB5ID0gK3k7XG5cbiAgICBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JDdWJlaGVsaXgoc3RhcnQpKS5oLCAoZW5kID0gY29sb3JDdWJlaGVsaXgoZW5kKSkuaCksXG4gICAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcbiAgICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGN1YmVoZWxpeC5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xuXG4gICAgcmV0dXJuIGN1YmVoZWxpeDtcbiAgfSkoMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1YmVoZWxpeChodWUpO1xuZXhwb3J0IHZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4KGNvbG9yKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICogKDEgLSB0KSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG4iLCJpbXBvcnQge2hjbCBhcyBjb2xvckhjbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhjbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhjbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhjbChlbmQpKS5oKSxcbiAgICAgICAgYyA9IGNvbG9yKHN0YXJ0LmMsIGVuZC5jKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5jID0gYyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGNsKGh1ZSk7XG5leHBvcnQgdmFyIGhjbExvbmcgPSBoY2woY29sb3IpO1xuIiwiaW1wb3J0IHtoc2wgYXMgY29sb3JIc2x9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBoc2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JIc2woc3RhcnQpKS5oLCAoZW5kID0gY29sb3JIc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBjb2xvcihzdGFydC5zLCBlbmQucyksXG4gICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhzbChodWUpO1xuZXhwb3J0IHZhciBoc2xMb25nID0gaHNsKGNvbG9yKTtcbiIsImltcG9ydCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0gaHVlKCthLCArYik7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHggPSBpKHQpO1xuICAgIHJldHVybiB4IC0gMzYwICogTWF0aC5mbG9vcih4IC8gMzYwKTtcbiAgfTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUFycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURhdGV9IGZyb20gXCIuL2RhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURpc2NyZXRlfSBmcm9tIFwiLi9kaXNjcmV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHVlfSBmcm9tIFwiLi9odWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlcn0gZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU9iamVjdH0gZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcIi4vcm91bmQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5leHBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzLCBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2Z30gZnJvbSBcIi4vdHJhbnNmb3JtL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVab29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSZ2IsIHJnYkJhc2lzIGFzIGludGVycG9sYXRlUmdiQmFzaXMsIHJnYkJhc2lzQ2xvc2VkIGFzIGludGVycG9sYXRlUmdiQmFzaXNDbG9zZWR9IGZyb20gXCIuL3JnYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHNsLCBoc2xMb25nIGFzIGludGVycG9sYXRlSHNsTG9uZ30gZnJvbSBcIi4vaHNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVMYWJ9IGZyb20gXCIuL2xhYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSGNsLCBoY2xMb25nIGFzIGludGVycG9sYXRlSGNsTG9uZ30gZnJvbSBcIi4vaGNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXgsIGN1YmVoZWxpeExvbmcgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nfSBmcm9tIFwiLi9jdWJlaGVsaXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwaWVjZXdpc2V9IGZyb20gXCIuL3BpZWNld2lzZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHF1YW50aXplfSBmcm9tIFwiLi9xdWFudGl6ZS5qc1wiO1xuIiwiaW1wb3J0IHtsYWIgYXMgY29sb3JMYWJ9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yIGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gY29sb3IoKHN0YXJ0ID0gY29sb3JMYWIoc3RhcnQpKS5sLCAoZW5kID0gY29sb3JMYWIoZW5kKSkubCksXG4gICAgICBhID0gY29sb3Ioc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIGlmICghYikgYiA9IFtdO1xuICB2YXIgbiA9IGEgPyBNYXRoLm1pbihiLmxlbmd0aCwgYS5sZW5ndGgpIDogMCxcbiAgICAgIGMgPSBiLnNsaWNlKCksXG4gICAgICBpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNbaV0gPSBhW2ldICogKDEgLSB0KSArIGJbaV0gKiB0O1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJBcnJheSh4KSB7XG4gIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoeCkgJiYgISh4IGluc3RhbmNlb2YgRGF0YVZpZXcpO1xufVxuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSB2YWx1ZShhW2tdLCBiW2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1trXSA9IGJba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgdmFsdWV9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBpZWNld2lzZShpbnRlcnBvbGF0ZSwgdmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkgdmFsdWVzID0gaW50ZXJwb2xhdGUsIGludGVycG9sYXRlID0gdmFsdWU7XG4gIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGggLSAxLCB2ID0gdmFsdWVzWzBdLCBJID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIElbaV0gPSBpbnRlcnBvbGF0ZSh2LCB2ID0gdmFsdWVzWysraV0pO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqPSBuKSkpO1xuICAgIHJldHVybiBJW2ldKHQgLSBpKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVycG9sYXRvciwgbikge1xuICB2YXIgc2FtcGxlcyA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoaSAvIChuIC0gMSkpO1xuICByZXR1cm4gc2FtcGxlcztcbn1cbiIsImltcG9ydCB7cmdiIGFzIGNvbG9yUmdifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBiYXNpcyBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuaW1wb3J0IGJhc2lzQ2xvc2VkIGZyb20gXCIuL2Jhc2lzQ2xvc2VkLmpzXCI7XG5pbXBvcnQgbm9nYW1tYSwge2dhbW1hfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gcmdiR2FtbWEoeSkge1xuICB2YXIgY29sb3IgPSBnYW1tYSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gY29sb3JSZ2Ioc3RhcnQpKS5yLCAoZW5kID0gY29sb3JSZ2IoZW5kKSkuciksXG4gICAgICAgIGcgPSBjb2xvcihzdGFydC5nLCBlbmQuZyksXG4gICAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuciA9IHIodCk7XG4gICAgICBzdGFydC5nID0gZyh0KTtcbiAgICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICByZ2IuZ2FtbWEgPSByZ2JHYW1tYTtcblxuICByZXR1cm4gcmdiO1xufSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3I7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBjb2xvclJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvci5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IuciA9IHIodCk7XG4gICAgICBjb2xvci5nID0gZyh0KTtcbiAgICAgIGNvbG9yLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKGJhc2lzKTtcbmV4cG9ydCB2YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChhICogKDEgLSB0KSArIGIgKiB0KTtcbiAgfTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXG4gICAgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uZShiKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBiaSA9IHJlQS5sYXN0SW5kZXggPSByZUIubGFzdEluZGV4ID0gMCwgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYW0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICAgICAgYnMsIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gICAgICBpID0gLTEsIC8vIGluZGV4IGluIHNcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG5cbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcblxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuICB3aGlsZSAoKGFtID0gcmVBLmV4ZWMoYSkpXG4gICAgICAmJiAoYm0gPSByZUIuZXhlYyhiKSkpIHtcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHsgLy8gbnVtYmVycyBpbiBhICYgYiBtYXRjaFxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJtO1xuICAgIH0gZWxzZSB7IC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtpOiBpLCB4OiBudW1iZXIoYW0sIGJtKX0pO1xuICAgIH1cbiAgICBiaSA9IHJlQi5sYXN0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgcmVtYWlucyBvZiBiLlxuICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgZWxzZSBzWysraV0gPSBicztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgb3B0aW1pemF0aW9uIGZvciBvbmx5IGEgc2luZ2xlIG1hdGNoLlxuICAvLyBPdGhlcndpc2UsIGludGVycG9sYXRlIGVhY2ggb2YgdGhlIG51bWJlcnMgYW5kIHJlam9pbiB0aGUgc3RyaW5nLlxuICByZXR1cm4gcy5sZW5ndGggPCAyID8gKHFbMF1cbiAgICAgID8gb25lKHFbMF0ueClcbiAgICAgIDogemVybyhiKSlcbiAgICAgIDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG59XG4iLCJ2YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG5cbmV4cG9ydCB2YXIgaWRlbnRpdHkgPSB7XG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgc2tld1g6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBzY2FsZVgsIHNjYWxlWSwgc2tld1g7XG4gIGlmIChzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYikpIGEgLz0gc2NhbGVYLCBiIC89IHNjYWxlWDtcbiAgaWYgKHNrZXdYID0gYSAqIGMgKyBiICogZCkgYyAtPSBhICogc2tld1gsIGQgLT0gYiAqIHNrZXdYO1xuICBpZiAoc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpKSBjIC89IHNjYWxlWSwgZCAvPSBzY2FsZVksIHNrZXdYIC89IHNjYWxlWTtcbiAgaWYgKGEgKiBkIDwgYiAqIGMpIGEgPSAtYSwgYiA9IC1iLCBza2V3WCA9IC1za2V3WCwgc2NhbGVYID0gLXNjYWxlWDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBlLFxuICAgIHRyYW5zbGF0ZVk6IGYsXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKGIsIGEpICogZGVncmVlcyxcbiAgICBza2V3WDogTWF0aC5hdGFuKHNrZXdYKSAqIGRlZ3JlZXMsXG4gICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgc2NhbGVZOiBzY2FsZVlcbiAgfTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4uL251bWJlci5qc1wiO1xuaW1wb3J0IHtwYXJzZUNzcywgcGFyc2VTdmd9IGZyb20gXCIuL3BhcnNlLmpzXCI7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuXG4gIGZ1bmN0aW9uIHBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiIFwiIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiIHx8IHliKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB4YiArIHB4Q29tbWEgKyB5YiArIHB4UGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdGF0ZShhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIGlmIChhIC0gYiA+IDE4MCkgYiArPSAzNjA7IGVsc2UgaWYgKGIgLSBhID4gMTgwKSBhICs9IDM2MDsgLy8gc2hvcnRlc3QgcGF0aFxuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2V3WChhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiICE9PSAxIHx8IHliICE9PSAxKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiArIHhiICsgXCIsXCIgKyB5YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XG4gICAgdHJhbnNsYXRlKGEudHJhbnNsYXRlWCwgYS50cmFuc2xhdGVZLCBiLnRyYW5zbGF0ZVgsIGIudHJhbnNsYXRlWSwgcywgcSk7XG4gICAgcm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XG4gICAgc2NhbGUoYS5zY2FsZVgsIGEuc2NhbGVZLCBiLnNjYWxlWCwgYi5zY2FsZVksIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDsgLy8gZ2NcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlU3ZnLCBcIiwgXCIsIFwiKVwiLCBcIilcIik7XG4iLCJpbXBvcnQgZGVjb21wb3NlLCB7aWRlbnRpdHl9IGZyb20gXCIuL2RlY29tcG9zZS5qc1wiO1xuXG52YXIgc3ZnTm9kZTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBjb25zdCBtID0gbmV3ICh0eXBlb2YgRE9NTWF0cml4ID09PSBcImZ1bmN0aW9uXCIgPyBET01NYXRyaXggOiBXZWJLaXRDU1NNYXRyaXgpKHZhbHVlICsgXCJcIik7XG4gIHJldHVybiBtLmlzSWRlbnRpdHkgPyBpZGVudGl0eSA6IGRlY29tcG9zZShtLmEsIG0uYiwgbS5jLCBtLmQsIG0uZSwgbS5mKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3ZnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghc3ZnTm9kZSkgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdmFsdWUpO1xuICBpZiAoISh2YWx1ZSA9IHN2Z05vZGUudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkpIHJldHVybiBpZGVudGl0eTtcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XG4gIHJldHVybiBkZWNvbXBvc2UodmFsdWUuYSwgdmFsdWUuYiwgdmFsdWUuYywgdmFsdWUuZCwgdmFsdWUuZSwgdmFsdWUuZik7XG59XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCByZ2IgZnJvbSBcIi4vcmdiLmpzXCI7XG5pbXBvcnQge2dlbmVyaWNBcnJheX0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBkYXRlIGZyb20gXCIuL2RhdGUuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQgb2JqZWN0IGZyb20gXCIuL29iamVjdC5qc1wiO1xuaW1wb3J0IHN0cmluZyBmcm9tIFwiLi9zdHJpbmcuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IG51bWJlckFycmF5LCB7aXNOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgdCA9IHR5cGVvZiBiLCBjO1xuICByZXR1cm4gYiA9PSBudWxsIHx8IHQgPT09IFwiYm9vbGVhblwiID8gY29uc3RhbnQoYilcbiAgICAgIDogKHQgPT09IFwibnVtYmVyXCIgPyBudW1iZXJcbiAgICAgIDogdCA9PT0gXCJzdHJpbmdcIiA/ICgoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgcmdiKSA6IHN0cmluZylcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gcmdiXG4gICAgICA6IGIgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZVxuICAgICAgOiBpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXlcbiAgICAgIDogQXJyYXkuaXNBcnJheShiKSA/IGdlbmVyaWNBcnJheVxuICAgICAgOiB0eXBlb2YgYi52YWx1ZU9mICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIudG9TdHJpbmcgIT09IFwiZnVuY3Rpb25cIiB8fCBpc05hTihiKSA/IG9iamVjdFxuICAgICAgOiBudW1iZXIpKGEsIGIpO1xufVxuIiwidmFyIGVwc2lsb24yID0gMWUtMTI7XG5cbmZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiB6b29tUmhvKHJobywgcmhvMiwgcmhvNCkge1xuXG4gIC8vIHAwID0gW3V4MCwgdXkwLCB3MF1cbiAgLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxuICBmdW5jdGlvbiB6b29tKHAwLCBwMSkge1xuICAgIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sXG4gICAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgICAgZHggPSB1eDEgLSB1eDAsXG4gICAgICAgIGR5ID0gdXkxIC0gdXkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgICBpLFxuICAgICAgICBTO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gICAgaWYgKGQyIDwgZXBzaWxvbjIpIHtcbiAgICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdCAqIGR4LFxuICAgICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgICB3MCAqIE1hdGguZXhwKHJobyAqIHQgKiBTKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYWwgY2FzZS5cbiAgICBlbHNlIHtcbiAgICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksXG4gICAgICAgICAgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG80ICogZDIpIC8gKDIgKiB3MCAqIHJobzIgKiBkMSksXG4gICAgICAgICAgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG80ICogZDIpIC8gKDIgKiB3MSAqIHJobzIgKiBkMSksXG4gICAgICAgICAgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLFxuICAgICAgICAgIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICAgIFMgPSAocjEgLSByMCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcyA9IHQgKiBTLFxuICAgICAgICAgICAgY29zaHIwID0gY29zaChyMCksXG4gICAgICAgICAgICB1ID0gdzAgLyAocmhvMiAqIGQxKSAqIChjb3NocjAgKiB0YW5oKHJobyAqIHMgKyByMCkgLSBzaW5oKHIwKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdSAqIGR4LFxuICAgICAgICAgIHV5MCArIHUgKiBkeSxcbiAgICAgICAgICB3MCAqIGNvc2hyMCAvIGNvc2gocmhvICogcyArIHIwKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkuZHVyYXRpb24gPSBTICogMTAwMCAqIHJobyAvIE1hdGguU1FSVDI7XG5cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIHpvb20ucmhvID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBfMSA9IE1hdGgubWF4KDFlLTMsICtfKSwgXzIgPSBfMSAqIF8xLCBfNCA9IF8yICogXzI7XG4gICAgcmV0dXJuIHpvb21SaG8oXzEsIF8yLCBfNCk7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59KShNYXRoLlNRUlQyLCAyLCA0KTtcbiIsIi8vIEdpdmVuIHNvbWV0aGluZyBhcnJheSBsaWtlIChvciBudWxsKSwgcmV0dXJucyBzb21ldGhpbmcgdGhhdCBpcyBzdHJpY3RseSBhblxuLy8gYXJyYXkuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBhcnJheS1saWtlIG9iamVjdHMgcGFzc2VkIHRvIGQzLnNlbGVjdEFsbFxuLy8gb3Igc2VsZWN0aW9uLnNlbGVjdEFsbCBhcmUgY29udmVydGVkIGludG8gcHJvcGVyIGFycmF5cyB3aGVuIGNyZWF0aW5nIGFcbi8vIHNlbGVjdGlvbjsgd2UgZG9u4oCZdCBldmVyIHdhbnQgdG8gY3JlYXRlIGEgc2VsZWN0aW9uIGJhY2tlZCBieSBhIGxpdmVcbi8vIEhUTUxDb2xsZWN0aW9uIG9yIE5vZGVMaXN0LiBIb3dldmVyLCBub3RlIHRoYXQgc2VsZWN0aW9uLnNlbGVjdEFsbCB3aWxsIHVzZSBhXG4vLyBzdGF0aWMgTm9kZUxpc3QgYXMgYSBncm91cCwgc2luY2UgaXQgc2FmZWx5IGRlcml2ZWQgZnJvbSBxdWVyeVNlbGVjdG9yQWxsLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJyYXkoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gW10gOiBBcnJheS5pc0FycmF5KHgpID8geCA6IEFycmF5LmZyb20oeCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdChjcmVhdG9yKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuL25hbWVzcGFjZS5qc1wiO1xuaW1wb3J0IHt4aHRtbH0gZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICA/IGNyZWF0b3JGaXhlZFxuICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0ZX0gZnJvbSBcIi4vY3JlYXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3JlYXRvcn0gZnJvbSBcIi4vY3JlYXRvci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGxvY2FsfSBmcm9tIFwiLi9sb2NhbC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1hdGNoZXJ9IGZyb20gXCIuL21hdGNoZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2V9IGZyb20gXCIuL25hbWVzcGFjZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5hbWVzcGFjZXN9IGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwb2ludGVyfSBmcm9tIFwiLi9wb2ludGVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcG9pbnRlcnN9IGZyb20gXCIuL3BvaW50ZXJzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0fSBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RBbGx9IGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdGlvbn0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3J9IGZyb20gXCIuL3NlbGVjdG9yLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3JBbGx9IGZyb20gXCIuL3NlbGVjdG9yQWxsLmpzXCI7XG5leHBvcnQge3N0eWxlVmFsdWUgYXMgc3R5bGV9IGZyb20gXCIuL3NlbGVjdGlvbi9zdHlsZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHdpbmRvd30gZnJvbSBcIi4vd2luZG93LmpzXCI7XG4iLCJ2YXIgbmV4dElkID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9jYWwoKSB7XG4gIHJldHVybiBuZXcgTG9jYWw7XG59XG5cbmZ1bmN0aW9uIExvY2FsKCkge1xuICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xufVxuXG5Mb2NhbC5wcm90b3R5cGUgPSBsb2NhbC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMb2NhbCxcbiAgZ2V0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fO1xuICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgIHJldHVybiBub2RlW2lkXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiBub2RlW3RoaXMuX10gPSB2YWx1ZTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuXyBpbiBub2RlICYmIGRlbGV0ZSBub2RlW3RoaXMuX107XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRNYXRjaGVyKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbiIsImltcG9ydCBuYW1lc3BhY2VzIGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xuICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbn1cbiIsImV4cG9ydCB2YXIgeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCwgbm9kZSkge1xuICBldmVudCA9IHNvdXJjZUV2ZW50KGV2ZW50KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG4gICAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICAgIH1cbiAgICBpZiAobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV07XG59XG4iLCJpbXBvcnQgcG9pbnRlciBmcm9tIFwiLi9wb2ludGVyLmpzXCI7XG5pbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnRzLCBub2RlKSB7XG4gIGlmIChldmVudHMudGFyZ2V0KSB7IC8vIGkuZS4sIGluc3RhbmNlb2YgRXZlbnQsIG5vdCBUb3VjaExpc3Qgb3IgaXRlcmFibGVcbiAgICBldmVudHMgPSBzb3VyY2VFdmVudChldmVudHMpO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIG5vZGUgPSBldmVudHMuY3VycmVudFRhcmdldDtcbiAgICBldmVudHMgPSBldmVudHMudG91Y2hlcyB8fCBbZXZlbnRzXTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShldmVudHMsIGV2ZW50ID0+IHBvaW50ZXIoZXZlbnQsIG5vZGUpKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW2FycmF5KHNlbGVjdG9yKV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4uL25hbWVzcGFjZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59XG4iLCJmdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZShmYWxzZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgTWFwLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSArIFwiXCI7XG4gICAgICBpZiAobm9kZUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlKSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSkgKyBcIlwiO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlKSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWUuZGVsZXRlKGtleVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWVzW2ldKSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXR1bShub2RlKSB7XG4gIHJldHVybiBub2RlLl9fZGF0YV9fO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIEFycmF5LmZyb20odGhpcywgZGF0dW0pO1xuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IGFycmF5bGlrZSh2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cykpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gR2l2ZW4gc29tZSBkYXRhLCB0aGlzIHJldHVybnMgYW4gYXJyYXktbGlrZSB2aWV3IG9mIGl0OiBhbiBvYmplY3QgdGhhdFxuLy8gZXhwb3NlcyBhIGxlbmd0aCBwcm9wZXJ0eSBhbmQgYWxsb3dzIG51bWVyaWMgaW5kZXhpbmcuIE5vdGUgdGhhdCB1bmxpa2Vcbi8vIHNlbGVjdEFsbCwgdGhpcyBpc27igJl0IHdvcnJpZWQgYWJvdXQg4oCcbGl2ZeKAnSBjb2xsZWN0aW9ucyBiZWNhdXNlIHRoZSByZXN1bHRpbmdcbi8vIGFycmF5IHdpbGwgb25seSBiZSB1c2VkIGJyaWVmbHkgd2hpbGUgZGF0YSBpcyBiZWluZyBib3VuZC4gKEl0IGlzIHBvc3NpYmxlIHRvXG4vLyBjYXVzZSB0aGUgZGF0YSB0byBjaGFuZ2Ugd2hpbGUgaXRlcmF0aW5nIGJ5IHVzaW5nIGEga2V5IGZ1bmN0aW9uLCBidXQgcGxlYXNlXG4vLyBkb27igJl0OyB3ZeKAmWQgcmF0aGVyIGF2b2lkIGEgZ3JhdHVpdG91cyBjb3B5LilcbmZ1bmN0aW9uIGFycmF5bGlrZShkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGRhdGFcbiAgICA/IGRhdGEgLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKGRhdGEpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJmdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cbiIsImltcG9ydCBzZWxlY3Rpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkIGZyb20gXCIuL3NlbGVjdENoaWxkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuIGZyb20gXCIuL3NlbGVjdENoaWxkcmVuLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VudGVyIGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2V4aXQgZnJvbSBcIi4vZXhpdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9qb2luIGZyb20gXCIuL2pvaW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb3JkZXIgZnJvbSBcIi4vb3JkZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc29ydCBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NhbGwgZnJvbSBcIi4vY2FsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlcyBmcm9tIFwiLi9ub2Rlcy5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlIGZyb20gXCIuL25vZGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VtcHR5IGZyb20gXCIuL2VtcHR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VhY2ggZnJvbSBcIi4vZWFjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcHJvcGVydHkgZnJvbSBcIi4vcHJvcGVydHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xhc3NlZCBmcm9tIFwiLi9jbGFzc2VkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9odG1sIGZyb20gXCIuL2h0bWwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmFpc2UgZnJvbSBcIi4vcmFpc2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbG93ZXIgZnJvbSBcIi4vbG93ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXBwZW5kIGZyb20gXCIuL2FwcGVuZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnNlcnQgZnJvbSBcIi4vaW5zZXJ0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xvbmUgZnJvbSBcIi4vY2xvbmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0dW0gZnJvbSBcIi4vZGF0dW0uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGlzcGF0Y2ggZnJvbSBcIi4vZGlzcGF0Y2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3IuanNcIjtcblxuZXhwb3J0IHZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gIHNlbGVjdDogc2VsZWN0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiBzZWxlY3Rpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3NlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gIGRhdGE6IHNlbGVjdGlvbl9kYXRhLFxuICBlbnRlcjogc2VsZWN0aW9uX2VudGVyLFxuICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgam9pbjogc2VsZWN0aW9uX2pvaW4sXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogc2VsZWN0aW9uX3NlbGVjdGlvbixcbiAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gIGNhbGw6IHNlbGVjdGlvbl9jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3NpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICBhdHRyOiBzZWxlY3Rpb25fYXR0cixcbiAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgY2xhc3NlZDogc2VsZWN0aW9uX2NsYXNzZWQsXG4gIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgcmFpc2U6IHNlbGVjdGlvbl9yYWlzZSxcbiAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICBpbnNlcnQ6IHNlbGVjdGlvbl9pbnNlcnQsXG4gIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcbiAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgb246IHNlbGVjdGlvbl9vbixcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9pdGVyYXRvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VsZWN0aW9uO1xuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKigpIHtcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbmVudGVyLCBvbnVwZGF0ZSwgb25leGl0KSB7XG4gIHZhciBlbnRlciA9IHRoaXMuZW50ZXIoKSwgdXBkYXRlID0gdGhpcywgZXhpdCA9IHRoaXMuZXhpdCgpO1xuICBpZiAodHlwZW9mIG9uZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVudGVyID0gb25lbnRlcihlbnRlcik7XG4gICAgaWYgKGVudGVyKSBlbnRlciA9IGVudGVyLnNlbGVjdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGVudGVyID0gZW50ZXIuYXBwZW5kKG9uZW50ZXIgKyBcIlwiKTtcbiAgfVxuICBpZiAob251cGRhdGUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZSA9IG9udXBkYXRlKHVwZGF0ZSk7XG4gICAgaWYgKHVwZGF0ZSkgdXBkYXRlID0gdXBkYXRlLnNlbGVjdGlvbigpO1xuICB9XG4gIGlmIChvbmV4aXQgPT0gbnVsbCkgZXhpdC5yZW1vdmUoKTsgZWxzZSBvbmV4aXQoZXhpdCk7XG4gIHJldHVybiBlbnRlciAmJiB1cGRhdGUgPyBlbnRlci5tZXJnZSh1cGRhdGUpLm9yZGVyKCkgOiB1cGRhdGU7XG59XG4iLCJmdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQ7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG59XG4iLCJmdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCwgdGhpcy5fX2RhdGFfXyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIodmFsdWUpO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8ub3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBvcHRpb25zOiBvcHRpb25zfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBvcHRpb25zKSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgaWYgKG5leHQgJiYgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuZXh0KSBeIDQpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XG59XG4iLCJmdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi4vYXJyYXkuanNcIjtcbmltcG9ydCBzZWxlY3RvckFsbCBmcm9tIFwiLi4vc2VsZWN0b3JBbGwuanNcIjtcblxuZnVuY3Rpb24gYXJyYXlBbGwoc2VsZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJyYXkoc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgPT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gYXJyYXlBbGwoc2VsZWN0KTtcbiAgZWxzZSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQ7XG5cbmZ1bmN0aW9uIGNoaWxkRmluZChtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbmQuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoaWxkRmlyc3QoKSB7XG4gIHJldHVybiB0aGlzLmZpcnN0RWxlbWVudENoaWxkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QobWF0Y2ggPT0gbnVsbCA/IGNoaWxkRmlyc3RcbiAgICAgIDogY2hpbGRGaW5kKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5cbmZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5GaWx0ZXIobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdEFsbChtYXRjaCA9PSBudWxsID8gY2hpbGRyZW5cbiAgICAgIDogY2hpbGRyZW5GaWx0ZXIodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSArK3NpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG59XG4iLCJmdW5jdGlvbiBub25lKCkge31cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJmdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBsZXQgc291cmNlRXZlbnQ7XG4gIHdoaWxlIChzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50KSBldmVudCA9IHNvdXJjZUV2ZW50O1xuICByZXR1cm4gZXZlbnQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuIiwiZXhwb3J0IHtcbiAgbm93LFxuICB0aW1lcixcbiAgdGltZXJGbHVzaFxufSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHRpbWVvdXRcbn0gZnJvbSBcIi4vdGltZW91dC5qc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIGludGVydmFsXG59IGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG4iLCJpbXBvcnQge1RpbWVyLCBub3d9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lciwgdG90YWwgPSBkZWxheTtcbiAgaWYgKGRlbGF5ID09IG51bGwpIHJldHVybiB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSwgdDtcbiAgdC5fcmVzdGFydCA9IHQucmVzdGFydDtcbiAgdC5yZXN0YXJ0ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgZGVsYXkgPSArZGVsYXksIHRpbWUgPSB0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lO1xuICAgIHQuX3Jlc3RhcnQoZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgICAgdC5fcmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgICB9LCBkZWxheSwgdGltZSk7XG4gIH1cbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwiaW1wb3J0IHtUaW1lcn0gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZWxhcHNlZCA9PiB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsInZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwodW5kZWZpbmVkLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7U0NIRURVTEVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbnZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgaTtcblxuICBpZiAoc2NoZWR1bGVzKSB7XG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5zdGF0ZSA+IFNDSEVEVUxFRCAmJiBzY2hlZHVsZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYWN0aXZlfSBmcm9tIFwiLi9hY3RpdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnJ1cHR9IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuIiwiaW1wb3J0IHtTVEFSVElORywgRU5ESU5HLCBFTkRFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcblxuICBpZiAoIXNjaGVkdWxlcykgcmV0dXJuO1xuXG4gIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG5cbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLm5hbWUgIT09IG5hbWUpIHsgZW1wdHkgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBhY3RpdmUgPSBzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HICYmIHNjaGVkdWxlLnN0YXRlIDwgRU5ESU5HO1xuICAgIHNjaGVkdWxlLnN0YXRlID0gRU5ERUQ7XG4gICAgc2NoZWR1bGUudGltZXIuc3RvcCgpO1xuICAgIHNjaGVkdWxlLm9uLmNhbGwoYWN0aXZlID8gXCJpbnRlcnJ1cHRcIiA6IFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlLmluZGV4LCBzY2hlZHVsZS5ncm91cCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgfVxuXG4gIGlmIChlbXB0eSkgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBzZWxlY3Rpb25faW50ZXJydXB0IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcblxuc2VsZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBzZWxlY3Rpb25faW50ZXJydXB0O1xuc2VsZWN0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uID0gc2VsZWN0aW9uX3RyYW5zaXRpb247XG4iLCJpbXBvcnQgaW50ZXJydXB0IGZyb20gXCIuLi9pbnRlcnJ1cHQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlIGZyb20gXCIuLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge2Vhc2VDdWJpY0luT3V0fSBmcm9tIFwiZDMtZWFzZVwiO1xuaW1wb3J0IHtub3d9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGVhc2VDdWJpY0luT3V0XG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG4gIHdoaWxlICghKHRpbWluZyA9IG5vZGUuX190cmFuc2l0aW9uKSB8fCAhKHRpbWluZyA9IHRpbWluZ1tpZF0pKSB7XG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNpdGlvbiAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IG5vdygpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGksIGdyb3VwLCB0aW1pbmcgfHwgaW5oZXJpdChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pKGZ1bGxuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdmFsdWUgPT0gbnVsbCA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIGksIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlKG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJhdHRyLlwiICsgbmFtZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtnZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGRlbGF5RnVuY3Rpb25cbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGR1cmF0aW9uRnVuY3Rpb25cbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZVZhcnlpbmcoaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMuZWFjaChlYXNlVmFyeWluZyh0aGlzLl9pZCwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG9uMCwgb24xLCB0aGF0ID0gdGhpcywgaWQgPSB0aGF0Ll9pZCwgc2l6ZSA9IHRoYXQuc2l6ZSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGNhbmNlbCA9IHt2YWx1ZTogcmVqZWN0fSxcbiAgICAgICAgZW5kID0ge3ZhbHVlOiBmdW5jdGlvbigpIHsgaWYgKC0tc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpOyB9fTtcblxuICAgIHRoYXQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICAgIGlmIChvbiAhPT0gb24wKSB7XG4gICAgICAgIG9uMSA9IChvbjAgPSBvbikuY29weSgpO1xuICAgICAgICBvbjEuXy5jYW5jZWwucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5pbnRlcnJ1cHQucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5lbmQucHVzaChlbmQpO1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBzZWxlY3Rpb24gd2FzIGVtcHR5LCByZXNvbHZlIGVuZCBpbW1lZGlhdGVseVxuICAgIGlmIChzaXplID09PSAwKSByZXNvbHZlKCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHttYXRjaGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyVHdlZW4gZnJvbSBcIi4vYXR0clR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kZWxheSBmcm9tIFwiLi9kZWxheS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2UgZnJvbSBcIi4vZWFzZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcgZnJvbSBcIi4vZWFzZVZhcnlpbmcuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0aW9uIGZyb20gXCIuL3NlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gZnJvbSBcIi4vc3R5bGVUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0VHdlZW4gZnJvbSBcIi4vdGV4dFR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3R3ZWVuIGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lbmQgZnJvbSBcIi4vZW5kLmpzXCI7XG5cbnZhciBpZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0aW9uKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHRyYW5zaXRpb25fZmlsdGVyLFxuICBtZXJnZTogdHJhbnNpdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiB0cmFuc2l0aW9uX3NlbGVjdGlvbixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbl90cmFuc2l0aW9uLFxuICBjYWxsOiBzZWxlY3Rpb25fcHJvdG90eXBlLmNhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9wcm90b3R5cGUuZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9wcm90b3R5cGUuZWFjaCxcbiAgb246IHRyYW5zaXRpb25fb24sXG4gIGF0dHI6IHRyYW5zaXRpb25fYXR0cixcbiAgYXR0clR3ZWVuOiB0cmFuc2l0aW9uX2F0dHJUd2VlbixcbiAgc3R5bGU6IHRyYW5zaXRpb25fc3R5bGUsXG4gIHN0eWxlVHdlZW46IHRyYW5zaXRpb25fc3R5bGVUd2VlbixcbiAgdGV4dDogdHJhbnNpdGlvbl90ZXh0LFxuICB0ZXh0VHdlZW46IHRyYW5zaXRpb25fdGV4dFR3ZWVuLFxuICByZW1vdmU6IHRyYW5zaXRpb25fcmVtb3ZlLFxuICB0d2VlbjogdHJhbnNpdGlvbl90d2VlbixcbiAgZGVsYXk6IHRyYW5zaXRpb25fZGVsYXksXG4gIGR1cmF0aW9uOiB0cmFuc2l0aW9uX2R1cmF0aW9uLFxuICBlYXNlOiB0cmFuc2l0aW9uX2Vhc2UsXG4gIGVhc2VWYXJ5aW5nOiB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nLFxuICBlbmQ6IHRyYW5zaXRpb25fZW5kLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX3Byb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdXG59O1xuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQge2ludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVTdHJpbmd9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIGludGVycG9sYXRlUmdiKVxuICAgICAgOiBpbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgaWYgKHRyYW5zaXRpb24uX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSB0cmFuc2l0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcbiAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKS5ldmVyeShmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lciwgdGltZW91dH0gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbmV4cG9ydCB2YXIgQ1JFQVRFRCA9IDA7XG5leHBvcnQgdmFyIFNDSEVEVUxFRCA9IDE7XG5leHBvcnQgdmFyIFNUQVJUSU5HID0gMjtcbmV4cG9ydCB2YXIgU1RBUlRFRCA9IDM7XG5leHBvcnQgdmFyIFJVTk5JTkcgPSA0O1xuZXhwb3J0IHZhciBFTkRJTkcgPSA1O1xuZXhwb3J0IHZhciBFTkRFRCA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGVzKSBub2RlLl9fdHJhbnNpdGlvbiA9IHt9O1xuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBncm91cDogZ3JvdXAsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBvbjogZW1wdHlPbixcbiAgICB0d2VlbjogZW1wdHlUd2VlbixcbiAgICB0aW1lOiB0aW1pbmcudGltZSxcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxuICAgIGR1cmF0aW9uOiB0aW1pbmcuZHVyYXRpb24sXG4gICAgZWFzZTogdGltaW5nLmVhc2UsXG4gICAgdGltZXI6IG51bGwsXG4gICAgc3RhdGU6IENSRUFURURcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSB0aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobm9kZSwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHtzZWxlY3Rvcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3RvckFsbH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG52YXIgU2VsZWN0aW9uID0gc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c3R5bGV9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlTnVsbChuYW1lLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHN0cmluZzEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCBzdHJpbmcxMCA9IHN0cmluZzEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpLFxuICAgICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHN0cmluZzEgPSB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVNYXliZVJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgb24wLCBvbjEsIGxpc3RlbmVyMCwga2V5ID0gXCJzdHlsZS5cIiArIG5hbWUsIGV2ZW50ID0gXCJlbmQuXCIgKyBrZXksIHJlbW92ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub24sXG4gICAgICAgIGxpc3RlbmVyID0gc2NoZWR1bGUudmFsdWVba2V5XSA9PSBudWxsID8gcmVtb3ZlIHx8IChyZW1vdmUgPSBzdHlsZVJlbW92ZShuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjAgfHwgbGlzdGVuZXIwICE9PSBsaXN0ZW5lcikgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihldmVudCwgbGlzdGVuZXIwID0gbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZU51bGwobmFtZSwgaSkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZShuYW1lKSlcbiAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpKVxuICAgICAgLmVhY2goc3R5bGVNYXliZVJlbW92ZSh0aGlzLl9pZCwgbmFtZSkpXG4gICAgOiB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlKSwgcHJpb3JpdHkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBudWxsKTtcbn1cbiIsImZ1bmN0aW9uIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkuY2FsbCh0aGlzLCB0KSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgdCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQgPSAoaTAgPSBpKSAmJiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cbiIsImltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24odHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxuICAgICAgOiB0ZXh0Q29uc3RhbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCIpKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRJbnRlcnBvbGF0ZShpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGkuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgdGV4dEludGVycG9sYXRlKGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJ0ZXh0XCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCB0ZXh0VHdlZW4odmFsdWUpKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gdHdlZW5SZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9IHR3ZWVuMCA9IHR3ZWVuO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFpvb21FdmVudCh0eXBlLCB7XG4gIHNvdXJjZUV2ZW50LFxuICB0YXJnZXQsXG4gIHRyYW5zZm9ybSxcbiAgZGlzcGF0Y2hcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHt2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzb3VyY2VFdmVudDoge3ZhbHVlOiBzb3VyY2VFdmVudCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0YXJnZXQ6IHt2YWx1ZTogdGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRyYW5zZm9ybToge3ZhbHVlOiB0cmFuc2Zvcm0sIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgXzoge3ZhbHVlOiBkaXNwYXRjaH1cbiAgfSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgem9vbX0gZnJvbSBcIi4vem9vbS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHpvb21UcmFuc2Zvcm0sIGlkZW50aXR5IGFzIHpvb21JZGVudGl0eSwgVHJhbnNmb3JtIGFzIFpvb21UcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCk7XG5cbnRyYW5zZm9ybS5wcm90b3R5cGUgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX196b29tKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuIGlkZW50aXR5O1xuICByZXR1cm4gbm9kZS5fX3pvb207XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7ZHJhZ0Rpc2FibGUsIGRyYWdFbmFibGV9IGZyb20gXCJkMy1kcmFnXCI7XG5pbXBvcnQge2ludGVycG9sYXRlWm9vbX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3NlbGVjdCwgcG9pbnRlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtpbnRlcnJ1cHR9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBab29tRXZlbnQgZnJvbSBcIi4vZXZlbnQuanNcIjtcbmltcG9ydCB7VHJhbnNmb3JtLCBpZGVudGl0eX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG4vLyBleGNlcHQgZm9yIHBpbmNoLXRvLXpvb20sIHdoaWNoIGlzIHNlbnQgYXMgYSB3aGVlbCtjdHJsS2V5IGV2ZW50XG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICBpZiAoZS5oYXNBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpKSB7XG4gICAgICBlID0gZS52aWV3Qm94LmJhc2VWYWw7XG4gICAgICByZXR1cm4gW1tlLngsIGUueV0sIFtlLnggKyBlLndpZHRoLCBlLnkgKyBlLmhlaWdodF1dO1xuICAgIH1cbiAgICByZXR1cm4gW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbZS5jbGllbnRXaWR0aCwgZS5jbGllbnRIZWlnaHRdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YShldmVudCkge1xuICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIChldmVudC5jdHJsS2V5ID8gMTAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzBdLFxuICAgICAgZHgxID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzFdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVswXSxcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXG4gICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzFdO1xuICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZShcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgZHkxID4gZHkwID8gKGR5MCArIGR5MSkgLyAyIDogTWF0aC5taW4oMCwgZHkwKSB8fCBNYXRoLm1heCgwLCBkeTEpXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBjb25zdHJhaW4gPSBkZWZhdWx0Q29uc3RyYWluLFxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IFtbLUluZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIEluZmluaXR5XV0sXG4gICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVab29tLFxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hmaXJzdCxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgdG91Y2hEZWxheSA9IDUwMCxcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDAsXG4gICAgICB0YXBEaXN0YW5jZSA9IDEwO1xuXG4gIGZ1bmN0aW9uIHpvb20oc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKVxuICAgICAgICAub24oXCJ3aGVlbC56b29tXCIsIHdoZWVsZWQsIHtwYXNzaXZlOiBmYWxzZX0pXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlZG93bmVkKVxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuem9vbSB0b3VjaGNhbmNlbC56b29tXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICB6b29tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmludGVycnVwdCgpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGdlc3R1cmUodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIC5ldmVudChldmVudClcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC56b29tKG51bGwsIHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdHJhbnNmb3JtKVxuICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS5zY2FsZVRvKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gazAgKiBrMTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS5zY2FsZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwLFxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0aGlzLl9fem9vbS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB4LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeVxuICAgICAgKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgbnVsbCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcDtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHAwWzBdLCBwMFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyAteC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyAteS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXlcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgaykge1xuICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIGspKTtcbiAgICByZXR1cm4gayA9PT0gdHJhbnNmb3JtLmsgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKGssIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBwMCwgcDEpIHtcbiAgICB2YXIgeCA9IHAwWzBdIC0gcDFbMF0gKiB0cmFuc2Zvcm0uaywgeSA9IHAwWzFdIC0gcDFbMV0gKiB0cmFuc2Zvcm0uaztcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtLnggJiYgeSA9PT0gdHJhbnNmb3JtLnkgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybS5rLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGV4dGVudCkge1xuICAgIHJldHVybiBbKCtleHRlbnRbMF1bMF0gKyArZXh0ZW50WzFdWzBdKSAvIDIsICgrZXh0ZW50WzBdWzFdICsgK2V4dGVudFsxXVsxXSkgLyAyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLnN0YXJ0KCk7IH0pXG4gICAgICAgIC5vbihcImludGVycnVwdC56b29tIGVuZC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLmVuZCgpOyB9KVxuICAgICAgICAudHdlZW4oXCJ6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZyA9IGdlc3R1cmUodGhhdCwgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gcG9pbnQgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHBvaW50ID09PSBcImZ1bmN0aW9uXCIgPyBwb2ludC5hcHBseSh0aGF0LCBhcmdzKSA6IHBvaW50LFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX3pvb21pbmcpIHx8IG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB0aGlzLnNvdXJjZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB0aGlzLnRhcHMgPSAwO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgZXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHRoaXMuc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy50aGF0Ll9fem9vbWluZyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aGF0Ll9fem9vbWluZztcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgZCA9IHNlbGVjdCh0aGlzLnRoYXQpLmRhdHVtKCk7XG4gICAgICBsaXN0ZW5lcnMuY2FsbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy50aGF0LFxuICAgICAgICBuZXcgWm9vbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogdGhpcy5zb3VyY2VFdmVudCxcbiAgICAgICAgICB0YXJnZXQ6IHpvb20sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMudGhhdC5fX3pvb20sXG4gICAgICAgICAgZGlzcGF0Y2g6IGxpc3RlbmVyc1xuICAgICAgICB9KSxcbiAgICAgICAgZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gd2hlZWxlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQpO1xuXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSByZWNlbnQgd2hlZWwgZXZlbnRzLCByZXNldCB0aGUgd2hlZWwgaWRsZSB0aW1lb3V0LlxuICAgIGlmIChnLndoZWVsKSB7XG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XG4gICAgICAgIGcubW91c2VbMV0gPSB0LmludmVydChnLm1vdXNlWzBdID0gcCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXG4gICAgZWxzZSBpZiAodC5rID09PSBrKSByZXR1cm47XG5cbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXG4gICAgZWxzZSB7XG4gICAgICBnLm1vdXNlID0gW3AsIHQuaW52ZXJ0KHApXTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBnLndoZWVsID0gc2V0VGltZW91dCh3aGVlbGlkbGVkLCB3aGVlbERlbGF5KTtcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIHRydWUpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdiA9IHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksXG4gICAgICAgIHgwID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBldmVudC5jbGllbnRZO1xuXG4gICAgZHJhZ0Rpc2FibGUoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKGV2ZW50KSB7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuZXZlbnQoZXZlbnQpXG4gICAgICAgLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKGcudGhhdC5fX3pvb20sIGcubW91c2VbMF0gPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwcGVkKGV2ZW50KSB7XG4gICAgICB2Lm9uKFwibW91c2Vtb3ZlLnpvb20gbW91c2V1cC56b29tXCIsIG51bGwpO1xuICAgICAgZHJhZ0VuYWJsZShldmVudC52aWV3LCBnLm1vdmVkKTtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgZy5ldmVudChldmVudCkuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBwb2ludGVyKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCwgdGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGV2ZW50LnNoaWZ0S2V5ID8gMC41IDogMiksXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJncyksIHRyYW5zbGF0ZUV4dGVudCk7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHNjaGVkdWxlLCB0MSwgcDAsIGV2ZW50KTtcbiAgICBlbHNlIHNlbGVjdCh0aGlzKS5jYWxsKHpvb20udHJhbnNmb3JtLCB0MSwgcDAsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSBuKS5ldmVudChldmVudCksXG4gICAgICAgIHN0YXJ0ZWQsIGksIHQsIHA7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBwID0gW3AsIHRoaXMuX196b29tLmludmVydChwKSwgdC5pZGVudGlmaWVyXTtcbiAgICAgIGlmICghZy50b3VjaDApIGcudG91Y2gwID0gcCwgc3RhcnRlZCA9IHRydWUsIGcudGFwcyA9IDEgKyAhIXRvdWNoc3RhcnRpbmc7XG4gICAgICBlbHNlIGlmICghZy50b3VjaDEgJiYgZy50b3VjaDBbMl0gIT09IHBbMl0pIGcudG91Y2gxID0gcCwgZy50YXBzID0gMDtcbiAgICB9XG5cbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICBpZiAoZy50YXBzIDwgMikgdG91Y2hmaXJzdCA9IHBbMF0sIHRvdWNoc3RhcnRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaHN0YXJ0aW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdCwgcCwgbDtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMFswXSA9IHA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMVswXSA9IHA7XG4gICAgfVxuICAgIHQgPSBnLnRoYXQuX196b29tO1xuICAgIGlmIChnLnRvdWNoMSkge1xuICAgICAgdmFyIHAwID0gZy50b3VjaDBbMF0sIGwwID0gZy50b3VjaDBbMV0sXG4gICAgICAgICAgcDEgPSBnLnRvdWNoMVswXSwgbDEgPSBnLnRvdWNoMVsxXSxcbiAgICAgICAgICBkcCA9IChkcCA9IHAxWzBdIC0gcDBbMF0pICogZHAgKyAoZHAgPSBwMVsxXSAtIHAwWzFdKSAqIGRwLFxuICAgICAgICAgIGRsID0gKGRsID0gbDFbMF0gLSBsMFswXSkgKiBkbCArIChkbCA9IGwxWzFdIC0gbDBbMV0pICogZGw7XG4gICAgICB0ID0gc2NhbGUodCwgTWF0aC5zcXJ0KGRwIC8gZGwpKTtcbiAgICAgIHAgPSBbKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMl07XG4gICAgICBsID0gWyhsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChnLnRvdWNoMCkgcCA9IGcudG91Y2gwWzBdLCBsID0gZy50b3VjaDBbMV07XG4gICAgZWxzZSByZXR1cm47XG5cbiAgICBnLnpvb20oXCJ0b3VjaFwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHQsIHAsIGwpLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDE7XG4gICAgfVxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICBpZiAoZy50b3VjaDApIGcudG91Y2gwWzFdID0gdGhpcy5fX3pvb20uaW52ZXJ0KGcudG91Y2gwWzBdKTtcbiAgICBlbHNlIHtcbiAgICAgIGcuZW5kKCk7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhIGRibHRhcCwgcmVyb3V0ZSB0byB0aGUgKG9wdGlvbmFsKSBkYmxjbGljay56b29tIGhhbmRsZXIuXG4gICAgICBpZiAoZy50YXBzID09PSAyKSB7XG4gICAgICAgIHQgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgICBpZiAoTWF0aC5oeXBvdCh0b3VjaGZpcnN0WzBdIC0gdFswXSwgdG91Y2hmaXJzdFsxXSAtIHRbMV0pIDwgdGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICB2YXIgcCA9IHNlbGVjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIik7XG4gICAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHpvb20ud2hlZWxEZWx0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3aGVlbERlbHRhID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHpvb20pIDogd2hlZWxEZWx0YTtcbiAgfTtcblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgem9vbS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSksIHpvb20pIDogZXh0ZW50O1xuICB9O1xuXG4gIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGVFeHRlbnRbMF1bMF0gPSArX1swXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzBdID0gK19bMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXSA9ICtfWzBdWzFdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV0gPSArX1sxXVsxXSwgem9vbSkgOiBbW3RyYW5zbGF0ZUV4dGVudFswXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdXSwgW3RyYW5zbGF0ZUV4dGVudFsxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdXV07XG4gIH07XG5cbiAgem9vbS5jb25zdHJhaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uc3RyYWluID0gXywgem9vbSkgOiBjb25zdHJhaW47XG4gIH07XG5cbiAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xuICB9O1xuXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCB6b29tKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHpvb20ub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xuICB9O1xuXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgem9vbSkgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHpvb20udGFwRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFwRGlzdGFuY2UgPSArXywgem9vbSkgOiB0YXBEaXN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn1cbiIsIi8qKlxuICogSlNUUy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FREx2MS50eHRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRV9FUEx2MS50eHRcbiAqIEBsaWNlbnNlXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUoKHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5qc3RzPXt9KX0odGhpcywoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgZXtzdGF0aWMgZXF1YWxzV2l0aFRvbGVyYW5jZSh0LGUsbil7cmV0dXJuIE1hdGguYWJzKHQtZSk8PW59fWNsYXNzIG4gZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0V4Y2VwdGlvbjpufSlbMF19dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5tZXNzYWdlfX1jbGFzcyBzIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjpzfSlbMF19fWNsYXNzIGl7Y29uc3RydWN0b3IodCxlKXt0aGlzLmxvdz1lfHwwLHRoaXMuaGlnaD10fHwwfXN0YXRpYyB0b0JpbmFyeVN0cmluZyh0KXtsZXQgZSxuPVwiXCI7Zm9yKGU9MjE0NzQ4MzY0ODtlPjA7ZT4+Pj0xKW4rPSh0LmhpZ2gmZSk9PT1lP1wiMVwiOlwiMFwiO2ZvcihlPTIxNDc0ODM2NDg7ZT4wO2U+Pj49MSluKz0odC5sb3cmZSk9PT1lP1wiMVwiOlwiMFwiO3JldHVybiBufX1mdW5jdGlvbiByKCl7fWZ1bmN0aW9uIG8oKXt9ZnVuY3Rpb24gbCgpe31mdW5jdGlvbiBhKCl7fWZ1bmN0aW9uIGMoKXt9ci5OYU49TmFOLHIuaXNOYU49dD0+TnVtYmVyLmlzTmFOKHQpLHIuaXNJbmZpbml0ZT10PT4hTnVtYmVyLmlzRmluaXRlKHQpLHIuTUFYX1ZBTFVFPU51bWJlci5NQVhfVkFMVUUsXCJmdW5jdGlvblwiPT10eXBlb2YgRmxvYXQ2NEFycmF5JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBJbnQzMkFycmF5P2Z1bmN0aW9uKCl7Y29uc3QgdD0yMTQ2NDM1MDcyLGU9bmV3IEZsb2F0NjRBcnJheSgxKSxuPW5ldyBJbnQzMkFycmF5KGUuYnVmZmVyKTtyLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24ocyl7ZVswXT1zO2xldCByPTB8blswXSxvPTB8blsxXTtyZXR1cm4obyZ0KT09PXQmJjAhPSgxMDQ4NTc1Jm8pJiYwIT09ciYmKHI9MCxvPTIxNDY5NTkzNjApLG5ldyBpKG8scil9LHIubG9uZ0JpdHNUb0RvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gblswXT10LmxvdyxuWzFdPXQuaGlnaCxlWzBdfX0oKTpmdW5jdGlvbigpe2NvbnN0IHQ9MTAyMyxlPU1hdGgubG9nMixuPU1hdGguZmxvb3Iscz1NYXRoLnBvdyxvPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTUzO3Q+MDt0LS0pe2NvbnN0IGk9cygyLHQpLTE7aWYobihlKGkpKSsxPT09dClyZXR1cm4gaX1yZXR1cm4gMH0oKTtyLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24ocil7bGV0IGwsYSxjLGgsdSxnLGQsXyxwO2lmKHI8MHx8MS9yPT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPyhnPTE8PDMxLHI9LXIpOmc9MCwwPT09cilyZXR1cm4gcD0wLF89ZyxuZXcgaShfLHApO2lmKHI9PT0xLzApcmV0dXJuIHA9MCxfPTIxNDY0MzUwNzJ8ZyxuZXcgaShfLHApO2lmKHIhPXIpcmV0dXJuIHA9MCxfPTIxNDY5NTkzNjAsbmV3IGkoXyxwKTtpZihoPTAscD0wLGw9bihyKSxsPjEpaWYobDw9byloPW4oZShsKSksaDw9MjA/KHA9MCxfPWw8PDIwLWgmMTA0ODU3NSk6KGM9aC0yMCxhPXMoMixjKSxwPWwlYTw8MzItYyxfPWwvYSYxMDQ4NTc1KTtlbHNlIGZvcihjPWwscD0wO2E9Yy8yLGM9bihhKSwwIT09YzspaCsrLHA+Pj49MSxwfD0oMSZfKTw8MzEsXz4+Pj0xLGEhPT1jJiYoX3w9NTI0Mjg4KTtpZihkPWgrdCx1PTA9PT1sLGw9ci1sLGg8NTImJjAhPT1sKWZvcihjPTA7Oyl7aWYoYT0yKmwsYT49MT8obD1hLTEsdT8oZC0tLHU9ITEpOihjPDw9MSxjfD0xLGgrKykpOihsPWEsdT8wPT0tLWQmJihoKyssdT0hMSk6KGM8PD0xLGgrKykpLDIwPT09aClffD1jLGM9MDtlbHNlIGlmKDUyPT09aCl7cHw9YzticmVha31pZigxPT09YSl7aDwyMD9ffD1jPDwyMC1oOmg8NTImJihwfD1jPDw1Mi1oKTticmVha319cmV0dXJuIF98PWQ8PDIwLF98PWcsbmV3IGkoXyxwKX0sci5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKGUpe2xldCBuLGkscixvO2NvbnN0IGw9ZS5oaWdoLGE9ZS5sb3csYz1sJjE8PDMxPy0xOjE7Zm9yKHI9KCgyMTQ2NDM1MDcyJmwpPj4yMCktdCxvPTAsaT0xPDwxOSxuPTE7bjw9MjA7bisrKWwmaSYmKG8rPXMoMiwtbikpLGk+Pj49MTtmb3IoaT0xPDwzMSxuPTIxO248PTUyO24rKylhJmkmJihvKz1zKDIsLW4pKSxpPj4+PTE7aWYoLTEwMjM9PT1yKXtpZigwPT09bylyZXR1cm4gMCpjO3I9LTEwMjJ9ZWxzZXtpZigxMDI0PT09cilyZXR1cm4gMD09PW8/Yy8wOk5hTjtvKz0xfXJldHVybiBjKm8qcygyLHIpfX0oKTtjbGFzcyBoIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe1J1bnRpbWVFeGNlcHRpb246aH0pWzBdfX1jbGFzcyB1IGV4dGVuZHMgaHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCloLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19fWNsYXNzIGd7c3RhdGljIHNob3VsZE5ldmVyUmVhY2hIZXJlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZy5zaG91bGROZXZlclJlYWNoSGVyZShudWxsKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aHJvdyBuZXcgdShcIlNob3VsZCBuZXZlciByZWFjaCBoZXJlXCIrKG51bGwhPT10P1wiOiBcIit0OlwiXCIpKX19c3RhdGljIGlzVHJ1ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtnLmlzVHJ1ZSh0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2lmKCFhcmd1bWVudHNbMF0pdGhyb3cgbnVsbD09PXQ/bmV3IHU6bmV3IHUodCl9fXN0YXRpYyBlcXVhbHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zy5lcXVhbHModCxlLG51bGwpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKCFlLmVxdWFscyh0KSl0aHJvdyBuZXcgdShcIkV4cGVjdGVkIFwiK3QrXCIgYnV0IGVuY291bnRlcmVkIFwiK2UrKG51bGwhPT1uP1wiOiBcIituOlwiXCIpKX19fWNvbnN0IGQ9bmV3IEFycmF5QnVmZmVyKDgpLF89bmV3IEZsb2F0NjRBcnJheShkKSxwPW5ldyBJbnQzMkFycmF5KGQpO2NsYXNzIG17Y29uc3RydWN0b3IoKXttLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMuej1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKW0uY29uc3RydWN0b3JfLmNhbGwodGhpcywwLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55LHQuZ2V0WigpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG0uTlVMTF9PUkRJTkFURSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy54PXQsdGhpcy55PWUsdGhpcy56PW59fXN0YXRpYyBoYXNoQ29kZSh0KXtyZXR1cm4gX1swXT10LHBbMF1ecFsxXX1nZXRNKCl7cmV0dXJuIHIuTmFOfXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgbS5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgbS5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgbS5aOnRoaXMuc2V0WihlKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fWVxdWFsczJEKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy54LHQueCxuKSYmISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy55LHQueSxuKX19c2V0TSh0KXt0aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK20uTSl9Z2V0Wigpe3JldHVybiB0aGlzLnp9Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgbS5YOnJldHVybiB0aGlzLng7Y2FzZSBtLlk6cmV0dXJuIHRoaXMueTtjYXNlIG0uWjpyZXR1cm4gdGhpcy5nZXRaKCl9dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1lcXVhbHMzRCh0KXtyZXR1cm4gdGhpcy54PT09dC54JiZ0aGlzLnk9PT10LnkmJih0aGlzLmdldFooKT09PXQuZ2V0WigpfHxyLmlzTmFOKHRoaXMuZ2V0WigpKSYmci5pc05hTih0LmdldFooKSkpfWVxdWFscyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIG0mJnRoaXMuZXF1YWxzMkQodCl9ZXF1YWxJbloodCxuKXtyZXR1cm4gZS5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMuZ2V0WigpLHQuZ2V0WigpLG4pfXNldFgodCl7dGhpcy54PXR9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy54PGUueD8tMTp0aGlzLng+ZS54PzE6dGhpcy55PGUueT8tMTp0aGlzLnk+ZS55PzE6MH1nZXRYKCl7cmV0dXJuIHRoaXMueH1zZXRaKHQpe3RoaXMuej10fWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZShcInRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoaXMgY2xhc3MgaXMgQ2xvbmVhYmxlXCIpLG51bGw7dGhyb3cgdH19Y29weSgpe3JldHVybiBuZXcgbSh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLmdldFooKStcIilcIn1kaXN0YW5jZTNEKHQpe2NvbnN0IGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnkscz10aGlzLmdldFooKS10LmdldFooKTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4rcypzKX1nZXRZKCl7cmV0dXJuIHRoaXMueX1zZXRZKHQpe3RoaXMueT10fWRpc3RhbmNlKHQpe2NvbnN0IGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuKX1oYXNoQ29kZSgpe2xldCB0PTE3O3JldHVybiB0PTM3KnQrbS5oYXNoQ29kZSh0aGlzLngpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMueSksdH1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC5nZXRaKCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW28sbCxjXX19Y2xhc3MgZntjb25zdHJ1Y3Rvcigpe2YuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGltZW5zaW9uc1RvVGVzdD0yLDA9PT1hcmd1bWVudHMubGVuZ3RoKWYuY29uc3RydWN0b3JfLmNhbGwodGhpcywyKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigyIT09dCYmMyE9PXQpdGhyb3cgbmV3IHMoXCJvbmx5IDIgb3IgMyBkaW1lbnNpb25zIG1heSBiZSBzcGVjaWZpZWRcIik7dGhpcy5fZGltZW5zaW9uc1RvVGVzdD10fX1zdGF0aWMgY29tcGFyZSh0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6ci5pc05hTih0KT9yLmlzTmFOKGUpPzA6LTE6ci5pc05hTihlKT8xOjB9Y29tcGFyZSh0LGUpe2NvbnN0IG49Zi5jb21wYXJlKHQueCxlLngpO2lmKDAhPT1uKXJldHVybiBuO2NvbnN0IHM9Zi5jb21wYXJlKHQueSxlLnkpO2lmKDAhPT1zKXJldHVybiBzO2lmKHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q8PTIpcmV0dXJuIDA7cmV0dXJuIGYuY29tcGFyZSh0LmdldFooKSxlLmdldFooKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1tLkRpbWVuc2lvbmFsQ29tcGFyYXRvcj1mLG0uTlVMTF9PUkRJTkFURT1yLk5hTixtLlg9MCxtLlk9MSxtLlo9MixtLk09MztjbGFzcyB5IGV4dGVuZHMgbXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCltLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbS5OVUxMX09SRElOQVRFKX19c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSB5Llg6dGhpcy54PWU7YnJlYWs7Y2FzZSB5Llk6dGhpcy55PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX1nZXRaKCl7cmV0dXJuIG0uTlVMTF9PUkRJTkFURX1nZXRPcmRpbmF0ZSh0KXtzd2l0Y2godCl7Y2FzZSB5Llg6cmV0dXJuIHRoaXMueDtjYXNlIHkuWTpyZXR1cm4gdGhpcy55fXRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9c2V0Wih0KXt0aHJvdyBuZXcgcyhcIkNvb3JkaW5hdGVYWSBkaW1lbnNpb24gMiBkb2VzIG5vdCBzdXBwb3J0IHotb3JkaW5hdGVcIil9Y29weSgpe3JldHVybiBuZXcgeSh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiKVwifXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKX19eS5YPTAseS5ZPTEseS5aPS0xLHkuTT0tMTtjbGFzcyB4IGV4dGVuZHMgbXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpbS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLl9tPTA7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB4KXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSksdGhpcy5fbT10Ll9tfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSksdGhpcy5fbT10aGlzLmdldE0oKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxtLk5VTExfT1JESU5BVEUpLHRoaXMuX209bn19Z2V0TSgpe3JldHVybiB0aGlzLl9tfXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgeC5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgeC5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgeC5NOnRoaXMuX209ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fXNldE0odCl7dGhpcy5fbT10fWdldFooKXtyZXR1cm4gbS5OVUxMX09SRElOQVRFfWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIHguWDpyZXR1cm4gdGhpcy54O2Nhc2UgeC5ZOnJldHVybiB0aGlzLnk7Y2FzZSB4Lk06cmV0dXJuIHRoaXMuX219dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1zZXRaKHQpe3Rocm93IG5ldyBzKFwiQ29vcmRpbmF0ZVhZIGRpbWVuc2lvbiAyIGRvZXMgbm90IHN1cHBvcnQgei1vcmRpbmF0ZVwiKX1jb3B5KCl7cmV0dXJuIG5ldyB4KHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIgbT1cIit0aGlzLmdldE0oKStcIilcIn1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC5nZXRaKCksdGhpcy5fbT10LmdldE0oKX19eC5YPTAseC5ZPTEseC5aPS0xLHguTT0yO2NsYXNzIEUgZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxFLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX209bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCltLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuX209MDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLl9tPXQuX219ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLl9tPXRoaXMuZ2V0TSgpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4pLHRoaXMuX209c319Z2V0TSgpe3JldHVybiB0aGlzLl9tfXNldE9yZGluYXRlKHQsZSl7c3dpdGNoKHQpe2Nhc2UgbS5YOnRoaXMueD1lO2JyZWFrO2Nhc2UgbS5ZOnRoaXMueT1lO2JyZWFrO2Nhc2UgbS5aOnRoaXMuej1lO2JyZWFrO2Nhc2UgbS5NOnRoaXMuX209ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fXNldE0odCl7dGhpcy5fbT10fWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIG0uWDpyZXR1cm4gdGhpcy54O2Nhc2UgbS5ZOnJldHVybiB0aGlzLnk7Y2FzZSBtLlo6cmV0dXJuIHRoaXMuZ2V0WigpO2Nhc2UgbS5NOnJldHVybiB0aGlzLmdldE0oKX10aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfWNvcHkoKXtyZXR1cm4gbmV3IEUodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiwgXCIrdGhpcy5nZXRaKCkrXCIgbT1cIit0aGlzLmdldE0oKStcIilcIn1zZXRDb29yZGluYXRlKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC5nZXRaKCksdGhpcy5fbT10LmdldE0oKX19ZnVuY3Rpb24gSSh0LGUpe3JldHVybiB0LmludGVyZmFjZXNfJiZ0LmludGVyZmFjZXNfLmluZGV4T2YoZSk+LTF9Y2xhc3MgTnthZGQoKXt9YWRkQWxsKCl7fWlzRW1wdHkoKXt9aXRlcmF0b3IoKXt9c2l6ZSgpe310b0FycmF5KCl7fXJlbW92ZSgpe319Y2xhc3MgUyBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uOlN9KVswXX19Y2xhc3MgdyBleHRlbmRzIE57Z2V0KCl7fXNldCgpe31pc0VtcHR5KCl7fX1jbGFzcyBDIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe05vU3VjaEVsZW1lbnRFeGNlcHRpb246Q30pWzBdfX1jbGFzcyBMIGV4dGVuZHMgd3tjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuYXJyYXk9W10sdCBpbnN0YW5jZW9mIE4mJnRoaXMuYWRkQWxsKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblt3LE5dfWVuc3VyZUNhcGFjaXR5KCl7fWFkZCh0KXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5hcnJheS5wdXNoKHQpOnRoaXMuYXJyYXkuc3BsaWNlKGFyZ3VtZW50c1swXSwwLGFyZ3VtZW50c1sxXSksITB9Y2xlYXIoKXt0aGlzLmFycmF5PVtdfWFkZEFsbCh0KXtmb3IoY29uc3QgZSBvZiB0KXRoaXMuYXJyYXkucHVzaChlKX1zZXQodCxlKXtjb25zdCBuPXRoaXMuYXJyYXlbdF07cmV0dXJuIHRoaXMuYXJyYXlbdF09ZSxufWl0ZXJhdG9yKCl7cmV0dXJuIG5ldyBUKHRoaXMpfWdldCh0KXtpZih0PDB8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBTO3JldHVybiB0aGlzLmFycmF5W3RdfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuYXJyYXkubGVuZ3RofXNvcnQodCl7dD90aGlzLmFycmF5LnNvcnQoKChlLG4pPT50LmNvbXBhcmUoZSxuKSkpOnRoaXMuYXJyYXkuc29ydCgpfXNpemUoKXtyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGh9dG9BcnJheSgpe3JldHVybiB0aGlzLmFycmF5LnNsaWNlKCl9cmVtb3ZlKHQpe2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheS5sZW5ndGg7ZTxuO2UrKylpZih0aGlzLmFycmF5W2VdPT09dClyZXR1cm4hIXRoaXMuYXJyYXkuc3BsaWNlKGUsMSk7cmV0dXJuITF9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5hcnJheS52YWx1ZXMoKX19Y2xhc3MgVHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmFycmF5TGlzdD10LHRoaXMucG9zaXRpb249MH1uZXh0KCl7aWYodGhpcy5wb3NpdGlvbj09PXRoaXMuYXJyYXlMaXN0LnNpemUoKSl0aHJvdyBuZXcgQztyZXR1cm4gdGhpcy5hcnJheUxpc3QuZ2V0KHRoaXMucG9zaXRpb24rKyl9aGFzTmV4dCgpe3JldHVybiB0aGlzLnBvc2l0aW9uPHRoaXMuYXJyYXlMaXN0LnNpemUoKX1zZXQodCl7cmV0dXJuIHRoaXMuYXJyYXlMaXN0LnNldCh0aGlzLnBvc2l0aW9uLTEsdCl9cmVtb3ZlKCl7dGhpcy5hcnJheUxpc3QucmVtb3ZlKHRoaXMuYXJyYXlMaXN0LmdldCh0aGlzLnBvc2l0aW9uKSl9fWNsYXNzIFIgZXh0ZW5kcyBMe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxSLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LCEwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LGUpfX1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLmdldCh0KX1hZGRBbGwoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJkkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtsZXQgZT0hMTtmb3IobGV0IG49YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXRoaXMuYWRkKG4ubmV4dCgpLHQpLGU9ITA7cmV0dXJuIGV9cmV0dXJuIHN1cGVyLmFkZEFsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2xvbmUoKXtjb25zdCB0PXN1cGVyLmNsb25lLmNhbGwodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLnNpemUoKTtlKyspdC5hZGQoZSx0aGlzLmdldChlKS5jbG9uZSgpKTtyZXR1cm4gdH10b0Nvb3JkaW5hdGVBcnJheSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnRvQXJyYXkoUi5jb29yZEFycmF5VHlwZSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXSlyZXR1cm4gdGhpcy50b0FycmF5KFIuY29vcmRBcnJheVR5cGUpO2NvbnN0IHQ9dGhpcy5zaXplKCksZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQ7bisrKWVbbl09dGhpcy5nZXQodC1uLTEpO3JldHVybiBlfX1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHN1cGVyLmFkZC5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQodCxlLCEwKSwhMH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZighYXJndW1lbnRzWzFdJiZ0aGlzLnNpemUoKT49MSl7aWYodGhpcy5nZXQodGhpcy5zaXplKCktMSkuZXF1YWxzMkQodCkpcmV0dXJuIG51bGx9c3VwZXIuYWRkLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKHQsZSksITB9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoYXJndW1lbnRzWzJdKWZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXRoaXMuYWRkKHRbbl0sZSk7ZWxzZSBmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSl0aGlzLmFkZCh0W25dLGUpO3JldHVybiEwfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIWFyZ3VtZW50c1syXSl7Y29uc3Qgbj10aGlzLnNpemUoKTtpZihuPjApe2lmKHQ+MCl7aWYodGhpcy5nZXQodC0xKS5lcXVhbHMyRChlKSlyZXR1cm4gbnVsbH1pZih0PG4pe2lmKHRoaXMuZ2V0KHQpLmVxdWFsczJEKGUpKXJldHVybiBudWxsfX19c3VwZXIuYWRkLmNhbGwodGhpcyx0LGUpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtsZXQgaT0xO24+cyYmKGk9LTEpO2ZvcihsZXQgcj1uO3IhPT1zO3IrPWkpdGhpcy5hZGQodFtyXSxlKTtyZXR1cm4hMH19Y2xvc2VSaW5nKCl7aWYodGhpcy5zaXplKCk+MCl7Y29uc3QgdD10aGlzLmdldCgwKS5jb3B5KCk7dGhpcy5hZGQodCwhMSl9fX1SLmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIFB7ZmlsdGVyKHQsZSl7fWlzRG9uZSgpe31pc0dlb21ldHJ5Q2hhbmdlZCgpe319Y2xhc3MgT3tjb25zdHJ1Y3Rvcigpe08uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbWlueD1udWxsLHRoaXMuX21heHg9bnVsbCx0aGlzLl9taW55PW51bGwsdGhpcy5fbWF4eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQueCxlLngsdC55LGUueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5pbml0KHQsZSxuLHMpfX1zdGF0aWMgaW50ZXJzZWN0cygpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbi54Pj0odC54PGUueD90Lng6ZS54KSYmbi54PD0odC54PmUueD90Lng6ZS54KSYmbi55Pj0odC55PGUueT90Lnk6ZS55KSYmbi55PD0odC55PmUueT90Lnk6ZS55KX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9TWF0aC5taW4obi54LHMueCkscj1NYXRoLm1heChuLngscy54KSxvPU1hdGgubWluKHQueCxlLngpLGw9TWF0aC5tYXgodC54LGUueCk7cmV0dXJuIShvPnIpJiYoIShsPGkpJiYoaT1NYXRoLm1pbihuLnkscy55KSxyPU1hdGgubWF4KG4ueSxzLnkpLG89TWF0aC5taW4odC55LGUueSksbD1NYXRoLm1heCh0LnksZS55KSwhKG8+cikmJiEobDxpKSkpfX1nZXRBcmVhKCl7cmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSp0aGlzLmdldEhlaWdodCgpfWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBPKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKTp0aGlzLl9tYXh4PT09ZS5nZXRNYXhYKCkmJnRoaXMuX21heHk9PT1lLmdldE1heFkoKSYmdGhpcy5fbWlueD09PWUuZ2V0TWluWCgpJiZ0aGlzLl9taW55PT09ZS5nZXRNaW5ZKCl9aW50ZXJzZWN0aW9uKHQpe2lmKHRoaXMuaXNOdWxsKCl8fHQuaXNOdWxsKCl8fCF0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIG5ldyBPO2NvbnN0IGU9dGhpcy5fbWlueD50Ll9taW54P3RoaXMuX21pbng6dC5fbWlueCxuPXRoaXMuX21pbnk+dC5fbWlueT90aGlzLl9taW55OnQuX21pbnkscz10aGlzLl9tYXh4PHQuX21heHg/dGhpcy5fbWF4eDp0Ll9tYXh4LGk9dGhpcy5fbWF4eTx0Ll9tYXh5P3RoaXMuX21heHk6dC5fbWF4eTtyZXR1cm4gbmV3IE8oZSxzLG4saSl9aXNOdWxsKCl7cmV0dXJuIHRoaXMuX21heHg8dGhpcy5fbWlueH1nZXRNYXhYKCl7cmV0dXJuIHRoaXMuX21heHh9Y292ZXJzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQueCx0LnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYodC5nZXRNaW5YKCk+PXRoaXMuX21pbngmJnQuZ2V0TWF4WCgpPD10aGlzLl9tYXh4JiZ0LmdldE1pblkoKT49dGhpcy5fbWlueSYmdC5nZXRNYXhZKCk8PXRoaXMuX21heHkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmKHQ+PXRoaXMuX21pbngmJnQ8PXRoaXMuX21heHgmJmU+PXRoaXMuX21pbnkmJmU8PXRoaXMuX21heHkpfX1pbnRlcnNlY3RzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYhKHQuX21pbng+dGhpcy5fbWF4eHx8dC5fbWF4eDx0aGlzLl9taW54fHx0Ll9taW55PnRoaXMuX21heHl8fHQuX21heHk8dGhpcy5fbWlueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQueCx0LnkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5pc051bGwoKSlyZXR1cm4hMTtpZigodC54PGUueD90Lng6ZS54KT50aGlzLl9tYXh4KXJldHVybiExO2lmKCh0Lng+ZS54P3QueDplLngpPHRoaXMuX21pbngpcmV0dXJuITE7aWYoKHQueTxlLnk/dC55OmUueSk+dGhpcy5fbWF4eSlyZXR1cm4hMTtyZXR1cm4hKCh0Lnk+ZS55P3QueTplLnkpPHRoaXMuX21pbnkpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhKHQ+dGhpcy5fbWF4eHx8dDx0aGlzLl9taW54fHxlPnRoaXMuX21heHl8fGU8dGhpcy5fbWlueSl9fX1nZXRNaW5ZKCl7cmV0dXJuIHRoaXMuX21pbnl9Z2V0RGlhbWV0ZXIoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtlKmUpfWdldE1pblgoKXtyZXR1cm4gdGhpcy5fbWlueH1leHBhbmRUb0luY2x1ZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZFRvSW5jbHVkZSh0LngsdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmlzTnVsbCgpPyh0aGlzLl9taW54PXQuZ2V0TWluWCgpLHRoaXMuX21heHg9dC5nZXRNYXhYKCksdGhpcy5fbWlueT10LmdldE1pblkoKSx0aGlzLl9tYXh5PXQuZ2V0TWF4WSgpKToodC5fbWlueDx0aGlzLl9taW54JiYodGhpcy5fbWlueD10Ll9taW54KSx0Ll9tYXh4PnRoaXMuX21heHgmJih0aGlzLl9tYXh4PXQuX21heHgpLHQuX21pbnk8dGhpcy5fbWlueSYmKHRoaXMuX21pbnk9dC5fbWlueSksdC5fbWF4eT50aGlzLl9tYXh5JiYodGhpcy5fbWF4eT10Ll9tYXh5KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaXNOdWxsKCk/KHRoaXMuX21pbng9dCx0aGlzLl9tYXh4PXQsdGhpcy5fbWlueT1lLHRoaXMuX21heHk9ZSk6KHQ8dGhpcy5fbWlueCYmKHRoaXMuX21pbng9dCksdD50aGlzLl9tYXh4JiYodGhpcy5fbWF4eD10KSxlPHRoaXMuX21pbnkmJih0aGlzLl9taW55PWUpLGU+dGhpcy5fbWF4eSYmKHRoaXMuX21heHk9ZSkpfX1taW5FeHRlbnQoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdDxlP3Q6ZX1nZXRXaWR0aCgpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5fbWF4eC10aGlzLl9taW54fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKT8wOi0xOmUuaXNOdWxsKCk/MTp0aGlzLl9taW54PGUuX21pbng/LTE6dGhpcy5fbWlueD5lLl9taW54PzE6dGhpcy5fbWlueTxlLl9taW55Py0xOnRoaXMuX21pbnk+ZS5fbWlueT8xOnRoaXMuX21heHg8ZS5fbWF4eD8tMTp0aGlzLl9tYXh4PmUuX21heHg/MTp0aGlzLl9tYXh5PGUuX21heHk/LTE6dGhpcy5fbWF4eT5lLl9tYXh5PzE6MH10cmFuc2xhdGUodCxlKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaW5pdCh0aGlzLmdldE1pblgoKSt0LHRoaXMuZ2V0TWF4WCgpK3QsdGhpcy5nZXRNaW5ZKCkrZSx0aGlzLmdldE1heFkoKStlKX1jb3B5KCl7cmV0dXJuIG5ldyBPKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCJFbnZbXCIrdGhpcy5fbWlueCtcIiA6IFwiK3RoaXMuX21heHgrXCIsIFwiK3RoaXMuX21pbnkrXCIgOiBcIit0aGlzLl9tYXh5K1wiXVwifXNldFRvTnVsbCgpe3RoaXMuX21pbng9MCx0aGlzLl9tYXh4PS0xLHRoaXMuX21pbnk9MCx0aGlzLl9tYXh5PS0xfWRpc2pvaW50KHQpe3JldHVybiEoIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpKXx8KHQuX21pbng+dGhpcy5fbWF4eHx8dC5fbWF4eDx0aGlzLl9taW54fHx0Ll9taW55PnRoaXMuX21heHl8fHQuX21heHk8dGhpcy5fbWlueSl9Z2V0SGVpZ2h0KCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLl9tYXh5LXRoaXMuX21pbnl9bWF4RXh0ZW50KCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ+ZT90OmV9ZXhwYW5kQnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRCeSh0LHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5fbWlueC09dCx0aGlzLl9tYXh4Kz10LHRoaXMuX21pbnktPWUsdGhpcy5fbWF4eSs9ZSwodGhpcy5fbWlueD50aGlzLl9tYXh4fHx0aGlzLl9taW55PnRoaXMuX21heHkpJiZ0aGlzLnNldFRvTnVsbCgpfX1jb250YWlucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY292ZXJzKHQsZSl9fWNlbnRyZSgpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6bmV3IG0oKHRoaXMuZ2V0TWluWCgpK3RoaXMuZ2V0TWF4WCgpKS8yLCh0aGlzLmdldE1pblkoKSt0aGlzLmdldE1heFkoKSkvMil9aW5pdCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuc2V0VG9OdWxsKCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWlueD10Ll9taW54LHRoaXMuX21heHg9dC5fbWF4eCx0aGlzLl9taW55PXQuX21pbnksdGhpcy5fbWF4eT10Ll9tYXh5fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodC54LGUueCx0LnksZS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0PGU/KHRoaXMuX21pbng9dCx0aGlzLl9tYXh4PWUpOih0aGlzLl9taW54PWUsdGhpcy5fbWF4eD10KSxuPHM/KHRoaXMuX21pbnk9bix0aGlzLl9tYXh5PXMpOih0aGlzLl9taW55PXMsdGhpcy5fbWF4eT1uKX19Z2V0TWF4WSgpe3JldHVybiB0aGlzLl9tYXh5fWRpc3RhbmNlKHQpe2lmKHRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gMDtsZXQgZT0wO3RoaXMuX21heHg8dC5fbWlueD9lPXQuX21pbngtdGhpcy5fbWF4eDp0aGlzLl9taW54PnQuX21heHgmJihlPXRoaXMuX21pbngtdC5fbWF4eCk7bGV0IG49MDtyZXR1cm4gdGhpcy5fbWF4eTx0Ll9taW55P249dC5fbWlueS10aGlzLl9tYXh5OnRoaXMuX21pbnk+dC5fbWF4eSYmKG49dGhpcy5fbWlueS10Ll9tYXh5KSwwPT09ZT9uOjA9PT1uP2U6TWF0aC5zcXJ0KGUqZStuKm4pfWhhc2hDb2RlKCl7bGV0IHQ9MTc7cmV0dXJuIHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21pbngpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21heHgpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21pbnkpLHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMuX21heHkpLHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW28sY119fWNsYXNzIHZ7Y29uc3RydWN0b3IodCl7dGhpcy5zdHI9dH1hcHBlbmQodCl7dGhpcy5zdHIrPXR9c2V0Q2hhckF0KHQsZSl7dGhpcy5zdHI9dGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX10b1N0cmluZygpe3JldHVybiB0aGlzLnN0cn19Y2xhc3MgTXtjb25zdHJ1Y3Rvcih0KXt0aGlzLnZhbHVlPXR9aW50VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX1jb21wYXJlVG8odCl7cmV0dXJuIHRoaXMudmFsdWU8dD8tMTp0aGlzLnZhbHVlPnQ/MTowfXN0YXRpYyBjb21wYXJlKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTowfXN0YXRpYyBpc05hbih0KXtyZXR1cm4gTnVtYmVyLmlzTmFOKHQpfXN0YXRpYyB2YWx1ZU9mKHQpe3JldHVybiBuZXcgTSh0KX19Y2xhc3MgYntzdGF0aWMgaXNXaGl0ZXNwYWNlKHQpe3JldHVybiB0PD0zMiYmdD49MHx8MTI3PT09dH1zdGF0aWMgdG9VcHBlckNhc2UodCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX19Y2xhc3MgRHtjb25zdHJ1Y3Rvcigpe0QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5faGk9MCx0aGlzLl9sbz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0QuY29uc3RydWN0b3JfLmNhbGwodGhpcyxELnBhcnNlKHQpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0KHQsZSl9fXN0YXRpYyBkZXRlcm1pbmFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbM10mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiBELmRldGVybWluYW50KEQudmFsdWVPZih0KSxELnZhbHVlT2YoZSksRC52YWx1ZU9mKG4pLEQudmFsdWVPZihzKSl9aWYoYXJndW1lbnRzWzNdaW5zdGFuY2VvZiBEJiZhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEQmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXTtyZXR1cm4gYXJndW1lbnRzWzBdLm11bHRpcGx5KG4pLnNlbGZTdWJ0cmFjdCh0Lm11bHRpcGx5KGUpKX19c3RhdGljIHNxcih0KXtyZXR1cm4gRC52YWx1ZU9mKHQpLnNlbGZNdWx0aXBseSh0KX1zdGF0aWMgdmFsdWVPZigpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBELnBhcnNlKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3JldHVybiBuZXcgRChhcmd1bWVudHNbMF0pfX1zdGF0aWMgc3FydCh0KXtyZXR1cm4gRC52YWx1ZU9mKHQpLnNxcnQoKX1zdGF0aWMgcGFyc2UodCl7bGV0IGU9MDtjb25zdCBuPXQubGVuZ3RoO2Zvcig7Yi5pc1doaXRlc3BhY2UodC5jaGFyQXQoZSkpOyllKys7bGV0IHM9ITE7aWYoZTxuKXtjb25zdCBuPXQuY2hhckF0KGUpO1wiLVwiIT09biYmXCIrXCIhPT1ufHwoZSsrLFwiLVwiPT09biYmKHM9ITApKX1jb25zdCBpPW5ldyBEO2xldCByPTAsbz0wLGw9MCxhPSExO2Zvcig7IShlPj1uKTspe2NvbnN0IG49dC5jaGFyQXQoZSk7aWYoZSsrLGIuaXNEaWdpdChuKSl7Y29uc3QgdD1uLVwiMFwiO2kuc2VsZk11bHRpcGx5KEQuVEVOKSxpLnNlbGZBZGQodCkscisrfWVsc2V7aWYoXCIuXCIhPT1uKXtpZihcImVcIj09PW58fFwiRVwiPT09bil7Y29uc3Qgbj10LnN1YnN0cmluZyhlKTt0cnl7bD1NLnBhcnNlSW50KG4pfWNhdGNoKGUpe3Rocm93IGUgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb24/bmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIkludmFsaWQgZXhwb25lbnQgXCIrbitcIiBpbiBzdHJpbmcgXCIrdCk6ZX1icmVha310aHJvdyBuZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK24rXCInIGF0IHBvc2l0aW9uIFwiK2UrXCIgaW4gc3RyaW5nIFwiK3QpfW89cixhPSEwfX1sZXQgYz1pO2F8fChvPXIpO2NvbnN0IGg9ci1vLWw7aWYoMD09PWgpYz1pO2Vsc2UgaWYoaD4wKXtjb25zdCB0PUQuVEVOLnBvdyhoKTtjPWkuZGl2aWRlKHQpfWVsc2UgaWYoaDwwKXtjb25zdCB0PUQuVEVOLnBvdygtaCk7Yz1pLm11bHRpcGx5KHQpfXJldHVybiBzP2MubmVnYXRlKCk6Y31zdGF0aWMgY3JlYXRlTmFOKCl7cmV0dXJuIG5ldyBEKHIuTmFOLHIuTmFOKX1zdGF0aWMgY29weSh0KXtyZXR1cm4gbmV3IEQodCl9c3RhdGljIG1hZ25pdHVkZSh0KXtjb25zdCBlPU1hdGguYWJzKHQpLG49TWF0aC5sb2coZSkvTWF0aC5sb2coMTApO2xldCBzPU1hdGgudHJ1bmMoTWF0aC5mbG9vcihuKSk7cmV0dXJuIDEwKk1hdGgucG93KDEwLHMpPD1lJiYocys9MSksc31zdGF0aWMgc3RyaW5nT2ZDaGFyKHQsZSl7Y29uc3Qgbj1uZXcgdjtmb3IobGV0IHM9MDtzPGU7cysrKW4uYXBwZW5kKHQpO3JldHVybiBuLnRvU3RyaW5nKCl9bGUodCl7cmV0dXJuIHRoaXMuX2hpPHQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbzw9dC5fbG99ZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHQsZSl7bGV0IG49dGhpcy5hYnMoKSxzPUQubWFnbml0dWRlKG4uX2hpKTtjb25zdCBpPUQuVEVOLnBvdyhzKTtuPW4uZGl2aWRlKGkpLG4uZ3QoRC5URU4pPyhuPW4uZGl2aWRlKEQuVEVOKSxzKz0xKTpuLmx0KEQuT05FKSYmKG49bi5tdWx0aXBseShELlRFTikscy09MSk7Y29uc3Qgcj1zKzEsbz1uZXcgdixsPUQuTUFYX1BSSU5UX0RJR0lUUy0xO2ZvcihsZXQgZT0wO2U8PWw7ZSsrKXt0JiZlPT09ciYmby5hcHBlbmQoXCIuXCIpO2NvbnN0IHM9TWF0aC50cnVuYyhuLl9oaSk7aWYoczwwKWJyZWFrO2xldCBpPSExLGE9MDtzPjk/KGk9ITAsYT1cIjlcIik6YT1cIjBcIitzLG8uYXBwZW5kKGEpLG49bi5zdWJ0cmFjdChELnZhbHVlT2YocykpLm11bHRpcGx5KEQuVEVOKSxpJiZuLnNlbGZBZGQoRC5URU4pO2xldCBjPSEwO2NvbnN0IGg9RC5tYWduaXR1ZGUobi5faGkpO2lmKGg8MCYmTWF0aC5hYnMoaCk+PWwtZSYmKGM9ITEpLCFjKWJyZWFrfXJldHVybiBlWzBdPXMsby50b1N0cmluZygpfXNxcigpe3JldHVybiB0aGlzLm11bHRpcGx5KHRoaXMpfWRvdWJsZVZhbHVlKCl7cmV0dXJuIHRoaXMuX2hpK3RoaXMuX2xvfXN1YnRyYWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQodC5uZWdhdGUoKSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKC10KX19ZXF1YWxzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPT09dC5fbG99fWlzWmVybygpe3JldHVybiAwPT09dGhpcy5faGkmJjA9PT10aGlzLl9sb31zZWxmU3VidHJhY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQuX2hpLC10Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtdCwwKX19Z2V0U3BlY2lhbE51bWJlclN0cmluZygpe3JldHVybiB0aGlzLmlzWmVybygpP1wiMC4wXCI6dGhpcy5pc05hTigpP1wiTmFOIFwiOm51bGx9bWluKHQpe3JldHVybiB0aGlzLmxlKHQpP3RoaXM6dH1zZWxmRGl2aWRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0LDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsLGM9bnVsbDtyZXR1cm4gbz10aGlzLl9oaS90LGw9RC5TUExJVCpvLG49bC1vLGM9RC5TUExJVCp0LG49bC1uLHM9by1uLGk9Yy10LGE9byp0LGk9Yy1pLHI9dC1pLGM9bippLWErbipyK3MqaStzKnIsbD0odGhpcy5faGktYS1jK3RoaXMuX2xvLW8qZSkvdCxjPW8rbCx0aGlzLl9oaT1jLHRoaXMuX2xvPW8tYytsLHRoaXN9fWR1bXAoKXtyZXR1cm5cIkREPFwiK3RoaXMuX2hpK1wiLCBcIit0aGlzLl9sbytcIj5cIn1kaXZpZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsO3I9dGhpcy5faGkvdC5faGksbz1ELlNQTElUKnIsZT1vLXIsYT1ELlNQTElUKnQuX2hpLGU9by1lLG49ci1lLHM9YS10Ll9oaSxsPXIqdC5faGkscz1hLXMsaT10Ll9oaS1zLGE9ZSpzLWwrZSppK24qcytuKmksbz0odGhpcy5faGktbC1hK3RoaXMuX2xvLXIqdC5fbG8pL3QuX2hpLGE9citvO3JldHVybiBuZXcgRChhLHItYStvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTih0KT9ELmNyZWF0ZU5hTigpOkQuY29weSh0aGlzKS5zZWxmRGl2aWRlKHQsMCl9fWdlKHQpe3JldHVybiB0aGlzLl9oaT50Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG8+PXQuX2xvfXBvdyh0KXtpZigwPT09dClyZXR1cm4gRC52YWx1ZU9mKDEpO2xldCBlPW5ldyBEKHRoaXMpLG49RC52YWx1ZU9mKDEpLHM9TWF0aC5hYnModCk7aWYocz4xKWZvcig7cz4wOylzJTI9PTEmJm4uc2VsZk11bHRpcGx5KGUpLHMvPTIscz4wJiYoZT1lLnNxcigpKTtlbHNlIG49ZTtyZXR1cm4gdDwwP24ucmVjaXByb2NhbCgpOm59Y2VpbCgpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gRC5OYU47Y29uc3QgdD1NYXRoLmNlaWwodGhpcy5faGkpO2xldCBlPTA7cmV0dXJuIHQ9PT10aGlzLl9oaSYmKGU9TWF0aC5jZWlsKHRoaXMuX2xvKSksbmV3IEQodCxlKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9oaTxlLl9oaT8tMTp0aGlzLl9oaT5lLl9oaT8xOnRoaXMuX2xvPGUuX2xvPy0xOnRoaXMuX2xvPmUuX2xvPzE6MH1yaW50KCl7aWYodGhpcy5pc05hTigpKXJldHVybiB0aGlzO3JldHVybiB0aGlzLmFkZCguNSkuZmxvb3IoKX1zZXRWYWx1ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc319bWF4KHQpe3JldHVybiB0aGlzLmdlKHQpP3RoaXM6dH1zcXJ0KCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gRC52YWx1ZU9mKDApO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBELk5hTjtjb25zdCB0PTEvTWF0aC5zcXJ0KHRoaXMuX2hpKSxlPXRoaXMuX2hpKnQsbj1ELnZhbHVlT2YoZSkscz10aGlzLnN1YnRyYWN0KG4uc3FyKCkpLl9oaSooLjUqdCk7cmV0dXJuIG4uYWRkKHMpfXNlbGZBZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmQWRkKHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGw7cmV0dXJuIHM9dGhpcy5faGkrdCxyPXMtdGhpcy5faGksaT1zLXIsaT10LXIrKHRoaXMuX2hpLWkpLG89aSt0aGlzLl9sbyxlPXMrbyxuPW8rKHMtZSksdGhpcy5faGk9ZStuLHRoaXMuX2xvPW4rKGUtdGhpcy5faGkpLHRoaXN9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGwsYz1udWxsO289dGhpcy5faGkrdCxpPXRoaXMuX2xvK2UsYT1vLXRoaXMuX2hpLGM9aS10aGlzLl9sbyxsPW8tYSxyPWktYyxsPXQtYSsodGhpcy5faGktbCkscj1lLWMrKHRoaXMuX2xvLXIpLGE9bCtpLG49bythLHM9YSsoby1uKSxhPXIrcztjb25zdCBoPW4rYSx1PWErKG4taCk7cmV0dXJuIHRoaXMuX2hpPWgsdGhpcy5fbG89dSx0aGlzfX1zZWxmTXVsdGlwbHkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0LDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGw7bz1ELlNQTElUKnRoaXMuX2hpLG49by10aGlzLl9oaSxsPUQuU1BMSVQqdCxuPW8tbixzPXRoaXMuX2hpLW4saT1sLXQsbz10aGlzLl9oaSp0LGk9bC1pLHI9dC1pLGw9bippLW8rbipyK3MqaStzKnIrKHRoaXMuX2hpKmUrdGhpcy5fbG8qdCk7Y29uc3QgYT1vK2w7bj1vLWE7Y29uc3QgYz1sK247cmV0dXJuIHRoaXMuX2hpPWEsdGhpcy5fbG89Yyx0aGlzfX1zZWxmU3FyKCl7cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHRoaXMpfWZsb29yKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBELk5hTjtjb25zdCB0PU1hdGguZmxvb3IodGhpcy5faGkpO2xldCBlPTA7cmV0dXJuIHQ9PT10aGlzLl9oaSYmKGU9TWF0aC5mbG9vcih0aGlzLl9sbykpLG5ldyBEKHQsZSl9bmVnYXRlKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOm5ldyBEKC10aGlzLl9oaSwtdGhpcy5fbG8pfWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gbnVsbDt0aHJvdyB0fX1tdWx0aXBseSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuaXNOYU4oKT9ELmNyZWF0ZU5hTigpOkQuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4odCk/RC5jcmVhdGVOYU4oKTpELmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHQsMCl9fWlzTmFOKCl7cmV0dXJuIHIuaXNOYU4odGhpcy5faGkpfWludFZhbHVlKCl7cmV0dXJuIE1hdGgudHJ1bmModGhpcy5faGkpfXRvU3RyaW5nKCl7Y29uc3QgdD1ELm1hZ25pdHVkZSh0aGlzLl9oaSk7cmV0dXJuIHQ+PS0zJiZ0PD0yMD90aGlzLnRvU3RhbmRhcmROb3RhdGlvbigpOnRoaXMudG9TY2lOb3RhdGlvbigpfXRvU3RhbmRhcmROb3RhdGlvbigpe2NvbnN0IHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCEwLGUpLHM9ZVswXSsxO2xldCBpPW47aWYoXCIuXCI9PT1uLmNoYXJBdCgwKSlpPVwiMFwiK247ZWxzZSBpZihzPDApaT1cIjAuXCIrRC5zdHJpbmdPZkNoYXIoXCIwXCIsLXMpK247ZWxzZSBpZigtMT09PW4uaW5kZXhPZihcIi5cIikpe2NvbnN0IHQ9cy1uLmxlbmd0aDtpPW4rRC5zdHJpbmdPZkNoYXIoXCIwXCIsdCkrXCIuMFwifXJldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIitpOml9cmVjaXByb2NhbCgpe2xldCB0PW51bGwsZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsO2k9MS90aGlzLl9oaSxyPUQuU1BMSVQqaSx0PXItaSxsPUQuU1BMSVQqdGhpcy5faGksdD1yLXQsZT1pLXQsbj1sLXRoaXMuX2hpLG89aSp0aGlzLl9oaSxuPWwtbixzPXRoaXMuX2hpLW4sbD10Km4tbyt0KnMrZSpuK2UqcyxyPSgxLW8tbC1pKnRoaXMuX2xvKS90aGlzLl9oaTtjb25zdCBhPWkrcjtyZXR1cm4gbmV3IEQoYSxpLWErcil9dG9TY2lOb3RhdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIEQuU0NJX05PVF9aRVJPO2NvbnN0IHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCExLGUpLHM9RC5TQ0lfTk9UX0VYUE9ORU5UX0NIQVIrZVswXTtpZihcIjBcIj09PW4uY2hhckF0KDApKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJGb3VuZCBsZWFkaW5nIHplcm86IFwiK24pO2xldCBpPVwiXCI7bi5sZW5ndGg+MSYmKGk9bi5zdWJzdHJpbmcoMSkpO2NvbnN0IHI9bi5jaGFyQXQoMCkrXCIuXCIraTtyZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIrcitzOnIrc31hYnMoKXtyZXR1cm4gdGhpcy5pc05hTigpP0QuTmFOOnRoaXMuaXNOZWdhdGl2ZSgpP3RoaXMubmVnYXRlKCk6bmV3IEQodGhpcyl9aXNQb3NpdGl2ZSgpe3JldHVybiB0aGlzLl9oaT4wfHwwPT09dGhpcy5faGkmJnRoaXMuX2xvPjB9bHQodCl7cmV0dXJuIHRoaXMuX2hpPHQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbzx0Ll9sb31hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBELmNvcHkodGhpcykuc2VsZkFkZCh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gRC5jb3B5KHRoaXMpLnNlbGZBZGQodCl9fWluaXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faGk9dCx0aGlzLl9sbz0wfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9oaT10Ll9oaSx0aGlzLl9sbz10Ll9sb319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faGk9dCx0aGlzLl9sbz1lfX1ndCh0KXtyZXR1cm4gdGhpcy5faGk+dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPnQuX2xvfWlzTmVnYXRpdmUoKXtyZXR1cm4gdGhpcy5faGk8MHx8MD09PXRoaXMuX2hpJiZ0aGlzLl9sbzwwfXRydW5jKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9ELk5hTjp0aGlzLmlzUG9zaXRpdmUoKT90aGlzLmZsb29yKCk6dGhpcy5jZWlsKCl9c2lnbnVtKCl7cmV0dXJuIHRoaXMuX2hpPjA/MTp0aGlzLl9oaTwwPy0xOnRoaXMuX2xvPjA/MTp0aGlzLl9sbzwwPy0xOjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2MsbyxsXX19RC5QST1uZXcgRCgzLjE0MTU5MjY1MzU4OTc5MywxMjI0NjQ2Nzk5MTQ3MzUzMmUtMzIpLEQuVFdPX1BJPW5ldyBEKDYuMjgzMTg1MzA3MTc5NTg2LDI0NDkyOTM1OTgyOTQ3MDY0ZS0zMiksRC5QSV8yPW5ldyBEKDEuNTcwNzk2MzI2Nzk0ODk2Niw2MTIzMjMzOTk1NzM2NzY2ZS0zMiksRC5FPW5ldyBEKDIuNzE4MjgxODI4NDU5MDQ1LDE0NDU2NDY4OTE3MjkyNTAyZS0zMiksRC5OYU49bmV3IEQoci5OYU4sci5OYU4pLEQuRVBTPTEyMzI1OTUxNjQ0MDc4M2UtNDYsRC5TUExJVD0xMzQyMTc3MjksRC5NQVhfUFJJTlRfRElHSVRTPTMyLEQuVEVOPUQudmFsdWVPZigxMCksRC5PTkU9RC52YWx1ZU9mKDEpLEQuU0NJX05PVF9FWFBPTkVOVF9DSEFSPVwiRVwiLEQuU0NJX05PVF9aRVJPPVwiMC4wRTBcIjtjbGFzcyBBe3N0YXRpYyBvcmllbnRhdGlvbkluZGV4KHQsZSxuKXtjb25zdCBzPUEub3JpZW50YXRpb25JbmRleEZpbHRlcih0LGUsbik7aWYoczw9MSlyZXR1cm4gcztjb25zdCBpPUQudmFsdWVPZihlLngpLnNlbGZBZGQoLXQueCkscj1ELnZhbHVlT2YoZS55KS5zZWxmQWRkKC10LnkpLG89RC52YWx1ZU9mKG4ueCkuc2VsZkFkZCgtZS54KSxsPUQudmFsdWVPZihuLnkpLnNlbGZBZGQoLWUueSk7cmV0dXJuIGkuc2VsZk11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChyLnNlbGZNdWx0aXBseShvKSkuc2lnbnVtKCl9c3RhdGljIHNpZ25PZkRldDJ4Migpe2lmKGFyZ3VtZW50c1szXWluc3RhbmNlb2YgRCYmYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBEJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM107cmV0dXJuIGFyZ3VtZW50c1swXS5tdWx0aXBseShuKS5zZWxmU3VidHJhY3QodC5tdWx0aXBseShlKSkuc2lnbnVtKCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1szXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1ELnZhbHVlT2YodCkscj1ELnZhbHVlT2YoZSksbz1ELnZhbHVlT2YobiksbD1ELnZhbHVlT2Yocyk7cmV0dXJuIGkubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHIubXVsdGlwbHkobykpLnNpZ251bSgpfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9bmV3IEQodC55KS5zZWxmU3VidHJhY3QoZS55KSxvPW5ldyBEKGUueCkuc2VsZlN1YnRyYWN0KHQueCksbD1uZXcgRCh0LngpLnNlbGZNdWx0aXBseShlLnkpLnNlbGZTdWJ0cmFjdChuZXcgRChlLngpLnNlbGZNdWx0aXBseSh0LnkpKSxhPW5ldyBEKG4ueSkuc2VsZlN1YnRyYWN0KHMueSksYz1uZXcgRChzLngpLnNlbGZTdWJ0cmFjdChuLngpLGg9bmV3IEQobi54KS5zZWxmTXVsdGlwbHkocy55KS5zZWxmU3VidHJhY3QobmV3IEQocy54KS5zZWxmTXVsdGlwbHkobi55KSksdT1vLm11bHRpcGx5KGgpLnNlbGZTdWJ0cmFjdChjLm11bHRpcGx5KGwpKSxnPWEubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KGkubXVsdGlwbHkoaCkpLGQ9aS5tdWx0aXBseShjKS5zZWxmU3VidHJhY3QoYS5tdWx0aXBseShvKSksXz11LnNlbGZEaXZpZGUoZCkuZG91YmxlVmFsdWUoKSxwPWcuc2VsZkRpdmlkZShkKS5kb3VibGVWYWx1ZSgpO3JldHVybiByLmlzTmFOKF8pfHxyLmlzSW5maW5pdGUoXyl8fHIuaXNOYU4ocCl8fHIuaXNJbmZpbml0ZShwKT9udWxsOm5ldyBtKF8scCl9c3RhdGljIG9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pe2xldCBzPW51bGw7Y29uc3QgaT0odC54LW4ueCkqKGUueS1uLnkpLHI9KHQueS1uLnkpKihlLngtbi54KSxvPWktcjtpZihpPjApe2lmKHI8PTApcmV0dXJuIEEuc2lnbnVtKG8pO3M9aStyfWVsc2V7aWYoIShpPDApKXJldHVybiBBLnNpZ251bShvKTtpZihyPj0wKXJldHVybiBBLnNpZ251bShvKTtzPS1pLXJ9Y29uc3QgbD1BLkRQX1NBRkVfRVBTSUxPTipzO3JldHVybiBvPj1sfHwtbz49bD9BLnNpZ251bShvKToyfXN0YXRpYyBzaWdudW0odCl7cmV0dXJuIHQ+MD8xOnQ8MD8tMTowfX1BLkRQX1NBRkVfRVBTSUxPTj0xZS0xNTtjbGFzcyBGe2dldE0odCl7aWYodGhpcy5oYXNNKCkpe2NvbnN0IGU9dGhpcy5nZXREaW1lbnNpb24oKS10aGlzLmdldE1lYXN1cmVzKCk7cmV0dXJuIHRoaXMuZ2V0T3JkaW5hdGUodCxlKX1yZXR1cm4gci5OYU59c2V0T3JkaW5hdGUodCxlLG4pe31nZXRaKHQpe3JldHVybiB0aGlzLmhhc1ooKT90aGlzLmdldE9yZGluYXRlKHQsMik6ci5OYU59c2l6ZSgpe31nZXRPcmRpbmF0ZSh0LGUpe31nZXRDb29yZGluYXRlKCl7fWdldENvb3JkaW5hdGVDb3B5KHQpe31jcmVhdGVDb29yZGluYXRlKCl7fWdldERpbWVuc2lvbigpe31oYXNNKCl7cmV0dXJuIHRoaXMuZ2V0TWVhc3VyZXMoKT4wfWdldFgodCl7fWhhc1ooKXtyZXR1cm4gdGhpcy5nZXREaW1lbnNpb24oKS10aGlzLmdldE1lYXN1cmVzKCk+Mn1nZXRNZWFzdXJlcygpe3JldHVybiAwfWV4cGFuZEVudmVsb3BlKHQpe31jb3B5KCl7fWdldFkodCl7fXRvQ29vcmRpbmF0ZUFycmF5KCl7fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19Ri5YPTAsRi5ZPTEsRi5aPTIsRi5NPTM7Y2xhc3MgR3tzdGF0aWMgaW5kZXgodCxlLG4pe3JldHVybiBBLm9yaWVudGF0aW9uSW5kZXgodCxlLG4pfXN0YXRpYyBpc0NDVygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5sZW5ndGgtMTtpZihlPDMpdGhyb3cgbmV3IHMoXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtsZXQgbj10WzBdLGk9MDtmb3IobGV0IHM9MTtzPD1lO3MrKyl7Y29uc3QgZT10W3NdO2UueT5uLnkmJihuPWUsaT1zKX1sZXQgcj1pO2Rve3ItPTEscjwwJiYocj1lKX13aGlsZSh0W3JdLmVxdWFsczJEKG4pJiZyIT09aSk7bGV0IG89aTtkb3tvPShvKzEpJWV9d2hpbGUodFtvXS5lcXVhbHMyRChuKSYmbyE9PWkpO2NvbnN0IGw9dFtyXSxhPXRbb107aWYobC5lcXVhbHMyRChuKXx8YS5lcXVhbHMyRChuKXx8bC5lcXVhbHMyRChhKSlyZXR1cm4hMTtjb25zdCBjPUcuaW5kZXgobCxuLGEpO2xldCBoPW51bGw7cmV0dXJuIGg9MD09PWM/bC54PmEueDpjPjAsaH1pZihJKGFyZ3VtZW50c1swXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKS0xO2lmKGU8Myl0aHJvdyBuZXcgcyhcIlJpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkXCIpO2xldCBuPXQuZ2V0Q29vcmRpbmF0ZSgwKSxpPTA7Zm9yKGxldCBzPTE7czw9ZTtzKyspe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKHMpO2UueT5uLnkmJihuPWUsaT1zKX1sZXQgcj1udWxsLG89aTtkb3tvLT0xLG88MCYmKG89ZSkscj10LmdldENvb3JkaW5hdGUobyl9d2hpbGUoci5lcXVhbHMyRChuKSYmbyE9PWkpO2xldCBsPW51bGwsYT1pO2Rve2E9KGErMSklZSxsPXQuZ2V0Q29vcmRpbmF0ZShhKX13aGlsZShsLmVxdWFsczJEKG4pJiZhIT09aSk7aWYoci5lcXVhbHMyRChuKXx8bC5lcXVhbHMyRChuKXx8ci5lcXVhbHMyRChsKSlyZXR1cm4hMTtjb25zdCBjPUcuaW5kZXgocixuLGwpO2xldCBoPW51bGw7cmV0dXJuIGg9MD09PWM/ci54PmwueDpjPjAsaH19fUcuQ0xPQ0tXSVNFPS0xLEcuUklHSFQ9Ry5DTE9DS1dJU0UsRy5DT1VOVEVSQ0xPQ0tXSVNFPTEsRy5MRUZUPUcuQ09VTlRFUkNMT0NLV0lTRSxHLkNPTExJTkVBUj0wLEcuU1RSQUlHSFQ9Ry5DT0xMSU5FQVI7Y2xhc3MgcXtzdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9dC54PGUueD90Lng6ZS54LG89dC55PGUueT90Lnk6ZS55LGw9dC54PmUueD90Lng6ZS54LGE9dC55PmUueT90Lnk6ZS55LGM9bi54PHMueD9uLng6cy54LGg9bi55PHMueT9uLnk6cy55LHU9bi54PnMueD9uLng6cy54LGc9bi55PnMueT9uLnk6cy55LGQ9KChpPmM/aTpjKSsobDx1P2w6dSkpLzIsXz0oKG8+aD9vOmgpKyhhPGc/YTpnKSkvMixwPXQueC1kLGY9dC55LV8seT1lLngtZCx4PWUueS1fLEU9bi54LWQsST1uLnktXyxOPXMueC1kLFM9cy55LV8sdz1mLXgsQz15LXAsTD1wKngteSpmLFQ9SS1TLFI9Ti1FLFA9RSpTLU4qSSxPPXcqUi1UKkMsdj0oQypQLVIqTCkvTyxNPShUKkwtdypQKS9PO3JldHVybiByLmlzTmFOKHYpfHxyLmlzSW5maW5pdGUodil8fHIuaXNOYU4oTSl8fHIuaXNJbmZpbml0ZShNKT9udWxsOm5ldyBtKHYrZCxNK18pfX1jbGFzcyBCe3N0YXRpYyBhcnJheWNvcHkodCxlLG4scyxpKXtsZXQgcj0wO2ZvcihsZXQgbz1lO288ZStpO28rKyluW3Mrcl09dFtvXSxyKyt9c3RhdGljIGdldFByb3BlcnR5KHQpe3JldHVybntcImxpbmUuc2VwYXJhdG9yXCI6XCJcXG5cIn1bdF19fWNsYXNzIFl7c3RhdGljIGxvZzEwKHQpe2NvbnN0IGU9TWF0aC5sb2codCk7cmV0dXJuIHIuaXNJbmZpbml0ZShlKXx8ci5pc05hTihlKT9lOmUvWS5MT0dfMTB9c3RhdGljIG1pbih0LGUsbixzKXtsZXQgaT10O3JldHVybiBlPGkmJihpPWUpLG48aSYmKGk9biksczxpJiYoaT1zKSxpfXN0YXRpYyBjbGFtcCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0PGU/ZTp0Pm4/bjp0fWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0PGU/ZTp0Pm4/bjp0fX1zdGF0aWMgd3JhcCh0LGUpe3JldHVybiB0PDA/ZS0gLXQlZTp0JWV9c3RhdGljIG1heCgpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXTtsZXQgbj1hcmd1bWVudHNbMF07cmV0dXJuIHQ+biYmKG49dCksZT5uJiYobj1lKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXTtsZXQgcz1hcmd1bWVudHNbMF07cmV0dXJuIHQ+cyYmKHM9dCksZT5zJiYocz1lKSxuPnMmJihzPW4pLHN9fXN0YXRpYyBhdmVyYWdlKHQsZSl7cmV0dXJuKHQrZSkvMn19WS5MT0dfMTA9TWF0aC5sb2coMTApO2NsYXNzIFZ7c3RhdGljIHNlZ21lbnRUb1NlZ21lbnQodCxlLG4scyl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIFYucG9pbnRUb1NlZ21lbnQodCxuLHMpO2lmKG4uZXF1YWxzKHMpKXJldHVybiBWLnBvaW50VG9TZWdtZW50KHMsdCxlKTtsZXQgaT0hMTtpZihPLmludGVyc2VjdHModCxlLG4scykpe2NvbnN0IHI9KGUueC10LngpKihzLnktbi55KS0oZS55LXQueSkqKHMueC1uLngpO2lmKDA9PT1yKWk9ITA7ZWxzZXtjb25zdCBvPSh0Lnktbi55KSoocy54LW4ueCktKHQueC1uLngpKihzLnktbi55KSxsPSgodC55LW4ueSkqKGUueC10LngpLSh0Lngtbi54KSooZS55LXQueSkpL3IsYT1vL3I7KGE8MHx8YT4xfHxsPDB8fGw+MSkmJihpPSEwKX19ZWxzZSBpPSEwO3JldHVybiBpP1kubWluKFYucG9pbnRUb1NlZ21lbnQodCxuLHMpLFYucG9pbnRUb1NlZ21lbnQoZSxuLHMpLFYucG9pbnRUb1NlZ21lbnQobix0LGUpLFYucG9pbnRUb1NlZ21lbnQocyx0LGUpKTowfXN0YXRpYyBwb2ludFRvU2VnbWVudCh0LGUsbil7aWYoZS54PT09bi54JiZlLnk9PT1uLnkpcmV0dXJuIHQuZGlzdGFuY2UoZSk7Y29uc3Qgcz0obi54LWUueCkqKG4ueC1lLngpKyhuLnktZS55KSoobi55LWUueSksaT0oKHQueC1lLngpKihuLngtZS54KSsodC55LWUueSkqKG4ueS1lLnkpKS9zO2lmKGk8PTApcmV0dXJuIHQuZGlzdGFuY2UoZSk7aWYoaT49MSlyZXR1cm4gdC5kaXN0YW5jZShuKTtjb25zdCByPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb0xpbmVQZXJwZW5kaWN1bGFyKHQsZSxuKXtjb25zdCBzPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxpPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKGkpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb1NlZ21lbnRTdHJpbmcodCxlKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IHMoXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2xldCBuPXQuZGlzdGFuY2UoZVswXSk7Zm9yKGxldCBzPTA7czxlLmxlbmd0aC0xO3MrKyl7Y29uc3QgaT1WLnBvaW50VG9TZWdtZW50KHQsZVtzXSxlW3MrMV0pO2k8biYmKG49aSl9cmV0dXJuIG59fWNsYXNzIHp7Y3JlYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheXx8SShhcmd1bWVudHNbMF0sRik7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY3JlYXRlKHQsZSl9fX1jbGFzcyBre2ZpbHRlcih0KXt9fWNsYXNzIFh7Y29uc3RydWN0b3IoKXtYLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNHZW9tZXRyeUNvbGxlY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRUeXBlQ29kZSgpPT09WC5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT059Z2V0RmFjdG9yeSgpe3JldHVybiB0aGlzLl9mYWN0b3J5fWdldEdlb21ldHJ5Tih0KXtyZXR1cm4gdGhpc31nZXRBcmVhKCl7cmV0dXJuIDB9aXNSZWN0YW5nbGUoKXtyZXR1cm4hMX1lcXVhbHNFeGFjdCh0KXtyZXR1cm4gdGhpcz09PXR8fHRoaXMuZXF1YWxzRXhhY3QodCwwKX1nZW9tZXRyeUNoYW5nZWQoKXt0aGlzLmFwcGx5KFguZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyKX1nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKXt0aGlzLl9lbnZlbG9wZT1udWxsfWVxdWFsc05vcm0odCl7cmV0dXJuIG51bGwhPT10JiZ0aGlzLm5vcm0oKS5lcXVhbHNFeGFjdCh0Lm5vcm0oKSl9Z2V0TGVuZ3RoKCl7cmV0dXJuIDB9Z2V0TnVtR2VvbWV0cmllcygpe3JldHVybiAxfWNvbXBhcmVUbygpe2xldCB0O2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdD1lLHRoaXMuZ2V0VHlwZUNvZGUoKSE9PXQuZ2V0VHlwZUNvZGUoKT90aGlzLmdldFR5cGVDb2RlKCktdC5nZXRUeXBlQ29kZSgpOnRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOnQuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MoZSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0PWUsdGhpcy5nZXRUeXBlQ29kZSgpIT09dC5nZXRUeXBlQ29kZSgpP3RoaXMuZ2V0VHlwZUNvZGUoKS10LmdldFR5cGVDb2RlKCk6dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6dC5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhlLG4pfX1nZXRVc2VyRGF0YSgpe3JldHVybiB0aGlzLl91c2VyRGF0YX1nZXRTUklEKCl7cmV0dXJuIHRoaXMuX1NSSUR9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeSh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9Y2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCl7aWYodC5nZXRUeXBlQ29kZSgpPT09WC5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT04pdGhyb3cgbmV3IHMoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIil9ZXF1YWwodCxlLG4pe3JldHVybiAwPT09bj90LmVxdWFscyhlKTp0LmRpc3RhbmNlKGUpPD1ufW5vcm0oKXtjb25zdCB0PXRoaXMuY29weSgpO3JldHVybiB0Lm5vcm1hbGl6ZSgpLHR9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5yZXZlcnNlSW50ZXJuYWwoKTtyZXR1cm4gbnVsbCE9dGhpcy5lbnZlbG9wZSYmKHQuZW52ZWxvcGU9dGhpcy5lbnZlbG9wZS5jb3B5KCkpLHQuc2V0U1JJRCh0aGlzLmdldFNSSUQoKSksdH1jb3B5KCl7Y29uc3QgdD10aGlzLmNvcHlJbnRlcm5hbCgpO3JldHVybiB0LmVudmVsb3BlPW51bGw9PXRoaXMuX2VudmVsb3BlP251bGw6dGhpcy5fZW52ZWxvcGUuY29weSgpLHQuX1NSSUQ9dGhpcy5fU1JJRCx0Ll91c2VyRGF0YT10aGlzLl91c2VyRGF0YSx0fWdldFByZWNpc2lvbk1vZGVsKCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX1nZXRFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lbnZlbG9wZSYmKHRoaXMuX2VudmVsb3BlPXRoaXMuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKSksbmV3IE8odGhpcy5fZW52ZWxvcGUpfXNldFNSSUQodCl7dGhpcy5fU1JJRD10fXNldFVzZXJEYXRhKHQpe3RoaXMuX3VzZXJEYXRhPXR9Y29tcGFyZSh0LGUpe2NvbnN0IG49dC5pdGVyYXRvcigpLHM9ZS5pdGVyYXRvcigpO2Zvcig7bi5oYXNOZXh0KCkmJnMuaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxlPXMubmV4dCgpLGk9dC5jb21wYXJlVG8oZSk7aWYoMCE9PWkpcmV0dXJuIGl9cmV0dXJuIG4uaGFzTmV4dCgpPzE6cy5oYXNOZXh0KCk/LTE6MH1oYXNoQ29kZSgpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpfWlzRXF1aXZhbGVudENsYXNzKHQpe3JldHVybiB0aGlzLmdldENsYXNzKCk9PT10LmdldENsYXNzKCl9aXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQoKXtyZXR1cm4gdGhpcy5nZXRUeXBlQ29kZSgpPT09WC5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT058fHRoaXMuZ2V0VHlwZUNvZGUoKT09PVguVFlQRUNPREVfTVVMVElQT0lOVHx8dGhpcy5nZXRUeXBlQ29kZSgpPT09WC5UWVBFQ09ERV9NVUxUSUxJTkVTVFJJTkd8fHRoaXMuZ2V0VHlwZUNvZGUoKT09PVguVFlQRUNPREVfTVVMVElQT0xZR09OfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsLG8sY119Z2V0Q2xhc3MoKXtyZXR1cm4gWH1zdGF0aWMgaGFzTm9uRW1wdHlFbGVtZW50cyh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZighdFtlXS5pc0VtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIGhhc051bGxFbGVtZW50cyh0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZihudWxsPT09dFtlXSlyZXR1cm4hMDtyZXR1cm4hMX19WC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24odCl7dCYmKHRoaXMuX2VudmVsb3BlPW51bGwsdGhpcy5fdXNlckRhdGE9bnVsbCx0aGlzLl9mYWN0b3J5PXQsdGhpcy5fU1JJRD10LmdldFNSSUQoKSl9LFguVFlQRUNPREVfUE9JTlQ9MCxYLlRZUEVDT0RFX01VTFRJUE9JTlQ9MSxYLlRZUEVDT0RFX0xJTkVTVFJJTkc9MixYLlRZUEVDT0RFX0xJTkVBUlJJTkc9MyxYLlRZUEVDT0RFX01VTFRJTElORVNUUklORz00LFguVFlQRUNPREVfUE9MWUdPTj01LFguVFlQRUNPREVfTVVMVElQT0xZR09OPTYsWC5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT049NyxYLlRZUEVOQU1FX1BPSU5UPVwiUG9pbnRcIixYLlRZUEVOQU1FX01VTFRJUE9JTlQ9XCJNdWx0aVBvaW50XCIsWC5UWVBFTkFNRV9MSU5FU1RSSU5HPVwiTGluZVN0cmluZ1wiLFguVFlQRU5BTUVfTElORUFSUklORz1cIkxpbmVhclJpbmdcIixYLlRZUEVOQU1FX01VTFRJTElORVNUUklORz1cIk11bHRpTGluZVN0cmluZ1wiLFguVFlQRU5BTUVfUE9MWUdPTj1cIlBvbHlnb25cIixYLlRZUEVOQU1FX01VTFRJUE9MWUdPTj1cIk11bHRpUG9seWdvblwiLFguVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OPVwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsWC5nZW9tZXRyeUNoYW5nZWRGaWx0ZXI9e2dldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX0sZmlsdGVyKHQpe3QuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl9fTtjbGFzcyBVe2ZpbHRlcih0KXt9fWNsYXNzIEh7c3RhdGljIG9mTGluZSh0KXtjb25zdCBlPXQuc2l6ZSgpO2lmKGU8PTEpcmV0dXJuIDA7bGV0IG49MDtjb25zdCBzPW5ldyBtO3QuZ2V0Q29vcmRpbmF0ZSgwLHMpO2xldCBpPXMueCxyPXMueTtmb3IobGV0IG89MTtvPGU7bysrKXt0LmdldENvb3JkaW5hdGUobyxzKTtjb25zdCBlPXMueCxsPXMueSxhPWUtaSxjPWwtcjtuKz1NYXRoLnNxcnQoYSphK2MqYyksaT1lLHI9bH1yZXR1cm4gbn19Y2xhc3MgV3t9Y2xhc3MgWntzdGF0aWMgY29weUNvb3JkKHQsZSxuLHMpe2NvbnN0IGk9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxuLmdldERpbWVuc2lvbigpKTtmb3IobGV0IHI9MDtyPGk7cisrKW4uc2V0T3JkaW5hdGUocyxyLHQuZ2V0T3JkaW5hdGUoZSxyKSl9c3RhdGljIGlzUmluZyh0KXtjb25zdCBlPXQuc2l6ZSgpO3JldHVybiAwPT09ZXx8IShlPD0zKSYmKHQuZ2V0T3JkaW5hdGUoMCxGLlgpPT09dC5nZXRPcmRpbmF0ZShlLTEsRi5YKSYmdC5nZXRPcmRpbmF0ZSgwLEYuWSk9PT10LmdldE9yZGluYXRlKGUtMSxGLlkpKX1zdGF0aWMgc2Nyb2xsKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLEYpJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1ouc2Nyb2xsKHQsZSxaLmlzUmluZyh0KSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxGKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPVouaW5kZXhPZihlLHQpO2lmKG48PTApcmV0dXJuIG51bGw7Wi5zY3JvbGwodCxuKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZTw9MClyZXR1cm4gbnVsbDtjb25zdCBzPXQuY29weSgpLGk9bj90LnNpemUoKS0xOnQuc2l6ZSgpO2ZvcihsZXQgbj0wO248aTtuKyspZm9yKGxldCByPTA7cjx0LmdldERpbWVuc2lvbigpO3IrKyl0LnNldE9yZGluYXRlKG4scixzLmdldE9yZGluYXRlKChlK24pJWkscikpO2lmKG4pZm9yKGxldCBlPTA7ZTx0LmdldERpbWVuc2lvbigpO2UrKyl0LnNldE9yZGluYXRlKGksZSx0LmdldE9yZGluYXRlKDAsZSkpfX1zdGF0aWMgaXNFcXVhbCh0LGUpe2NvbnN0IG49dC5zaXplKCk7aWYobiE9PWUuc2l6ZSgpKXJldHVybiExO2NvbnN0IHM9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgbj0wO248cztuKyspe2NvbnN0IHM9dC5nZXRPcmRpbmF0ZShpLG4pLG89ZS5nZXRPcmRpbmF0ZShpLG4pO2lmKHQuZ2V0T3JkaW5hdGUoaSxuKSE9PWUuZ2V0T3JkaW5hdGUoaSxuKSYmKCFyLmlzTmFOKHMpfHwhci5pc05hTihvKSkpcmV0dXJuITF9cmV0dXJuITB9c3RhdGljIG1pbkNvb3JkaW5hdGVJbmRleCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gWi5taW5Db29yZGluYXRlSW5kZXgodCwwLHQuc2l6ZSgpLTEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXTtsZXQgbj0tMSxzPW51bGw7Zm9yKGxldCBpPWFyZ3VtZW50c1sxXTtpPD1lO2krKyl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoaSk7KG51bGw9PT1zfHxzLmNvbXBhcmVUbyhlKT4wKSYmKHM9ZSxuPWkpfXJldHVybiBufX1zdGF0aWMgZXh0ZW5kKHQsZSxuKXtjb25zdCBzPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSksaT1lLnNpemUoKTtpZihaLmNvcHkoZSwwLHMsMCxpKSxpPjApZm9yKGxldCB0PWk7dDxuO3QrKylaLmNvcHkoZSxpLTEscyx0LDEpO3JldHVybiBzfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5zaXplKCktMSxuPU1hdGgudHJ1bmMoZS8yKTtmb3IobGV0IHM9MDtzPD1uO3MrKylaLnN3YXAodCxzLGUtcyl9c3RhdGljIHN3YXAodCxlLG4pe2lmKGU9PT1uKXJldHVybiBudWxsO2ZvcihsZXQgcz0wO3M8dC5nZXREaW1lbnNpb24oKTtzKyspe2NvbnN0IGk9dC5nZXRPcmRpbmF0ZShlLHMpO3Quc2V0T3JkaW5hdGUoZSxzLHQuZ2V0T3JkaW5hdGUobixzKSksdC5zZXRPcmRpbmF0ZShuLHMsaSl9fXN0YXRpYyBjb3B5KHQsZSxuLHMsaSl7Zm9yKGxldCByPTA7cjxpO3IrKylaLmNvcHlDb29yZCh0LGUrcixuLHMrcil9c3RhdGljIGVuc3VyZVZhbGlkUmluZyh0LGUpe2NvbnN0IG49ZS5zaXplKCk7aWYoMD09PW4pcmV0dXJuIGU7aWYobjw9MylyZXR1cm4gWi5jcmVhdGVDbG9zZWRSaW5nKHQsZSw0KTtyZXR1cm4gZS5nZXRPcmRpbmF0ZSgwLEYuWCk9PT1lLmdldE9yZGluYXRlKG4tMSxGLlgpJiZlLmdldE9yZGluYXRlKDAsRi5ZKT09PWUuZ2V0T3JkaW5hdGUobi0xLEYuWSk/ZTpaLmNyZWF0ZUNsb3NlZFJpbmcodCxlLG4rMSl9c3RhdGljIGluZGV4T2YodCxlKXtmb3IobGV0IG49MDtuPGUuc2l6ZSgpO24rKylpZih0Lng9PT1lLmdldE9yZGluYXRlKG4sRi5YKSYmdC55PT09ZS5nZXRPcmRpbmF0ZShuLEYuWSkpcmV0dXJuIG47cmV0dXJuLTF9c3RhdGljIGNyZWF0ZUNsb3NlZFJpbmcodCxlLG4pe2NvbnN0IHM9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxpPWUuc2l6ZSgpO1ouY29weShlLDAscywwLGkpO2ZvcihsZXQgdD1pO3Q8bjt0KyspWi5jb3B5KGUsMCxzLHQsMSk7cmV0dXJuIHN9c3RhdGljIG1pbkNvb3JkaW5hdGUodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10LmdldENvb3JkaW5hdGUobik7KG51bGw9PT1lfHxlLmNvbXBhcmVUbyhzKT4wKSYmKGU9cyl9cmV0dXJuIGV9fWNsYXNzIGogZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7VW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb246an0pWzBdfX1jbGFzcyBLe3N0YXRpYyB0b0RpbWVuc2lvblN5bWJvbCh0KXtzd2l0Y2godCl7Y2FzZSBLLkZBTFNFOnJldHVybiBLLlNZTV9GQUxTRTtjYXNlIEsuVFJVRTpyZXR1cm4gSy5TWU1fVFJVRTtjYXNlIEsuRE9OVENBUkU6cmV0dXJuIEsuU1lNX0RPTlRDQVJFO2Nhc2UgSy5QOnJldHVybiBLLlNZTV9QO2Nhc2UgSy5MOnJldHVybiBLLlNZTV9MO2Nhc2UgSy5BOnJldHVybiBLLlNZTV9BfXRocm93IG5ldyBzKFwiVW5rbm93biBkaW1lbnNpb24gdmFsdWU6IFwiK3QpfXN0YXRpYyB0b0RpbWVuc2lvblZhbHVlKHQpe3N3aXRjaChiLnRvVXBwZXJDYXNlKHQpKXtjYXNlIEsuU1lNX0ZBTFNFOnJldHVybiBLLkZBTFNFO2Nhc2UgSy5TWU1fVFJVRTpyZXR1cm4gSy5UUlVFO2Nhc2UgSy5TWU1fRE9OVENBUkU6cmV0dXJuIEsuRE9OVENBUkU7Y2FzZSBLLlNZTV9QOnJldHVybiBLLlA7Y2FzZSBLLlNZTV9MOnJldHVybiBLLkw7Y2FzZSBLLlNZTV9BOnJldHVybiBLLkF9dGhyb3cgbmV3IHMoXCJVbmtub3duIGRpbWVuc2lvbiBzeW1ib2w6IFwiK3QpfX1LLlA9MCxLLkw9MSxLLkE9MixLLkZBTFNFPS0xLEsuVFJVRT0tMixLLkRPTlRDQVJFPS0zLEsuU1lNX0ZBTFNFPVwiRlwiLEsuU1lNX1RSVUU9XCJUXCIsSy5TWU1fRE9OVENBUkU9XCIqXCIsSy5TWU1fUD1cIjBcIixLLlNZTV9MPVwiMVwiLEsuU1lNX0E9XCIyXCI7Y2xhc3MgUXtmaWx0ZXIodCl7fX1jbGFzcyBKIGV4dGVuZHMgWHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wb2ludHM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07WC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX19Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bmV3IE86dGhpcy5fcG9pbnRzLmV4cGFuZEVudmVsb3BlKG5ldyBPKX1pc1JpbmcoKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpJiZ0aGlzLmlzU2ltcGxlKCl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KCl9Y29weUludGVybmFsKCl7cmV0dXJuIG5ldyBKKHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQ7aWYodGhpcy5fcG9pbnRzLnNpemUoKSE9PW4uX3BvaW50cy5zaXplKCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9wb2ludHMuc2l6ZSgpO3QrKylpZighdGhpcy5lcXVhbCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxuLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8TWF0aC50cnVuYyh0aGlzLl9wb2ludHMuc2l6ZSgpLzIpO3QrKyl7Y29uc3QgZT10aGlzLl9wb2ludHMuc2l6ZSgpLTEtdDtpZighdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuZXF1YWxzKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKSl7aWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuY29tcGFyZVRvKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKT4wKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7Wi5yZXZlcnNlKHQpLHRoaXMuX3BvaW50cz10fXJldHVybiBudWxsfX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKDApfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9LLkZBTFNFOjB9aXNDbG9zZWQoKXtyZXR1cm4hdGhpcy5pc0VtcHR5KCkmJnRoaXMuZ2V0Q29vcmRpbmF0ZU4oMCkuZXF1YWxzMkQodGhpcy5nZXRDb29yZGluYXRlTih0aGlzLmdldE51bVBvaW50cygpLTEpKX1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7cmV0dXJuIFoucmV2ZXJzZSh0KSx0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQpfWdldEVuZFBvaW50KCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4odGhpcy5nZXROdW1Qb2ludHMoKS0xKX1nZXRUeXBlQ29kZSgpe3JldHVybiBYLlRZUEVDT0RFX0xJTkVTVFJJTkd9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0TGVuZ3RoKCl7cmV0dXJuIEgub2ZMaW5lKHRoaXMuX3BvaW50cyl9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMuX3BvaW50cy5zaXplKCl9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPTAsbj0wO2Zvcig7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpJiZuPHQuX3BvaW50cy5zaXplKCk7KXtjb25zdCBzPXRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpLmNvbXBhcmVUbyh0Ll9wb2ludHMuZ2V0Q29vcmRpbmF0ZShuKSk7aWYoMCE9PXMpcmV0dXJuIHM7ZSsrLG4rK31yZXR1cm4gZTx0aGlzLl9wb2ludHMuc2l6ZSgpPzE6bjx0Ll9wb2ludHMuc2l6ZSgpPy0xOjB9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBhcmd1bWVudHNbMV0uY29tcGFyZSh0aGlzLl9wb2ludHMsdC5fcG9pbnRzKX19YXBwbHkoKXtpZihJKGFyZ3VtZW50c1swXSxVKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpO2UrKyl0LmZpbHRlcih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxQKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuX3BvaW50cy5zaXplKCkpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpJiYodC5maWx0ZXIodGhpcy5fcG9pbnRzLGUpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFEpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9fWdldEJvdW5kYXJ5KCl7dGhyb3cgbmV3IGp9aXNFcXVpdmFsZW50Q2xhc3ModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBKfWdldENvb3JkaW5hdGVOKHQpe3JldHVybiB0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gWC5UWVBFTkFNRV9MSU5FU1RSSU5HfWdldENvb3JkaW5hdGVTZXF1ZW5jZSgpe3JldHVybiB0aGlzLl9wb2ludHN9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fcG9pbnRzLnNpemUoKX1pbml0KHQpe2lmKG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksMT09PXQuc2l6ZSgpKXRocm93IG5ldyBzKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVTdHJpbmcgKGZvdW5kIFwiK3Quc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDIpXCIpO3RoaXMuX3BvaW50cz10fWlzQ29vcmRpbmF0ZSh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCk7ZSsrKWlmKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpLmVxdWFscyh0KSlyZXR1cm4hMDtyZXR1cm4hMX1nZXRTdGFydFBvaW50KCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4oMCl9Z2V0UG9pbnROKHQpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ddfX1jbGFzcyAke31jbGFzcyB0dCBleHRlbmRzIFh7Y29uc3RydWN0b3IoKXtzdXBlcigpLHR0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3JkaW5hdGVzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07WC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBuZXcgTztjb25zdCB0PW5ldyBPO3JldHVybiB0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlcy5nZXRYKDApLHRoaXMuX2Nvb3JkaW5hdGVzLmdldFkoMCkpLHR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/W106W3RoaXMuZ2V0Q29vcmRpbmF0ZSgpXX1jb3B5SW50ZXJuYWwoKXtyZXR1cm4gbmV3IHR0KHRoaXMuX2Nvb3JkaW5hdGVzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmKCEoIXRoaXMuaXNFbXB0eSgpfHwhdC5pc0VtcHR5KCkpfHx0aGlzLmlzRW1wdHkoKT09PXQuaXNFbXB0eSgpJiZ0aGlzLmVxdWFsKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe31nZXRDb29yZGluYXRlKCl7cmV0dXJuIDAhPT10aGlzLl9jb29yZGluYXRlcy5zaXplKCk/dGhpcy5fY29vcmRpbmF0ZXMuZ2V0Q29vcmRpbmF0ZSgwKTpudWxsfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIEsuRkFMU0V9cmV2ZXJzZUludGVybmFsKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2Nvb3JkaW5hdGVzLmNvcHkoKSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gWC5UWVBFQ09ERV9QT0lOVH1nZXREaW1lbnNpb24oKXtyZXR1cm4gMH1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoxfWdldFgoKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFggY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS54fWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1sxXS5jb21wYXJlKHRoaXMuX2Nvb3JkaW5hdGVzLHQuX2Nvb3JkaW5hdGVzKX19YXBwbHkoKXtpZihJKGFyZ3VtZW50c1swXSxVKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuX2Nvb3JkaW5hdGVzLDApLHQuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFEpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX1BPSU5UfWdldENvb3JkaW5hdGVTZXF1ZW5jZSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc31nZXRZKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRZIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9jb29yZGluYXRlcy5zaXplKCl9aW5pdCh0KXtudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLGcuaXNUcnVlKHQuc2l6ZSgpPD0xKSx0aGlzLl9jb29yZGluYXRlcz10fWlzU2ltcGxlKCl7cmV0dXJuITB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuWyRdfX1jbGFzcyBldHtzdGF0aWMgb2ZSaW5nKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYWJzKGV0Lm9mUmluZ1NpZ25lZCh0KSl9aWYoSShhcmd1bWVudHNbMF0sRikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmFicyhldC5vZlJpbmdTaWduZWQodCkpfX1zdGF0aWMgb2ZSaW5nU2lnbmVkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5sZW5ndGg8MylyZXR1cm4gMDtsZXQgZT0wO2NvbnN0IG49dFswXS54O2ZvcihsZXQgcz0xO3M8dC5sZW5ndGgtMTtzKyspe2NvbnN0IGk9dFtzXS54LW4scj10W3MrMV0ueTtlKz1pKih0W3MtMV0ueS1yKX1yZXR1cm4gZS8yfWlmKEkoYXJndW1lbnRzWzBdLEYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpO2lmKGU8MylyZXR1cm4gMDtjb25zdCBuPW5ldyBtLHM9bmV3IG0saT1uZXcgbTt0LmdldENvb3JkaW5hdGUoMCxzKSx0LmdldENvb3JkaW5hdGUoMSxpKTtjb25zdCByPXMueDtpLngtPXI7bGV0IG89MDtmb3IobGV0IGw9MTtsPGUtMTtsKyspbi55PXMueSxzLng9aS54LHMueT1pLnksdC5nZXRDb29yZGluYXRlKGwrMSxpKSxpLngtPXIsbys9cy54KihuLnktaS55KTtyZXR1cm4gby8yfX19Y2xhc3MgbnR7c3RhdGljIHNvcnQoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl0LnNvcnQoKCh0LGUpPT50LmNvbXBhcmVUbyhlKSkpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpdC5zb3J0KCgodCxlKT0+YXJndW1lbnRzWzFdLmNvbXBhcmUodCxlKSkpO2Vsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9dC5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKTtlLnNvcnQoKTtjb25zdCBuPXQuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChlLHQuc2xpY2UoYXJndW1lbnRzWzJdLHQubGVuZ3RoKSk7dC5zcGxpY2UoMCx0Lmxlbmd0aCk7Zm9yKGNvbnN0IGUgb2Ygbil0LnB1c2goZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT10LnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO2Uuc29ydCgoKHQsZSk9PmFyZ3VtZW50c1szXS5jb21wYXJlKHQsZSkpKTtjb25zdCBuPXQuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChlLHQuc2xpY2UoYXJndW1lbnRzWzJdLHQubGVuZ3RoKSk7dC5zcGxpY2UoMCx0Lmxlbmd0aCk7Zm9yKGNvbnN0IGUgb2Ygbil0LnB1c2goZSl9fXN0YXRpYyBhc0xpc3QodCl7Y29uc3QgZT1uZXcgTDtmb3IoY29uc3QgbiBvZiB0KWUuYWRkKG4pO3JldHVybiBlfXN0YXRpYyBjb3B5T2YodCxlKXtyZXR1cm4gdC5zbGljZSgwLGUpfX1jbGFzcyBzdHt9Y2xhc3MgaXQgZXh0ZW5kcyBYe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxpdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2hvbGVzPW51bGw7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKFguY29uc3RydWN0b3JfLmNhbGwodGhpcyxuKSxudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZygpKSxudWxsPT09ZSYmKGU9W10pLFguaGFzTnVsbEVsZW1lbnRzKGUpKXRocm93IG5ldyBzKFwiaG9sZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO2lmKHQuaXNFbXB0eSgpJiZYLmhhc05vbkVtcHR5RWxlbWVudHMoZSkpdGhyb3cgbmV3IHMoXCJzaGVsbCBpcyBlbXB0eSBidXQgaG9sZXMgYXJlIG5vdFwiKTt0aGlzLl9zaGVsbD10LHRoaXMuX2hvbGVzPWV9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5fc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWdldENvb3JkaW5hdGVzKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuW107Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtsZXQgZT0tMTtjb25zdCBuPXRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspZSsrLHRbZV09bltzXTtmb3IobGV0IG49MDtuPHRoaXMuX2hvbGVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dGhpcy5faG9sZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyllKyssdFtlXT1zW25dfXJldHVybiB0fWdldEFyZWEoKXtsZXQgdD0wO3QrPWV0Lm9mUmluZyh0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQtPWV0Lm9mUmluZyh0aGlzLl9ob2xlc1tlXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHR9Y29weUludGVybmFsKCl7Y29uc3QgdD10aGlzLl9zaGVsbC5jb3B5KCksZT1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKyllW3RdPXRoaXMuX2hvbGVzW3RdLmNvcHkoKTtyZXR1cm4gbmV3IGl0KHQsZSx0aGlzLl9mYWN0b3J5KX1pc1JlY3RhbmdsZSgpe2lmKDAhPT10aGlzLmdldE51bUludGVyaW9yUmluZygpKXJldHVybiExO2lmKG51bGw9PT10aGlzLl9zaGVsbClyZXR1cm4hMTtpZig1IT09dGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCkpcmV0dXJuITE7Y29uc3QgdD10aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxlPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2ZvcihsZXQgbj0wO248NTtuKyspe2NvbnN0IHM9dC5nZXRYKG4pO2lmKHMhPT1lLmdldE1pblgoKSYmcyE9PWUuZ2V0TWF4WCgpKXJldHVybiExO2NvbnN0IGk9dC5nZXRZKG4pO2lmKGkhPT1lLmdldE1pblkoKSYmaSE9PWUuZ2V0TWF4WSgpKXJldHVybiExfWxldCBuPXQuZ2V0WCgwKSxzPXQuZ2V0WSgwKTtmb3IobGV0IGU9MTtlPD00O2UrKyl7Y29uc3QgaT10LmdldFgoZSkscj10LmdldFkoZSk7aWYoaSE9PW49PT0ociE9PXMpKXJldHVybiExO249aSxzPXJ9cmV0dXJuITB9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQscz10aGlzLl9zaGVsbCxpPW4uX3NoZWxsO2lmKCFzLmVxdWFsc0V4YWN0KGksZSkpcmV0dXJuITE7aWYodGhpcy5faG9sZXMubGVuZ3RoIT09bi5faG9sZXMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKylpZighdGhpcy5faG9sZXNbdF0uZXF1YWxzRXhhY3Qobi5faG9sZXNbdF0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5fc2hlbGw9dGhpcy5ub3JtYWxpemVkKHRoaXMuX3NoZWxsLCEwKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspdGhpcy5faG9sZXNbdF09dGhpcy5ub3JtYWxpemVkKHRoaXMuX2hvbGVzW3RdLCExKTtudC5zb3J0KHRoaXMuX2hvbGVzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkscz1aLm1pbkNvb3JkaW5hdGVJbmRleChuLDAsbi5zaXplKCktMik7Wi5zY3JvbGwobixzLCEwKSxHLmlzQ0NXKG4pPT09ZSYmWi5yZXZlcnNlKG4pfX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGUoKX1nZXROdW1JbnRlcmlvclJpbmcoKXtyZXR1cm4gdGhpcy5faG9sZXMubGVuZ3RofWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIDF9cmV2ZXJzZUludGVybmFsKCl7Y29uc3QgdD10aGlzLmdldEV4dGVyaW9yUmluZygpLnJldmVyc2UoKSxlPW5ldyBBcnJheSh0aGlzLmdldE51bUludGVyaW9yUmluZygpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF09dGhpcy5nZXRJbnRlcmlvclJpbmdOKHQpLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbih0LGUpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFguVFlQRUNPREVfUE9MWUdPTn1nZXREaW1lbnNpb24oKXtyZXR1cm4gMn1nZXRMZW5ndGgoKXtsZXQgdD0wO3QrPXRoaXMuX3NoZWxsLmdldExlbmd0aCgpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9ob2xlc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH1nZXROdW1Qb2ludHMoKXtsZXQgdD10aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5faG9sZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9Y29udmV4SHVsbCgpe3JldHVybiB0aGlzLmdldEV4dGVyaW9yUmluZygpLmNvbnZleEh1bGwoKX1ub3JtYWxpemVkKHQsZSl7Y29uc3Qgbj10LmNvcHkoKTtyZXR1cm4gdGhpcy5ub3JtYWxpemUobixlKSxufWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX3NoZWxsLG49dC5fc2hlbGw7cmV0dXJuIGUuY29tcGFyZVRvU2FtZUNsYXNzKG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXSxuPXRoaXMuX3NoZWxsLHM9ZS5fc2hlbGwsaT1uLmNvbXBhcmVUb1NhbWVDbGFzcyhzLHQpO2lmKDAhPT1pKXJldHVybiBpO2NvbnN0IHI9dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSxvPWUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bGV0IGw9MDtmb3IoO2w8ciYmbDxvOyl7Y29uc3Qgbj10aGlzLmdldEludGVyaW9yUmluZ04obCkscz1lLmdldEludGVyaW9yUmluZ04obCksaT1uLmNvbXBhcmVUb1NhbWVDbGFzcyhzLHQpO2lmKDAhPT1pKXJldHVybiBpO2wrK31yZXR1cm4gbDxyPzE6bDxvPy0xOjB9fWFwcGx5KCl7aWYoSShhcmd1bWVudHNbMF0sVSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NoZWxsLmFwcGx5KHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0aGlzLl9ob2xlc1tlXS5hcHBseSh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFApKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl9zaGVsbC5hcHBseSh0KSwhdC5pc0RvbmUoKSlmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aCYmKHRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFEpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpLHRoaXMuX3NoZWxsLmFwcGx5KHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0aGlzLl9ob2xlc1tlXS5hcHBseSh0KX19Z2V0Qm91bmRhcnkoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKzEpLmZpbGwobnVsbCk7dFswXT10aGlzLl9zaGVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdFtlKzFdPXRoaXMuX2hvbGVzW2VdO3JldHVybiB0Lmxlbmd0aDw9MT90aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHRbMF0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpOnRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0KX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gWC5UWVBFTkFNRV9QT0xZR09OfWdldEV4dGVyaW9yUmluZygpe3JldHVybiB0aGlzLl9zaGVsbH1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX3NoZWxsLmlzRW1wdHkoKX1nZXRJbnRlcmlvclJpbmdOKHQpe3JldHVybiB0aGlzLl9ob2xlc1t0XX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bc3RdfX1jbGFzcyBydCBleHRlbmRzIE57Y29udGFpbnMoKXt9fWNsYXNzIG90IGV4dGVuZHMgcnR7fWNsYXNzIGx0IGV4dGVuZHMgb3R7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmFycmF5PVtdLHQgaW5zdGFuY2VvZiBOJiZ0aGlzLmFkZEFsbCh0KX1jb250YWlucyh0KXtmb3IoY29uc3QgZSBvZiB0aGlzLmFycmF5KWlmKDA9PT1lLmNvbXBhcmVUbyh0KSlyZXR1cm4hMDtyZXR1cm4hMX1hZGQodCl7aWYodGhpcy5jb250YWlucyh0KSlyZXR1cm4hMTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXkubGVuZ3RoO2U8bjtlKyspe2lmKDE9PT10aGlzLmFycmF5W2VdLmNvbXBhcmVUbyh0KSlyZXR1cm4hIXRoaXMuYXJyYXkuc3BsaWNlKGUsMCx0KX1yZXR1cm4gdGhpcy5hcnJheS5wdXNoKHQpLCEwfWFkZEFsbCh0KXtmb3IoY29uc3QgZSBvZiB0KXRoaXMuYWRkKGUpO3JldHVybiEwfXJlbW92ZSgpe3Rocm93IG5ldyBqfXNpemUoKXtyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGh9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9dG9BcnJheSgpe3JldHVybiB0aGlzLmFycmF5LnNsaWNlKCl9aXRlcmF0b3IoKXtyZXR1cm4gbmV3IGF0KHRoaXMuYXJyYXkpfX1jbGFzcyBhdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmFycmF5PXQsdGhpcy5wb3NpdGlvbj0wfW5leHQoKXtpZih0aGlzLnBvc2l0aW9uPT09dGhpcy5hcnJheS5sZW5ndGgpdGhyb3cgbmV3IEM7cmV0dXJuIHRoaXMuYXJyYXlbdGhpcy5wb3NpdGlvbisrXX1oYXNOZXh0KCl7cmV0dXJuIHRoaXMucG9zaXRpb248dGhpcy5hcnJheS5sZW5ndGh9cmVtb3ZlKCl7dGhyb3cgbmV3IGp9fWNsYXNzIGN0IGV4dGVuZHMgWHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksY3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbWV0cmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoWC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLG51bGw9PT10JiYodD1bXSksWC5oYXNOdWxsRWxlbWVudHModCkpdGhyb3cgbmV3IHMoXCJnZW9tZXRyaWVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTt0aGlzLl9nZW9tZXRyaWVzPXR9fWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7Y29uc3QgdD1uZXcgTztmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9nZW9tZXRyaWVzW2VdLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIHR9Z2V0R2VvbWV0cnlOKHQpe3JldHVybiB0aGlzLl9nZW9tZXRyaWVzW3RdfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtsZXQgZT0tMTtmb3IobGV0IG49MDtuPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10aGlzLl9nZW9tZXRyaWVzW25dLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxzLmxlbmd0aDtuKyspZSsrLHRbZV09c1tuXX1yZXR1cm4gdH1nZXRBcmVhKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldEFyZWEoKTtyZXR1cm4gdH1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgY3QodCx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dDtpZih0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCE9PW4uX2dlb21ldHJpZXMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9nZW9tZXRyaWVzW3RdLmVxdWFsc0V4YWN0KG4uX2dlb21ldHJpZXNbdF0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKyl0aGlzLl9nZW9tZXRyaWVzW3RdLm5vcm1hbGl6ZSgpO250LnNvcnQodGhpcy5fZ2VvbWV0cmllcyl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuX2dlb21ldHJpZXNbMF0uZ2V0Q29vcmRpbmF0ZSgpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7bGV0IHQ9Sy5GQUxTRTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKTtyZXR1cm4gdH1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEwodCk7Zm9yKGxldCBuPTA7bjx0O24rKyllLmFkZCh0aGlzLl9nZW9tZXRyaWVzW25dLnJldmVyc2UoKSk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoZSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gWC5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT059Z2V0RGltZW5zaW9uKCl7bGV0IHQ9Sy5GQUxTRTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5fZ2VvbWV0cmllc1tlXS5nZXREaW1lbnNpb24oKSk7cmV0dXJuIHR9Z2V0TGVuZ3RoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fWdldE51bVBvaW50cygpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH1nZXROdW1HZW9tZXRyaWVzKCl7cmV0dXJuIHRoaXMuX2dlb21ldHJpZXMubGVuZ3RofWNvbXBhcmVUb1NhbWVDbGFzcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBsdChudC5hc0xpc3QodGhpcy5fZ2VvbWV0cmllcykpLG49bmV3IGx0KG50LmFzTGlzdCh0Ll9nZW9tZXRyaWVzKSk7cmV0dXJuIHRoaXMuY29tcGFyZShlLG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXSxuPXRoaXMuZ2V0TnVtR2VvbWV0cmllcygpLHM9ZS5nZXROdW1HZW9tZXRyaWVzKCk7bGV0IGk9MDtmb3IoO2k8biYmaTxzOyl7Y29uc3Qgbj10aGlzLmdldEdlb21ldHJ5TihpKSxzPWUuZ2V0R2VvbWV0cnlOKGkpLHI9bi5jb21wYXJlVG9TYW1lQ2xhc3Mocyx0KTtpZigwIT09cilyZXR1cm4gcjtpKyt9cmV0dXJuIGk8bj8xOmk8cz8tMTowfX1hcHBseSgpe2lmKEkoYXJndW1lbnRzWzBdLFUpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDA9PT10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoJiYodGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxRKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5fZ2VvbWV0cmllc1tlXS5hcHBseSh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLGspKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfX1nZXRCb3VuZGFyeSgpe3JldHVybiBYLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSxudWxsfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX0dFT01FVFJZQ09MTEVDVElPTn1pc0VtcHR5KCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNFbXB0eSgpKXJldHVybiExO3JldHVybiEwfX1jbGFzcyBodCBleHRlbmRzIGN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxodC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtjdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9Y29weUludGVybmFsKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGh0KHQsdGhpcy5fZmFjdG9yeSl9aXNWYWxpZCgpe3JldHVybiEwfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1t0XS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHN1cGVyLmdldENvb3JkaW5hdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIEsuRkFMU0V9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gWC5UWVBFQ09ERV9NVUxUSVBPSU5UfWdldERpbWVuc2lvbigpe3JldHVybiAwfWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX01VTFRJUE9JTlR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuWyRdfX1jbGFzcyB1dCBleHRlbmRzIEp7Y29uc3RydWN0b3IoKXtzdXBlcigpLHV0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0ouY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMudmFsaWRhdGVDb25zdHJ1Y3Rpb24oKX1jb3B5SW50ZXJuYWwoKXtyZXR1cm4gbmV3IHV0KHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gSy5GQUxTRX1pc0Nsb3NlZCgpe3JldHVybiEhdGhpcy5pc0VtcHR5KCl8fHN1cGVyLmlzQ2xvc2VkLmNhbGwodGhpcyl9cmV2ZXJzZUludGVybmFsKCl7Y29uc3QgdD10aGlzLl9wb2ludHMuY29weSgpO3JldHVybiBaLnJldmVyc2UodCksdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0KX1nZXRUeXBlQ29kZSgpe3JldHVybiBYLlRZUEVDT0RFX0xJTkVBUlJJTkd9dmFsaWRhdGVDb25zdHJ1Y3Rpb24oKXtpZighdGhpcy5pc0VtcHR5KCkmJiFzdXBlci5pc0Nsb3NlZC5jYWxsKHRoaXMpKXRocm93IG5ldyBzKFwiUG9pbnRzIG9mIExpbmVhclJpbmcgZG8gbm90IGZvcm0gYSBjbG9zZWQgbGluZXN0cmluZ1wiKTtpZih0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKT49MSYmdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk8dXQuTUlOSU1VTV9WQUxJRF9TSVpFKXRocm93IG5ldyBzKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVhclJpbmcgKGZvdW5kIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDQpXCIpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX0xJTkVBUlJJTkd9fXV0Lk1JTklNVU1fVkFMSURfU0laRT00O2NsYXNzIGd0e3N0YXRpYyBtZWFzdXJlcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHk/MDp0IGluc3RhbmNlb2YgeHx8dCBpbnN0YW5jZW9mIEU/MTowfXN0YXRpYyBkaW1lbnNpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB5PzI6dCBpbnN0YW5jZW9mIHg/Mzp0IGluc3RhbmNlb2YgRT80OjN9c3RhdGljIGNyZWF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gZ3QuY3JlYXRlKHQsMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiAyPT09dD9uZXcgeTozPT09dCYmMD09PWU/bmV3IG06Mz09PXQmJjE9PT1lP25ldyB4OjQ9PT10JiYxPT09ZT9uZXcgRTpuZXcgbX19fWNsYXNzIGR0e3N0YXRpYyBpc1JpbmcodCl7cmV0dXJuISh0Lmxlbmd0aDw0KSYmISF0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfXN0YXRpYyBwdE5vdEluTGlzdCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl07aWYoZHQuaW5kZXhPZihzLGUpPDApcmV0dXJuIHN9cmV0dXJuIG51bGx9c3RhdGljIHNjcm9sbCh0LGUpe2NvbnN0IG49ZHQuaW5kZXhPZihlLHQpO2lmKG48MClyZXR1cm4gbnVsbDtjb25zdCBzPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtCLmFycmF5Y29weSh0LG4scywwLHQubGVuZ3RoLW4pLEIuYXJyYXljb3B5KHQsMCxzLHQubGVuZ3RoLW4sbiksQi5hcnJheWNvcHkocywwLHQsMCx0Lmxlbmd0aCl9c3RhdGljIGVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT09dHx8bnVsbD09PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZVtuXSkpcmV0dXJuITE7cmV0dXJuITB9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKWlmKDAhPT1uLmNvbXBhcmUodFtzXSxlW3NdKSlyZXR1cm4hMTtyZXR1cm4hMH19c3RhdGljIGludGVyc2VjdGlvbih0LGUpe2NvbnN0IG49bmV3IFI7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspZS5pbnRlcnNlY3RzKHRbc10pJiZuLmFkZCh0W3NdLCEwKTtyZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyBtZWFzdXJlcyh0KXtpZihudWxsPT09dHx8MD09PXQubGVuZ3RoKXJldHVybiAwO2xldCBlPTA7Zm9yKGNvbnN0IG4gb2YgdCllPU1hdGgubWF4KGUsZ3QubWVhc3VyZXMobikpO3JldHVybiBlfXN0YXRpYyBoYXNSZXBlYXRlZFBvaW50cyh0KXtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0W2UtMV0uZXF1YWxzKHRbZV0pKXJldHVybiEwO3JldHVybiExfXN0YXRpYyByZW1vdmVSZXBlYXRlZFBvaW50cyh0KXtpZighZHQuaGFzUmVwZWF0ZWRQb2ludHModCkpcmV0dXJuIHQ7cmV0dXJuIG5ldyBSKHQsITEpLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10Lmxlbmd0aC0xLG49TWF0aC50cnVuYyhlLzIpO2ZvcihsZXQgcz0wO3M8PW47cysrKXtjb25zdCBuPXRbc107dFtzXT10W2Utc10sdFtlLXNdPW59fXN0YXRpYyByZW1vdmVOdWxsKHQpe2xldCBlPTA7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspbnVsbCE9PXRbbl0mJmUrKztjb25zdCBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2lmKDA9PT1lKXJldHVybiBuO2xldCBzPTA7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspbnVsbCE9PXRbZV0mJihuW3MrK109dFtlXSk7cmV0dXJuIG59c3RhdGljIGNvcHlEZWVwKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWVbbl09dFtuXS5jb3B5KCk7cmV0dXJuIGV9aWYoNT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdO2ZvcihsZXQgcj0wO3I8aTtyKyspbltzK3JdPXRbZStyXS5jb3B5KCl9fXN0YXRpYyBpc0VxdWFsUmV2ZXJzZWQodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dLGk9ZVt0Lmxlbmd0aC1uLTFdO2lmKDAhPT1zLmNvbXBhcmVUbyhpKSlyZXR1cm4hMX1yZXR1cm4hMH1zdGF0aWMgZW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTztmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllLmV4cGFuZFRvSW5jbHVkZSh0W25dKTtyZXR1cm4gZX1zdGF0aWMgdG9Db29yZGluYXRlQXJyYXkodCl7cmV0dXJuIHQudG9BcnJheShkdC5jb29yZEFycmF5VHlwZSl9c3RhdGljIGRpbWVuc2lvbih0KXtpZihudWxsPT09dHx8MD09PXQubGVuZ3RoKXJldHVybiAzO2xldCBlPTA7Zm9yKGNvbnN0IG4gb2YgdCllPU1hdGgubWF4KGUsZ3QuZGltZW5zaW9uKG4pKTtyZXR1cm4gZX1zdGF0aWMgYXRMZWFzdE5Db29yZGluYXRlc09yTm90aGluZyh0LGUpe3JldHVybiBlLmxlbmd0aD49dD9lOltdfXN0YXRpYyBpbmRleE9mKHQsZSl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspaWYodC5lcXVhbHMoZVtuXSkpcmV0dXJuIG47cmV0dXJuLTF9c3RhdGljIGluY3JlYXNpbmdEaXJlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTxNYXRoLnRydW5jKHQubGVuZ3RoLzIpO2UrKyl7Y29uc3Qgbj10Lmxlbmd0aC0xLWUscz10W2VdLmNvbXBhcmVUbyh0W25dKTtpZigwIT09cylyZXR1cm4gc31yZXR1cm4gMX1zdGF0aWMgY29tcGFyZSh0LGUpe2xldCBuPTA7Zm9yKDtuPHQubGVuZ3RoJiZuPGUubGVuZ3RoOyl7Y29uc3Qgcz10W25dLmNvbXBhcmVUbyhlW25dKTtpZigwIT09cylyZXR1cm4gcztuKyt9cmV0dXJuIG48ZS5sZW5ndGg/LTE6bjx0Lmxlbmd0aD8xOjB9c3RhdGljIG1pbkNvb3JkaW5hdGUodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKykobnVsbD09PWV8fGUuY29tcGFyZVRvKHRbbl0pPjApJiYoZT10W25dKTtyZXR1cm4gZX1zdGF0aWMgZXh0cmFjdCh0LGUsbil7ZT1ZLmNsYW1wKGUsMCx0Lmxlbmd0aCk7bGV0IHM9KG49WS5jbGFtcChuLC0xLHQubGVuZ3RoKSktZSsxO248MCYmKHM9MCksZT49dC5sZW5ndGgmJihzPTApLG48ZSYmKHM9MCk7Y29uc3QgaT1uZXcgQXJyYXkocykuZmlsbChudWxsKTtpZigwPT09cylyZXR1cm4gaTtsZXQgcj0wO2ZvcihsZXQgcz1lO3M8PW47cysrKWlbcisrXT10W3NdO3JldHVybiBpfX1kdC5Gb3J3YXJkQ29tcGFyYXRvcj1jbGFzc3tjb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtyZXR1cm4gZHQuY29tcGFyZShuLHMpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19LGR0LkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yPWNsYXNze2NvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO2lmKG4ubGVuZ3RoPHMubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPnMubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtjb25zdCBpPWR0LmNvbXBhcmUobixzKTtyZXR1cm4gZHQuaXNFcXVhbFJldmVyc2VkKG4scyk/MDppfU9MRGNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO2lmKG4ubGVuZ3RoPHMubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPnMubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtjb25zdCBpPWR0LmluY3JlYXNpbmdEaXJlY3Rpb24obikscj1kdC5pbmNyZWFzaW5nRGlyZWN0aW9uKHMpO2xldCBvPWk+MD8wOm4ubGVuZ3RoLTEsbD1yPjA/MDpuLmxlbmd0aC0xO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCB0PW5bb10uY29tcGFyZVRvKHNbbF0pO2lmKDAhPT10KXJldHVybiB0O28rPWksbCs9cn1yZXR1cm4gMH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fSxkdC5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKTtjbGFzcyBfdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLnN0cj10fWFwcGVuZCh0KXt0aGlzLnN0cis9dH1zZXRDaGFyQXQodCxlKXt0aGlzLnN0cj10aGlzLnN0ci5zdWJzdHIoMCx0KStlK3RoaXMuc3RyLnN1YnN0cih0KzEpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc3RyfX1jbGFzcyBwdHtjb25zdHJ1Y3Rvcigpe3B0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2RpbWVuc2lvbj0zLHRoaXMuX21lYXN1cmVzPTAsdGhpcy5fY29vcmRpbmF0ZXM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGR0LmRpbWVuc2lvbih0KSxkdC5tZWFzdXJlcyh0KSl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09bmV3IG19ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7dGhpcy5fZGltZW5zaW9uPXQuZ2V0RGltZW5zaW9uKCksdGhpcy5fbWVhc3VyZXM9dC5nZXRNZWFzdXJlcygpLHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09dC5nZXRDb29yZGluYXRlQ29weShlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtwdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxkdC5tZWFzdXJlcyh0KSl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5fZGltZW5zaW9uPWU7Zm9yKGxldCBuPTA7bjx0O24rKyl0aGlzLl9jb29yZGluYXRlc1tuXT1ndC5jcmVhdGUoZSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2RpbWVuc2lvbj1lLHRoaXMuX21lYXN1cmVzPW4sdGhpcy5fY29vcmRpbmF0ZXM9bnVsbD09PXQ/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6dH1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuX2RpbWVuc2lvbj1lLHRoaXMuX21lYXN1cmVzPW47Zm9yKGxldCBlPTA7ZTx0O2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT10aGlzLmNyZWF0ZUNvb3JkaW5hdGUoKX19Z2V0TSh0KXtyZXR1cm4gdGhpcy5oYXNNKCk/dGhpcy5fY29vcmRpbmF0ZXNbdF0uZ2V0TSgpOnIuTmFOfXNldE9yZGluYXRlKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBGLlg6dGhpcy5fY29vcmRpbmF0ZXNbdF0ueD1uO2JyZWFrO2Nhc2UgRi5ZOnRoaXMuX2Nvb3JkaW5hdGVzW3RdLnk9bjticmVhaztkZWZhdWx0OnRoaXMuX2Nvb3JkaW5hdGVzW3RdLnNldE9yZGluYXRlKGUsbil9fWdldFoodCl7cmV0dXJuIHRoaXMuaGFzWigpP3RoaXMuX2Nvb3JkaW5hdGVzW3RdLmdldFooKTpyLk5hTn1zaXplKCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aH1nZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaChlKXtjYXNlIEYuWDpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueDtjYXNlIEYuWTpyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueTtkZWZhdWx0OnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS5nZXRPcmRpbmF0ZShlKX19Z2V0Q29vcmRpbmF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF19aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2FyZ3VtZW50c1sxXS5zZXRDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW3RdKX19Z2V0Q29vcmRpbmF0ZUNvcHkodCl7Y29uc3QgZT10aGlzLmNyZWF0ZUNvb3JkaW5hdGUoKTtyZXR1cm4gZS5zZXRDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW3RdKSxlfWNyZWF0ZUNvb3JkaW5hdGUoKXtyZXR1cm4gZ3QuY3JlYXRlKHRoaXMuZ2V0RGltZW5zaW9uKCksdGhpcy5nZXRNZWFzdXJlcygpKX1nZXREaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5fZGltZW5zaW9ufWdldFgodCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnh9Z2V0TWVhc3VyZXMoKXtyZXR1cm4gdGhpcy5fbWVhc3VyZXN9ZXhwYW5kRW52ZWxvcGUodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdH1jb3B5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuY3JlYXRlQ29vcmRpbmF0ZSgpO24uc2V0Q29vcmRpbmF0ZSh0aGlzLl9jb29yZGluYXRlc1tlXSksdFtlXT1ufXJldHVybiBuZXcgcHQodCx0aGlzLl9kaW1lbnNpb24sdGhpcy5fbWVhc3VyZXMpfXRvU3RyaW5nKCl7aWYodGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoPjApe2NvbnN0IHQ9bmV3IF90KDE3KnRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCk7dC5hcHBlbmQoXCIoXCIpLHQuYXBwZW5kKHRoaXMuX2Nvb3JkaW5hdGVzWzBdKTtmb3IobGV0IGU9MTtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5hcHBlbmQoXCIsIFwiKSx0LmFwcGVuZCh0aGlzLl9jb29yZGluYXRlc1tlXSk7cmV0dXJuIHQuYXBwZW5kKFwiKVwiKSx0LnRvU3RyaW5nKCl9cmV0dXJuXCIoKVwifWdldFkodCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLnl9dG9Db29yZGluYXRlQXJyYXkoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0YsY119fWNsYXNzIG10e3N0YXRpYyBpbnN0YW5jZSgpe3JldHVybiBtdC5pbnN0YW5jZU9iamVjdH1yZWFkUmVzb2x2ZSgpe3JldHVybiBtdC5pbnN0YW5jZSgpfWNyZWF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtyZXR1cm4gbmV3IHB0KGFyZ3VtZW50c1swXSl9aWYoSShhcmd1bWVudHNbMF0sRikpe3JldHVybiBuZXcgcHQoYXJndW1lbnRzWzBdKX19ZWxzZXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzFdO3JldHVybiB0PjMmJih0PTMpLHQ8MiYmKHQ9MiksbmV3IHB0KGFyZ3VtZW50c1swXSx0KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzJdLGU9YXJndW1lbnRzWzFdLXQ7cmV0dXJuIHQ+MSYmKHQ9MSksZT4zJiYoZT0zKSxlPDImJihlPTIpLG5ldyBwdChhcmd1bWVudHNbMF0sZSt0LHQpfX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3osY119fW10Lmluc3RhbmNlT2JqZWN0PW5ldyBtdDtjbGFzcyBmdCBleHRlbmRzIGN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxmdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtjdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9Y29weUludGVybmFsKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLl9nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGZ0KHQsdGhpcy5fZmFjdG9yeSl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRUeXBlQ29kZSgpe3JldHVybiBYLlRZUEVDT0RFX01VTFRJUE9MWUdPTn1nZXREaW1lbnNpb24oKXtyZXR1cm4gMn1nZXRCb3VuZGFyeSgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0Qm91bmRhcnkoKTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl0LmFkZChuLmdldEdlb21ldHJ5TihlKSl9Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0LnRvQXJyYXkoZSkpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX01VTFRJUE9MWUdPTn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bc3RdfX1jbGFzcyB5dHtnZXQoKXt9cHV0KCl7fXNpemUoKXt9dmFsdWVzKCl7fWVudHJ5U2V0KCl7fX1jbGFzcyB4dCBleHRlbmRzIHJ0e2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5tYXA9bmV3IE1hcCx0IGluc3RhbmNlb2YgTiYmdGhpcy5hZGRBbGwodCl9Y29udGFpbnModCl7Y29uc3QgZT10Lmhhc2hDb2RlP3QuaGFzaENvZGUoKTp0O3JldHVybiEhdGhpcy5tYXAuaGFzKGUpfWFkZCh0KXtjb25zdCBlPXQuaGFzaENvZGU/dC5oYXNoQ29kZSgpOnQ7cmV0dXJuIXRoaXMubWFwLmhhcyhlKSYmISF0aGlzLm1hcC5zZXQoZSx0KX1hZGRBbGwodCl7Zm9yKGNvbnN0IGUgb2YgdCl0aGlzLmFkZChlKTtyZXR1cm4hMH1yZW1vdmUoKXt0aHJvdyBuZXcgan1zaXplKCl7cmV0dXJuIHRoaXMubWFwLnNpemV9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5tYXAuc2l6ZX10b0FycmF5KCl7cmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAudmFsdWVzKCkpfWl0ZXJhdG9yKCl7cmV0dXJuIG5ldyBFdCh0aGlzLm1hcCl9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5tYXB9fWNsYXNzIEV0e2NvbnN0cnVjdG9yKHQpe3RoaXMuaXRlcmF0b3I9dC52YWx1ZXMoKTtjb25zdHtkb25lOmUsdmFsdWU6bn09dGhpcy5pdGVyYXRvci5uZXh0KCk7dGhpcy5kb25lPWUsdGhpcy52YWx1ZT1ufW5leHQoKXtpZih0aGlzLmRvbmUpdGhyb3cgbmV3IEM7Y29uc3QgdD10aGlzLnZhbHVlLHtkb25lOmUsdmFsdWU6bn09dGhpcy5pdGVyYXRvci5uZXh0KCk7cmV0dXJuIHRoaXMuZG9uZT1lLHRoaXMudmFsdWU9bix0fWhhc05leHQoKXtyZXR1cm4hdGhpcy5kb25lfXJlbW92ZSgpe3Rocm93IG5ldyBqfX1jbGFzcyBJdCBleHRlbmRzIHl0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLm1hcD1uZXcgTWFwfWdldCh0KXtyZXR1cm4gdGhpcy5tYXAuZ2V0KHQpfHxudWxsfXB1dCh0LGUpe3JldHVybiB0aGlzLm1hcC5zZXQodCxlKSxlfXZhbHVlcygpe2NvbnN0IHQ9bmV3IEwsZT10aGlzLm1hcC52YWx1ZXMoKTtsZXQgbj1lLm5leHQoKTtmb3IoOyFuLmRvbmU7KXQuYWRkKG4udmFsdWUpLG49ZS5uZXh0KCk7cmV0dXJuIHR9ZW50cnlTZXQoKXtjb25zdCB0PW5ldyB4dDtyZXR1cm4gdGhpcy5tYXAuZW50cmllcygpLmZvckVhY2goKGU9PnQuYWRkKGUpKSksdH1zaXplKCl7cmV0dXJuIHRoaXMubWFwLnNpemUoKX19Y2xhc3MgTnR7Y29uc3RydWN0b3IoKXtOdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tb2RlbFR5cGU9bnVsbCx0aGlzLl9zY2FsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX21vZGVsVHlwZT1OdC5GTE9BVElORztlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT10LHQ9PT1OdC5GSVhFRCYmdGhpcy5zZXRTY2FsZSgxKX1lbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21vZGVsVHlwZT1OdC5GSVhFRCx0aGlzLnNldFNjYWxlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXQuX21vZGVsVHlwZSx0aGlzLl9zY2FsZT10Ll9zY2FsZX19c3RhdGljIG1vc3RQcmVjaXNlKHQsZSl7cmV0dXJuIHQuY29tcGFyZVRvKGUpPj0wP3Q6ZX1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgTnQpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09ZS5fbW9kZWxUeXBlJiZ0aGlzLl9zY2FsZT09PWUuX3NjYWxlfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQsbj10aGlzLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpLHM9ZS5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKTtyZXR1cm4gTS5jb21wYXJlKG4scyl9Z2V0U2NhbGUoKXtyZXR1cm4gdGhpcy5fc2NhbGV9aXNGbG9hdGluZygpe3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1OdC5GTE9BVElOR3x8dGhpcy5fbW9kZWxUeXBlPT09TnQuRkxPQVRJTkdfU0lOR0xFfWdldFR5cGUoKXtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlfXRvU3RyaW5nKCl7bGV0IHQ9XCJVTktOT1dOXCI7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PU50LkZMT0FUSU5HP3Q9XCJGbG9hdGluZ1wiOnRoaXMuX21vZGVsVHlwZT09PU50LkZMT0FUSU5HX1NJTkdMRT90PVwiRmxvYXRpbmctU2luZ2xlXCI6dGhpcy5fbW9kZWxUeXBlPT09TnQuRklYRUQmJih0PVwiRml4ZWQgKFNjYWxlPVwiK3RoaXMuZ2V0U2NhbGUoKStcIilcIiksdH1tYWtlUHJlY2lzZSgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHIuaXNOYU4odCkpcmV0dXJuIHQ7aWYodGhpcy5fbW9kZWxUeXBlPT09TnQuRkxPQVRJTkdfU0lOR0xFKXtyZXR1cm4gdH1yZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09TnQuRklYRUQ/TWF0aC5yb3VuZCh0KnRoaXMuX3NjYWxlKS90aGlzLl9zY2FsZTp0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fbW9kZWxUeXBlPT09TnQuRkxPQVRJTkcpcmV0dXJuIG51bGw7dC54PXRoaXMubWFrZVByZWNpc2UodC54KSx0Lnk9dGhpcy5tYWtlUHJlY2lzZSh0LnkpfX1nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKXtsZXQgdD0xNjtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09TnQuRkxPQVRJTkc/dD0xNjp0aGlzLl9tb2RlbFR5cGU9PT1OdC5GTE9BVElOR19TSU5HTEU/dD02OnRoaXMuX21vZGVsVHlwZT09PU50LkZJWEVEJiYodD0xK01hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0U2NhbGUoKSkvTWF0aC5sb2coMTApKSkpLHR9c2V0U2NhbGUodCl7dGhpcy5fc2NhbGU9TWF0aC5hYnModCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2Msb119fWNsYXNzIFN0e2NvbnN0cnVjdG9yKCl7U3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbmFtZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25hbWU9dCxTdC5uYW1lVG9UeXBlTWFwLnB1dCh0LHRoaXMpfXJlYWRSZXNvbHZlKCl7cmV0dXJuIFN0Lm5hbWVUb1R5cGVNYXAuZ2V0KHRoaXMuX25hbWUpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX25hbWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NdfX1TdC5uYW1lVG9UeXBlTWFwPW5ldyBJdCxOdC5UeXBlPVN0LE50LkZJWEVEPW5ldyBTdChcIkZJWEVEXCIpLE50LkZMT0FUSU5HPW5ldyBTdChcIkZMT0FUSU5HXCIpLE50LkZMT0FUSU5HX1NJTkdMRT1uZXcgU3QoXCJGTE9BVElORyBTSU5HTEVcIiksTnQubWF4aW11bVByZWNpc2VWYWx1ZT05MDA3MTk5MjU0NzQwOTkyO2NsYXNzIHd0IGV4dGVuZHMgY3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLHd0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2N0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgd3QodCx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/Sy5GQUxTRTowfWlzQ2xvc2VkKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNDbG9zZWQoKSlyZXR1cm4hMTtyZXR1cm4hMH1nZXRUeXBlQ29kZSgpe3JldHVybiBYLlRZUEVDT0RFX01VTFRJTElORVNUUklOR31nZXREaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRCb3VuZGFyeSgpe3Rocm93IG5ldyBqfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX01VTFRJTElORVNUUklOR31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bV119fWNsYXNzIEN0e2NvbnN0cnVjdG9yKCl7Q3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW51bGwsdGhpcy5fU1JJRD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUN0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IE50LDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLHopKXtjb25zdCB0PWFyZ3VtZW50c1swXTtDdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBOdCwwLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Q3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDAsQ3QuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0N0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLEN0LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1uLHRoaXMuX1NSSUQ9ZX19c3RhdGljIHRvTXVsdGlQb2x5Z29uQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9HZW9tZXRyeUFycmF5KHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIGdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCl7cmV0dXJuIG10Lmluc3RhbmNlKCl9c3RhdGljIHRvTXVsdGlMaW5lU3RyaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9MaW5lU3RyaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9NdWx0aVBvaW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9MaW5lYXJSaW5nQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9Qb2ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvUG9seWdvbkFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIGNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfWNyZWF0ZUVtcHR5KHQpe3N3aXRjaCh0KXtjYXNlLTE6cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7Y2FzZSAwOnJldHVybiB0aGlzLmNyZWF0ZVBvaW50KCk7Y2FzZSAxOnJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDI6cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbigpO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIGRpbWVuc2lvbjogXCIrdCl9fXRvR2VvbWV0cnkodCl7cmV0dXJuIHQuaXNOdWxsKCk/dGhpcy5jcmVhdGVQb2ludCgpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCkmJnQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVQb2ludChuZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSkpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCl8fHQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IG0odC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpXSk6dGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhbbmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSxuZXcgbSh0LmdldE1heFgoKSx0LmdldE1heFkoKSksbmV3IG0odC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpLG5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKV0pLG51bGwpfWNyZWF0ZUxpbmVTdHJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihJKGFyZ3VtZW50c1swXSxGKSl7cmV0dXJuIG5ldyBKKGFyZ3VtZW50c1swXSx0aGlzKX19fWNyZWF0ZU11bHRpTGluZVN0cmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgd3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyB3dChhcmd1bWVudHNbMF0sdGhpcyl9fWJ1aWxkR2VvbWV0cnkodCl7bGV0IGU9bnVsbCxuPSExLHM9ITE7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCkscj10LmdldFR5cGVDb2RlKCk7bnVsbD09PWUmJihlPXIpLHIhPT1lJiYobj0hMCksdCBpbnN0YW5jZW9mIGN0JiYocz0hMCl9aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYobnx8cylyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oQ3QudG9HZW9tZXRyeUFycmF5KHQpKTtjb25zdCBpPXQuaXRlcmF0b3IoKS5uZXh0KCk7aWYodC5zaXplKCk+MSl7aWYoaSBpbnN0YW5jZW9mIGl0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9seWdvbihDdC50b1BvbHlnb25BcnJheSh0KSk7aWYoaSBpbnN0YW5jZW9mIEopcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKEN0LnRvTGluZVN0cmluZ0FycmF5KHQpKTtpZihpIGluc3RhbmNlb2YgdHQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChDdC50b1BvaW50QXJyYXkodCkpO2cuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogXCIraS5nZXRHZW9tZXRyeVR5cGUoKSl9cmV0dXJuIGl9Y3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHModCl7cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9Y3JlYXRlUG9pbnQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2ludCh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW3RdKTpudWxsKX1pZihJKGFyZ3VtZW50c1swXSxGKSl7cmV0dXJuIG5ldyB0dChhcmd1bWVudHNbMF0sdGhpcyl9fX1nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnl9Y3JlYXRlUG9seWdvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24obnVsbCxudWxsKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sRikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB1dCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0LG51bGwpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IGl0KGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sdGhpcyl9fWdldFNSSUQoKXtyZXR1cm4gdGhpcy5fU1JJRH1jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGN0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgY3QoYXJndW1lbnRzWzBdLHRoaXMpfX1nZXRQcmVjaXNpb25Nb2RlbCgpe3JldHVybiB0aGlzLl9wcmVjaXNpb25Nb2RlbH1jcmVhdGVMaW5lYXJSaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoSShhcmd1bWVudHNbMF0sRikpe3JldHVybiBuZXcgdXQoYXJndW1lbnRzWzBdLHRoaXMpfX19Y3JlYXRlTXVsdGlQb2x5Z29uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBmdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IGZ0KGFyZ3VtZW50c1swXSx0aGlzKX19Y3JlYXRlTXVsdGlQb2ludCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgaHQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7cmV0dXJuIG5ldyBodChhcmd1bWVudHNbMF0sdGhpcyl9aWYoSShhcmd1bWVudHNbMF0sRikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSgxLHQuZ2V0RGltZW5zaW9uKCksdC5nZXRNZWFzdXJlcygpKTtaLmNvcHkodCxuLHMsMCwxKSxlW25dPXRoaXMuY3JlYXRlUG9pbnQocyl9cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChlKX19fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjXX19Y29uc3QgTHQ9XCJYWVwiLFR0PVwiWFlaXCIsUnQ9XCJYWU1cIixQdD1cIlhZWk1cIixPdD17UE9JTlQ6XCJQb2ludFwiLExJTkVfU1RSSU5HOlwiTGluZVN0cmluZ1wiLExJTkVBUl9SSU5HOlwiTGluZWFyUmluZ1wiLFBPTFlHT046XCJQb2x5Z29uXCIsTVVMVElfUE9JTlQ6XCJNdWx0aVBvaW50XCIsTVVMVElfTElORV9TVFJJTkc6XCJNdWx0aUxpbmVTdHJpbmdcIixNVUxUSV9QT0xZR09OOlwiTXVsdGlQb2x5Z29uXCIsR0VPTUVUUllfQ09MTEVDVElPTjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLENJUkNMRTpcIkNpcmNsZVwifSx2dD1cIkVNUFRZXCIsTXQ9MSxidD0yLER0PTMsQXQ9NCxGdD01LEd0PTYscXQ9e307Zm9yKGNvbnN0IHQgaW4gT3QpcXRbdF09T3RbdF0udG9VcHBlckNhc2UoKTtjbGFzcyBCdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLndrdD10LHRoaXMuaW5kZXhfPS0xfWlzQWxwaGFfKHQpe3JldHVybiB0Pj1cImFcIiYmdDw9XCJ6XCJ8fHQ+PVwiQVwiJiZ0PD1cIlpcIn1pc051bWVyaWNfKHQsZSl7cmV0dXJuIHQ+PVwiMFwiJiZ0PD1cIjlcInx8XCIuXCI9PXQmJiEodm9pZCAwIT09ZSYmZSl9aXNXaGl0ZVNwYWNlXyh0KXtyZXR1cm5cIiBcIj09dHx8XCJcXHRcIj09dHx8XCJcXHJcIj09dHx8XCJcXG5cIj09dH1uZXh0Q2hhcl8oKXtyZXR1cm4gdGhpcy53a3QuY2hhckF0KCsrdGhpcy5pbmRleF8pfW5leHRUb2tlbigpe2NvbnN0IHQ9dGhpcy5uZXh0Q2hhcl8oKSxlPXRoaXMuaW5kZXhfO2xldCBuLHM9dDtpZihcIihcIj09dCluPWJ0O2Vsc2UgaWYoXCIsXCI9PXQpbj1GdDtlbHNlIGlmKFwiKVwiPT10KW49RHQ7ZWxzZSBpZih0aGlzLmlzTnVtZXJpY18odCl8fFwiLVwiPT10KW49QXQscz10aGlzLnJlYWROdW1iZXJfKCk7ZWxzZSBpZih0aGlzLmlzQWxwaGFfKHQpKW49TXQscz10aGlzLnJlYWRUZXh0XygpO2Vsc2V7aWYodGhpcy5pc1doaXRlU3BhY2VfKHQpKXJldHVybiB0aGlzLm5leHRUb2tlbigpO2lmKFwiXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIit0KTtuPUd0fXJldHVybntwb3NpdGlvbjplLHZhbHVlOnMsdHlwZTpufX1yZWFkTnVtYmVyXygpe2xldCB0O2NvbnN0IGU9dGhpcy5pbmRleF87bGV0IG49ITEscz0hMTtkb3tcIi5cIj09dD9uPSEwOlwiZVwiIT10JiZcIkVcIiE9dHx8KHM9ITApLHQ9dGhpcy5uZXh0Q2hhcl8oKX13aGlsZSh0aGlzLmlzTnVtZXJpY18odCxuKXx8IXMmJihcImVcIj09dHx8XCJFXCI9PXQpfHxzJiYoXCItXCI9PXR8fFwiK1wiPT10KSk7cmV0dXJuIHBhcnNlRmxvYXQodGhpcy53a3Quc3Vic3RyaW5nKGUsdGhpcy5pbmRleF8tLSkpfXJlYWRUZXh0Xygpe2xldCB0O2NvbnN0IGU9dGhpcy5pbmRleF87ZG97dD10aGlzLm5leHRDaGFyXygpfXdoaWxlKHRoaXMuaXNBbHBoYV8odCkpO3JldHVybiB0aGlzLndrdC5zdWJzdHJpbmcoZSx0aGlzLmluZGV4Xy0tKS50b1VwcGVyQ2FzZSgpfX1jbGFzcyBZdHtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMubGV4ZXJfPXQsdGhpcy50b2tlbl8sdGhpcy5sYXlvdXRfPUx0LHRoaXMuZmFjdG9yeT1lfWNvbnN1bWVfKCl7dGhpcy50b2tlbl89dGhpcy5sZXhlcl8ubmV4dFRva2VuKCl9aXNUb2tlblR5cGUodCl7cmV0dXJuIHRoaXMudG9rZW5fLnR5cGU9PXR9bWF0Y2godCl7Y29uc3QgZT10aGlzLmlzVG9rZW5UeXBlKHQpO3JldHVybiBlJiZ0aGlzLmNvbnN1bWVfKCksZX1wYXJzZSgpe3RoaXMuY29uc3VtZV8oKTtyZXR1cm4gdGhpcy5wYXJzZUdlb21ldHJ5XygpfXBhcnNlR2VvbWV0cnlMYXlvdXRfKCl7bGV0IHQ9THQ7Y29uc3QgZT10aGlzLnRva2VuXztpZih0aGlzLmlzVG9rZW5UeXBlKE10KSl7Y29uc3Qgbj1lLnZhbHVlO1wiWlwiPT09bj90PVR0OlwiTVwiPT09bj90PVJ0OlwiWk1cIj09PW4mJih0PVB0KSx0IT09THQmJnRoaXMuY29uc3VtZV8oKX1yZXR1cm4gdH1wYXJzZUdlb21ldHJ5Q29sbGVjdGlvblRleHRfKCl7aWYodGhpcy5tYXRjaChidCkpe2NvbnN0IHQ9W107ZG97dC5wdXNoKHRoaXMucGFyc2VHZW9tZXRyeV8oKSl9d2hpbGUodGhpcy5tYXRjaChGdCkpO2lmKHRoaXMubWF0Y2goRHQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvaW50VGV4dF8oKXtpZih0aGlzLm1hdGNoKGJ0KSl7Y29uc3QgdD10aGlzLnBhcnNlUG9pbnRfKCk7aWYodGhpcy5tYXRjaChEdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm4gbnVsbDt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTGluZVN0cmluZ1RleHRfKCl7aWYodGhpcy5tYXRjaChidCkpe2NvbnN0IHQ9dGhpcy5wYXJzZVBvaW50TGlzdF8oKTtpZih0aGlzLm1hdGNoKER0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VQb2x5Z29uVGV4dF8oKXtpZih0aGlzLm1hdGNoKGJ0KSl7Y29uc3QgdD10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRMaXN0XygpO2lmKHRoaXMubWF0Y2goRHQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZU11bHRpUG9pbnRUZXh0Xygpe2lmKHRoaXMubWF0Y2goYnQpKXtsZXQgdDtpZih0PXRoaXMudG9rZW5fLnR5cGU9PWJ0P3RoaXMucGFyc2VQb2ludFRleHRMaXN0XygpOnRoaXMucGFyc2VQb2ludExpc3RfKCksdGhpcy5tYXRjaChEdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTXVsdGlMaW5lU3RyaW5nVGV4dF8oKXtpZih0aGlzLm1hdGNoKGJ0KSl7Y29uc3QgdD10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRMaXN0XygpO2lmKHRoaXMubWF0Y2goRHQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZU11bHRpUG9seWdvblRleHRfKCl7aWYodGhpcy5tYXRjaChidCkpe2NvbnN0IHQ9dGhpcy5wYXJzZVBvbHlnb25UZXh0TGlzdF8oKTtpZih0aGlzLm1hdGNoKER0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VQb2ludF8oKXtjb25zdCB0PVtdLGU9dGhpcy5sYXlvdXRfLmxlbmd0aDtmb3IobGV0IG49MDtuPGU7KytuKXtjb25zdCBlPXRoaXMudG9rZW5fO2lmKCF0aGlzLm1hdGNoKEF0KSlicmVhazt0LnB1c2goZS52YWx1ZSl9aWYodC5sZW5ndGg9PWUpcmV0dXJuIHQ7dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvaW50TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlUG9pbnRfKCldO2Zvcig7dGhpcy5tYXRjaChGdCk7KXQucHVzaCh0aGlzLnBhcnNlUG9pbnRfKCkpO3JldHVybiB0fXBhcnNlUG9pbnRUZXh0TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlUG9pbnRUZXh0XygpXTtmb3IoO3RoaXMubWF0Y2goRnQpOyl0LnB1c2godGhpcy5wYXJzZVBvaW50VGV4dF8oKSk7cmV0dXJuIHR9cGFyc2VMaW5lU3RyaW5nVGV4dExpc3RfKCl7Y29uc3QgdD1bdGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpXTtmb3IoO3RoaXMubWF0Y2goRnQpOyl0LnB1c2godGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpKTtyZXR1cm4gdH1wYXJzZVBvbHlnb25UZXh0TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlUG9seWdvblRleHRfKCldO2Zvcig7dGhpcy5tYXRjaChGdCk7KXQucHVzaCh0aGlzLnBhcnNlUG9seWdvblRleHRfKCkpO3JldHVybiB0fWlzRW1wdHlHZW9tZXRyeV8oKXtjb25zdCB0PXRoaXMuaXNUb2tlblR5cGUoTXQpJiZ0aGlzLnRva2VuXy52YWx1ZT09dnQ7cmV0dXJuIHQmJnRoaXMuY29uc3VtZV8oKSx0fWZvcm1hdEVycm9yTWVzc2FnZV8oKXtyZXR1cm5cIlVuZXhwZWN0ZWQgYFwiK3RoaXMudG9rZW5fLnZhbHVlK1wiYCBhdCBwb3NpdGlvbiBcIit0aGlzLnRva2VuXy5wb3NpdGlvbitcIiBpbiBgXCIrdGhpcy5sZXhlcl8ud2t0K1wiYFwifXBhcnNlR2VvbWV0cnlfKCl7Y29uc3QgdD10aGlzLmZhY3RvcnksZT10PT5uZXcgbSguLi50KSxuPW49Pntjb25zdCBzPW4ubWFwKChuPT50LmNyZWF0ZUxpbmVhclJpbmcobi5tYXAoZSkpKSk7cmV0dXJuIHMubGVuZ3RoPjE/dC5jcmVhdGVQb2x5Z29uKHNbMF0scy5zbGljZSgxKSk6dC5jcmVhdGVQb2x5Z29uKHNbMF0pfSxzPXRoaXMudG9rZW5fO2lmKHRoaXMubWF0Y2goTXQpKXtjb25zdCBpPXMudmFsdWU7aWYodGhpcy5sYXlvdXRfPXRoaXMucGFyc2VHZW9tZXRyeUxheW91dF8oKSxcIkdFT01FVFJZQ09MTEVDVElPTlwiPT1pKXtjb25zdCBlPXRoaXMucGFyc2VHZW9tZXRyeUNvbGxlY3Rpb25UZXh0XygpO3JldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX1zd2l0Y2goaSl7Y2FzZVwiUE9JTlRcIjp7Y29uc3QgZT10aGlzLnBhcnNlUG9pbnRUZXh0XygpO3JldHVybiBlP3QuY3JlYXRlUG9pbnQobmV3IG0oLi4uZSkpOnQuY3JlYXRlUG9pbnQoKX1jYXNlXCJMSU5FU1RSSU5HXCI6e2NvbnN0IG49dGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpLm1hcChlKTtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKG4pfWNhc2VcIkxJTkVBUlJJTkdcIjp7Y29uc3Qgbj10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCkubWFwKGUpO3JldHVybiB0LmNyZWF0ZUxpbmVhclJpbmcobil9Y2FzZVwiUE9MWUdPTlwiOntjb25zdCBlPXRoaXMucGFyc2VQb2x5Z29uVGV4dF8oKTtyZXR1cm4gZSYmMCE9PWUubGVuZ3RoP24oZSk6dC5jcmVhdGVQb2x5Z29uKCl9Y2FzZVwiTVVMVElQT0lOVFwiOntjb25zdCBuPXRoaXMucGFyc2VNdWx0aVBvaW50VGV4dF8oKTtpZighbnx8MD09PW4ubGVuZ3RoKXJldHVybiB0LmNyZWF0ZU11bHRpUG9pbnQoKTtjb25zdCBzPW4ubWFwKGUpLm1hcCgoZT0+dC5jcmVhdGVQb2ludChlKSkpO3JldHVybiB0LmNyZWF0ZU11bHRpUG9pbnQocyl9Y2FzZVwiTVVMVElMSU5FU1RSSU5HXCI6e2NvbnN0IG49dGhpcy5wYXJzZU11bHRpTGluZVN0cmluZ1RleHRfKCkubWFwKChuPT50LmNyZWF0ZUxpbmVTdHJpbmcobi5tYXAoZSkpKSk7cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfWNhc2VcIk1VTFRJUE9MWUdPTlwiOntjb25zdCBlPXRoaXMucGFyc2VNdWx0aVBvbHlnb25UZXh0XygpO2lmKCFlfHwwPT09ZS5sZW5ndGgpcmV0dXJuIHQuY3JlYXRlTXVsdGlQb2x5Z29uKCk7Y29uc3Qgcz1lLm1hcChuKTtyZXR1cm4gdC5jcmVhdGVNdWx0aVBvbHlnb24ocyl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdlb21ldHJ5IHR5cGU6IFwiK2kpfX10aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfX1mdW5jdGlvbiBWdCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm5cIlwiO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKCksbj1bZS54LGUueV07cmV0dXJuIGUueiYmbi5wdXNoKGUueiksZS5tJiZuLnB1c2goZS5tKSxuLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIHp0KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLm1hcCgodD0+W3QueCx0LnldKSksbj1bXTtmb3IobGV0IHQ9MCxzPWUubGVuZ3RoO3Q8czsrK3Qpbi5wdXNoKGVbdF0uam9pbihcIiBcIikpO3JldHVybiBuLmpvaW4oXCIsIFwiKX1mdW5jdGlvbiBrdCh0KXtjb25zdCBlPVtdO2UucHVzaChcIihcIit6dCh0LmdldEV4dGVyaW9yUmluZygpKStcIilcIik7Zm9yKGxldCBuPTAscz10LmdldE51bUludGVyaW9yUmluZygpO248czsrK24pZS5wdXNoKFwiKFwiK3p0KHQuZ2V0SW50ZXJpb3JSaW5nTihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX1jb25zdCBYdD17UG9pbnQ6VnQsTGluZVN0cmluZzp6dCxMaW5lYXJSaW5nOnp0LFBvbHlnb246a3QsTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goXCIoXCIrVnQodC5nZXRHZW9tZXRyeU4obikpK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goXCIoXCIrenQodC5nZXRHZW9tZXRyeU4obikpK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goXCIoXCIra3QodC5nZXRHZW9tZXRyeU4obikpK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wLHM9dC5nZXROdW1HZW9tZXRyaWVzKCk7bjxzOysrbillLnB1c2goVXQodC5nZXRHZW9tZXRyeU4obikpKTtyZXR1cm4gZS5qb2luKFwiLCBcIil9fTtmdW5jdGlvbiBVdCh0KXtsZXQgZT10LmdldEdlb21ldHJ5VHlwZSgpO2NvbnN0IG49WHRbZV07ZT1lLnRvVXBwZXJDYXNlKCk7Y29uc3Qgcz1mdW5jdGlvbih0KXtsZXQgZT1cIlwiO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlO2NvbnN0IG49dC5nZXRDb29yZGluYXRlKCk7cmV0dXJuIG4ueiYmKGUrPVwiWlwiKSxuLm0mJihlKz1cIk1cIiksZX0odCk7aWYocy5sZW5ndGg+MCYmKGUrPVwiIFwiK3MpLHQuaXNFbXB0eSgpKXJldHVybiBlK1wiIFwiK3Z0O3JldHVybiBlK1wiIChcIituKHQpK1wiKVwifWNsYXNzIEh0e2NvbnN0cnVjdG9yKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBDdCx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCl9cmVhZCh0KXtjb25zdCBlPW5ldyBCdCh0KTtyZXR1cm4gbmV3IFl0KGUsdGhpcy5nZW9tZXRyeUZhY3RvcnkpLnBhcnNlKCl9d3JpdGUodCl7cmV0dXJuIFV0KHQpfX1jbGFzcyBXdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgSHQodCl9d3JpdGUodCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfXN0YXRpYyB0b0xpbmVTdHJpbmcodCxlKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7cmV0dXJuXCJMSU5FU1RSSU5HICggXCIrdC54K1wiIFwiK3QueStcIiwgXCIrZS54K1wiIFwiK2UueStcIiApXCJ9fWNsYXNzIFp0e2NvbnN0cnVjdG9yKCl7WnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVzdWx0PW51bGwsdGhpcy5faW5wdXRMaW5lcz1BcnJheSgyKS5maWxsKCkubWFwKCgoKT0+QXJyYXkoMikpKSx0aGlzLl9pbnRQdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9pbnRMaW5lSW5kZXg9bnVsbCx0aGlzLl9pc1Byb3Blcj1udWxsLHRoaXMuX3BhPW51bGwsdGhpcy5fcGI9bnVsbCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2ludFB0WzBdPW5ldyBtLHRoaXMuX2ludFB0WzFdPW5ldyBtLHRoaXMuX3BhPXRoaXMuX2ludFB0WzBdLHRoaXMuX3BiPXRoaXMuX2ludFB0WzFdLHRoaXMuX3Jlc3VsdD0wfXN0YXRpYyBjb21wdXRlRWRnZURpc3RhbmNlKHQsZSxuKXtjb25zdCBzPU1hdGguYWJzKG4ueC1lLngpLGk9TWF0aC5hYnMobi55LWUueSk7bGV0IHI9LTE7aWYodC5lcXVhbHMoZSkpcj0wO2Vsc2UgaWYodC5lcXVhbHMobikpcj1zPmk/czppO2Vsc2V7Y29uc3Qgbj1NYXRoLmFicyh0LngtZS54KSxvPU1hdGguYWJzKHQueS1lLnkpO3I9cz5pP246bywwIT09cnx8dC5lcXVhbHMoZSl8fChyPU1hdGgubWF4KG4sbykpfXJldHVybiBnLmlzVHJ1ZSghKDA9PT1yJiYhdC5lcXVhbHMoZSkpLFwiQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHJ9c3RhdGljIG5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnkscj1NYXRoLnNxcnQocypzK2kqaSk7cmV0dXJuIGcuaXNUcnVlKCEoMD09PXImJiF0LmVxdWFscyhlKSksXCJJbnZhbGlkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHJ9Z2V0SW5kZXhBbG9uZ1NlZ21lbnQodCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5faW50TGluZUluZGV4W3RdW2VdfWdldFRvcG9sb2d5U3VtbWFyeSgpe2NvbnN0IHQ9bmV3IF90O3JldHVybiB0aGlzLmlzRW5kUG9pbnQoKSYmdC5hcHBlbmQoXCIgZW5kcG9pbnRcIiksdGhpcy5faXNQcm9wZXImJnQuYXBwZW5kKFwiIHByb3BlclwiKSx0aGlzLmlzQ29sbGluZWFyKCkmJnQuYXBwZW5kKFwiIGNvbGxpbmVhclwiKSx0LnRvU3RyaW5nKCl9Y29tcHV0ZUludGVyc2VjdGlvbih0LGUsbixzKXt0aGlzLl9pbnB1dExpbmVzWzBdWzBdPXQsdGhpcy5faW5wdXRMaW5lc1swXVsxXT1lLHRoaXMuX2lucHV0TGluZXNbMV1bMF09bix0aGlzLl9pbnB1dExpbmVzWzFdWzFdPXMsdGhpcy5fcmVzdWx0PXRoaXMuY29tcHV0ZUludGVyc2VjdCh0LGUsbixzKX1nZXRJbnRlcnNlY3Rpb25OdW0oKXtyZXR1cm4gdGhpcy5fcmVzdWx0fWNvbXB1dGVJbnRMaW5lSW5kZXgoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCludWxsPT09dGhpcy5faW50TGluZUluZGV4JiYodGhpcy5faW50TGluZUluZGV4PUFycmF5KDIpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgyKSkpLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMSkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMCk+dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwxKT8odGhpcy5faW50TGluZUluZGV4W3RdWzBdPTAsdGhpcy5faW50TGluZUluZGV4W3RdWzFdPTEpOih0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMF09MSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMV09MCl9fWlzUHJvcGVyKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2lzUHJvcGVyfXNldFByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3ByZWNpc2lvbk1vZGVsPXR9aXNJbnRlcmlvckludGVyc2VjdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDApfHwhIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigxKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9yZXN1bHQ7ZSsrKWlmKCF0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLl9pbnB1dExpbmVzW3RdWzBdKSYmIXRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHRoaXMuX2lucHV0TGluZXNbdF1bMV0pKXJldHVybiEwO3JldHVybiExfX1nZXRJbnRlcnNlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2ludFB0W3RdfWlzRW5kUG9pbnQoKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9yZXN1bHQhPT1adC5OT19JTlRFUlNFQ1RJT059Z2V0RWRnZURpc3RhbmNlKHQsZSl7cmV0dXJuIFp0LmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5faW50UHRbZV0sdGhpcy5faW5wdXRMaW5lc1t0XVswXSx0aGlzLl9pbnB1dExpbmVzW3RdWzFdKX1pc0NvbGxpbmVhcigpe3JldHVybiB0aGlzLl9yZXN1bHQ9PT1adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLHRoaXMuX2lucHV0TGluZXNbMF1bMV0pK1wiIC0gXCIrV3QudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sdGhpcy5faW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX1nZXRFbmRwb2ludCh0LGUpe3JldHVybiB0aGlzLl9pbnB1dExpbmVzW3RdW2VdfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcmVzdWx0O2UrKylpZih0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0KSlyZXR1cm4hMDtyZXR1cm4hMX1nZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQodCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5faW50UHRbdGhpcy5faW50TGluZUluZGV4W3RdW2VdXX19WnQuRE9OVF9JTlRFUlNFQ1Q9MCxadC5ET19JTlRFUlNFQ1Q9MSxadC5DT0xMSU5FQVI9MixadC5OT19JTlRFUlNFQ1RJT049MCxadC5QT0lOVF9JTlRFUlNFQ1RJT049MSxadC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OPTI7Y2xhc3MganQgZXh0ZW5kcyBadHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9c3RhdGljIG5lYXJlc3RFbmRwb2ludCh0LGUsbixzKXtsZXQgaT10LHI9Vi5wb2ludFRvU2VnbWVudCh0LG4scyksbz1WLnBvaW50VG9TZWdtZW50KGUsbixzKTtyZXR1cm4gbzxyJiYocj1vLGk9ZSksbz1WLnBvaW50VG9TZWdtZW50KG4sdCxlKSxvPHImJihyPW8saT1uKSxvPVYucG9pbnRUb1NlZ21lbnQocyx0LGUpLG88ciYmKHI9byxpPXMpLGl9aXNJblNlZ21lbnRFbnZlbG9wZXModCl7Y29uc3QgZT1uZXcgTyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLHRoaXMuX2lucHV0TGluZXNbMF1bMV0pLG49bmV3IE8odGhpcy5faW5wdXRMaW5lc1sxXVswXSx0aGlzLl9pbnB1dExpbmVzWzFdWzFdKTtyZXR1cm4gZS5jb250YWlucyh0KSYmbi5jb250YWlucyh0KX1jb21wdXRlSW50ZXJzZWN0aW9uKCl7aWYoMyE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHN1cGVyLmNvbXB1dGVJbnRlcnNlY3Rpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLl9pc1Byb3Blcj0hMSxPLmludGVyc2VjdHMoZSxuLHQpJiYwPT09Ry5pbmRleChlLG4sdCkmJjA9PT1HLmluZGV4KG4sZSx0KSlyZXR1cm4gdGhpcy5faXNQcm9wZXI9ITAsKHQuZXF1YWxzKGUpfHx0LmVxdWFscyhuKSkmJih0aGlzLl9pc1Byb3Blcj0hMSksdGhpcy5fcmVzdWx0PVp0LlBPSU5UX0lOVEVSU0VDVElPTixudWxsO3RoaXMuX3Jlc3VsdD1adC5OT19JTlRFUlNFQ1RJT059fWludGVyc2VjdGlvbih0LGUsbixzKXtsZXQgaT10aGlzLmludGVyc2VjdGlvblNhZmUodCxlLG4scyk7cmV0dXJuIHRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMoaSl8fChpPW5ldyBtKGp0Lm5lYXJlc3RFbmRwb2ludCh0LGUsbixzKSkpLG51bGwhPT10aGlzLl9wcmVjaXNpb25Nb2RlbCYmdGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoaSksaX1jaGVja0REKHQsZSxuLHMsaSl7Y29uc3Qgcj1BLmludGVyc2VjdGlvbih0LGUsbixzKSxvPXRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMocik7Qi5vdXQucHJpbnRsbihcIkREIGluIGVudiA9IFwiK28rXCIgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcIityKSxpLmRpc3RhbmNlKHIpPjFlLTQmJkIub3V0LnByaW50bG4oXCJEaXN0YW5jZSA9IFwiK2kuZGlzdGFuY2UocikpfWludGVyc2VjdGlvblNhZmUodCxlLG4scyl7bGV0IGk9cS5pbnRlcnNlY3Rpb24odCxlLG4scyk7cmV0dXJuIG51bGw9PT1pJiYoaT1qdC5uZWFyZXN0RW5kcG9pbnQodCxlLG4scykpLGl9Y29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPU8uaW50ZXJzZWN0cyh0LGUsbikscj1PLmludGVyc2VjdHModCxlLHMpLG89Ty5pbnRlcnNlY3RzKG4scyx0KSxsPU8uaW50ZXJzZWN0cyhuLHMsZSk7cmV0dXJuIGkmJnI/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09cyxadC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpvJiZsPyh0aGlzLl9pbnRQdFswXT10LHRoaXMuX2ludFB0WzFdPWUsWnQuQ09MTElORUFSX0lOVEVSU0VDVElPTik6aSYmbz8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT10LCFuLmVxdWFscyh0KXx8cnx8bD9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6aSYmbD8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT1lLCFuLmVxdWFscyhlKXx8cnx8bz9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6ciYmbz8odGhpcy5faW50UHRbMF09cyx0aGlzLl9pbnRQdFsxXT10LCFzLmVxdWFscyh0KXx8aXx8bD9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6ciYmbD8odGhpcy5faW50UHRbMF09cyx0aGlzLl9pbnRQdFsxXT1lLCFzLmVxdWFscyhlKXx8aXx8bz9adC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOlp0LlBPSU5UX0lOVEVSU0VDVElPTik6WnQuTk9fSU5URVJTRUNUSU9OfWNvbXB1dGVJbnRlcnNlY3QodCxlLG4scyl7aWYodGhpcy5faXNQcm9wZXI9ITEsIU8uaW50ZXJzZWN0cyh0LGUsbixzKSlyZXR1cm4gWnQuTk9fSU5URVJTRUNUSU9OO2NvbnN0IGk9Ry5pbmRleCh0LGUsbikscj1HLmluZGV4KHQsZSxzKTtpZihpPjAmJnI+MHx8aTwwJiZyPDApcmV0dXJuIFp0Lk5PX0lOVEVSU0VDVElPTjtjb25zdCBvPUcuaW5kZXgobixzLHQpLGw9Ry5pbmRleChuLHMsZSk7aWYobz4wJiZsPjB8fG88MCYmbDwwKXJldHVybiBadC5OT19JTlRFUlNFQ1RJT047cmV0dXJuIDA9PT1pJiYwPT09ciYmMD09PW8mJjA9PT1sP3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixzKTooMD09PWl8fDA9PT1yfHwwPT09b3x8MD09PWw/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQocyk/dGhpcy5faW50UHRbMF09dDplLmVxdWFsczJEKG4pfHxlLmVxdWFsczJEKHMpP3RoaXMuX2ludFB0WzBdPWU6MD09PWk/dGhpcy5faW50UHRbMF09bmV3IG0obik6MD09PXI/dGhpcy5faW50UHRbMF09bmV3IG0ocyk6MD09PW8/dGhpcy5faW50UHRbMF09bmV3IG0odCk6MD09PWwmJih0aGlzLl9pbnRQdFswXT1uZXcgbShlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLl9pbnRQdFswXT10aGlzLmludGVyc2VjdGlvbih0LGUsbixzKSksWnQuUE9JTlRfSU5URVJTRUNUSU9OKX19Y2xhc3MgS3R7Y29uc3RydWN0b3IoKXtLdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUt0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IG0sbmV3IG0pO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0t0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnAwPXQsdGhpcy5wMT1lfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO0t0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IG0odCxlKSxuZXcgbShuLHMpKX19c3RhdGljIG1pZFBvaW50KHQsZSl7cmV0dXJuIG5ldyBtKCh0LngrZS54KS8yLCh0LnkrZS55KS8yKX1taW5YKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueCx0aGlzLnAxLngpfW9yaWVudGF0aW9uSW5kZXgoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPUcuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDApLG49Ry5pbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMSk7cmV0dXJuIGU+PTAmJm4+PTB8fGU8PTAmJm48PTA/TWF0aC5tYXgoZSxuKTowfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEcuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQpfX10b0dlb21ldHJ5KHQpe3JldHVybiB0LmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMucDAsdGhpcy5wMV0pfWlzVmVydGljYWwoKXtyZXR1cm4gdGhpcy5wMC54PT09dGhpcy5wMS54fWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBLdCkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLnAwLmVxdWFscyhlLnAwKSYmdGhpcy5wMS5lcXVhbHMoZS5wMSl9aW50ZXJzZWN0aW9uKHQpe2NvbnN0IGU9bmV3IGp0O3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfXByb2plY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuZXF1YWxzKHRoaXMucDApfHx0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gbmV3IG0odCk7Y29uc3QgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgbTtyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMCksbj10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMSk7aWYoZT49MSYmbj49MSlyZXR1cm4gbnVsbDtpZihlPD0wJiZuPD0wKXJldHVybiBudWxsO2xldCBzPXRoaXMucHJvamVjdCh0LnAwKTtlPDAmJihzPXRoaXMucDApLGU+MSYmKHM9dGhpcy5wMSk7bGV0IGk9dGhpcy5wcm9qZWN0KHQucDEpO3JldHVybiBuPDAmJihpPXRoaXMucDApLG4+MSYmKGk9dGhpcy5wMSksbmV3IEt0KHMsaSl9fW5vcm1hbGl6ZSgpe3RoaXMucDEuY29tcGFyZVRvKHRoaXMucDApPDAmJnRoaXMucmV2ZXJzZSgpfWFuZ2xlKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX1nZXRDb29yZGluYXRlKHQpe3JldHVybiAwPT09dD90aGlzLnAwOnRoaXMucDF9ZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHQpe3JldHVybiBWLnBvaW50VG9MaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9bWluWSgpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLnksdGhpcy5wMS55KX1taWRQb2ludCgpe3JldHVybiBLdC5taWRQb2ludCh0aGlzLnAwLHRoaXMucDEpfXByb2plY3Rpb25GYWN0b3IodCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7Y29uc3QgZT10aGlzLnAxLngtdGhpcy5wMC54LG49dGhpcy5wMS55LXRoaXMucDAueSxzPWUqZStuKm47aWYoczw9MClyZXR1cm4gci5OYU47cmV0dXJuKCh0LngtdGhpcy5wMC54KSplKyh0LnktdGhpcy5wMC55KSpuKS9zfWNsb3Nlc3RQb2ludHModCl7Y29uc3QgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTtjb25zdCBuPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2xldCBzPXIuTUFYX1ZBTFVFLGk9bnVsbDtjb25zdCBvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO3M9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO2NvbnN0IGw9dGhpcy5jbG9zZXN0UG9pbnQodC5wMSk7aT1sLmRpc3RhbmNlKHQucDEpLGk8cyYmKHM9aSxuWzBdPWwsblsxXT10LnAxKTtjb25zdCBhPXQuY2xvc2VzdFBvaW50KHRoaXMucDApO2k9YS5kaXN0YW5jZSh0aGlzLnAwKSxpPHMmJihzPWksblswXT10aGlzLnAwLG5bMV09YSk7Y29uc3QgYz10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gaT1jLmRpc3RhbmNlKHRoaXMucDEpLGk8cyYmKHM9aSxuWzBdPXRoaXMucDEsblsxXT1jKSxufWNsb3Nlc3RQb2ludCh0KXtjb25zdCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtpZihlPjAmJmU8MSlyZXR1cm4gdGhpcy5wcm9qZWN0KHQpO3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHQpPHRoaXMucDEuZGlzdGFuY2UodCk/dGhpcy5wMDp0aGlzLnAxfW1heFgoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LHRoaXMucDEueCl9Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMucDAuZGlzdGFuY2UodGhpcy5wMSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dCxuPXRoaXMucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnRoaXMucDEuY29tcGFyZVRvKGUucDEpfXJldmVyc2UoKXtjb25zdCB0PXRoaXMucDA7dGhpcy5wMD10aGlzLnAxLHRoaXMucDE9dH1lcXVhbHNUb3BvKHQpe3JldHVybiB0aGlzLnAwLmVxdWFscyh0LnAwKSYmdGhpcy5wMS5lcXVhbHModC5wMSl8fHRoaXMucDAuZXF1YWxzKHQucDEpJiZ0aGlzLnAxLmVxdWFscyh0LnAwKX1saW5lSW50ZXJzZWN0aW9uKHQpe3JldHVybiBxLmludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1tYXhZKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMucDAueSx0aGlzLnAxLnkpfXBvaW50QWxvbmdPZmZzZXQodCxlKXtjb25zdCBuPXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxzPXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxpPXRoaXMucDEueC10aGlzLnAwLngscj10aGlzLnAxLnktdGhpcy5wMC55LG89TWF0aC5zcXJ0KGkqaStyKnIpO2xldCBsPTAsYT0wO2lmKDAhPT1lKXtpZihvPD0wKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJDYW5ub3QgY29tcHV0ZSBvZmZzZXQgZnJvbSB6ZXJvLWxlbmd0aCBsaW5lIHNlZ21lbnRcIik7bD1lKmkvbyxhPWUqci9vfXJldHVybiBuZXcgbShuLWEscytsKX1zZXRDb29yZGluYXRlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldENvb3JkaW5hdGVzKHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wMC54PXQueCx0aGlzLnAwLnk9dC55LHRoaXMucDEueD1lLngsdGhpcy5wMS55PWUueX19c2VnbWVudEZyYWN0aW9uKHQpe2xldCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtyZXR1cm4gZTwwP2U9MDooZT4xfHxyLmlzTmFOKGUpKSYmKGU9MSksZX10b1N0cmluZygpe3JldHVyblwiTElORVNUUklORyggXCIrdGhpcy5wMC54K1wiIFwiK3RoaXMucDAueStcIiwgXCIrdGhpcy5wMS54K1wiIFwiK3RoaXMucDEueStcIilcIn1pc0hvcml6b250YWwoKXtyZXR1cm4gdGhpcy5wMC55PT09dGhpcy5wMS55fXJlZmxlY3QodCl7Y29uc3QgZT10aGlzLnAxLmdldFkoKS10aGlzLnAwLmdldFkoKSxuPXRoaXMucDAuZ2V0WCgpLXRoaXMucDEuZ2V0WCgpLHM9dGhpcy5wMC5nZXRZKCkqKHRoaXMucDEuZ2V0WCgpLXRoaXMucDAuZ2V0WCgpKS10aGlzLnAwLmdldFgoKSoodGhpcy5wMS5nZXRZKCktdGhpcy5wMC5nZXRZKCkpLGk9ZSplK24qbixyPWUqZS1uKm4sbz10LmdldFgoKSxsPXQuZ2V0WSgpO3JldHVybiBuZXcgbSgoLXIqby0yKmUqbipsLTIqZSpzKS9pLChyKmwtMiplKm4qby0yKm4qcykvaSl9ZGlzdGFuY2UoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gVi5zZWdtZW50VG9TZWdtZW50KHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFYucG9pbnRUb1NlZ21lbnQodCx0aGlzLnAwLHRoaXMucDEpfX1wb2ludEFsb25nKHQpe2NvbnN0IGU9bmV3IG07cmV0dXJuIGUueD10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCksZS55PXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxlfWhhc2hDb2RlKCl7bGV0IHQ9ci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7Y29uc3QgZT1NYXRoLnRydW5jKHQpXk1hdGgudHJ1bmModD4+MzIpO2xldCBuPXIuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO25ePTMxKnIuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpO3JldHVybiBlXihNYXRoLnRydW5jKG4pXk1hdGgudHJ1bmMobj4+MzIpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxjXX19Y2xhc3MgUXR7c3RhdGljIHRvTG9jYXRpb25TeW1ib2wodCl7c3dpdGNoKHQpe2Nhc2UgUXQuRVhURVJJT1I6cmV0dXJuXCJlXCI7Y2FzZSBRdC5CT1VOREFSWTpyZXR1cm5cImJcIjtjYXNlIFF0LklOVEVSSU9SOnJldHVyblwiaVwiO2Nhc2UgUXQuTk9ORTpyZXR1cm5cIi1cIn10aHJvdyBuZXcgcyhcIlVua25vd24gbG9jYXRpb24gdmFsdWU6IFwiK3QpfX1RdC5JTlRFUklPUj0wLFF0LkJPVU5EQVJZPTEsUXQuRVhURVJJT1I9MixRdC5OT05FPS0xO2NsYXNzIEp0e2NvbnN0cnVjdG9yKCl7SnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbWF0cml4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbWF0cml4PUFycmF5KDMpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgzKSkpLHRoaXMuc2V0QWxsKEsuRkFMU0UpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07SnQuY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5zZXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEp0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtKdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXT10Ll9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXT10Ll9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXT10Ll9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXT10Ll9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXT10Ll9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXT10Ll9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXT10Ll9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXT10Ll9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkVYVEVSSU9SXT10Ll9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkVYVEVSSU9SXX19c3RhdGljIG1hdGNoZXMoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBlPT09Sy5TWU1fRE9OVENBUkV8fChlPT09Sy5TWU1fVFJVRSYmKHQ+PTB8fHQ9PT1LLlRSVUUpfHwoZT09PUsuU1lNX0ZBTFNFJiZ0PT09Sy5GQUxTRXx8KGU9PT1LLlNZTV9QJiZ0PT09Sy5QfHwoZT09PUsuU1lNX0wmJnQ9PT1LLkx8fGU9PT1LLlNZTV9BJiZ0PT09Sy5BKSkpKX1pZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IEp0KGFyZ3VtZW50c1swXSkubWF0Y2hlcyh0KX19c3RhdGljIGlzVHJ1ZSh0KXtyZXR1cm4gdD49MHx8dD09PUsuVFJVRX1pc0ludGVyc2VjdHMoKXtyZXR1cm4hdGhpcy5pc0Rpc2pvaW50KCl9aXNDb3ZlcnMoKXtyZXR1cm4oSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldKSkmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPT09Sy5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV09PT1LLkZBTFNFfWlzQ292ZXJlZEJ5KCl7cmV0dXJuKEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXSkpJiZ0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXT09PUsuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdPT09Sy5GQUxTRX1zZXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49TWF0aC50cnVuYyhlLzMpLHM9ZSUzO3RoaXMuX21hdHJpeFtuXVtzXT1LLnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9tYXRyaXhbdF1bZV09bn19aXNDb250YWlucygpe3JldHVybiBKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXT09PUsuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldPT09Sy5GQUxTRX1zZXRBdExlYXN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPU1hdGgudHJ1bmMoZS8zKSxzPWUlMzt0aGlzLnNldEF0TGVhc3QobixzLEsudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSkpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9tYXRyaXhbdF1bZV08biYmKHRoaXMuX21hdHJpeFt0XVtlXT1uKX19c2V0QXRMZWFzdElmVmFsaWQodCxlLG4pe3Q+PTAmJmU+PTAmJnRoaXMuc2V0QXRMZWFzdCh0LGUsbil9aXNXaXRoaW4oKXtyZXR1cm4gSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl09PT1LLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXT09PUsuRkFMU0V9aXNUb3VjaGVzKHQsZSl7cmV0dXJuIHQ+ZT90aGlzLmlzVG91Y2hlcyhlLHQpOih0PT09Sy5BJiZlPT09Sy5BfHx0PT09Sy5MJiZlPT09Sy5MfHx0PT09Sy5MJiZlPT09Sy5BfHx0PT09Sy5QJiZlPT09Sy5BfHx0PT09Sy5QJiZlPT09Sy5MKSYmKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdPT09Sy5GQUxTRSYmKEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkJPVU5EQVJZXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXSl8fEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXSkpKX1pc092ZXJsYXBzKHQsZSl7cmV0dXJuIHQ9PT1LLlAmJmU9PT1LLlB8fHQ9PT1LLkEmJmU9PT1LLkE/SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdKTp0PT09Sy5MJiZlPT09Sy5MJiYoMT09PXRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl0pKX1pc0VxdWFscyh0LGUpe3JldHVybiB0PT09ZSYmKEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdPT09Sy5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5FWFRFUklPUl09PT1LLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXT09PUsuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldPT09Sy5GQUxTRSl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyBfdChcIjEyMzQ1Njc4OVwiKTtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdC5zZXRDaGFyQXQoMyplK24sSy50b0RpbWVuc2lvblN5bWJvbCh0aGlzLl9tYXRyaXhbZV1bbl0pKTtyZXR1cm4gdC50b1N0cmluZygpfXNldEFsbCh0KXtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdGhpcy5fbWF0cml4W2VdW25dPXR9Z2V0KHQsZSl7cmV0dXJuIHRoaXMuX21hdHJpeFt0XVtlXX10cmFuc3Bvc2UoKXtsZXQgdD10aGlzLl9tYXRyaXhbMV1bMF07cmV0dXJuIHRoaXMuX21hdHJpeFsxXVswXT10aGlzLl9tYXRyaXhbMF1bMV0sdGhpcy5fbWF0cml4WzBdWzFdPXQsdD10aGlzLl9tYXRyaXhbMl1bMF0sdGhpcy5fbWF0cml4WzJdWzBdPXRoaXMuX21hdHJpeFswXVsyXSx0aGlzLl9tYXRyaXhbMF1bMl09dCx0PXRoaXMuX21hdHJpeFsyXVsxXSx0aGlzLl9tYXRyaXhbMl1bMV09dGhpcy5fbWF0cml4WzFdWzJdLHRoaXMuX21hdHJpeFsxXVsyXT10LHRoaXN9bWF0Y2hlcyh0KXtpZig5IT09dC5sZW5ndGgpdGhyb3cgbmV3IHMoXCJTaG91bGQgYmUgbGVuZ3RoIDk6IFwiK3QpO2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKylpZighSnQubWF0Y2hlcyh0aGlzLl9tYXRyaXhbZV1bbl0sdC5jaGFyQXQoMyplK24pKSlyZXR1cm4hMTtyZXR1cm4hMH1hZGQodCl7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXRoaXMuc2V0QXRMZWFzdChlLG4sdC5nZXQoZSxuKSl9aXNEaXNqb2ludCgpe3JldHVybiB0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXT09PUsuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldPT09Sy5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl09PT1LLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkJPVU5EQVJZXT09PUsuRkFMU0V9aXNDcm9zc2VzKHQsZSl7cmV0dXJuIHQ9PT1LLlAmJmU9PT1LLkx8fHQ9PT1LLlAmJmU9PT1LLkF8fHQ9PT1LLkwmJmU9PT1LLkE/SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdKTp0PT09Sy5MJiZlPT09Sy5QfHx0PT09Sy5BJiZlPT09Sy5QfHx0PT09Sy5BJiZlPT09Sy5MP0p0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXSk6dD09PUsuTCYmZT09PUsuTCYmMD09PXRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19Y2xhc3MgJHR7c3RhdGljIHRvRGVncmVlcyh0KXtyZXR1cm4gMTgwKnQvTWF0aC5QSX1zdGF0aWMgbm9ybWFsaXplKHQpe2Zvcig7dD5NYXRoLlBJOyl0LT0kdC5QSV9USU1FU18yO2Zvcig7dDw9LU1hdGguUEk7KXQrPSR0LlBJX1RJTUVTXzI7cmV0dXJuIHR9c3RhdGljIGFuZ2xlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmF0YW4yKHQueSx0LngpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10Lngscz1lLnktdC55O3JldHVybiBNYXRoLmF0YW4yKHMsbil9fXN0YXRpYyBpc0FjdXRlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55O3JldHVybiBzKihuLngtZS54KStpKihuLnktZS55KT4wfXN0YXRpYyBpc09idHVzZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueTtyZXR1cm4gcyoobi54LWUueCkraSoobi55LWUueSk8MH1zdGF0aWMgaW50ZXJpb3JBbmdsZSh0LGUsbil7Y29uc3Qgcz0kdC5hbmdsZShlLHQpLGk9JHQuYW5nbGUoZSxuKTtyZXR1cm4gTWF0aC5hYnMoaS1zKX1zdGF0aWMgbm9ybWFsaXplUG9zaXRpdmUodCl7aWYodDwwKXtmb3IoO3Q8MDspdCs9JHQuUElfVElNRVNfMjt0Pj0kdC5QSV9USU1FU18yJiYodD0wKX1lbHNle2Zvcig7dD49JHQuUElfVElNRVNfMjspdC09JHQuUElfVElNRVNfMjt0PDAmJih0PTApfXJldHVybiB0fXN0YXRpYyBhbmdsZUJldHdlZW4odCxlLG4pe2NvbnN0IHM9JHQuYW5nbGUoZSx0KSxpPSR0LmFuZ2xlKGUsbik7cmV0dXJuICR0LmRpZmYocyxpKX1zdGF0aWMgZGlmZih0LGUpe2xldCBuPW51bGw7cmV0dXJuIG49dDxlP2UtdDp0LWUsbj5NYXRoLlBJJiYobj0yKk1hdGguUEktbiksbn1zdGF0aWMgdG9SYWRpYW5zKHQpe3JldHVybiB0Kk1hdGguUEkvMTgwfXN0YXRpYyBnZXRUdXJuKHQsZSl7Y29uc3Qgbj1NYXRoLnNpbihlLXQpO3JldHVybiBuPjA/JHQuQ09VTlRFUkNMT0NLV0lTRTpuPDA/JHQuQ0xPQ0tXSVNFOiR0Lk5PTkV9c3RhdGljIGFuZ2xlQmV0d2Vlbk9yaWVudGVkKHQsZSxuKXtjb25zdCBzPSR0LmFuZ2xlKGUsdCksaT0kdC5hbmdsZShlLG4pLXM7cmV0dXJuIGk8PS1NYXRoLlBJP2krJHQuUElfVElNRVNfMjppPk1hdGguUEk/aS0kdC5QSV9USU1FU18yOml9fSR0LlBJX1RJTUVTXzI9MipNYXRoLlBJLCR0LlBJX09WRVJfMj1NYXRoLlBJLzIsJHQuUElfT1ZFUl80PU1hdGguUEkvNCwkdC5DT1VOVEVSQ0xPQ0tXSVNFPUcuQ09VTlRFUkNMT0NLV0lTRSwkdC5DTE9DS1dJU0U9Ry5DTE9DS1dJU0UsJHQuTk9ORT1HLkNPTExJTkVBUjtjbGFzcyB0ZSBleHRlbmRzIG57Y29uc3RydWN0b3IoKXtzdXBlcigpLHRlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe24uY29uc3RydWN0b3JfLmNhbGwodGhpcyxcIlByb2plY3RpdmUgcG9pbnQgbm90IHJlcHJlc2VudGFibGUgb24gdGhlIENhcnRlc2lhbiBwbGFuZS5cIil9fWNsYXNzIGVle2NvbnN0cnVjdG9yKCl7ZWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy53PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy54PTAsdGhpcy55PTAsdGhpcy53PTE7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMudz0xfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMueD10LHRoaXMueT1lLHRoaXMudz0xfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQueSplLnctZS55KnQudyx0aGlzLnk9ZS54KnQudy10LngqZS53LHRoaXMudz10LngqZS55LWUueCp0Lnl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQueS1lLnksdGhpcy55PWUueC10LngsdGhpcy53PXQueCplLnktZS54KnQueX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy54PXQsdGhpcy55PWUsdGhpcy53PW59ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT10LnktZS55LHI9ZS54LXQueCxvPXQueCplLnktZS54KnQueSxsPW4ueS1zLnksYT1zLngtbi54LGM9bi54KnMueS1zLngqbi55O3RoaXMueD1yKmMtYSpvLHRoaXMueT1sKm8taSpjLHRoaXMudz1pKmEtbCpyfX1nZXRZKCl7Y29uc3QgdD10aGlzLnkvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdGU7cmV0dXJuIHR9Z2V0WCgpe2NvbnN0IHQ9dGhpcy54L3RoaXMudztpZihyLmlzTmFOKHQpfHxyLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IHRlO3JldHVybiB0fWdldENvb3JkaW5hdGUoKXtjb25zdCB0PW5ldyBtO3JldHVybiB0Lng9dGhpcy5nZXRYKCksdC55PXRoaXMuZ2V0WSgpLHR9fWNsYXNzIG5le2NvbnN0cnVjdG9yKCl7bmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLnAyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5wMD10LHRoaXMucDE9ZSx0aGlzLnAyPW59c3RhdGljIGFyZWEodCxlLG4pe3JldHVybiBNYXRoLmFicygoKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yKX1zdGF0aWMgc2lnbmVkQXJlYSh0LGUsbil7cmV0dXJuKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMn1zdGF0aWMgZGV0KHQsZSxuLHMpe3JldHVybiB0KnMtZSpufXN0YXRpYyBpbnRlcnBvbGF0ZVoodCxlLG4scyl7Y29uc3QgaT1lLngscj1lLnksbz1uLngtaSxsPXMueC1pLGE9bi55LXIsYz1zLnktcixoPW8qYy1sKmEsdT10LngtaSxnPXQueS1yLGQ9KGMqdS1sKmcpL2gsXz0oLWEqdStvKmcpL2g7cmV0dXJuIGUuZ2V0WigpK2QqKG4uZ2V0WigpLWUuZ2V0WigpKStfKihzLmdldFooKS1lLmdldFooKSl9c3RhdGljIGxvbmdlc3RTaWRlTGVuZ3RoKHQsZSxuKXtjb25zdCBzPXQuZGlzdGFuY2UoZSksaT1lLmRpc3RhbmNlKG4pLHI9bi5kaXN0YW5jZSh0KTtsZXQgbz1zO3JldHVybiBpPm8mJihvPWkpLHI+byYmKG89ciksb31zdGF0aWMgY2lyY3VtY2VudHJlREQodCxlLG4pe2NvbnN0IHM9RC52YWx1ZU9mKHQueCkuc3VidHJhY3Qobi54KSxpPUQudmFsdWVPZih0LnkpLnN1YnRyYWN0KG4ueSkscj1ELnZhbHVlT2YoZS54KS5zdWJ0cmFjdChuLngpLG89RC52YWx1ZU9mKGUueSkuc3VidHJhY3Qobi55KSxsPUQuZGV0ZXJtaW5hbnQocyxpLHIsbykubXVsdGlwbHkoMiksYT1zLnNxcigpLmFkZChpLnNxcigpKSxjPXIuc3FyKCkuYWRkKG8uc3FyKCkpLGg9RC5kZXRlcm1pbmFudChpLGEsbyxjKSx1PUQuZGV0ZXJtaW5hbnQocyxhLHIsYyksZz1ELnZhbHVlT2Yobi54KS5zdWJ0cmFjdChoLmRpdmlkZShsKSkuZG91YmxlVmFsdWUoKSxkPUQudmFsdWVPZihuLnkpLmFkZCh1LmRpdmlkZShsKSkuZG91YmxlVmFsdWUoKTtyZXR1cm4gbmV3IG0oZyxkKX1zdGF0aWMgaXNBY3V0ZSh0LGUsbil7cmV0dXJuISEkdC5pc0FjdXRlKHQsZSxuKSYmKCEhJHQuaXNBY3V0ZShlLG4sdCkmJiEhJHQuaXNBY3V0ZShuLHQsZSkpfXN0YXRpYyBjaXJjdW1jZW50cmUodCxlLG4pe2NvbnN0IHM9bi54LGk9bi55LHI9dC54LXMsbz10LnktaSxsPWUueC1zLGE9ZS55LWksYz0yKm5lLmRldChyLG8sbCxhKSxoPW5lLmRldChvLHIqcitvKm8sYSxsKmwrYSphKSx1PW5lLmRldChyLHIqcitvKm8sbCxsKmwrYSphKTtyZXR1cm4gbmV3IG0ocy1oL2MsaSt1L2MpfXN0YXRpYyBwZXJwZW5kaWN1bGFyQmlzZWN0b3IodCxlKXtjb25zdCBuPWUueC10Lngscz1lLnktdC55LGk9bmV3IGVlKHQueCtuLzIsdC55K3MvMiwxKSxyPW5ldyBlZSh0LngtcytuLzIsdC55K24rcy8yLDEpO3JldHVybiBuZXcgZWUoaSxyKX1zdGF0aWMgYW5nbGVCaXNlY3Rvcih0LGUsbil7Y29uc3Qgcz1lLmRpc3RhbmNlKHQpLGk9cy8ocytlLmRpc3RhbmNlKG4pKSxyPW4ueC10Lngsbz1uLnktdC55O3JldHVybiBuZXcgbSh0LngraSpyLHQueStpKm8pfXN0YXRpYyBhcmVhM0QodCxlLG4pe2NvbnN0IHM9ZS54LXQueCxpPWUueS10Lnkscj1lLmdldFooKS10LmdldFooKSxvPW4ueC10LngsbD1uLnktdC55LGE9bi5nZXRaKCktdC5nZXRaKCksYz1pKmEtcipsLGg9cipvLXMqYSx1PXMqbC1pKm8sZz1jKmMraCpoK3UqdTtyZXR1cm4gTWF0aC5zcXJ0KGcpLzJ9c3RhdGljIGNlbnRyb2lkKHQsZSxuKXtjb25zdCBzPSh0LngrZS54K24ueCkvMyxpPSh0LnkrZS55K24ueSkvMztyZXR1cm4gbmV3IG0ocyxpKX1zdGF0aWMgaW5DZW50cmUodCxlLG4pe2NvbnN0IHM9ZS5kaXN0YW5jZShuKSxpPXQuZGlzdGFuY2Uobikscj10LmRpc3RhbmNlKGUpLG89cytpK3IsbD0ocyp0LngraSplLngrcipuLngpL28sYT0ocyp0LnkraSplLnkrcipuLnkpL287cmV0dXJuIG5ldyBtKGwsYSl9YXJlYSgpe3JldHVybiBuZS5hcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1zaWduZWRBcmVhKCl7cmV0dXJuIG5lLnNpZ25lZEFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWludGVycG9sYXRlWih0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgcyhcIlN1cHBsaWVkIHBvaW50IGlzIG51bGwuXCIpO3JldHVybiBuZS5pbnRlcnBvbGF0ZVoodCx0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9bG9uZ2VzdFNpZGVMZW5ndGgoKXtyZXR1cm4gbmUubG9uZ2VzdFNpZGVMZW5ndGgodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWlzQWN1dGUoKXtyZXR1cm4gbmUuaXNBY3V0ZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Y2lyY3VtY2VudHJlKCl7cmV0dXJuIG5lLmNpcmN1bWNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9YXJlYTNEKCl7cmV0dXJuIG5lLmFyZWEzRCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Y2VudHJvaWQoKXtyZXR1cm4gbmUuY2VudHJvaWQodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWluQ2VudHJlKCl7cmV0dXJuIG5lLmluQ2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX19Y2xhc3Mgc2UgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxzZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCluLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO24uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19fWNsYXNzIGlle2NvbnN0cnVjdG9yKCl7aWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbTAwPW51bGwsdGhpcy5fbTAxPW51bGwsdGhpcy5fbTAyPW51bGwsdGhpcy5fbTEwPW51bGwsdGhpcy5fbTExPW51bGwsdGhpcy5fbTEyPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb0lkZW50aXR5KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbTAwPXRbMF0sdGhpcy5fbTAxPXRbMV0sdGhpcy5fbTAyPXRbMl0sdGhpcy5fbTEwPXRbM10sdGhpcy5fbTExPXRbNF0sdGhpcy5fbTEyPXRbNV19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGllKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQpfX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzVdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzRdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQsZSxuLHMsaSxyKX19c3RhdGljIHRyYW5zbGF0aW9uSW5zdGFuY2UodCxlKXtjb25zdCBuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1RyYW5zbGF0aW9uKHQsZSksbn1zdGF0aWMgc2hlYXJJbnN0YW5jZSh0LGUpe2NvbnN0IG49bmV3IGllO3JldHVybiBuLnNldFRvU2hlYXIodCxlKSxufXN0YXRpYyByZWZsZWN0aW9uSW5zdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9SZWZsZWN0aW9uKHQsZSksbn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgaWU7cmV0dXJuIGkuc2V0VG9SZWZsZWN0aW9uKHQsZSxuLHMpLGl9fXN0YXRpYyByb3RhdGlvbkluc3RhbmNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBpZS5yb3RhdGlvbkluc3RhbmNlKE1hdGguc2luKHQpLE1hdGguY29zKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9Sb3RhdGlvbih0LGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBpZS5yb3RhdGlvbkluc3RhbmNlKE1hdGguc2luKHQpLE1hdGguY29zKHQpLGUsbil9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGllO3JldHVybiBpLnNldFRvUm90YXRpb24odCxlLG4scyksaX19c3RhdGljIHNjYWxlSW5zdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9TY2FsZSh0LGUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGllO3JldHVybiBpLnRyYW5zbGF0ZSgtbiwtcyksaS5zY2FsZSh0LGUpLGkudHJhbnNsYXRlKG4scyksaX19c2V0VG9SZWZsZWN0aW9uQmFzaWModCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXRocm93IG5ldyBzKFwiUmVmbGVjdGlvbiBsaW5lIHBvaW50cyBtdXN0IGJlIGRpc3RpbmN0XCIpO2NvbnN0IHI9bi10LG89aS1lLGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9by9sLGM9ci9sLGg9MiphKmMsdT1jKmMtYSphO3JldHVybiB0aGlzLl9tMDA9dSx0aGlzLl9tMDE9aCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9aCx0aGlzLl9tMTE9LXUsdGhpcy5fbTEyPTAsdGhpc31nZXRJbnZlcnNlKCl7Y29uc3QgdD10aGlzLmdldERldGVybWluYW50KCk7aWYoMD09PXQpdGhyb3cgbmV3IHNlKFwiVHJhbnNmb3JtYXRpb24gaXMgbm9uLWludmVydGlibGVcIik7Y29uc3QgZT10aGlzLl9tMTEvdCxuPS10aGlzLl9tMTAvdCxzPS10aGlzLl9tMDEvdCxpPXRoaXMuX20wMC90LHI9KHRoaXMuX20wMSp0aGlzLl9tMTItdGhpcy5fbTAyKnRoaXMuX20xMSkvdCxvPSgtdGhpcy5fbTAwKnRoaXMuX20xMit0aGlzLl9tMTAqdGhpcy5fbTAyKS90O3JldHVybiBuZXcgaWUoZSxzLHIsbixpLG8pfWNvbXBvc2UodCl7Y29uc3QgZT10Ll9tMDAqdGhpcy5fbTAwK3QuX20wMSp0aGlzLl9tMTAsbj10Ll9tMDAqdGhpcy5fbTAxK3QuX20wMSp0aGlzLl9tMTEscz10Ll9tMDAqdGhpcy5fbTAyK3QuX20wMSp0aGlzLl9tMTIrdC5fbTAyLGk9dC5fbTEwKnRoaXMuX20wMCt0Ll9tMTEqdGhpcy5fbTEwLHI9dC5fbTEwKnRoaXMuX20wMSt0Ll9tMTEqdGhpcy5fbTExLG89dC5fbTEwKnRoaXMuX20wMit0Ll9tMTEqdGhpcy5fbTEyK3QuX20xMjtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPW4sdGhpcy5fbTAyPXMsdGhpcy5fbTEwPWksdGhpcy5fbTExPXIsdGhpcy5fbTEyPW8sdGhpc31lcXVhbHModCl7aWYobnVsbD09PXQpcmV0dXJuITE7aWYoISh0IGluc3RhbmNlb2YgaWUpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fbTAwPT09ZS5fbTAwJiZ0aGlzLl9tMDE9PT1lLl9tMDEmJnRoaXMuX20wMj09PWUuX20wMiYmdGhpcy5fbTEwPT09ZS5fbTEwJiZ0aGlzLl9tMTE9PT1lLl9tMTEmJnRoaXMuX20xMj09PWUuX20xMn1zZXRUb1NjYWxlKHQsZSl7cmV0dXJuIHRoaXMuX20wMD10LHRoaXMuX20wMT0wLHRoaXMuX20wMj0wLHRoaXMuX20xMD0wLHRoaXMuX20xMT1lLHRoaXMuX20xMj0wLHRoaXN9aXNJZGVudGl0eSgpe3JldHVybiAxPT09dGhpcy5fbTAwJiYwPT09dGhpcy5fbTAxJiYwPT09dGhpcy5fbTAyJiYwPT09dGhpcy5fbTEwJiYxPT09dGhpcy5fbTExJiYwPT09dGhpcy5fbTEyfXNjYWxlKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShpZS5zY2FsZUluc3RhbmNlKHQsZSkpLHRoaXN9c2V0VG9JZGVudGl0eSgpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9MCx0aGlzfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITB9c2V0VHJhbnNmb3JtYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX20wMD10Ll9tMDAsdGhpcy5fbTAxPXQuX20wMSx0aGlzLl9tMDI9dC5fbTAyLHRoaXMuX20xMD10Ll9tMTAsdGhpcy5fbTExPXQuX20xMSx0aGlzLl9tMTI9dC5fbTEyLHRoaXN9aWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3JldHVybiB0aGlzLl9tMDA9dCx0aGlzLl9tMDE9ZSx0aGlzLl9tMDI9bix0aGlzLl9tMTA9cyx0aGlzLl9tMTE9aSx0aGlzLl9tMTI9cix0aGlzfX1zZXRUb1JvdGF0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNldFRvUm90YXRpb24oTWF0aC5zaW4odCksTWF0aC5jb3ModCkpLHRoaXN9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9LXQsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPXQsdGhpcy5fbTExPWUsdGhpcy5fbTEyPTAsdGhpc31pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuc2V0VG9Sb3RhdGlvbihNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSxlLG4pLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9LXQsdGhpcy5fbTAyPW4tbiplK3MqdCx0aGlzLl9tMTA9dCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9cy1uKnQtcyplLHRoaXN9fWdldE1hdHJpeEVudHJpZXMoKXtyZXR1cm5bdGhpcy5fbTAwLHRoaXMuX20wMSx0aGlzLl9tMDIsdGhpcy5fbTEwLHRoaXMuX20xMSx0aGlzLl9tMTJdfWZpbHRlcih0LGUpe3RoaXMudHJhbnNmb3JtKHQsZSl9cm90YXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucm90YXRpb25JbnN0YW5jZSh0KSksdGhpc31pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucm90YXRpb25JbnN0YW5jZSh0LGUsbikpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0aGlzLmNvbXBvc2UoaWUucm90YXRpb25JbnN0YW5jZSh0LGUsbixzKSksdGhpc319Z2V0RGV0ZXJtaW5hbnQoKXtyZXR1cm4gdGhpcy5fbTAwKnRoaXMuX20xMS10aGlzLl9tMDEqdGhpcy5fbTEwfWNvbXBvc2VCZWZvcmUodCl7Y29uc3QgZT10aGlzLl9tMDAqdC5fbTAwK3RoaXMuX20wMSp0Ll9tMTAsbj10aGlzLl9tMDAqdC5fbTAxK3RoaXMuX20wMSp0Ll9tMTEscz10aGlzLl9tMDAqdC5fbTAyK3RoaXMuX20wMSp0Ll9tMTIrdGhpcy5fbTAyLGk9dGhpcy5fbTEwKnQuX20wMCt0aGlzLl9tMTEqdC5fbTEwLHI9dGhpcy5fbTEwKnQuX20wMSt0aGlzLl9tMTEqdC5fbTExLG89dGhpcy5fbTEwKnQuX20wMit0aGlzLl9tMTEqdC5fbTEyK3RoaXMuX20xMjtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPW4sdGhpcy5fbTAyPXMsdGhpcy5fbTEwPWksdGhpcy5fbTExPXIsdGhpcy5fbTEyPW8sdGhpc31zZXRUb1NoZWFyKHQsZSl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT10LHRoaXMuX20wMj0wLHRoaXMuX20xMD1lLHRoaXMuX20xMT0xLHRoaXMuX20xMj0wLHRoaXN9aXNEb25lKCl7cmV0dXJuITF9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgdDtnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG51bGx9dHJhbnNsYXRlKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShpZS50cmFuc2xhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9c2V0VG9SZWZsZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgcyhcIlJlZmxlY3Rpb24gdmVjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7aWYodD09PWUpcmV0dXJuIHRoaXMuX20wMD0wLHRoaXMuX20wMT0xLHRoaXMuX20wMj0wLHRoaXMuX20xMD0xLHRoaXMuX20xMT0wLHRoaXMuX20xMj0wLHRoaXM7Y29uc3Qgbj1NYXRoLnNxcnQodCp0K2UqZSksaT1lL24scj10L247cmV0dXJuIHRoaXMucm90YXRlKC1pLHIpLHRoaXMuc2NhbGUoMSwtMSksdGhpcy5yb3RhdGUoaSxyKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtpZih0PT09biYmZT09PWkpdGhyb3cgbmV3IHMoXCJSZWZsZWN0aW9uIGxpbmUgcG9pbnRzIG11c3QgYmUgZGlzdGluY3RcIik7dGhpcy5zZXRUb1RyYW5zbGF0aW9uKC10LC1lKTtjb25zdCByPW4tdCxvPWktZSxsPU1hdGguc3FydChyKnIrbypvKSxhPW8vbCxjPXIvbDtyZXR1cm4gdGhpcy5yb3RhdGUoLWEsYyksdGhpcy5zY2FsZSgxLC0xKSx0aGlzLnJvdGF0ZShhLGMpLHRoaXMudHJhbnNsYXRlKHQsZSksdGhpc319dG9TdHJpbmcoKXtyZXR1cm5cIkFmZmluZVRyYW5zZm9ybWF0aW9uW1tcIit0aGlzLl9tMDArXCIsIFwiK3RoaXMuX20wMStcIiwgXCIrdGhpcy5fbTAyK1wiXSwgW1wiK3RoaXMuX20xMCtcIiwgXCIrdGhpcy5fbTExK1wiLCBcIit0aGlzLl9tMTIrXCJdXVwifXNldFRvVHJhbnNsYXRpb24odCxlKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPXQsdGhpcy5fbTEwPTAsdGhpcy5fbTExPTEsdGhpcy5fbTEyPWUsdGhpc31zaGVhcih0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UoaWUuc2hlYXJJbnN0YW5jZSh0LGUpKSx0aGlzfXRyYW5zZm9ybSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXS5jb3B5KCk7cmV0dXJuIHQuYXBwbHkodGhpcyksdH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbTAwKnQueCt0aGlzLl9tMDEqdC55K3RoaXMuX20wMixzPXRoaXMuX20xMCp0LngrdGhpcy5fbTExKnQueSt0aGlzLl9tMTI7cmV0dXJuIGUueD1uLGUueT1zLGV9aWYoSShhcmd1bWVudHNbMF0sRikmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9tMDAqdC5nZXRPcmRpbmF0ZShlLDApK3RoaXMuX20wMSp0LmdldE9yZGluYXRlKGUsMSkrdGhpcy5fbTAyLHM9dGhpcy5fbTEwKnQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLl9tMTEqdC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMuX20xMjt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX19fXJlZmxlY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlKSksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlLG4scykpLHRoaXN9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsLFBdfX1jbGFzcyByZXtzdGF0aWMgc29sdmUodCxlKXtjb25zdCBuPWUubGVuZ3RoO2lmKHQubGVuZ3RoIT09bnx8dFswXS5sZW5ndGghPT1uKXRocm93IG5ldyBzKFwiTWF0cml4IEEgaXMgaW5jb3JyZWN0bHkgc2l6ZWRcIik7Zm9yKGxldCBzPTA7czxuO3MrKyl7bGV0IGk9cztmb3IobGV0IGU9cysxO2U8bjtlKyspTWF0aC5hYnModFtlXVtzXSk+TWF0aC5hYnModFtpXVtzXSkmJihpPWUpO2lmKDA9PT10W2ldW3NdKXJldHVybiBudWxsO3JlLnN3YXBSb3dzKHQscyxpKSxyZS5zd2FwUm93cyhlLHMsaSk7Zm9yKGxldCBpPXMrMTtpPG47aSsrKXtjb25zdCByPXRbaV1bc10vdFtzXVtzXTtmb3IobGV0IGU9bi0xO2U+PXM7ZS0tKXRbaV1bZV0tPXRbc11bZV0qcjtlW2ldLT1lW3NdKnJ9fWNvbnN0IGk9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7Zm9yKGxldCBzPW4tMTtzPj0wO3MtLSl7bGV0IHI9MDtmb3IobGV0IGU9cysxO2U8bjtlKyspcis9dFtzXVtlXSppW2VdO2lbc109KGVbc10tcikvdFtzXVtzXX1yZXR1cm4gaX1zdGF0aWMgc3dhcFJvd3MoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKGxldCBzPTA7czx0WzBdLmxlbmd0aDtzKyspe2NvbnN0IGk9dFtlXVtzXTt0W2VdW3NdPXRbbl1bc10sdFtuXVtzXT1pfX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPT09bilyZXR1cm4gbnVsbDtjb25zdCBzPXRbZV07dFtlXT10W25dLHRbbl09c319fWNsYXNzIG9le2NvbnN0cnVjdG9yKCl7b2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3JjMD1udWxsLHRoaXMuX3NyYzE9bnVsbCx0aGlzLl9zcmMyPW51bGwsdGhpcy5fZGVzdDA9bnVsbCx0aGlzLl9kZXN0MT1udWxsLHRoaXMuX2Rlc3QyPW51bGwsdGhpcy5fbTAwPW51bGwsdGhpcy5fbTAxPW51bGwsdGhpcy5fbTAyPW51bGwsdGhpcy5fbTEwPW51bGwsdGhpcy5fbTExPW51bGwsdGhpcy5fbTEyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07dGhpcy5fc3JjMD10LHRoaXMuX3NyYzE9ZSx0aGlzLl9zcmMyPW4sdGhpcy5fZGVzdDA9cyx0aGlzLl9kZXN0MT1pLHRoaXMuX2Rlc3QyPXJ9c29sdmUodCl7Y29uc3QgZT1bW3RoaXMuX3NyYzAueCx0aGlzLl9zcmMwLnksMV0sW3RoaXMuX3NyYzEueCx0aGlzLl9zcmMxLnksMV0sW3RoaXMuX3NyYzIueCx0aGlzLl9zcmMyLnksMV1dO3JldHVybiByZS5zb2x2ZShlLHQpfWNvbXB1dGUoKXtjb25zdCB0PVt0aGlzLl9kZXN0MC54LHRoaXMuX2Rlc3QxLngsdGhpcy5fZGVzdDIueF0sZT10aGlzLnNvbHZlKHQpO2lmKG51bGw9PT1lKXJldHVybiExO3RoaXMuX20wMD1lWzBdLHRoaXMuX20wMT1lWzFdLHRoaXMuX20wMj1lWzJdO2NvbnN0IG49W3RoaXMuX2Rlc3QwLnksdGhpcy5fZGVzdDEueSx0aGlzLl9kZXN0Mi55XSxzPXRoaXMuc29sdmUobik7cmV0dXJuIG51bGwhPT1zJiYodGhpcy5fbTEwPXNbMF0sdGhpcy5fbTExPXNbMV0sdGhpcy5fbTEyPXNbMl0sITApfWdldFRyYW5zZm9ybWF0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpP25ldyBpZSh0aGlzLl9tMDAsdGhpcy5fbTAxLHRoaXMuX20wMix0aGlzLl9tMTAsdGhpcy5fbTExLHRoaXMuX20xMik6bnVsbH19Y2xhc3MgbGV7c3RhdGljIGNyZWF0ZUZyb21CYXNlTGluZXModCxlLG4scyl7Y29uc3QgaT1uZXcgbSh0Lngrcy54LW4ueCx0Lnkrcy55LW4ueSkscj0kdC5hbmdsZUJldHdlZW5PcmllbnRlZChlLHQsaSksbz1lLmRpc3RhbmNlKHQpLGw9cy5kaXN0YW5jZShuKTtpZigwPT09bylyZXR1cm4gbmV3IGllO2NvbnN0IGE9bC9vLGM9aWUudHJhbnNsYXRpb25JbnN0YW5jZSgtdC54LC10LnkpO3JldHVybiBjLnJvdGF0ZShyKSxjLnNjYWxlKGEsYSksYy50cmFuc2xhdGUobi54LG4ueSksY31zdGF0aWMgY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10Lngscz1lLnktdC55O3JldHVybiBpZS50cmFuc2xhdGlvbkluc3RhbmNlKG4scyl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgcyhcIlNyYyBhbmQgRGVzdCBhcnJheXMgYXJlIG5vdCB0aGUgc2FtZSBsZW5ndGhcIik7aWYodC5sZW5ndGg8PTApdGhyb3cgbmV3IHMoXCJUb28gZmV3IGNvbnRyb2wgcG9pbnRzXCIpO2lmKHQubGVuZ3RoPjMpdGhyb3cgbmV3IHMoXCJUb28gbWFueSBjb250cm9sIHBvaW50c1wiKTtyZXR1cm4gMT09PXQubGVuZ3RoP2xlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLGVbMF0pOjI9PT10Lmxlbmd0aD9sZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSx0WzFdLGVbMF0sZVsxXSk6bGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sdFsxXSx0WzJdLGVbMF0sZVsxXSxlWzJdKX19ZWxzZXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgbShzLngtbi54LHMueS1uLnkpLHI9JHQuYW5nbGVCZXR3ZWVuT3JpZW50ZWQoZSx0LGkpLG89ZS5kaXN0YW5jZSh0KSxsPXMuZGlzdGFuY2Uobik7aWYoMD09PW8pcmV0dXJuIG51bGw7Y29uc3QgYT1sL28sYz1pZS50cmFuc2xhdGlvbkluc3RhbmNlKC10LngsLXQueSk7cmV0dXJuIGMucm90YXRlKHIpLGMuc2NhbGUoYSxhKSxjLnRyYW5zbGF0ZShuLngsbi55KSxjfWlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IG9lKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdKS5nZXRUcmFuc2Zvcm1hdGlvbigpfX19fWNsYXNzIGFle2NvbnN0cnVjdG9yKCl7YWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29vcmRzPXR9c3RhdGljIGdldENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEw7cmV0dXJuIHQuYXBwbHkobmV3IGFlKGUpKSxlfWZpbHRlcih0KXsodCBpbnN0YW5jZW9mIEp8fHQgaW5zdGFuY2VvZiB0dCkmJnRoaXMuX2Nvb3Jkcy5hZGQodC5nZXRDb29yZGluYXRlKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX19Y2xhc3MgY2V7Y29uc3RydWN0b3IoKXtjZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9tYXBPcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX21hcE9wPXR9c3RhdGljIG1hcCh0LGUpe3JldHVybiBuZXcgY2UoZSkubWFwKHQpfW1hcCh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXRoaXMuX21hcE9wLm1hcCh0LmdldEdlb21ldHJ5TihuKSk7cy5pc0VtcHR5KCl8fGUuYWRkKHMpfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oQ3QudG9HZW9tZXRyeUFycmF5KGUpKX19Y2xhc3MgaGV7Y29uc3RydWN0b3IoKXtoZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX3NraXBFbXB0eT0hMSx0aGlzLl9pbnB1dEdlb21zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Rvcnk9aGUuZXh0cmFjdEZhY3RvcnkodCksdGhpcy5faW5wdXRHZW9tcz10fXN0YXRpYyBjb21iaW5lKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgaGUoYXJndW1lbnRzWzBdKS5jb21iaW5lKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgaGUoaGUuY3JlYXRlTGlzdCh0LGUpKS5jb21iaW5lKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuZXcgaGUoaGUuY3JlYXRlTGlzdCh0LGUsbikpLmNvbWJpbmUoKX19c3RhdGljIGV4dHJhY3RGYWN0b3J5KHQpe3JldHVybiB0LmlzRW1wdHkoKT9udWxsOnQuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpfXN0YXRpYyBjcmVhdGVMaXN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7cmV0dXJuIG4uYWRkKHQpLG4uYWRkKGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IEw7cmV0dXJuIHMuYWRkKHQpLHMuYWRkKGUpLHMuYWRkKG4pLHN9fWV4dHJhY3RFbGVtZW50cyh0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO3RoaXMuX3NraXBFbXB0eSYmcy5pc0VtcHR5KCl8fGUuYWRkKHMpfX1jb21iaW5lKCl7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9dGhpcy5faW5wdXRHZW9tcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3RFbGVtZW50cyhuLHQpfXJldHVybiAwPT09dC5zaXplKCk/bnVsbCE9PXRoaXMuX2dlb21GYWN0b3J5P3RoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpOm51bGw6dGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX19Y2xhc3MgdWV7Y29uc3RydWN0b3IoKXt1ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5faXNVc2VyRGF0YUNvcGllZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fX1zZXRDb3B5VXNlckRhdGEodCl7dGhpcy5faXNVc2VyRGF0YUNvcGllZD10fWVkaXQodCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuZWRpdEludGVybmFsKHQsZSk7cmV0dXJuIHRoaXMuX2lzVXNlckRhdGFDb3BpZWQmJm4uc2V0VXNlckRhdGEodC5nZXRVc2VyRGF0YSgpKSxufWVkaXRJbnRlcm5hbCh0LGUpe3JldHVybiBudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHQgaW5zdGFuY2VvZiBjdD90aGlzLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKTp0IGluc3RhbmNlb2YgaXQ/dGhpcy5lZGl0UG9seWdvbih0LGUpOnQgaW5zdGFuY2VvZiB0dHx8dCBpbnN0YW5jZW9mIEo/ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSk6KGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbnN1cHBvcnRlZCBHZW9tZXRyeSB0eXBlOiBcIit0LmdldEdlb21ldHJ5VHlwZSgpKSxudWxsKX1lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj1lLmVkaXQodCx0aGlzLl9mYWN0b3J5KSxzPW5ldyBMO2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBpPXRoaXMuZWRpdChuLmdldEdlb21ldHJ5Tih0KSxlKTtudWxsPT09aXx8aS5pc0VtcHR5KCl8fHMuYWRkKGkpfXJldHVybiBuLmdldEdlb21ldHJ5VHlwZSgpPT09WC5UWVBFTkFNRV9NVUxUSVBPSU5UP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChzLnRvQXJyYXkoW10pKTpuLmdldEdlb21ldHJ5VHlwZSgpPT09WC5UWVBFTkFNRV9NVUxUSUxJTkVTVFJJTkc/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocy50b0FycmF5KFtdKSk6bi5nZXRHZW9tZXRyeVR5cGUoKT09PVguVFlQRU5BTUVfTVVMVElQT0xZR09OP3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKHMudG9BcnJheShbXSkpOnRoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKHMudG9BcnJheShbXSkpfWVkaXRQb2x5Z29uKHQsZSl7bGV0IG49ZS5lZGl0KHQsdGhpcy5fZmFjdG9yeSk7aWYobnVsbD09PW4mJihuPXRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbigpKSxuLmlzRW1wdHkoKSlyZXR1cm4gbjtjb25zdCBzPXRoaXMuZWRpdChuLmdldEV4dGVyaW9yUmluZygpLGUpO2lmKG51bGw9PT1zfHxzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7Y29uc3QgaT1uZXcgTDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXtjb25zdCBzPXRoaXMuZWRpdChuLmdldEludGVyaW9yUmluZ04odCksZSk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHxpLmFkZChzKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHMsaS50b0FycmF5KFtdKSl9fWZ1bmN0aW9uIGdlKCl7fXVlLkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uPWdlO3VlLk5vT3BHZW9tZXRyeU9wZXJhdGlvbj1jbGFzc3tlZGl0KHQsZSl7cmV0dXJuIHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2dlXX19LHVlLkNvb3JkaW5hdGVPcGVyYXRpb249Y2xhc3N7ZWRpdCh0LGUpe2NvbnN0IG49dGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KTtyZXR1cm4gdCBpbnN0YW5jZW9mIHV0P251bGw9PT1uP2UuY3JlYXRlTGluZWFyUmluZygpOmUuY3JlYXRlTGluZWFyUmluZyhuKTp0IGluc3RhbmNlb2YgSj9udWxsPT09bj9lLmNyZWF0ZUxpbmVTdHJpbmcoKTplLmNyZWF0ZUxpbmVTdHJpbmcobik6dCBpbnN0YW5jZW9mIHR0P251bGw9PT1ufHwwPT09bi5sZW5ndGg/ZS5jcmVhdGVQb2ludCgpOmUuY3JlYXRlUG9pbnQoblswXSk6dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ2VdfX0sdWUuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uPWNsYXNze2VkaXQodCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIHV0P2UuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIEo/ZS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgdHQ/ZS5jcmVhdGVQb2ludCh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ2VdfX07Y2xhc3MgZGV7Y29uc3RydWN0b3IoKXtkZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tZXRyeVR5cGU9bnVsbCx0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21ldHJ5VHlwZT10LHRoaXMuX2NvbXBzPWV9c3RhdGljIGlzT2ZUeXBlKHQsZSl7cmV0dXJuIHQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1lfHxlPT09WC5UWVBFTkFNRV9MSU5FU1RSSU5HJiZ0LmdldEdlb21ldHJ5VHlwZSgpPT09WC5UWVBFTkFNRV9MSU5FQVJSSU5HfXN0YXRpYyBleHRyYWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBkZS5leHRyYWN0KHQsZSxuZXcgTCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0LmdldEdlb21ldHJ5VHlwZSgpPT09ZT9uLmFkZCh0KTp0IGluc3RhbmNlb2YgY3QmJnQuYXBwbHkobmV3IGRlKGUsbikpLG59fWZpbHRlcih0KXsobnVsbD09PXRoaXMuX2dlb21ldHJ5VHlwZXx8ZGUuaXNPZlR5cGUodCx0aGlzLl9nZW9tZXRyeVR5cGUpKSYmdGhpcy5fY29tcHMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltRXX19Y2xhc3MgX2V7c3RhdGljIG1hcCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCYmSShhcmd1bWVudHNbMV0scGUpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1HZW9tZXRyaWVzKCk7cysrKXtjb25zdCBpPWUubWFwKHQuZ2V0R2VvbWV0cnlOKHMpKTtudWxsIT09aSYmbi5hZGQoaSl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkobil9aWYoSShhcmd1bWVudHNbMF0sTikmJkkoYXJndW1lbnRzWzFdLHBlKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPWUubWFwKHQpO251bGwhPT1pJiZuLmFkZChpKX1yZXR1cm4gbn19fWZ1bmN0aW9uIHBlKCl7fV9lLk1hcE9wPXBlO2NsYXNzIG1le2NvbnN0cnVjdG9yKCl7bWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX3BydW5lRW1wdHlHZW9tZXRyeT0hMCx0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU9ITAsdGhpcy5fcHJlc2VydmVDb2xsZWN0aW9ucz0hMSx0aGlzLl9wcmVzZXJ2ZVR5cGU9ITF9dHJhbnNmb3JtUG9pbnQodCxlKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfXRyYW5zZm9ybVBvbHlnb24odCxlKXtsZXQgbj0hMDtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEV4dGVyaW9yUmluZygpLHQpO251bGwhPT1zJiZzIGluc3RhbmNlb2YgdXQmJiFzLmlzRW1wdHkoKXx8KG49ITEpO2NvbnN0IGk9bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpLHQpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8KHMgaW5zdGFuY2VvZiB1dHx8KG49ITEpLGkuYWRkKHMpKX1pZihuKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24ocyxpLnRvQXJyYXkoW10pKTt7Y29uc3QgdD1uZXcgTDtyZXR1cm4gbnVsbCE9PXMmJnQuYWRkKHMpLHQuYWRkQWxsKGkpLHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX19Y3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlKHQpe3JldHVybiB0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCl9Z2V0SW5wdXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb219dHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtyZXR1cm4gdGhpcy5jb3B5KHQpfXRyYW5zZm9ybUxpbmVTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9dHJhbnNmb3JtTXVsdGlQb2ludCh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1Qb2ludCh0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtUG9seWdvbih0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX1jb3B5KHQpe3JldHVybiB0LmNvcHkoKX10cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtKHQuZ2V0R2VvbWV0cnlOKGUpKTtudWxsIT09cyYmKHRoaXMuX3BydW5lRW1wdHlHZW9tZXRyeSYmcy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlP3RoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEN0LnRvR2VvbWV0cnlBcnJheShuKSk6dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybSh0KXtpZih0aGlzLl9pbnB1dEdlb209dCx0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHQgaW5zdGFuY2VvZiB0dClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBodClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIHV0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgSilyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIHd0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBpdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGZ0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBjdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxudWxsKTt0aHJvdyBuZXcgcyhcIlVua25vd24gR2VvbWV0cnkgc3VidHlwZTogXCIrdC5nZXRHZW9tZXRyeVR5cGUoKSl9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49dGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobnVsbCk7Y29uc3Qgcz1uLnNpemUoKTtyZXR1cm4gcz4wJiZzPDQmJiF0aGlzLl9wcmVzZXJ2ZVR5cGU/dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4pOnRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuKX19Y2xhc3MgZmV7Y29uc3RydWN0b3IoKXtmZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb21wcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBzPXR9c3RhdGljIGdldEdlb21ldHJ5KHQpe3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGZlLmdldExpbmVzKHQpKX1zdGF0aWMgZ2V0TGluZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGZlLmdldExpbmVzKHQsbmV3IEwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIEo/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIGN0JiZ0LmFwcGx5KG5ldyBmZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBKJiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1FdfX1jbGFzcyB5ZXtjb25zdHJ1Y3Rvcigpe3llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xpbmVzPW51bGwsdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmc9ITEsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVzPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbGluZXM9dCx0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz1lfX1zdGF0aWMgZ2V0R2VvbWV0cnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoeWUuZ2V0TGluZXModCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh5ZS5nZXRMaW5lcyh0LGUpKX19c3RhdGljIGdldExpbmVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB5ZS5nZXRMaW5lcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sTikmJkkoYXJndW1lbnRzWzFdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtmb3IobGV0IGU9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3llLmdldExpbmVzKG4sdCl9cmV0dXJuIHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtyZXR1cm4gdC5hcHBseShuZXcgeWUobixlKSksbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgmJkkoYXJndW1lbnRzWzFdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIEo/ZS5hZGQodCk6dC5hcHBseShuZXcgeWUoZSkpLGV9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZJKGFyZ3VtZW50c1swXSxOKSYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO2ZvcihsZXQgbj1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7eWUuZ2V0TGluZXMocyx0LGUpfXJldHVybiB0fWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgmJkkoYXJndW1lbnRzWzFdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXTtyZXR1cm4gYXJndW1lbnRzWzBdLmFwcGx5KG5ldyB5ZSh0LGUpKSx0fX19ZmlsdGVyKHQpe2lmKHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nJiZ0IGluc3RhbmNlb2YgdXQpe2NvbnN0IGU9dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtyZXR1cm4gdGhpcy5fbGluZXMuYWRkKGUpLG51bGx9dCBpbnN0YW5jZW9mIEomJnRoaXMuX2xpbmVzLmFkZCh0KX1zZXRGb3JjZVRvTGluZVN0cmluZyh0KXt0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX19Y29uc3QgeGU9e3JldmVyc2VPcmRlcjpmdW5jdGlvbigpe3JldHVybntjb21wYXJlOih0LGUpPT5lLmNvbXBhcmVUbyh0KX19LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4geGUuc29ydCh0KSx0LmdldCgwKX0sc29ydDpmdW5jdGlvbih0LGUpe2NvbnN0IG49dC50b0FycmF5KCk7ZT9udC5zb3J0KG4sZSk6bnQuc29ydChuKTtjb25zdCBzPXQuaXRlcmF0b3IoKTtmb3IobGV0IHQ9MCxlPW4ubGVuZ3RoO3Q8ZTt0Kyspcy5uZXh0KCkscy5zZXQoblt0XSl9LHNpbmdsZXRvbkxpc3Q6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgTDtyZXR1cm4gZS5hZGQodCksZX19O2NsYXNzIEVle2NvbnN0cnVjdG9yKCl7RWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXR9c3RhdGljIGdldFBvaW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdCBpbnN0YW5jZW9mIHR0P3hlLnNpbmdsZXRvbkxpc3QodCk6RWUuZ2V0UG9pbnRzKHQsbmV3IEwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIHR0P2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBjdCYmdC5hcHBseShuZXcgRWUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgdHQmJnRoaXMuX3B0cy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1FdfX1jbGFzcyBJZXtjb25zdHJ1Y3Rvcigpe0llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcHM9dH1zdGF0aWMgZ2V0UG9seWdvbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEllLmdldFBvbHlnb25zKHQsbmV3IEwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdCBpbnN0YW5jZW9mIGl0P2UuYWRkKHQpOnQgaW5zdGFuY2VvZiBjdCYmdC5hcHBseShuZXcgSWUoZSkpLGV9fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgaXQmJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUV19fWNsYXNzIE5le2NvbnN0cnVjdG9yKCl7TmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNEb25lPSExfWFwcGx5VG8odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKSYmIXRoaXMuX2lzRG9uZTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYobiBpbnN0YW5jZW9mIGN0KXRoaXMuYXBwbHlUbyhuKTtlbHNlIGlmKHRoaXMudmlzaXQobiksdGhpcy5pc0RvbmUoKSlyZXR1cm4gdGhpcy5faXNEb25lPSEwLG51bGx9fX1jbGFzcyBTZXtjb25zdHJ1Y3Rvcigpe1NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fcHJlY01vZGVsPW51bGwsdGhpcy5fZGltPW5ldyB3ZSx0aGlzLl9uUHRzPTEwMCx0aGlzLl9yb3RhdGlvbkFuZ2xlPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpU2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgQ3QpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0PXQsdGhpcy5fcHJlY01vZGVsPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKX19Y3JlYXRlU3VwZXJjaXJjbGUodCl7Y29uc3QgZT0xL3Qsbj10aGlzLl9kaW0uZ2V0TWluU2l6ZSgpLzIscz10aGlzLl9kaW0uZ2V0Q2VudHJlKCksaT1NYXRoLnBvdyhuLHQpLHI9bixvPU1hdGgucG93KGkvMixlKSxsPU1hdGgudHJ1bmModGhpcy5fblB0cy84KSxhPW5ldyBBcnJheSg4KmwrMSkuZmlsbChudWxsKSxjPW8vbDtmb3IobGV0IG49MDtuPD1sO24rKyl7bGV0IG89MCxoPXI7aWYoMCE9PW4pe289YypuO2NvbnN0IHM9TWF0aC5wb3cobyx0KTtoPU1hdGgucG93KGktcyxlKX1hW25dPXRoaXMuY29vcmRUcmFucyhvLGgscyksYVsyKmwtbl09dGhpcy5jb29yZFRyYW5zKGgsbyxzKSxhWzIqbCtuXT10aGlzLmNvb3JkVHJhbnMoaCwtbyxzKSxhWzQqbC1uXT10aGlzLmNvb3JkVHJhbnMobywtaCxzKSxhWzQqbCtuXT10aGlzLmNvb3JkVHJhbnMoLW8sLWgscyksYVs2Kmwtbl09dGhpcy5jb29yZFRyYW5zKC1oLC1vLHMpLGFbNipsK25dPXRoaXMuY29vcmRUcmFucygtaCxvLHMpLGFbOCpsLW5dPXRoaXMuY29vcmRUcmFucygtbyxoLHMpfWFbYS5sZW5ndGgtMV09bmV3IG0oYVswXSk7Y29uc3QgaD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGEpLHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihoKTtyZXR1cm4gdGhpcy5yb3RhdGUodSl9c2V0TnVtUG9pbnRzKHQpe3RoaXMuX25QdHM9dH1zZXRCYXNlKHQpe3RoaXMuX2RpbS5zZXRCYXNlKHQpfXNldFJvdGF0aW9uKHQpe3RoaXMuX3JvdGF0aW9uQW5nbGU9dH1zZXRXaWR0aCh0KXt0aGlzLl9kaW0uc2V0V2lkdGgodCl9Y3JlYXRlRWxsaXBzZSgpe2NvbnN0IHQ9dGhpcy5fZGltLmdldEVudmVsb3BlKCksZT10LmdldFdpZHRoKCkvMixuPXQuZ2V0SGVpZ2h0KCkvMixzPXQuZ2V0TWluWCgpK2UsaT10LmdldE1pblkoKStuLHI9bmV3IEFycmF5KHRoaXMuX25QdHMrMSkuZmlsbChudWxsKTtsZXQgbz0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fblB0czt0Kyspe2NvbnN0IGw9dCooMipNYXRoLlBJL3RoaXMuX25QdHMpLGE9ZSpNYXRoLmNvcyhsKStzLGM9bipNYXRoLnNpbihsKStpO3JbbysrXT10aGlzLmNvb3JkKGEsYyl9cltvXT1uZXcgbShyWzBdKTtjb25zdCBsPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcociksYT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGwpO3JldHVybiB0aGlzLnJvdGF0ZShhKX1jb29yZFRyYW5zKHQsZSxuKXtyZXR1cm4gdGhpcy5jb29yZCh0K24ueCxlK24ueSl9Y3JlYXRlU3F1aXJjbGUoKXtyZXR1cm4gdGhpcy5jcmVhdGVTdXBlcmNpcmNsZSg0KX1zZXRFbnZlbG9wZSh0KXt0aGlzLl9kaW0uc2V0RW52ZWxvcGUodCl9c2V0Q2VudHJlKHQpe3RoaXMuX2RpbS5zZXRDZW50cmUodCl9Y3JlYXRlQXJjKHQsZSl7Y29uc3Qgbj10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxzPW4uZ2V0V2lkdGgoKS8yLGk9bi5nZXRIZWlnaHQoKS8yLHI9bi5nZXRNaW5YKCkrcyxvPW4uZ2V0TWluWSgpK2k7bGV0IGw9ZTsobDw9MHx8bD4yKk1hdGguUEkpJiYobD0yKk1hdGguUEkpO2NvbnN0IGE9bC8odGhpcy5fblB0cy0xKSxjPW5ldyBBcnJheSh0aGlzLl9uUHRzKS5maWxsKG51bGwpO2xldCBoPTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9uUHRzO2UrKyl7Y29uc3Qgbj10K2UqYSxsPXMqTWF0aC5jb3Mobikrcix1PWkqTWF0aC5zaW4obikrbztjW2grK109dGhpcy5jb29yZChsLHUpfWNvbnN0IHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZVN0cmluZyhjKTtyZXR1cm4gdGhpcy5yb3RhdGUodSl9cm90YXRlKHQpe2lmKDAhPT10aGlzLl9yb3RhdGlvbkFuZ2xlKXtjb25zdCBlPWllLnJvdGF0aW9uSW5zdGFuY2UodGhpcy5fcm90YXRpb25BbmdsZSx0aGlzLl9kaW0uZ2V0Q2VudHJlKCkueCx0aGlzLl9kaW0uZ2V0Q2VudHJlKCkueSk7dC5hcHBseShlKX1yZXR1cm4gdH1jb29yZCh0LGUpe2NvbnN0IG49bmV3IG0odCxlKTtyZXR1cm4gdGhpcy5fcHJlY01vZGVsLm1ha2VQcmVjaXNlKG4pLG59Y3JlYXRlQXJjUG9seWdvbih0LGUpe2NvbnN0IG49dGhpcy5fZGltLmdldEVudmVsb3BlKCkscz1uLmdldFdpZHRoKCkvMixpPW4uZ2V0SGVpZ2h0KCkvMixyPW4uZ2V0TWluWCgpK3Msbz1uLmdldE1pblkoKStpO2xldCBsPWU7KGw8PTB8fGw+MipNYXRoLlBJKSYmKGw9MipNYXRoLlBJKTtjb25zdCBhPWwvKHRoaXMuX25QdHMtMSksYz1uZXcgQXJyYXkodGhpcy5fblB0cysyKS5maWxsKG51bGwpO2xldCBoPTA7Y1toKytdPXRoaXMuY29vcmQocixvKTtmb3IobGV0IGU9MDtlPHRoaXMuX25QdHM7ZSsrKXtjb25zdCBuPXQrYSplLGw9cypNYXRoLmNvcyhuKStyLHU9aSpNYXRoLnNpbihuKStvO2NbaCsrXT10aGlzLmNvb3JkKGwsdSl9Y1toKytdPXRoaXMuY29vcmQocixvKTtjb25zdCB1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcoYyksZz10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKHUpO3JldHVybiB0aGlzLnJvdGF0ZShnKX1jcmVhdGVSZWN0YW5nbGUoKXtsZXQgdD1udWxsLGU9MCxuPU1hdGgudHJ1bmModGhpcy5fblB0cy80KTtuPDEmJihuPTEpO2NvbnN0IHM9dGhpcy5fZGltLmdldEVudmVsb3BlKCkuZ2V0V2lkdGgoKS9uLGk9dGhpcy5fZGltLmdldEVudmVsb3BlKCkuZ2V0SGVpZ2h0KCkvbixyPW5ldyBBcnJheSg0Km4rMSkuZmlsbChudWxsKSxvPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpO2Zvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1pblgoKSt0KnMsaT1vLmdldE1pblkoKTtyW2UrK109dGhpcy5jb29yZChuLGkpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1heFgoKSxzPW8uZ2V0TWluWSgpK3QqaTtyW2UrK109dGhpcy5jb29yZChuLHMpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1heFgoKS10KnMsaT1vLmdldE1heFkoKTtyW2UrK109dGhpcy5jb29yZChuLGkpfWZvcih0PTA7dDxuO3QrKyl7Y29uc3Qgbj1vLmdldE1pblgoKSxzPW8uZ2V0TWF4WSgpLXQqaTtyW2UrK109dGhpcy5jb29yZChuLHMpfXJbZSsrXT1uZXcgbShyWzBdKTtjb25zdCBsPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcociksYT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGwpO3JldHVybiB0aGlzLnJvdGF0ZShhKX1jcmVhdGVDaXJjbGUoKXtyZXR1cm4gdGhpcy5jcmVhdGVFbGxpcHNlKCl9c2V0SGVpZ2h0KHQpe3RoaXMuX2RpbS5zZXRIZWlnaHQodCl9c2V0U2l6ZSh0KXt0aGlzLl9kaW0uc2V0U2l6ZSh0KX19Y2xhc3Mgd2V7Y29uc3RydWN0b3IoKXt3ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmJhc2U9bnVsbCx0aGlzLmNlbnRyZT1udWxsLHRoaXMud2lkdGg9bnVsbCx0aGlzLmhlaWdodD1udWxsfXNldEJhc2UodCl7dGhpcy5iYXNlPXR9c2V0V2lkdGgodCl7dGhpcy53aWR0aD10fWdldEJhc2UoKXtyZXR1cm4gdGhpcy5iYXNlfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMud2lkdGh9c2V0RW52ZWxvcGUodCl7dGhpcy53aWR0aD10LmdldFdpZHRoKCksdGhpcy5oZWlnaHQ9dC5nZXRIZWlnaHQoKSx0aGlzLmJhc2U9bmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuY2VudHJlPW5ldyBtKHQuY2VudHJlKCkpfXNldENlbnRyZSh0KXt0aGlzLmNlbnRyZT10fWdldE1pblNpemUoKXtyZXR1cm4gTWF0aC5taW4odGhpcy53aWR0aCx0aGlzLmhlaWdodCl9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuYmFzZT9uZXcgTyh0aGlzLmJhc2UueCx0aGlzLmJhc2UueCt0aGlzLndpZHRoLHRoaXMuYmFzZS55LHRoaXMuYmFzZS55K3RoaXMuaGVpZ2h0KTpudWxsIT09dGhpcy5jZW50cmU/bmV3IE8odGhpcy5jZW50cmUueC10aGlzLndpZHRoLzIsdGhpcy5jZW50cmUueCt0aGlzLndpZHRoLzIsdGhpcy5jZW50cmUueS10aGlzLmhlaWdodC8yLHRoaXMuY2VudHJlLnkrdGhpcy5oZWlnaHQvMik6bmV3IE8oMCx0aGlzLndpZHRoLDAsdGhpcy5oZWlnaHQpfWdldENlbnRyZSgpe3JldHVybiBudWxsPT09dGhpcy5jZW50cmUmJih0aGlzLmNlbnRyZT1uZXcgbSh0aGlzLmJhc2UueCt0aGlzLndpZHRoLzIsdGhpcy5iYXNlLnkrdGhpcy5oZWlnaHQvMikpLHRoaXMuY2VudHJlfWdldEhlaWdodCgpe3JldHVybiB0aGlzLmhlaWdodH1zZXRIZWlnaHQodCl7dGhpcy5oZWlnaHQ9dH1zZXRTaXplKHQpe3RoaXMuaGVpZ2h0PXQsdGhpcy53aWR0aD10fX1TZS5EaW1lbnNpb25zPXdlO2NsYXNzIENlIGV4dGVuZHMgU2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLENlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX251bUFybXM9OCx0aGlzLl9hcm1MZW5ndGhSYXRpbz0uNSwwPT09YXJndW1lbnRzLmxlbmd0aClTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX1zdGF0aWMgY3JlYXRlKHQsZSxuLHMsaSl7Y29uc3Qgcj1uZXcgQ2U7ci5zZXRDZW50cmUodCksci5zZXRTaXplKGUpLHIuc2V0TnVtUG9pbnRzKG4pLHIuc2V0QXJtTGVuZ3RoUmF0aW8oaSksci5zZXROdW1Bcm1zKHMpO3JldHVybiByLmNyZWF0ZVNpbmVTdGFyKCl9c2V0TnVtQXJtcyh0KXt0aGlzLl9udW1Bcm1zPXR9c2V0QXJtTGVuZ3RoUmF0aW8odCl7dGhpcy5fYXJtTGVuZ3RoUmF0aW89dH1jcmVhdGVTaW5lU3Rhcigpe2NvbnN0IHQ9dGhpcy5fZGltLmdldEVudmVsb3BlKCksZT10LmdldFdpZHRoKCkvMjtsZXQgbj10aGlzLl9hcm1MZW5ndGhSYXRpbztuPDAmJihuPTApLG4+MSYmKG49MSk7Y29uc3Qgcz1uKmUsaT0oMS1uKSplLHI9dC5nZXRNaW5YKCkrZSxvPXQuZ2V0TWluWSgpK2UsbD1uZXcgQXJyYXkodGhpcy5fblB0cysxKS5maWxsKG51bGwpO2xldCBhPTA7Zm9yKGxldCB0PTA7dDx0aGlzLl9uUHRzO3QrKyl7Y29uc3QgZT10L3RoaXMuX25QdHMqdGhpcy5fbnVtQXJtcyxuPWUtTWF0aC5mbG9vcihlKSxjPTIqTWF0aC5QSSpuLGg9aStzKigoTWF0aC5jb3MoYykrMSkvMiksdT10KigyKk1hdGguUEkvdGhpcy5fblB0cyksZz1oKk1hdGguY29zKHUpK3IsZD1oKk1hdGguc2luKHUpK287bFthKytdPXRoaXMuY29vcmQoZyxkKX1sW2FdPW5ldyBtKGxbMF0pO2NvbnN0IGM9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhsKTtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihjKX19dmFyIExlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFmZmluZVRyYW5zZm9ybWF0aW9uOmllLEFmZmluZVRyYW5zZm9ybWF0aW9uQnVpbGRlcjpvZSxBZmZpbmVUcmFuc2Zvcm1hdGlvbkZhY3Rvcnk6bGUsQ29tcG9uZW50Q29vcmRpbmF0ZUV4dHJhY3RlcjphZSxHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXI6Y2UsR2VvbWV0cnlDb21iaW5lcjpoZSxHZW9tZXRyeUVkaXRvcjp1ZSxHZW9tZXRyeUV4dHJhY3RlcjpkZSxHZW9tZXRyeU1hcHBlcjpfZSxHZW9tZXRyeVRyYW5zZm9ybWVyOm1lLExpbmVTdHJpbmdFeHRyYWN0ZXI6ZmUsTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyOnllLFBvaW50RXh0cmFjdGVyOkVlLFBvbHlnb25FeHRyYWN0ZXI6SWUsU2hvcnRDaXJjdWl0ZWRHZW9tZXRyeVZpc2l0b3I6TmUsU2luZVN0YXJGYWN0b3J5OkNlfSksVGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29vcmRpbmF0ZTptLENvb3JkaW5hdGVYWTp5LENvb3JkaW5hdGVYWU06eCxDb29yZGluYXRlWFlaTTpFLENvb3JkaW5hdGVMaXN0OlIsQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyOlAsRW52ZWxvcGU6TyxMaW5lU2VnbWVudDpLdCxHZW9tZXRyeUZhY3Rvcnk6Q3QsR2VvbWV0cnk6WCxQb2ludDp0dCxMaW5lU3RyaW5nOkosTGluZWFyUmluZzp1dCxQb2x5Z29uOml0LEdlb21ldHJ5Q29sbGVjdGlvbjpjdCxNdWx0aVBvaW50Omh0LE11bHRpTGluZVN0cmluZzp3dCxNdWx0aVBvbHlnb246ZnQsRGltZW5zaW9uOkssSW50ZXJzZWN0aW9uTWF0cml4Okp0LFByZWNpc2lvbk1vZGVsOk50LExvY2F0aW9uOlF0LFRyaWFuZ2xlOm5lLHV0aWw6TGV9KTtjbGFzcyBSZXtjb25zdHJ1Y3Rvcigpe1JlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0PVtuZXcgbSxuZXcgbV0sdGhpcy5fZGlzdGFuY2U9ci5OYU4sdGhpcy5faXNOdWxsPSEwfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0fWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0W3RdfXNldE1pbmltdW0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRNaW5pbXVtKHQuX3B0WzBdLHQuX3B0WzFdKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLl9pc051bGwpcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZSh0LGUpLG51bGw7Y29uc3Qgbj10LmRpc3RhbmNlKGUpO248dGhpcy5fZGlzdGFuY2UmJnRoaXMuaW5pdGlhbGl6ZSh0LGUsbil9fWluaXRpYWxpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9pc051bGw9ITA7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZSh0KSx0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKGUpLHRoaXMuX2Rpc3RhbmNlPXQuZGlzdGFuY2UoZSksdGhpcy5faXNOdWxsPSExfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUodCksdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShlKSx0aGlzLl9kaXN0YW5jZT1uLHRoaXMuX2lzTnVsbD0hMX19dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKHRoaXMuX3B0WzBdLHRoaXMuX3B0WzFdKX1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9kaXN0YW5jZX1zZXRNYXhpbXVtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TWF4aW11bSh0Ll9wdFswXSx0Ll9wdFsxXSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNOdWxsKXJldHVybiB0aGlzLmluaXRpYWxpemUodCxlKSxudWxsO2NvbnN0IG49dC5kaXN0YW5jZShlKTtuPnRoaXMuX2Rpc3RhbmNlJiZ0aGlzLmluaXRpYWxpemUodCxlLG4pfX19Y2xhc3MgUGV7c3RhdGljIGNvbXB1dGVEaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgSiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBLdCxpPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoLTE7dCsrKXtzLnNldENvb3JkaW5hdGVzKGlbdF0saVt0KzFdKTtjb25zdCByPXMuY2xvc2VzdFBvaW50KGUpO24uc2V0TWluaW11bShyLGUpfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgaXQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07UGUuY29tcHV0ZURpc3RhbmNlKHQuZ2V0RXh0ZXJpb3JSaW5nKCksZSxuKTtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKVBlLmNvbXB1dGVEaXN0YW5jZSh0LmdldEludGVyaW9yUmluZ04ocyksZSxuKX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0IGluc3RhbmNlb2YgSilQZS5jb21wdXRlRGlzdGFuY2UodCxlLG4pO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGl0KVBlLmNvbXB1dGVEaXN0YW5jZSh0LGUsbik7ZWxzZSBpZih0IGluc3RhbmNlb2YgY3Qpe2NvbnN0IHM9dDtmb3IobGV0IHQ9MDt0PHMuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3QgaT1zLmdldEdlb21ldHJ5Tih0KTtQZS5jb21wdXRlRGlzdGFuY2UoaSxlLG4pfX1lbHNlIG4uc2V0TWluaW11bSh0LmdldENvb3JkaW5hdGUoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUmUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbMF0uY2xvc2VzdFBvaW50KHQpO2Uuc2V0TWluaW11bShuLHQpfX19Y2xhc3MgT2V7Y29uc3RydWN0b3IoKXtPZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nMD1udWxsLHRoaXMuX2cxPW51bGwsdGhpcy5fcHREaXN0PW5ldyBSZSx0aGlzLl9kZW5zaWZ5RnJhYz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2cwPXQsdGhpcy5fZzE9ZX1zdGF0aWMgZGlzdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBPZShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5kaXN0YW5jZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1syXSxlPW5ldyBPZShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKTtyZXR1cm4gZS5zZXREZW5zaWZ5RnJhY3Rpb24odCksZS5kaXN0YW5jZSgpfX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdERpc3QuZ2V0Q29vcmRpbmF0ZXMoKX1zZXREZW5zaWZ5RnJhY3Rpb24odCl7aWYodD4xfHx0PD0wKXRocm93IG5ldyBzKFwiRnJhY3Rpb24gaXMgbm90IGluIHJhbmdlICgwLjAgLSAxLjBdXCIpO3RoaXMuX2RlbnNpZnlGcmFjPXR9Y29tcHV0ZSh0LGUpe3RoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodCxlLHRoaXMuX3B0RGlzdCksdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZShlLHQsdGhpcy5fcHREaXN0KX1kaXN0YW5jZSgpe3JldHVybiB0aGlzLmNvbXB1dGUodGhpcy5fZzAsdGhpcy5fZzEpLHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpfWNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHQsZSxuKXtjb25zdCBzPW5ldyB2ZShlKTtpZih0LmFwcGx5KHMpLG4uc2V0TWF4aW11bShzLmdldE1heFBvaW50RGlzdGFuY2UoKSksdGhpcy5fZGVuc2lmeUZyYWM+MCl7Y29uc3Qgcz1uZXcgTWUoZSx0aGlzLl9kZW5zaWZ5RnJhYyk7dC5hcHBseShzKSxuLnNldE1heGltdW0ocy5nZXRNYXhQb2ludERpc3RhbmNlKCkpfX1vcmllbnRlZERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodGhpcy5fZzAsdGhpcy5fZzEsdGhpcy5fcHREaXN0KSx0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKX19Y2xhc3MgdmV7Y29uc3RydWN0b3IoKXt2ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9tYXhQdERpc3Q9bmV3IFJlLHRoaXMuX21pblB0RGlzdD1uZXcgUmUsdGhpcy5fZXVjbGlkZWFuRGlzdD1uZXcgUGUsdGhpcy5fZ2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb209dH1maWx0ZXIodCl7dGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKSxQZS5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSx0LHRoaXMuX21pblB0RGlzdCksdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KX1nZXRNYXhQb2ludERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21heFB0RGlzdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVV19fWNsYXNzIE1le2NvbnN0cnVjdG9yKCl7TWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWF4UHREaXN0PW5ldyBSZSx0aGlzLl9taW5QdERpc3Q9bmV3IFJlLHRoaXMuX2dlb209bnVsbCx0aGlzLl9udW1TdWJTZWdzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbT10LHRoaXMuX251bVN1YlNlZ3M9TWF0aC50cnVuYyhNYXRoLnJvdW5kKDEvZSkpfWZpbHRlcih0LGUpe2lmKDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlKGUtMSkscz10LmdldENvb3JkaW5hdGUoZSksaT0ocy54LW4ueCkvdGhpcy5fbnVtU3ViU2VncyxyPShzLnktbi55KS90aGlzLl9udW1TdWJTZWdzO2ZvcihsZXQgdD0wO3Q8dGhpcy5fbnVtU3ViU2Vnczt0Kyspe2NvbnN0IGU9bi54K3QqaSxzPW4ueSt0KnIsbz1uZXcgbShlLHMpO3RoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCksUGUuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sbyx0aGlzLl9taW5QdERpc3QpLHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCl9fWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITF9Z2V0TWF4UG9pbnREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9tYXhQdERpc3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1BdfX1PZS5NYXhQb2ludERpc3RhbmNlRmlsdGVyPXZlLE9lLk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlcj1NZTt2YXIgYmU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZTpPZSxEaXN0YW5jZVRvUG9pbnQ6UGUsUG9pbnRQYWlyRGlzdGFuY2U6UmV9KTtjbGFzcyBEZXt2aXNpdEl0ZW0odCl7fX1jbGFzcyBBZXtsb2NhdGUodCl7fX1jbGFzcyBGZXtjb25zdHJ1Y3Rvcigpe0ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21pbj1yLlBPU0lUSVZFX0lORklOSVRZLHRoaXMuX21heD1yLk5FR0FUSVZFX0lORklOSVRZfWdldE1pbigpe3JldHVybiB0aGlzLl9taW59aW50ZXJzZWN0cyh0LGUpe3JldHVybiEodGhpcy5fbWluPmV8fHRoaXMuX21heDx0KX1nZXRNYXgoKXtyZXR1cm4gdGhpcy5fbWF4fXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyhuZXcgbSh0aGlzLl9taW4sMCksbmV3IG0odGhpcy5fbWF4LDApKX19RmUuTm9kZUNvbXBhcmF0b3I9Y2xhc3N7Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWUsaT0obi5fbWluK24uX21heCkvMixyPShzLl9taW4rcy5fbWF4KS8yO3JldHVybiBpPHI/LTE6aT5yPzE6MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fTtjbGFzcyBHZSBleHRlbmRzIEZle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxHZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pdGVtPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWluPXQsdGhpcy5fbWF4PWUsdGhpcy5faXRlbT1ufXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bi52aXNpdEl0ZW0odGhpcy5faXRlbSl9fWNsYXNzIHFlIGV4dGVuZHMgRmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLHFlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGUxPW51bGwsdGhpcy5fbm9kZTI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2RlMT10LHRoaXMuX25vZGUyPWUsdGhpcy5idWlsZEV4dGVudCh0aGlzLl9ub2RlMSx0aGlzLl9ub2RlMil9YnVpbGRFeHRlbnQodCxlKXt0aGlzLl9taW49TWF0aC5taW4odC5fbWluLGUuX21pbiksdGhpcy5fbWF4PU1hdGgubWF4KHQuX21heCxlLl9tYXgpfXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bnVsbCE9PXRoaXMuX25vZGUxJiZ0aGlzLl9ub2RlMS5xdWVyeSh0LGUsbiksbnVsbCE9PXRoaXMuX25vZGUyJiZ0aGlzLl9ub2RlMi5xdWVyeSh0LGUsbil9fWNsYXNzIEJle2NvbnN0cnVjdG9yKCl7QmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGVhdmVzPW5ldyBMLHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9sZXZlbD0wfWJ1aWxkVHJlZSgpe3hlLnNvcnQodGhpcy5fbGVhdmVzLG5ldyBGZS5Ob2RlQ29tcGFyYXRvcik7bGV0IHQ9dGhpcy5fbGVhdmVzLGU9bnVsbCxuPW5ldyBMO2Zvcig7Oyl7aWYodGhpcy5idWlsZExldmVsKHQsbiksMT09PW4uc2l6ZSgpKXJldHVybiBuLmdldCgwKTtlPXQsdD1uLG49ZX19aW5zZXJ0KHQsZSxuKXtpZihudWxsIT09dGhpcy5fcm9vdCl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiSW5kZXggY2Fubm90IGJlIGFkZGVkIHRvIG9uY2UgaXQgaGFzIGJlZW4gcXVlcmllZFwiKTt0aGlzLl9sZWF2ZXMuYWRkKG5ldyBHZSh0LGUsbikpfXF1ZXJ5KHQsZSxuKXtpZih0aGlzLmluaXQoKSxudWxsPT09dGhpcy5fcm9vdClyZXR1cm4gbnVsbDt0aGlzLl9yb290LnF1ZXJ5KHQsZSxuKX1idWlsZFJvb3QoKXtpZihudWxsIT09dGhpcy5fcm9vdClyZXR1cm4gbnVsbDt0aGlzLl9yb290PXRoaXMuYnVpbGRUcmVlKCl9cHJpbnROb2RlKHQpe0Iub3V0LnByaW50bG4oV3QudG9MaW5lU3RyaW5nKG5ldyBtKHQuX21pbix0aGlzLl9sZXZlbCksbmV3IG0odC5fbWF4LHRoaXMuX2xldmVsKSkpfWluaXQoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3Jvb3R8fDA9PT10aGlzLl9sZWF2ZXMuc2l6ZSgpP251bGw6dm9pZCB0aGlzLmJ1aWxkUm9vdCgpfWJ1aWxkTGV2ZWwodCxlKXt0aGlzLl9sZXZlbCsrLGUuY2xlYXIoKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rPTIpe2NvbnN0IHM9dC5nZXQobik7aWYobnVsbD09PShuKzE8dC5zaXplKCk/dC5nZXQobik6bnVsbCkpZS5hZGQocyk7ZWxzZXtjb25zdCBzPW5ldyBxZSh0LmdldChuKSx0LmdldChuKzEpKTtlLmFkZChzKX19fX1jbGFzcyBZZXtjb25zdHJ1Y3Rvcigpe1llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2l0ZW1zPW5ldyBMfXZpc2l0SXRlbSh0KXt0aGlzLl9pdGVtcy5hZGQodCl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RlXX19Y2xhc3MgVmV7Y29uc3RydWN0b3IoKXtWZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wPW51bGwsdGhpcy5fY3Jvc3NpbmdDb3VudD0wLHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcD10fXN0YXRpYyBsb2NhdGVQb2ludEluUmluZygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmSShhcmd1bWVudHNbMV0sRikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9bmV3IFZlKGFyZ3VtZW50c1swXSksbj1uZXcgbSxzPW5ldyBtO2ZvcihsZXQgaT0xO2k8dC5zaXplKCk7aSsrKWlmKHQuZ2V0Q29vcmRpbmF0ZShpLG4pLHQuZ2V0Q29vcmRpbmF0ZShpLTEscyksZS5jb3VudFNlZ21lbnQobixzKSxlLmlzT25TZWdtZW50KCkpcmV0dXJuIGUuZ2V0TG9jYXRpb24oKTtyZXR1cm4gZS5nZXRMb2NhdGlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1uZXcgVmUoYXJndW1lbnRzWzBdKTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dLGk9dFtuLTFdO2lmKGUuY291bnRTZWdtZW50KHMsaSksZS5pc09uU2VnbWVudCgpKXJldHVybiBlLmdldExvY2F0aW9uKCl9cmV0dXJuIGUuZ2V0TG9jYXRpb24oKX19Y291bnRTZWdtZW50KHQsZSl7aWYodC54PHRoaXMuX3AueCYmZS54PHRoaXMuX3AueClyZXR1cm4gbnVsbDtpZih0aGlzLl9wLng9PT1lLngmJnRoaXMuX3AueT09PWUueSlyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2lmKHQueT09PXRoaXMuX3AueSYmZS55PT09dGhpcy5fcC55KXtsZXQgbj10Lngscz1lLng7cmV0dXJuIG4+cyYmKG49ZS54LHM9dC54KSx0aGlzLl9wLng+PW4mJnRoaXMuX3AueDw9cyYmKHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITApLG51bGx9aWYodC55PnRoaXMuX3AueSYmZS55PD10aGlzLl9wLnl8fGUueT50aGlzLl9wLnkmJnQueTw9dGhpcy5fcC55KXtsZXQgbj1HLmluZGV4KHQsZSx0aGlzLl9wKTtpZihuPT09Ry5DT0xMSU5FQVIpcmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ9ITAsbnVsbDtlLnk8dC55JiYobj0tbiksbj09PUcuTEVGVCYmdGhpcy5fY3Jvc3NpbmdDb3VudCsrfX1pc1BvaW50SW5Qb2x5Z29uKCl7cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSE9PVF0LkVYVEVSSU9SfWdldExvY2F0aW9uKCl7cmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQ/UXQuQk9VTkRBUlk6dGhpcy5fY3Jvc3NpbmdDb3VudCUyPT0xP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SfWlzT25TZWdtZW50KCl7cmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnR9fWNsYXNzIHple2NvbnN0cnVjdG9yKCl7emUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbT1udWxsLHRoaXMuX2luZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoIShJKHQsc3QpfHx0IGluc3RhbmNlb2YgdXQpKXRocm93IG5ldyBzKFwiQXJndW1lbnQgbXVzdCBiZSBQb2x5Z29uYWwgb3IgTGluZWFyUmluZ1wiKTt0aGlzLl9nZW9tPXR9bG9jYXRlKHQpe251bGw9PT10aGlzLl9pbmRleCYmKHRoaXMuX2luZGV4PW5ldyBYZSh0aGlzLl9nZW9tKSx0aGlzLl9nZW9tPW51bGwpO2NvbnN0IGU9bmV3IFZlKHQpLG49bmV3IGtlKGUpO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeSh0LnksdC55LG4pLGUuZ2V0TG9jYXRpb24oKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfX1jbGFzcyBrZXtjb25zdHJ1Y3Rvcigpe2tlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvdW50ZXI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb3VudGVyPXR9dmlzaXRJdGVtKHQpe2NvbnN0IGU9dDt0aGlzLl9jb3VudGVyLmNvdW50U2VnbWVudChlLmdldENvb3JkaW5hdGUoMCksZS5nZXRDb29yZGluYXRlKDEpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRGVdfX1jbGFzcyBYZXtjb25zdHJ1Y3Rvcigpe1hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRW1wdHk9ITEsdGhpcy5faW5kZXg9bmV3IEJlO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuaXNFbXB0eSgpP3RoaXMuX2lzRW1wdHk9ITA6dGhpcy5pbml0KHQpfWluaXQodCl7Zm9yKGxldCBlPXllLmdldExpbmVzKHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7dGhpcy5hZGRMaW5lKHQpfX1hZGRMaW5lKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPW5ldyBLdCh0W2UtMV0sdFtlXSkscz1NYXRoLm1pbihuLnAwLnksbi5wMS55KSxpPU1hdGgubWF4KG4ucDAueSxuLnAxLnkpO3RoaXMuX2luZGV4Lmluc2VydChzLGksbil9fXF1ZXJ5KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzRW1wdHkpcmV0dXJuIG5ldyBMO2NvbnN0IG49bmV3IFllO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeSh0LGUsbiksbi5nZXRJdGVtcygpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLl9pc0VtcHR5KXJldHVybiBudWxsO3RoaXMuX2luZGV4LnF1ZXJ5KHQsZSxuKX19fXplLlNlZ21lbnRWaXNpdG9yPWtlLHplLkludGVydmFsSW5kZXhlZEdlb21ldHJ5PVhlO2NsYXNzIFVle3N0YXRpYyBpc09uTGluZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmSShhcmd1bWVudHNbMV0sRikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGp0LHM9bmV3IG0saT1uZXcgbSxyPWUuc2l6ZSgpO2ZvcihsZXQgbz0xO288cjtvKyspaWYoZS5nZXRDb29yZGluYXRlKG8tMSxzKSxlLmdldENvb3JkaW5hdGUobyxpKSxuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxzLGkpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITA7cmV0dXJuITF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBqdDtmb3IobGV0IHM9MTtzPGUubGVuZ3RoO3MrKyl7Y29uc3QgaT1lW3MtMV0scj1lW3NdO2lmKG4uY29tcHV0ZUludGVyc2VjdGlvbih0LGksciksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMH1yZXR1cm4hMX19c3RhdGljIGxvY2F0ZUluUmluZyh0LGUpe3JldHVybiBWZS5sb2NhdGVQb2ludEluUmluZyh0LGUpfXN0YXRpYyBpc0luUmluZyh0LGUpe3JldHVybiBVZS5sb2NhdGVJblJpbmcodCxlKSE9PVF0LkVYVEVSSU9SfX1jbGFzcyBIZXtoYXNOZXh0KCl7fW5leHQoKXt9cmVtb3ZlKCl7fX1jbGFzcyBXZXtjb25zdHJ1Y3Rvcigpe1dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BhcmVudD1udWxsLHRoaXMuX2F0U3RhcnQ9bnVsbCx0aGlzLl9tYXg9bnVsbCx0aGlzLl9pbmRleD1udWxsLHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudD10LHRoaXMuX2F0U3RhcnQ9ITAsdGhpcy5faW5kZXg9MCx0aGlzLl9tYXg9dC5nZXROdW1HZW9tZXRyaWVzKCl9c3RhdGljIGlzQXRvbWljKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIGN0KX1uZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4gdGhpcy5fYXRTdGFydD0hMSxXZS5pc0F0b21pYyh0aGlzLl9wYXJlbnQpJiZ0aGlzLl9pbmRleCsrLHRoaXMuX3BhcmVudDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfWlmKHRoaXMuX2luZGV4Pj10aGlzLl9tYXgpdGhyb3cgbmV3IEM7Y29uc3QgdD10aGlzLl9wYXJlbnQuZ2V0R2VvbWV0cnlOKHRoaXMuX2luZGV4KyspO3JldHVybiB0IGluc3RhbmNlb2YgY3Q/KHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1uZXcgV2UodCksdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKSk6dH1yZW1vdmUoKXt0aHJvdyBuZXcgaih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKX1oYXNOZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4hMDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiEwO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfXJldHVybiEodGhpcy5faW5kZXg+PXRoaXMuX21heCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hlXX19Y2xhc3MgWmV7Y29uc3RydWN0b3IoKXtaZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbT10fXN0YXRpYyBsb2NhdGVQb2ludEluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBRdC5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz1aZS5sb2NhdGVQb2ludEluUmluZyh0LG4pO2lmKHMhPT1RdC5JTlRFUklPUilyZXR1cm4gcztmb3IobGV0IG49MDtuPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bisrKXtjb25zdCBzPWUuZ2V0SW50ZXJpb3JSaW5nTihuKSxpPVplLmxvY2F0ZVBvaW50SW5SaW5nKHQscyk7aWYoaT09PVF0LkJPVU5EQVJZKXJldHVybiBRdC5CT1VOREFSWTtpZihpPT09UXQuSU5URVJJT1IpcmV0dXJuIFF0LkVYVEVSSU9SfXJldHVybiBRdC5JTlRFUklPUn1zdGF0aWMgbG9jYXRlUG9pbnRJblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9VZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOlF0LkVYVEVSSU9SfXN0YXRpYyBjb250YWluc1BvaW50SW5Qb2x5Z29uKHQsZSl7cmV0dXJuIFF0LkVYVEVSSU9SIT09WmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKX1zdGF0aWMgbG9jYXRlSW5HZW9tZXRyeSh0LGUpe2lmKGUgaW5zdGFuY2VvZiBpdClyZXR1cm4gWmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKTtpZihlIGluc3RhbmNlb2YgY3Qpe2NvbnN0IG49bmV3IFdlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHMhPT1lKXtjb25zdCBlPVplLmxvY2F0ZUluR2VvbWV0cnkodCxzKTtpZihlIT09UXQuRVhURVJJT1IpcmV0dXJuIGV9fX1yZXR1cm4gUXQuRVhURVJJT1J9c3RhdGljIGlzQ29udGFpbmVkKHQsZSl7cmV0dXJuIFF0LkVYVEVSSU9SIT09WmUubG9jYXRlKHQsZSl9c3RhdGljIGxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9RdC5FWFRFUklPUjplLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP1plLmxvY2F0ZUluR2VvbWV0cnkodCxlKTpRdC5FWFRFUklPUn1sb2NhdGUodCl7cmV0dXJuIFplLmxvY2F0ZSh0LHRoaXMuX2dlb20pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fXZhciBqZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yOnplLFBvaW50T25HZW9tZXRyeUxvY2F0b3I6QWUsU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yOlplfSk7Y2xhc3MgS2V7bWVhc3VyZSh0LGUpe319Y2xhc3MgUWV7c3RhdGljIGRpYWdvbmFsU2l6ZSh0KXtpZih0LmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfW1lYXN1cmUodCxlKXtjb25zdCBuPU9lLmRpc3RhbmNlKHQsZSxRZS5ERU5TSUZZX0ZSQUNUSU9OKSxzPW5ldyBPKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtzLmV4cGFuZFRvSW5jbHVkZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIDEtbi9RZS5kaWFnb25hbFNpemUocyl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0tlXX19UWUuREVOU0lGWV9GUkFDVElPTj0uMjU7dmFyIEplPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFyZWFTaW1pbGFyaXR5TWVhc3VyZTpjbGFzc3ttZWFzdXJlKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKGUpLmdldEFyZWEoKS90LnVuaW9uKGUpLmdldEFyZWEoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bS2VdfX0sSGF1c2RvcmZmU2ltaWxhcml0eU1lYXN1cmU6UWUsU2ltaWxhcml0eU1lYXN1cmU6S2UsU2ltaWxhcml0eU1lYXN1cmVDb21iaW5lcjpjbGFzc3tzdGF0aWMgY29tYmluZSh0LGUpe3JldHVybiBNYXRoLm1pbih0LGUpfX19KTtjbGFzcyAkZXtjb25zdHJ1Y3RvcigpeyRlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2FyZWFCYXNlUHQ9bnVsbCx0aGlzLl90cmlhbmdsZUNlbnQzPW5ldyBtLHRoaXMuX2FyZWFzdW0yPTAsdGhpcy5fY2czPW5ldyBtLHRoaXMuX2xpbmVDZW50U3VtPW5ldyBtLHRoaXMuX3RvdGFsTGVuZ3RoPTAsdGhpcy5fcHRDb3VudD0wLHRoaXMuX3B0Q2VudFN1bT1uZXcgbTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmVhQmFzZVB0PW51bGwsdGhpcy5hZGQodCl9c3RhdGljIGFyZWEyKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShuLngtdC54KSooZS55LXQueSl9c3RhdGljIGNlbnRyb2lkMyh0LGUsbixzKXtyZXR1cm4gcy54PXQueCtlLngrbi54LHMueT10LnkrZS55K24ueSxudWxsfXN0YXRpYyBnZXRDZW50cm9pZCh0KXtyZXR1cm4gbmV3ICRlKHQpLmdldENlbnRyb2lkKCl9c2V0QXJlYUJhc2VQb2ludCh0KXt0aGlzLl9hcmVhQmFzZVB0PXR9YWRkUG9pbnQodCl7dGhpcy5fcHRDb3VudCs9MSx0aGlzLl9wdENlbnRTdW0ueCs9dC54LHRoaXMuX3B0Q2VudFN1bS55Kz10Lnl9YWRkTGluZVNlZ21lbnRzKHQpe2xldCBlPTA7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl7Y29uc3Qgcz10W25dLmRpc3RhbmNlKHRbbisxXSk7aWYoMD09PXMpY29udGludWU7ZSs9cztjb25zdCBpPSh0W25dLngrdFtuKzFdLngpLzI7dGhpcy5fbGluZUNlbnRTdW0ueCs9cyppO2NvbnN0IHI9KHRbbl0ueSt0W24rMV0ueSkvMjt0aGlzLl9saW5lQ2VudFN1bS55Kz1zKnJ9dGhpcy5fdG90YWxMZW5ndGgrPWUsMD09PWUmJnQubGVuZ3RoPjAmJnRoaXMuYWRkUG9pbnQodFswXSl9YWRkSG9sZSh0KXtjb25zdCBlPUcuaXNDQ1codCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuX2FyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9Z2V0Q2VudHJvaWQoKXtjb25zdCB0PW5ldyBtO2lmKE1hdGguYWJzKHRoaXMuX2FyZWFzdW0yKT4wKXQueD10aGlzLl9jZzMueC8zL3RoaXMuX2FyZWFzdW0yLHQueT10aGlzLl9jZzMueS8zL3RoaXMuX2FyZWFzdW0yO2Vsc2UgaWYodGhpcy5fdG90YWxMZW5ndGg+MCl0Lng9dGhpcy5fbGluZUNlbnRTdW0ueC90aGlzLl90b3RhbExlbmd0aCx0Lnk9dGhpcy5fbGluZUNlbnRTdW0ueS90aGlzLl90b3RhbExlbmd0aDtlbHNle2lmKCEodGhpcy5fcHRDb3VudD4wKSlyZXR1cm4gbnVsbDt0Lng9dGhpcy5fcHRDZW50U3VtLngvdGhpcy5fcHRDb3VudCx0Lnk9dGhpcy5fcHRDZW50U3VtLnkvdGhpcy5fcHRDb3VudH1yZXR1cm4gdH1hZGRTaGVsbCh0KXt0Lmxlbmd0aD4wJiZ0aGlzLnNldEFyZWFCYXNlUG9pbnQodFswXSk7Y29uc3QgZT0hRy5pc0NDVyh0KTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5fYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX1hZGRUcmlhbmdsZSh0LGUsbixzKXtjb25zdCBpPXM/MTotMTskZS5jZW50cm9pZDModCxlLG4sdGhpcy5fdHJpYW5nbGVDZW50Myk7Y29uc3Qgcj0kZS5hcmVhMih0LGUsbik7dGhpcy5fY2czLngrPWkqcip0aGlzLl90cmlhbmdsZUNlbnQzLngsdGhpcy5fY2czLnkrPWkqcip0aGlzLl90cmlhbmdsZUNlbnQzLnksdGhpcy5fYXJlYXN1bTIrPWkqcn1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGl0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZFNoZWxsKHQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl0aGlzLmFkZEhvbGUodC5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgdHQpdGhpcy5hZGRQb2ludCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgSil0aGlzLmFkZExpbmVTZWdtZW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGl0KXtjb25zdCBlPXQ7dGhpcy5hZGQoZSl9ZWxzZSBpZih0IGluc3RhbmNlb2YgY3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fX19Y2xhc3MgdG4gZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7RW1wdHlTdGFja0V4Y2VwdGlvbjp0bn0pWzBdfX1jbGFzcyBlbiBleHRlbmRzIHd7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuYXJyYXk9W119YWRkKHQpe3JldHVybiB0aGlzLmFycmF5LnB1c2godCksITB9Z2V0KHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IFM7cmV0dXJuIHRoaXMuYXJyYXlbdF19cHVzaCh0KXtyZXR1cm4gdGhpcy5hcnJheS5wdXNoKHQpLHR9cG9wKCl7aWYoMD09PXRoaXMuYXJyYXkubGVuZ3RoKXRocm93IG5ldyB0bjtyZXR1cm4gdGhpcy5hcnJheS5wb3AoKX1wZWVrKCl7aWYoMD09PXRoaXMuYXJyYXkubGVuZ3RoKXRocm93IG5ldyB0bjtyZXR1cm4gdGhpcy5hcnJheVt0aGlzLmFycmF5Lmxlbmd0aC0xXX1lbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9aXNFbXB0eSgpe3JldHVybiB0aGlzLmVtcHR5KCl9c2VhcmNoKHQpe3JldHVybiB0aGlzLmFycmF5LmluZGV4T2YodCl9c2l6ZSgpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aH10b0FycmF5KCl7cmV0dXJuIHRoaXMuYXJyYXkuc2xpY2UoKX19Y2xhc3Mgbm57Y29uc3RydWN0b3IoKXtubi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZFNldD1uZXcgeHQsdGhpcy5fbGlzdD1uZXcgTH1zdGF0aWMgZmlsdGVyQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbm47Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5maWx0ZXIodFtuXSk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZXMoKX1maWx0ZXIodCl7dGhpcy5fY29vcmRTZXQuYWRkKHQpJiZ0aGlzLl9saXN0LmFkZCh0KX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2xpc3Quc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLl9saXN0LnRvQXJyYXkodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1VdfX1jbGFzcyBzbntjb25zdHJ1Y3Rvcigpe3NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5faW5wdXRQdHM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07c24uY29uc3RydWN0b3JfLmNhbGwodGhpcyxzbi5leHRyYWN0Q29vcmRpbmF0ZXModCksdC5nZXRGYWN0b3J5KCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0UHRzPW5uLmZpbHRlckNvb3JkaW5hdGVzKHQpLHRoaXMuX2dlb21GYWN0b3J5PWV9fXN0YXRpYyBleHRyYWN0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbm47cmV0dXJuIHQuYXBwbHkoZSksZS5nZXRDb29yZGluYXRlcygpfXByZVNvcnQodCl7bGV0IGU9bnVsbDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKykodFtuXS55PHRbMF0ueXx8dFtuXS55PT09dFswXS55JiZ0W25dLng8dFswXS54KSYmKGU9dFswXSx0WzBdPXRbbl0sdFtuXT1lKTtyZXR1cm4gbnQuc29ydCh0LDEsdC5sZW5ndGgsbmV3IHJuKHRbMF0pKSx0fWNvbXB1dGVPY3RSaW5nKHQpe2NvbnN0IGU9dGhpcy5jb21wdXRlT2N0UHRzKHQpLG49bmV3IFI7cmV0dXJuIG4uYWRkKGUsITEpLG4uc2l6ZSgpPDM/bnVsbDoobi5jbG9zZVJpbmcoKSxuLnRvQ29vcmRpbmF0ZUFycmF5KCkpfWxpbmVPclBvbHlnb24odCl7aWYoMz09PSh0PXRoaXMuY2xlYW5SaW5nKHQpKS5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW3RbMF0sdFsxXV0pO2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KTtyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlUG9seWdvbihlKX1jbGVhblJpbmcodCl7Zy5lcXVhbHModFswXSx0W3QubGVuZ3RoLTFdKTtjb25zdCBlPW5ldyBMO2xldCBuPW51bGw7Zm9yKGxldCBzPTA7czw9dC5sZW5ndGgtMjtzKyspe2NvbnN0IGk9dFtzXSxyPXRbcysxXTtpLmVxdWFscyhyKXx8KG51bGwhPT1uJiZ0aGlzLmlzQmV0d2VlbihuLGkscil8fChlLmFkZChpKSxuPWkpKX1lLmFkZCh0W3QubGVuZ3RoLTFdKTtjb25zdCBzPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gZS50b0FycmF5KHMpfWlzQmV0d2Vlbih0LGUsbil7aWYoMCE9PUcuaW5kZXgodCxlLG4pKXJldHVybiExO2lmKHQueCE9PW4ueCl7aWYodC54PD1lLngmJmUueDw9bi54KXJldHVybiEwO2lmKG4ueDw9ZS54JiZlLng8PXQueClyZXR1cm4hMH1pZih0LnkhPT1uLnkpe2lmKHQueTw9ZS55JiZlLnk8PW4ueSlyZXR1cm4hMDtpZihuLnk8PWUueSYmZS55PD10LnkpcmV0dXJuITB9cmV0dXJuITF9cmVkdWNlKHQpe2NvbnN0IGU9dGhpcy5jb21wdXRlT2N0UmluZyh0KTtpZihudWxsPT09ZSlyZXR1cm4gdDtjb25zdCBuPW5ldyBsdDtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyluLmFkZChlW3RdKTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKylVZS5pc0luUmluZyh0W3NdLGUpfHxuLmFkZCh0W3NdKTtjb25zdCBzPWR0LnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiBzLmxlbmd0aDwzP3RoaXMucGFkQXJyYXkzKHMpOnN9Z2V0Q29udmV4SHVsbCgpe2lmKDA9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKDE9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuX2lucHV0UHRzWzBdKTtpZigyPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX2lucHV0UHRzKTtsZXQgdD10aGlzLl9pbnB1dFB0czt0aGlzLl9pbnB1dFB0cy5sZW5ndGg+NTAmJih0PXRoaXMucmVkdWNlKHRoaXMuX2lucHV0UHRzKSk7Y29uc3QgZT10aGlzLnByZVNvcnQodCksbj10aGlzLmdyYWhhbVNjYW4oZSkscz10aGlzLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiB0aGlzLmxpbmVPclBvbHlnb24ocyl9cGFkQXJyYXkzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspbjx0Lmxlbmd0aD9lW25dPXRbbl06ZVtuXT10WzBdO3JldHVybiBlfWNvbXB1dGVPY3RQdHModCl7Y29uc3QgZT1uZXcgQXJyYXkoOCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXS54PGVbMF0ueCYmKGVbMF09dFtuXSksdFtuXS54LXRbbl0ueTxlWzFdLngtZVsxXS55JiYoZVsxXT10W25dKSx0W25dLnk+ZVsyXS55JiYoZVsyXT10W25dKSx0W25dLngrdFtuXS55PmVbM10ueCtlWzNdLnkmJihlWzNdPXRbbl0pLHRbbl0ueD5lWzRdLngmJihlWzRdPXRbbl0pLHRbbl0ueC10W25dLnk+ZVs1XS54LWVbNV0ueSYmKGVbNV09dFtuXSksdFtuXS55PGVbNl0ueSYmKGVbNl09dFtuXSksdFtuXS54K3Rbbl0ueTxlWzddLngrZVs3XS55JiYoZVs3XT10W25dKTtyZXR1cm4gZX10b0Nvb3JkaW5hdGVBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10LmdldChuKTtlW25dPXN9cmV0dXJuIGV9Z3JhaGFtU2Nhbih0KXtsZXQgZT1udWxsO2NvbnN0IG49bmV3IGVuO24ucHVzaCh0WzBdKSxuLnB1c2godFsxXSksbi5wdXNoKHRbMl0pO2ZvcihsZXQgcz0zO3M8dC5sZW5ndGg7cysrKXtmb3IoZT1uLnBvcCgpOyFuLmVtcHR5KCkmJkcuaW5kZXgobi5wZWVrKCksZSx0W3NdKT4wOyllPW4ucG9wKCk7bi5wdXNoKGUpLG4ucHVzaCh0W3NdKX1yZXR1cm4gbi5wdXNoKHRbMF0pLG59fWNsYXNzIHJue2NvbnN0cnVjdG9yKCl7cm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3JpZ2luPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZ2luPXR9c3RhdGljIHBvbGFyQ29tcGFyZSh0LGUsbil7Y29uc3Qgcz1lLngtdC54LGk9ZS55LXQueSxyPW4ueC10Lngsbz1uLnktdC55LGw9Ry5pbmRleCh0LGUsbik7aWYobD09PUcuQ09VTlRFUkNMT0NLV0lTRSlyZXR1cm4gMTtpZihsPT09Ry5DTE9DS1dJU0UpcmV0dXJuLTE7Y29uc3QgYT1zKnMraSppLGM9cipyK28qbztyZXR1cm4gYTxjPy0xOmE+Yz8xOjB9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7cmV0dXJuIHJuLnBvbGFyQ29tcGFyZSh0aGlzLl9vcmlnaW4sbixzKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fXNuLlJhZGlhbENvbXBhcmF0b3I9cm47Y2xhc3Mgb257Y29uc3RydWN0b3IoKXtvbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnRlcmlvclBvaW50PW51bGwsdGhpcy5fbWF4V2lkdGg9LTE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wcm9jZXNzKHQpfXN0YXRpYyBnZXRJbnRlcmlvclBvaW50KHQpe3JldHVybiBuZXcgb24odCkuZ2V0SW50ZXJpb3JQb2ludCgpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1wcm9jZXNzKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBpdCl0aGlzLnByb2Nlc3NQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGN0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5wcm9jZXNzKGUuZ2V0R2VvbWV0cnlOKHQpKX19cHJvY2Vzc1BvbHlnb24odCl7Y29uc3QgZT1uZXcgbG4odCk7ZS5wcm9jZXNzKCk7Y29uc3Qgbj1lLmdldFdpZHRoKCk7bj50aGlzLl9tYXhXaWR0aCYmKHRoaXMuX21heFdpZHRoPW4sdGhpcy5faW50ZXJpb3JQb2ludD1lLmdldEludGVyaW9yUG9pbnQoKSl9fWNsYXNzIGxue2NvbnN0cnVjdG9yKCl7bG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcG9seWdvbj1udWxsLHRoaXMuX2ludGVyaW9yUG9pbnRZPW51bGwsdGhpcy5faW50ZXJpb3JTZWN0aW9uV2lkdGg9MCx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG9seWdvbj10LHRoaXMuX2ludGVyaW9yUG9pbnRZPWNuLmdldFNjYW5MaW5lWSh0KX1zdGF0aWMgaXNFZGdlQ3Jvc3NpbmdDb3VudGVkKHQsZSxuKXtjb25zdCBzPXQuZ2V0WSgpLGk9ZS5nZXRZKCk7cmV0dXJuIHMhPT1pJiYoIShzPT09biYmaTxuKSYmIShpPT09biYmczxuKSl9c3RhdGljIGludGVyc2VjdHNIb3Jpem9udGFsTGluZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hKGU8dC5nZXRNaW5ZKCkpJiYhKGU+dC5nZXRNYXhZKCkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4hKHQuZ2V0WSgpPm4mJmUuZ2V0WSgpPm4pJiYhKHQuZ2V0WSgpPG4mJmUuZ2V0WSgpPG4pfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSxuKXtjb25zdCBzPXQuZ2V0WCgpLGk9ZS5nZXRYKCk7aWYocz09PWkpcmV0dXJuIHM7Y29uc3Qgcj1pLXMsbz0oZS5nZXRZKCktdC5nZXRZKCkpL3I7cmV0dXJuIHMrKG4tdC5nZXRZKCkpL299ZmluZEJlc3RNaWRwb2ludCh0KXtpZigwPT09dC5zaXplKCkpcmV0dXJuIG51bGw7Zy5pc1RydWUoMD09dC5zaXplKCklMixcIkludGVyaW9yIFBvaW50IHJvYnVzdG5lc3MgZmFpbHVyZTogb2RkIG51bWJlciBvZiBzY2FubGluZSBjcm9zc2luZ3NcIiksdC5zb3J0KG5ldyBhbik7Zm9yKGxldCBlPTA7ZTx0LnNpemUoKTtlKz0yKXtjb25zdCBuPXQuZ2V0KGUpLHM9dC5nZXQoZSsxKSxpPXMtbjtpZihpPnRoaXMuX2ludGVyaW9yU2VjdGlvbldpZHRoKXt0aGlzLl9pbnRlcmlvclNlY3Rpb25XaWR0aD1pO2NvbnN0IHQ9b24uYXZnKG4scyk7dGhpcy5faW50ZXJpb3JQb2ludD1uZXcgbSh0LHRoaXMuX2ludGVyaW9yUG9pbnRZKX19fXByb2Nlc3MoKXtpZih0aGlzLl9wb2x5Z29uLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHRoaXMuX3BvbHlnb24uZ2V0Q29vcmRpbmF0ZSgpKTtjb25zdCB0PW5ldyBMO3RoaXMuc2NhblJpbmcodGhpcy5fcG9seWdvbi5nZXRFeHRlcmlvclJpbmcoKSx0KTtmb3IobGV0IGU9MDtlPHRoaXMuX3BvbHlnb24uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuc2NhblJpbmcodGhpcy5fcG9seWdvbi5nZXRJbnRlcmlvclJpbmdOKGUpLHQpO3RoaXMuZmluZEJlc3RNaWRwb2ludCh0KX1zY2FuUmluZyh0LGUpe2lmKCFsbi5pbnRlcnNlY3RzSG9yaXpvbnRhbExpbmUodC5nZXRFbnZlbG9wZUludGVybmFsKCksdGhpcy5faW50ZXJpb3JQb2ludFkpKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MTt0PG4uc2l6ZSgpO3QrKyl7Y29uc3Qgcz1uLmdldENvb3JkaW5hdGUodC0xKSxpPW4uZ2V0Q29vcmRpbmF0ZSh0KTt0aGlzLmFkZEVkZ2VDcm9zc2luZyhzLGksdGhpcy5faW50ZXJpb3JQb2ludFksZSl9fWdldFdpZHRoKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yU2VjdGlvbldpZHRofWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGRFZGdlQ3Jvc3NpbmcodCxlLG4scyl7aWYoIWxuLmludGVyc2VjdHNIb3Jpem9udGFsTGluZSh0LGUsbikpcmV0dXJuIG51bGw7aWYoIWxuLmlzRWRnZUNyb3NzaW5nQ291bnRlZCh0LGUsbikpcmV0dXJuIG51bGw7Y29uc3QgaT1sbi5pbnRlcnNlY3Rpb24odCxlLG4pO3MuYWRkKGkpfX1jbGFzcyBhbntjb21wYXJlKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTowfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19bG4uRG91YmxlQ29tcGFyYXRvcj1hbjtjbGFzcyBjbntjb25zdHJ1Y3Rvcigpe2NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BvbHk9bnVsbCx0aGlzLl9jZW50cmVZPW51bGwsdGhpcy5faGlZPXIuTUFYX1ZBTFVFLHRoaXMuX2xvWT0tci5NQVhfVkFMVUU7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG9seT10LHRoaXMuX2hpWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNYXhZKCksdGhpcy5fbG9ZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1pblkoKSx0aGlzLl9jZW50cmVZPW9uLmF2Zyh0aGlzLl9sb1ksdGhpcy5faGlZKX1zdGF0aWMgZ2V0U2NhbkxpbmVZKHQpe3JldHVybiBuZXcgY24odCkuZ2V0U2NhbkxpbmVZKCl9dXBkYXRlSW50ZXJ2YWwodCl7dDw9dGhpcy5fY2VudHJlWT90PnRoaXMuX2xvWSYmKHRoaXMuX2xvWT10KTp0PnRoaXMuX2NlbnRyZVkmJnQ8dGhpcy5faGlZJiYodGhpcy5faGlZPXQpfWdldFNjYW5MaW5lWSgpe3RoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEV4dGVyaW9yUmluZygpKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3BvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXRoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEludGVyaW9yUmluZ04odCkpO3JldHVybiBvbi5hdmcodGhpcy5faGlZLHRoaXMuX2xvWSl9cHJvY2Vzcyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IG49ZS5nZXRZKHQpO3RoaXMudXBkYXRlSW50ZXJ2YWwobil9fX1vbi5JbnRlcmlvclBvaW50UG9seWdvbj1sbixvbi5TY2FuTGluZVlPcmRpbmF0ZUZpbmRlcj1jbjtjbGFzcyBobntjb25zdHJ1Y3Rvcigpe2huLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NlbnRyb2lkPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuaXNFbXB0eSgpP3RoaXMuX2NlbnRyb2lkPW51bGw6KHRoaXMuX2NlbnRyb2lkPSRlLmdldENlbnRyb2lkKHQpLHQuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0aGlzLl9jZW50cm9pZCkpLHRoaXMuYWRkSW50ZXJpb3IodCksbnVsbD09PXRoaXMuX2ludGVyaW9yUG9pbnQmJnRoaXMuYWRkRW5kcG9pbnRzKHQpfXN0YXRpYyBnZXRJbnRlcmlvclBvaW50KHQpe3JldHVybiBuZXcgaG4odCkuZ2V0SW50ZXJpb3JQb2ludCgpfWFkZEVuZHBvaW50cygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIEopdGhpcy5hZGRFbmRwb2ludHModC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBjdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkRW5kcG9pbnRzKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0WzBdKSx0aGlzLmFkZCh0W3QubGVuZ3RoLTFdKX19Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fWFkZEludGVyaW9yKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgSil0aGlzLmFkZEludGVyaW9yKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgY3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZEludGVyaW9yKGUuZ2V0R2VvbWV0cnlOKHQpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoLTE7ZSsrKXRoaXMuYWRkKHRbZV0pfX1hZGQodCl7Y29uc3QgZT10LmRpc3RhbmNlKHRoaXMuX2NlbnRyb2lkKTtlPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5faW50ZXJpb3JQb2ludD1uZXcgbSh0KSx0aGlzLl9taW5EaXN0YW5jZT1lKX19Y2xhc3MgdW57Y29uc3RydWN0b3IoKXt1bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jZW50cm9pZD1udWxsLHRoaXMuX21pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jZW50cm9pZD0kZS5nZXRDZW50cm9pZCh0KSx0aGlzLmFkZCh0KX1zdGF0aWMgZ2V0SW50ZXJpb3JQb2ludCh0KXtyZXR1cm4gbmV3IHVuKHQpLmdldEludGVyaW9yUG9pbnQoKX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgdHQpdGhpcy5hZGQodC5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGN0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmRpc3RhbmNlKHRoaXMuX2NlbnRyb2lkKTtlPHRoaXMuX21pbkRpc3RhbmNlJiYodGhpcy5faW50ZXJpb3JQb2ludD1uZXcgbSh0KSx0aGlzLl9taW5EaXN0YW5jZT1lKX19fWNsYXNzIGdue2lzSW5Cb3VuZGFyeSh0KXt9fWNsYXNzIGRue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdCUyPT0xfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnbl19fWNsYXNzIF9ue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdD4wfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnbl19fWNsYXNzIHBue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdD4xfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnbl19fWNsYXNzIG1ue2lzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gMT09PXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Z24uTW9kMkJvdW5kYXJ5Tm9kZVJ1bGU9ZG4sZ24uRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPV9uLGduLk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPXBuLGduLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9bW4sZ24uTU9EMl9CT1VOREFSWV9SVUxFPW5ldyBkbixnbi5FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBfbixnbi5NVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBwbixnbi5NT05PVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IG1uLGduLk9HQ19TRlNfQk9VTkRBUllfUlVMRT1nbi5NT0QyX0JPVU5EQVJZX1JVTEU7Y2xhc3MgZm57Y29uc3RydWN0b3IoKXtmbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9ib3VuZGFyeVJ1bGU9Z24uT0dDX1NGU19CT1VOREFSWV9SVUxFLHRoaXMuX2lzSW49bnVsbCx0aGlzLl9udW1Cb3VuZGFyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXRocm93IG5ldyBzKFwiUnVsZSBtdXN0IGJlIG5vbi1udWxsXCIpO3RoaXMuX2JvdW5kYXJ5UnVsZT10fX1sb2NhdGVJblBvbHlnb25SaW5nKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/VWUubG9jYXRlSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpRdC5FWFRFUklPUn1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRlKHQsZSkhPT1RdC5FWFRFUklPUn11cGRhdGVMb2NhdGlvbkluZm8odCl7dD09PVF0LklOVEVSSU9SJiYodGhpcy5faXNJbj0hMCksdD09PVF0LkJPVU5EQVJZJiZ0aGlzLl9udW1Cb3VuZGFyaWVzKyt9Y29tcHV0ZUxvY2F0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIHR0JiZ0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uUG9pbnQodCxlKSksZSBpbnN0YW5jZW9mIEopdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgaXQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJblBvbHlnb24odCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2Ygd3Qpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgZnQpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUluUG9seWdvbih0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgY3Qpe2NvbnN0IG49bmV3IFdlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MhPT1lJiZ0aGlzLmNvbXB1dGVMb2NhdGlvbih0LHMpfX19bG9jYXRlT25Qb2ludCh0LGUpe3JldHVybiBlLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0KT9RdC5JTlRFUklPUjpRdC5FWFRFUklPUn1sb2NhdGVPbkxpbmVTdHJpbmcodCxlKXtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KSlyZXR1cm4gUXQuRVhURVJJT1I7Y29uc3Qgbj1lLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO3JldHVybiBlLmlzQ2xvc2VkKCl8fCF0LmVxdWFscyhuLmdldENvb3JkaW5hdGUoMCkpJiYhdC5lcXVhbHMobi5nZXRDb29yZGluYXRlKG4uc2l6ZSgpLTEpKT9VZS5pc09uTGluZSh0LG4pP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SOlF0LkJPVU5EQVJZfWxvY2F0ZUluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBRdC5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxuKTtpZihzPT09UXQuRVhURVJJT1IpcmV0dXJuIFF0LkVYVEVSSU9SO2lmKHM9PT1RdC5CT1VOREFSWSlyZXR1cm4gUXQuQk9VTkRBUlk7Zm9yKGxldCBuPTA7bjxlLmdldE51bUludGVyaW9yUmluZygpO24rKyl7Y29uc3Qgcz1lLmdldEludGVyaW9yUmluZ04obiksaT10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxzKTtpZihpPT09UXQuSU5URVJJT1IpcmV0dXJuIFF0LkVYVEVSSU9SO2lmKGk9PT1RdC5CT1VOREFSWSlyZXR1cm4gUXQuQk9VTkRBUll9cmV0dXJuIFF0LklOVEVSSU9SfWxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9RdC5FWFRFUklPUjplIGluc3RhbmNlb2YgSj90aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LGUpOmUgaW5zdGFuY2VvZiBpdD90aGlzLmxvY2F0ZUluUG9seWdvbih0LGUpOih0aGlzLl9pc0luPSExLHRoaXMuX251bUJvdW5kYXJpZXM9MCx0aGlzLmNvbXB1dGVMb2NhdGlvbih0LGUpLHRoaXMuX2JvdW5kYXJ5UnVsZS5pc0luQm91bmRhcnkodGhpcy5fbnVtQm91bmRhcmllcyk/UXQuQk9VTkRBUlk6dGhpcy5fbnVtQm91bmRhcmllcz4wfHx0aGlzLl9pc0luP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SKX19Y2xhc3MgeW57Y29uc3RydWN0b3IoKXt5bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dD1udWxsLHRoaXMuX2V4dHJlbWFsUHRzPW51bGwsdGhpcy5fY2VudHJlPW51bGwsdGhpcy5fcmFkaXVzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXQ9dH1zdGF0aWMgZmFydGhlc3RQb2ludHModCl7Y29uc3QgZT10WzBdLmRpc3RhbmNlKHRbMV0pLG49dFsxXS5kaXN0YW5jZSh0WzJdKSxzPXRbMl0uZGlzdGFuY2UodFswXSk7cmV0dXJuIGU+PW4mJmU+PXM/W3RbMF0sdFsxXV06bj49ZSYmbj49cz9bdFsxXSx0WzJdXTpbdFsyXSx0WzBdXX1zdGF0aWMgcG9pbnRXaXRNaW5BbmdsZVdpdGhYKHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz1udWxsO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCByPXRbaV07aWYocj09PWUpY29udGludWU7Y29uc3Qgbz1yLngtZS54O2xldCBsPXIueS1lLnk7bDwwJiYobD0tbCk7Y29uc3QgYT1sL01hdGguc3FydChvKm8rbCpsKTthPG4mJihuPWEscz1yKX1yZXR1cm4gc31zdGF0aWMgbG93ZXN0UG9pbnQodCl7bGV0IGU9dFswXTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl0W25dLnk8ZS55JiYoZT10W25dKTtyZXR1cm4gZX1zdGF0aWMgcG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudCh0LGUsbil7bGV0IHM9ci5NQVhfVkFMVUUsaT1udWxsO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBvPXRbcl07aWYobz09PWUpY29udGludWU7aWYobz09PW4pY29udGludWU7Y29uc3QgbD0kdC5hbmdsZUJldHdlZW4oZSxvLG4pO2w8cyYmKHM9bCxpPW8pfXJldHVybiBpfWdldFJhZGl1cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9yYWRpdXN9Z2V0RGlhbWV0ZXIoKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKX1jb25zdCB0PXRoaXMuX2V4dHJlbWFsUHRzWzBdLGU9dGhpcy5fZXh0cmVtYWxQdHNbMV07cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX1nZXRFeHRyZW1hbFBvaW50cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0c31jb21wdXRlQ2lyY2xlUG9pbnRzKCl7aWYodGhpcy5faW5wdXQuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO2lmKDE9PT10aGlzLl9pbnB1dC5nZXROdW1Qb2ludHMoKSl7Y29uc3QgdD10aGlzLl9pbnB1dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IG0odFswXSldLG51bGx9Y29uc3QgdD10aGlzLl9pbnB1dC5jb252ZXhIdWxsKCkuZ2V0Q29vcmRpbmF0ZXMoKTtsZXQgZT10O2lmKHRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSkmJihlPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpLGR0LmNvcHlEZWVwKHQsMCxlLDAsdC5sZW5ndGgtMSkpLGUubGVuZ3RoPD0yKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1kdC5jb3B5RGVlcChlKSxudWxsO2xldCBuPXluLmxvd2VzdFBvaW50KGUpLHM9eW4ucG9pbnRXaXRNaW5BbmdsZVdpdGhYKGUsbik7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHQ9eW4ucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudChlLG4scyk7aWYoJHQuaXNPYnR1c2Uobix0LHMpKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IG0obiksbmV3IG0ocyldLG51bGw7aWYoJHQuaXNPYnR1c2UodCxuLHMpKW49dDtlbHNle2lmKCEkdC5pc09idHVzZSh0LHMsbikpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgbShuKSxuZXcgbShzKSxuZXcgbSh0KV0sbnVsbDtzPXR9fWcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJMb2dpYyBmYWlsdXJlIGluIE1pbmltdW0gQm91bmRpbmcgQ2lyY2xlIGFsZ29yaXRobSFcIil9Y29tcHV0ZSgpe2lmKG51bGwhPT10aGlzLl9leHRyZW1hbFB0cylyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDaXJjbGVQb2ludHMoKSx0aGlzLmNvbXB1dGVDZW50cmUoKSxudWxsIT09dGhpcy5fY2VudHJlJiYodGhpcy5fcmFkaXVzPXRoaXMuX2NlbnRyZS5kaXN0YW5jZSh0aGlzLl9leHRyZW1hbFB0c1swXSkpfWdldENpcmNsZSgpe2lmKHRoaXMuY29tcHV0ZSgpLG51bGw9PT10aGlzLl9jZW50cmUpcmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKCk7Y29uc3QgdD10aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKTtyZXR1cm4gMD09PXRoaXMuX3JhZGl1cz90OnQuYnVmZmVyKHRoaXMuX3JhZGl1cyl9Z2V0Q2VudHJlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX2NlbnRyZX1nZXRNYXhpbXVtRGlhbWV0ZXIoKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKTtjYXNlIDI6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLl9leHRyZW1hbFB0c1swXSx0aGlzLl9leHRyZW1hbFB0c1sxXV0pO2RlZmF1bHQ6Y29uc3QgdD15bi5mYXJ0aGVzdFBvaW50cyh0aGlzLl9leHRyZW1hbFB0cyk7cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQpfX1jb21wdXRlQ2VudHJlKCl7c3dpdGNoKHRoaXMuX2V4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnRoaXMuX2NlbnRyZT1udWxsO2JyZWFrO2Nhc2UgMTp0aGlzLl9jZW50cmU9dGhpcy5fZXh0cmVtYWxQdHNbMF07YnJlYWs7Y2FzZSAyOnRoaXMuX2NlbnRyZT1uZXcgbSgodGhpcy5fZXh0cmVtYWxQdHNbMF0ueCt0aGlzLl9leHRyZW1hbFB0c1sxXS54KS8yLCh0aGlzLl9leHRyZW1hbFB0c1swXS55K3RoaXMuX2V4dHJlbWFsUHRzWzFdLnkpLzIpO2JyZWFrO2Nhc2UgMzp0aGlzLl9jZW50cmU9bmUuY2lyY3VtY2VudHJlKHRoaXMuX2V4dHJlbWFsUHRzWzBdLHRoaXMuX2V4dHJlbWFsUHRzWzFdLHRoaXMuX2V4dHJlbWFsUHRzWzJdKX19fWNsYXNzIHhue2NvbnN0cnVjdG9yKCl7eG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5faXNDb252ZXg9bnVsbCx0aGlzLl9jb252ZXhIdWxsUHRzPW51bGwsdGhpcy5fbWluQmFzZVNlZz1uZXcgS3QsdGhpcy5fbWluV2lkdGhQdD1udWxsLHRoaXMuX21pblB0SW5kZXg9bnVsbCx0aGlzLl9taW5XaWR0aD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt4bi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsITEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2lzQ29udmV4PWV9fXN0YXRpYyBuZXh0SW5kZXgodCxlKXtyZXR1cm4rK2U+PXQubGVuZ3RoJiYoZT0wKSxlfXN0YXRpYyBjb21wdXRlQyh0LGUsbil7cmV0dXJuIHQqbi55LWUqbi54fXN0YXRpYyBnZXRNaW5pbXVtRGlhbWV0ZXIodCl7cmV0dXJuIG5ldyB4bih0KS5nZXREaWFtZXRlcigpfXN0YXRpYyBnZXRNaW5pbXVtUmVjdGFuZ2xlKHQpe3JldHVybiBuZXcgeG4odCkuZ2V0TWluaW11bVJlY3RhbmdsZSgpfXN0YXRpYyBjb21wdXRlU2VnbWVudEZvckxpbmUodCxlLG4pe2xldCBzPW51bGwsaT1udWxsO3JldHVybiBNYXRoLmFicyhlKT5NYXRoLmFicyh0KT8ocz1uZXcgbSgwLG4vZSksaT1uZXcgbSgxLG4vZS10L2UpKToocz1uZXcgbShuL3QsMCksaT1uZXcgbShuL3QtZS90LDEpKSxuZXcgS3QocyxpKX1nZXRXaWR0aENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGhQdH1nZXRTdXBwb3J0aW5nU2VnbWVudCgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMuX21pbkJhc2VTZWcucDAsdGhpcy5fbWluQmFzZVNlZy5wMV0pfWdldERpYW1ldGVyKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksbnVsbD09PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wcm9qZWN0KHRoaXMuX21pbldpZHRoUHQpO3JldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsdGhpcy5fbWluV2lkdGhQdF0pfWNvbXB1dGVXaWR0aENvbnZleCh0KXt0aGlzLl9jb252ZXhIdWxsUHRzPXQgaW5zdGFuY2VvZiBpdD90LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCk6dC5nZXRDb29yZGluYXRlcygpLDA9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluQmFzZVNlZz1udWxsKToxPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDA9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAxPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0pOjI9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aHx8Mz09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAwPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMT10aGlzLl9jb252ZXhIdWxsUHRzWzFdKTp0aGlzLmNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodGhpcy5fY29udmV4SHVsbFB0cyl9Y29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0KXt0aGlzLl9taW5XaWR0aD1yLk1BWF9WQUxVRTtsZXQgZT0xO2NvbnN0IG49bmV3IEt0O2ZvcihsZXQgcz0wO3M8dC5sZW5ndGgtMTtzKyspbi5wMD10W3NdLG4ucDE9dFtzKzFdLGU9dGhpcy5maW5kTWF4UGVycERpc3RhbmNlKHQsbixlKX1jb21wdXRlTWluaW11bURpYW1ldGVyKCl7aWYobnVsbCE9PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIG51bGw7aWYodGhpcy5faXNDb252ZXgpdGhpcy5jb21wdXRlV2lkdGhDb252ZXgodGhpcy5faW5wdXRHZW9tKTtlbHNle2NvbnN0IHQ9bmV3IHNuKHRoaXMuX2lucHV0R2VvbSkuZ2V0Q29udmV4SHVsbCgpO3RoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHQpfX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGh9ZmluZE1heFBlcnBEaXN0YW5jZSh0LGUsbil7bGV0IHM9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtuXSksaT1zLHI9bixvPXI7Zm9yKDtpPj1zOylzPWkscj1vLG89eG4ubmV4dEluZGV4KHQsciksaT1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W29dKTtyZXR1cm4gczx0aGlzLl9taW5XaWR0aCYmKHRoaXMuX21pblB0SW5kZXg9cix0aGlzLl9taW5XaWR0aD1zLHRoaXMuX21pbldpZHRoUHQ9dFt0aGlzLl9taW5QdEluZGV4XSx0aGlzLl9taW5CYXNlU2VnPW5ldyBLdChlKSkscn1nZXRNaW5pbXVtUmVjdGFuZ2xlKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksMD09PXRoaXMuX21pbldpZHRoKXJldHVybiB0aGlzLl9taW5CYXNlU2VnLnAwLmVxdWFsczJEKHRoaXMuX21pbkJhc2VTZWcucDEpP3RoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fbWluQmFzZVNlZy5wMCk6dGhpcy5fbWluQmFzZVNlZy50b0dlb21ldHJ5KHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wMS54LXRoaXMuX21pbkJhc2VTZWcucDAueCxlPXRoaXMuX21pbkJhc2VTZWcucDEueS10aGlzLl9taW5CYXNlU2VnLnAwLnk7bGV0IG49ci5NQVhfVkFMVUUscz0tci5NQVhfVkFMVUUsaT1yLk1BWF9WQUxVRSxvPS1yLk1BWF9WQUxVRTtmb3IobGV0IHI9MDtyPHRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoO3IrKyl7Y29uc3QgbD14bi5jb21wdXRlQyh0LGUsdGhpcy5fY29udmV4SHVsbFB0c1tyXSk7bD5zJiYocz1sKSxsPG4mJihuPWwpO2NvbnN0IGE9eG4uY29tcHV0ZUMoLWUsdCx0aGlzLl9jb252ZXhIdWxsUHRzW3JdKTthPm8mJihvPWEpLGE8aSYmKGk9YSl9Y29uc3QgbD14bi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsbyksYT14bi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsaSksYz14bi5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxzKSxoPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LG4pLHU9Yy5saW5lSW50ZXJzZWN0aW9uKGwpLGc9aC5saW5lSW50ZXJzZWN0aW9uKGwpLGQ9aC5saW5lSW50ZXJzZWN0aW9uKGEpLF89Yy5saW5lSW50ZXJzZWN0aW9uKGEpLHA9dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKFt1LGcsZCxfLHVdKTtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKHApfX12YXIgRW49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGlzdGFuY2U6YmUsbG9jYXRlOmplLG1hdGNoOkplLEFuZ2xlOiR0LEFyZWE6ZXQsQ2VudHJvaWQ6JGUsQ29udmV4SHVsbDpzbixEaXN0YW5jZTpWLEludGVyaW9yUG9pbnRBcmVhOm9uLEludGVyaW9yUG9pbnRMaW5lOmhuLEludGVyaW9yUG9pbnRQb2ludDp1bixMZW5ndGg6SCxPcmllbnRhdGlvbjpHLFBvaW50TG9jYXRpb246VWUsUG9pbnRMb2NhdG9yOmZuLFJvYnVzdExpbmVJbnRlcnNlY3RvcjpqdCxNaW5pbXVtQm91bmRpbmdDaXJjbGU6eW4sTWluaW11bURpYW1ldGVyOnhufSk7Y2xhc3MgSW57Y29uc3RydWN0b3IoKXtJbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBkZW5zaWZ5UG9pbnRzKHQsZSxuKXtjb25zdCBzPW5ldyBLdCxpPW5ldyBSO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGgtMTtyKyspe3MucDA9dFtyXSxzLnAxPXRbcisxXSxpLmFkZChzLnAwLCExKTtjb25zdCBvPXMuZ2V0TGVuZ3RoKCksbD1NYXRoLnRydW5jKG8vZSkrMTtpZihsPjEpe2NvbnN0IHQ9by9sO2ZvcihsZXQgZT0xO2U8bDtlKyspe2NvbnN0IHI9ZSp0L28sbD1zLnBvaW50QWxvbmcocik7bi5tYWtlUHJlY2lzZShsKSxpLmFkZChsLCExKX19fXJldHVybiBpLmFkZCh0W3QubGVuZ3RoLTFdLCExKSxpLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIGRlbnNpZnkodCxlKXtjb25zdCBuPW5ldyBJbih0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gbmV3IE5uKHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PD0wKXRocm93IG5ldyBzKFwiVG9sZXJhbmNlIG11c3QgYmUgcG9zaXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH19Y2xhc3MgTm4gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIGZ0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1Jbi5kZW5zaWZ5UG9pbnRzKG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSxlLmdldFByZWNpc2lvbk1vZGVsKCkpO3JldHVybiBlIGluc3RhbmNlb2YgSiYmMT09PXMubGVuZ3RoJiYocz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdC5idWZmZXIoMCl9fUluLkRlbnNpZnlUcmFuc2Zvcm1lcj1Objt2YXIgU249T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGVuc2lmaWVyOklufSk7Y2xhc3Mgd257c3RhdGljIGlzTm9ydGhlcm4odCl7cmV0dXJuIHQ9PT13bi5ORXx8dD09PXduLk5XfXN0YXRpYyBpc09wcG9zaXRlKHQsZSl7aWYodD09PWUpcmV0dXJuITE7cmV0dXJuIDI9PT0odC1lKzQpJTR9c3RhdGljIGNvbW1vbkhhbGZQbGFuZSh0LGUpe2lmKHQ9PT1lKXJldHVybiB0O2lmKDI9PT0odC1lKzQpJTQpcmV0dXJuLTE7Y29uc3Qgbj10PGU/dDplO3JldHVybiAwPT09biYmMz09PSh0PmU/dDplKT8zOm59c3RhdGljIGlzSW5IYWxmUGxhbmUodCxlKXtyZXR1cm4gZT09PXduLlNFP3Q9PT13bi5TRXx8dD09PXduLlNXOnQ9PT1lfHx0PT09ZSsxfXN0YXRpYyBxdWFkcmFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgcyhcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7cmV0dXJuIHQ+PTA/ZT49MD93bi5ORTp3bi5TRTplPj0wP3duLk5XOnduLlNXfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihlLng9PT10LngmJmUueT09PXQueSl0aHJvdyBuZXcgcyhcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrdCk7cmV0dXJuIGUueD49dC54P2UueT49dC55P3duLk5FOnduLlNFOmUueT49dC55P3duLk5XOnduLlNXfX19d24uTkU9MCx3bi5OVz0xLHduLlNXPTIsd24uU0U9MztjbGFzcyBDbntjb25zdHJ1Y3Rvcigpe0NuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX29yaWc9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZz10fXN0YXRpYyBjcmVhdGUodCxlKXtjb25zdCBuPW5ldyBDbih0KSxzPW5ldyBDbihlKTtyZXR1cm4gbi5saW5rKHMpLG59ZmluZCh0KXtsZXQgZT10aGlzO2Rve2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKGUuZGVzdCgpLmVxdWFsczJEKHQpKXJldHVybiBlO2U9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gbnVsbH1kZXN0KCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZ31pc0VkZ2VzU29ydGVkKCl7Y29uc3QgdD10aGlzLmZpbmRMb3dlc3QoKTtsZXQgZT10O2Rve2NvbnN0IG49ZS5vTmV4dCgpO2lmKG49PT10KWJyZWFrO2lmKCEobi5jb21wYXJlVG8oZSk+MCkpcmV0dXJuITE7ZT1ufXdoaWxlKGUhPT10KTtyZXR1cm4hMH1vTmV4dCgpe3JldHVybiB0aGlzLl9zeW0uX25leHR9ZGlyZWN0aW9uWSgpe3JldHVybiB0aGlzLmRpcmVjdGlvblB0KCkuZ2V0WSgpLXRoaXMuX29yaWcuZ2V0WSgpfWluc2VydCh0KXtpZih0aGlzLm9OZXh0KCk9PT10aGlzKXJldHVybiB0aGlzLmluc2VydEFmdGVyKHQpLG51bGw7dGhpcy5pbnNlcnRpb25FZGdlKHQpLmluc2VydEFmdGVyKHQpfWluc2VydEFmdGVyKHQpe2cuZXF1YWxzKHRoaXMuX29yaWcsdC5vcmlnKCkpO2NvbnN0IGU9dGhpcy5vTmV4dCgpO3RoaXMuX3N5bS5zZXROZXh0KHQpLHQuc3ltKCkuc2V0TmV4dChlKX1kZWdyZWUoKXtsZXQgdD0wLGU9dGhpcztkb3t0KyssZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiB0fWVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX29yaWcuZXF1YWxzMkQodCkmJnRoaXMuX3N5bS5fb3JpZy5lcXVhbHMoZSl9fWZpbmRMb3dlc3QoKXtsZXQgdD10aGlzLGU9dGhpcy5vTmV4dCgpO2Rve2UuY29tcGFyZVRvKHQpPDAmJih0PWUpLGU9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gdH1kaXJlY3Rpb25QdCgpe3JldHVybiB0aGlzLmRlc3QoKX1zeW0oKXtyZXR1cm4gdGhpcy5fc3ltfXByZXYoKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfWNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKHQpe2NvbnN0IGU9dGhpcy5kaXJlY3Rpb25YKCksbj10aGlzLmRpcmVjdGlvblkoKSxzPXQuZGlyZWN0aW9uWCgpLGk9dC5kaXJlY3Rpb25ZKCk7aWYoZT09PXMmJm49PT1pKXJldHVybiAwO2NvbnN0IHI9d24ucXVhZHJhbnQoZSxuKSxvPXduLnF1YWRyYW50KHMsaSk7aWYocj5vKXJldHVybiAxO2lmKHI8bylyZXR1cm4tMTtjb25zdCBsPXRoaXMuZGlyZWN0aW9uUHQoKSxhPXQuZGlyZWN0aW9uUHQoKTtyZXR1cm4gRy5pbmRleCh0Ll9vcmlnLGEsbCl9cHJldk5vZGUoKXtsZXQgdD10aGlzO2Zvcig7Mj09PXQuZGVncmVlKCk7KWlmKHQ9dC5wcmV2KCksdD09PXRoaXMpcmV0dXJuIG51bGw7cmV0dXJuIHR9ZGlyZWN0aW9uWCgpe3JldHVybiB0aGlzLmRpcmVjdGlvblB0KCkuZ2V0WCgpLXRoaXMuX29yaWcuZ2V0WCgpfWluc2VydGlvbkVkZ2UodCl7bGV0IGU9dGhpcztkb3tjb25zdCBuPWUub05leHQoKTtpZihuLmNvbXBhcmVUbyhlKT4wJiZ0LmNvbXBhcmVUbyhlKT49MCYmdC5jb21wYXJlVG8obik8PTApcmV0dXJuIGU7aWYobi5jb21wYXJlVG8oZSk8PTAmJih0LmNvbXBhcmVUbyhuKTw9MHx8dC5jb21wYXJlVG8oZSk+PTApKXJldHVybiBlO2U9bn13aGlsZShlIT09dGhpcyk7cmV0dXJuIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSxudWxsfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZUFuZ3VsYXJEaXJlY3Rpb24oZSl9dG9TdHJpbmdOb2RlKCl7Y29uc3QgdD10aGlzLm9yaWcoKSxlPSh0aGlzLmRlc3QoKSxuZXcgX3QpO2UuYXBwZW5kKFwiTm9kZSggXCIrV3QuZm9ybWF0KHQpK1wiIClcXG5cIik7bGV0IG49dGhpcztkb3tlLmFwcGVuZChcIiAgLT4gXCIrbiksZS5hcHBlbmQoXCJcXG5cIiksbj1uLm9OZXh0KCl9d2hpbGUobiE9PXRoaXMpO3JldHVybiBlLnRvU3RyaW5nKCl9bGluayh0KXt0aGlzLnNldFN5bSh0KSx0LnNldFN5bSh0aGlzKSx0aGlzLnNldE5leHQodCksdC5zZXROZXh0KHRoaXMpfW5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1zZXRTeW0odCl7dGhpcy5fc3ltPXR9b3JpZygpe3JldHVybiB0aGlzLl9vcmlnfXRvU3RyaW5nKCl7cmV0dXJuXCJIRShcIit0aGlzLl9vcmlnLngrXCIgXCIrdGhpcy5fb3JpZy55K1wiLCBcIit0aGlzLl9zeW0uX29yaWcueCtcIiBcIit0aGlzLl9zeW0uX29yaWcueStcIilcIn10b1N0cmluZ05vZGVFZGdlKCl7cmV0dXJuXCIgIC0+IChcIitXdC5mb3JtYXQodGhpcy5kZXN0KCkpfXNldE5leHQodCl7dGhpcy5fbmV4dD10fX1jbGFzcyBMbiBleHRlbmRzIENue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxMbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc01hcmtlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTtDbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfXN0YXRpYyBzZXRNYXJrQm90aCh0LGUpe3Quc2V0TWFyayhlKSx0LnN5bSgpLnNldE1hcmsoZSl9c3RhdGljIGlzTWFya2VkKHQpe3JldHVybiB0LmlzTWFya2VkKCl9c3RhdGljIHNldE1hcmsodCxlKXt0LnNldE1hcmsoZSl9c3RhdGljIG1hcmtCb3RoKHQpe3QubWFyaygpLHQuc3ltKCkubWFyaygpfXN0YXRpYyBtYXJrKHQpe3QubWFyaygpfW1hcmsoKXt0aGlzLl9pc01hcmtlZD0hMH1zZXRNYXJrKHQpe3RoaXMuX2lzTWFya2VkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9fWNsYXNzIFRue2NvbnN0cnVjdG9yKCl7VG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdmVydGV4TWFwPW5ldyBJdH1zdGF0aWMgaXNWYWxpZEVkZ2UodCxlKXtyZXR1cm4gMCE9PWUuY29tcGFyZVRvKHQpfWluc2VydCh0LGUsbil7Y29uc3Qgcz10aGlzLmNyZWF0ZSh0LGUpO251bGwhPT1uP24uaW5zZXJ0KHMpOnRoaXMuX3ZlcnRleE1hcC5wdXQodCxzKTtjb25zdCBpPXRoaXMuX3ZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1pP2kuaW5zZXJ0KHMuc3ltKCkpOnRoaXMuX3ZlcnRleE1hcC5wdXQoZSxzLnN5bSgpKSxzfWNyZWF0ZSh0LGUpe2NvbnN0IG49dGhpcy5jcmVhdGVFZGdlKHQpLHM9dGhpcy5jcmVhdGVFZGdlKGUpO3JldHVybiBuLmxpbmsocyksbn1jcmVhdGVFZGdlKHQpe3JldHVybiBuZXcgQ24odCl9YWRkRWRnZSh0LGUpe2lmKCFUbi5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5fdmVydGV4TWFwLmdldCh0KTtsZXQgcz1udWxsO2lmKG51bGwhPT1uJiYocz1uLmZpbmQoZSkpLG51bGwhPT1zKXJldHVybiBzO3JldHVybiB0aGlzLmluc2VydCh0LGUsbil9Z2V0VmVydGV4RWRnZXMoKXtyZXR1cm4gdGhpcy5fdmVydGV4TWFwLnZhbHVlcygpfWZpbmRFZGdlKHQsZSl7Y29uc3Qgbj10aGlzLl92ZXJ0ZXhNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09bj9udWxsOm4uZmluZChlKX19Y2xhc3MgUm4gZXh0ZW5kcyBMbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNTdGFydD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTtMbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfXNldFN0YXJ0KCl7dGhpcy5faXNTdGFydD0hMH1pc1N0YXJ0KCl7cmV0dXJuIHRoaXMuX2lzU3RhcnR9fWNsYXNzIFBuIGV4dGVuZHMgVG57Y29uc3RydWN0b3IoKXtzdXBlcigpfWNyZWF0ZUVkZ2UodCl7cmV0dXJuIG5ldyBSbih0KX19Y2xhc3MgT257Y29uc3RydWN0b3IoKXtPbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZXN1bHQ9bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9saW5lcz1uZXcgTCx0aGlzLl9ub2RlRWRnZVN0YWNrPW5ldyBlbix0aGlzLl9yaW5nU3RhcnRFZGdlPW51bGwsdGhpcy5fZ3JhcGg9bmV3IFBufXN0YXRpYyBkaXNzb2x2ZSh0KXtjb25zdCBlPW5ldyBPbjtyZXR1cm4gZS5hZGQodCksZS5nZXRSZXN1bHQoKX1hZGRMaW5lKHQpe3RoaXMuX2xpbmVzLmFkZCh0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC50b0Nvb3JkaW5hdGVBcnJheSgpKSl9dXBkYXRlUmluZ1N0YXJ0RWRnZSh0KXtyZXR1cm4gdC5pc1N0YXJ0KCl8fCh0PXQuc3ltKCkpLmlzU3RhcnQoKT9udWxsPT09dGhpcy5fcmluZ1N0YXJ0RWRnZT8odGhpcy5fcmluZ1N0YXJ0RWRnZT10LG51bGwpOnZvaWQodC5vcmlnKCkuY29tcGFyZVRvKHRoaXMuX3JpbmdTdGFydEVkZ2Uub3JpZygpKTwwJiYodGhpcy5fcmluZ1N0YXJ0RWRnZT10KSk6bnVsbH1nZXRSZXN1bHQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jlc3VsdCYmdGhpcy5jb21wdXRlUmVzdWx0KCksdGhpcy5fcmVzdWx0fXByb2Nlc3ModCl7bGV0IGU9dC5wcmV2Tm9kZSgpO251bGw9PT1lJiYoZT10KSx0aGlzLnN0YWNrRWRnZXMoZSksdGhpcy5idWlsZExpbmVzKCl9YnVpbGRSaW5nKHQpe2NvbnN0IGU9bmV3IFI7bGV0IG49dDtmb3IoZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocz09PXQpYnJlYWs7ZS5hZGQocy5vcmlnKCkuY29weSgpLCExKSxuPXN9ZS5hZGQobi5kZXN0KCkuY29weSgpLCExKSx0aGlzLmFkZExpbmUoZSl9YnVpbGRMaW5lKHQpe2NvbnN0IGU9bmV3IFI7bGV0IG49dDtmb3IodGhpcy5fcmluZ1N0YXJ0RWRnZT1udWxsLExuLm1hcmtCb3RoKG4pLGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt0aGlzLnVwZGF0ZVJpbmdTdGFydEVkZ2Uobik7Y29uc3Qgcz1uLm5leHQoKTtpZihzPT09dClyZXR1cm4gdGhpcy5idWlsZFJpbmcodGhpcy5fcmluZ1N0YXJ0RWRnZSksbnVsbDtlLmFkZChzLm9yaWcoKS5jb3B5KCksITEpLG49cyxMbi5tYXJrQm90aChuKX1lLmFkZChuLmRlc3QoKS5jbG9uZSgpLCExKSx0aGlzLnN0YWNrRWRnZXMobi5zeW0oKSksdGhpcy5hZGRMaW5lKGUpfXN0YWNrRWRnZXModCl7bGV0IGU9dDtkb3tMbi5pc01hcmtlZChlKXx8dGhpcy5fbm9kZUVkZ2VTdGFjay5hZGQoZSksZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXQpfWNvbXB1dGVSZXN1bHQoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0VmVydGV4RWRnZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtMbi5pc01hcmtlZChlKXx8dGhpcy5wcm9jZXNzKGUpfXRoaXMuX3Jlc3VsdD10aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpfWJ1aWxkTGluZXMoKXtmb3IoOyF0aGlzLl9ub2RlRWRnZVN0YWNrLmVtcHR5KCk7KXtjb25zdCB0PXRoaXMuX25vZGVFZGdlU3RhY2sucG9wKCk7TG4uaXNNYXJrZWQodCl8fHRoaXMuYnVpbGRMaW5lKHQpfX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2FyZ3VtZW50c1swXS5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgSiYmdGhpcy5hZGQodCl9fSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEope2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2xldCBuPSExO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPXRoaXMuX2dyYXBoLmFkZEVkZ2UoZS5nZXRDb29yZGluYXRlKHQtMSksZS5nZXRDb29yZGluYXRlKHQpKTtudWxsIT09cyYmKG58fChzLnNldFN0YXJ0KCksbj0hMCkpfX19fXZhciB2bj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMaW5lRGlzc29sdmVyOk9ufSk7Y2xhc3MgTW57c3RhdGljIG9wcG9zaXRlKHQpe3JldHVybiB0PT09TW4uTEVGVD9Nbi5SSUdIVDp0PT09TW4uUklHSFQ/TW4uTEVGVDp0fX1Nbi5PTj0wLE1uLkxFRlQ9MSxNbi5SSUdIVD0yO2NsYXNzIGJue2NvbnN0cnVjdG9yKCl7Ym4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5tY2U9bnVsbCx0aGlzLmNoYWluSW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm1jZT10LHRoaXMuY2hhaW5JbmRleD1lfWNvbXB1dGVJbnRlcnNlY3Rpb25zKHQsZSl7dGhpcy5tY2UuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLmNoYWluSW5kZXgsdC5tY2UsdC5jaGFpbkluZGV4LGUpfX1jbGFzcyBEbntjb25zdHJ1Y3Rvcigpe0RuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xhYmVsPW51bGwsdGhpcy5feFZhbHVlPW51bGwsdGhpcy5fZXZlbnRUeXBlPW51bGwsdGhpcy5faW5zZXJ0RXZlbnQ9bnVsbCx0aGlzLl9kZWxldGVFdmVudEluZGV4PW51bGwsdGhpcy5fb2JqPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2V2ZW50VHlwZT1Ebi5ERUxFVEUsdGhpcy5feFZhbHVlPXQsdGhpcy5faW5zZXJ0RXZlbnQ9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ldmVudFR5cGU9RG4uSU5TRVJULHRoaXMuX2xhYmVsPXQsdGhpcy5feFZhbHVlPWUsdGhpcy5fb2JqPW59fWlzRGVsZXRlKCl7cmV0dXJuIHRoaXMuX2V2ZW50VHlwZT09PURuLkRFTEVURX1zZXREZWxldGVFdmVudEluZGV4KHQpe3RoaXMuX2RlbGV0ZUV2ZW50SW5kZXg9dH1nZXRPYmplY3QoKXtyZXR1cm4gdGhpcy5fb2JqfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX3hWYWx1ZTxlLl94VmFsdWU/LTE6dGhpcy5feFZhbHVlPmUuX3hWYWx1ZT8xOnRoaXMuX2V2ZW50VHlwZTxlLl9ldmVudFR5cGU/LTE6dGhpcy5fZXZlbnRUeXBlPmUuX2V2ZW50VHlwZT8xOjB9Z2V0SW5zZXJ0RXZlbnQoKXtyZXR1cm4gdGhpcy5faW5zZXJ0RXZlbnR9aXNJbnNlcnQoKXtyZXR1cm4gdGhpcy5fZXZlbnRUeXBlPT09RG4uSU5TRVJUfWlzU2FtZUxhYmVsKHQpe3JldHVybiBudWxsIT09dGhpcy5fbGFiZWwmJnRoaXMuX2xhYmVsPT09dC5fbGFiZWx9Z2V0RGVsZXRlRXZlbnRJbmRleCgpe3JldHVybiB0aGlzLl9kZWxldGVFdmVudEluZGV4fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19RG4uSU5TRVJUPTEsRG4uREVMRVRFPTI7Y2xhc3MgQW57Y29uc3RydWN0b3IoKXtBbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5faGFzUHJvcGVyPSExLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSExLHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9pbmNsdWRlUHJvcGVyPW51bGwsdGhpcy5fcmVjb3JkSXNvbGF0ZWQ9bnVsbCx0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb249bnVsbCx0aGlzLl9udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wLHRoaXMuX2JkeU5vZGVzPW51bGwsdGhpcy5faXNEb25lPSExLHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbGk9dCx0aGlzLl9pbmNsdWRlUHJvcGVyPWUsdGhpcy5fcmVjb3JkSXNvbGF0ZWQ9bn1zdGF0aWMgaXNBZGphY2VudFNlZ21lbnRzKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfWlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXtpZih0PT09biYmMT09PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihBbi5pc0FkamFjZW50U2VnbWVudHMoZSxzKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe2NvbnN0IG49dC5nZXROdW1Qb2ludHMoKS0xO2lmKDA9PT1lJiZzPT09bnx8MD09PXMmJmU9PT1uKXJldHVybiEwfX1yZXR1cm4hMX1nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpe3JldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH1zZXRJc0RvbmVJZlByb3BlckludCh0KXt0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50PXR9aGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3J9aXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKS5nZXRDb29yZGluYXRlKCk7aWYodC5pc0ludGVyc2VjdGlvbihlKSlyZXR1cm4hMH1yZXR1cm4hMX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIHRoaXMuX2lzRG9uZX1pc0JvdW5kYXJ5UG9pbnQodCxlKXtyZXR1cm4gbnVsbCE9PWUmJighIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzBdKXx8ISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVsxXSkpfXNldEJvdW5kYXJ5Tm9kZXModCxlKXt0aGlzLl9iZHlOb2Rlcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9iZHlOb2Rlc1swXT10LHRoaXMuX2JkeU5vZGVzWzFdPWV9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5fcmVjb3JkSXNvbGF0ZWQmJih0LnNldElzb2xhdGVkKCExKSxuLnNldElzb2xhdGVkKCExKSksdGhpcy5fbnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLCF0aGlzLl9pbmNsdWRlUHJvcGVyJiZ0aGlzLl9saS5pc1Byb3BlcigpfHwodC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSkpLHRoaXMuX2xpLmlzUHJvcGVyKCkmJih0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkuY29weSgpLHRoaXMuX2hhc1Byb3Blcj0hMCx0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50JiYodGhpcy5faXNEb25lPSEwKSx0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLl9saSx0aGlzLl9iZHlOb2Rlcyl8fCh0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKSl9fWNsYXNzIEZuIGV4dGVuZHMgY2xhc3N7fXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5ldmVudHM9bmV3IEwsdGhpcy5uT3ZlcmxhcHM9bnVsbH1wcmVwYXJlRXZlbnRzKCl7eGUuc29ydCh0aGlzLmV2ZW50cyk7Zm9yKGxldCB0PTA7dDx0aGlzLmV2ZW50cy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuZXZlbnRzLmdldCh0KTtlLmlzRGVsZXRlKCkmJmUuZ2V0SW5zZXJ0RXZlbnQoKS5zZXREZWxldGVFdmVudEluZGV4KHQpfX1jb21wdXRlSW50ZXJzZWN0aW9ucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm5PdmVybGFwcz0wLHRoaXMucHJlcGFyZUV2ZW50cygpO2ZvcihsZXQgZT0wO2U8dGhpcy5ldmVudHMuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10aGlzLmV2ZW50cy5nZXQoZSk7aWYobi5pc0luc2VydCgpJiZ0aGlzLnByb2Nlc3NPdmVybGFwcyhlLG4uZ2V0RGVsZXRlRXZlbnRJbmRleCgpLG4sdCksdC5pc0RvbmUoKSlicmVha319ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFuJiZJKGFyZ3VtZW50c1swXSx3KSYmSShhcmd1bWVudHNbMV0sdykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuYWRkRWRnZXModCx0KSx0aGlzLmFkZEVkZ2VzKGUsZSksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhuKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZJKGFyZ3VtZW50c1swXSx3KSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBbil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdP3RoaXMuYWRkRWRnZXModCxudWxsKTp0aGlzLmFkZEVkZ2VzKHQpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoZSl9fWFkZEVkZ2UodCxlKXtjb25zdCBuPXQuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UoKSxzPW4uZ2V0U3RhcnRJbmRleGVzKCk7Zm9yKGxldCB0PTA7dDxzLmxlbmd0aC0xO3QrKyl7Y29uc3Qgcz1uZXcgYm4obix0KSxpPW5ldyBEbihlLG4uZ2V0TWluWCh0KSxzKTt0aGlzLmV2ZW50cy5hZGQoaSksdGhpcy5ldmVudHMuYWRkKG5ldyBEbihuLmdldE1heFgodCksaSkpfX1wcm9jZXNzT3ZlcmxhcHModCxlLG4scyl7Y29uc3QgaT1uLmdldE9iamVjdCgpO2ZvcihsZXQgcj10O3I8ZTtyKyspe2NvbnN0IHQ9dGhpcy5ldmVudHMuZ2V0KHIpO2lmKHQuaXNJbnNlcnQoKSl7Y29uc3QgZT10LmdldE9iamVjdCgpO24uaXNTYW1lTGFiZWwodCl8fChpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKGUscyksdGhpcy5uT3ZlcmxhcHMrKyl9fX1hZGRFZGdlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkRWRnZShlLGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtmb3IobGV0IGU9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuYWRkRWRnZShuLHQpfX19fWNsYXNzIEdue2NvbnN0cnVjdG9yKCl7R24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5sb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5sZW5ndGgpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQoMSksdGhpcy5sb2NhdGlvbltNbi5PTl09dH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgR24pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaW5pdCh0LmxvY2F0aW9uLmxlbmd0aCksbnVsbCE9PXQpZm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10LmxvY2F0aW9uW2VdfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmluaXQoMyksdGhpcy5sb2NhdGlvbltNbi5PTl09dCx0aGlzLmxvY2F0aW9uW01uLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltNbi5SSUdIVF09bn19c2V0QWxsTG9jYXRpb25zKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09dH1pc051bGwoKXtmb3IobGV0IHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdIT09UXQuTk9ORSlyZXR1cm4hMTtyZXR1cm4hMH1zZXRBbGxMb2NhdGlvbnNJZk51bGwodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PVF0Lk5PTkUmJih0aGlzLmxvY2F0aW9uW2VdPXQpfWlzTGluZSgpe3JldHVybiAxPT09dGhpcy5sb2NhdGlvbi5sZW5ndGh9bWVyZ2UodCl7aWYodC5sb2NhdGlvbi5sZW5ndGg+dGhpcy5sb2NhdGlvbi5sZW5ndGgpe2NvbnN0IHQ9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7dFtNbi5PTl09dGhpcy5sb2NhdGlvbltNbi5PTl0sdFtNbi5MRUZUXT1RdC5OT05FLHRbTW4uUklHSFRdPVF0Lk5PTkUsdGhpcy5sb2NhdGlvbj10fWZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09PT1RdC5OT05FJiZlPHQubG9jYXRpb24ubGVuZ3RoJiYodGhpcy5sb2NhdGlvbltlXT10LmxvY2F0aW9uW2VdKX1nZXRMb2NhdGlvbnMoKXtyZXR1cm4gdGhpcy5sb2NhdGlvbn1mbGlwKCl7aWYodGhpcy5sb2NhdGlvbi5sZW5ndGg8PTEpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLmxvY2F0aW9uW01uLkxFRlRdO3RoaXMubG9jYXRpb25bTW4uTEVGVF09dGhpcy5sb2NhdGlvbltNbi5SSUdIVF0sdGhpcy5sb2NhdGlvbltNbi5SSUdIVF09dH10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHY7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKFF0LnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltNbi5MRUZUXSkpLHQuYXBwZW5kKFF0LnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltNbi5PTl0pKSx0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChRdC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bTW4uUklHSFRdKSksdC50b1N0cmluZygpfXNldExvY2F0aW9ucyh0LGUsbil7dGhpcy5sb2NhdGlvbltNbi5PTl09dCx0aGlzLmxvY2F0aW9uW01uLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltNbi5SSUdIVF09bn1nZXQodCl7cmV0dXJuIHQ8dGhpcy5sb2NhdGlvbi5sZW5ndGg/dGhpcy5sb2NhdGlvblt0XTpRdC5OT05FfWlzQXJlYSgpe3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xfWlzQW55TnVsbCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF09PT1RdC5OT05FKXJldHVybiEwO3JldHVybiExfXNldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TG9jYXRpb24oTW4uT04sdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5sb2NhdGlvblt0XT1lfX1pbml0KHQpe3RoaXMubG9jYXRpb249bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5zZXRBbGxMb2NhdGlvbnMoUXQuTk9ORSl9aXNFcXVhbE9uU2lkZSh0LGUpe3JldHVybiB0aGlzLmxvY2F0aW9uW2VdPT09dC5sb2NhdGlvbltlXX1hbGxQb3NpdGlvbnNFcXVhbCh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKylpZih0aGlzLmxvY2F0aW9uW2VdIT09dClyZXR1cm4hMTtyZXR1cm4hMH19Y2xhc3MgcW57Y29uc3RydWN0b3IoKXtxbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLmVsdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgR24odCksdGhpcy5lbHRbMV09bmV3IEduKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxbil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IEduKHQuZWx0WzBdKSx0aGlzLmVsdFsxXT1uZXcgR24odC5lbHRbMV0pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFswXT1uZXcgR24oUXQuTk9ORSksdGhpcy5lbHRbMV09bmV3IEduKFF0Lk5PTkUpLHRoaXMuZWx0W3RdLnNldExvY2F0aW9uKGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuZWx0WzBdPW5ldyBHbih0LGUsbiksdGhpcy5lbHRbMV09bmV3IEduKHQsZSxuKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmVsdFswXT1uZXcgR24oUXQuTk9ORSxRdC5OT05FLFF0Lk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBHbihRdC5OT05FLFF0Lk5PTkUsUXQuTk9ORSksdGhpcy5lbHRbdF0uc2V0TG9jYXRpb25zKGUsbixzKX19c3RhdGljIHRvTGluZUxhYmVsKHQpe2NvbnN0IGU9bmV3IHFuKFF0Lk5PTkUpO2ZvcihsZXQgbj0wO248MjtuKyspZS5zZXRMb2NhdGlvbihuLHQuZ2V0TG9jYXRpb24obikpO3JldHVybiBlfWdldEdlb21ldHJ5Q291bnQoKXtsZXQgdD0wO3JldHVybiB0aGlzLmVsdFswXS5pc051bGwoKXx8dCsrLHRoaXMuZWx0WzFdLmlzTnVsbCgpfHx0KyssdH1zZXRBbGxMb2NhdGlvbnModCxlKXt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnMoZSl9aXNOdWxsKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc051bGwoKX1zZXRBbGxMb2NhdGlvbnNJZk51bGwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0KSx0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldEFsbExvY2F0aW9uc0lmTnVsbChlKX19aXNMaW5lKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0xpbmUoKX1tZXJnZSh0KXtmb3IobGV0IGU9MDtlPDI7ZSsrKW51bGw9PT10aGlzLmVsdFtlXSYmbnVsbCE9PXQuZWx0W2VdP3RoaXMuZWx0W2VdPW5ldyBHbih0LmVsdFtlXSk6dGhpcy5lbHRbZV0ubWVyZ2UodC5lbHRbZV0pfWZsaXAoKXt0aGlzLmVsdFswXS5mbGlwKCksdGhpcy5lbHRbMV0uZmxpcCgpfWdldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoTW4uT04pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KGUpfX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHY7cmV0dXJuIG51bGwhPT10aGlzLmVsdFswXSYmKHQuYXBwZW5kKFwiQTpcIiksdC5hcHBlbmQodGhpcy5lbHRbMF0udG9TdHJpbmcoKSkpLG51bGwhPT10aGlzLmVsdFsxXSYmKHQuYXBwZW5kKFwiIEI6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzFdLnRvU3RyaW5nKCkpKSx0LnRvU3RyaW5nKCl9aXNBcmVhKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuZWx0WzBdLmlzQXJlYSgpfHx0aGlzLmVsdFsxXS5pc0FyZWEoKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmlzQXJlYSgpfX1pc0FueU51bGwodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzQW55TnVsbCgpfXNldExvY2F0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKE1uLk9OLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKGUsbil9fWlzRXF1YWxPblNpZGUodCxlKXtyZXR1cm4gdGhpcy5lbHRbMF0uaXNFcXVhbE9uU2lkZSh0LmVsdFswXSxlKSYmdGhpcy5lbHRbMV0uaXNFcXVhbE9uU2lkZSh0LmVsdFsxXSxlKX1hbGxQb3NpdGlvbnNFcXVhbCh0LGUpe3JldHVybiB0aGlzLmVsdFt0XS5hbGxQb3NpdGlvbnNFcXVhbChlKX10b0xpbmUodCl7dGhpcy5lbHRbdF0uaXNBcmVhKCkmJih0aGlzLmVsdFt0XT1uZXcgR24odGhpcy5lbHRbdF0ubG9jYXRpb25bMF0pKX19Y2xhc3MgQm57Y29uc3RydWN0b3IoKXtCbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLmRpc3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmNvb3JkPW5ldyBtKHQpLHRoaXMuc2VnbWVudEluZGV4PWUsdGhpcy5kaXN0PW59Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb29yZH1wcmludCh0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCksdC5wcmludGxuKFwiIGRpc3QgPSBcIit0aGlzLmRpc3QpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZShlLnNlZ21lbnRJbmRleCxlLmRpc3QpfWlzRW5kUG9pbnQodCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmMD09PXRoaXMuZGlzdHx8dGhpcy5zZWdtZW50SW5kZXg9PT10fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY29vcmQrXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCtcIiBkaXN0ID0gXCIrdGhpcy5kaXN0fWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuZGlzdH1jb21wYXJlKHQsZSl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PHQ/LTE6dGhpcy5zZWdtZW50SW5kZXg+dD8xOnRoaXMuZGlzdDxlPy0xOnRoaXMuZGlzdD5lPzE6MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIFluIGV4dGVuZHMgeXR7fWZ1bmN0aW9uIFZuKHQpe3JldHVybiBudWxsPT10PzA6dC5jb2xvcn1mdW5jdGlvbiB6bih0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucGFyZW50fWZ1bmN0aW9uIGtuKHQsZSl7bnVsbCE9PXQmJih0LmNvbG9yPWUpfWZ1bmN0aW9uIFhuKHQpe3JldHVybiBudWxsPT10P251bGw6dC5sZWZ0fWZ1bmN0aW9uIFVuKHQpe3JldHVybiBudWxsPT10P251bGw6dC5yaWdodH1jbGFzcyBIbiBleHRlbmRzIFlue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnJvb3RfPW51bGwsdGhpcy5zaXplXz0wfWdldCh0KXtsZXQgZT10aGlzLnJvb3RfO2Zvcig7bnVsbCE9PWU7KXtjb25zdCBuPXQuY29tcGFyZVRvKGUua2V5KTtpZihuPDApZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuIGUudmFsdWU7ZT1lLnJpZ2h0fX1yZXR1cm4gbnVsbH1wdXQodCxlKXtpZihudWxsPT09dGhpcy5yb290XylyZXR1cm4gdGhpcy5yb290Xz17a2V5OnQsdmFsdWU6ZSxsZWZ0Om51bGwscmlnaHQ6bnVsbCxwYXJlbnQ6bnVsbCxjb2xvcjowLGdldFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleSgpe3JldHVybiB0aGlzLmtleX19LHRoaXMuc2l6ZV89MSxudWxsO2xldCBuLHMsaT10aGlzLnJvb3RfO2Rve2lmKG49aSxzPXQuY29tcGFyZVRvKGkua2V5KSxzPDApaT1pLmxlZnQ7ZWxzZXtpZighKHM+MCkpe2NvbnN0IHQ9aS52YWx1ZTtyZXR1cm4gaS52YWx1ZT1lLHR9aT1pLnJpZ2h0fX13aGlsZShudWxsIT09aSk7Y29uc3Qgcj17a2V5OnQsbGVmdDpudWxsLHJpZ2h0Om51bGwsdmFsdWU6ZSxwYXJlbnQ6bixjb2xvcjowLGdldFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleSgpe3JldHVybiB0aGlzLmtleX19O3JldHVybiBzPDA/bi5sZWZ0PXI6bi5yaWdodD1yLHRoaXMuZml4QWZ0ZXJJbnNlcnRpb24ociksdGhpcy5zaXplXysrLG51bGx9Zml4QWZ0ZXJJbnNlcnRpb24odCl7bGV0IGU7Zm9yKHQuY29sb3I9MTtudWxsIT10JiZ0IT09dGhpcy5yb290XyYmMT09PXQucGFyZW50LmNvbG9yOyl6bih0KT09PVhuKHpuKHpuKHQpKSk/KGU9VW4oem4oem4odCkpKSwxPT09Vm4oZSk/KGtuKHpuKHQpLDApLGtuKGUsMCksa24oem4oem4odCkpLDEpLHQ9em4oem4odCkpKToodD09PVVuKHpuKHQpKSYmKHQ9em4odCksdGhpcy5yb3RhdGVMZWZ0KHQpKSxrbih6bih0KSwwKSxrbih6bih6bih0KSksMSksdGhpcy5yb3RhdGVSaWdodCh6bih6bih0KSkpKSk6KGU9WG4oem4oem4odCkpKSwxPT09Vm4oZSk/KGtuKHpuKHQpLDApLGtuKGUsMCksa24oem4oem4odCkpLDEpLHQ9em4oem4odCkpKToodD09PVhuKHpuKHQpKSYmKHQ9em4odCksdGhpcy5yb3RhdGVSaWdodCh0KSksa24oem4odCksMCksa24oem4oem4odCkpLDEpLHRoaXMucm90YXRlTGVmdCh6bih6bih0KSkpKSk7dGhpcy5yb290Xy5jb2xvcj0wfXZhbHVlcygpe2NvbnN0IHQ9bmV3IEw7bGV0IGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUudmFsdWUpO251bGwhPT0oZT1Ibi5zdWNjZXNzb3IoZSkpOyl0LmFkZChlLnZhbHVlKTtyZXR1cm4gdH1lbnRyeVNldCgpe2NvbnN0IHQ9bmV3IHh0O2xldCBlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlKTtudWxsIT09KGU9SG4uc3VjY2Vzc29yKGUpKTspdC5hZGQoZSk7cmV0dXJuIHR9cm90YXRlTGVmdCh0KXtpZihudWxsIT10KXtjb25zdCBlPXQucmlnaHQ7dC5yaWdodD1lLmxlZnQsbnVsbCE9ZS5sZWZ0JiYoZS5sZWZ0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQubGVmdD09PXQ/dC5wYXJlbnQubGVmdD1lOnQucGFyZW50LnJpZ2h0PWUsZS5sZWZ0PXQsdC5wYXJlbnQ9ZX19cm90YXRlUmlnaHQodCl7aWYobnVsbCE9dCl7Y29uc3QgZT10LmxlZnQ7dC5sZWZ0PWUucmlnaHQsbnVsbCE9ZS5yaWdodCYmKGUucmlnaHQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5yaWdodD09PXQ/dC5wYXJlbnQucmlnaHQ9ZTp0LnBhcmVudC5sZWZ0PWUsZS5yaWdodD10LHQucGFyZW50PWV9fWdldEZpcnN0RW50cnkoKXtsZXQgdD10aGlzLnJvb3RfO2lmKG51bGwhPXQpZm9yKDtudWxsIT10LmxlZnQ7KXQ9dC5sZWZ0O3JldHVybiB0fXN0YXRpYyBzdWNjZXNzb3IodCl7bGV0IGU7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7aWYobnVsbCE9PXQucmlnaHQpe2ZvcihlPXQucmlnaHQ7bnVsbCE9PWUubGVmdDspZT1lLmxlZnQ7cmV0dXJuIGV9e2U9dC5wYXJlbnQ7bGV0IG49dDtmb3IoO251bGwhPT1lJiZuPT09ZS5yaWdodDspbj1lLGU9ZS5wYXJlbnQ7cmV0dXJuIGV9fXNpemUoKXtyZXR1cm4gdGhpcy5zaXplX31jb250YWluc0tleSh0KXtsZXQgZT10aGlzLnJvb3RfO2Zvcig7bnVsbCE9PWU7KXtjb25zdCBuPXQuY29tcGFyZVRvKGUua2V5KTtpZihuPDApZT1lLmxlZnQ7ZWxzZXtpZighKG4+MCkpcmV0dXJuITA7ZT1lLnJpZ2h0fX1yZXR1cm4hMX19Y2xhc3MgV257Y29uc3RydWN0b3IoKXtXbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2RlTWFwPW5ldyBIbix0aGlzLmVkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1hZGRTcGxpdEVkZ2VzKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLHMpO3QuYWRkKGkpLG49c319YWRkRW5kcG9pbnRzKCl7Y29uc3QgdD10aGlzLmVkZ2UucHRzLmxlbmd0aC0xO3RoaXMuYWRkKHRoaXMuZWRnZS5wdHNbMF0sMCwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW3RdLHQsMCl9Y3JlYXRlU3BsaXRFZGdlKHQsZSl7bGV0IG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMjtjb25zdCBzPXRoaXMuZWRnZS5wdHNbZS5zZWdtZW50SW5kZXhdLGk9ZS5kaXN0PjB8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBtKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5lZGdlLnB0c1tuXTtyZXR1cm4gaSYmKHJbb109ZS5jb29yZCksbmV3ICRuKHIsbmV3IHFuKHRoaXMuZWRnZS5fbGFiZWwpKX1hZGQodCxlLG4pe2NvbnN0IHM9bmV3IEJuKHQsZSxuKSxpPXRoaXMuX25vZGVNYXAuZ2V0KHMpO3JldHVybiBudWxsIT09aT9pOih0aGlzLl9ub2RlTWFwLnB1dChzLHMpLHMpfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtpZihlLm5leHQoKS5jb29yZC5lcXVhbHModCkpcmV0dXJuITB9cmV0dXJuITF9fWNsYXNzIFpue2NvbnN0cnVjdG9yKCl7Wm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGF0YT1udWxsLHRoaXMuX3NpemU9MCwwPT09YXJndW1lbnRzLmxlbmd0aClabi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDEwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9kYXRhPW5ldyBBcnJheSh0KS5maWxsKG51bGwpfX1zaXplKCl7cmV0dXJuIHRoaXMuX3NpemV9YWRkQWxsKHQpe3JldHVybiBudWxsPT09dHx8MD09PXQubGVuZ3RoP251bGw6KHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSt0Lmxlbmd0aCksQi5hcnJheWNvcHkodCwwLHRoaXMuX2RhdGEsdGhpcy5fc2l6ZSx0Lmxlbmd0aCksdm9pZCh0aGlzLl9zaXplKz10Lmxlbmd0aCkpfWVuc3VyZUNhcGFjaXR5KHQpe2lmKHQ8PXRoaXMuX2RhdGEubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IGU9TWF0aC5tYXgodCwyKnRoaXMuX2RhdGEubGVuZ3RoKTt0aGlzLl9kYXRhPW50LmNvcHlPZih0aGlzLl9kYXRhLGUpfXRvQXJyYXkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9zaXplKS5maWxsKG51bGwpO3JldHVybiBCLmFycmF5Y29weSh0aGlzLl9kYXRhLDAsdCwwLHRoaXMuX3NpemUpLHR9YWRkKHQpe3RoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSsxKSx0aGlzLl9kYXRhW3RoaXMuX3NpemVdPXQsKyt0aGlzLl9zaXplfX1jbGFzcyBqbntzdGF0aWMgdG9JbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXQuZ2V0KG4pLmludFZhbHVlKCk7cmV0dXJuIGV9Z2V0Q2hhaW5TdGFydEluZGljZXModCl7bGV0IGU9MDtjb25zdCBuPW5ldyBabihNYXRoLnRydW5jKHQubGVuZ3RoLzIpKTtuLmFkZChlKTtkb3tjb25zdCBzPXRoaXMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQocyksZT1zfXdoaWxlKGU8dC5sZW5ndGgtMSk7cmV0dXJuIG4udG9BcnJheSgpfWZpbmRDaGFpbkVuZCh0LGUpe2NvbnN0IG49d24ucXVhZHJhbnQodFtlXSx0W2UrMV0pO2xldCBzPWUrMTtmb3IoO3M8dC5sZW5ndGg7KXtpZih3bi5xdWFkcmFudCh0W3MtMV0sdFtzXSkhPT1uKWJyZWFrO3MrK31yZXR1cm4gcy0xfU9MRGdldENoYWluU3RhcnRJbmRpY2VzKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgTDtuLmFkZChlKTtkb3tjb25zdCBzPXRoaXMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQocyksZT1zfXdoaWxlKGU8dC5sZW5ndGgtMSk7cmV0dXJuIGpuLnRvSW50QXJyYXkobil9fWNsYXNzIEtue2NvbnN0cnVjdG9yKCl7S24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5lPW51bGwsdGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0SW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmU9dCx0aGlzLnB0cz10LmdldENvb3JkaW5hdGVzKCk7Y29uc3QgZT1uZXcgam47dGhpcy5zdGFydEluZGV4PWUuZ2V0Q2hhaW5TdGFydEluZGljZXModGhpcy5wdHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfWdldE1heFgodCl7Y29uc3QgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZT5uP2U6bn1nZXRNaW5YKHQpe2NvbnN0IGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU8bj9lOm59Y29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbigpe2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5zdGFydEluZGV4W3RdLHRoaXMuc3RhcnRJbmRleFt0KzFdLGUsZS5zdGFydEluZGV4W25dLGUuc3RhcnRJbmRleFtuKzFdLHMpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO2lmKGUtdD09MSYmaS1zPT0xKXJldHVybiByLmFkZEludGVyc2VjdGlvbnModGhpcy5lLHQsbi5lLHMpLG51bGw7aWYoIXRoaXMub3ZlcmxhcHModCxlLG4scyxpKSlyZXR1cm4gbnVsbDtjb25zdCBvPU1hdGgudHJ1bmMoKHQrZSkvMiksbD1NYXRoLnRydW5jKChzK2kpLzIpO3Q8byYmKHM8bCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHQsbyxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0LG8sbixsLGkscikpLG88ZSYmKHM8bCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG8sZSxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihvLGUsbixsLGkscikpfX1vdmVybGFwcyh0LGUsbixzLGkpe3JldHVybiBPLmludGVyc2VjdHModGhpcy5wdHNbdF0sdGhpcy5wdHNbZV0sbi5wdHNbc10sbi5wdHNbaV0pfWdldFN0YXJ0SW5kZXhlcygpe3JldHVybiB0aGlzLnN0YXJ0SW5kZXh9Y29tcHV0ZUludGVyc2VjdHModCxlKXtmb3IobGV0IG49MDtuPHRoaXMuc3RhcnRJbmRleC5sZW5ndGgtMTtuKyspZm9yKGxldCBzPTA7czx0LnN0YXJ0SW5kZXgubGVuZ3RoLTE7cysrKXRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihuLHQscyxlKX19Y2xhc3MgUW57Y29uc3RydWN0b3IoKXtRbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9kZXB0aD1BcnJheSgyKS5maWxsKCkubWFwKCgoKT0+QXJyYXkoMykpKTtmb3IobGV0IHQ9MDt0PDI7dCsrKWZvcihsZXQgZT0wO2U8MztlKyspdGhpcy5fZGVwdGhbdF1bZV09UW4uTlVMTF9WQUxVRX1zdGF0aWMgZGVwdGhBdExvY2F0aW9uKHQpe3JldHVybiB0PT09UXQuRVhURVJJT1I/MDp0PT09UXQuSU5URVJJT1I/MTpRbi5OVUxMX1ZBTFVFfWdldERlcHRoKHQsZSl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdfXNldERlcHRoKHQsZSxuKXt0aGlzLl9kZXB0aFt0XVtlXT1ufWlzTnVsbCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWZvcihsZXQgZT0wO2U8MztlKyspaWYodGhpcy5fZGVwdGhbdF1bZV0hPT1Rbi5OVUxMX1ZBTFVFKXJldHVybiExO3JldHVybiEwfWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bMV09PT1Rbi5OVUxMX1ZBTFVFfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV09PT1Rbi5OVUxMX1ZBTFVFfX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWlmKCF0aGlzLmlzTnVsbCh0KSl7bGV0IGU9dGhpcy5fZGVwdGhbdF1bMV07dGhpcy5fZGVwdGhbdF1bMl08ZSYmKGU9dGhpcy5fZGVwdGhbdF1bMl0pLGU8MCYmKGU9MCk7Zm9yKGxldCBuPTE7bjwzO24rKyl7bGV0IHM9MDt0aGlzLl9kZXB0aFt0XVtuXT5lJiYocz0xKSx0aGlzLl9kZXB0aFt0XVtuXT1zfX19Z2V0RGVsdGEodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW01uLlJJR0hUXS10aGlzLl9kZXB0aFt0XVtNbi5MRUZUXX1nZXRMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXTw9MD9RdC5FWFRFUklPUjpRdC5JTlRFUklPUn10b1N0cmluZygpe3JldHVyblwiQTogXCIrdGhpcy5fZGVwdGhbMF1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMF1bMl0rXCIgQjogXCIrdGhpcy5fZGVwdGhbMV1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMV1bMl19YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8MjtlKyspZm9yKGxldCBuPTE7bjwzO24rKyl7Y29uc3Qgcz10LmdldExvY2F0aW9uKGUsbik7cyE9PVF0LkVYVEVSSU9SJiZzIT09UXQuSU5URVJJT1J8fCh0aGlzLmlzTnVsbChlLG4pP3RoaXMuX2RlcHRoW2VdW25dPVFuLmRlcHRoQXRMb2NhdGlvbihzKTp0aGlzLl9kZXB0aFtlXVtuXSs9UW4uZGVwdGhBdExvY2F0aW9uKHMpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdPT09UXQuSU5URVJJT1ImJnRoaXMuX2RlcHRoW3RdW2VdKyt9fX1Rbi5OVUxMX1ZBTFVFPS0xO2NsYXNzIEpue2NvbnN0cnVjdG9yKCl7Sm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzQ292ZXJlZD0hMSx0aGlzLl9pc0NvdmVyZWRTZXQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sYWJlbD10fX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fXNldEluUmVzdWx0KHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH1pc0NvdmVyZWQoKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkfWlzQ292ZXJlZFNldCgpe3JldHVybiB0aGlzLl9pc0NvdmVyZWRTZXR9c2V0TGFiZWwodCl7dGhpcy5fbGFiZWw9dH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1zZXRDb3ZlcmVkKHQpe3RoaXMuX2lzQ292ZXJlZD10LHRoaXMuX2lzQ292ZXJlZFNldD0hMH11cGRhdGVJTSh0KXtnLmlzVHJ1ZSh0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCk+PTIsXCJmb3VuZCBwYXJ0aWFsIGxhYmVsXCIpLHRoaXMuY29tcHV0ZUlNKHQpfWlzSW5SZXN1bHQoKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfX1jbGFzcyAkbiBleHRlbmRzIEpue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSwkbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLnB0cz1udWxsLHRoaXMuX2Vudj1udWxsLHRoaXMuZWlMaXN0PW5ldyBXbih0aGlzKSx0aGlzLl9uYW1lPW51bGwsdGhpcy5fbWNlPW51bGwsdGhpcy5faXNJc29sYXRlZD0hMCx0aGlzLl9kZXB0aD1uZXcgUW4sdGhpcy5fZGVwdGhEZWx0YT0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTskbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wdHM9dCx0aGlzLl9sYWJlbD1lfX1zdGF0aWMgdXBkYXRlSU0oKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEp0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFuKSlyZXR1cm4gc3VwZXIudXBkYXRlSU0uYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxNbi5PTiksdC5nZXRMb2NhdGlvbigxLE1uLk9OKSwxKSx0LmlzQXJlYSgpJiYoZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsTW4uTEVGVCksdC5nZXRMb2NhdGlvbigxLE1uLkxFRlQpLDIpLGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLE1uLlJJR0hUKSx0LmdldExvY2F0aW9uKDEsTW4uUklHSFQpLDIpKX19Z2V0RGVwdGgoKXtyZXR1cm4gdGhpcy5fZGVwdGh9Z2V0Q29sbGFwc2VkRWRnZSgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7dFswXT10aGlzLnB0c1swXSx0WzFdPXRoaXMucHRzWzFdO3JldHVybiBuZXcgJG4odCxxbi50b0xpbmVMYWJlbCh0aGlzLl9sYWJlbCkpfWlzSXNvbGF0ZWQoKXtyZXR1cm4gdGhpcy5faXNJc29sYXRlZH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31zZXRJc29sYXRlZCh0KXt0aGlzLl9pc0lzb2xhdGVkPXR9c2V0TmFtZSh0KXt0aGlzLl9uYW1lPXR9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mICRuKSlyZXR1cm4hMTtjb25zdCBlPXQ7aWYodGhpcy5wdHMubGVuZ3RoIT09ZS5wdHMubGVuZ3RoKXJldHVybiExO2xldCBuPSEwLHM9ITAsaT10aGlzLnB0cy5sZW5ndGg7Zm9yKGxldCB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKWlmKHRoaXMucHRzW3RdLmVxdWFsczJEKGUucHRzW3RdKXx8KG49ITEpLHRoaXMucHRzW3RdLmVxdWFsczJEKGUucHRzWy0taV0pfHwocz0hMSksIW4mJiFzKXJldHVybiExO3JldHVybiEwfWdldENvb3JkaW5hdGUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5wdHMubGVuZ3RoPjA/dGhpcy5wdHNbMF06bnVsbDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucHRzW3RdfX1wcmludCh0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIiksdC5wcmludChcIkxJTkVTVFJJTkcgKFwiKTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7dC5wcmludChcIikgIFwiK3RoaXMuX2xhYmVsK1wiIFwiK3RoaXMuX2RlcHRoRGVsdGEpfWNvbXB1dGVJTSh0KXskbi51cGRhdGVJTSh0aGlzLl9sYWJlbCx0KX1pc0NvbGxhcHNlZCgpe3JldHVybiEhdGhpcy5fbGFiZWwuaXNBcmVhKCkmJigzPT09dGhpcy5wdHMubGVuZ3RoJiYhIXRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSkpfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfWdldE1heGltdW1TZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RoLTF9Z2V0RGVwdGhEZWx0YSgpe3JldHVybiB0aGlzLl9kZXB0aERlbHRhfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9cHJpbnRSZXZlcnNlKHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKTtmb3IobGV0IGU9dGhpcy5wdHMubGVuZ3RoLTE7ZT49MDtlLS0pdC5wcmludCh0aGlzLnB0c1tlXStcIiBcIik7dC5wcmludGxuKFwiXCIpfWdldE1vbm90b25lQ2hhaW5FZGdlKCl7cmV0dXJuIG51bGw9PT10aGlzLl9tY2UmJih0aGlzLl9tY2U9bmV3IEtuKHRoaXMpKSx0aGlzLl9tY2V9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXt0aGlzLl9lbnY9bmV3IE87Zm9yKGxldCB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMuX2Vudi5leHBhbmRUb0luY2x1ZGUodGhpcy5wdHNbdF0pfXJldHVybiB0aGlzLl9lbnZ9YWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9bmV3IG0odC5nZXRJbnRlcnNlY3Rpb24ocykpO2xldCByPWUsbz10LmdldEVkZ2VEaXN0YW5jZShuLHMpO2NvbnN0IGw9cisxO2lmKGw8dGhpcy5wdHMubGVuZ3RoKXtjb25zdCB0PXRoaXMucHRzW2xdO2kuZXF1YWxzMkQodCkmJihyPWwsbz0wKX10aGlzLmVpTGlzdC5hZGQoaSxyLG8pfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgX3Q7dC5hcHBlbmQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKSx0LmFwcGVuZChcIkxJTkVTVFJJTkcgKFwiKTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LmFwcGVuZChcIixcIiksdC5hcHBlbmQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTtyZXR1cm4gdC5hcHBlbmQoXCIpICBcIit0aGlzLl9sYWJlbCtcIiBcIit0aGlzLl9kZXB0aERlbHRhKSx0LnRvU3RyaW5nKCl9aXNQb2ludHdpc2VFcXVhbCh0KXtpZih0aGlzLnB0cy5sZW5ndGghPT10LnB0cy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWlmKCF0aGlzLnB0c1tlXS5lcXVhbHMyRCh0LnB0c1tlXSkpcmV0dXJuITE7cmV0dXJuITB9c2V0RGVwdGhEZWx0YSh0KXt0aGlzLl9kZXB0aERlbHRhPXR9Z2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKXtyZXR1cm4gdGhpcy5laUxpc3R9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixzKX19Y2xhc3MgdHMgZXh0ZW5kcyBKbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmQ9bnVsbCx0aGlzLl9lZGdlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Nvb3JkPXQsdGhpcy5fZWRnZXM9ZSx0aGlzLl9sYWJlbD1uZXcgcW4oMCxRdC5OT05FKX1pc0luY2lkZW50RWRnZUluUmVzdWx0KCl7Zm9yKGxldCB0PXRoaXMuZ2V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtpZih0Lm5leHQoKS5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKXJldHVybiEwfXJldHVybiExfWlzSXNvbGF0ZWQoKXtyZXR1cm4gMT09PXRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Nvb3JkfXByaW50KHQpe3QucHJpbnRsbihcIm5vZGUgXCIrdGhpcy5fY29vcmQrXCIgbGJsOiBcIit0aGlzLl9sYWJlbCl9Y29tcHV0ZUlNKHQpe31jb21wdXRlTWVyZ2VkTG9jYXRpb24odCxlKXtsZXQgbj1RdC5OT05FO2lmKG49dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSksIXQuaXNOdWxsKGUpKXtjb25zdCBzPXQuZ2V0TG9jYXRpb24oZSk7biE9PVF0LkJPVU5EQVJZJiYobj1zKX1yZXR1cm4gbn1zZXRMYWJlbCgpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pfHwhTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXJldHVybiBzdXBlci5zZXRMYWJlbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLl9sYWJlbD90aGlzLl9sYWJlbD1uZXcgcW4odCxlKTp0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUpfX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31tZXJnZUxhYmVsKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB0cyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQuX2xhYmVsKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcW4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8MjtlKyspe2NvbnN0IG49dGhpcy5jb21wdXRlTWVyZ2VkTG9jYXRpb24odCxlKTt0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKT09PVF0Lk5PTkUmJnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGUsbil9fX1hZGQodCl7dGhpcy5fZWRnZXMuaW5zZXJ0KHQpLHQuc2V0Tm9kZSh0aGlzKX1zZXRMYWJlbEJvdW5kYXJ5KHQpe2lmKG51bGw9PT10aGlzLl9sYWJlbClyZXR1cm4gbnVsbDtsZXQgZT1RdC5OT05FO251bGwhPT10aGlzLl9sYWJlbCYmKGU9dGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24odCkpO2xldCBuPW51bGw7c3dpdGNoKGUpe2Nhc2UgUXQuQk9VTkRBUlk6bj1RdC5JTlRFUklPUjticmVhaztjYXNlIFF0LklOVEVSSU9SOmRlZmF1bHQ6bj1RdC5CT1VOREFSWX10aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LG4pfX1jbGFzcyBlc3tjb25zdHJ1Y3Rvcigpe2VzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMubm9kZU1hcD1uZXcgSG4sdGhpcy5ub2RlRmFjdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUZhY3Q9dH1maW5kKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfWFkZE5vZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPXRoaXMubm9kZU1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1lJiYoZT10aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUodCksdGhpcy5ub2RlTWFwLnB1dCh0LGUpKSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdHMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5ub2RlTWFwLmdldCh0LmdldENvb3JkaW5hdGUoKSk7cmV0dXJuIG51bGw9PT1lPyh0aGlzLm5vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHQpOihlLm1lcmdlTGFiZWwodCksZSl9fXByaW50KHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX1nZXRCb3VuZGFyeU5vZGVzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpPT09UXQuQk9VTkRBUlkmJmUuYWRkKHMpfXJldHVybiBlfWFkZCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuYWRkTm9kZShlKS5hZGQodCl9fWNsYXNzIG5ze2NvbnN0cnVjdG9yKCl7bnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZWRnZT1udWxsLHRoaXMuX2xhYmVsPW51bGwsdGhpcy5fbm9kZT1udWxsLHRoaXMuX3AwPW51bGwsdGhpcy5fcDE9bnVsbCx0aGlzLl9keD1udWxsLHRoaXMuX2R5PW51bGwsdGhpcy5fcXVhZHJhbnQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZT10fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO25zLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4sbnVsbCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLmluaXQoZSxuKSx0aGlzLl9sYWJlbD1zfX1jb21wYXJlRGlyZWN0aW9uKHQpe3JldHVybiB0aGlzLl9keD09PXQuX2R4JiZ0aGlzLl9keT09PXQuX2R5PzA6dGhpcy5fcXVhZHJhbnQ+dC5fcXVhZHJhbnQ/MTp0aGlzLl9xdWFkcmFudDx0Ll9xdWFkcmFudD8tMTpHLmluZGV4KHQuX3AwLHQuX3AxLHRoaXMuX3AxKX1nZXREeSgpe3JldHVybiB0aGlzLl9keX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3AwfXNldE5vZGUodCl7dGhpcy5fbm9kZT10fXByaW50KHQpe2NvbnN0IGU9TWF0aC5hdGFuMih0aGlzLl9keSx0aGlzLl9keCksbj10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLHM9bi5sYXN0SW5kZXhPZihcIi5cIiksaT1uLnN1YnN0cmluZyhzKzEpO3QucHJpbnQoXCIgIFwiK2krXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrZStcIiAgIFwiK3RoaXMuX2xhYmVsKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9Z2V0RGlyZWN0ZWRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3AxfWdldER4KCl7cmV0dXJuIHRoaXMuX2R4fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1nZXRRdWFkcmFudCgpe3JldHVybiB0aGlzLl9xdWFkcmFudH1nZXROb2RlKCl7cmV0dXJuIHRoaXMuX25vZGV9dG9TdHJpbmcoKXtjb25zdCB0PU1hdGguYXRhbjIodGhpcy5fZHksdGhpcy5fZHgpLGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpO3JldHVyblwiICBcIitlLnN1YnN0cmluZyhuKzEpK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK3QrXCIgICBcIit0aGlzLl9sYWJlbH1jb21wdXRlTGFiZWwodCl7fWluaXQodCxlKXt0aGlzLl9wMD10LHRoaXMuX3AxPWUsdGhpcy5fZHg9ZS54LXQueCx0aGlzLl9keT1lLnktdC55LHRoaXMuX3F1YWRyYW50PXduLnF1YWRyYW50KHRoaXMuX2R4LHRoaXMuX2R5KSxnLmlzVHJ1ZSghKDA9PT10aGlzLl9keCYmMD09PXRoaXMuX2R5KSxcIkVkZ2VFbmQgd2l0aCBpZGVudGljYWwgZW5kcG9pbnRzIGZvdW5kXCIpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3Mgc3MgZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIoZT90K1wiIFsgXCIrZStcIiBdXCI6dCksdGhpcy5wdD1lP25ldyBtKGUpOnZvaWQgMCx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe1RvcG9sb2d5RXhjZXB0aW9uOnNzfSlbMF19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLnB0fX1jbGFzcyBpcyBleHRlbmRzIG5ze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxpcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0ZvcndhcmQ9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fbmV4dE1pbj1udWxsLHRoaXMuX2VkZ2VSaW5nPW51bGwsdGhpcy5fbWluRWRnZVJpbmc9bnVsbCx0aGlzLl9kZXB0aD1bMCwtOTk5LC05OTldO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKG5zLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCksdGhpcy5faXNGb3J3YXJkPWUsZSl0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKDApLHQuZ2V0Q29vcmRpbmF0ZSgxKSk7ZWxzZXtjb25zdCBlPXQuZ2V0TnVtUG9pbnRzKCktMTt0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKGUpLHQuZ2V0Q29vcmRpbmF0ZShlLTEpKX10aGlzLmNvbXB1dGVEaXJlY3RlZExhYmVsKCl9c3RhdGljIGRlcHRoRmFjdG9yKHQsZSl7cmV0dXJuIHQ9PT1RdC5FWFRFUklPUiYmZT09PVF0LklOVEVSSU9SPzE6dD09PVF0LklOVEVSSU9SJiZlPT09UXQuRVhURVJJT1I/LTE6MH1nZXROZXh0TWluKCl7cmV0dXJuIHRoaXMuX25leHRNaW59Z2V0RGVwdGgodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdfXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9Y29tcHV0ZURpcmVjdGVkTGFiZWwoKXt0aGlzLl9sYWJlbD1uZXcgcW4odGhpcy5fZWRnZS5nZXRMYWJlbCgpKSx0aGlzLl9pc0ZvcndhcmR8fHRoaXMuX2xhYmVsLmZsaXAoKX1nZXROZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9c2V0RGVwdGgodCxlKXtpZigtOTk5IT09dGhpcy5fZGVwdGhbdF0mJnRoaXMuX2RlcHRoW3RdIT09ZSl0aHJvdyBuZXcgc3MoXCJhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3RoaXMuX2RlcHRoW3RdPWV9aXNJbnRlcmlvckFyZWFFZGdlKCl7bGV0IHQ9ITA7Zm9yKGxldCBlPTA7ZTwyO2UrKyl0aGlzLl9sYWJlbC5pc0FyZWEoZSkmJnRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUsTW4uTEVGVCk9PT1RdC5JTlRFUklPUiYmdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSxNbi5SSUdIVCk9PT1RdC5JTlRFUklPUnx8KHQ9ITEpO3JldHVybiB0fXNldE5leHRNaW4odCl7dGhpcy5fbmV4dE1pbj10fXByaW50KHQpe3N1cGVyLnByaW50LmNhbGwodGhpcyx0KSx0LnByaW50KFwiIFwiK3RoaXMuX2RlcHRoW01uLkxFRlRdK1wiL1wiK3RoaXMuX2RlcHRoW01uLlJJR0hUXSksdC5wcmludChcIiAoXCIrdGhpcy5nZXREZXB0aERlbHRhKCkrXCIpXCIpLHRoaXMuX2lzSW5SZXN1bHQmJnQucHJpbnQoXCIgaW5SZXN1bHRcIil9c2V0TWluRWRnZVJpbmcodCl7dGhpcy5fbWluRWRnZVJpbmc9dH1pc0xpbmVFZGdlKCl7Y29uc3QgdD10aGlzLl9sYWJlbC5pc0xpbmUoMCl8fHRoaXMuX2xhYmVsLmlzTGluZSgxKSxlPSF0aGlzLl9sYWJlbC5pc0FyZWEoMCl8fHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsUXQuRVhURVJJT1IpLG49IXRoaXMuX2xhYmVsLmlzQXJlYSgxKXx8dGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMSxRdC5FWFRFUklPUik7cmV0dXJuIHQmJmUmJm59c2V0RWRnZVJpbmcodCl7dGhpcy5fZWRnZVJpbmc9dH1nZXRNaW5FZGdlUmluZygpe3JldHVybiB0aGlzLl9taW5FZGdlUmluZ31nZXREZXB0aERlbHRhKCl7bGV0IHQ9dGhpcy5fZWRnZS5nZXREZXB0aERlbHRhKCk7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZHx8KHQ9LXQpLHR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWdldFN5bSgpe3JldHVybiB0aGlzLl9zeW19aXNGb3J3YXJkKCl7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9cHJpbnRFZGdlKHQpe3RoaXMucHJpbnQodCksdC5wcmludChcIiBcIiksdGhpcy5faXNGb3J3YXJkP3RoaXMuX2VkZ2UucHJpbnQodCk6dGhpcy5fZWRnZS5wcmludFJldmVyc2UodCl9c2V0U3ltKHQpe3RoaXMuX3N5bT10fXNldFZpc2l0ZWRFZGdlKHQpe3RoaXMuc2V0VmlzaXRlZCh0KSx0aGlzLl9zeW0uc2V0VmlzaXRlZCh0KX1zZXRFZGdlRGVwdGhzKHQsZSl7bGV0IG49dGhpcy5nZXRFZGdlKCkuZ2V0RGVwdGhEZWx0YSgpO3RoaXMuX2lzRm9yd2FyZHx8KG49LW4pO2xldCBzPTE7dD09PU1uLkxFRlQmJihzPS0xKTtjb25zdCBpPU1uLm9wcG9zaXRlKHQpLHI9ZStuKnM7dGhpcy5zZXREZXB0aCh0LGUpLHRoaXMuc2V0RGVwdGgoaSxyKX1nZXRFZGdlUmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ31pc0luUmVzdWx0KCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH19Y2xhc3MgcnN7Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IHRzKHQsbnVsbCl9fWNsYXNzIG9ze2NvbnN0cnVjdG9yKCl7b3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZWRnZXM9bmV3IEwsdGhpcy5fbm9kZXM9bnVsbCx0aGlzLl9lZGdlRW5kTGlzdD1uZXcgTCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9ub2Rlcz1uZXcgZXMobmV3IHJzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ub2Rlcz1uZXcgZXModCl9fXN0YXRpYyBsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX1wcmludEVkZ2VzKHQpe3QucHJpbnRsbihcIkVkZ2VzOlwiKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspe3QucHJpbnRsbihcImVkZ2UgXCIrZStcIjpcIik7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7bi5wcmludCh0KSxuLmVpTGlzdC5wcmludCh0KX19ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZXMuZmluZCh0KX1hZGROb2RlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB0cyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZSh0KX19Z2V0Tm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKCl9bGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19ZGVidWdQcmludGxuKHQpe0Iub3V0LnByaW50bG4odCl9aXNCb3VuZGFyeU5vZGUodCxlKXtjb25zdCBuPXRoaXMuX25vZGVzLmZpbmQoZSk7aWYobnVsbD09PW4pcmV0dXJuITE7Y29uc3Qgcz1uLmdldExhYmVsKCk7cmV0dXJuIG51bGwhPT1zJiZzLmdldExvY2F0aW9uKHQpPT09UXQuQk9VTkRBUll9bGlua0FsbERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua0FsbERpcmVjdGVkRWRnZXMoKX19bWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLG4scyl7cmV0dXJuISF0LmVxdWFscyhuKSYmKEcuaW5kZXgodCxlLHMpPT09Ry5DT0xMSU5FQVImJnduLnF1YWRyYW50KHQsZSk9PT13bi5xdWFkcmFudChuLHMpKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kTGlzdH1kZWJ1Z1ByaW50KHQpe0Iub3V0LnByaW50KHQpfWdldEVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLl9lZGdlcy5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuX2VkZ2VzLmdldChuKSxpPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxpWzBdLGlbMV0pKXJldHVybiBzO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLGlbaS5sZW5ndGgtMV0saVtpLmxlbmd0aC0yXSkpcmV0dXJuIHN9cmV0dXJuIG51bGx9aW5zZXJ0RWRnZSh0KXt0aGlzLl9lZGdlcy5hZGQodCl9ZmluZEVkZ2VFbmQodCl7Zm9yKGxldCBlPXRoaXMuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuLmdldEVkZ2UoKT09PXQpcmV0dXJuIG59cmV0dXJuIG51bGx9YWRkRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IG49bmV3IGlzKHQsITApLHM9bmV3IGlzKHQsITEpO24uc2V0U3ltKHMpLHMuc2V0U3ltKG4pLHRoaXMuYWRkKG4pLHRoaXMuYWRkKHMpfX1hZGQodCl7dGhpcy5fbm9kZXMuYWRkKHQpLHRoaXMuX2VkZ2VFbmRMaXN0LmFkZCh0KX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2Rlcy52YWx1ZXMoKX1maW5kRWRnZSh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5fZWRnZXMuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLl9lZGdlcy5nZXQobiksaT1zLmdldENvb3JkaW5hdGVzKCk7aWYodC5lcXVhbHMoaVswXSkmJmUuZXF1YWxzKGlbMV0pKXJldHVybiBzfXJldHVybiBudWxsfX1jbGFzcyBscyBleHRlbmRzIG9ze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxscy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wYXJlbnRHZW9tPW51bGwsdGhpcy5fbGluZUVkZ2VNYXA9bmV3IEl0LHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGU9bnVsbCx0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSEwLHRoaXMuX2FyZ0luZGV4PW51bGwsdGhpcy5fYm91bmRhcnlOb2Rlcz1udWxsLHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMSx0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbCx0aGlzLl9hcmVhUHRMb2NhdG9yPW51bGwsdGhpcy5fcHRMb2NhdG9yPW5ldyBmbiwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bHMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsZ24uT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9hcmdJbmRleD10LHRoaXMuX3BhcmVudEdlb209ZSx0aGlzLl9ib3VuZGFyeU5vZGVSdWxlPW4sbnVsbCE9PWUmJnRoaXMuYWRkKGUpfX1zdGF0aWMgZGV0ZXJtaW5lQm91bmRhcnkodCxlKXtyZXR1cm4gdC5pc0luQm91bmRhcnkoZSk/UXQuQk9VTkRBUlk6UXQuSU5URVJJT1J9aW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpe2NvbnN0IG49dGhpcy5fbm9kZXMuYWRkTm9kZShlKS5nZXRMYWJlbCgpO2xldCBzPTEsaT1RdC5OT05FO2k9bi5nZXRMb2NhdGlvbih0LE1uLk9OKSxpPT09UXQuQk9VTkRBUlkmJnMrKztjb25zdCByPWxzLmRldGVybWluZUJvdW5kYXJ5KHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUscyk7bi5zZXRMb2NhdGlvbih0LHIpfWNvbXB1dGVTZWxmTm9kZXMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcHV0ZVNlbGZOb2Rlcyh0LGUsITEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPW5ldyBBbihhcmd1bWVudHNbMF0sITAsITEpO24uc2V0SXNEb25lSWZQcm9wZXJJbnQoZSk7Y29uc3Qgcz10aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLGk9dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIHV0fHx0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgaXR8fHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBmdCxyPXR8fCFpO3JldHVybiBzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLG4sciksdGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModGhpcy5fYXJnSW5kZXgpLG59fWNvbXB1dGVTcGxpdEVkZ2VzKHQpe2ZvcihsZXQgZT10aGlzLl9lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZWlMaXN0LmFkZFNwbGl0RWRnZXModCl9fWNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0LGUsbil7Y29uc3Qgcz1uZXcgQW4oZSxuLCEwKTtzLnNldEJvdW5kYXJ5Tm9kZXModGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksdC5nZXRCb3VuZGFyeU5vZGVzKCkpO3JldHVybiB0aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLHQuX2VkZ2VzLHMpLHN9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5fcGFyZW50R2VvbX1nZXRCb3VuZGFyeU5vZGVSdWxlKCl7cmV0dXJuIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGV9aGFzVG9vRmV3UG9pbnRzKCl7cmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c31hZGRQb2ludCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGUoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHQsUXQuSU5URVJJT1IpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHQsUXQuSU5URVJJT1IpfX1hZGRQb2x5Z29uKHQpe3RoaXMuYWRkUG9seWdvblJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSxRdC5FWFRFUklPUixRdC5JTlRFUklPUik7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl7Y29uc3Qgbj10LmdldEludGVyaW9yUmluZ04oZSk7dGhpcy5hZGRQb2x5Z29uUmluZyhuLFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SKX19YWRkRWRnZSh0KXt0aGlzLmluc2VydEVkZ2UodCk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxlWzBdLFF0LkJPVU5EQVJZKSx0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LGVbZS5sZW5ndGgtMV0sUXQuQk9VTkRBUlkpfWFkZExpbmVTdHJpbmcodCl7Y29uc3QgZT1kdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLl9pbnZhbGlkUG9pbnQ9ZVswXSxudWxsO2NvbnN0IG49bmV3ICRuKGUsbmV3IHFuKHRoaXMuX2FyZ0luZGV4LFF0LklOVEVSSU9SKSk7dGhpcy5fbGluZUVkZ2VNYXAucHV0KHQsbiksdGhpcy5pbnNlcnRFZGdlKG4pLGcuaXNUcnVlKGUubGVuZ3RoPj0yLFwiZm91bmQgTGluZVN0cmluZyB3aXRoIHNpbmdsZSBwb2ludFwiKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsZVswXSksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LGVbZS5sZW5ndGgtMV0pfWdldEludmFsaWRQb2ludCgpe3JldHVybiB0aGlzLl9pbnZhbGlkUG9pbnR9Z2V0Qm91bmRhcnlQb2ludHMoKXtjb25zdCB0PXRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBuPTA7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7ZVtuKytdPXQuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKX1yZXR1cm4gZX1nZXRCb3VuZGFyeU5vZGVzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9ib3VuZGFyeU5vZGVzJiYodGhpcy5fYm91bmRhcnlOb2Rlcz10aGlzLl9ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuX2FyZ0luZGV4KSksdGhpcy5fYm91bmRhcnlOb2Rlc31hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSh0LGUsbil7aWYodGhpcy5pc0JvdW5kYXJ5Tm9kZSh0LGUpKXJldHVybiBudWxsO249PT1RdC5CT1VOREFSWSYmdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT90aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodCxlKTp0aGlzLmluc2VydFBvaW50KHQsZSxuKX1hZGRQb2x5Z29uUmluZyh0LGUsbil7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgcz1kdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKHMubGVuZ3RoPDQpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLl9pbnZhbGlkUG9pbnQ9c1swXSxudWxsO2xldCBpPWUscj1uO0cuaXNDQ1cocykmJihpPW4scj1lKTtjb25zdCBvPW5ldyAkbihzLG5ldyBxbih0aGlzLl9hcmdJbmRleCxRdC5CT1VOREFSWSxpLHIpKTt0aGlzLl9saW5lRWRnZU1hcC5wdXQodCxvKSx0aGlzLmluc2VydEVkZ2UobyksdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxzWzBdLFF0LkJPVU5EQVJZKX1pbnNlcnRQb2ludCh0LGUsbil7Y29uc3Qgcz10aGlzLl9ub2Rlcy5hZGROb2RlKGUpLGk9cy5nZXRMYWJlbCgpO251bGw9PT1pP3MuX2xhYmVsPW5ldyBxbih0LG4pOmkuc2V0TG9jYXRpb24odCxuKX1jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKXtyZXR1cm4gbmV3IEZufWFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZWlMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxuLmNvb3JkLHMpfX19YWRkKCl7aWYoISgxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKSlyZXR1cm4gc3VwZXIuYWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIGZ0JiYodGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMSksdCBpbnN0YW5jZW9mIGl0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBKKXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB0dCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB3dCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgY3QpKXRocm93IG5ldyBqKHQuZ2V0R2VvbWV0cnlUeXBlKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19fWFkZENvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fWxvY2F0ZSh0KXtyZXR1cm4gSSh0aGlzLl9wYXJlbnRHZW9tLHN0KSYmdGhpcy5fcGFyZW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk+NTA/KG51bGw9PT10aGlzLl9hcmVhUHRMb2NhdG9yJiYodGhpcy5fYXJlYVB0TG9jYXRvcj1uZXcgemUodGhpcy5fcGFyZW50R2VvbSkpLHRoaXMuX2FyZWFQdExvY2F0b3IubG9jYXRlKHQpKTp0aGlzLl9wdExvY2F0b3IubG9jYXRlKHQsdGhpcy5fcGFyZW50R2VvbSl9ZmluZEVkZ2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBKKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbGluZUVkZ2VNYXAuZ2V0KHQpfXJldHVybiBzdXBlci5maW5kRWRnZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBhcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9tZXRyeUdyYXBoOmxzfSk7Y2xhc3MgY3N7dmlzaXQodCl7fX1jbGFzcyBoc3tjb25zdHJ1Y3Rvcigpe2hzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3A9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD1uZXcgbSh0KSx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD0xLHRoaXMuX2RhdGE9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wPW5ldyBtKHQsZSksdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9MSx0aGlzLl9kYXRhPW59fWlzUmVwZWF0ZWQoKXtyZXR1cm4gdGhpcy5fY291bnQ+MX1nZXRSaWdodCgpe3JldHVybiB0aGlzLl9yaWdodH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B9c2V0TGVmdCh0KXt0aGlzLl9sZWZ0PXR9Z2V0WCgpe3JldHVybiB0aGlzLl9wLnh9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWdldENvdW50KCl7cmV0dXJuIHRoaXMuX2NvdW50fWdldExlZnQoKXtyZXR1cm4gdGhpcy5fbGVmdH1nZXRZKCl7cmV0dXJuIHRoaXMuX3AueX1pbmNyZW1lbnQoKXt0aGlzLl9jb3VudD10aGlzLl9jb3VudCsxfXNldFJpZ2h0KHQpe3RoaXMuX3JpZ2h0PXR9fWNsYXNzIHVze2NvbnN0cnVjdG9yKCl7dXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcm9vdD1udWxsLHRoaXMuX251bWJlck9mTm9kZXM9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl1cy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3RvbGVyYW5jZT10fX1zdGF0aWMgdG9Db29yZGluYXRlcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdXMudG9Db29yZGluYXRlcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgUjtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPWU/dC5nZXRDb3VudCgpOjE7Zm9yKGxldCBlPTA7ZTxpO2UrKyluLmFkZCh0LmdldENvb3JkaW5hdGUoKSwhMCl9cmV0dXJuIG4udG9Db29yZGluYXRlQXJyYXkoKX19aW5zZXJ0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluc2VydCh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihudWxsPT09dGhpcy5fcm9vdClyZXR1cm4gdGhpcy5fcm9vdD1uZXcgaHModCxlKSx0aGlzLl9yb290O2lmKHRoaXMuX3RvbGVyYW5jZT4wKXtjb25zdCBlPXRoaXMuZmluZEJlc3RNYXRjaE5vZGUodCk7aWYobnVsbCE9PWUpcmV0dXJuIGUuaW5jcmVtZW50KCksZX1yZXR1cm4gdGhpcy5pbnNlcnRFeGFjdCh0LGUpfX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8mJkkoYXJndW1lbnRzWzFdLHcpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLl9yb290LHQsITAsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltjc119dmlzaXQodCl7ZS5hZGQodCl9fSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8mJkkoYXJndW1lbnRzWzFdLGNzKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5xdWVyeU5vZGUodGhpcy5fcm9vdCx0LCEwLGUpfX1xdWVyeU5vZGUodCxlLG4scyl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7bGV0IGk9bnVsbCxyPW51bGwsbz1udWxsO24/KGk9ZS5nZXRNaW5YKCkscj1lLmdldE1heFgoKSxvPXQuZ2V0WCgpKTooaT1lLmdldE1pblkoKSxyPWUuZ2V0TWF4WSgpLG89dC5nZXRZKCkpO2NvbnN0IGw9bzw9cjtpPG8mJnRoaXMucXVlcnlOb2RlKHQuZ2V0TGVmdCgpLGUsIW4scyksZS5jb250YWlucyh0LmdldENvb3JkaW5hdGUoKSkmJnMudmlzaXQodCksbCYmdGhpcy5xdWVyeU5vZGUodC5nZXRSaWdodCgpLGUsIW4scyl9ZmluZEJlc3RNYXRjaE5vZGUodCl7Y29uc3QgZT1uZXcgZ3ModCx0aGlzLl90b2xlcmFuY2UpO3JldHVybiB0aGlzLnF1ZXJ5KGUucXVlcnlFbnZlbG9wZSgpLGUpLGUuZ2V0Tm9kZSgpfWlzRW1wdHkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jvb3R9aW5zZXJ0RXhhY3QodCxlKXtsZXQgbj10aGlzLl9yb290LHM9dGhpcy5fcm9vdCxpPSEwLHI9ITA7Zm9yKDtudWxsIT09bjspe2lmKG51bGwhPT1uKXtpZih0LmRpc3RhbmNlKG4uZ2V0Q29vcmRpbmF0ZSgpKTw9dGhpcy5fdG9sZXJhbmNlKXJldHVybiBuLmluY3JlbWVudCgpLG59cj1pP3QueDxuLmdldFgoKTp0Lnk8bi5nZXRZKCkscz1uLG49cj9uLmdldExlZnQoKTpuLmdldFJpZ2h0KCksaT0haX10aGlzLl9udW1iZXJPZk5vZGVzPXRoaXMuX251bWJlck9mTm9kZXMrMTtjb25zdCBvPW5ldyBocyh0LGUpO3JldHVybiByP3Muc2V0TGVmdChvKTpzLnNldFJpZ2h0KG8pLG99fWNsYXNzIGdze2NvbnN0cnVjdG9yKCl7Z3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdG9sZXJhbmNlPW51bGwsdGhpcy5fbWF0Y2hOb2RlPW51bGwsdGhpcy5fbWF0Y2hEaXN0PTAsdGhpcy5fcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9dCx0aGlzLl90b2xlcmFuY2U9ZX12aXNpdCh0KXtjb25zdCBlPXRoaXMuX3AuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpO2lmKCEoZTw9dGhpcy5fdG9sZXJhbmNlKSlyZXR1cm4gbnVsbDtsZXQgbj0hMTsobnVsbD09PXRoaXMuX21hdGNoTm9kZXx8ZTx0aGlzLl9tYXRjaERpc3R8fG51bGwhPT10aGlzLl9tYXRjaE5vZGUmJmU9PT10aGlzLl9tYXRjaERpc3QmJnQuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLl9tYXRjaE5vZGUuZ2V0Q29vcmRpbmF0ZSgpKTwxKSYmKG49ITApLG4mJih0aGlzLl9tYXRjaE5vZGU9dCx0aGlzLl9tYXRjaERpc3Q9ZSl9cXVlcnlFbnZlbG9wZSgpe2NvbnN0IHQ9bmV3IE8odGhpcy5fcCk7cmV0dXJuIHQuZXhwYW5kQnkodGhpcy5fdG9sZXJhbmNlKSx0fWdldE5vZGUoKXtyZXR1cm4gdGhpcy5fbWF0Y2hOb2RlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjc119fXVzLkJlc3RNYXRjaFZpc2l0b3I9Z3M7dmFyIGRzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEtkVHJlZTp1c30pO2NsYXNzIF9ze2NvbnN0cnVjdG9yKCl7X3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXRlbXM9bmV3IEwsdGhpcy5fc3Vibm9kZT1uZXcgQXJyYXkoNCkuZmlsbChudWxsKX1zdGF0aWMgZ2V0U3Vibm9kZUluZGV4KHQsZSxuKXtsZXQgcz0tMTtyZXR1cm4gdC5nZXRNaW5YKCk+PWUmJih0LmdldE1pblkoKT49biYmKHM9MyksdC5nZXRNYXhZKCk8PW4mJihzPTEpKSx0LmdldE1heFgoKTw9ZSYmKHQuZ2V0TWluWSgpPj1uJiYocz0yKSx0LmdldE1heFkoKTw9biYmKHM9MCkpLHN9aGFzQ2hpbGRyZW4oKXtmb3IobGV0IHQ9MDt0PDQ7dCsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfWlzUHJ1bmFibGUoKXtyZXR1cm4hKHRoaXMuaGFzQ2hpbGRyZW4oKXx8dGhpcy5oYXNJdGVtcygpKX1hZGRBbGxJdGVtcyh0KXt0LmFkZEFsbCh0aGlzLl9pdGVtcyk7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmdGhpcy5fc3Vibm9kZVtlXS5hZGRBbGxJdGVtcyh0KTtyZXR1cm4gdH1nZXROb2RlQ291bnQoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJih0Kz10aGlzLl9zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrMX1zaXplKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYodCs9dGhpcy5fc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0K3RoaXMuX2l0ZW1zLnNpemUoKX1hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7ZS5hZGRBbGwodGhpcy5faXRlbXMpO2ZvcihsZXQgbj0wO248NDtuKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbbl0mJnRoaXMuX3N1Ym5vZGVbbl0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKX12aXNpdEl0ZW1zKHQsZSl7Zm9yKGxldCB0PXRoaXMuX2l0ZW1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWUudmlzaXRJdGVtKHQubmV4dCgpKX1oYXNJdGVtcygpe3JldHVybiF0aGlzLl9pdGVtcy5pc0VtcHR5KCl9cmVtb3ZlKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4hMTtsZXQgbj0hMTtmb3IobGV0IHM9MDtzPDQ7cysrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW3NdJiYobj10aGlzLl9zdWJub2RlW3NdLnJlbW92ZSh0LGUpLG4pKXt0aGlzLl9zdWJub2RlW3NdLmlzUHJ1bmFibGUoKSYmKHRoaXMuX3N1Ym5vZGVbc109bnVsbCk7YnJlYWt9cmV0dXJuIG58fChuPXRoaXMuX2l0ZW1zLnJlbW92ZShlKSxuKX12aXNpdCh0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7dGhpcy52aXNpdEl0ZW1zKHQsZSk7Zm9yKGxldCBuPTA7bjw0O24rKyludWxsIT09dGhpcy5fc3Vibm9kZVtuXSYmdGhpcy5fc3Vibm9kZVtuXS52aXNpdCh0LGUpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWRlcHRoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdKXtjb25zdCBuPXRoaXMuX3N1Ym5vZGVbZV0uZGVwdGgoKTtuPnQmJih0PW4pfXJldHVybiB0KzF9aXNFbXB0eSgpe2xldCB0PSEwO2lmKHRoaXMuX2l0ZW1zLmlzRW1wdHkoKSl7Zm9yKGxldCBlPTA7ZTw0O2UrKylpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmIXRoaXMuX3N1Ym5vZGVbZV0uaXNFbXB0eSgpKXt0PSExO2JyZWFrfX1lbHNlIHQ9ITE7cmV0dXJuIHR9YWRkKHQpe3RoaXMuX2l0ZW1zLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bY119fWZ1bmN0aW9uIHBzKCl7fXBzLmV4cG9uZW50PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe2xldCBuLHMsaSxyO2NvbnN0IG89ezMyOntkOjEyNyxjOjEyOCxiOjAsYTowfSw2NDp7ZDozMjc1MixjOjAsYjowLGE6MH19LGw9ezMyOjgsNjQ6MTF9W3RdO3J8fChuPWU8MHx8MS9lPDAsaXNGaW5pdGUoZSl8fChyPW9bdF0sbiYmKHIuZCs9MTw8dC80LTEpLHM9TWF0aC5wb3coMixsKS0xLGk9MCkpO2lmKCFyKXtmb3Iocz17MzI6MTI3LDY0OjEwMjN9W3RdLGk9TWF0aC5hYnMoZSk7aT49MjspcysrLGkvPTI7Zm9yKDtpPDEmJnM+MDspcy0tLGkqPTI7czw9MCYmKGkvPTIpLDMyPT09dCYmcz4yNTQmJihyPXtkOm4/MjU1OjEyNyxjOjEyOCxiOjAsYTowfSxzPU1hdGgucG93KDIsbCktMSxpPTApfXJldHVybiBzfSg2NCx0KS0xMDIzfSxwcy5wb3dlck9mMj1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0KX07Y2xhc3MgbXN7Y29uc3RydWN0b3IoKXttcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdD1uZXcgbSx0aGlzLl9sZXZlbD0wLHRoaXMuX2Vudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcHV0ZUtleSh0KX1zdGF0aWMgY29tcHV0ZVF1YWRMZXZlbCh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCkscz1lPm4/ZTpuO3JldHVybiBwcy5leHBvbmVudChzKSsxfWdldExldmVsKCl7cmV0dXJuIHRoaXMuX2xldmVsfWNvbXB1dGVLZXkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKHRoaXMuX2xldmVsPW1zLmNvbXB1dGVRdWFkTGV2ZWwodCksdGhpcy5fZW52PW5ldyBPLHRoaXMuY29tcHV0ZUtleSh0aGlzLl9sZXZlbCx0KTshdGhpcy5fZW52LmNvbnRhaW5zKHQpOyl0aGlzLl9sZXZlbCs9MSx0aGlzLmNvbXB1dGVLZXkodGhpcy5fbGV2ZWwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1wcy5wb3dlck9mMih0KTt0aGlzLl9wdC54PU1hdGguZmxvb3IoZS5nZXRNaW5YKCkvbikqbix0aGlzLl9wdC55PU1hdGguZmxvb3IoZS5nZXRNaW5ZKCkvbikqbix0aGlzLl9lbnYuaW5pdCh0aGlzLl9wdC54LHRoaXMuX3B0Lngrbix0aGlzLl9wdC55LHRoaXMuX3B0Lnkrbil9fWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuX2Vudn1nZXRDZW50cmUoKXtyZXR1cm4gbmV3IG0oKHRoaXMuX2Vudi5nZXRNaW5YKCkrdGhpcy5fZW52LmdldE1heFgoKSkvMiwodGhpcy5fZW52LmdldE1pblkoKSt0aGlzLl9lbnYuZ2V0TWF4WSgpKS8yKX1nZXRQb2ludCgpe3JldHVybiB0aGlzLl9wdH19Y2xhc3MgZnMgZXh0ZW5kcyBfc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZW52PW51bGwsdGhpcy5fY2VudHJleD1udWxsLHRoaXMuX2NlbnRyZXk9bnVsbCx0aGlzLl9sZXZlbD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2Vudj10LHRoaXMuX2xldmVsPWUsdGhpcy5fY2VudHJleD0odC5nZXRNaW5YKCkrdC5nZXRNYXhYKCkpLzIsdGhpcy5fY2VudHJleT0odC5nZXRNaW5ZKCkrdC5nZXRNYXhZKCkpLzJ9c3RhdGljIGNyZWF0ZU5vZGUodCl7Y29uc3QgZT1uZXcgbXModCk7cmV0dXJuIG5ldyBmcyhlLmdldEVudmVsb3BlKCksZS5nZXRMZXZlbCgpKX1zdGF0aWMgY3JlYXRlRXhwYW5kZWQodCxlKXtjb25zdCBuPW5ldyBPKGUpO251bGwhPT10JiZuLmV4cGFuZFRvSW5jbHVkZSh0Ll9lbnYpO2NvbnN0IHM9ZnMuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJnMuaW5zZXJ0Tm9kZSh0KSxzfWZpbmQodCl7Y29uc3QgZT1fcy5nZXRTdWJub2RlSW5kZXgodCx0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKC0xPT09ZSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5fc3Vibm9kZVtlXSl7cmV0dXJuIHRoaXMuX3N1Ym5vZGVbZV0uZmluZCh0KX1yZXR1cm4gdGhpc31pc1NlYXJjaE1hdGNoKHQpe3JldHVybiBudWxsIT09dCYmdGhpcy5fZW52LmludGVyc2VjdHModCl9Z2V0U3Vibm9kZSh0KXtyZXR1cm4gbnVsbD09PXRoaXMuX3N1Ym5vZGVbdF0mJih0aGlzLl9zdWJub2RlW3RdPXRoaXMuY3JlYXRlU3Vibm9kZSh0KSksdGhpcy5fc3Vibm9kZVt0XX1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLl9lbnZ9Z2V0Tm9kZSh0KXtjb25zdCBlPV9zLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYoLTEhPT1lKXtyZXR1cm4gdGhpcy5nZXRTdWJub2RlKGUpLmdldE5vZGUodCl9cmV0dXJuIHRoaXN9Y3JlYXRlU3Vibm9kZSh0KXtsZXQgZT0wLG49MCxzPTAsaT0wO3N3aXRjaCh0KXtjYXNlIDA6ZT10aGlzLl9lbnYuZ2V0TWluWCgpLG49dGhpcy5fY2VudHJleCxzPXRoaXMuX2Vudi5nZXRNaW5ZKCksaT10aGlzLl9jZW50cmV5O2JyZWFrO2Nhc2UgMTplPXRoaXMuX2NlbnRyZXgsbj10aGlzLl9lbnYuZ2V0TWF4WCgpLHM9dGhpcy5fZW52LmdldE1pblkoKSxpPXRoaXMuX2NlbnRyZXk7YnJlYWs7Y2FzZSAyOmU9dGhpcy5fZW52LmdldE1pblgoKSxuPXRoaXMuX2NlbnRyZXgscz10aGlzLl9jZW50cmV5LGk9dGhpcy5fZW52LmdldE1heFkoKTticmVhaztjYXNlIDM6ZT10aGlzLl9jZW50cmV4LG49dGhpcy5fZW52LmdldE1heFgoKSxzPXRoaXMuX2NlbnRyZXksaT10aGlzLl9lbnYuZ2V0TWF4WSgpfWNvbnN0IHI9bmV3IE8oZSxuLHMsaSk7cmV0dXJuIG5ldyBmcyhyLHRoaXMuX2xldmVsLTEpfWluc2VydE5vZGUodCl7Zy5pc1RydWUobnVsbD09PXRoaXMuX2Vudnx8dGhpcy5fZW52LmNvbnRhaW5zKHQuX2VudikpO2NvbnN0IGU9X3MuZ2V0U3Vibm9kZUluZGV4KHQuX2Vudix0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKHQuX2xldmVsPT09dGhpcy5fbGV2ZWwtMSl0aGlzLl9zdWJub2RlW2VdPXQ7ZWxzZXtjb25zdCBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydE5vZGUodCksdGhpcy5fc3Vibm9kZVtlXT1ufX19Y2xhc3MgeXN7c3RhdGljIGlzWmVyb1dpZHRoKHQsZSl7Y29uc3Qgbj1lLXQ7aWYoMD09PW4pcmV0dXJuITA7Y29uc3Qgcz1uL01hdGgubWF4KE1hdGguYWJzKHQpLE1hdGguYWJzKGUpKTtyZXR1cm4gcHMuZXhwb25lbnQocyk8PXlzLk1JTl9CSU5BUllfRVhQT05FTlR9fXlzLk1JTl9CSU5BUllfRVhQT05FTlQ9LTUwO2NsYXNzIHhzIGV4dGVuZHMgX3N7Y29uc3RydWN0b3IoKXtzdXBlcigpfWluc2VydCh0LGUpe2NvbnN0IG49X3MuZ2V0U3Vibm9kZUluZGV4KHQseHMub3JpZ2luLngseHMub3JpZ2luLnkpO2lmKC0xPT09bilyZXR1cm4gdGhpcy5hZGQoZSksbnVsbDtjb25zdCBzPXRoaXMuX3N1Ym5vZGVbbl07aWYobnVsbD09PXN8fCFzLmdldEVudmVsb3BlKCkuY29udGFpbnModCkpe2NvbnN0IGU9ZnMuY3JlYXRlRXhwYW5kZWQocyx0KTt0aGlzLl9zdWJub2RlW25dPWV9dGhpcy5pbnNlcnRDb250YWluZWQodGhpcy5fc3Vibm9kZVtuXSx0LGUpfWlzU2VhcmNoTWF0Y2godCl7cmV0dXJuITB9aW5zZXJ0Q29udGFpbmVkKHQsZSxuKXtnLmlzVHJ1ZSh0LmdldEVudmVsb3BlKCkuY29udGFpbnMoZSkpO2NvbnN0IHM9eXMuaXNaZXJvV2lkdGgoZS5nZXRNaW5YKCksZS5nZXRNYXhYKCkpLGk9eXMuaXNaZXJvV2lkdGgoZS5nZXRNaW5ZKCksZS5nZXRNYXhZKCkpO2xldCByPW51bGw7cj1zfHxpP3QuZmluZChlKTp0LmdldE5vZGUoZSksci5hZGQobil9fXhzLm9yaWdpbj1uZXcgbSgwLDApO2NsYXNzIEVze2luc2VydCh0LGUpe31yZW1vdmUodCxlKXt9cXVlcnkoKXt9fWNsYXNzIElze2NvbnN0cnVjdG9yKCl7SXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcm9vdD1udWxsLHRoaXMuX21pbkV4dGVudD0xLHRoaXMuX3Jvb3Q9bmV3IHhzfXN0YXRpYyBlbnN1cmVFeHRlbnQodCxlKXtsZXQgbj10LmdldE1pblgoKSxzPXQuZ2V0TWF4WCgpLGk9dC5nZXRNaW5ZKCkscj10LmdldE1heFkoKTtyZXR1cm4gbiE9PXMmJmkhPT1yP3Q6KG49PT1zJiYobi09ZS8yLHMrPWUvMiksaT09PXImJihpLT1lLzIscis9ZS8yKSxuZXcgTyhuLHMsaSxyKSl9c2l6ZSgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LnNpemUoKTowfWluc2VydCh0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO2NvbnN0IG49SXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTt0aGlzLl9yb290Lmluc2VydChuLGUpfXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IFllO3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZS5nZXRJdGVtcygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9yb290LnZpc2l0KHQsZSl9fXF1ZXJ5QWxsKCl7Y29uc3QgdD1uZXcgTDtyZXR1cm4gdGhpcy5fcm9vdC5hZGRBbGxJdGVtcyh0KSx0fXJlbW92ZSh0LGUpe2NvbnN0IG49SXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTtyZXR1cm4gdGhpcy5fcm9vdC5yZW1vdmUobixlKX1jb2xsZWN0U3RhdHModCl7Y29uc3QgZT10LmdldFdpZHRoKCk7ZTx0aGlzLl9taW5FeHRlbnQmJmU+MCYmKHRoaXMuX21pbkV4dGVudD1lKTtjb25zdCBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLl9taW5FeHRlbnQmJm4+MCYmKHRoaXMuX21pbkV4dGVudD1uKX1kZXB0aCgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LmRlcHRoKCk6MH1pc0VtcHR5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yb290fHx0aGlzLl9yb290LmlzRW1wdHkoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRXMsY119fXZhciBOcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxRdWFkdHJlZTpJc30pO2NsYXNzIFNze2dldEJvdW5kcygpe319Y2xhc3Mgd3N7Y29uc3RydWN0b3IoKXt3cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ib3VuZHM9bnVsbCx0aGlzLl9pdGVtPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fYm91bmRzPXQsdGhpcy5faXRlbT1lfWdldEl0ZW0oKXtyZXR1cm4gdGhpcy5faXRlbX1nZXRCb3VuZHMoKXtyZXR1cm4gdGhpcy5fYm91bmRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltTcyxjXX19Y2xhc3MgQ3N7Y29uc3RydWN0b3IoKXtDcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXplPW51bGwsdGhpcy5faXRlbXM9bnVsbCx0aGlzLl9zaXplPTAsdGhpcy5faXRlbXM9bmV3IEwsdGhpcy5faXRlbXMuYWRkKG51bGwpfXBvbGwoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMuX2l0ZW1zLmdldCgxKTtyZXR1cm4gdGhpcy5faXRlbXMuc2V0KDEsdGhpcy5faXRlbXMuZ2V0KHRoaXMuX3NpemUpKSx0aGlzLl9zaXplLT0xLHRoaXMucmVvcmRlcigxKSx0fXNpemUoKXtyZXR1cm4gdGhpcy5fc2l6ZX1yZW9yZGVyKHQpe2xldCBlPW51bGw7Y29uc3Qgbj10aGlzLl9pdGVtcy5nZXQodCk7Zm9yKDsyKnQ8PXRoaXMuX3NpemUmJihlPTIqdCxlIT09dGhpcy5fc2l6ZSYmdGhpcy5faXRlbXMuZ2V0KGUrMSkuY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChlKSk8MCYmZSsrLHRoaXMuX2l0ZW1zLmdldChlKS5jb21wYXJlVG8obik8MCk7dD1lKXRoaXMuX2l0ZW1zLnNldCh0LHRoaXMuX2l0ZW1zLmdldChlKSk7dGhpcy5faXRlbXMuc2V0KHQsbil9Y2xlYXIoKXt0aGlzLl9zaXplPTAsdGhpcy5faXRlbXMuY2xlYXIoKX1wZWVrKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7cmV0dXJuIHRoaXMuX2l0ZW1zLmdldCgxKX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9zaXplfWFkZCh0KXt0aGlzLl9pdGVtcy5hZGQobnVsbCksdGhpcy5fc2l6ZSs9MTtsZXQgZT10aGlzLl9zaXplO2Zvcih0aGlzLl9pdGVtcy5zZXQoMCx0KTt0LmNvbXBhcmVUbyh0aGlzLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk8MDtlLz0yKXRoaXMuX2l0ZW1zLnNldChlLHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTt0aGlzLl9pdGVtcy5zZXQoZSx0KX19Y2xhc3MgTHN7Y29uc3RydWN0b3IoKXtMcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9jaGlsZEJvdW5kYWJsZXM9bmV3IEwsdGhpcy5fYm91bmRzPW51bGwsdGhpcy5fbGV2ZWw9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGV2ZWw9dH19Z2V0TGV2ZWwoKXtyZXR1cm4gdGhpcy5fbGV2ZWx9c2l6ZSgpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuc2l6ZSgpfWdldENoaWxkQm91bmRhYmxlcygpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXN9YWRkQ2hpbGRCb3VuZGFibGUodCl7Zy5pc1RydWUobnVsbD09PXRoaXMuX2JvdW5kcyksdGhpcy5fY2hpbGRCb3VuZGFibGVzLmFkZCh0KX1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCl9Z2V0Qm91bmRzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9ib3VuZHMmJih0aGlzLl9ib3VuZHM9dGhpcy5jb21wdXRlQm91bmRzKCkpLHRoaXMuX2JvdW5kc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bU3MsY119fWNsYXNzIFRze3N0YXRpYyBtYXhEaXN0YW5jZSh0LGUsbixzLGkscixvLGwpe2xldCBhPVRzLmRpc3RhbmNlKHQsZSxpLHIpO3JldHVybiBhPU1hdGgubWF4KGEsVHMuZGlzdGFuY2UodCxlLG8sbCkpLGE9TWF0aC5tYXgoYSxUcy5kaXN0YW5jZShuLHMsaSxyKSksYT1NYXRoLm1heChhLFRzLmRpc3RhbmNlKG4scyxvLGwpKSxhfXN0YXRpYyBkaXN0YW5jZSh0LGUsbixzKXtjb25zdCBpPW4tdCxyPXMtZTtyZXR1cm4gTWF0aC5zcXJ0KGkqaStyKnIpfXN0YXRpYyBtYXhpbXVtRGlzdGFuY2UodCxlKXtjb25zdCBuPU1hdGgubWluKHQuZ2V0TWluWCgpLGUuZ2V0TWluWCgpKSxzPU1hdGgubWluKHQuZ2V0TWluWSgpLGUuZ2V0TWluWSgpKSxpPU1hdGgubWF4KHQuZ2V0TWF4WCgpLGUuZ2V0TWF4WCgpKSxyPU1hdGgubWF4KHQuZ2V0TWF4WSgpLGUuZ2V0TWF4WSgpKTtyZXR1cm4gVHMuZGlzdGFuY2UobixzLGkscil9c3RhdGljIG1pbk1heERpc3RhbmNlKHQsZSl7Y29uc3Qgbj10LmdldE1pblgoKSxzPXQuZ2V0TWluWSgpLGk9dC5nZXRNYXhYKCkscj10LmdldE1heFkoKSxvPWUuZ2V0TWluWCgpLGw9ZS5nZXRNaW5ZKCksYT1lLmdldE1heFgoKSxjPWUuZ2V0TWF4WSgpO2xldCBoPVRzLm1heERpc3RhbmNlKG4scyxuLHIsbyxsLG8sYyk7cmV0dXJuIGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShuLHMsbixyLG8sbCxhLGwpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UobixzLG4scixhLGMsbyxjKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKG4scyxuLHIsYSxjLGEsbCkpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShuLHMsaSxzLG8sbCxvLGMpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UobixzLGkscyxvLGwsYSxsKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKG4scyxpLHMsYSxjLG8sYykpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShuLHMsaSxzLGEsYyxhLGwpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UoaSxyLG4scixvLGwsbyxjKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKGkscixuLHIsbyxsLGEsbCkpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShpLHIsbixyLGEsYyxvLGMpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UoaSxyLG4scixhLGMsYSxsKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKGkscixpLHMsbyxsLG8sYykpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShpLHIsaSxzLG8sbCxhLGwpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UoaSxyLGkscyxhLGMsbyxjKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKGkscixpLHMsYSxjLGEsbCkpLGh9fWNsYXNzIFJze2NvbnN0cnVjdG9yKCl7UnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fYm91bmRhYmxlMT1udWxsLHRoaXMuX2JvdW5kYWJsZTI9bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2l0ZW1EaXN0YW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2JvdW5kYWJsZTE9dCx0aGlzLl9ib3VuZGFibGUyPWUsdGhpcy5faXRlbURpc3RhbmNlPW4sdGhpcy5fZGlzdGFuY2U9dGhpcy5kaXN0YW5jZSgpfXN0YXRpYyBhcmVhKHQpe3JldHVybiB0LmdldEJvdW5kcygpLmdldEFyZWEoKX1zdGF0aWMgaXNDb21wb3NpdGUodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBMc31tYXhpbXVtRGlzdGFuY2UoKXtyZXR1cm4gVHMubWF4aW11bURpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTEuZ2V0Qm91bmRzKCksdGhpcy5fYm91bmRhYmxlMi5nZXRCb3VuZHMoKSl9ZXhwYW5kVG9RdWV1ZSh0LGUpe2NvbnN0IG49UnMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSksaT1Scy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKTtpZihuJiZpKXJldHVybiBScy5hcmVhKHRoaXMuX2JvdW5kYWJsZTEpPlJzLmFyZWEodGhpcy5fYm91bmRhYmxlMik/KHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMiwhMSx0LGUpLG51bGwpOih0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLHRoaXMuX2JvdW5kYWJsZTEsITAsdCxlKSxudWxsKTtpZihuKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIsITEsdCxlKSxudWxsO2lmKGkpcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsdGhpcy5fYm91bmRhYmxlMSwhMCx0LGUpLG51bGw7dGhyb3cgbmV3IHMoXCJuZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGVcIil9aXNMZWF2ZXMoKXtyZXR1cm4hKFJzLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpfHxScy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fZGlzdGFuY2U8ZS5fZGlzdGFuY2U/LTE6dGhpcy5fZGlzdGFuY2U+ZS5fZGlzdGFuY2U/MTowfWV4cGFuZCh0LGUsbixzLGkpe2ZvcihsZXQgcj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXtjb25zdCB0PXIubmV4dCgpO2xldCBvPW51bGw7bz1uP25ldyBScyhlLHQsdGhpcy5faXRlbURpc3RhbmNlKTpuZXcgUnModCxlLHRoaXMuX2l0ZW1EaXN0YW5jZSksby5nZXREaXN0YW5jZSgpPGkmJnMuYWRkKG8pfX1nZXRCb3VuZGFibGUodCl7cmV0dXJuIDA9PT10P3RoaXMuX2JvdW5kYWJsZTE6dGhpcy5fYm91bmRhYmxlMn1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9kaXN0YW5jZX1kaXN0YW5jZSgpe3JldHVybiB0aGlzLmlzTGVhdmVzKCk/dGhpcy5faXRlbURpc3RhbmNlLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMik6dGhpcy5fYm91bmRhYmxlMS5nZXRCb3VuZHMoKS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUyLmdldEJvdW5kcygpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIFBze2NvbnN0cnVjdG9yKCl7UHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcm9vdD1udWxsLHRoaXMuX2J1aWx0PSExLHRoaXMuX2l0ZW1Cb3VuZGFibGVzPW5ldyBMLHRoaXMuX25vZGVDYXBhY2l0eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVBzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsUHMuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtnLmlzVHJ1ZSh0PjEsXCJOb2RlIGNhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5fbm9kZUNhcGFjaXR5PXR9fXN0YXRpYyBjb21wYXJlRG91Ymxlcyh0LGUpe3JldHVybiB0PmU/MTp0PGU/LTE6MH1xdWVyeUludGVybmFsKCl7aWYoSShhcmd1bWVudHNbMl0sRGUpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBMcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbMV0uZ2V0Q2hpbGRCb3VuZGFibGVzKCk7Zm9yKGxldCBzPTA7czxuLnNpemUoKTtzKyspe2NvbnN0IGk9bi5nZXQocyk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGkuZ2V0Qm91bmRzKCksdCkmJihpIGluc3RhbmNlb2YgTHM/dGhpcy5xdWVyeUludGVybmFsKHQsaSxlKTppIGluc3RhbmNlb2Ygd3M/ZS52aXNpdEl0ZW0oaS5nZXRJdGVtKCkpOmcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fWVsc2UgaWYoSShhcmd1bWVudHNbMl0sdykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIExzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1sxXS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtmb3IobGV0IHM9MDtzPG4uc2l6ZSgpO3MrKyl7Y29uc3QgaT1uLmdldChzKTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoaS5nZXRCb3VuZHMoKSx0KSYmKGkgaW5zdGFuY2VvZiBMcz90aGlzLnF1ZXJ5SW50ZXJuYWwodCxpLGUpOmkgaW5zdGFuY2VvZiB3cz9lLmFkZChpLmdldEl0ZW0oKSk6Zy5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19fWdldE5vZGVDYXBhY2l0eSgpe3JldHVybiB0aGlzLl9ub2RlQ2FwYWNpdHl9bGFzdE5vZGUodCl7cmV0dXJuIHQuZ2V0KHQuc2l6ZSgpLTEpfXNpemUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuc2l6ZSh0aGlzLl9yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuIGluc3RhbmNlb2YgTHM/dCs9dGhpcy5zaXplKG4pOm4gaW5zdGFuY2VvZiB3cyYmKHQrPTEpfXJldHVybiB0fX1yZW1vdmVJdGVtKHQsZSl7bGV0IG49bnVsbDtmb3IobGV0IHM9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0IGluc3RhbmNlb2Ygd3MmJnQuZ2V0SXRlbSgpPT09ZSYmKG49dCl9cmV0dXJuIG51bGwhPT1uJiYodC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUobiksITApfWl0ZW1zVHJlZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLmJ1aWxkKCk7Y29uc3QgdD10aGlzLml0ZW1zVHJlZSh0aGlzLl9yb290KTtyZXR1cm4gbnVsbD09PXQ/bmV3IEw6dH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtmb3IobGV0IG49dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0IGluc3RhbmNlb2YgTHMpe2NvbnN0IG49dGhpcy5pdGVtc1RyZWUodCk7bnVsbCE9PW4mJmUuYWRkKG4pfWVsc2UgdCBpbnN0YW5jZW9mIHdzP2UuYWRkKHQuZ2V0SXRlbSgpKTpnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIGUuc2l6ZSgpPD0wP251bGw6ZX19aW5zZXJ0KHQsZSl7Zy5pc1RydWUoIXRoaXMuX2J1aWx0LFwiQ2Fubm90IGluc2VydCBpdGVtcyBpbnRvIGFuIFNUUiBwYWNrZWQgUi10cmVlIGFmdGVyIGl0IGhhcyBiZWVuIGJ1aWx0LlwiKSx0aGlzLl9pdGVtQm91bmRhYmxlcy5hZGQobmV3IHdzKHQsZSkpfWJvdW5kYWJsZXNBdExldmVsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7cmV0dXJuIHRoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCx0aGlzLl9yb290LGUpLGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGcuaXNUcnVlKHQ+LTIpLGUuZ2V0TGV2ZWwoKT09PXQpcmV0dXJuIG4uYWRkKGUpLG51bGw7Zm9yKGxldCBzPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGU9cy5uZXh0KCk7ZSBpbnN0YW5jZW9mIExzP3RoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCxlLG4pOihnLmlzVHJ1ZShlIGluc3RhbmNlb2Ygd3MpLC0xPT09dCYmbi5hZGQoZSkpfXJldHVybiBudWxsfX1xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1aWxkKCk7Y29uc3QgZT1uZXcgTDtyZXR1cm4gdGhpcy5pc0VtcHR5KCl8fHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnF1ZXJ5SW50ZXJuYWwodCx0aGlzLl9yb290LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuYnVpbGQoKSx0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeUludGVybmFsKHQsdGhpcy5fcm9vdCxlKX19YnVpbGQoKXtpZih0aGlzLl9idWlsdClyZXR1cm4gbnVsbDt0aGlzLl9yb290PXRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKT90aGlzLmNyZWF0ZU5vZGUoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5faXRlbUJvdW5kYWJsZXMsLTEpLHRoaXMuX2l0ZW1Cb3VuZGFibGVzPW51bGwsdGhpcy5fYnVpbHQ9ITB9Z2V0Um9vdCgpe3JldHVybiB0aGlzLmJ1aWxkKCksdGhpcy5fcm9vdH1yZW1vdmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYnVpbGQoKSwhIXRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnJlbW92ZSh0LHRoaXMuX3Jvb3QsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2xldCBzPXRoaXMucmVtb3ZlSXRlbShlLG4pO2lmKHMpcmV0dXJuITA7bGV0IGk9bnVsbDtmb3IobGV0IHI9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7Y29uc3QgZT1yLm5leHQoKTtpZih0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoZS5nZXRCb3VuZHMoKSx0KSYmKGUgaW5zdGFuY2VvZiBMcyYmKHM9dGhpcy5yZW1vdmUodCxlLG4pLHMpKSl7aT1lO2JyZWFrfX1yZXR1cm4gbnVsbCE9PWkmJmkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpJiZlLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShpKSxzfX1jcmVhdGVIaWdoZXJMZXZlbHModCxlKXtnLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49dGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSsxKTtyZXR1cm4gMT09PW4uc2l6ZSgpP24uZ2V0KDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKG4sZSsxKX1kZXB0aCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5kZXB0aCh0aGlzLl9yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuIGluc3RhbmNlb2YgTHMpe2NvbnN0IGU9dGhpcy5kZXB0aChuKTtlPnQmJih0PWUpfX1yZXR1cm4gdCsxfX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSl7Zy5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPW5ldyBMO24uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSk7Y29uc3Qgcz1uZXcgTCh0KTt4ZS5zb3J0KHMsdGhpcy5nZXRDb21wYXJhdG9yKCkpO2ZvcihsZXQgdD1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBzPXQubmV4dCgpO3RoaXMubGFzdE5vZGUobikuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuc2l6ZSgpPT09dGhpcy5nZXROb2RlQ2FwYWNpdHkoKSYmbi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKSx0aGlzLmxhc3ROb2RlKG4pLmFkZENoaWxkQm91bmRhYmxlKHMpfXJldHVybiBufWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fYnVpbHQ/dGhpcy5fcm9vdC5pc0VtcHR5KCk6dGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjXX19UHMuSW50ZXJzZWN0c09wPWZ1bmN0aW9uKCl7fSxQcy5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTA7Y2xhc3MgT3N7ZGlzdGFuY2UodCxlKXt9fWNsYXNzIHZzIGV4dGVuZHMgUHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXZzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdnMuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtQcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX1zdGF0aWMgY2VudHJlWCh0KXtyZXR1cm4gdnMuYXZnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WCgpKX1zdGF0aWMgYXZnKHQsZSl7cmV0dXJuKHQrZSkvMn1zdGF0aWMgZ2V0SXRlbXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7bGV0IG49MDtmb3IoOyF0LmlzRW1wdHkoKTspe2NvbnN0IHM9dC5wb2xsKCk7ZVtuXT1zLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbisrfXJldHVybiBlfXN0YXRpYyBjZW50cmVZKHQpe3JldHVybiB2cy5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXModCxlKXtnLmlzVHJ1ZSh0Lmxlbmd0aD4wKTtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKW4uYWRkQWxsKHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHRbc10sZSkpO3JldHVybiBufW5lYXJlc3ROZWlnaGJvdXJLKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXJLKHQsci5QT1NJVElWRV9JTkZJTklUWSxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl07bGV0IG49YXJndW1lbnRzWzFdO2NvbnN0IHM9bmV3IENzO3MuYWRkKHQpO2NvbnN0IGk9bmV3IENzO2Zvcig7IXMuaXNFbXB0eSgpJiZuPj0wOyl7Y29uc3QgdD1zLnBvbGwoKSxyPXQuZ2V0RGlzdGFuY2UoKTtpZihyPj1uKWJyZWFrO2lmKHQuaXNMZWF2ZXMoKSlpZihpLnNpemUoKTxlKWkuYWRkKHQpO2Vsc2V7aS5wZWVrKCkuZ2V0RGlzdGFuY2UoKT5yJiYoaS5wb2xsKCksaS5hZGQodCkpO249aS5wZWVrKCkuZ2V0RGlzdGFuY2UoKX1lbHNlIHQuZXhwYW5kVG9RdWV1ZShzLG4pfXJldHVybiB2cy5nZXRJdGVtcyhpKX19Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IE1zKHQpfXNpemUoKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/c3VwZXIuc2l6ZS5jYWxsKHRoaXMpOnN1cGVyLnNpemUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydCgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE8pKXJldHVybiBzdXBlci5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0LmlzTnVsbCgpKXJldHVybiBudWxsO3N1cGVyLmluc2VydC5jYWxsKHRoaXMsdCxlKX19Z2V0SW50ZXJzZWN0c09wKCl7cmV0dXJuIHZzLmludGVyc2VjdHNPcH12ZXJ0aWNhbFNsaWNlcyh0LGUpe2NvbnN0IG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvZSkpLHM9bmV3IEFycmF5KGUpLmZpbGwobnVsbCksaT10Lml0ZXJhdG9yKCk7Zm9yKGxldCB0PTA7dDxlO3QrKyl7c1t0XT1uZXcgTDtsZXQgZT0wO2Zvcig7aS5oYXNOZXh0KCkmJmU8bjspe2NvbnN0IG49aS5uZXh0KCk7c1t0XS5hZGQobiksZSsrfX1yZXR1cm4gc31xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3VwZXIucXVlcnkuY2FsbCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtzdXBlci5xdWVyeS5jYWxsKHRoaXMsdCxlKX19Z2V0Q29tcGFyYXRvcigpe3JldHVybiB2cy55Q29tcGFyYXRvcn1jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodCxlKXtyZXR1cm4gc3VwZXIuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsdCxlKX1yZW1vdmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHN1cGVyLnJlbW92ZS5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIucmVtb3ZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1kZXB0aCgpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9zdXBlci5kZXB0aC5jYWxsKHRoaXMpOnN1cGVyLmRlcHRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSl7Zy5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL3RoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKSxzPW5ldyBMKHQpO3hlLnNvcnQocyx2cy54Q29tcGFyYXRvcik7Y29uc3QgaT10aGlzLnZlcnRpY2FsU2xpY2VzKHMsTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5zcXJ0KG4pKSkpO3JldHVybiB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMoaSxlKX1uZWFyZXN0TmVpZ2hib3VyKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLE9zKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgUnModGhpcy5nZXRSb290KCksdGhpcy5nZXRSb290KCksdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFJzKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1yLlBPU0lUSVZFX0lORklOSVRZLG49bnVsbDtjb25zdCBzPW5ldyBDcztmb3Iocy5hZGQodCk7IXMuaXNFbXB0eSgpJiZlPjA7KXtjb25zdCB0PXMucG9sbCgpLGk9dC5nZXREaXN0YW5jZSgpO2lmKGk+PWUpYnJlYWs7dC5pc0xlYXZlcygpPyhlPWksbj10KTp0LmV4cGFuZFRvUXVldWUocyxlKX1yZXR1cm4gbnVsbD09PW4/bnVsbDpbbi5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLG4uZ2V0Qm91bmRhYmxlKDEpLmdldEl0ZW0oKV19fWVsc2V7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNFbXB0eSgpfHx0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBScyh0aGlzLmdldFJvb3QoKSx0LmdldFJvb3QoKSxlKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKG4pfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1syXSxlPW5ldyB3cyhhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKSxuPW5ldyBScyh0aGlzLmdldFJvb3QoKSxlLHQpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIobilbMF19aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzJdLGU9YXJndW1lbnRzWzNdLG49bmV3IHdzKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLHM9bmV3IFJzKHRoaXMuZ2V0Um9vdCgpLG4sdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cksocyxlKX19fWlzV2l0aGluRGlzdGFuY2UoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49ci5QT1NJVElWRV9JTkZJTklUWTtjb25zdCBzPW5ldyBDcztmb3Iocy5hZGQodCk7IXMuaXNFbXB0eSgpOyl7Y29uc3QgdD1zLnBvbGwoKSxpPXQuZ2V0RGlzdGFuY2UoKTtpZihpPmUpcmV0dXJuITE7aWYodC5tYXhpbXVtRGlzdGFuY2UoKTw9ZSlyZXR1cm4hMDtpZih0LmlzTGVhdmVzKCkpe2lmKG49aSxuPD1lKXJldHVybiEwfWVsc2UgdC5leHBhbmRUb1F1ZXVlKHMsbil9cmV0dXJuITF9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IFJzKHRoaXMuZ2V0Um9vdCgpLHQuZ2V0Um9vdCgpLGUpO3JldHVybiB0aGlzLmlzV2l0aGluRGlzdGFuY2UocyxuKX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0VzLGNdfX1jbGFzcyBNcyBleHRlbmRzIExze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxNcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXTtMcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWNvbXB1dGVCb3VuZHMoKXtsZXQgdD1udWxsO2ZvcihsZXQgZT10aGlzLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO251bGw9PT10P3Q9bmV3IE8obi5nZXRCb3VuZHMoKSk6dC5leHBhbmRUb0luY2x1ZGUobi5nZXRCb3VuZHMoKSl9cmV0dXJuIHR9fXZzLlNUUnRyZWVOb2RlPU1zLHZzLnhDb21wYXJhdG9yPW5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19Y29tcGFyZSh0LGUpe3JldHVybiBQcy5jb21wYXJlRG91Ymxlcyh2cy5jZW50cmVYKHQuZ2V0Qm91bmRzKCkpLHZzLmNlbnRyZVgoZS5nZXRCb3VuZHMoKSkpfX0sdnMueUNvbXBhcmF0b3I9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX1jb21wYXJlKHQsZSl7cmV0dXJuIFBzLmNvbXBhcmVEb3VibGVzKHZzLmNlbnRyZVkodC5nZXRCb3VuZHMoKSksdnMuY2VudHJlWShlLmdldEJvdW5kcygpKSl9fSx2cy5pbnRlcnNlY3RzT3A9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltJbnRlcnNlY3RzT3BdfWludGVyc2VjdHModCxlKXtyZXR1cm4gdC5pbnRlcnNlY3RzKGUpfX0sdnMuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwO3ZhciBicz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxTVFJ0cmVlOnZzfSksRHM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsa2R0cmVlOmRzLHF1YWR0cmVlOk5zLHN0cnRyZWU6YnN9KTtjb25zdCBBcz1bXCJQb2ludFwiLFwiTXVsdGlQb2ludFwiLFwiTGluZVN0cmluZ1wiLFwiTXVsdGlMaW5lU3RyaW5nXCIsXCJQb2x5Z29uXCIsXCJNdWx0aVBvbHlnb25cIl07Y2xhc3MgRnN7Y29uc3RydWN0b3IodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEN0fXJlYWQodCl7bGV0IGU7ZT1cInN0cmluZ1wiPT10eXBlb2YgdD9KU09OLnBhcnNlKHQpOnQ7Y29uc3Qgbj1lLnR5cGU7aWYoIUdzW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIitlLnR5cGUpO3JldHVybi0xIT09QXMuaW5kZXhPZihuKT9Hc1tuXS5jYWxsKHRoaXMsZS5jb29yZGluYXRlcyk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PW4/R3Nbbl0uY2FsbCh0aGlzLGUuZ2VvbWV0cmllcyk6R3Nbbl0uY2FsbCh0aGlzLGUpfXdyaXRlKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeVR5cGUoKTtpZighcXNbZV0pdGhyb3cgbmV3IEVycm9yKFwiR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gcXNbZV0uY2FsbCh0aGlzLHQpfX1jb25zdCBHcz17RmVhdHVyZTpmdW5jdGlvbih0KXtjb25zdCBlPXt9O2Zvcihjb25zdCBuIGluIHQpZVtuXT10W25dO2lmKHQuZ2VvbWV0cnkpe2NvbnN0IG49dC5nZW9tZXRyeS50eXBlO2lmKCFHc1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrdC50eXBlKTtlLmdlb21ldHJ5PXRoaXMucmVhZCh0Lmdlb21ldHJ5KX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PUdzLmJib3guY2FsbCh0aGlzLHQuYmJveCkpLGV9LEZlYXR1cmVDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9e307aWYodC5mZWF0dXJlcyl7ZS5mZWF0dXJlcz1bXTtmb3IobGV0IG49MDtuPHQuZmVhdHVyZXMubGVuZ3RoOysrbillLmZlYXR1cmVzLnB1c2godGhpcy5yZWFkKHQuZmVhdHVyZXNbbl0pKX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PXRoaXMucGFyc2UuYmJveC5jYWxsKHRoaXMsdC5iYm94KSksZX0sY29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaChuZXcgbShzWzBdLHNbMV0pKX1yZXR1cm4gZX0sYmJveDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhbbmV3IG0odFswXSx0WzFdKSxuZXcgbSh0WzJdLHRbMV0pLG5ldyBtKHRbMl0sdFszXSksbmV3IG0odFswXSx0WzNdKSxuZXcgbSh0WzBdLHRbMV0pXSl9LFBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IG0oLi4udCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpfSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKEdzLlBvaW50LmNhbGwodGhpcyx0W25dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1Hcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsdCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZSl9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChHcy5MaW5lU3RyaW5nLmNhbGwodGhpcyx0W25dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPUdzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyx0WzBdKSxuPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoZSkscz1bXTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoOysrZSl7Y29uc3Qgbj10W2VdLGk9R3MuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLG4pLHI9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhpKTtzLnB1c2gocil9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixzKX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2goR3MuUG9seWdvbi5jYWxsKHRoaXMscykpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKHRoaXMucmVhZChzKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX19LHFzPXtjb29yZGluYXRlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W3QueCx0LnldO3JldHVybiB0LnomJmUucHVzaCh0LnopLHQubSYmZS5wdXNoKHQubSksZX0sUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJue3R5cGU6XCJQb2ludFwiLGNvb3JkaW5hdGVzOnFzLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZSgpKX19LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9cXMuUG9pbnQuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9pbnRcIixjb29yZGluYXRlczplfX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdLG49dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7Kyt0KXtjb25zdCBzPW5bdF07ZS5wdXNoKHFzLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHMpKX1yZXR1cm57dHlwZTpcIkxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPXFzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W10sbj1xcy5MaW5lU3RyaW5nLmNhbGwodGhpcyx0Ll9zaGVsbCk7ZS5wdXNoKG4uY29vcmRpbmF0ZXMpO2ZvcihsZXQgbj0wO248dC5faG9sZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9ob2xlc1tuXSxpPXFzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIlBvbHlnb25cIixjb29yZGluYXRlczplfX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPXFzLlBvbHlnb24uY2FsbCh0aGlzLHMpO2UucHVzaChpLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9cy5nZXRHZW9tZXRyeVR5cGUoKTtlLnB1c2gocXNbaV0uY2FsbCh0aGlzLHMpKX1yZXR1cm57dHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLGdlb21ldHJpZXM6ZX19fTtmdW5jdGlvbiBCcyh0KXtyZXR1cm5bdC54LHQueV19dmFyIFlzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb0pTT05SZWFkZXI6Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEZzKHR8fG5ldyBDdCl9cmVhZCh0KXtyZXR1cm4gdGhpcy5wYXJzZXIucmVhZCh0KX19LEdlb0pTT05Xcml0ZXI6Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnBhcnNlcj1uZXcgRnModGhpcy5nZW9tZXRyeUZhY3RvcnkpfXdyaXRlKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19LE9MM1BhcnNlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBDdCx0aGlzLm9sPWV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBvbCYmb2x9aW5qZWN0KHQsZSxuLHMsaSxyLG8sbCl7dGhpcy5vbD17Z2VvbTp7UG9pbnQ6dCxMaW5lU3RyaW5nOmUsTGluZWFyUmluZzpuLFBvbHlnb246cyxNdWx0aVBvaW50OmksTXVsdGlMaW5lU3RyaW5nOnIsTXVsdGlQb2x5Z29uOm8sR2VvbWV0cnlDb2xsZWN0aW9uOmx9fX1yZWFkKHQpe2NvbnN0IGU9dGhpcy5vbDtyZXR1cm4gdCBpbnN0YW5jZW9mIGUuZ2VvbS5Qb2ludD90aGlzLmNvbnZlcnRGcm9tUG9pbnQodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5MaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTGluZWFyUmluZz90aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLlBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aVBvaW50P3RoaXMuY29udmVydEZyb21NdWx0aVBvaW50KHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlMaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aVBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbj90aGlzLmNvbnZlcnRGcm9tQ29sbGVjdGlvbih0KTp2b2lkIDB9Y29udmVydEZyb21Qb2ludCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IG0oZVswXSxlWzFdKSl9Y29udmVydEZyb21MaW5lU3RyaW5nKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbSh0WzBdLHRbMV0pfSkpKX1jb252ZXJ0RnJvbUxpbmVhclJpbmcodCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBtKHRbMF0sdFsxXSl9KSkpfWNvbnZlcnRGcm9tUG9seWdvbih0KXtjb25zdCBlPXQuZ2V0TGluZWFyUmluZ3MoKTtsZXQgbj1udWxsO2NvbnN0IHM9W107Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IGk9dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcoZVt0XSk7MD09PXQ/bj1pOnMucHVzaChpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLHMpfWNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KXtjb25zdCBlPXQuZ2V0UG9pbnRzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9Y29udmVydEZyb21NdWx0aUxpbmVTdHJpbmcodCl7Y29uc3QgZT10LmdldExpbmVTdHJpbmdzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfWNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpe2NvbnN0IGU9dC5nZXRQb2x5Z29ucygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX1jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCl7Y29uc3QgZT10LmdldEdlb21ldHJpZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWQodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfXdyaXRlKHQpe3JldHVyblwiUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2ludCh0LmdldENvb3JkaW5hdGUoKSk6XCJMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZVN0cmluZyh0KTpcIkxpbmVhclJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lYXJSaW5nKHQpOlwiUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvbHlnb24odCk6XCJNdWx0aVBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2ludCh0KTpcIk11bHRpTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KTpcIk11bHRpUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9seWdvbih0KTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0NvbGxlY3Rpb24odCk6dm9pZCAwfWNvbnZlcnRUb1BvaW50KHQpe3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLlBvaW50KFt0LngsdC55XSl9Y29udmVydFRvTGluZVN0cmluZyh0KXtjb25zdCBlPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKEJzKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5MaW5lU3RyaW5nKGUpfWNvbnZlcnRUb0xpbmVhclJpbmcodCl7Y29uc3QgZT10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChCcyk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTGluZWFyUmluZyhlKX1jb252ZXJ0VG9Qb2x5Z29uKHQpe2NvbnN0IGU9W3QuX3NoZWxsLl9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChCcyldO2ZvcihsZXQgbj0wO248dC5faG9sZXMubGVuZ3RoO24rKyllLnB1c2godC5faG9sZXNbbl0uX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKEJzKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uUG9seWdvbihlKX1jb252ZXJ0VG9NdWx0aVBvaW50KHQpe3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9pbnQodC5nZXRDb29yZGluYXRlcygpLm1hcChCcykpfWNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodC5fZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlMaW5lU3RyaW5nKGUpfWNvbnZlcnRUb011bHRpUG9seWdvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb1BvbHlnb24odC5fZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlQb2x5Z29uKGUpfWNvbnZlcnRUb0NvbGxlY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dO2UucHVzaCh0aGlzLndyaXRlKHMpKX1yZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSxXS1RSZWFkZXI6Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEh0KHR8fG5ldyBDdCl9cmVhZCh0KXtyZXR1cm4gdGhpcy5wYXJzZXIucmVhZCh0KX19LFdLVFdyaXRlcjpXdH0pO2NsYXNzIFZze3N0YXRpYyByZWxhdGl2ZVNpZ24odCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9c3RhdGljIGNvbXBhcmUodCxlLG4pe2lmKGUuZXF1YWxzMkQobikpcmV0dXJuIDA7Y29uc3Qgcz1Wcy5yZWxhdGl2ZVNpZ24oZS54LG4ueCksaT1Wcy5yZWxhdGl2ZVNpZ24oZS55LG4ueSk7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gVnMuY29tcGFyZVZhbHVlKHMsaSk7Y2FzZSAxOnJldHVybiBWcy5jb21wYXJlVmFsdWUoaSxzKTtjYXNlIDI6cmV0dXJuIFZzLmNvbXBhcmVWYWx1ZShpLC1zKTtjYXNlIDM6cmV0dXJuIFZzLmNvbXBhcmVWYWx1ZSgtcyxpKTtjYXNlIDQ6cmV0dXJuIFZzLmNvbXBhcmVWYWx1ZSgtcywtaSk7Y2FzZSA1OnJldHVybiBWcy5jb21wYXJlVmFsdWUoLWksLXMpO2Nhc2UgNjpyZXR1cm4gVnMuY29tcGFyZVZhbHVlKC1pLHMpO2Nhc2UgNzpyZXR1cm4gVnMuY29tcGFyZVZhbHVlKHMsLWkpfXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiaW52YWxpZCBvY3RhbnQgdmFsdWVcIiksMH1zdGF0aWMgY29tcGFyZVZhbHVlKHQsZSl7cmV0dXJuIHQ8MD8tMTp0PjA/MTplPDA/LTE6ZT4wPzE6MH19Y2xhc3MgenN7Y29uc3RydWN0b3IoKXt6cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zZWdTdHJpbmc9bnVsbCx0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLl9zZWdtZW50T2N0YW50PW51bGwsdGhpcy5faXNJbnRlcmlvcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX3NlZ1N0cmluZz10LHRoaXMuY29vcmQ9bmV3IG0oZSksdGhpcy5zZWdtZW50SW5kZXg9bix0aGlzLl9zZWdtZW50T2N0YW50PXMsdGhpcy5faXNJbnRlcmlvcj0hZS5lcXVhbHMyRCh0LmdldENvb3JkaW5hdGUobikpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb29yZH1wcmludCh0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8ZS5zZWdtZW50SW5kZXg/LTE6dGhpcy5zZWdtZW50SW5kZXg+ZS5zZWdtZW50SW5kZXg/MTp0aGlzLmNvb3JkLmVxdWFsczJEKGUuY29vcmQpPzA6dGhpcy5faXNJbnRlcmlvcj9lLl9pc0ludGVyaW9yP1ZzLmNvbXBhcmUodGhpcy5fc2VnbWVudE9jdGFudCx0aGlzLmNvb3JkLGUuY29vcmQpOjE6LTF9aXNFbmRQb2ludCh0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYhdGhpcy5faXNJbnRlcmlvcnx8dGhpcy5zZWdtZW50SW5kZXg9PT10fXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4K1wiOlwiK3RoaXMuY29vcmQudG9TdHJpbmcoKX1pc0ludGVyaW9yKCl7cmV0dXJuIHRoaXMuX2lzSW50ZXJpb3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBrc3tjb25zdHJ1Y3Rvcigpe2tzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVNYXA9bmV3IEhuLHRoaXMuX2VkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlPXR9Z2V0U3BsaXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IFI7dGhpcy5hZGRFbmRwb2ludHMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKTt0aGlzLmFkZEVkZ2VDb29yZGluYXRlcyhuLHMsdCksbj1zfXJldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9YWRkQ29sbGFwc2VkTm9kZXMoKXtjb25zdCB0PW5ldyBMO3RoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpLHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmludFZhbHVlKCk7dGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfX1jcmVhdGVTcGxpdEVkZ2VQdHModCxlKXtsZXQgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyO2lmKDI9PT1uKXJldHVybltuZXcgbSh0LmNvb3JkKSxuZXcgbShlLmNvb3JkKV07Y29uc3Qgcz10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLGk9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBtKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKG4pO3JldHVybiBpJiYocltvXT1uZXcgbShlLmNvb3JkKSkscn1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2Uuc2l6ZSgpLTI7ZSsrKXtjb25zdCBuPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKSxzPSh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsxKSx0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsyKSk7bi5lcXVhbHMyRChzKSYmdC5hZGQoTS52YWx1ZU9mKGUrMSkpfX1hZGRFZGdlQ29vcmRpbmF0ZXModCxlLG4pe2NvbnN0IHM9dGhpcy5jcmVhdGVTcGxpdEVkZ2VQdHModCxlKTtuLmFkZChzLCExKX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9YWRkU3BsaXRFZGdlcyh0KXt0aGlzLmFkZEVuZHBvaW50cygpLHRoaXMuYWRkQ29sbGFwc2VkTm9kZXMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4scyk7dC5hZGQoaSksbj1zfX1maW5kQ29sbGFwc2VJbmRleCh0LGUsbil7aWYoIXQuY29vcmQuZXF1YWxzMkQoZS5jb29yZCkpcmV0dXJuITE7bGV0IHM9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXg7cmV0dXJuIGUuaXNJbnRlcmlvcigpfHxzLS0sMT09PXMmJihuWzBdPXQuc2VnbWVudEluZGV4KzEsITApfWZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyh0KXtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5pdGVyYXRvcigpO2xldCBzPW4ubmV4dCgpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBpPW4ubmV4dCgpO3RoaXMuZmluZENvbGxhcHNlSW5kZXgocyxpLGUpJiZ0LmFkZChNLnZhbHVlT2YoZVswXSkpLHM9aX19Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWFkZEVuZHBvaW50cygpe2NvbnN0IHQ9dGhpcy5fZWRnZS5zaXplKCktMTt0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoMCksMCksdGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfWNyZWF0ZVNwbGl0RWRnZSh0LGUpe2NvbnN0IG49dGhpcy5jcmVhdGVTcGxpdEVkZ2VQdHModCxlKTtyZXR1cm4gbmV3IFdzKG4sdGhpcy5fZWRnZS5nZXREYXRhKCkpfWFkZCh0LGUpe2NvbnN0IG49bmV3IHpzKHRoaXMuX2VkZ2UsdCxlLHRoaXMuX2VkZ2UuZ2V0U2VnbWVudE9jdGFudChlKSkscz10aGlzLl9ub2RlTWFwLmdldChuKTtyZXR1cm4gbnVsbCE9PXM/KGcuaXNUcnVlKHMuY29vcmQuZXF1YWxzMkQodCksXCJGb3VuZCBlcXVhbCBub2RlcyB3aXRoIGRpZmZlcmVudCBjb29yZGluYXRlc1wiKSxzKToodGhpcy5fbm9kZU1hcC5wdXQobixuKSxuKX1jaGVja1NwbGl0RWRnZXNDb3JyZWN0bmVzcyh0KXtjb25zdCBlPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZXMoKSxuPXQuZ2V0KDApLmdldENvb3JkaW5hdGUoMCk7aWYoIW4uZXF1YWxzMkQoZVswXSkpdGhyb3cgbmV3IGgoXCJiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCBcIituKTtjb25zdCBzPXQuZ2V0KHQuc2l6ZSgpLTEpLmdldENvb3JkaW5hdGVzKCksaT1zW3MubGVuZ3RoLTFdO2lmKCFpLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pKXRocm93IG5ldyBoKFwiYmFkIHNwbGl0IGVkZ2UgZW5kIHBvaW50IGF0IFwiK2kpfX1jbGFzcyBYc3tzdGF0aWMgb2N0YW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBzKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7Y29uc3Qgbj1NYXRoLmFicyh0KSxpPU1hdGguYWJzKGUpO3JldHVybiB0Pj0wP2U+PTA/bj49aT8wOjE6bj49aT83OjY6ZT49MD9uPj1pPzM6MjpuPj1pPzQ6NX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1lLngtdC54LGk9ZS55LXQueTtpZigwPT09biYmMD09PWkpdGhyb3cgbmV3IHMoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIit0KTtyZXR1cm4gWHMub2N0YW50KG4saSl9fX1jbGFzcyBVc3tnZXRDb29yZGluYXRlcygpe31zaXplKCl7fWdldENvb3JkaW5hdGUodCl7fWlzQ2xvc2VkKCl7fXNldERhdGEodCl7fWdldERhdGEoKXt9fWNsYXNzIEhze2FkZEludGVyc2VjdGlvbih0LGUpe31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVXNdfX1jbGFzcyBXc3tjb25zdHJ1Y3Rvcigpe1dzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVMaXN0PW5ldyBrcyh0aGlzKSx0aGlzLl9wdHM9bnVsbCx0aGlzLl9kYXRhPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fZGF0YT1lfXN0YXRpYyBnZXROb2RlZFN1YnN0cmluZ3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtyZXR1cm4gV3MuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07Zm9yKGxldCBlPWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKHQpfX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRzfXNpemUoKXtyZXR1cm4gdGhpcy5fcHRzLmxlbmd0aH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHNbdF19aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aC0xXSl9Z2V0U2VnbWVudE9jdGFudCh0KXtyZXR1cm4gdD09PXRoaXMuX3B0cy5sZW5ndGgtMT8tMTp0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1zYWZlT2N0YW50KHQsZSl7cmV0dXJuIHQuZXF1YWxzMkQoZSk/MDpYcy5vY3RhbnQodCxlKX1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9YWRkSW50ZXJzZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzNdLG49bmV3IG0oYXJndW1lbnRzWzBdLmdldEludGVyc2VjdGlvbihlKSk7dGhpcy5hZGRJbnRlcnNlY3Rpb24obix0KX19dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKG5ldyBwdCh0aGlzLl9wdHMpKX1nZXROb2RlTGlzdCgpe3JldHVybiB0aGlzLl9ub2RlTGlzdH1hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl7bGV0IG49ZTtjb25zdCBzPW4rMTtpZihzPHRoaXMuX3B0cy5sZW5ndGgpe2NvbnN0IGU9dGhpcy5fcHRzW3NdO3QuZXF1YWxzMkQoZSkmJihuPXMpfXJldHVybiB0aGlzLl9ub2RlTGlzdC5hZGQodCxuKX1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltIc119fWNsYXNzIFpze2NvbnN0cnVjdG9yKCl7WnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3ZlcmxhcFNlZzE9bmV3IEt0LHRoaXMuX292ZXJsYXBTZWcyPW5ldyBLdH1vdmVybGFwKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdO2FyZ3VtZW50c1swXS5nZXRMaW5lU2VnbWVudCh0LHRoaXMuX292ZXJsYXBTZWcxKSxlLmdldExpbmVTZWdtZW50KG4sdGhpcy5fb3ZlcmxhcFNlZzIpLHRoaXMub3ZlcmxhcCh0aGlzLl9vdmVybGFwU2VnMSx0aGlzLl9vdmVybGFwU2VnMil9fX1jbGFzcyBqc3tjb25zdHJ1Y3Rvcigpe2pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3N0YXJ0PW51bGwsdGhpcy5fZW5kPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5fY29udGV4dD1udWxsLHRoaXMuX2lkPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fcHRzPXQsdGhpcy5fc3RhcnQ9ZSx0aGlzLl9lbmQ9bix0aGlzLl9jb250ZXh0PXN9Z2V0TGluZVNlZ21lbnQodCxlKXtlLnAwPXRoaXMuX3B0c1t0XSxlLnAxPXRoaXMuX3B0c1t0KzFdfWNvbXB1dGVTZWxlY3QodCxlLG4scyl7Y29uc3QgaT10aGlzLl9wdHNbZV0scj10aGlzLl9wdHNbbl07aWYobi1lPT0xKXJldHVybiBzLnNlbGVjdCh0aGlzLGUpLG51bGw7aWYoIXQuaW50ZXJzZWN0cyhpLHIpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygoZStuKS8yKTtlPG8mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LGUsbyxzKSxvPG4mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LG8sbixzKX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2VuZC10aGlzLl9zdGFydCsxKS5maWxsKG51bGwpO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuX3N0YXJ0O248PXRoaXMuX2VuZDtuKyspdFtlKytdPXRoaXMuX3B0c1tuXTtyZXR1cm4gdH1jb21wdXRlT3ZlcmxhcHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5jb21wdXRlT3ZlcmxhcHModGhpcy5fc3RhcnQsdGhpcy5fZW5kLHQsdC5fc3RhcnQsdC5fZW5kLGUpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO2lmKGUtdD09MSYmaS1zPT0xKXJldHVybiByLm92ZXJsYXAodGhpcyx0LG4scyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixsLGkscikpLG88ZSYmKHM8bCYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4sbCxpLHIpKX19c2V0SWQodCl7dGhpcy5faWQ9dH1zZWxlY3QodCxlKXt0aGlzLmNvbXB1dGVTZWxlY3QodCx0aGlzLl9zdGFydCx0aGlzLl9lbmQsZSl9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXtjb25zdCB0PXRoaXMuX3B0c1t0aGlzLl9zdGFydF0sZT10aGlzLl9wdHNbdGhpcy5fZW5kXTt0aGlzLl9lbnY9bmV3IE8odCxlKX1yZXR1cm4gdGhpcy5fZW52fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE8uaW50ZXJzZWN0cyh0aGlzLl9wdHNbdF0sdGhpcy5fcHRzW2VdLG4uX3B0c1tzXSxuLl9wdHNbaV0pfWdldEVuZEluZGV4KCl7cmV0dXJuIHRoaXMuX2VuZH1nZXRTdGFydEluZGV4KCl7cmV0dXJuIHRoaXMuX3N0YXJ0fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fY29udGV4dH1nZXRJZCgpe3JldHVybiB0aGlzLl9pZH19Y2xhc3MgS3N7c3RhdGljIGZpbmRDaGFpbkVuZCh0LGUpe2xldCBuPWU7Zm9yKDtuPHQubGVuZ3RoLTEmJnRbbl0uZXF1YWxzMkQodFtuKzFdKTspbisrO2lmKG4+PXQubGVuZ3RoLTEpcmV0dXJuIHQubGVuZ3RoLTE7Y29uc3Qgcz13bi5xdWFkcmFudCh0W25dLHRbbisxXSk7bGV0IGk9ZSsxO2Zvcig7aTx0Lmxlbmd0aDspe2lmKCF0W2ktMV0uZXF1YWxzMkQodFtpXSkpe2lmKHduLnF1YWRyYW50KHRbaS0xXSx0W2ldKSE9PXMpYnJlYWt9aSsrfXJldHVybiBpLTF9c3RhdGljIGdldENoYWlucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gS3MuZ2V0Q2hhaW5zKHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7bGV0IHM9MDtkb3tjb25zdCBpPUtzLmZpbmRDaGFpbkVuZCh0LHMpLHI9bmV3IGpzKHQscyxpLGUpO24uYWRkKHIpLHM9aX13aGlsZShzPHQubGVuZ3RoLTEpO3JldHVybiBufX19Y2xhc3MgUXN7Y29tcHV0ZU5vZGVzKHQpe31nZXROb2RlZFN1YnN0cmluZ3MoKXt9fWNsYXNzIEpze2NvbnN0cnVjdG9yKCl7SnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc2VnSW50PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0U2VnbWVudEludGVyc2VjdG9yKHQpfX1zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl7dGhpcy5fc2VnSW50PXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1FzXX19Y2xhc3MgJHMgZXh0ZW5kcyBKc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksJHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbW9ub0NoYWlucz1uZXcgTCx0aGlzLl9pbmRleD1uZXcgdnMsdGhpcy5faWRDb3VudGVyPTAsdGhpcy5fbm9kZWRTZWdTdHJpbmdzPW51bGwsdGhpcy5fbk92ZXJsYXBzPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0pzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fWdldE1vbm90b25lQ2hhaW5zKCl7cmV0dXJuIHRoaXMuX21vbm9DaGFpbnN9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7cmV0dXJuIFdzLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpfWdldEluZGV4KCl7cmV0dXJuIHRoaXMuX2luZGV4fWFkZCh0KXtmb3IobGV0IGU9S3MuZ2V0Q2hhaW5zKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldElkKHRoaXMuX2lkQ291bnRlcisrKSx0aGlzLl9pbmRleC5pbnNlcnQodC5nZXRFbnZlbG9wZSgpLHQpLHRoaXMuX21vbm9DaGFpbnMuYWRkKHQpfX1jb21wdXRlTm9kZXModCl7dGhpcy5fbm9kZWRTZWdTdHJpbmdzPXQ7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3RoaXMuaW50ZXJzZWN0Q2hhaW5zKCl9aW50ZXJzZWN0Q2hhaW5zKCl7Y29uc3QgdD1uZXcgdGkodGhpcy5fc2VnSW50KTtmb3IobGV0IGU9dGhpcy5fbW9ub0NoYWlucy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtmb3IobGV0IGU9dGhpcy5faW5kZXgucXVlcnkobi5nZXRFbnZlbG9wZSgpKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKTtpZihzLmdldElkKCk+bi5nZXRJZCgpJiYobi5jb21wdXRlT3ZlcmxhcHMocyx0KSx0aGlzLl9uT3ZlcmxhcHMrKyksdGhpcy5fc2VnSW50LmlzRG9uZSgpKXJldHVybiBudWxsfX19fWNsYXNzIHRpIGV4dGVuZHMgWnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2k9dH1vdmVybGFwKCl7aWYoNCE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHN1cGVyLm92ZXJsYXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXSxzPWFyZ3VtZW50c1swXS5nZXRDb250ZXh0KCksaT1lLmdldENvbnRleHQoKTt0aGlzLl9zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhzLHQsaSxuKX19fSRzLlNlZ21lbnRPdmVybGFwQWN0aW9uPXRpO2NsYXNzIGVpe2NvbnN0cnVjdG9yKCl7ZWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbm9kZXI9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX29mZnNldFg9bnVsbCx0aGlzLl9vZmZzZXRZPW51bGwsdGhpcy5faXNTY2FsZWQ9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2VpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLDAsMCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbm9kZXI9dCx0aGlzLl9zY2FsZUZhY3Rvcj1lLHRoaXMuX2lzU2NhbGVkPSF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpfX1yZXNjYWxlKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5yZXNjYWxlKGUuZ2V0Q29vcmRpbmF0ZXMoKSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXS54PXRbZV0ueC90aGlzLl9zY2FsZUZhY3Rvcit0aGlzLl9vZmZzZXRYLHRbZV0ueT10W2VdLnkvdGhpcy5fc2NhbGVGYWN0b3IrdGhpcy5fb2Zmc2V0WTsyPT09dC5sZW5ndGgmJnRbMF0uZXF1YWxzMkQodFsxXSkmJkIub3V0LnByaW50bG4odCl9fXNjYWxlKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEwodC5zaXplKCkpO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBXcyh0aGlzLnNjYWxlKHQuZ2V0Q29vcmRpbmF0ZXMoKSksdC5nZXREYXRhKCkpKX1yZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllW25dPW5ldyBtKE1hdGgucm91bmQoKHRbbl0ueC10aGlzLl9vZmZzZXRYKSp0aGlzLl9zY2FsZUZhY3RvciksTWF0aC5yb3VuZCgodFtuXS55LXRoaXMuX29mZnNldFkpKnRoaXMuX3NjYWxlRmFjdG9yKSx0W25dLmdldFooKSk7cmV0dXJuIGR0LnJlbW92ZVJlcGVhdGVkUG9pbnRzKGUpfX1pc0ludGVnZXJQcmVjaXNpb24oKXtyZXR1cm4gMT09PXRoaXMuX3NjYWxlRmFjdG9yfWdldE5vZGVkU3Vic3RyaW5ncygpe2NvbnN0IHQ9dGhpcy5fbm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7cmV0dXJuIHRoaXMuX2lzU2NhbGVkJiZ0aGlzLnJlc2NhbGUodCksdH1jb21wdXRlTm9kZXModCl7bGV0IGU9dDt0aGlzLl9pc1NjYWxlZCYmKGU9dGhpcy5zY2FsZSh0KSksdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKGUpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltRc119fXZhciBuaT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxNQ0luZGV4Tm9kZXI6JHMsU2NhbGVkTm9kZXI6ZWksU2VnbWVudFN0cmluZzpVc30pO2NsYXNzIHNpe2NvbnN0cnVjdG9yKCl7c2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbT1udWxsLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fYm5SdWxlPW51bGwsdGhpcy5fZW5kcG9pbnRNYXA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07c2kuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGduLk1PRDJfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbT10LHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpLHRoaXMuX2JuUnVsZT1lfX1zdGF0aWMgZ2V0Qm91bmRhcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBzaShhcmd1bWVudHNbMF0pLmdldEJvdW5kYXJ5KCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgc2koYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkuZ2V0Qm91bmRhcnkoKX19Ym91bmRhcnlNdWx0aUxpbmVTdHJpbmcodCl7aWYodGhpcy5fZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7Y29uc3QgZT10aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpO3JldHVybiAxPT09ZS5sZW5ndGg/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoZVswXSk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoZSl9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5fZ2VvbSBpbnN0YW5jZW9mIEo/dGhpcy5ib3VuZGFyeUxpbmVTdHJpbmcodGhpcy5fZ2VvbSk6dGhpcy5fZ2VvbSBpbnN0YW5jZW9mIHd0P3RoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5fZ2VvbSk6dGhpcy5fZ2VvbS5nZXRCb3VuZGFyeSgpfWJvdW5kYXJ5TGluZVN0cmluZyh0KXtpZih0aGlzLl9nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTtpZih0LmlzQ2xvc2VkKCkpe3JldHVybiB0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KDIpP3QuZ2V0U3RhcnRQb2ludCgpOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX1yZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludChbdC5nZXRTdGFydFBvaW50KCksdC5nZXRFbmRQb2ludCgpXSl9Z2V0RW1wdHlNdWx0aVBvaW50KCl7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX1jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBMO3RoaXMuX2VuZHBvaW50TWFwPW5ldyBIbjtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTswIT09bi5nZXROdW1Qb2ludHMoKSYmKHRoaXMuYWRkRW5kcG9pbnQobi5nZXRDb29yZGluYXRlTigwKSksdGhpcy5hZGRFbmRwb2ludChuLmdldENvb3JkaW5hdGVOKG4uZ2V0TnVtUG9pbnRzKCktMSkpKX1mb3IobGV0IHQ9dGhpcy5fZW5kcG9pbnRNYXAuZW50cnlTZXQoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0VmFsdWUoKS5jb3VudDt0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KHMpJiZlLmFkZChuLmdldEtleSgpKX1yZXR1cm4gZHQudG9Db29yZGluYXRlQXJyYXkoZSl9YWRkRW5kcG9pbnQodCl7bGV0IGU9dGhpcy5fZW5kcG9pbnRNYXAuZ2V0KHQpO251bGw9PT1lJiYoZT1uZXcgaWksdGhpcy5fZW5kcG9pbnRNYXAucHV0KHQsZSkpLGUuY291bnQrK319Y2xhc3MgaWl7Y29uc3RydWN0b3IoKXtpaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmNvdW50PW51bGx9fWNsYXNzIHJpe2NvbnN0cnVjdG9yKCl7cmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSEwLHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hZS5pc0luQm91bmRhcnkoMil9fXN0YXRpYyBpc1NpbXBsZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IHJpKGFyZ3VtZW50c1swXSkuaXNTaW1wbGUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyByaShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5pc1NpbXBsZSgpfX1pc1NpbXBsZU11bHRpUG9pbnQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Y29uc3QgZT1uZXcgbHQ7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obikuZ2V0Q29vcmRpbmF0ZSgpO2lmKGUuY29udGFpbnMocykpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXMsITE7ZS5hZGQocyl9cmV0dXJuITB9aXNTaW1wbGVQb2x5Z29uYWwodCl7Zm9yKGxldCBlPXllLmdldExpbmVzKHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKCF0aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCkpcmV0dXJuITF9cmV0dXJuITB9aGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24odCl7Y29uc3QgZT1uZXcgSG47Zm9yKGxldCBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLHM9dC5pc0Nsb3NlZCgpLGk9dC5nZXRDb29yZGluYXRlKDApO3RoaXMuYWRkRW5kcG9pbnQoZSxpLHMpO2NvbnN0IHI9dC5nZXRDb29yZGluYXRlKHQuZ2V0TnVtUG9pbnRzKCktMSk7dGhpcy5hZGRFbmRwb2ludChlLHIscyl9Zm9yKGxldCB0PWUudmFsdWVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7aWYoZS5pc0Nsb3NlZCYmMiE9PWUuZGVncmVlKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1lLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX1nZXROb25TaW1wbGVMb2NhdGlvbigpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbn1pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO2NvbnN0IGU9bmV3IGxzKDAsdCksbj1uZXcganQscz1lLmNvbXB1dGVTZWxmTm9kZXMobiwhMCk7cmV0dXJuIXMuaGFzSW50ZXJzZWN0aW9uKCl8fChzLmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1zLmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOiF0aGlzLmhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKGUpJiYoIXRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcnx8IXRoaXMuaGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSkpKX1oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldE1heGltdW1TZWdtZW50SW5kZXgoKTtmb3IobGV0IGU9dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKCF0LmlzRW5kUG9pbnQobikpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXQuZ2V0Q29vcmRpbmF0ZSgpLCEwfX1yZXR1cm4hMX1hZGRFbmRwb2ludCh0LGUsbil7bGV0IHM9dC5nZXQoZSk7bnVsbD09PXMmJihzPW5ldyBvaShlKSx0LnB1dChlLHMpKSxzLmFkZEVuZHBvaW50KG4pfWNvbXB1dGVTaW1wbGUodCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsISF0LmlzRW1wdHkoKXx8KHQgaW5zdGFuY2VvZiBKfHx0IGluc3RhbmNlb2Ygd3Q/dGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpOnQgaW5zdGFuY2VvZiBodD90aGlzLmlzU2ltcGxlTXVsdGlQb2ludCh0KTpJKHQsc3QpP3RoaXMuaXNTaW1wbGVQb2x5Z29uYWwodCk6ISh0IGluc3RhbmNlb2YgY3QpfHx0aGlzLmlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpKX1pc1NpbXBsZSgpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLHRoaXMuY29tcHV0ZVNpbXBsZSh0aGlzLl9pbnB1dEdlb20pfWlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmNvbXB1dGVTaW1wbGUobikpcmV0dXJuITF9cmV0dXJuITB9fWNsYXNzIG9pe2NvbnN0cnVjdG9yKCl7b2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5wdD1udWxsLHRoaXMuaXNDbG9zZWQ9bnVsbCx0aGlzLmRlZ3JlZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucHQ9dCx0aGlzLmlzQ2xvc2VkPSExLHRoaXMuZGVncmVlPTB9YWRkRW5kcG9pbnQodCl7dGhpcy5kZWdyZWUrKyx0aGlzLmlzQ2xvc2VkfD10fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5wdH19cmkuRW5kcG9pbnRJbmZvPW9pO2NsYXNzIGxpe2NvbnN0cnVjdG9yKCl7bGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz1saS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTLHRoaXMuX2VuZENhcFN0eWxlPWxpLkNBUF9ST1VORCx0aGlzLl9qb2luU3R5bGU9bGkuSk9JTl9ST1VORCx0aGlzLl9taXRyZUxpbWl0PWxpLkRFRkFVTFRfTUlUUkVfTElNSVQsdGhpcy5faXNTaW5nbGVTaWRlZD0hMSx0aGlzLl9zaW1wbGlmeUZhY3Rvcj1saS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUiwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KSx0aGlzLnNldEVuZENhcFN0eWxlKGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KSx0aGlzLnNldEVuZENhcFN0eWxlKGUpLHRoaXMuc2V0Sm9pblN0eWxlKG4pLHRoaXMuc2V0TWl0cmVMaW1pdChzKX19c3RhdGljIGJ1ZmZlckRpc3RhbmNlRXJyb3IodCl7Y29uc3QgZT1NYXRoLlBJLzIvdDtyZXR1cm4gMS1NYXRoLmNvcyhlLzIpfWdldEVuZENhcFN0eWxlKCl7cmV0dXJuIHRoaXMuX2VuZENhcFN0eWxlfWlzU2luZ2xlU2lkZWQoKXtyZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZH1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX3F1YWRyYW50U2VnbWVudHM9dCwwPT09dGhpcy5fcXVhZHJhbnRTZWdtZW50cyYmKHRoaXMuX2pvaW5TdHlsZT1saS5KT0lOX0JFVkVMKSx0aGlzLl9xdWFkcmFudFNlZ21lbnRzPDAmJih0aGlzLl9qb2luU3R5bGU9bGkuSk9JTl9NSVRSRSx0aGlzLl9taXRyZUxpbWl0PU1hdGguYWJzKHRoaXMuX3F1YWRyYW50U2VnbWVudHMpKSx0PD0wJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz0xKSx0aGlzLl9qb2luU3R5bGUhPT1saS5KT0lOX1JPVU5EJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz1saS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTKX1nZXRKb2luU3R5bGUoKXtyZXR1cm4gdGhpcy5fam9pblN0eWxlfXNldEpvaW5TdHlsZSh0KXt0aGlzLl9qb2luU3R5bGU9dH1zZXRTaW1wbGlmeUZhY3Rvcih0KXt0aGlzLl9zaW1wbGlmeUZhY3Rvcj10PDA/MDp0fWdldFNpbXBsaWZ5RmFjdG9yKCl7cmV0dXJuIHRoaXMuX3NpbXBsaWZ5RmFjdG9yfWdldFF1YWRyYW50U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnRTZWdtZW50c31zZXRFbmRDYXBTdHlsZSh0KXt0aGlzLl9lbmRDYXBTdHlsZT10fWdldE1pdHJlTGltaXQoKXtyZXR1cm4gdGhpcy5fbWl0cmVMaW1pdH1zZXRNaXRyZUxpbWl0KHQpe3RoaXMuX21pdHJlTGltaXQ9dH1zZXRTaW5nbGVTaWRlZCh0KXt0aGlzLl9pc1NpbmdsZVNpZGVkPXR9fWxpLkNBUF9ST1VORD0xLGxpLkNBUF9GTEFUPTIsbGkuQ0FQX1NRVUFSRT0zLGxpLkpPSU5fUk9VTkQ9MSxsaS5KT0lOX01JVFJFPTIsbGkuSk9JTl9CRVZFTD0zLGxpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM9OCxsaS5ERUZBVUxUX01JVFJFX0xJTUlUPTUsbGkuREVGQVVMVF9TSU1QTElGWV9GQUNUT1I9LjAxO2NsYXNzIGFpe2NvbnN0cnVjdG9yKCl7YWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWluSW5kZXg9LTEsdGhpcy5fbWluQ29vcmQ9bnVsbCx0aGlzLl9taW5EZT1udWxsLHRoaXMuX29yaWVudGVkRGU9bnVsbH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX21pbkNvb3JkfWdldFJpZ2h0bW9zdFNpZGUodCxlKXtsZXQgbj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKTtyZXR1cm4gbjwwJiYobj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlLTEpKSxuPDAmJih0aGlzLl9taW5Db29yZD1udWxsLHRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpKSxufWZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKXtjb25zdCB0PXRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2cuaXNUcnVlKHRoaXMuX21pbkluZGV4PjAmJnRoaXMuX21pbkluZGV4PHQubGVuZ3RoLFwicmlnaHRtb3N0IHBvaW50IGV4cGVjdGVkIHRvIGJlIGludGVyaW9yIHZlcnRleCBvZiBlZGdlXCIpO2NvbnN0IGU9dFt0aGlzLl9taW5JbmRleC0xXSxuPXRbdGhpcy5fbWluSW5kZXgrMV0scz1HLmluZGV4KHRoaXMuX21pbkNvb3JkLG4sZSk7bGV0IGk9ITE7KGUueTx0aGlzLl9taW5Db29yZC55JiZuLnk8dGhpcy5fbWluQ29vcmQueSYmcz09PUcuQ09VTlRFUkNMT0NLV0lTRXx8ZS55PnRoaXMuX21pbkNvb3JkLnkmJm4ueT50aGlzLl9taW5Db29yZC55JiZzPT09Ry5DTE9DS1dJU0UpJiYoaT0hMCksaSYmKHRoaXMuX21pbkluZGV4PXRoaXMuX21pbkluZGV4LTEpfWdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKXtjb25zdCBuPXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7aWYoZTwwfHxlKzE+PW4ubGVuZ3RoKXJldHVybi0xO2lmKG5bZV0ueT09PW5bZSsxXS55KXJldHVybi0xO2xldCBzPU1uLkxFRlQ7cmV0dXJuIG5bZV0ueTxuW2UrMV0ueSYmKHM9TW4uUklHSFQpLHN9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9vcmllbnRlZERlfWNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KXtjb25zdCBlPXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aC0xO24rKykobnVsbD09PXRoaXMuX21pbkNvb3JkfHxlW25dLng+dGhpcy5fbWluQ29vcmQueCkmJih0aGlzLl9taW5EZT10LHRoaXMuX21pbkluZGV4PW4sdGhpcy5fbWluQ29vcmQ9ZVtuXSl9ZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKXtjb25zdCB0PXRoaXMuX21pbkRlLmdldE5vZGUoKS5nZXRFZGdlcygpO3RoaXMuX21pbkRlPXQuZ2V0UmlnaHRtb3N0RWRnZSgpLHRoaXMuX21pbkRlLmlzRm9yd2FyZCgpfHwodGhpcy5fbWluRGU9dGhpcy5fbWluRGUuZ2V0U3ltKCksdGhpcy5fbWluSW5kZXg9dGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpfWZpbmRFZGdlKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuaXNGb3J3YXJkKCkmJnRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpfWcuaXNUcnVlKDAhPT10aGlzLl9taW5JbmRleHx8dGhpcy5fbWluQ29vcmQuZXF1YWxzKHRoaXMuX21pbkRlLmdldENvb3JkaW5hdGUoKSksXCJpbmNvbnNpc3RlbmN5IGluIHJpZ2h0bW9zdCBwcm9jZXNzaW5nXCIpLDA9PT10aGlzLl9taW5JbmRleD90aGlzLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCk6dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCksdGhpcy5fb3JpZW50ZWREZT10aGlzLl9taW5EZTt0aGlzLmdldFJpZ2h0bW9zdFNpZGUodGhpcy5fbWluRGUsdGhpcy5fbWluSW5kZXgpPT09TW4uTEVGVCYmKHRoaXMuX29yaWVudGVkRGU9dGhpcy5fbWluRGUuZ2V0U3ltKCkpfX1jbGFzcyBjaXtjb25zdHJ1Y3Rvcigpe3RoaXMuYXJyYXk9W119YWRkTGFzdCh0KXt0aGlzLmFycmF5LnB1c2godCl9cmVtb3ZlRmlyc3QoKXtyZXR1cm4gdGhpcy5hcnJheS5zaGlmdCgpfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuYXJyYXkubGVuZ3RofX1jbGFzcyBoaXtjb25zdHJ1Y3Rvcigpe2hpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZpbmRlcj1udWxsLHRoaXMuX2RpckVkZ2VMaXN0PW5ldyBMLHRoaXMuX25vZGVzPW5ldyBMLHRoaXMuX3JpZ2h0TW9zdENvb3JkPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5fZmluZGVyPW5ldyBhaX1jbGVhclZpc2l0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0VmlzaXRlZCghMSl9fWdldFJpZ2h0bW9zdENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcmlnaHRNb3N0Q29vcmR9Y29tcHV0ZU5vZGVEZXB0aCh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc1Zpc2l0ZWQoKXx8dC5nZXRTeW0oKS5pc1Zpc2l0ZWQoKSl7ZT10O2JyZWFrfX1pZihudWxsPT09ZSl0aHJvdyBuZXcgc3MoXCJ1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKTt0LmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhlKTtmb3IobGV0IGU9dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0VmlzaXRlZCghMCksdGhpcy5jb3B5U3ltRGVwdGhzKHQpfX1jb21wdXRlRGVwdGgodCl7dGhpcy5jbGVhclZpc2l0ZWRFZGdlcygpO2NvbnN0IGU9dGhpcy5fZmluZGVyLmdldEVkZ2UoKTtlLmdldE5vZGUoKSxlLmdldExhYmVsKCk7ZS5zZXRFZGdlRGVwdGhzKE1uLlJJR0hULHQpLHRoaXMuY29weVN5bURlcHRocyhlKSx0aGlzLmNvbXB1dGVEZXB0aHMoZSl9Y3JlYXRlKHQpe3RoaXMuYWRkUmVhY2hhYmxlKHQpLHRoaXMuX2ZpbmRlci5maW5kRWRnZSh0aGlzLl9kaXJFZGdlTGlzdCksdGhpcy5fcmlnaHRNb3N0Q29vcmQ9dGhpcy5fZmluZGVyLmdldENvb3JkaW5hdGUoKX1maW5kUmVzdWx0RWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5nZXREZXB0aChNbi5SSUdIVCk+PTEmJmUuZ2V0RGVwdGgoTW4uTEVGVCk8PTAmJiFlLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZlLnNldEluUmVzdWx0KCEwKX19Y29tcHV0ZURlcHRocyh0KXtjb25zdCBlPW5ldyB4dCxuPW5ldyBjaSxzPXQuZ2V0Tm9kZSgpO2ZvcihuLmFkZExhc3QocyksZS5hZGQocyksdC5zZXRWaXNpdGVkKCEwKTshbi5pc0VtcHR5KCk7KXtjb25zdCB0PW4ucmVtb3ZlRmlyc3QoKTtlLmFkZCh0KSx0aGlzLmNvbXB1dGVOb2RlRGVwdGgodCk7Zm9yKGxldCBzPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKS5nZXRTeW0oKTtpZih0LmlzVmlzaXRlZCgpKWNvbnRpbnVlO2NvbnN0IGk9dC5nZXROb2RlKCk7ZS5jb250YWlucyhpKXx8KG4uYWRkTGFzdChpKSxlLmFkZChpKSl9fX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZC54PGUuX3JpZ2h0TW9zdENvb3JkLng/LTE6dGhpcy5fcmlnaHRNb3N0Q29vcmQueD5lLl9yaWdodE1vc3RDb29yZC54PzE6MH1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe2NvbnN0IHQ9bmV3IE87Zm9yKGxldCBlPXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGgtMTtlKyspdC5leHBhbmRUb0luY2x1ZGUobltlXSl9dGhpcy5fZW52PXR9cmV0dXJuIHRoaXMuX2Vudn1hZGRSZWFjaGFibGUodCl7Y29uc3QgZT1uZXcgZW47Zm9yKGUuYWRkKHQpOyFlLmVtcHR5KCk7KXtjb25zdCB0PWUucG9wKCk7dGhpcy5hZGQodCxlKX19Y29weVN5bURlcHRocyh0KXtjb25zdCBlPXQuZ2V0U3ltKCk7ZS5zZXREZXB0aChNbi5MRUZULHQuZ2V0RGVwdGgoTW4uUklHSFQpKSxlLnNldERlcHRoKE1uLlJJR0hULHQuZ2V0RGVwdGgoTW4uTEVGVCkpfWFkZCh0LGUpe3Quc2V0VmlzaXRlZCghMCksdGhpcy5fbm9kZXMuYWRkKHQpO2ZvcihsZXQgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fZGlyRWRnZUxpc3QuYWRkKHQpO2NvbnN0IHM9dC5nZXRTeW0oKS5nZXROb2RlKCk7cy5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKHMpfX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2Rlc31nZXREaXJlY3RlZEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VMaXN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgdWl7Y29uc3RydWN0b3IoKXt1aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zdGFydERlPW51bGwsdGhpcy5fbWF4Tm9kZURlZ3JlZT0tMSx0aGlzLl9lZGdlcz1uZXcgTCx0aGlzLl9wdHM9bmV3IEwsdGhpcy5fbGFiZWw9bmV3IHFuKFF0Lk5PTkUpLHRoaXMuX3Jpbmc9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9zaGVsbD1udWxsLHRoaXMuX2hvbGVzPW5ldyBMLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLmNvbXB1dGVQb2ludHModCksdGhpcy5jb21wdXRlUmluZygpfX1jb21wdXRlUmluZygpe2lmKG51bGwhPT10aGlzLl9yaW5nKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX3B0cy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wdHMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuX3B0cy5nZXQoZSk7dGhpcy5fcmluZz10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KSx0aGlzLl9pc0hvbGU9Ry5pc0NDVyh0aGlzLl9yaW5nLmdldENvb3JkaW5hdGVzKCkpfWlzSXNvbGF0ZWQoKXtyZXR1cm4gMT09PXRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKX1jb21wdXRlUG9pbnRzKHQpe3RoaXMuX3N0YXJ0RGU9dDtsZXQgZT10LG49ITA7ZG97aWYobnVsbD09PWUpdGhyb3cgbmV3IHNzKFwiRm91bmQgbnVsbCBEaXJlY3RlZEVkZ2VcIik7aWYoZS5nZXRFZGdlUmluZygpPT09dGhpcyl0aHJvdyBuZXcgc3MoXCJEaXJlY3RlZCBFZGdlIHZpc2l0ZWQgdHdpY2UgZHVyaW5nIHJpbmctYnVpbGRpbmcgYXQgXCIrZS5nZXRDb29yZGluYXRlKCkpO3RoaXMuX2VkZ2VzLmFkZChlKTtjb25zdCB0PWUuZ2V0TGFiZWwoKTtnLmlzVHJ1ZSh0LmlzQXJlYSgpKSx0aGlzLm1lcmdlTGFiZWwodCksdGhpcy5hZGRQb2ludHMoZS5nZXRFZGdlKCksZS5pc0ZvcndhcmQoKSxuKSxuPSExLHRoaXMuc2V0RWRnZVJpbmcoZSx0aGlzKSxlPXRoaXMuZ2V0TmV4dChlKX13aGlsZShlIT09dGhpcy5fc3RhcnREZSl9Z2V0TGluZWFyUmluZygpe3JldHVybiB0aGlzLl9yaW5nfWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0cy5nZXQodCl9Y29tcHV0ZU1heE5vZGVEZWdyZWUoKXt0aGlzLl9tYXhOb2RlRGVncmVlPTA7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3tjb25zdCBlPXQuZ2V0Tm9kZSgpLmdldEVkZ2VzKCkuZ2V0T3V0Z29pbmdEZWdyZWUodGhpcyk7ZT50aGlzLl9tYXhOb2RlRGVncmVlJiYodGhpcy5fbWF4Tm9kZURlZ3JlZT1lKSx0PXRoaXMuZ2V0TmV4dCh0KX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSk7dGhpcy5fbWF4Tm9kZURlZ3JlZSo9Mn1hZGRQb2ludHModCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpO2lmKGUpe2xldCB0PTE7biYmKHQ9MCk7Zm9yKGxldCBlPXQ7ZTxzLmxlbmd0aDtlKyspdGhpcy5fcHRzLmFkZChzW2VdKX1lbHNle2xldCB0PXMubGVuZ3RoLTI7biYmKHQ9cy5sZW5ndGgtMSk7Zm9yKGxldCBlPXQ7ZT49MDtlLS0pdGhpcy5fcHRzLmFkZChzW2VdKX19aXNIb2xlKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX1zZXRJblJlc3VsdCgpe2xldCB0PXRoaXMuX3N0YXJ0RGU7ZG97dC5nZXRFZGdlKCkuc2V0SW5SZXN1bHQoITApLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpfWNvbnRhaW5zUG9pbnQodCl7Y29uc3QgZT10aGlzLmdldExpbmVhclJpbmcoKTtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuY29udGFpbnModCkpcmV0dXJuITE7aWYoIVVlLmlzSW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKSlyZXR1cm4hMTtmb3IobGV0IGU9dGhpcy5faG9sZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITF9cmV0dXJuITB9YWRkSG9sZSh0KXt0aGlzLl9ob2xlcy5hZGQodCl9aXNTaGVsbCgpe3JldHVybiBudWxsPT09dGhpcy5fc2hlbGx9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9Z2V0TWF4Tm9kZURlZ3JlZSgpe3JldHVybiB0aGlzLl9tYXhOb2RlRGVncmVlPDAmJnRoaXMuY29tcHV0ZU1heE5vZGVEZWdyZWUoKSx0aGlzLl9tYXhOb2RlRGVncmVlfWdldFNoZWxsKCl7cmV0dXJuIHRoaXMuX3NoZWxsfW1lcmdlTGFiZWwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQsMCksdGhpcy5tZXJnZUxhYmVsKHQsMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0uZ2V0TG9jYXRpb24odCxNbi5SSUdIVCk7aWYoZT09PVF0Lk5PTkUpcmV0dXJuIG51bGw7aWYodGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24odCk9PT1RdC5OT05FKXJldHVybiB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUpLG51bGx9fXNldFNoZWxsKHQpe3RoaXMuX3NoZWxsPXQsbnVsbCE9PXQmJnQuYWRkSG9sZSh0aGlzKX10b1BvbHlnb24odCl7Y29uc3QgZT1uZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMuc2l6ZSgpO3QrKyllW3RdPXRoaXMuX2hvbGVzLmdldCh0KS5nZXRMaW5lYXJSaW5nKCk7cmV0dXJuIHQuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSxlKX19Y2xhc3MgZ2kgZXh0ZW5kcyB1aXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZ2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dWkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfXNldEVkZ2VSaW5nKHQsZSl7dC5zZXRNaW5FZGdlUmluZyhlKX1nZXROZXh0KHQpe3JldHVybiB0LmdldE5leHRNaW4oKX19Y2xhc3MgZGkgZXh0ZW5kcyB1aXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dWkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfWJ1aWxkTWluaW1hbFJpbmdzKCl7Y29uc3QgdD1uZXcgTDtsZXQgZT10aGlzLl9zdGFydERlO2Rve2lmKG51bGw9PT1lLmdldE1pbkVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IGdpKGUsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTt0LmFkZChuKX1lPWUuZ2V0TmV4dCgpfXdoaWxlKGUhPT10aGlzLl9zdGFydERlKTtyZXR1cm4gdH1zZXRFZGdlUmluZyh0LGUpe3Quc2V0RWRnZVJpbmcoZSl9bGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCl7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3t0LmdldE5vZGUoKS5nZXRFZGdlcygpLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0aGlzKSx0PXQuZ2V0TmV4dCgpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKX1nZXROZXh0KHQpe3JldHVybiB0LmdldE5leHQoKX19Y2xhc3MgX2l7Y29uc3RydWN0b3IoKXtfaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9zaGVsbExpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PXR9c3RhdGljIGZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0TGluZWFyUmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCk7bGV0IGk9bi5nZXRDb29yZGluYXRlTigwKSxyPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLGw9ZS5nZXRMaW5lYXJSaW5nKCksYT1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZihhLmVxdWFscyhzKSljb250aW51ZTtpZighYS5jb250YWlucyhzKSljb250aW51ZTtpPWR0LnB0Tm90SW5MaXN0KG4uZ2V0Q29vcmRpbmF0ZXMoKSxsLmdldENvb3JkaW5hdGVzKCkpO2xldCBjPSExO1VlLmlzSW5SaW5nKGksbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09cnx8by5jb250YWlucyhhKSkmJihyPWUsbz1yLmdldExpbmVhclJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfXJldHVybiByfXNvcnRTaGVsbHNBbmRIb2xlcyh0LGUsbil7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc0hvbGUoKT9uLmFkZCh0KTplLmFkZCh0KX19Y29tcHV0ZVBvbHlnb25zKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkudG9Qb2x5Z29uKHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7ZS5hZGQodCl9cmV0dXJuIGV9cGxhY2VGcmVlSG9sZXModCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtpZihudWxsPT09ZS5nZXRTaGVsbCgpKXtjb25zdCBuPV9pLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoZSx0KTtpZihudWxsPT09bil0aHJvdyBuZXcgc3MoXCJ1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbFwiLGUuZ2V0Q29vcmRpbmF0ZSgwKSk7ZS5zZXRTaGVsbChuKX19fWJ1aWxkTWluaW1hbEVkZ2VSaW5ncyh0LGUsbil7Y29uc3Qgcz1uZXcgTDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKTtpZih0LmdldE1heE5vZGVEZWdyZWUoKT4yKXt0LmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9dC5idWlsZE1pbmltYWxSaW5ncygpLGk9dGhpcy5maW5kU2hlbGwocyk7bnVsbCE9PWk/KHRoaXMucGxhY2VQb2x5Z29uSG9sZXMoaSxzKSxlLmFkZChpKSk6bi5hZGRBbGwocyl9ZWxzZSBzLmFkZCh0KX1yZXR1cm4gc31idWlsZE1heGltYWxFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzSW5SZXN1bHQoKSYmdC5nZXRMYWJlbCgpLmlzQXJlYSgpJiZudWxsPT09dC5nZXRFZGdlUmluZygpKXtjb25zdCBuPW5ldyBkaSh0LHRoaXMuX2dlb21ldHJ5RmFjdG9yeSk7ZS5hZGQobiksbi5zZXRJblJlc3VsdCgpfX1yZXR1cm4gZX1wbGFjZVBvbHlnb25Ib2xlcyh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2UuaXNIb2xlKCkmJmUuc2V0U2hlbGwodCl9fWdldFBvbHlnb25zKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVBvbHlnb25zKHRoaXMuX3NoZWxsTGlzdCl9ZmluZFNoZWxsKHQpe2xldCBlPTAsbj1udWxsO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNIb2xlKCl8fChuPXQsZSsrKX1yZXR1cm4gZy5pc1RydWUoZTw9MSxcImZvdW5kIHR3byBzaGVsbHMgaW4gTWluaW1hbEVkZ2VSaW5nIGxpc3RcIiksbn1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodC5nZXRFZGdlRW5kcygpLHQuZ2V0Tm9kZXMoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07b3MubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoZSk7Y29uc3Qgbj10aGlzLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyh0KSxzPW5ldyBMLGk9dGhpcy5idWlsZE1pbmltYWxFZGdlUmluZ3Mobix0aGlzLl9zaGVsbExpc3Qscyk7dGhpcy5zb3J0U2hlbGxzQW5kSG9sZXMoaSx0aGlzLl9zaGVsbExpc3QscyksdGhpcy5wbGFjZUZyZWVIb2xlcyh0aGlzLl9zaGVsbExpc3Qscyl9fX1jbGFzcyBwaXtjb25zdHJ1Y3Rvcigpe3BpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0TGluZT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sPW51bGwsdGhpcy5faXNEZWxldGVkPW51bGwsdGhpcy5fYW5nbGVPcmllbnRhdGlvbj1HLkNPVU5URVJDTE9DS1dJU0U7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRMaW5lPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7cmV0dXJuIG5ldyBwaSh0KS5zaW1wbGlmeShlKX1pc0RlbGV0YWJsZSh0LGUsbixzKXtjb25zdCBpPXRoaXMuX2lucHV0TGluZVt0XSxyPXRoaXMuX2lucHV0TGluZVtlXSxvPXRoaXMuX2lucHV0TGluZVtuXTtyZXR1cm4hIXRoaXMuaXNDb25jYXZlKGkscixvKSYmKCEhdGhpcy5pc1NoYWxsb3coaSxyLG8scykmJnRoaXMuaXNTaGFsbG93U2FtcGxlZChpLHIsdCxuLHMpKX1kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMoKXtsZXQgdD0xLGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSkscz0hMTtmb3IoO248dGhpcy5faW5wdXRMaW5lLmxlbmd0aDspe2xldCBpPSExO3RoaXMuaXNEZWxldGFibGUodCxlLG4sdGhpcy5fZGlzdGFuY2VUb2wpJiYodGhpcy5faXNEZWxldGVkW2VdPXBpLkRFTEVURSxpPSEwLHM9ITApLHQ9aT9uOmUsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKX1yZXR1cm4gc31pc1NoYWxsb3dDb25jYXZpdHkodCxlLG4scyl7aWYoIShHLmluZGV4KHQsZSxuKT09PXRoaXMuX2FuZ2xlT3JpZW50YXRpb24pKXJldHVybiExO3JldHVybiBWLnBvaW50VG9TZWdtZW50KGUsdCxuKTxzfWlzU2hhbGxvd1NhbXBsZWQodCxlLG4scyxpKXtsZXQgcj1NYXRoLnRydW5jKChzLW4pL3BpLk5VTV9QVFNfVE9fQ0hFQ0spO3I8PTAmJihyPTEpO2ZvcihsZXQgbz1uO288cztvKz1yKWlmKCF0aGlzLmlzU2hhbGxvdyh0LGUsdGhpcy5faW5wdXRMaW5lW29dLGkpKXJldHVybiExO3JldHVybiEwfWlzQ29uY2F2ZSh0LGUsbil7cmV0dXJuIEcuaW5kZXgodCxlLG4pPT09dGhpcy5fYW5nbGVPcmllbnRhdGlvbn1zaW1wbGlmeSh0KXt0aGlzLl9kaXN0YW5jZVRvbD1NYXRoLmFicyh0KSx0PDAmJih0aGlzLl9hbmdsZU9yaWVudGF0aW9uPUcuQ0xPQ0tXSVNFKSx0aGlzLl9pc0RlbGV0ZWQ9bmV3IEFycmF5KHRoaXMuX2lucHV0TGluZS5sZW5ndGgpLmZpbGwobnVsbCk7bGV0IGU9ITE7ZG97ZT10aGlzLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpfXdoaWxlKGUpO3JldHVybiB0aGlzLmNvbGxhcHNlTGluZSgpfWZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpe2xldCBlPXQrMTtmb3IoO2U8dGhpcy5faW5wdXRMaW5lLmxlbmd0aCYmdGhpcy5faXNEZWxldGVkW2VdPT09cGkuREVMRVRFOyllKys7cmV0dXJuIGV9aXNTaGFsbG93KHQsZSxuLHMpe3JldHVybiBWLnBvaW50VG9TZWdtZW50KGUsdCxuKTxzfWNvbGxhcHNlTGluZSgpe2NvbnN0IHQ9bmV3IFI7Zm9yKGxldCBlPTA7ZTx0aGlzLl9pbnB1dExpbmUubGVuZ3RoO2UrKyl0aGlzLl9pc0RlbGV0ZWRbZV0hPT1waS5ERUxFVEUmJnQuYWRkKHRoaXMuX2lucHV0TGluZVtlXSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX19cGkuSU5JVD0wLHBpLkRFTEVURT0xLHBpLktFRVA9MSxwaS5OVU1fUFRTX1RPX0NIRUNLPTEwO2NsYXNzIG1pe2NvbnN0cnVjdG9yKCl7bWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRMaXN0PW51bGwsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2U9MCx0aGlzLl9wdExpc3Q9bmV3IEx9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRMaXN0LnRvQXJyYXkobWkuQ09PUkRJTkFURV9BUlJBWV9UWVBFKX1zZXRQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9wcmVjaXNpb25Nb2RlbD10fWFkZFB0KHQpe2NvbnN0IGU9bmV3IG0odCk7aWYodGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoZSksdGhpcy5pc1JlZHVuZGFudChlKSlyZXR1cm4gbnVsbDt0aGlzLl9wdExpc3QuYWRkKGUpfXJldmVyc2UoKXt9YWRkUHRzKHQsZSl7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmFkZFB0KHRbZV0pO2Vsc2UgZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pdGhpcy5hZGRQdCh0W2VdKX1pc1JlZHVuZGFudCh0KXtpZih0aGlzLl9wdExpc3Quc2l6ZSgpPDEpcmV0dXJuITE7Y29uc3QgZT10aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCktMSk7cmV0dXJuIHQuZGlzdGFuY2UoZSk8dGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlfXRvU3RyaW5nKCl7cmV0dXJuKG5ldyBDdCkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpLnRvU3RyaW5nKCl9Y2xvc2VSaW5nKCl7aWYodGhpcy5fcHRMaXN0LnNpemUoKTwxKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IG0odGhpcy5fcHRMaXN0LmdldCgwKSksZT10aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCktMSk7aWYodC5lcXVhbHMoZSkpcmV0dXJuIG51bGw7dGhpcy5fcHRMaXN0LmFkZCh0KX1zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UodCl7dGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlPXR9fW1pLkNPT1JESU5BVEVfQVJSQVlfVFlQRT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKTtjbGFzcyBmaXtjb25zdHJ1Y3Rvcigpe2ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21heEN1cnZlU2VnbWVudEVycm9yPTAsdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtPW51bGwsdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj0xLHRoaXMuX3NlZ0xpc3Q9bnVsbCx0aGlzLl9kaXN0YW5jZT0wLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYnVmUGFyYW1zPW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9zMD1udWxsLHRoaXMuX3MxPW51bGwsdGhpcy5fczI9bnVsbCx0aGlzLl9zZWcwPW5ldyBLdCx0aGlzLl9zZWcxPW5ldyBLdCx0aGlzLl9vZmZzZXQwPW5ldyBLdCx0aGlzLl9vZmZzZXQxPW5ldyBLdCx0aGlzLl9zaWRlPTAsdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fYnVmUGFyYW1zPWUsdGhpcy5fbGk9bmV3IGp0LHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bT1NYXRoLlBJLzIvZS5nZXRRdWFkcmFudFNlZ21lbnRzKCksZS5nZXRRdWFkcmFudFNlZ21lbnRzKCk+PTgmJmUuZ2V0Sm9pblN0eWxlKCk9PT1saS5KT0lOX1JPVU5EJiYodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj1maS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUiksdGhpcy5pbml0KG4pfWFkZE5leHRTZWdtZW50KHQsZSl7aWYodGhpcy5fczA9dGhpcy5fczEsdGhpcy5fczE9dGhpcy5fczIsdGhpcy5fczI9dCx0aGlzLl9zZWcwLnNldENvb3JkaW5hdGVzKHRoaXMuX3MwLHRoaXMuX3MxKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzAsdGhpcy5fc2lkZSx0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQwKSx0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHRoaXMuX3MxLHRoaXMuX3MyKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsdGhpcy5fc2lkZSx0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQxKSx0aGlzLl9zMS5lcXVhbHModGhpcy5fczIpKXJldHVybiBudWxsO2NvbnN0IG49Ry5pbmRleCh0aGlzLl9zMCx0aGlzLl9zMSx0aGlzLl9zMikscz1uPT09Ry5DTE9DS1dJU0UmJnRoaXMuX3NpZGU9PT1Nbi5MRUZUfHxuPT09Ry5DT1VOVEVSQ0xPQ0tXSVNFJiZ0aGlzLl9zaWRlPT09TW4uUklHSFQ7MD09PW4/dGhpcy5hZGRDb2xsaW5lYXIoZSk6cz90aGlzLmFkZE91dHNpZGVUdXJuKG4sZSk6dGhpcy5hZGRJbnNpZGVUdXJuKG4sZSl9YWRkTGluZUVuZENhcCh0LGUpe2NvbnN0IG49bmV3IEt0KHQsZSkscz1uZXcgS3Q7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLE1uLkxFRlQsdGhpcy5fZGlzdGFuY2Uscyk7Y29uc3QgaT1uZXcgS3Q7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLE1uLlJJR0hULHRoaXMuX2Rpc3RhbmNlLGkpO2NvbnN0IHI9ZS54LXQueCxvPWUueS10LnksbD1NYXRoLmF0YW4yKG8scik7c3dpdGNoKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIGxpLkNBUF9ST1VORDp0aGlzLl9zZWdMaXN0LmFkZFB0KHMucDEpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQoZSxsK01hdGguUEkvMixsLU1hdGguUEkvMixHLkNMT0NLV0lTRSx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5hZGRQdChpLnAxKTticmVhaztjYXNlIGxpLkNBUF9GTEFUOnRoaXMuX3NlZ0xpc3QuYWRkUHQocy5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdChpLnAxKTticmVhaztjYXNlIGxpLkNBUF9TUVVBUkU6Y29uc3QgdD1uZXcgbTt0Lng9TWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKk1hdGguY29zKGwpLHQueT1NYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkqTWF0aC5zaW4obCk7Y29uc3Qgbj1uZXcgbShzLnAxLngrdC54LHMucDEueSt0LnkpLHI9bmV3IG0oaS5wMS54K3QueCxpLnAxLnkrdC55KTt0aGlzLl9zZWdMaXN0LmFkZFB0KG4pLHRoaXMuX3NlZ0xpc3QuYWRkUHQocil9fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3NlZ0xpc3QuZ2V0Q29vcmRpbmF0ZXMoKX1hZGRNaXRyZUpvaW4odCxlLG4scyl7Y29uc3QgaT1xLmludGVyc2VjdGlvbihlLnAwLGUucDEsbi5wMCxuLnAxKTtpZihudWxsIT09aSl7aWYoKHM8PTA/MTppLmRpc3RhbmNlKHQpL01hdGguYWJzKHMpKTw9dGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSlyZXR1cm4gdGhpcy5fc2VnTGlzdC5hZGRQdChpKSxudWxsfXRoaXMuYWRkTGltaXRlZE1pdHJlSm9pbihlLG4scyx0aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKX1hZGRPdXRzaWRlVHVybih0LGUpe2lmKHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCk8dGhpcy5fZGlzdGFuY2UqZmkuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1IpcmV0dXJuIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksbnVsbDt0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1saS5KT0lOX01JVFJFP3RoaXMuYWRkTWl0cmVKb2luKHRoaXMuX3MxLHRoaXMuX29mZnNldDAsdGhpcy5fb2Zmc2V0MSx0aGlzLl9kaXN0YW5jZSk6dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09bGkuSk9JTl9CRVZFTD90aGlzLmFkZEJldmVsSm9pbih0aGlzLl9vZmZzZXQwLHRoaXMuX29mZnNldDEpOihlJiZ0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuYWRkQ29ybmVyRmlsbGV0KHRoaXMuX3MxLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx0LHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApKX1jcmVhdGVTcXVhcmUodCl7dGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngrdGhpcy5fZGlzdGFuY2UsdC55K3RoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngrdGhpcy5fZGlzdGFuY2UsdC55LXRoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngtdGhpcy5fZGlzdGFuY2UsdC55LXRoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgbSh0LngtdGhpcy5fZGlzdGFuY2UsdC55K3RoaXMuX2Rpc3RhbmNlKSksdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1hZGRTZWdtZW50cyh0LGUpe3RoaXMuX3NlZ0xpc3QuYWRkUHRzKHQsZSl9YWRkRmlyc3RTZWdtZW50KCl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKX1hZGRDb3JuZXJGaWxsZXQodCxlLG4scyxpKXtjb25zdCByPWUueC10Lngsbz1lLnktdC55O2xldCBsPU1hdGguYXRhbjIobyxyKTtjb25zdCBhPW4ueC10LngsYz1uLnktdC55LGg9TWF0aC5hdGFuMihjLGEpO3M9PT1HLkNMT0NLV0lTRT9sPD1oJiYobCs9MipNYXRoLlBJKTpsPj1oJiYobC09MipNYXRoLlBJKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQodCxsLGgscyxpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG4pfWFkZExhc3RTZWdtZW50KCl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAxKX1pbml0U2lkZVNlZ21lbnRzKHQsZSxuKXt0aGlzLl9zMT10LHRoaXMuX3MyPWUsdGhpcy5fc2lkZT1uLHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModCxlKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsbix0aGlzLl9kaXN0YW5jZSx0aGlzLl9vZmZzZXQxKX1hZGRMaW1pdGVkTWl0cmVKb2luKHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5fc2VnMC5wMSxyPSR0LmFuZ2xlKGksdGhpcy5fc2VnMC5wMCksbz0kdC5hbmdsZUJldHdlZW5PcmllbnRlZCh0aGlzLl9zZWcwLnAwLGksdGhpcy5fc2VnMS5wMSkvMixsPSR0Lm5vcm1hbGl6ZShyK28pLGE9JHQubm9ybWFsaXplKGwrTWF0aC5QSSksYz1zKm4saD1uLWMqTWF0aC5hYnMoTWF0aC5zaW4obykpLHU9aS54K2MqTWF0aC5jb3MoYSksZz1pLnkrYypNYXRoLnNpbihhKSxkPW5ldyBtKHUsZyksXz1uZXcgS3QoaSxkKSxwPV8ucG9pbnRBbG9uZ09mZnNldCgxLGgpLGY9Xy5wb2ludEFsb25nT2Zmc2V0KDEsLWgpO3RoaXMuX3NpZGU9PT1Nbi5MRUZUPyh0aGlzLl9zZWdMaXN0LmFkZFB0KHApLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZikpOih0aGlzLl9zZWdMaXN0LmFkZFB0KGYpLHRoaXMuX3NlZ0xpc3QuYWRkUHQocCkpfWFkZERpcmVjdGVkRmlsbGV0KHQsZSxuLHMsaSl7Y29uc3Qgcj1zPT09Ry5DTE9DS1dJU0U/LTE6MSxvPU1hdGguYWJzKGUtbiksbD1NYXRoLnRydW5jKG8vdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtKy41KTtpZihsPDEpcmV0dXJuIG51bGw7Y29uc3QgYT1vL2wsYz1uZXcgbTtmb3IobGV0IG49MDtuPGw7bisrKXtjb25zdCBzPWUrcipuKmE7Yy54PXQueCtpKk1hdGguY29zKHMpLGMueT10LnkraSpNYXRoLnNpbihzKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGMpfX1jb21wdXRlT2Zmc2V0U2VnbWVudCh0LGUsbixzKXtjb25zdCBpPWU9PT1Nbi5MRUZUPzE6LTEscj10LnAxLngtdC5wMC54LG89dC5wMS55LXQucDAueSxsPU1hdGguc3FydChyKnIrbypvKSxhPWkqbipyL2wsYz1pKm4qby9sO3MucDAueD10LnAwLngtYyxzLnAwLnk9dC5wMC55K2Escy5wMS54PXQucDEueC1jLHMucDEueT10LnAxLnkrYX1hZGRJbnNpZGVUdXJuKHQsZSl7aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9vZmZzZXQwLnAwLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx0aGlzLl9vZmZzZXQxLnAxKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSl0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKSk7ZWxzZSBpZih0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITAsdGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKTx0aGlzLl9kaXN0YW5jZSpmaS5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtlbHNle2lmKHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj4wKXtjb25zdCB0PW5ldyBtKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDAucDEueCt0aGlzLl9zMS54KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQwLnAxLnkrdGhpcy5fczEueSkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQodCk7Y29uc3QgZT1uZXcgbSgodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQxLnAwLngrdGhpcy5fczEueCkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MS5wMC55K3RoaXMuX3MxLnkpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLl9zZWdMaXN0LmFkZFB0KGUpfWVsc2UgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9zMSk7dGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKX19Y3JlYXRlQ2lyY2xlKHQpe2NvbnN0IGU9bmV3IG0odC54K3RoaXMuX2Rpc3RhbmNlLHQueSk7dGhpcy5fc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KHQsMCwyKk1hdGguUEksLTEsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9YWRkQmV2ZWxKb2luKHQsZSl7dGhpcy5fc2VnTGlzdC5hZGRQdCh0LnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGUucDApfWluaXQodCl7dGhpcy5fZGlzdGFuY2U9dCx0aGlzLl9tYXhDdXJ2ZVNlZ21lbnRFcnJvcj10KigxLU1hdGguY29zKHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bS8yKSksdGhpcy5fc2VnTGlzdD1uZXcgbWksdGhpcy5fc2VnTGlzdC5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9wcmVjaXNpb25Nb2RlbCksdGhpcy5fc2VnTGlzdC5zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UodCpmaS5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpfWFkZENvbGxpbmVhcih0KXt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX3MwLHRoaXMuX3MxLHRoaXMuX3MxLHRoaXMuX3MyKTt0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKT49MiYmKHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWxpLkpPSU5fQkVWRUx8fHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWxpLkpPSU5fTUlUUkU/KHQmJnRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKSk6dGhpcy5hZGRDb3JuZXJGaWxsZXQodGhpcy5fczEsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLEcuQ0xPQ0tXSVNFLHRoaXMuX2Rpc3RhbmNlKSl9Y2xvc2VSaW5nKCl7dGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1oYXNOYXJyb3dDb25jYXZlQW5nbGUoKXtyZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlfX1maS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj0uMDAxLGZpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0uMDAxLGZpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0xZS02LGZpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SPTgwO2NsYXNzIHlpe2NvbnN0cnVjdG9yKCl7eWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZGlzdGFuY2U9MCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2J1ZlBhcmFtcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fYnVmUGFyYW1zPWV9c3RhdGljIGNvcHlDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPW5ldyBtKHRbbl0pO3JldHVybiBlfWdldE9mZnNldEN1cnZlKHQsZSl7aWYodGhpcy5fZGlzdGFuY2U9ZSwwPT09ZSlyZXR1cm4gbnVsbDtjb25zdCBuPWU8MCxzPU1hdGguYWJzKGUpLGk9dGhpcy5nZXRTZWdHZW4ocyk7dC5sZW5ndGg8PTE/dGhpcy5jb21wdXRlUG9pbnRDdXJ2ZSh0WzBdLGkpOnRoaXMuY29tcHV0ZU9mZnNldEN1cnZlKHQsbixpKTtjb25zdCByPWkuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gbiYmZHQucmV2ZXJzZShyKSxyfWNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe24uYWRkU2VnbWVudHModCwhMCk7Y29uc3QgZT1waS5zaW1wbGlmeSh0LC1zKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbaV0sZVtpLTFdLE1uLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PWktMjt0Pj0wO3QtLSluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTtjb25zdCBlPXBpLnNpbXBsaWZ5KHQscyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlWzBdLGVbMV0sTW4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfW4uYWRkTGFzdFNlZ21lbnQoKSxuLmNsb3NlUmluZygpfWNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLG4pe2xldCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2U9PT1Nbi5SSUdIVCYmKHM9LXMpO2NvbnN0IGk9cGkuc2ltcGxpZnkodCxzKSxyPWkubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGlbci0xXSxpWzBdLGUpO2ZvcihsZXQgdD0xO3Q8PXI7dCsrKXtjb25zdCBlPTEhPT10O24uYWRkTmV4dFNlZ21lbnQoaVt0XSxlKX1uLmNsb3NlUmluZygpfWNvbXB1dGVMaW5lQnVmZmVyQ3VydmUodCxlKXtjb25zdCBuPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpLHM9cGkuc2ltcGxpZnkodCxuKSxpPXMubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKHNbMF0sc1sxXSxNbi5MRUZUKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyllLmFkZE5leHRTZWdtZW50KHNbdF0sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAoc1tpLTFdLHNbaV0pO2NvbnN0IHI9cGkuc2ltcGxpZnkodCwtbiksbz1yLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhyW29dLHJbby0xXSxNbi5MRUZUKTtmb3IobGV0IHQ9by0yO3Q+PTA7dC0tKWUuYWRkTmV4dFNlZ21lbnQoclt0XSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChyWzFdLHJbMF0pLGUuY2xvc2VSaW5nKCl9Y29tcHV0ZVBvaW50Q3VydmUodCxlKXtzd2l0Y2godGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgbGkuQ0FQX1JPVU5EOmUuY3JlYXRlQ2lyY2xlKHQpO2JyZWFrO2Nhc2UgbGkuQ0FQX1NRVUFSRTplLmNyZWF0ZVNxdWFyZSh0KX19Z2V0TGluZUN1cnZlKHQsZSl7aWYodGhpcy5fZGlzdGFuY2U9ZSx0aGlzLmlzTGluZU9mZnNldEVtcHR5KGUpKXJldHVybiBudWxsO2NvbnN0IG49TWF0aC5hYnMoZSkscz10aGlzLmdldFNlZ0dlbihuKTtpZih0Lmxlbmd0aDw9MSl0aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0scyk7ZWxzZSBpZih0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXtjb25zdCBuPWU8MDt0aGlzLmNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsbixzKX1lbHNlIHRoaXMuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LHMpO3JldHVybiBzLmdldENvb3JkaW5hdGVzKCl9Z2V0QnVmZmVyUGFyYW1ldGVycygpe3JldHVybiB0aGlzLl9idWZQYXJhbXN9c2ltcGxpZnlUb2xlcmFuY2UodCl7cmV0dXJuIHQqdGhpcy5fYnVmUGFyYW1zLmdldFNpbXBsaWZ5RmFjdG9yKCl9Z2V0UmluZ0N1cnZlKHQsZSxuKXtpZih0aGlzLl9kaXN0YW5jZT1uLHQubGVuZ3RoPD0yKXJldHVybiB0aGlzLmdldExpbmVDdXJ2ZSh0LG4pO2lmKDA9PT1uKXJldHVybiB5aS5jb3B5Q29vcmRpbmF0ZXModCk7Y29uc3Qgcz10aGlzLmdldFNlZ0dlbihuKTtyZXR1cm4gdGhpcy5jb21wdXRlUmluZ0J1ZmZlckN1cnZlKHQsZSxzKSxzLmdldENvb3JkaW5hdGVzKCl9Y29tcHV0ZU9mZnNldEN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe2NvbnN0IGU9cGkuc2ltcGxpZnkodCwtcyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlW2ldLGVbaS0xXSxNbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD1pLTI7dD49MDt0LS0pbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1lbHNle2NvbnN0IGU9cGkuc2ltcGxpZnkodCxzKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbMF0sZVsxXSxNbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpfWlzTGluZU9mZnNldEVtcHR5KHQpe3JldHVybiAwPT09dHx8dDwwJiYhdGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKX1nZXRTZWdHZW4odCl7cmV0dXJuIG5ldyBmaSh0aGlzLl9wcmVjaXNpb25Nb2RlbCx0aGlzLl9idWZQYXJhbXMsdCl9fWNsYXNzIHhpe2NvbnN0cnVjdG9yKCl7eGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3ViZ3JhcGhzPW51bGwsdGhpcy5fc2VnPW5ldyBLdDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJncmFwaHM9dH1maW5kU3RhYmJlZFNlZ21lbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7Zm9yKGxldCBuPXRoaXMuX3N1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0RW52ZWxvcGUoKTt0Lnk8aS5nZXRNaW5ZKCl8fHQueT5pLmdldE1heFkoKXx8dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQscy5nZXREaXJlY3RlZEVkZ2VzKCksZSl9cmV0dXJuIGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoSShhcmd1bWVudHNbMl0sdykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBpcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgaT0wO2k8cy5sZW5ndGgtMTtpKyspe3RoaXMuX3NlZy5wMD1zW2ldLHRoaXMuX3NlZy5wMT1zW2krMV0sdGhpcy5fc2VnLnAwLnk+dGhpcy5fc2VnLnAxLnkmJnRoaXMuX3NlZy5yZXZlcnNlKCk7aWYoTWF0aC5tYXgodGhpcy5fc2VnLnAwLngsdGhpcy5fc2VnLnAxLngpPHQueCljb250aW51ZTtpZih0aGlzLl9zZWcuaXNIb3Jpem9udGFsKCkpY29udGludWU7aWYodC55PHRoaXMuX3NlZy5wMC55fHx0Lnk+dGhpcy5fc2VnLnAxLnkpY29udGludWU7aWYoRy5pbmRleCh0aGlzLl9zZWcucDAsdGhpcy5fc2VnLnAxLHQpPT09Ry5SSUdIVCljb250aW51ZTtsZXQgcj1lLmdldERlcHRoKE1uLkxFRlQpO3RoaXMuX3NlZy5wMC5lcXVhbHMoc1tpXSl8fChyPWUuZ2V0RGVwdGgoTW4uUklHSFQpKTtjb25zdCBvPW5ldyBFaSh0aGlzLl9zZWcscik7bi5hZGQobyl9fWVsc2UgaWYoSShhcmd1bWVudHNbMl0sdykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmSShhcmd1bWVudHNbMV0sdykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdO2ZvcihsZXQgbj1hcmd1bWVudHNbMV0uaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5pc0ZvcndhcmQoKSYmdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQscyxlKX19fWdldERlcHRoKHQpe2NvbnN0IGU9dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQpO2lmKDA9PT1lLnNpemUoKSlyZXR1cm4gMDtyZXR1cm4geGUubWluKGUpLl9sZWZ0RGVwdGh9fWNsYXNzIEVpe2NvbnN0cnVjdG9yKCl7RWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdXB3YXJkU2VnPW51bGwsdGhpcy5fbGVmdERlcHRoPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdXB3YXJkU2VnPW5ldyBLdCh0KSx0aGlzLl9sZWZ0RGVwdGg9ZX1jb21wYXJlVG8odCl7Y29uc3QgZT10O2lmKHRoaXMuX3Vwd2FyZFNlZy5taW5YKCk+PWUuX3Vwd2FyZFNlZy5tYXhYKCkpcmV0dXJuIDE7aWYodGhpcy5fdXB3YXJkU2VnLm1heFgoKTw9ZS5fdXB3YXJkU2VnLm1pblgoKSlyZXR1cm4tMTtsZXQgbj10aGlzLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleChlLl91cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KHRoaXMuX3Vwd2FyZFNlZyksMCE9PW4/bjp0aGlzLl91cHdhcmRTZWcuY29tcGFyZVRvKGUuX3Vwd2FyZFNlZykpfWNvbXBhcmVYKHQsZSl7Y29uc3Qgbj10LnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0LnAxLmNvbXBhcmVUbyhlLnAxKX10b1N0cmluZygpe3JldHVybiB0aGlzLl91cHdhcmRTZWcudG9TdHJpbmcoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fXhpLkRlcHRoU2VnbWVudD1FaTtjbGFzcyBJaXtjb25zdHJ1Y3Rvcigpe0lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5fY3VydmVCdWlsZGVyPW51bGwsdGhpcy5fY3VydmVMaXN0PW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2Rpc3RhbmNlPWUsdGhpcy5fY3VydmVCdWlsZGVyPW59YWRkUmluZ1NpZGUodCxlLG4scyxpKXtpZigwPT09ZSYmdC5sZW5ndGg8dXQuTUlOSU1VTV9WQUxJRF9TSVpFKXJldHVybiBudWxsO2xldCByPXMsbz1pO3QubGVuZ3RoPj11dC5NSU5JTVVNX1ZBTElEX1NJWkUmJkcuaXNDQ1codCkmJihyPWksbz1zLG49TW4ub3Bwb3NpdGUobikpO2NvbnN0IGw9dGhpcy5fY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZSh0LG4sZSk7dGhpcy5hZGRDdXJ2ZShsLHIsbyl9YWRkUmluZ0JvdGhTaWRlcyh0LGUpe3RoaXMuYWRkUmluZ1NpZGUodCxlLE1uLkxFRlQsUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpLHRoaXMuYWRkUmluZ1NpZGUodCxlLE1uLlJJR0hULFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SKX1hZGRQb2ludCh0KXtpZih0aGlzLl9kaXN0YW5jZTw9MClyZXR1cm4gbnVsbDtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPXRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLl9kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKX1hZGRQb2x5Z29uKHQpe2xldCBlPXRoaXMuX2Rpc3RhbmNlLG49TW4uTEVGVDt0aGlzLl9kaXN0YW5jZTwwJiYoZT0tdGhpcy5fZGlzdGFuY2Usbj1Nbi5SSUdIVCk7Y29uc3Qgcz10LmdldEV4dGVyaW9yUmluZygpLGk9ZHQucmVtb3ZlUmVwZWF0ZWRQb2ludHMocy5nZXRDb29yZGluYXRlcygpKTtpZih0aGlzLl9kaXN0YW5jZTwwJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShzLHRoaXMuX2Rpc3RhbmNlKSlyZXR1cm4gbnVsbDtpZih0aGlzLl9kaXN0YW5jZTw9MCYmaS5sZW5ndGg8MylyZXR1cm4gbnVsbDt0aGlzLmFkZFJpbmdTaWRlKGksZSxuLFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKTtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXtjb25zdCBpPXQuZ2V0SW50ZXJpb3JSaW5nTihzKSxyPWR0LnJlbW92ZVJlcGVhdGVkUG9pbnRzKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fZGlzdGFuY2U+MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkoaSwtdGhpcy5fZGlzdGFuY2UpfHx0aGlzLmFkZFJpbmdTaWRlKHIsZSxNbi5vcHBvc2l0ZShuKSxRdC5JTlRFUklPUixRdC5FWFRFUklPUil9fWlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KHQsZSl7Y29uc3Qgbj1uZXcgbmUodFswXSx0WzFdLHRbMl0pLHM9bi5pbkNlbnRyZSgpO3JldHVybiBWLnBvaW50VG9TZWdtZW50KHMsbi5wMCxuLnAxKTxNYXRoLmFicyhlKX1hZGRMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2N1cnZlQnVpbGRlci5pc0xpbmVPZmZzZXRFbXB0eSh0aGlzLl9kaXN0YW5jZSkpcmV0dXJuIG51bGw7Y29uc3QgZT1kdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGR0LmlzUmluZyhlKSYmIXRoaXMuX2N1cnZlQnVpbGRlci5nZXRCdWZmZXJQYXJhbWV0ZXJzKCkuaXNTaW5nbGVTaWRlZCgpKXRoaXMuYWRkUmluZ0JvdGhTaWRlcyhlLHRoaXMuX2Rpc3RhbmNlKTtlbHNle2NvbnN0IHQ9dGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuX2Rpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKHQsUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpfX1hZGRDdXJ2ZSh0LGUsbil7aWYobnVsbD09PXR8fHQubGVuZ3RoPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz1uZXcgV3ModCxuZXcgcW4oMCxRdC5CT1VOREFSWSxlLG4pKTt0aGlzLl9jdXJ2ZUxpc3QuYWRkKHMpfWdldEN1cnZlcygpe3JldHVybiB0aGlzLmFkZCh0aGlzLl9pbnB1dEdlb20pLHRoaXMuX2N1cnZlTGlzdH1hZGQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIGl0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBKKXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB0dCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGh0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiB3dCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgY3QpKXRocm93IG5ldyBqKHQuZ2V0R2VvbWV0cnlUeXBlKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19aXNFcm9kZWRDb21wbGV0ZWx5KHQsZSl7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCk7aWYobi5sZW5ndGg8NClyZXR1cm4gZTwwO2lmKDQ9PT1uLmxlbmd0aClyZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShuLGUpO2NvbnN0IHM9dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1NYXRoLm1pbihzLmdldEhlaWdodCgpLHMuZ2V0V2lkdGgoKSk7cmV0dXJuIGU8MCYmMipNYXRoLmFicyhlKT5pfWFkZENvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fX1jbGFzcyBOaXtjb25zdHJ1Y3Rvcigpe05pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2VkZ2VNYXA9bmV3IEhuLHRoaXMuX2VkZ2VMaXN0PW51bGwsdGhpcy5fcHRJbkFyZWFMb2NhdGlvbj1bUXQuTk9ORSxRdC5OT05FXX1nZXROZXh0Q1codCl7dGhpcy5nZXRFZGdlcygpO2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuaW5kZXhPZih0KTtsZXQgbj1lLTE7cmV0dXJuIDA9PT1lJiYobj10aGlzLl9lZGdlTGlzdC5zaXplKCktMSksdGhpcy5fZWRnZUxpc3QuZ2V0KG4pfXByb3BhZ2F0ZVNpZGVMYWJlbHModCl7bGV0IGU9UXQuTk9ORTtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKS5nZXRMYWJlbCgpO3MuaXNBcmVhKHQpJiZzLmdldExvY2F0aW9uKHQsTW4uTEVGVCkhPT1RdC5OT05FJiYoZT1zLmdldExvY2F0aW9uKHQsTW4uTEVGVCkpfWlmKGU9PT1RdC5OT05FKXJldHVybiBudWxsO2xldCBuPWU7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT1zLmdldExhYmVsKCk7aWYoaS5nZXRMb2NhdGlvbih0LE1uLk9OKT09PVF0Lk5PTkUmJmkuc2V0TG9jYXRpb24odCxNbi5PTixuKSxpLmlzQXJlYSh0KSl7Y29uc3QgZT1pLmdldExvY2F0aW9uKHQsTW4uTEVGVCkscj1pLmdldExvY2F0aW9uKHQsTW4uUklHSFQpO2lmKHIhPT1RdC5OT05FKXtpZihyIT09bil0aHJvdyBuZXcgc3MoXCJzaWRlIGxvY2F0aW9uIGNvbmZsaWN0XCIscy5nZXRDb29yZGluYXRlKCkpO2U9PT1RdC5OT05FJiZnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZSAoYXQgXCIrcy5nZXRDb29yZGluYXRlKCkrXCIpXCIpLG49ZX1lbHNlIGcuaXNUcnVlKGkuZ2V0TG9jYXRpb24odCxNbi5MRUZUKT09PVF0Lk5PTkUsXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlXCIpLGkuc2V0TG9jYXRpb24odCxNbi5SSUdIVCxuKSxpLnNldExvY2F0aW9uKHQsTW4uTEVGVCxuKX19fWdldENvb3JkaW5hdGUoKXtjb25zdCB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7cmV0dXJuIHQubmV4dCgpLmdldENvb3JkaW5hdGUoKX1wcmludCh0KXtCLm91dC5wcmludGxuKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0KXtyZXR1cm4gdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0LmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KDApfWNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQodCl7Y29uc3QgZT10aGlzLmdldEVkZ2VzKCk7aWYoZS5zaXplKCk8PTApcmV0dXJuITA7Y29uc3Qgbj1lLnNpemUoKS0xLHM9ZS5nZXQobikuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LE1uLkxFRlQpO2cuaXNUcnVlKHMhPT1RdC5OT05FLFwiRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2VcIik7bGV0IGk9cztmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRMYWJlbCgpO2cuaXNUcnVlKG4uaXNBcmVhKHQpLFwiRm91bmQgbm9uLWFyZWEgZWRnZVwiKTtjb25zdCBzPW4uZ2V0TG9jYXRpb24odCxNbi5MRUZUKSxyPW4uZ2V0TG9jYXRpb24odCxNbi5SSUdIVCk7aWYocz09PXIpcmV0dXJuITE7aWYociE9PWkpcmV0dXJuITE7aT1zfXJldHVybiEwfWZpbmRJbmRleCh0KXt0aGlzLml0ZXJhdG9yKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlTGlzdC5zaXplKCk7ZSsrKXtpZih0aGlzLl9lZGdlTGlzdC5nZXQoZSk9PT10KXJldHVybiBlfXJldHVybi0xfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoKS5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lZGdlTGlzdCYmKHRoaXMuX2VkZ2VMaXN0PW5ldyBMKHRoaXMuX2VkZ2VNYXAudmFsdWVzKCkpKSx0aGlzLl9lZGdlTGlzdH1nZXRMb2NhdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF09PT1RdC5OT05FJiYodGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XT1aZS5sb2NhdGUoZSxuW3RdLmdldEdlb21ldHJ5KCkpKSx0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdjt0LmFwcGVuZChcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKSx0LmFwcGVuZChcIlxcblwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0LmFwcGVuZChuKSx0LmFwcGVuZChcIlxcblwiKX1yZXR1cm4gdC50b1N0cmluZygpfWNvbXB1dGVFZGdlRW5kTGFiZWxzKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5jb21wdXRlTGFiZWwodCl9fWNvbXB1dGVMYWJlbGxpbmcodCl7dGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0WzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtjb25zdCBlPVshMSwhMV07Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkuZ2V0TGFiZWwoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKW4uaXNMaW5lKHQpJiZuLmdldExvY2F0aW9uKHQpPT09UXQuQk9VTkRBUlkmJihlW3RdPSEwKX1mb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtmb3IobGV0IG49MDtuPDI7bisrKWlmKGkuaXNBbnlOdWxsKG4pKXtsZXQgcj1RdC5OT05FO2lmKGVbbl0pcj1RdC5FWFRFUklPUjtlbHNle2NvbnN0IGU9cy5nZXRDb29yZGluYXRlKCk7cj10aGlzLmdldExvY2F0aW9uKG4sZSx0KX1pLnNldEFsbExvY2F0aW9uc0lmTnVsbChuLHIpfX19Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2VkZ2VNYXAuc2l6ZSgpfWluc2VydEVkZ2VFbmQodCxlKXt0aGlzLl9lZGdlTWFwLnB1dCh0LGUpLHRoaXMuX2VkZ2VMaXN0PW51bGx9fWNsYXNzIFNpIGV4dGVuZHMgTml7Y29uc3RydWN0b3IoKXtzdXBlcigpLFNpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdD1udWxsLHRoaXMuX2xhYmVsPW51bGwsdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HPTEsdGhpcy5fTElOS0lOR19UT19PVVRHT0lORz0yfWxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl7dGhpcy5nZXRSZXN1bHRBcmVhRWRnZXMoKTtsZXQgdD1udWxsLGU9bnVsbCxuPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztmb3IobGV0IHM9MDtzPHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCk7cysrKXtjb25zdCBpPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQocykscj1pLmdldFN5bSgpO2lmKGkuZ2V0TGFiZWwoKS5pc0FyZWEoKSlzd2l0Y2gobnVsbD09PXQmJmkuaXNJblJlc3VsdCgpJiYodD1pKSxuKXtjYXNlIHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORzppZighci5pc0luUmVzdWx0KCkpY29udGludWU7ZT1yLG49dGhpcy5fTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc6aWYoIWkuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2Uuc2V0TmV4dChpKSxuPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlOR319aWYobj09PXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcpe2lmKG51bGw9PT10KXRocm93IG5ldyBzcyhcIm5vIG91dGdvaW5nIGRpckVkZ2UgZm91bmRcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7Zy5pc1RydWUodC5pc0luUmVzdWx0KCksXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksZS5zZXROZXh0KHQpfX1pbnNlcnQodCl7Y29uc3QgZT10O3RoaXMuaW5zZXJ0RWRnZUVuZChlLGUpfWdldFJpZ2h0bW9zdEVkZ2UoKXtjb25zdCB0PXRoaXMuZ2V0RWRnZXMoKSxlPXQuc2l6ZSgpO2lmKGU8MSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0KDApO2lmKDE9PT1lKXJldHVybiBuO2NvbnN0IHM9dC5nZXQoZS0xKSxpPW4uZ2V0UXVhZHJhbnQoKSxyPXMuZ2V0UXVhZHJhbnQoKTtyZXR1cm4gd24uaXNOb3J0aGVybihpKSYmd24uaXNOb3J0aGVybihyKT9uOnduLmlzTm9ydGhlcm4oaSl8fHduLmlzTm9ydGhlcm4ocik/MCE9PW4uZ2V0RHkoKT9uOjAhPT1zLmdldER5KCk/czooZy5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHR3byBob3Jpem9udGFsIGVkZ2VzIGluY2lkZW50IG9uIG5vZGVcIiksbnVsbCk6c31wcmludCh0KXtCLm91dC5wcmludGxuKFwiRGlyZWN0ZWRFZGdlU3RhcjogXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QucHJpbnQoXCJvdXQgXCIpLG4ucHJpbnQodCksdC5wcmludGxuKCksdC5wcmludChcImluIFwiKSxuLmdldFN5bSgpLnByaW50KHQpLHQucHJpbnRsbigpfX1nZXRSZXN1bHRBcmVhRWRnZXMoKXtpZihudWxsIT09dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0KXJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q7dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0PW5ldyBMO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpOyhlLmlzSW5SZXN1bHQoKXx8ZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpJiZ0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuYWRkKGUpfXJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3R9dXBkYXRlTGFiZWxsaW5nKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldExhYmVsKCk7bi5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0LmdldExvY2F0aW9uKDApKSxuLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQuZ2V0TG9jYXRpb24oMSkpfX1saW5rQWxsRGlyZWN0ZWRFZGdlcygpe3RoaXMuZ2V0RWRnZXMoKTtsZXQgdD1udWxsLGU9bnVsbDtmb3IobGV0IG49dGhpcy5fZWRnZUxpc3Quc2l6ZSgpLTE7bj49MDtuLS0pe2NvbnN0IHM9dGhpcy5fZWRnZUxpc3QuZ2V0KG4pLGk9cy5nZXRTeW0oKTtudWxsPT09ZSYmKGU9aSksbnVsbCE9PXQmJmkuc2V0TmV4dCh0KSx0PXN9ZS5zZXROZXh0KHQpfWNvbXB1dGVEZXB0aHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLmZpbmRJbmRleCh0KSxuPXQuZ2V0RGVwdGgoTW4uTEVGVCkscz10LmdldERlcHRoKE1uLlJJR0hUKSxpPXRoaXMuY29tcHV0ZURlcHRocyhlKzEsdGhpcy5fZWRnZUxpc3Quc2l6ZSgpLG4pO2lmKHRoaXMuY29tcHV0ZURlcHRocygwLGUsaSkhPT1zKXRocm93IG5ldyBzcyhcImRlcHRoIG1pc21hdGNoIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtsZXQgZT1hcmd1bWVudHNbMl07Zm9yKGxldCBuPWFyZ3VtZW50c1swXTtuPHQ7bisrKXtjb25zdCB0PXRoaXMuX2VkZ2VMaXN0LmdldChuKTt0LnNldEVkZ2VEZXB0aHMoTW4uUklHSFQsZSksZT10LmdldERlcHRoKE1uLkxFRlQpfXJldHVybiBlfX1tZXJnZVN5bUxhYmVscygpe2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuZ2V0TGFiZWwoKS5tZXJnZShlLmdldFN5bSgpLmdldExhYmVsKCkpfX1saW5rTWluaW1hbERpcmVjdGVkRWRnZXModCl7bGV0IGU9bnVsbCxuPW51bGwscz10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7Zm9yKGxldCBpPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCktMTtpPj0wO2ktLSl7Y29uc3Qgcj10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KGkpLG89ci5nZXRTeW0oKTtzd2l0Y2gobnVsbD09PWUmJnIuZ2V0RWRnZVJpbmcoKT09PXQmJihlPXIpLHMpe2Nhc2UgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKG8uZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bj1vLHM9dGhpcy5fTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc6aWYoci5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuLnNldE5leHRNaW4ocikscz10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkd9fXM9PT10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HJiYoZy5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIGZvciBmaXJzdCBvdXRnb2luZyBkaXJFZGdlXCIpLGcuaXNUcnVlKGUuZ2V0RWRnZVJpbmcoKT09PXQsXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksbi5zZXROZXh0TWluKGUpKX1nZXRPdXRnb2luZ0RlZ3JlZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5pc0luUmVzdWx0KCkmJnQrK31yZXR1cm4gdH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9MDtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0RWRnZVJpbmcoKT09PXQmJmUrK31yZXR1cm4gZX19Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9ZmluZENvdmVyZWRMaW5lRWRnZXMoKXtsZXQgdD1RdC5OT05FO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRTeW0oKTtpZighbi5pc0xpbmVFZGdlKCkpe2lmKG4uaXNJblJlc3VsdCgpKXt0PVF0LklOVEVSSU9SO2JyZWFrfWlmKHMuaXNJblJlc3VsdCgpKXt0PVF0LkVYVEVSSU9SO2JyZWFrfX19aWYodD09PVF0Lk5PTkUpcmV0dXJuIG51bGw7bGV0IGU9dDtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKSxzPW4uZ2V0U3ltKCk7bi5pc0xpbmVFZGdlKCk/bi5nZXRFZGdlKCkuc2V0Q292ZXJlZChlPT09UXQuSU5URVJJT1IpOihuLmlzSW5SZXN1bHQoKSYmKGU9UXQuRVhURVJJT1IpLHMuaXNJblJlc3VsdCgpJiYoZT1RdC5JTlRFUklPUikpfX1jb21wdXRlTGFiZWxsaW5nKHQpe3N1cGVyLmNvbXB1dGVMYWJlbGxpbmcuY2FsbCh0aGlzLHQpLHRoaXMuX2xhYmVsPW5ldyBxbihRdC5OT05FKTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKS5nZXRFZGdlKCkuZ2V0TGFiZWwoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKXtjb25zdCBuPWUuZ2V0TG9jYXRpb24odCk7biE9PVF0LklOVEVSSU9SJiZuIT09UXQuQk9VTkRBUll8fHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsUXQuSU5URVJJT1IpfX19fWNsYXNzIHdpIGV4dGVuZHMgcnN7Y29uc3RydWN0b3IoKXtzdXBlcigpfWNyZWF0ZU5vZGUodCl7cmV0dXJuIG5ldyB0cyh0LG5ldyBTaSl9fWNsYXNzIENpe2NvbnN0cnVjdG9yKCl7Q2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fb3JpZW50YXRpb249bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dCx0aGlzLl9vcmllbnRhdGlvbj1DaS5vcmllbnRhdGlvbih0KX1zdGF0aWMgb3JpZW50YXRpb24odCl7cmV0dXJuIDE9PT1kdC5pbmNyZWFzaW5nRGlyZWN0aW9uKHQpfXN0YXRpYyBjb21wYXJlT3JpZW50ZWQodCxlLG4scyl7Y29uc3QgaT1lPzE6LTEscj1zPzE6LTEsbz1lP3QubGVuZ3RoOi0xLGw9cz9uLmxlbmd0aDotMTtsZXQgYT1lPzA6dC5sZW5ndGgtMSxjPXM/MDpuLmxlbmd0aC0xO2Zvcig7Oyl7Y29uc3QgZT10W2FdLmNvbXBhcmVUbyhuW2NdKTtpZigwIT09ZSlyZXR1cm4gZTthKz1pLGMrPXI7Y29uc3Qgcz1hPT09byxoPWM9PT1sO2lmKHMmJiFoKXJldHVybi0xO2lmKCFzJiZoKXJldHVybiAxO2lmKHMmJmgpcmV0dXJuIDB9fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIENpLmNvbXBhcmVPcmllbnRlZCh0aGlzLl9wdHMsdGhpcy5fb3JpZW50YXRpb24sZS5fcHRzLGUuX29yaWVudGF0aW9uKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIExpe2NvbnN0cnVjdG9yKCl7TGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZWRnZXM9bmV3IEwsdGhpcy5fb2NhTWFwPW5ldyBIbn1wcmludCh0KXt0LnByaW50KFwiTVVMVElMSU5FU1RSSU5HICggXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7ZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KFwiKFwiKTtjb25zdCBzPW4uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoc1tlXS54K1wiIFwiK3NbZV0ueSk7dC5wcmludGxuKFwiKVwiKX10LnByaW50KFwiKSAgXCIpfWFkZEFsbCh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSl9ZmluZEVkZ2VJbmRleCh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspaWYodGhpcy5fZWRnZXMuZ2V0KGUpLmVxdWFscyh0KSlyZXR1cm4gZTtyZXR1cm4tMX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfWdldCh0KXtyZXR1cm4gdGhpcy5fZWRnZXMuZ2V0KHQpfWZpbmRFcXVhbEVkZ2UodCl7Y29uc3QgZT1uZXcgQ2kodC5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gdGhpcy5fb2NhTWFwLmdldChlKX1hZGQodCl7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IGU9bmV3IENpKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fb2NhTWFwLnB1dChlLHQpfX1jbGFzcyBUaXtwcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXt9aXNEb25lKCl7fX1jbGFzcyBSaXtjb25zdHJ1Y3Rvcigpe1JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9oYXNQcm9wZXI9ITEsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5faGFzSW50ZXJpb3I9ITEsdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMubnVtSW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXR9c3RhdGljIGlzQWRqYWNlbnRTZWdtZW50cyh0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX1pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl7aWYodD09PW4mJjE9PT10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoUmkuaXNBZGphY2VudFNlZ21lbnRzKGUscykpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXtjb25zdCBuPXQuc2l6ZSgpLTE7aWYoMD09PWUmJnM9PT1ufHwwPT09cyYmZT09PW4pcmV0dXJuITB9fXJldHVybiExfWdldFByb3BlckludGVyc2VjdGlvblBvaW50KCl7cmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50fWhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yfWdldExpbmVJbnRlcnNlY3Rvcigpe3JldHVybiB0aGlzLl9saX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyc2VjdGlvbnMrKyx0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrLHRoaXMuX2hhc0ludGVyaW9yPSEwKSx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCx0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKSx0aGlzLl9saS5pc1Byb3BlcigpJiYodGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zKyssdGhpcy5faGFzUHJvcGVyPSEwLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSEwKSkpfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuITF9aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJpb3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1RpXX19Y2xhc3MgUGl7Y29uc3RydWN0b3IoKXtQaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9idWZQYXJhbXM9bnVsbCx0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl93b3JraW5nTm9kZXI9bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZWRnZUxpc3Q9bmV3IExpO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2J1ZlBhcmFtcz10fXN0YXRpYyBkZXB0aERlbHRhKHQpe2NvbnN0IGU9dC5nZXRMb2NhdGlvbigwLE1uLkxFRlQpLG49dC5nZXRMb2NhdGlvbigwLE1uLlJJR0hUKTtyZXR1cm4gZT09PVF0LklOVEVSSU9SJiZuPT09UXQuRVhURVJJT1I/MTplPT09UXQuRVhURVJJT1ImJm49PT1RdC5JTlRFUklPUj8tMTowfXN0YXRpYyBjb252ZXJ0U2VnU3RyaW5ncyh0KXtjb25zdCBlPW5ldyBDdCxuPW5ldyBMO2Zvcig7dC5oYXNOZXh0KCk7KXtjb25zdCBzPXQubmV4dCgpLGk9ZS5jcmVhdGVMaW5lU3RyaW5nKHMuZ2V0Q29vcmRpbmF0ZXMoKSk7bi5hZGQoaSl9cmV0dXJuIGUuYnVpbGRHZW9tZXRyeShuKX1zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsPXR9aW5zZXJ0VW5pcXVlRWRnZSh0KXtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe2NvbnN0IG49ZS5nZXRMYWJlbCgpO2xldCBzPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChzPW5ldyBxbih0LmdldExhYmVsKCkpLHMuZmxpcCgpKSxuLm1lcmdlKHMpO2NvbnN0IGk9UGkuZGVwdGhEZWx0YShzKSxyPWUuZ2V0RGVwdGhEZWx0YSgpK2k7ZS5zZXREZXB0aERlbHRhKHIpfWVsc2UgdGhpcy5fZWRnZUxpc3QuYWRkKHQpLHQuc2V0RGVwdGhEZWx0YShQaS5kZXB0aERlbHRhKHQuZ2V0TGFiZWwoKSkpfWJ1aWxkU3ViZ3JhcGhzKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPXQuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpLHI9bmV3IHhpKG4pLmdldERlcHRoKGkpO3QuY29tcHV0ZURlcHRoKHIpLHQuZmluZFJlc3VsdEVkZ2VzKCksbi5hZGQodCksZS5hZGQodC5nZXREaXJlY3RlZEVkZ2VzKCksdC5nZXROb2RlcygpKX19Y3JlYXRlU3ViZ3JhcGhzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZighdC5pc1Zpc2l0ZWQoKSl7Y29uc3Qgbj1uZXcgaGk7bi5jcmVhdGUodCksZS5hZGQobil9fXJldHVybiB4ZS5zb3J0KGUseGUucmV2ZXJzZU9yZGVyKCkpLGV9Y3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCl9Z2V0Tm9kZXIodCl7aWYobnVsbCE9PXRoaXMuX3dvcmtpbmdOb2RlcilyZXR1cm4gdGhpcy5fd29ya2luZ05vZGVyO2NvbnN0IGU9bmV3ICRzLG49bmV3IGp0O3JldHVybiBuLnNldFByZWNpc2lvbk1vZGVsKHQpLGUuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBSaShuKSksZX1idWZmZXIodCxlKXtsZXQgbj10aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw7bnVsbD09PW4mJihuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCk7Y29uc3Qgcz1uZXcgeWkobix0aGlzLl9idWZQYXJhbXMpLGk9bmV3IElpKHQsZSxzKS5nZXRDdXJ2ZXMoKTtpZihpLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dGhpcy5jb21wdXRlTm9kZWRFZGdlcyhpLG4pLHRoaXMuX2dyYXBoPW5ldyBvcyhuZXcgd2kpLHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpO2NvbnN0IHI9dGhpcy5jcmVhdGVTdWJncmFwaHModGhpcy5fZ3JhcGgpLG89bmV3IF9pKHRoaXMuX2dlb21GYWN0KTt0aGlzLmJ1aWxkU3ViZ3JhcGhzKHIsbyk7Y29uc3QgbD1vLmdldFBvbHlnb25zKCk7aWYobC5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3JldHVybiB0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGwpfWNvbXB1dGVOb2RlZEVkZ2VzKHQsZSl7Y29uc3Qgbj10aGlzLmdldE5vZGVyKGUpO24uY29tcHV0ZU5vZGVzKHQpO2ZvcihsZXQgdD1uLmdldE5vZGVkU3Vic3RyaW5ncygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRDb29yZGluYXRlcygpO2lmKDI9PT1uLmxlbmd0aCYmblswXS5lcXVhbHMyRChuWzFdKSljb250aW51ZTtjb25zdCBzPWUuZ2V0RGF0YSgpLGk9bmV3ICRuKGUuZ2V0Q29vcmRpbmF0ZXMoKSxuZXcgcW4ocykpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZShpKX19c2V0Tm9kZXIodCl7dGhpcy5fd29ya2luZ05vZGVyPXR9fWNsYXNzIE9pe2NvbnN0cnVjdG9yKCl7T2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX3NlZ1N0cmluZ3M9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWdTdHJpbmdzPXR9Y2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKS5nZXRDb29yZGluYXRlcygpO3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoZVswXSx0aGlzLl9zZWdTdHJpbmdzKSx0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKGVbZS5sZW5ndGgtMV0sdGhpcy5fc2VnU3RyaW5ncyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPWFyZ3VtZW50c1sxXS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0xO2U8bi5sZW5ndGgtMTtlKyspaWYobltlXS5lcXVhbHModCkpdGhyb3cgbmV3IGgoXCJmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggXCIrZStcIiA6cHQgXCIrdCl9fX1jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2ZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoZSxuKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldENvb3JkaW5hdGVzKCkscz1lLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBpPTA7aTxuLmxlbmd0aC0xO2krKylmb3IobGV0IG49MDtuPHMubGVuZ3RoLTE7bisrKXRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnModCxpLGUsbil9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5fbGkuaXNQcm9wZXIoKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSxpLHIpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLG8sbCkpKXRocm93IG5ldyBoKFwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBhdCBcIitpK1wiLVwiK3IrXCIgYW5kIFwiK28rXCItXCIrbCl9fWNoZWNrVmFsaWQoKXt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tDb2xsYXBzZXMoKX1jaGVja0NvbGxhcHNlcygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuY2hlY2tDb2xsYXBzZXMoZSl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKXRoaXMuY2hlY2tDb2xsYXBzZSh0W2VdLHRbZSsxXSx0W2UrMl0pfX1oYXNJbnRlcmlvckludGVyc2VjdGlvbih0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl7Y29uc3QgaT10LmdldEludGVyc2VjdGlvbihzKTtpZighaS5lcXVhbHMoZSkmJiFpLmVxdWFscyhuKSlyZXR1cm4hMH1yZXR1cm4hMX1jaGVja0NvbGxhcHNlKHQsZSxuKXtpZih0LmVxdWFscyhuKSl0aHJvdyBuZXcgaChcImZvdW5kIG5vbi1ub2RlZCBjb2xsYXBzZSBhdCBcIitPaS5mYWN0LmNyZWF0ZUxpbmVTdHJpbmcoW3QsZSxuXSkpfX1PaS5mYWN0PW5ldyBDdDtjbGFzcyB2aXtjb25zdHJ1Y3Rvcigpe3ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW51bGwsdGhpcy5fcHQ9bnVsbCx0aGlzLl9vcmlnaW5hbFB0PW51bGwsdGhpcy5fcHRTY2FsZWQ9bnVsbCx0aGlzLl9wMFNjYWxlZD1udWxsLHRoaXMuX3AxU2NhbGVkPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9taW54PW51bGwsdGhpcy5fbWF4eD1udWxsLHRoaXMuX21pbnk9bnVsbCx0aGlzLl9tYXh5PW51bGwsdGhpcy5fY29ybmVyPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX3NhZmVFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLl9vcmlnaW5hbFB0PXQsdGhpcy5fcHQ9dCx0aGlzLl9zY2FsZUZhY3Rvcj1lLHRoaXMuX2xpPW4sZTw9MCl0aHJvdyBuZXcgcyhcIlNjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpOzEhPT1lJiYodGhpcy5fcHQ9bmV3IG0odGhpcy5zY2FsZSh0LngpLHRoaXMuc2NhbGUodC55KSksdGhpcy5fcDBTY2FsZWQ9bmV3IG0sdGhpcy5fcDFTY2FsZWQ9bmV3IG0pLHRoaXMuaW5pdENvcm5lcnModGhpcy5fcHQpfWludGVyc2VjdHNTY2FsZWQodCxlKXtjb25zdCBuPU1hdGgubWluKHQueCxlLngpLHM9TWF0aC5tYXgodC54LGUueCksaT1NYXRoLm1pbih0LnksZS55KSxyPU1hdGgubWF4KHQueSxlLnkpLG89dGhpcy5fbWF4eDxufHx0aGlzLl9taW54PnN8fHRoaXMuX21heHk8aXx8dGhpcy5fbWlueT5yO2lmKG8pcmV0dXJuITE7Y29uc3QgbD10aGlzLmludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKTtyZXR1cm4gZy5pc1RydWUoIShvJiZsKSxcIkZvdW5kIGJhZCBlbnZlbG9wZSB0ZXN0XCIpLGx9aW5pdENvcm5lcnModCl7Y29uc3QgZT0uNTt0aGlzLl9taW54PXQueC1lLHRoaXMuX21heHg9dC54K2UsdGhpcy5fbWlueT10LnktZSx0aGlzLl9tYXh5PXQueStlLHRoaXMuX2Nvcm5lclswXT1uZXcgbSh0aGlzLl9tYXh4LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsxXT1uZXcgbSh0aGlzLl9taW54LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsyXT1uZXcgbSh0aGlzLl9taW54LHRoaXMuX21pbnkpLHRoaXMuX2Nvcm5lclszXT1uZXcgbSh0aGlzLl9tYXh4LHRoaXMuX21pbnkpfWludGVyc2VjdHModCxlKXtyZXR1cm4gMT09PXRoaXMuX3NjYWxlRmFjdG9yP3RoaXMuaW50ZXJzZWN0c1NjYWxlZCh0LGUpOih0aGlzLmNvcHlTY2FsZWQodCx0aGlzLl9wMFNjYWxlZCksdGhpcy5jb3B5U2NhbGVkKGUsdGhpcy5fcDFTY2FsZWQpLHRoaXMuaW50ZXJzZWN0c1NjYWxlZCh0aGlzLl9wMFNjYWxlZCx0aGlzLl9wMVNjYWxlZCkpfXNjYWxlKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqdGhpcy5fc2NhbGVGYWN0b3IpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fb3JpZ2luYWxQdH1jb3B5U2NhbGVkKHQsZSl7ZS54PXRoaXMuc2NhbGUodC54KSxlLnk9dGhpcy5zY2FsZSh0LnkpfWdldFNhZmVFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9zYWZlRW52KXtjb25zdCB0PXZpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IvdGhpcy5fc2NhbGVGYWN0b3I7dGhpcy5fc2FmZUVudj1uZXcgTyh0aGlzLl9vcmlnaW5hbFB0LngtdCx0aGlzLl9vcmlnaW5hbFB0LngrdCx0aGlzLl9vcmlnaW5hbFB0LnktdCx0aGlzLl9vcmlnaW5hbFB0LnkrdCl9cmV0dXJuIHRoaXMuX3NhZmVFbnZ9aW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSh0LGUpe3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzFdLHRoaXMuX2Nvcm5lclsyXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbM10sdGhpcy5fY29ybmVyWzBdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSkpfWludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKXtsZXQgbj0hMSxzPSExO3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMV0sdGhpcy5fY29ybmVyWzJdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKG49ITApLHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYocz0hMCksdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzNdLHRoaXMuX2Nvcm5lclswXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwoISghbnx8IXMpfHwoISF0LmVxdWFscyh0aGlzLl9wdCl8fCEhZS5lcXVhbHModGhpcy5fcHQpKSkpKSl9YWRkU25hcHBlZE5vZGUodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZShlKSxzPXQuZ2V0Q29vcmRpbmF0ZShlKzEpO3JldHVybiEhdGhpcy5pbnRlcnNlY3RzKG4scykmJih0LmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSxlKSwhMCl9fXZpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1I9Ljc1O2NsYXNzIE1pe2NvbnN0cnVjdG9yKCl7TWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5zZWxlY3RlZFNlZ21lbnQ9bmV3IEt0fXNlbGVjdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMF0uZ2V0TGluZVNlZ21lbnQodCx0aGlzLnNlbGVjdGVkU2VnbWVudCksdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpfX19Y2xhc3MgYml7Y29uc3RydWN0b3IoKXtiaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2luZGV4PXR9c25hcCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zbmFwKHQsbnVsbCwtMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9dC5nZXRTYWZlRW52ZWxvcGUoKSxpPW5ldyBEaSh0LGUsbik7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHMsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltEZV19dmlzaXRJdGVtKHQpe3Quc2VsZWN0KHMsaSl9fSksaS5pc05vZGVBZGRlZCgpfX19Y2xhc3MgRGkgZXh0ZW5kcyBNaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faG90UGl4ZWw9bnVsbCx0aGlzLl9wYXJlbnRFZGdlPW51bGwsdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleD1udWxsLHRoaXMuX2lzTm9kZUFkZGVkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2hvdFBpeGVsPXQsdGhpcy5fcGFyZW50RWRnZT1lLHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXg9bn1pc05vZGVBZGRlZCgpe3JldHVybiB0aGlzLl9pc05vZGVBZGRlZH1zZWxlY3QoKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YganMpKXJldHVybiBzdXBlci5zZWxlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXS5nZXRDb250ZXh0KCk7aWYodGhpcy5fcGFyZW50RWRnZT09PWUmJih0PT09dGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleHx8dCsxPT09dGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleCkpcmV0dXJuIG51bGw7dGhpcy5faXNOb2RlQWRkZWR8PXRoaXMuX2hvdFBpeGVsLmFkZFNuYXBwZWROb2RlKGUsdCl9fX1iaS5Ib3RQaXhlbFNuYXBBY3Rpb249RGk7Y2xhc3MgQWl7Y29uc3RydWN0b3IoKXtBaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1udWxsLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXQsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zPW5ldyBMfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpO3QrKyl0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnMuYWRkKHRoaXMuX2xpLmdldEludGVyc2VjdGlvbih0KSk7dC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSl9fWlzRG9uZSgpe3JldHVybiExfWdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1RpXX19Y2xhc3MgRml7Y29uc3RydWN0b3IoKXtGaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wbT1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3BvaW50U25hcHBlcj1udWxsLHRoaXMuX25vZGVkU2VnU3RyaW5ncz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BtPXQsdGhpcy5fbGk9bmV3IGp0LHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHQpLHRoaXMuX3NjYWxlRmFjdG9yPXQuZ2V0U2NhbGUoKX1jaGVja0NvcnJlY3RuZXNzKHQpe2NvbnN0IGU9V3MuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQpLHM9bmV3IE9pKGUpO3RyeXtzLmNoZWNrVmFsaWQoKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBuKSl0aHJvdyB0O3QucHJpbnRTdGFja1RyYWNlKCl9fWdldE5vZGVkU3Vic3RyaW5ncygpe3JldHVybiBXcy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKX1zbmFwUm91bmQodCxlKXtjb25zdCBuPXRoaXMuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzKG4pLHRoaXMuY29tcHV0ZVZlcnRleFNuYXBzKHQpfWZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKXtjb25zdCBuPW5ldyBBaShlKTtyZXR1cm4gdGhpcy5fbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKG4pLHRoaXMuX25vZGVyLmNvbXB1dGVOb2Rlcyh0KSxuLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpfWNvbXB1dGVWZXJ0ZXhTbmFwcygpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuY29tcHV0ZVZlcnRleFNuYXBzKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgV3Mpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCBzPW5ldyB2aShlW25dLHRoaXMuX3NjYWxlRmFjdG9yLHRoaXMuX2xpKTt0aGlzLl9wb2ludFNuYXBwZXIuc25hcChzLHQsbikmJnQuYWRkSW50ZXJzZWN0aW9uKGVbbl0sbil9fX1jb21wdXRlTm9kZXModCl7dGhpcy5fbm9kZWRTZWdTdHJpbmdzPXQsdGhpcy5fbm9kZXI9bmV3ICRzLHRoaXMuX3BvaW50U25hcHBlcj1uZXcgYmkodGhpcy5fbm9kZXIuZ2V0SW5kZXgoKSksdGhpcy5zbmFwUm91bmQodCx0aGlzLl9saSl9Y29tcHV0ZUludGVyc2VjdGlvblNuYXBzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49bmV3IHZpKHQsdGhpcy5fc2NhbGVGYWN0b3IsdGhpcy5fbGkpO3RoaXMuX3BvaW50U25hcHBlci5zbmFwKG4pfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUXNdfX1jbGFzcyBHaXtjb25zdHJ1Y3Rvcigpe0dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2FyZ0dlb209bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2J1ZlBhcmFtcz1uZXcgbGksdGhpcy5fcmVzdWx0R2VvbWV0cnk9bnVsbCx0aGlzLl9zYXZlRXhjZXB0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZ0dlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9hcmdHZW9tPXQsdGhpcy5fYnVmUGFyYW1zPWV9fXN0YXRpYyBidWZmZXJPcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IEdpKGFyZ3VtZW50c1swXSkuZ2V0UmVzdWx0R2VvbWV0cnkodCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPW5ldyBHaShhcmd1bWVudHNbMF0pO24uc2V0UXVhZHJhbnRTZWdtZW50cyhlKTtyZXR1cm4gbi5nZXRSZXN1bHRHZW9tZXRyeSh0KX1pZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIGxpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgR2koYXJndW1lbnRzWzBdLGFyZ3VtZW50c1syXSkuZ2V0UmVzdWx0R2VvbWV0cnkodCl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdLHM9bmV3IEdpKGFyZ3VtZW50c1swXSk7cy5zZXRRdWFkcmFudFNlZ21lbnRzKGUpLHMuc2V0RW5kQ2FwU3R5bGUobik7cmV0dXJuIHMuZ2V0UmVzdWx0R2VvbWV0cnkodCl9fXN0YXRpYyBwcmVjaXNpb25TY2FsZUZhY3Rvcih0LGUsbil7Y29uc3Qgcz10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPVkubWF4KE1hdGguYWJzKHMuZ2V0TWF4WCgpKSxNYXRoLmFicyhzLmdldE1heFkoKSksTWF0aC5hYnMocy5nZXRNaW5YKCkpLE1hdGguYWJzKHMuZ2V0TWluWSgpKSkrMiooZT4wP2U6MCkscj1uLU1hdGgudHJ1bmMoTWF0aC5sb2coaSkvTWF0aC5sb2coMTApKzEpO3JldHVybiBNYXRoLnBvdygxMCxyKX1idWZmZXJGaXhlZFByZWNpc2lvbih0KXtjb25zdCBlPW5ldyBlaShuZXcgRmkobmV3IE50KDEpKSx0LmdldFNjYWxlKCkpLG49bmV3IFBpKHRoaXMuX2J1ZlBhcmFtcyk7bi5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCksbi5zZXROb2RlcihlKSx0aGlzLl9yZXN1bHRHZW9tZXRyeT1uLmJ1ZmZlcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlKX1idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD1HaS5NQVhfUFJFQ0lTSU9OX0RJR0lUUzt0Pj0wO3QtLSl7dHJ5e3RoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbih0KX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBzcykpdGhyb3cgdDt0aGlzLl9zYXZlRXhjZXB0aW9uPXR9aWYobnVsbCE9PXRoaXMuX3Jlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsfXRocm93IHRoaXMuX3NhdmVFeGNlcHRpb259aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9R2kucHJlY2lzaW9uU2NhbGVGYWN0b3IodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSx0KSxuPW5ldyBOdChlKTt0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKG4pfX1jb21wdXRlR2VvbWV0cnkoKXtpZih0aGlzLmJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCksbnVsbCE9PXRoaXMuX3Jlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5fYXJnR2VvbS5nZXRGYWN0b3J5KCkuZ2V0UHJlY2lzaW9uTW9kZWwoKTt0LmdldFR5cGUoKT09PU50LkZJWEVEP3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24odCk6dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl9c2V0UXVhZHJhbnRTZWdtZW50cyh0KXt0aGlzLl9idWZQYXJhbXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpe3RyeXtjb25zdCB0PW5ldyBQaSh0aGlzLl9idWZQYXJhbXMpO3RoaXMuX3Jlc3VsdEdlb21ldHJ5PXQuYnVmZmVyKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGgpKXRocm93IHQ7dGhpcy5fc2F2ZUV4Y2VwdGlvbj10fX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5fZGlzdGFuY2U9dCx0aGlzLmNvbXB1dGVHZW9tZXRyeSgpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5fXNldEVuZENhcFN0eWxlKHQpe3RoaXMuX2J1ZlBhcmFtcy5zZXRFbmRDYXBTdHlsZSh0KX19R2kuQ0FQX1JPVU5EPWxpLkNBUF9ST1VORCxHaS5DQVBfQlVUVD1saS5DQVBfRkxBVCxHaS5DQVBfRkxBVD1saS5DQVBfRkxBVCxHaS5DQVBfU1FVQVJFPWxpLkNBUF9TUVVBUkUsR2kuTUFYX1BSRUNJU0lPTl9ESUdJVFM9MTI7dmFyIHFpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEJ1ZmZlck9wOkdpLEJ1ZmZlclBhcmFtZXRlcnM6bGl9KTtjbGFzcyBCaXtjb25zdHJ1Y3Rvcigpe0JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2NvbXBvbmVudD1udWxsLHRoaXMuX3NlZ0luZGV4PW51bGwsdGhpcy5fcHQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07QmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LEJpLklOU0lERV9BUkVBLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2NvbXBvbmVudD10LHRoaXMuX3NlZ0luZGV4PWUsdGhpcy5fcHQ9bn19Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9aXNJbnNpZGVBcmVhKCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4PT09QmkuSU5TSURFX0FSRUF9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50LmdldEdlb21ldHJ5VHlwZSgpK1wiW1wiK3RoaXMuX3NlZ0luZGV4K1wiXS1cIitXdC50b1BvaW50KHRoaXMuX3B0KX1nZXRHZW9tZXRyeUNvbXBvbmVudCgpe3JldHVybiB0aGlzLl9jb21wb25lbnR9fUJpLklOU0lERV9BUkVBPS0xO2NsYXNzIFlpe2NvbnN0cnVjdG9yKCl7WWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbG9jYXRpb25zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbG9jYXRpb25zPXR9c3RhdGljIGdldExvY2F0aW9ucyh0KXtjb25zdCBlPW5ldyBMO3JldHVybiB0LmFwcGx5KG5ldyBZaShlKSksZX1maWx0ZXIodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7KHQgaW5zdGFuY2VvZiB0dHx8dCBpbnN0YW5jZW9mIEp8fHQgaW5zdGFuY2VvZiBpdCkmJnRoaXMuX2xvY2F0aW9ucy5hZGQobmV3IEJpKHQsMCx0LmdldENvb3JkaW5hdGUoKSkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltRXX19Y2xhc3MgVml7Y29uc3RydWN0b3IoKXtWaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fdGVybWluYXRlRGlzdGFuY2U9MCx0aGlzLl9wdExvY2F0b3I9bmV3IGZuLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb249bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07VmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lLHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlPW59fXN0YXRpYyBkaXN0YW5jZSh0LGUpe3JldHVybiBuZXcgVmkodCxlKS5kaXN0YW5jZSgpfXN0YXRpYyBpc1dpdGhpbkRpc3RhbmNlKHQsZSxuKXtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+bilyZXR1cm4hMTtyZXR1cm4gbmV3IFZpKHQsZSxuKS5kaXN0YW5jZSgpPD1ufXN0YXRpYyBuZWFyZXN0UG9pbnRzKHQsZSl7cmV0dXJuIG5ldyBWaSh0LGUpLm5lYXJlc3RQb2ludHMoKX1jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMCx0KSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fZ2VvbVt0XTtpZihuLmdldERpbWVuc2lvbigpPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz0xLXQsaT1JZS5nZXRQb2x5Z29ucyhuKTtpZihpLnNpemUoKT4wKXtjb25zdCBuPVlpLmdldExvY2F0aW9ucyh0aGlzLl9nZW9tW3NdKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKG4saSxlKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bc109ZVswXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3RdPWVbMV0sbnVsbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZJKGFyZ3VtZW50c1swXSx3KSYmSShhcmd1bWVudHNbMV0sdykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKWlmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoaSxlLmdldCh0KSxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCaSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBpdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmdldENvb3JkaW5hdGUoKTtpZihRdC5FWFRFUklPUiE9PXRoaXMuX3B0TG9jYXRvci5sb2NhdGUocyxlKSlyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U9MCxuWzBdPXQsblsxXT1uZXcgQmkoZSxzKSxudWxsfX1jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWNvbXB1dGVGYWNldERpc3RhbmNlKCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxlPXllLmdldExpbmVzKHRoaXMuX2dlb21bMF0pLG49eWUuZ2V0TGluZXModGhpcy5fZ2VvbVsxXSkscz1FZS5nZXRQb2ludHModGhpcy5fZ2VvbVswXSksaT1FZS5nZXRQb2ludHModGhpcy5fZ2VvbVsxXSk7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMoZSxuLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhlLGksdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKG4scyx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITApLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHMsaSx0KSx2b2lkIHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSkpKSl9bmVhcmVzdExvY2F0aW9ucygpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb259dXBkYXRlTWluRGlzdGFuY2UodCxlKXtpZihudWxsPT09dFswXSlyZXR1cm4gbnVsbDtlPyh0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMV0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzBdKToodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXT10WzBdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV09dFsxXSl9bmVhcmVzdFBvaW50cygpe3RoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7cmV0dXJuW3RoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV0uZ2V0Q29vcmRpbmF0ZSgpXX1jb21wdXRlTWluRGlzdGFuY2UoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7aWYobnVsbCE9PXRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb24pcmV0dXJuIG51bGw7aWYodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUZhY2V0RGlzdGFuY2UoKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgSiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiB0dCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMuX21pbkRpc3RhbmNlKXJldHVybiBudWxsO2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlKCk7Zm9yKGxldCByPTA7cjxzLmxlbmd0aC0xO3IrKyl7Y29uc3Qgbz1WLnBvaW50VG9TZWdtZW50KGksc1tyXSxzW3IrMV0pO2lmKG88dGhpcy5fbWluRGlzdGFuY2Upe3RoaXMuX21pbkRpc3RhbmNlPW87Y29uc3QgbD1uZXcgS3Qoc1tyXSxzW3IrMV0pLmNsb3Nlc3RQb2ludChpKTtuWzBdPW5ldyBCaSh0LHIsbCksblsxXT1uZXcgQmkoZSwwLGkpfWlmKHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEomJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMuX21pbkRpc3RhbmNlKXJldHVybiBudWxsO2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgcj0wO3I8cy5sZW5ndGgtMTtyKyspe2NvbnN0IG89bmV3IE8oc1tyXSxzW3IrMV0pO2lmKCEoby5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpKWZvcihsZXQgbD0wO2w8aS5sZW5ndGgtMTtsKyspe2NvbnN0IGE9bmV3IE8oaVtsXSxpW2wrMV0pO2lmKG8uZGlzdGFuY2UoYSk+dGhpcy5fbWluRGlzdGFuY2UpY29udGludWU7Y29uc3QgYz1WLnNlZ21lbnRUb1NlZ21lbnQoc1tyXSxzW3IrMV0saVtsXSxpW2wrMV0pO2lmKGM8dGhpcy5fbWluRGlzdGFuY2Upe3RoaXMuX21pbkRpc3RhbmNlPWM7Y29uc3Qgbz1uZXcgS3Qoc1tyXSxzW3IrMV0pLGE9bmV3IEt0KGlbbF0saVtsKzFdKSxoPW8uY2xvc2VzdFBvaW50cyhhKTtuWzBdPW5ldyBCaSh0LHIsaFswXSksblsxXT1uZXcgQmkoZSxsLGhbMV0pfWlmKHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fX1jb21wdXRlTWluRGlzdGFuY2VQb2ludHModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpLHI9aS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2Uocy5nZXRDb29yZGluYXRlKCkpO2lmKHI8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9taW5EaXN0YW5jZT1yLG5bMF09bmV3IEJpKGksMCxpLmdldENvb3JkaW5hdGUoKSksblsxXT1uZXcgQmkocywwLHMuZ2V0Q29vcmRpbmF0ZSgpKSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19ZGlzdGFuY2UoKXtpZihudWxsPT09dGhpcy5fZ2VvbVswXXx8bnVsbD09PXRoaXMuX2dlb21bMV0pdGhyb3cgbmV3IHMoXCJudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuX2dlb21bMF0uaXNFbXB0eSgpfHx0aGlzLl9nZW9tWzFdLmlzRW1wdHkoKT8wOih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlKX1jb21wdXRlTWluRGlzdGFuY2VMaW5lcyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fX12YXIgemk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGlzdGFuY2VPcDpWaX0pO2NsYXNzIGtpe2NvbnN0cnVjdG9yKCl7a2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2RpcmVjdGVkRWRnZXM9bmV3IEwsdGhpcy5fY29vcmRpbmF0ZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9Z2V0Q29vcmRpbmF0ZXMoKXtpZihudWxsPT09dGhpcy5fY29vcmRpbmF0ZXMpe2xldCB0PTAsZT0wO2NvbnN0IG49bmV3IFI7Zm9yKGxldCBzPXRoaXMuX2RpcmVjdGVkRWRnZXMuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCk7aS5nZXRFZGdlRGlyZWN0aW9uKCk/dCsrOmUrKyxuLmFkZChpLmdldEVkZ2UoKS5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSwhMSxpLmdldEVkZ2VEaXJlY3Rpb24oKSl9dGhpcy5fY29vcmRpbmF0ZXM9bi50b0Nvb3JkaW5hdGVBcnJheSgpLGU+dCYmZHQucmV2ZXJzZSh0aGlzLl9jb29yZGluYXRlcyl9cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfXRvTGluZVN0cmluZygpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKX1hZGQodCl7dGhpcy5fZGlyZWN0ZWRFZGdlcy5hZGQodCl9fWNsYXNzIFhpe2NvbnN0cnVjdG9yKCl7WGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNNYXJrZWQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuX2RhdGE9bnVsbH1zdGF0aWMgZ2V0Q29tcG9uZW50V2l0aFZpc2l0ZWRTdGF0ZSh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO2lmKG4uaXNWaXNpdGVkKCk9PT1lKXJldHVybiBufXJldHVybiBudWxsfXN0YXRpYyBzZXRWaXNpdGVkKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3QubmV4dCgpLnNldFZpc2l0ZWQoZSl9fXN0YXRpYyBzZXRNYXJrZWQodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0TWFya2VkKGUpfX1zZXRWaXNpdGVkKHQpe3RoaXMuX2lzVmlzaXRlZD10fWlzTWFya2VkKCl7cmV0dXJuIHRoaXMuX2lzTWFya2VkfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1zZXRNYXJrZWQodCl7dGhpcy5faXNNYXJrZWQ9dH1nZXRDb250ZXh0KCl7cmV0dXJuIHRoaXMuX2RhdGF9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH1zZXRDb250ZXh0KHQpe3RoaXMuX2RhdGE9dH19Y2xhc3MgVWkgZXh0ZW5kcyBYaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksVWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcGFyZW50RWRnZT1udWxsLHRoaXMuX2Zyb209bnVsbCx0aGlzLl90bz1udWxsLHRoaXMuX3AwPW51bGwsdGhpcy5fcDE9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9lZGdlRGlyZWN0aW9uPW51bGwsdGhpcy5fcXVhZHJhbnQ9bnVsbCx0aGlzLl9hbmdsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9mcm9tPXQsdGhpcy5fdG89ZSx0aGlzLl9lZGdlRGlyZWN0aW9uPXMsdGhpcy5fcDA9dC5nZXRDb29yZGluYXRlKCksdGhpcy5fcDE9bjtjb25zdCBpPXRoaXMuX3AxLngtdGhpcy5fcDAueCxyPXRoaXMuX3AxLnktdGhpcy5fcDAueTt0aGlzLl9xdWFkcmFudD13bi5xdWFkcmFudChpLHIpLHRoaXMuX2FuZ2xlPU1hdGguYXRhbjIocixpKX19c3RhdGljIHRvRWRnZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmFkZChuLm5leHQoKS5fcGFyZW50RWRnZSk7cmV0dXJuIGV9aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9wYXJlbnRFZGdlfWNvbXBhcmVEaXJlY3Rpb24odCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50PnQuX3F1YWRyYW50PzE6dGhpcy5fcXVhZHJhbnQ8dC5fcXVhZHJhbnQ/LTE6Ry5pbmRleCh0Ll9wMCx0Ll9wMSx0aGlzLl9wMSl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9mcm9tLmdldENvb3JkaW5hdGUoKX1wcmludCh0KXtjb25zdCBlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKSxzPWUuc3Vic3RyaW5nKG4rMSk7dC5wcmludChcIiAgXCIrcytcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIit0aGlzLl9hbmdsZSl9Z2V0RGlyZWN0aW9uUHQoKXtyZXR1cm4gdGhpcy5fcDF9Z2V0QW5nbGUoKXtyZXR1cm4gdGhpcy5fYW5nbGV9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpfWdldEZyb21Ob2RlKCl7cmV0dXJuIHRoaXMuX2Zyb219Z2V0U3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1zZXRFZGdlKHQpe3RoaXMuX3BhcmVudEVkZ2U9dH1yZW1vdmUoKXt0aGlzLl9zeW09bnVsbCx0aGlzLl9wYXJlbnRFZGdlPW51bGx9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9wYXJlbnRFZGdlfWdldFF1YWRyYW50KCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50fXNldFN5bSh0KXt0aGlzLl9zeW09dH1nZXRUb05vZGUoKXtyZXR1cm4gdGhpcy5fdG99Z2V0RWRnZURpcmVjdGlvbigpe3JldHVybiB0aGlzLl9lZGdlRGlyZWN0aW9ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgSGkgZXh0ZW5kcyBVaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107VWkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixzKX1nZXROZXh0KCl7cmV0dXJuIDIhPT10aGlzLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpP251bGw6dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApPT09dGhpcy5nZXRTeW0oKT90aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk6KGcuaXNUcnVlKHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKT09PXRoaXMuZ2V0U3ltKCkpLHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKSl9fWNsYXNzIFdpIGV4dGVuZHMgWGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLFdpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2RpckVkZ2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXREaXJlY3RlZEVkZ2VzKHQsZSl9fWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fZGlyRWRnZX1zZXREaXJlY3RlZEVkZ2VzKHQsZSl7dGhpcy5fZGlyRWRnZT1bdCxlXSx0LnNldEVkZ2UodGhpcyksZS5zZXRFZGdlKHRoaXMpLHQuc2V0U3ltKGUpLGUuc2V0U3ltKHQpLHQuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKHQpLGUuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKGUpfWdldERpckVkZ2UoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlW3RdfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygamkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMF06dGhpcy5fZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzFdOm51bGx9fXJlbW92ZSgpe3RoaXMuX2RpckVkZ2U9bnVsbH1nZXRPcHBvc2l0ZU5vZGUodCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVswXS5nZXRUb05vZGUoKTp0aGlzLl9kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMV0uZ2V0VG9Ob2RlKCk6bnVsbH19Y2xhc3MgWml7Y29uc3RydWN0b3IoKXtaaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vdXRFZGdlcz1uZXcgTCx0aGlzLl9zb3J0ZWQ9ITF9Z2V0TmV4dEVkZ2UodCl7Y29uc3QgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLl9vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlKzEpKX1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD10aGlzLml0ZXJhdG9yKCk7aWYoIXQuaGFzTmV4dCgpKXJldHVybiBudWxsO3JldHVybiB0Lm5leHQoKS5nZXRDb29yZGluYXRlKCl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLl9vdXRFZGdlcy5pdGVyYXRvcigpfXNvcnRFZGdlcygpe3RoaXMuX3NvcnRlZHx8KHhlLnNvcnQodGhpcy5fb3V0RWRnZXMpLHRoaXMuX3NvcnRlZD0hMCl9cmVtb3ZlKHQpe3RoaXMuX291dEVkZ2VzLnJlbW92ZSh0KX1nZXRFZGdlcygpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMuX291dEVkZ2VzfWdldE5leHRDV0VkZ2UodCl7Y29uc3QgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLl9vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlLTEpKX1nZXRJbmRleCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgV2kpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9vdXRFZGdlcy5zaXplKCk7ZSsrKXtpZih0aGlzLl9vdXRFZGdlcy5nZXQoZSkuZ2V0RWRnZSgpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFVpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2ZvcihsZXQgZT0wO2U8dGhpcy5fb3V0RWRnZXMuc2l6ZSgpO2UrKyl7aWYodGhpcy5fb3V0RWRnZXMuZ2V0KGUpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2xldCB0PWFyZ3VtZW50c1swXSV0aGlzLl9vdXRFZGdlcy5zaXplKCk7cmV0dXJuIHQ8MCYmKHQrPXRoaXMuX291dEVkZ2VzLnNpemUoKSksdH19YWRkKHQpe3RoaXMuX291dEVkZ2VzLmFkZCh0KSx0aGlzLl9zb3J0ZWQ9ITF9Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX291dEVkZ2VzLnNpemUoKX19Y2xhc3MgamkgZXh0ZW5kcyBYaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksamkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcHQ9bnVsbCx0aGlzLl9kZVN0YXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07amkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG5ldyBaaSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHQ9dCx0aGlzLl9kZVN0YXI9ZX19c3RhdGljIGdldEVkZ2VzQmV0d2Vlbih0LGUpe2NvbnN0IG49VWkudG9FZGdlcyh0LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSkscz1uZXcgeHQobiksaT1VaS50b0VkZ2VzKGUuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKTtyZXR1cm4gcy5yZXRhaW5BbGwoaSksc31pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3B0fWFkZE91dEVkZ2UodCl7dGhpcy5fZGVTdGFyLmFkZCh0KX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fWdldE91dEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2RlU3Rhcn1yZW1vdmUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9wdD1udWxsO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RlU3Rhci5yZW1vdmUodCl9fWdldEluZGV4KHQpe3JldHVybiB0aGlzLl9kZVN0YXIuZ2V0SW5kZXgodCl9Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2RlU3Rhci5nZXREZWdyZWUoKX19Y2xhc3MgS2kgZXh0ZW5kcyBXaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksS2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2xpbmV9fWNsYXNzIFFpe2NvbnN0cnVjdG9yKCl7UWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZU1hcD1uZXcgSG59ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5nZXQodCl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfXJlbW92ZSh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5yZW1vdmUodCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCl9YWRkKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0fX1jbGFzcyBKaXtjb25zdHJ1Y3Rvcigpe0ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2VkZ2VzPW5ldyB4dCx0aGlzLl9kaXJFZGdlcz1uZXcgeHQsdGhpcy5fbm9kZU1hcD1uZXcgUWl9ZmluZE5vZGVzT2ZEZWdyZWUodCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dGhpcy5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5nZXREZWdyZWUoKT09PXQmJmUuYWRkKHMpfXJldHVybiBlfWRpckVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9kaXJFZGdlcy5pdGVyYXRvcigpfWVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfXJlbW92ZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgV2kpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDEpKSx0aGlzLl9lZGdlcy5yZW1vdmUodCksdC5yZW1vdmUoKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVWkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRTeW0oKTtudWxsIT09ZSYmZS5zZXRTeW0obnVsbCksdC5nZXRGcm9tTm9kZSgpLnJlbW92ZSh0KSx0LnJlbW92ZSgpLHRoaXMuX2RpckVkZ2VzLnJlbW92ZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygamkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0U3ltKCk7bnVsbCE9PW4mJnRoaXMucmVtb3ZlKG4pLHRoaXMuX2RpckVkZ2VzLnJlbW92ZSh0KTtjb25zdCBzPXQuZ2V0RWRnZSgpO251bGwhPT1zJiZ0aGlzLl9lZGdlcy5yZW1vdmUocyl9dGhpcy5fbm9kZU1hcC5yZW1vdmUodC5nZXRDb29yZGluYXRlKCkpLHQucmVtb3ZlKCl9fWZpbmROb2RlKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLmZpbmQodCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9bm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuaXRlcmF0b3IoKX1jb250YWlucygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgV2kpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9lZGdlcy5jb250YWlucyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFVpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuY29udGFpbnModCl9fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygamkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25vZGVNYXAuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBXaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZXMuYWRkKHQpLHRoaXMuYWRkKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5hZGQodC5nZXREaXJFZGdlKDEpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVWkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RpckVkZ2VzLmFkZCh0KX19Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKX19Y2xhc3MgJGkgZXh0ZW5kcyBKaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9YWRkRWRnZSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPWR0LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8PTEpcmV0dXJuIG51bGw7Y29uc3Qgbj1lWzBdLHM9ZVtlLmxlbmd0aC0xXSxpPXRoaXMuZ2V0Tm9kZShuKSxyPXRoaXMuZ2V0Tm9kZShzKSxvPW5ldyBIaShpLHIsZVsxXSwhMCksbD1uZXcgSGkocixpLGVbZS5sZW5ndGgtMl0sITEpLGE9bmV3IEtpKHQpO2Euc2V0RGlyZWN0ZWRFZGdlcyhvLGwpLHRoaXMuYWRkKGEpfWdldE5vZGUodCl7bGV0IGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBqaSh0KSx0aGlzLmFkZChlKSksZX19Y2xhc3MgdHJ7Y29uc3RydWN0b3IoKXt0ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1uZXcgJGksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZWRnZVN0cmluZ3M9bnVsbH1idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2UuaXNNYXJrZWQoKXx8KGcuaXNUcnVlKDI9PT1lLmdldERlZ3JlZSgpKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fWJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTsyIT09ZS5nZXREZWdyZWUoKSYmKHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19YnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzKCl9Z2V0TWVyZ2VkTGluZVN0cmluZ3MoKXtyZXR1cm4gdGhpcy5tZXJnZSgpLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzfWJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KHQpe2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5nZXRFZGdlKCkuaXNNYXJrZWQoKXx8dGhpcy5fZWRnZVN0cmluZ3MuYWRkKHRoaXMuYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKHQpKX19bWVyZ2UoKXtpZihudWxsIT09dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3MpcmV0dXJuIG51bGw7WGkuc2V0TWFya2VkKHRoaXMuX2dyYXBoLm5vZGVJdGVyYXRvcigpLCExKSxYaS5zZXRNYXJrZWQodGhpcy5fZ3JhcGguZWRnZUl0ZXJhdG9yKCksITEpLHRoaXMuX2VkZ2VTdHJpbmdzPW5ldyBMLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpLHRoaXMuX21lcmdlZExpbmVTdHJpbmdzPW5ldyBMO2ZvcihsZXQgdD10aGlzLl9lZGdlU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncy5hZGQoZS50b0xpbmVTdHJpbmcoKSl9fWFkZExpbmVTdHJpbmcodCl7bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpfWJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aCh0KXtjb25zdCBlPW5ldyBraSh0aGlzLl9mYWN0b3J5KTtsZXQgbj10O2Rve2UuYWRkKG4pLG4uZ2V0RWRnZSgpLnNldE1hcmtlZCghMCksbj1uLmdldE5leHQoKX13aGlsZShudWxsIT09biYmbiE9PXQpO3JldHVybiBlfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7biBpbnN0YW5jZW9mIEomJnRoaXMuYWRkTGluZVN0cmluZyhuKX19ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bnVsbDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmFkZCh0KX19fWJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlcygpfX1jbGFzcyBlcntjb25zdHJ1Y3Rvcigpe2VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BhcmVudEdyYXBoPW51bGwsdGhpcy5fZWRnZXM9bmV3IHh0LHRoaXMuX2RpckVkZ2VzPW5ldyBMLHRoaXMuX25vZGVNYXA9bmV3IFFpO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudEdyYXBoPXR9ZGlyRWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCl9ZWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudEdyYXBofW5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLml0ZXJhdG9yKCl9Y29udGFpbnModCl7cmV0dXJuIHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpfWFkZCh0KXtpZih0aGlzLl9lZGdlcy5jb250YWlucyh0KSlyZXR1cm4gbnVsbDt0aGlzLl9lZGdlcy5hZGQodCksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5fbm9kZU1hcC5hZGQodC5nZXREaXJFZGdlKDApLmdldEZyb21Ob2RlKCkpLHRoaXMuX25vZGVNYXAuYWRkKHQuZ2V0RGlyRWRnZSgxKS5nZXRGcm9tTm9kZSgpKX19Y2xhc3MgbnJ7Y29uc3RydWN0b3IoKXtuci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dyYXBoPXR9YWRkUmVhY2hhYmxlKHQsZSl7Y29uc3Qgbj1uZXcgZW47Zm9yKG4uYWRkKHQpOyFuLmVtcHR5KCk7KXtjb25zdCB0PW4ucG9wKCk7dGhpcy5hZGRFZGdlcyh0LG4sZSl9fWZpbmRTdWJncmFwaCh0KXtjb25zdCBlPW5ldyBlcih0aGlzLl9ncmFwaCk7cmV0dXJuIHRoaXMuYWRkUmVhY2hhYmxlKHQsZSksZX1nZXRDb25uZWN0ZWRTdWJncmFwaHMoKXtjb25zdCB0PW5ldyBMO1hpLnNldFZpc2l0ZWQodGhpcy5fZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpO2ZvcihsZXQgZT10aGlzLl9ncmFwaC5lZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0RGlyRWRnZSgwKS5nZXRGcm9tTm9kZSgpO24uaXNWaXNpdGVkKCl8fHQuYWRkKHRoaXMuZmluZFN1YmdyYXBoKG4pKX1yZXR1cm4gdH1hZGRFZGdlcyh0LGUsbil7dC5zZXRWaXNpdGVkKCEwKTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO24uYWRkKHQuZ2V0RWRnZSgpKTtjb25zdCBpPXQuZ2V0VG9Ob2RlKCk7aS5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKGkpfX19Y2xhc3Mgc3J7Y29uc3RydWN0b3IoKXtzci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1uZXcgJGksdGhpcy5fZmFjdG9yeT1uZXcgQ3QsdGhpcy5fbGluZUNvdW50PTAsdGhpcy5faXNSdW49ITEsdGhpcy5fc2VxdWVuY2VkR2VvbWV0cnk9bnVsbCx0aGlzLl9pc1NlcXVlbmNlYWJsZT0hMX1zdGF0aWMgZmluZFVudmlzaXRlZEJlc3RPcmllbnRlZERFKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5nZXRFZGdlKCkuaXNWaXNpdGVkKCl8fChuPXQsdC5nZXRFZGdlRGlyZWN0aW9uKCkmJihlPXQpKX1yZXR1cm4gbnVsbCE9PWU/ZTpufXN0YXRpYyBmaW5kTG93ZXN0RGVncmVlTm9kZSh0KXtsZXQgZT1NLk1BWF9WQUxVRSxuPW51bGw7Zm9yKGxldCBzPXQubm9kZUl0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpOyhudWxsPT09bnx8dC5nZXREZWdyZWUoKTxlKSYmKGU9dC5nZXREZWdyZWUoKSxuPXQpfXJldHVybiBufXN0YXRpYyBpc1NlcXVlbmNlZCh0KXtpZighKHQgaW5zdGFuY2VvZiB3dCkpcmV0dXJuITA7Y29uc3QgZT10LG49bmV3IGx0O2xldCBzPW51bGw7Y29uc3QgaT1uZXcgTDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3Qgcj1lLmdldEdlb21ldHJ5Tih0KSxvPXIuZ2V0Q29vcmRpbmF0ZU4oMCksbD1yLmdldENvb3JkaW5hdGVOKHIuZ2V0TnVtUG9pbnRzKCktMSk7aWYobi5jb250YWlucyhvKSlyZXR1cm4hMTtpZihuLmNvbnRhaW5zKGwpKXJldHVybiExO251bGwhPT1zJiYoby5lcXVhbHMocyl8fChuLmFkZEFsbChpKSxpLmNsZWFyKCkpKSxpLmFkZChvKSxpLmFkZChsKSxzPWx9cmV0dXJuITB9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCksbj1uZXcgQXJyYXkoZS5sZW5ndGgpLmZpbGwobnVsbCkscz1lLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHM7dCsrKW5bcy0xLXRdPW5ldyBtKGVbdF0pO3JldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKG4pfXN0YXRpYyBzZXF1ZW5jZSh0KXtjb25zdCBlPW5ldyBzcjtyZXR1cm4gZS5hZGQodCksZS5nZXRTZXF1ZW5jZWRMaW5lU3RyaW5ncygpfWFkZExpbmUodCl7bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpLHRoaXMuX2xpbmVDb3VudCsrfWhhc1NlcXVlbmNlKHQpe2xldCBlPTA7Zm9yKGxldCBuPXQubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXREZWdyZWUoKSUyPT0xJiZlKyt9cmV0dXJuIGU8PTJ9Y29tcHV0ZVNlcXVlbmNlKCl7aWYodGhpcy5faXNSdW4pcmV0dXJuIG51bGw7dGhpcy5faXNSdW49ITA7Y29uc3QgdD10aGlzLmZpbmRTZXF1ZW5jZXMoKTtpZihudWxsPT09dClyZXR1cm4gbnVsbDt0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeT10aGlzLmJ1aWxkU2VxdWVuY2VkR2VvbWV0cnkodCksdGhpcy5faXNTZXF1ZW5jZWFibGU9ITA7Y29uc3QgZT10aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeS5nZXROdW1HZW9tZXRyaWVzKCk7Zy5pc1RydWUodGhpcy5fbGluZUNvdW50PT09ZSxcIkxpbmVzIHdlcmUgbWlzc2luZyBmcm9tIHJlc3VsdFwiKSxnLmlzVHJ1ZSh0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeSBpbnN0YW5jZW9mIEp8fHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5IGluc3RhbmNlb2Ygd3QsXCJSZXN1bHQgaXMgbm90IGxpbmVhbFwiKX1maW5kU2VxdWVuY2VzKCl7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9bmV3IG5yKHRoaXMuX2dyYXBoKS5nZXRDb25uZWN0ZWRTdWJncmFwaHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZighdGhpcy5oYXNTZXF1ZW5jZShuKSlyZXR1cm4gbnVsbDt7Y29uc3QgZT10aGlzLmZpbmRTZXF1ZW5jZShuKTt0LmFkZChlKX19cmV0dXJuIHR9YWRkUmV2ZXJzZVN1YnBhdGgodCxlLG4pe2NvbnN0IHM9dC5nZXRUb05vZGUoKTtsZXQgaT1udWxsO2Zvcig7Oyl7ZS5hZGQodC5nZXRTeW0oKSksdC5nZXRFZGdlKCkuc2V0VmlzaXRlZCghMCksaT10LmdldEZyb21Ob2RlKCk7Y29uc3Qgbj1zci5maW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUoaSk7aWYobnVsbD09PW4pYnJlYWs7dD1uLmdldFN5bSgpfW4mJmcuaXNUcnVlKGk9PT1zLFwicGF0aCBub3QgY29udGlndW91c1wiKX1maW5kU2VxdWVuY2UodCl7WGkuc2V0VmlzaXRlZCh0LmVkZ2VJdGVyYXRvcigpLCExKTtjb25zdCBlPXNyLmZpbmRMb3dlc3REZWdyZWVOb2RlKHQpLmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0U3ltKCksbj1uZXcgY2kscz1uLmxpc3RJdGVyYXRvcigpO2Zvcih0aGlzLmFkZFJldmVyc2VTdWJwYXRoKGUscywhMSk7cy5oYXNQcmV2aW91cygpOyl7Y29uc3QgdD1zLnByZXZpb3VzKCksZT1zci5maW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUodC5nZXRGcm9tTm9kZSgpKTtudWxsIT09ZSYmdGhpcy5hZGRSZXZlcnNlU3VicGF0aChlLmdldFN5bSgpLHMsITApfXJldHVybiB0aGlzLm9yaWVudChuKX1yZXZlcnNlKHQpe2NvbnN0IGU9bmV3IGNpO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkRmlyc3QodC5nZXRTeW0oKSl9cmV0dXJuIGV9b3JpZW50KHQpe2NvbnN0IGU9dC5nZXQoMCksbj10LmdldCh0LnNpemUoKS0xKSxzPWUuZ2V0RnJvbU5vZGUoKSxpPW4uZ2V0VG9Ob2RlKCk7bGV0IHI9ITE7aWYoMT09PXMuZ2V0RGVncmVlKCl8fDE9PT1pLmdldERlZ3JlZSgpKXtsZXQgdD0hMTsxPT09bi5nZXRUb05vZGUoKS5nZXREZWdyZWUoKSYmITE9PT1uLmdldEVkZ2VEaXJlY3Rpb24oKSYmKHQ9ITAscj0hMCksMT09PWUuZ2V0RnJvbU5vZGUoKS5nZXREZWdyZWUoKSYmITA9PT1lLmdldEVkZ2VEaXJlY3Rpb24oKSYmKHQ9ITAscj0hMSksdHx8MT09PWUuZ2V0RnJvbU5vZGUoKS5nZXREZWdyZWUoKSYmKHI9ITApfXJldHVybiByP3RoaXMucmV2ZXJzZSh0KTp0fWJ1aWxkU2VxdWVuY2VkR2VvbWV0cnkodCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Zm9yKGxldCB0PW4ubmV4dCgpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRFZGdlKCkuZ2V0TGluZSgpO2xldCBpPXM7bi5nZXRFZGdlRGlyZWN0aW9uKCl8fHMuaXNDbG9zZWQoKXx8KGk9c3IucmV2ZXJzZShzKSksZS5hZGQoaSl9fXJldHVybiAwPT09ZS5zaXplKCk/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobmV3IEFycmF5KDApLmZpbGwobnVsbCkpOnRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShlKX1nZXRTZXF1ZW5jZWRMaW5lU3RyaW5ncygpe3JldHVybiB0aGlzLmNvbXB1dGVTZXF1ZW5jZSgpLHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5fWlzU2VxdWVuY2VhYmxlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVNlcXVlbmNlKCksdGhpcy5faXNTZXF1ZW5jZWFibGV9YWRkKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGQoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXthcmd1bWVudHNbMF0uYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIEomJnRoaXMuYWRkTGluZSh0KX19KX19fXZhciBpcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMaW5lTWVyZ2VyOnRyLExpbmVTZXF1ZW5jZXI6c3J9KTtjbGFzcyBycntjb25zdHJ1Y3Rvcigpe3JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3NuYXBUb2xlcmFuY2U9MCx0aGlzLl9zcmNQdHM9bnVsbCx0aGlzLl9zZWc9bmV3IEt0LHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPSExLHRoaXMuX2lzQ2xvc2VkPSExLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSiYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cnIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGVzKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9zcmNQdHM9dCx0aGlzLl9pc0Nsb3NlZD1yci5pc0Nsb3NlZCh0KSx0aGlzLl9zbmFwVG9sZXJhbmNlPWV9fXN0YXRpYyBpc0Nsb3NlZCh0KXtyZXR1cm4hKHQubGVuZ3RoPD0xKSYmdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX1zbmFwVmVydGljZXModCxlKXtjb25zdCBuPXRoaXMuX2lzQ2xvc2VkP3Quc2l6ZSgpLTE6dC5zaXplKCk7Zm9yKGxldCBzPTA7czxuO3MrKyl7Y29uc3Qgbj10LmdldChzKSxpPXRoaXMuZmluZFNuYXBGb3JWZXJ0ZXgobixlKTtudWxsIT09aSYmKHQuc2V0KHMsbmV3IG0oaSkpLDA9PT1zJiZ0aGlzLl9pc0Nsb3NlZCYmdC5zZXQodC5zaXplKCktMSxuZXcgbShpKSkpfX1maW5kU25hcEZvclZlcnRleCh0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtpZih0LmVxdWFsczJEKGVbbl0pKXJldHVybiBudWxsO2lmKHQuZGlzdGFuY2UoZVtuXSk8dGhpcy5fc25hcFRvbGVyYW5jZSlyZXR1cm4gZVtuXX1yZXR1cm4gbnVsbH1zbmFwVG8odCl7Y29uc3QgZT1uZXcgUih0aGlzLl9zcmNQdHMpO3RoaXMuc25hcFZlcnRpY2VzKGUsdCksdGhpcy5zbmFwU2VnbWVudHMoZSx0KTtyZXR1cm4gZS50b0Nvb3JkaW5hdGVBcnJheSgpfXNuYXBTZWdtZW50cyh0LGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDtsZXQgbj1lLmxlbmd0aDtlWzBdLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pJiYobj1lLmxlbmd0aC0xKTtmb3IobGV0IHM9MDtzPG47cysrKXtjb25zdCBuPWVbc10saT10aGlzLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAobix0KTtpPj0wJiZ0LmFkZChpKzEsbmV3IG0obiksITEpfX1maW5kU2VnbWVudEluZGV4VG9TbmFwKHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz0tMTtmb3IobGV0IGk9MDtpPGUuc2l6ZSgpLTE7aSsrKXtpZih0aGlzLl9zZWcucDA9ZS5nZXQoaSksdGhpcy5fc2VnLnAxPWUuZ2V0KGkrMSksdGhpcy5fc2VnLnAwLmVxdWFsczJEKHQpfHx0aGlzLl9zZWcucDEuZXF1YWxzMkQodCkpe2lmKHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKWNvbnRpbnVlO3JldHVybi0xfWNvbnN0IHI9dGhpcy5fc2VnLmRpc3RhbmNlKHQpO3I8dGhpcy5fc25hcFRvbGVyYW5jZSYmcjxuJiYobj1yLHM9aSl9cmV0dXJuIHN9c2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModCl7dGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9dH19Y2xhc3Mgb3J7Y29uc3RydWN0b3IoKXtvci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zcmNHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3JjR2VvbT10fXN0YXRpYyBzbmFwKHQsZSxuKXtjb25zdCBzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGk9bmV3IG9yKHQpO3NbMF09aS5zbmFwVG8oZSxuKTtjb25zdCByPW5ldyBvcihlKTtyZXR1cm4gc1sxXT1yLnNuYXBUbyhzWzBdLG4pLHN9c3RhdGljIGNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1vci5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KTtjb25zdCBuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKTtpZihuLmdldFR5cGUoKT09PU50LkZJWEVEKXtjb25zdCB0PTEvbi5nZXRTY2FsZSgpKjIvMS40MTU7dD5lJiYoZT10KX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIE1hdGgubWluKG9yLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0KSxvci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UoZSkpfX1zdGF0aWMgY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gTWF0aC5taW4oZS5nZXRIZWlnaHQoKSxlLmdldFdpZHRoKCkpKm9yLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUn1zdGF0aWMgc25hcFRvU2VsZih0LGUsbil7cmV0dXJuIG5ldyBvcih0KS5zbmFwVG9TZWxmKGUsbil9c25hcFRvKHQsZSl7Y29uc3Qgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KTtyZXR1cm4gbmV3IGxyKGUsbikudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pfXNuYXBUb1NlbGYodCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHRoaXMuX3NyY0dlb20pLHM9bmV3IGxyKHQsbiwhMCkudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pO2xldCBpPXM7cmV0dXJuIGUmJkkoaSxzdCkmJihpPXMuYnVmZmVyKDApKSxpfWNvbXB1dGVTbmFwVG9sZXJhbmNlKHQpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KS8xMH1leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbHQsbj10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0KyspZS5hZGQoblt0XSk7cmV0dXJuIGUudG9BcnJheShuZXcgQXJyYXkoMCkuZmlsbChudWxsKSl9Y29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpe2xldCBlPXIuTUFYX1ZBTFVFO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspe2NvbnN0IHM9dFtuXS5kaXN0YW5jZSh0W24rMV0pO3M8ZSYmKGU9cyl9cmV0dXJuIGV9fW9yLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUj0xZS05O2NsYXNzIGxyIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLGxyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3NuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLl9zbmFwUHRzPW51bGwsdGhpcy5faXNTZWxmU25hcD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fc25hcFRvbGVyYW5jZT10LHRoaXMuX3NuYXBQdHM9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9zbmFwVG9sZXJhbmNlPXQsdGhpcy5fc25hcFB0cz1lLHRoaXMuX2lzU2VsZlNuYXA9bn19c25hcExpbmUodCxlKXtjb25zdCBuPW5ldyBycih0LHRoaXMuX3NuYXBUb2xlcmFuY2UpO3JldHVybiBuLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHRoaXMuX2lzU2VsZlNuYXApLG4uc25hcFRvKGUpfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCkscz10aGlzLnNuYXBMaW5lKG4sdGhpcy5fc25hcFB0cyk7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX19dmFyIGFyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5U25hcHBlcjpvcixMaW5lU3RyaW5nU25hcHBlcjpycn0pO2NsYXNzIGNye2NvbnN0cnVjdG9yKCl7Y3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fZGF0YT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX2RhdGE9ZX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdHN9c2l6ZSgpe3JldHVybiB0aGlzLl9wdHMubGVuZ3RofWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0c1t0XX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoLTFdKX1nZXRTZWdtZW50T2N0YW50KHQpe3JldHVybiB0PT09dGhpcy5fcHRzLmxlbmd0aC0xPy0xOlhzLm9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcobmV3IHB0KHRoaXMuX3B0cykpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltVc119fWNsYXNzIGhye2NvbnN0cnVjdG9yKCl7aHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seT0hMSx0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucz0hMCx0aGlzLl9pc0ludGVyaW9ySW50ZXJzZWN0aW9uc09ubHk9ITEsdGhpcy5fbGk9bnVsbCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj1udWxsLHRoaXMuX2ludFNlZ21lbnRzPW51bGwsdGhpcy5faW50ZXJzZWN0aW9ucz1uZXcgTCx0aGlzLl9pbnRlcnNlY3Rpb25Db3VudD0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpPXQsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbH1zdGF0aWMgY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlcih0KXtjb25zdCBlPW5ldyBocih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZX1zdGF0aWMgaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbigpe2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1szXTtyZXR1cm4oIWFyZ3VtZW50c1syXXx8IW4pJiYhIXQuZXF1YWxzMkQoZSl9aWYoOD09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdLG89YXJndW1lbnRzWzZdLGw9YXJndW1lbnRzWzddO3JldHVybiEhaHIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbih0LG4saSxvKXx8KCEhaHIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbih0LHMsaSxsKXx8KCEhaHIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbihlLG4scixvKXx8ISFoci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKGUscyxyLGwpKSl9fXN0YXRpYyBjcmVhdGVJbnRlcmlvckludGVyc2VjdGlvbkNvdW50ZXIodCl7Y29uc3QgZT1uZXcgaHIodCk7cmV0dXJuIGUuc2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seSghMCksZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX1zdGF0aWMgY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlcih0KXtjb25zdCBlPW5ldyBocih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX1zdGF0aWMgaXNFbmRTZWdtZW50KHQsZSl7cmV0dXJuIDA9PT1lfHxlPj10LnNpemUoKS0yfXN0YXRpYyBjcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIodCl7cmV0dXJuIG5ldyBocih0KX1zdGF0aWMgY3JlYXRlSW50ZXJpb3JJbnRlcnNlY3Rpb25zRmluZGVyKHQpe2NvbnN0IGU9bmV3IGhyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEludGVyaW9ySW50ZXJzZWN0aW9uc09ubHkoITApLGV9c2V0Q2hlY2tFbmRTZWdtZW50c09ubHkodCl7dGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seT10fWdldEludGVyc2VjdGlvblNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX2ludFNlZ21lbnRzfWNvdW50KCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50fWdldEludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uc31zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz10fXNldEtlZXBJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2tlZXBJbnRlcnNlY3Rpb25zPXR9Z2V0SW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ufXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKCF0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyYmdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4gbnVsbDtjb25zdCBpPXQ9PT1uO2lmKGkmJmU9PT1zKXJldHVybiBudWxsO2lmKHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkpe2lmKCEoaHIuaXNFbmRTZWdtZW50KHQsZSl8fGhyLmlzRW5kU2VnbWVudChuLHMpKSlyZXR1cm4gbnVsbH1jb25zdCByPXQuZ2V0Q29vcmRpbmF0ZShlKSxvPXQuZ2V0Q29vcmRpbmF0ZShlKzEpLGw9bi5nZXRDb29yZGluYXRlKHMpLGE9bi5nZXRDb29yZGluYXRlKHMrMSksYz0wPT09ZSxoPWUrMj09PXQuc2l6ZSgpLHU9MD09PXMsZz1zKzI9PT1uLnNpemUoKTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIsbyxsLGEpO2NvbnN0IGQ9dGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKTtsZXQgXz0hMTtpZighdGhpcy5faXNJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5KXtfPSEoaSYmTWF0aC5hYnMocy1lKTw9MSkmJmhyLmlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24ocixvLGwsYSxjLGgsdSxnKX0oZHx8XykmJih0aGlzLl9pbnRTZWdtZW50cz1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLl9pbnRTZWdtZW50c1swXT1yLHRoaXMuX2ludFNlZ21lbnRzWzFdPW8sdGhpcy5faW50U2VnbWVudHNbMl09bCx0aGlzLl9pbnRTZWdtZW50c1szXT1hLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPXRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKSx0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucyYmdGhpcy5faW50ZXJzZWN0aW9ucy5hZGQodGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24pLHRoaXMuX2ludGVyc2VjdGlvbkNvdW50KyspfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zJiZudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259c2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seSh0KXt0aGlzLl9pc0ludGVyaW9ySW50ZXJzZWN0aW9uc09ubHk9dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVGldfX1jbGFzcyB1cntjb25zdHJ1Y3Rvcigpe3VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9zZWdTdHJpbmdzPW51bGwsdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5fc2VnSW50PW51bGwsdGhpcy5faXNWYWxpZD0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWdTdHJpbmdzPXR9c3RhdGljIGNvbXB1dGVJbnRlcnNlY3Rpb25zKHQpe2NvbnN0IGU9bmV3IHVyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLmlzVmFsaWQoKSxlLmdldEludGVyc2VjdGlvbnMoKX1leGVjdXRlKCl7aWYobnVsbCE9PXRoaXMuX3NlZ0ludClyZXR1cm4gbnVsbDt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5leGVjdXRlKCksdGhpcy5faXNWYWxpZH1zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz10fWNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7dGhpcy5faXNWYWxpZD0hMCx0aGlzLl9zZWdJbnQ9bmV3IGhyKHRoaXMuX2xpKSx0aGlzLl9zZWdJbnQuc2V0RmluZEFsbEludGVyc2VjdGlvbnModGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMpO2NvbnN0IHQ9bmV3ICRzO2lmKHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuX3NlZ0ludCksdC5jb21wdXRlTm9kZXModGhpcy5fc2VnU3RyaW5ncyksdGhpcy5fc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpKXJldHVybiB0aGlzLl9pc1ZhbGlkPSExLG51bGx9Y2hlY2tWYWxpZCgpe2lmKHRoaXMuZXhlY3V0ZSgpLCF0aGlzLl9pc1ZhbGlkKXRocm93IG5ldyBzcyh0aGlzLmdldEVycm9yTWVzc2FnZSgpLHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb24oKSl9Z2V0RXJyb3JNZXNzYWdlKCl7aWYodGhpcy5faXNWYWxpZClyZXR1cm5cIm5vIGludGVyc2VjdGlvbnMgZm91bmRcIjtjb25zdCB0PXRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpO3JldHVyblwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBiZXR3ZWVuIFwiK1d0LnRvTGluZVN0cmluZyh0WzBdLHRbMV0pK1wiIGFuZCBcIitXdC50b0xpbmVTdHJpbmcodFsyXSx0WzNdKX19Y2xhc3MgZ3J7Y29uc3RydWN0b3IoKXtnci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9udj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX252PW5ldyB1cihnci50b1NlZ21lbnRTdHJpbmdzKHQpKX1zdGF0aWMgdG9TZWdtZW50U3RyaW5ncyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBjcih0LmdldENvb3JkaW5hdGVzKCksdCkpfXJldHVybiBlfXN0YXRpYyBjaGVja1ZhbGlkKHQpe25ldyBncih0KS5jaGVja1ZhbGlkKCl9Y2hlY2tWYWxpZCgpe3RoaXMuX252LmNoZWNrVmFsaWQoKX19Y2xhc3MgZHJ7Y29uc3RydWN0b3IoKXtkci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vcD1udWxsLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3B0TG9jYXRvcj1udWxsLHRoaXMuX2xpbmVFZGdlc0xpc3Q9bmV3IEwsdGhpcy5fcmVzdWx0TGluZUxpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLl9wdExvY2F0b3I9bn1jb2xsZWN0TGluZXModCl7Zm9yKGxldCBlPXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLmNvbGxlY3RMaW5lRWRnZShuLHQsdGhpcy5fbGluZUVkZ2VzTGlzdCksdGhpcy5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2Uobix0LHRoaXMuX2xpbmVFZGdlc0xpc3QpfX1sYWJlbElzb2xhdGVkTGluZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9vcC5nZXRBcmdHZW9tZXRyeShlKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9YnVpbGQodCl7cmV0dXJuIHRoaXMuZmluZENvdmVyZWRMaW5lRWRnZXMoKSx0aGlzLmNvbGxlY3RMaW5lcyh0KSx0aGlzLmJ1aWxkTGluZXModCksdGhpcy5fcmVzdWx0TGluZUxpc3R9Y29sbGVjdExpbmVFZGdlKHQsZSxuKXtjb25zdCBzPXQuZ2V0TGFiZWwoKSxpPXQuZ2V0RWRnZSgpO3QuaXNMaW5lRWRnZSgpJiYodC5pc1Zpc2l0ZWQoKXx8IU5yLmlzUmVzdWx0T2ZPcChzLGUpfHxpLmlzQ292ZXJlZCgpfHwobi5hZGQoaSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKX1maW5kQ292ZXJlZExpbmVFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuZmluZENvdmVyZWRMaW5lRWRnZXMoKX1mb3IobGV0IHQ9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRFZGdlKCk7aWYoZS5pc0xpbmVFZGdlKCkmJiFuLmlzQ292ZXJlZFNldCgpKXtjb25zdCB0PXRoaXMuX29wLmlzQ292ZXJlZEJ5QShlLmdldENvb3JkaW5hdGUoKSk7bi5zZXRDb3ZlcmVkKHQpfX19bGFiZWxJc29sYXRlZExpbmVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRMYWJlbCgpO3QuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTGluZSh0LDApOnRoaXMubGFiZWxJc29sYXRlZExpbmUodCwxKSl9fWJ1aWxkTGluZXModCl7Zm9yKGxldCB0PXRoaXMuX2xpbmVFZGdlc0xpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlLmdldENvb3JkaW5hdGVzKCkpO3RoaXMuX3Jlc3VsdExpbmVMaXN0LmFkZChuKSxlLnNldEluUmVzdWx0KCEwKX19Y29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKHQsZSxuKXtjb25zdCBzPXQuZ2V0TGFiZWwoKTtyZXR1cm4gdC5pc0xpbmVFZGdlKCl8fHQuaXNWaXNpdGVkKCl8fHQuaXNJbnRlcmlvckFyZWFFZGdlKCl8fHQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKT9udWxsOihnLmlzVHJ1ZSghKHQuaXNJblJlc3VsdCgpfHx0LmdldFN5bSgpLmlzSW5SZXN1bHQoKSl8fCF0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpLHZvaWQoTnIuaXNSZXN1bHRPZk9wKHMsZSkmJmU9PT1Oci5JTlRFUlNFQ1RJT04mJihuLmFkZCh0LmdldEVkZ2UoKSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKSl9fWNsYXNzIF9ye2NvbnN0cnVjdG9yKCl7X3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3A9bnVsbCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9yZXN1bHRQb2ludExpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZX1maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoKTtpZighdGhpcy5fb3AuaXNDb3ZlcmVkQnlMQShlKSl7Y29uc3QgdD10aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSk7dGhpcy5fcmVzdWx0UG9pbnRMaXN0LmFkZCh0KX19ZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKCFuLmlzSW5SZXN1bHQoKSYmKCFuLmlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKSYmKDA9PT1uLmdldEVkZ2VzKCkuZ2V0RGVncmVlKCl8fHQ9PT1Oci5JTlRFUlNFQ1RJT04pKSl7Y29uc3QgZT1uLmdldExhYmVsKCk7TnIuaXNSZXN1bHRPZk9wKGUsdCkmJnRoaXMuZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50KG4pfX19YnVpbGQodCl7cmV0dXJuIHRoaXMuZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2Rlcyh0KSx0aGlzLl9yZXN1bHRQb2ludExpc3R9fWNsYXNzIHBye2NvbnN0cnVjdG9yKCl7dGhpcy5faXNGaXJzdD0hMCx0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudD01Myx0aGlzLl9jb21tb25CaXRzPW5ldyBpLHRoaXMuX2NvbW1vblNpZ25FeHA9bnVsbH1nZXRDb21tb24oKXtyZXR1cm4gci5sb25nQml0c1RvRG91YmxlKHRoaXMuX2NvbW1vbkJpdHMpfWFkZCh0KXtjb25zdCBlPXIuZG91YmxlVG9Mb25nQml0cyh0KTtpZih0aGlzLl9pc0ZpcnN0KXJldHVybiB0aGlzLl9jb21tb25CaXRzPWUsdGhpcy5fY29tbW9uU2lnbkV4cD1wci5zaWduRXhwQml0cyh0aGlzLl9jb21tb25CaXRzKSx0aGlzLl9pc0ZpcnN0PSExLG51bGw7aWYocHIuc2lnbkV4cEJpdHMoZSkhPT10aGlzLl9jb21tb25TaWduRXhwKXJldHVybiB0aGlzLl9jb21tb25CaXRzLmhpZ2g9MCx0aGlzLl9jb21tb25CaXRzLmxvdz0wLG51bGw7dGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9cHIubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0aGlzLl9jb21tb25CaXRzLGUpLHRoaXMuX2NvbW1vbkJpdHM9cHIuemVyb0xvd2VyQml0cyh0aGlzLl9jb21tb25CaXRzLDY0LSgxMit0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudCkpfXRvU3RyaW5nKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9ci5sb25nQml0c1RvRG91YmxlKHQpLG49XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIraS50b0JpbmFyeVN0cmluZyh0KSxzPW4uc3Vic3RyaW5nKG4ubGVuZ3RoLTY0KTtyZXR1cm4gcy5zdWJzdHJpbmcoMCwxKStcIiAgXCIrcy5zdWJzdHJpbmcoMSwxMikrXCIoZXhwKSBcIitzLnN1YnN0cmluZygxMikrXCIgWyBcIitlK1wiIF1cIn19Z2V0Q2xhc3MoKXtyZXR1cm4gcHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119c3RhdGljIGdldEJpdCh0LGUpe2NvbnN0IG49MTw8ZSUzMjtyZXR1cm4gZTwzMj8wIT0odC5sb3cmbik/MTowOjAhPSh0LmhpZ2gmbik/MTowfXN0YXRpYyBzaWduRXhwQml0cyh0KXtyZXR1cm4gdC5oaWdoPj4+MjB9c3RhdGljIHplcm9Mb3dlckJpdHModCxlKXtsZXQgbj1cImxvd1wiO2lmKGU+MzImJih0Lmxvdz0wLGUlPTMyLG49XCJoaWdoXCIpLGU+MCl7Y29uc3Qgcz1lPDMyP34oKDE8PGUpLTEpOjA7dFtuXSY9c31yZXR1cm4gdH1zdGF0aWMgbnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0LGUpe2xldCBuPTA7Zm9yKGxldCBzPTUyO3M+PTA7cy0tKXtpZihwci5nZXRCaXQodCxzKSE9PXByLmdldEJpdChlLHMpKXJldHVybiBuO24rK31yZXR1cm4gNTJ9fWNsYXNzIG1ye2NvbnN0cnVjdG9yKCl7bXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29tbW9uQ29vcmQ9bnVsbCx0aGlzLl9jY0ZpbHRlcj1uZXcgZnJ9YWRkQ29tbW9uQml0cyh0KXtjb25zdCBlPW5ldyB5cih0aGlzLl9jb21tb25Db29yZCk7dC5hcHBseShlKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpfXJlbW92ZUNvbW1vbkJpdHModCl7aWYoMD09PXRoaXMuX2NvbW1vbkNvb3JkLngmJjA9PT10aGlzLl9jb21tb25Db29yZC55KXJldHVybiB0O2NvbnN0IGU9bmV3IG0odGhpcy5fY29tbW9uQ29vcmQpO2UueD0tZS54LGUueT0tZS55O2NvbnN0IG49bmV3IHlyKGUpO3JldHVybiB0LmFwcGx5KG4pLHQuZ2VvbWV0cnlDaGFuZ2VkKCksdH1nZXRDb21tb25Db29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2NvbW1vbkNvb3JkfWFkZCh0KXt0LmFwcGx5KHRoaXMuX2NjRmlsdGVyKSx0aGlzLl9jb21tb25Db29yZD10aGlzLl9jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCl9fWNsYXNzIGZye2NvbnN0cnVjdG9yKCl7ZnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29tbW9uQml0c1g9bmV3IHByLHRoaXMuX2NvbW1vbkJpdHNZPW5ldyBwcn1maWx0ZXIodCl7dGhpcy5fY29tbW9uQml0c1guYWRkKHQueCksdGhpcy5fY29tbW9uQml0c1kuYWRkKHQueSl9Z2V0Q29tbW9uQ29vcmRpbmF0ZSgpe3JldHVybiBuZXcgbSh0aGlzLl9jb21tb25CaXRzWC5nZXRDb21tb24oKSx0aGlzLl9jb21tb25CaXRzWS5nZXRDb21tb24oKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1VdfX1jbGFzcyB5cntjb25zdHJ1Y3Rvcigpe3lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMudHJhbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRyYW5zPXR9ZmlsdGVyKHQsZSl7Y29uc3Qgbj10LmdldE9yZGluYXRlKGUsMCkrdGhpcy50cmFucy54LHM9dC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMudHJhbnMueTt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX1pc0RvbmUoKXtyZXR1cm4hMX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiEwfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltQXX19bXIuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlcj1mcixtci5UcmFuc2xhdGVyPXlyO2NsYXNzIHhye2NvbnN0cnVjdG9yKCl7eHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5fY2JyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZSx0aGlzLmNvbXB1dGVTbmFwVG9sZXJhbmNlKCl9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyB4cih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiB4ci5vdmVybGF5T3AodCxlLE5yLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIHhyLm92ZXJsYXlPcCh0LGUsTnIuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe3JldHVybiB4ci5vdmVybGF5T3AodCxlLE5yLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7cmV0dXJuIHhyLm92ZXJsYXlPcCh0LGUsTnIuRElGRkVSRU5DRSl9c2VsZlNuYXAodCl7cmV0dXJuIG5ldyBvcih0KS5zbmFwVG8odCx0aGlzLl9zbmFwVG9sZXJhbmNlKX1yZW1vdmVDb21tb25CaXRzKHQpe3RoaXMuX2Nicj1uZXcgbXIsdGhpcy5fY2JyLmFkZCh0WzBdKSx0aGlzLl9jYnIuYWRkKHRbMV0pO2NvbnN0IGU9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIGVbMF09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModFswXS5jb3B5KCkpLGVbMV09dGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHModFsxXS5jb3B5KCkpLGV9cHJlcGFyZVJlc3VsdCh0KXtyZXR1cm4gdGhpcy5fY2JyLmFkZENvbW1vbkJpdHModCksdH1nZXRSZXN1bHRHZW9tZXRyeSh0KXtjb25zdCBlPXRoaXMuc25hcCh0aGlzLl9nZW9tKSxuPU5yLm92ZXJsYXlPcChlWzBdLGVbMV0sdCk7cmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChuKX1jaGVja1ZhbGlkKHQpe3QuaXNWYWxpZCgpfHxCLm91dC5wcmludGxuKFwiU25hcHBlZCBnZW9tZXRyeSBpcyBpbnZhbGlkXCIpfWNvbXB1dGVTbmFwVG9sZXJhbmNlKCl7dGhpcy5fc25hcFRvbGVyYW5jZT1vci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdKX1zbmFwKHQpe2NvbnN0IGU9dGhpcy5yZW1vdmVDb21tb25CaXRzKHQpO3JldHVybiBvci5zbmFwKGVbMF0sZVsxXSx0aGlzLl9zbmFwVG9sZXJhbmNlKX19Y2xhc3MgRXJ7Y29uc3RydWN0b3IoKXtFci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWV9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyBFcih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBFci5vdmVybGF5T3AodCxlLE5yLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsTnIuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe3JldHVybiBFci5vdmVybGF5T3AodCxlLE5yLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsTnIuRElGRkVSRU5DRSl9Z2V0UmVzdWx0R2VvbWV0cnkodCl7bGV0IGU9bnVsbCxuPSExLHM9bnVsbDt0cnl7ZT1Oci5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdLHQpOyEwJiYobj0hMCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDtzPXR9aWYoIW4pdHJ5e2U9eHIub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSx0KX1jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgaD9zOnR9cmV0dXJuIGV9fWNsYXNzIElye2NvbnN0cnVjdG9yKCl7SXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGk9bmV3IGp0LHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYXJnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBscygwLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0lyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLGduLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dC5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhlLmdldFByZWNpc2lvbk1vZGVsKCkpPj0wP3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKTp0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fYXJnPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2FyZ1swXT1uZXcgbHMoMCx0LG4pLHRoaXMuX2FyZ1sxXT1uZXcgbHMoMSxlLG4pfX1nZXRBcmdHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5fYXJnW3RdLmdldEdlb21ldHJ5KCl9c2V0Q29tcHV0YXRpb25QcmVjaXNpb24odCl7dGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9saS5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbCl9fWNsYXNzIE5yIGV4dGVuZHMgSXJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLE5yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0TG9jYXRvcj1uZXcgZm4sdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9yZXN1bHRHZW9tPW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9lZGdlTGlzdD1uZXcgTGksdGhpcy5fcmVzdWx0UG9seUxpc3Q9bmV3IEwsdGhpcy5fcmVzdWx0TGluZUxpc3Q9bmV3IEwsdGhpcy5fcmVzdWx0UG9pbnRMaXN0PW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0lyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9ncmFwaD1uZXcgb3MobmV3IHdpKSx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IE5yKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIE5yLmNyZWF0ZUVtcHR5UmVzdWx0KE5yLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1pZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSxOci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSlyZXR1cm4gTnIuY3JlYXRlRW1wdHlSZXN1bHQoTnIuSU5URVJTRUNUSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXtjb25zdCBuPWU7cmV0dXJuIGNlLm1hcCh0LG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bTWFwT3BdfW1hcCh0KXtyZXR1cm4gTnIuaW50ZXJzZWN0aW9uKHQsbil9fSl9cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsTnIuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBOci5jcmVhdGVFbXB0eVJlc3VsdChOci5TWU1ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1pZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSxOci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgcmVzdWx0RGltZW5zaW9uKHQsZSxuKXtjb25zdCBzPWUuZ2V0RGltZW5zaW9uKCksaT1uLmdldERpbWVuc2lvbigpO2xldCByPS0xO3N3aXRjaCh0KXtjYXNlIE5yLklOVEVSU0VDVElPTjpyPU1hdGgubWluKHMsaSk7YnJlYWs7Y2FzZSBOci5VTklPTjpyPU1hdGgubWF4KHMsaSk7YnJlYWs7Y2FzZSBOci5ESUZGRVJFTkNFOnI9czticmVhaztjYXNlIE5yLlNZTURJRkZFUkVOQ0U6cj1NYXRoLm1heChzLGkpfXJldHVybiByfXN0YXRpYyBjcmVhdGVFbXB0eVJlc3VsdCh0LGUsbixzKXtjb25zdCBpPU5yLnJlc3VsdERpbWVuc2lvbih0LGUsbik7cmV0dXJuIHMuY3JlYXRlRW1wdHkoaSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gTnIuY3JlYXRlRW1wdHlSZXN1bHQoTnIuRElGRkVSRU5DRSx0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKTtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSxOci5ESUZGRVJFTkNFKX1zdGF0aWMgaXNSZXN1bHRPZk9wKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRMb2NhdGlvbigwKSxzPXQuZ2V0TG9jYXRpb24oMSk7cmV0dXJuIE5yLmlzUmVzdWx0T2ZPcChuLHMsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtzd2l0Y2godD09PVF0LkJPVU5EQVJZJiYodD1RdC5JTlRFUklPUiksZT09PVF0LkJPVU5EQVJZJiYoZT1RdC5JTlRFUklPUiksbil7Y2FzZSBOci5JTlRFUlNFQ1RJT046cmV0dXJuIHQ9PT1RdC5JTlRFUklPUiYmZT09PVF0LklOVEVSSU9SO2Nhc2UgTnIuVU5JT046cmV0dXJuIHQ9PT1RdC5JTlRFUklPUnx8ZT09PVF0LklOVEVSSU9SO2Nhc2UgTnIuRElGRkVSRU5DRTpyZXR1cm4gdD09PVF0LklOVEVSSU9SJiZlIT09UXQuSU5URVJJT1I7Y2FzZSBOci5TWU1ESUZGRVJFTkNFOnJldHVybiB0PT09UXQuSU5URVJJT1ImJmUhPT1RdC5JTlRFUklPUnx8dCE9PVF0LklOVEVSSU9SJiZlPT09UXQuSU5URVJJT1J9cmV0dXJuITF9fWluc2VydFVuaXF1ZUVkZ2UodCl7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXtjb25zdCBuPWUuZ2V0TGFiZWwoKTtsZXQgcz10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwocz1uZXcgcW4odC5nZXRMYWJlbCgpKSxzLmZsaXAoKSk7Y29uc3QgaT1lLmdldERlcHRoKCk7aS5pc051bGwoKSYmaS5hZGQobiksaS5hZGQocyksbi5tZXJnZShzKX1lbHNlIHRoaXMuX2VkZ2VMaXN0LmFkZCh0KX1nZXRHcmFwaCgpe3JldHVybiB0aGlzLl9ncmFwaH1jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRTeW0oKTtlLmlzSW5SZXN1bHQoKSYmbi5pc0luUmVzdWx0KCkmJihlLnNldEluUmVzdWx0KCExKSxuLnNldEluUmVzdWx0KCExKSl9fWlzQ292ZXJlZEJ5TEEodCl7cmV0dXJuISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdExpbmVMaXN0KXx8ISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0KX1jb21wdXRlR2VvbWV0cnkodCxlLG4scyl7Y29uc3QgaT1uZXcgTDtyZXR1cm4gaS5hZGRBbGwodCksaS5hZGRBbGwoZSksaS5hZGRBbGwobiksaS5pc0VtcHR5KCk/TnIuY3JlYXRlRW1wdHlSZXN1bHQocyx0aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKSx0aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKSx0aGlzLl9nZW9tRmFjdCk6dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShpKX1tZXJnZVN5bUxhYmVscygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLm1lcmdlU3ltTGFiZWxzKCl9fWlzQ292ZXJlZCh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2lmKHRoaXMuX3B0TG9jYXRvci5sb2NhdGUodCxlKSE9PVF0LkVYVEVSSU9SKXJldHVybiEwfXJldHVybiExfXJlcGxhY2VDb2xsYXBzZWRFZGdlcygpe2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPXRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24uaXNDb2xsYXBzZWQoKSYmKGUucmVtb3ZlKCksdC5hZGQobi5nZXRDb2xsYXBzZWRFZGdlKCkpKX10aGlzLl9lZGdlTGlzdC5hZGRBbGwodCl9dXBkYXRlTm9kZUxhYmVsbGluZygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRFZGdlcygpLmdldExhYmVsKCk7ZS5nZXRMYWJlbCgpLm1lcmdlKG4pfX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtyZXR1cm4gdGhpcy5jb21wdXRlT3ZlcmxheSh0KSx0aGlzLl9yZXN1bHRHZW9tfWluc2VydFVuaXF1ZUVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZSh0KX19Y29tcHV0ZU92ZXJsYXkodCl7dGhpcy5jb3B5UG9pbnRzKDApLHRoaXMuY29weVBvaW50cygxKSx0aGlzLl9hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5fYXJnWzFdLHRoaXMuX2xpLCEwKTtjb25zdCBlPW5ldyBMO3RoaXMuX2FyZ1swXS5jb21wdXRlU3BsaXRFZGdlcyhlKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5pbnNlcnRVbmlxdWVFZGdlcyhlKSx0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCksdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKSxnci5jaGVja1ZhbGlkKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuY29tcHV0ZUxhYmVsbGluZygpLHRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZXMoKSx0aGlzLmZpbmRSZXN1bHRBcmVhRWRnZXModCksdGhpcy5jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpO2NvbnN0IG49bmV3IF9pKHRoaXMuX2dlb21GYWN0KTtuLmFkZCh0aGlzLl9ncmFwaCksdGhpcy5fcmVzdWx0UG9seUxpc3Q9bi5nZXRQb2x5Z29ucygpO2NvbnN0IHM9bmV3IGRyKHRoaXMsdGhpcy5fZ2VvbUZhY3QsdGhpcy5fcHRMb2NhdG9yKTt0aGlzLl9yZXN1bHRMaW5lTGlzdD1zLmJ1aWxkKHQpO2NvbnN0IGk9bmV3IF9yKHRoaXMsdGhpcy5fZ2VvbUZhY3QsdGhpcy5fcHRMb2NhdG9yKTt0aGlzLl9yZXN1bHRQb2ludExpc3Q9aS5idWlsZCh0KSx0aGlzLl9yZXN1bHRHZW9tPXRoaXMuY29tcHV0ZUdlb21ldHJ5KHRoaXMuX3Jlc3VsdFBvaW50TGlzdCx0aGlzLl9yZXN1bHRMaW5lTGlzdCx0aGlzLl9yZXN1bHRQb2x5TGlzdCx0KX1sYWJlbEluY29tcGxldGVOb2RlKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2FyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX1jb3B5UG9pbnRzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuX2dyYXBoLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19ZmluZFJlc3VsdEFyZWFFZGdlcyh0KXtmb3IobGV0IGU9dGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKTtzLmlzQXJlYSgpJiYhbi5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmTnIuaXNSZXN1bHRPZk9wKHMuZ2V0TG9jYXRpb24oMCxNbi5SSUdIVCkscy5nZXRMb2NhdGlvbigxLE1uLlJJR0hUKSx0KSYmbi5zZXRJblJlc3VsdCghMCl9fWNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCl7Zm9yKGxldCB0PXRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpLHM9ZS5nZXREZXB0aCgpO2lmKCFzLmlzTnVsbCgpKXtzLm5vcm1hbGl6ZSgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspbi5pc051bGwodCl8fCFuLmlzQXJlYSgpfHxzLmlzTnVsbCh0KXx8KDA9PT1zLmdldERlbHRhKHQpP24udG9MaW5lKHQpOihnLmlzVHJ1ZSghcy5pc051bGwodCxNbi5MRUZUKSxcImRlcHRoIG9mIExFRlQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbih0LE1uLkxFRlQscy5nZXRMb2NhdGlvbih0LE1uLkxFRlQpKSxnLmlzVHJ1ZSghcy5pc051bGwodCxNbi5SSUdIVCksXCJkZXB0aCBvZiBSSUdIVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHQsTW4uUklHSFQscy5nZXRMb2NhdGlvbih0LE1uLlJJR0hUKSkpKX19fWNvbXB1dGVMYWJlbGxpbmcoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuX2FyZyl9dGhpcy5tZXJnZVN5bUxhYmVscygpLHRoaXMudXBkYXRlTm9kZUxhYmVsbGluZygpfWxhYmVsSW5jb21wbGV0ZU5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7ZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUoZSwwKTp0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUoZSwxKSksZS5nZXRFZGdlcygpLnVwZGF0ZUxhYmVsbGluZyhuKX19aXNDb3ZlcmVkQnlBKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRQb2x5TGlzdCl9fU5yLklOVEVSU0VDVElPTj0xLE5yLlVOSU9OPTIsTnIuRElGRkVSRU5DRT0zLE5yLlNZTURJRkZFUkVOQ0U9NDt2YXIgU3I9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsc25hcDphcixPdmVybGF5T3A6TnJ9KTtjbGFzcyB3ciBleHRlbmRzIFVpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx3ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lZGdlUmluZz1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9sYWJlbD0tMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtVaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLHMpfWdldE5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1pc0luUmluZygpe3JldHVybiBudWxsIT09dGhpcy5fZWRnZVJpbmd9c2V0UmluZyh0KXt0aGlzLl9lZGdlUmluZz10fXNldExhYmVsKHQpe3RoaXMuX2xhYmVsPXR9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9Z2V0UmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ319Y2xhc3MgQ3IgZXh0ZW5kcyBXaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQ3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2xpbmV9fWNsYXNzIExye2NvbnN0cnVjdG9yKCl7THIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW5ldyBDdCx0aGlzLl9nZW9tR3JhcGg9bnVsbCx0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tR3JhcGg9dH1zdGF0aWMgZmluZERpZmZlcmVudFBvaW50KHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGUpKXJldHVybiB0W25dO3JldHVybiBudWxsfXZpc2l0SW50ZXJpb3JSaW5nKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCkscz1uWzBdLGk9THIuZmluZERpZmZlcmVudFBvaW50KG4scykscj1lLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHMsaSksbz1lLmZpbmRFZGdlRW5kKHIpO2xldCBsPW51bGw7by5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsTW4uUklHSFQpPT09UXQuSU5URVJJT1I/bD1vOm8uZ2V0U3ltKCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLE1uLlJJR0hUKT09PVF0LklOVEVSSU9SJiYobD1vLmdldFN5bSgpKSxnLmlzVHJ1ZShudWxsIT09bCxcInVuYWJsZSB0byBmaW5kIGRpckVkZ2Ugd2l0aCBJbnRlcmlvciBvbiBSSFNcIiksdGhpcy52aXNpdExpbmtlZERpcmVjdGVkRWRnZXMobCl9dmlzaXRTaGVsbEludGVyaW9ycyh0LGUpe2lmKHQgaW5zdGFuY2VvZiBpdCl7Y29uc3Qgbj10O3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX1pZih0IGluc3RhbmNlb2YgZnQpe2NvbnN0IG49dDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5Tih0KTt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKHMuZ2V0RXh0ZXJpb3JSaW5nKCksZSl9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZH1zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQodCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxNbi5SSUdIVCk9PT1RdC5JTlRFUklPUiYmdC5zZXRJblJlc3VsdCghMCl9fXZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyh0KXtjb25zdCBlPXQ7bGV0IG49dDtkb3tnLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgRGlyZWN0ZWQgRWRnZVwiKSxuLnNldFZpc2l0ZWQoITApLG49bi5nZXROZXh0KCl9d2hpbGUobiE9PWUpfWJ1aWxkRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc0luUmVzdWx0KCkmJm51bGw9PT10LmdldEVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IGRpKHQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtuLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9bi5idWlsZE1pbmltYWxSaW5ncygpO2UuYWRkQWxsKHMpfX1yZXR1cm4gZX1oYXNVbnZpc2l0ZWRTaGVsbEVkZ2UodCl7Zm9yKGxldCBlPTA7ZTx0LnNpemUoKTtlKyspe2NvbnN0IG49dC5nZXQoZSk7aWYobi5pc0hvbGUoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0RWRnZXMoKTtsZXQgaT1zLmdldCgwKTtpZihpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxNbi5SSUdIVCk9PT1RdC5JTlRFUklPUilmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKylpZihpPXMuZ2V0KHQpLCFpLmlzVmlzaXRlZCgpKXJldHVybiB0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmQ9aS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9aXNJbnRlcmlvcnNDb25uZWN0ZWQoKXtjb25zdCB0PW5ldyBMO3RoaXMuX2dlb21HcmFwaC5jb21wdXRlU3BsaXRFZGdlcyh0KTtjb25zdCBlPW5ldyBvcyhuZXcgd2kpO2UuYWRkRWRnZXModCksdGhpcy5zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQoZSksZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpO2NvbnN0IG49dGhpcy5idWlsZEVkZ2VSaW5ncyhlLmdldEVkZ2VFbmRzKCkpO3JldHVybiB0aGlzLnZpc2l0U2hlbGxJbnRlcmlvcnModGhpcy5fZ2VvbUdyYXBoLmdldEdlb21ldHJ5KCksZSksIXRoaXMuaGFzVW52aXNpdGVkU2hlbGxFZGdlKG4pfX1jbGFzcyBUcntjcmVhdGVFZGdlRW5kRm9yTmV4dCh0LGUsbixzKXtjb25zdCBpPW4uc2VnbWVudEluZGV4KzE7aWYoaT49dC5nZXROdW1Qb2ludHMoKSYmbnVsbD09PXMpcmV0dXJuIG51bGw7bGV0IHI9dC5nZXRDb29yZGluYXRlKGkpO251bGwhPT1zJiZzLnNlZ21lbnRJbmRleD09PW4uc2VnbWVudEluZGV4JiYocj1zLmNvb3JkKTtjb25zdCBvPW5ldyBucyh0LG4uY29vcmQscixuZXcgcW4odC5nZXRMYWJlbCgpKSk7ZS5hZGQobyl9Y3JlYXRlRWRnZUVuZEZvclByZXYodCxlLG4scyl7bGV0IGk9bi5zZWdtZW50SW5kZXg7aWYoMD09PW4uZGlzdCl7aWYoMD09PWkpcmV0dXJuIG51bGw7aS0tfWxldCByPXQuZ2V0Q29vcmRpbmF0ZShpKTtudWxsIT09cyYmcy5zZWdtZW50SW5kZXg+PWkmJihyPXMuY29vcmQpO2NvbnN0IG89bmV3IHFuKHQuZ2V0TGFiZWwoKSk7by5mbGlwKCk7Y29uc3QgbD1uZXcgbnModCxuLmNvb3JkLHIsbyk7ZS5hZGQobCl9Y29tcHV0ZUVkZ2VFbmRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7Zm9yKGxldCBuPXQ7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuY29tcHV0ZUVkZ2VFbmRzKHQsZSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpO24uYWRkRW5kcG9pbnRzKCk7Y29uc3Qgcz1uLml0ZXJhdG9yKCk7bGV0IGk9bnVsbCxyPW51bGw7aWYoIXMuaGFzTmV4dCgpKXJldHVybiBudWxsO2xldCBvPXMubmV4dCgpO2Rve2k9cixyPW8sbz1udWxsLHMuaGFzTmV4dCgpJiYobz1zLm5leHQoKSksbnVsbCE9PXImJih0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JQcmV2KHQsZSxyLGkpLHRoaXMuY3JlYXRlRWRnZUVuZEZvck5leHQodCxlLHIsbykpfXdoaWxlKG51bGwhPT1yKX19fWNsYXNzIFJyIGV4dGVuZHMgbnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLFJyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2VkZ2VFbmRzPW5ldyBMLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtSci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG51bGwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07bnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldEVkZ2UoKSx0LmdldENvb3JkaW5hdGUoKSx0LmdldERpcmVjdGVkQ29vcmRpbmF0ZSgpLG5ldyBxbih0LmdldExhYmVsKCkpKSx0aGlzLmluc2VydCh0KX19aW5zZXJ0KHQpe3RoaXMuX2VkZ2VFbmRzLmFkZCh0KX1wcmludCh0KXt0LnByaW50bG4oXCJFZGdlRW5kQnVuZGxlLS1cXHgzZSBMYWJlbDogXCIrdGhpcy5fbGFiZWwpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KSx0LnByaW50bG4oKX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZHMuaXRlcmF0b3IoKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kc31jb21wdXRlTGFiZWxPbih0LGUpe2xldCBuPTAscz0hMTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgaT1lLm5leHQoKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2k9PT1RdC5CT1VOREFSWSYmbisrLGk9PT1RdC5JTlRFUklPUiYmKHM9ITApfWxldCBpPVF0Lk5PTkU7cyYmKGk9UXQuSU5URVJJT1IpLG4+MCYmKGk9bHMuZGV0ZXJtaW5lQm91bmRhcnkoZSxuKSksdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxpKX1jb21wdXRlTGFiZWxTaWRlKHQsZSl7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocy5nZXRMYWJlbCgpLmlzQXJlYSgpKXtjb25zdCBuPXMuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGUpO2lmKG49PT1RdC5JTlRFUklPUilyZXR1cm4gdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLFF0LklOVEVSSU9SKSxudWxsO249PT1RdC5FWFRFUklPUiYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLFF0LkVYVEVSSU9SKX19fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbFNpZGVzKHQpe3RoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LE1uLkxFRlQpLHRoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LE1uLlJJR0hUKX11cGRhdGVJTSh0KXskbi51cGRhdGVJTSh0aGlzLl9sYWJlbCx0KX1jb21wdXRlTGFiZWwodCl7bGV0IGU9ITE7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldExhYmVsKCkuaXNBcmVhKCkmJihlPSEwKX10aGlzLl9sYWJlbD1lP25ldyBxbihRdC5OT05FLFF0Lk5PTkUsUXQuTk9ORSk6bmV3IHFuKFF0Lk5PTkUpO2ZvcihsZXQgbj0wO248MjtuKyspdGhpcy5jb21wdXRlTGFiZWxPbihuLHQpLGUmJnRoaXMuY29tcHV0ZUxhYmVsU2lkZXMobil9fWNsYXNzIFByIGV4dGVuZHMgTml7Y29uc3RydWN0b3IoKXtzdXBlcigpfXVwZGF0ZUlNKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS51cGRhdGVJTSh0KX19aW5zZXJ0KHQpe2xldCBlPXRoaXMuX2VkZ2VNYXAuZ2V0KHQpO251bGw9PT1lPyhlPW5ldyBScih0KSx0aGlzLmluc2VydEVkZ2VFbmQodCxlKSk6ZS5pbnNlcnQodCl9fWNsYXNzIE9yIGV4dGVuZHMgdHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLE9yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX11cGRhdGVJTUZyb21FZGdlcyh0KXt0aGlzLl9lZGdlcy51cGRhdGVJTSh0KX1jb21wdXRlSU0odCl7dC5zZXRBdExlYXN0SWZWYWxpZCh0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbigwKSx0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbigxKSwwKX19Y2xhc3MgdnIgZXh0ZW5kcyByc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IE9yKHQsbmV3IFByKX19Y2xhc3MgTXJ7Y29uc3RydWN0b3IoKXtNci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2Rlcz1uZXcgZXMobmV3IHZyKX1pbnNlcnRFZGdlRW5kcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGQodCl9fWdldE5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpfWNvcHlOb2Rlc0FuZExhYmVscyh0LGUpe2ZvcihsZXQgbj10LmdldE5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGROb2RlKHQuZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbChlLHQuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSl9fWJ1aWxkKHQpe3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQsMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHModCwwKTtjb25zdCBlPShuZXcgVHIpLmNvbXB1dGVFZGdlRW5kcyh0LmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKGUpfWNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LGUpe2ZvcihsZXQgbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxzPXQuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKTtmb3IobGV0IG49dC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLGk9dGhpcy5fbm9kZXMuYWRkTm9kZSh0LmNvb3JkKTtzPT09UXQuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KGUpOmkuZ2V0TGFiZWwoKS5pc051bGwoZSkmJmkuc2V0TGFiZWwoZSxRdC5JTlRFUklPUil9fX19Y2xhc3MgYnJ7Y29uc3RydWN0b3IoKXtici5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fZ2VvbUdyYXBoPW51bGwsdGhpcy5fbm9kZUdyYXBoPW5ldyBNcix0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tR3JhcGg9dH1pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtpZighZS5nZXRFZGdlcygpLmlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodGhpcy5fZ2VvbUdyYXBoKSlyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50PWUuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKSwhMX1yZXR1cm4hMH1nZXRJbnZhbGlkUG9pbnQoKXtyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50fWhhc0R1cGxpY2F0ZVJpbmdzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2ZvcihsZXQgZT10Lm5leHQoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHQuZ2V0RWRnZUVuZHMoKS5zaXplKCk+MSlyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50PXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGUoMCksITB9fXJldHVybiExfWlzTm9kZUNvbnNpc3RlbnRBcmVhKCl7Y29uc3QgdD10aGlzLl9nZW9tR3JhcGguY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMCwhMCk7cmV0dXJuIHQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuX2ludmFsaWRQb2ludD10LmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOih0aGlzLl9ub2RlR3JhcGguYnVpbGQodGhpcy5fZ2VvbUdyYXBoKSx0aGlzLmlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpKX19Y2xhc3MgRHJ7Y29uc3RydWN0b3IoKXtEci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ncmFwaD1udWxsLHRoaXMuX3JpbmdzPW5ldyBMLHRoaXMuX3RvdGFsRW52PW5ldyBPLHRoaXMuX2luZGV4PW51bGwsdGhpcy5fbmVzdGVkUHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ncmFwaD10fWJ1aWxkSW5kZXgoKXt0aGlzLl9pbmRleD1uZXcgdnM7Zm9yKGxldCB0PTA7dDx0aGlzLl9yaW5ncy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX3JpbmdzLmdldCh0KSxuPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3RoaXMuX2luZGV4Lmluc2VydChuLGUpfX1nZXROZXN0ZWRQb2ludCgpe3JldHVybiB0aGlzLl9uZXN0ZWRQdH1pc05vbk5lc3RlZCgpe3RoaXMuYnVpbGRJbmRleCgpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcmluZ3Muc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9yaW5ncy5nZXQodCksbj1lLmdldENvb3JkaW5hdGVzKCkscz10aGlzLl9pbmRleC5xdWVyeShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7Zm9yKGxldCB0PTA7dDxzLnNpemUoKTt0Kyspe2NvbnN0IGk9cy5nZXQodCkscj1pLmdldENvb3JkaW5hdGVzKCk7aWYoZT09PWkpY29udGludWU7aWYoIWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoaS5nZXRFbnZlbG9wZUludGVybmFsKCkpKWNvbnRpbnVlO2NvbnN0IG89RnIuZmluZFB0Tm90Tm9kZShuLGksdGhpcy5fZ3JhcGgpO2lmKG51bGw9PT1vKWNvbnRpbnVlO2lmKFVlLmlzSW5SaW5nKG8scikpcmV0dXJuIHRoaXMuX25lc3RlZFB0PW8sITF9fXJldHVybiEwfWFkZCh0KXt0aGlzLl9yaW5ncy5hZGQodCksdGhpcy5fdG90YWxFbnYuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX19Y2xhc3MgQXJ7Y29uc3RydWN0b3IoKXtBci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9lcnJvclR5cGU9bnVsbCx0aGlzLl9wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtBci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZXJyb3JUeXBlPXQsbnVsbCE9PWUmJih0aGlzLl9wdD1lLmNvcHkoKSl9fWdldEVycm9yVHlwZSgpe3JldHVybiB0aGlzLl9lcnJvclR5cGV9Z2V0TWVzc2FnZSgpe3JldHVybiBBci5lcnJNc2dbdGhpcy5fZXJyb3JUeXBlXX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fXRvU3RyaW5nKCl7bGV0IHQ9XCJcIjtyZXR1cm4gbnVsbCE9PXRoaXMuX3B0JiYodD1cIiBhdCBvciBuZWFyIHBvaW50IFwiK3RoaXMuX3B0KSx0aGlzLmdldE1lc3NhZ2UoKSt0fX1Bci5FUlJPUj0wLEFyLlJFUEVBVEVEX1BPSU5UPTEsQXIuSE9MRV9PVVRTSURFX1NIRUxMPTIsQXIuTkVTVEVEX0hPTEVTPTMsQXIuRElTQ09OTkVDVEVEX0lOVEVSSU9SPTQsQXIuU0VMRl9JTlRFUlNFQ1RJT049NSxBci5SSU5HX1NFTEZfSU5URVJTRUNUSU9OPTYsQXIuTkVTVEVEX1NIRUxMUz03LEFyLkRVUExJQ0FURV9SSU5HUz04LEFyLlRPT19GRVdfUE9JTlRTPTksQXIuSU5WQUxJRF9DT09SRElOQVRFPTEwLEFyLlJJTkdfTk9UX0NMT1NFRD0xMSxBci5lcnJNc2c9W1wiVG9wb2xvZ3kgVmFsaWRhdGlvbiBFcnJvclwiLFwiUmVwZWF0ZWQgUG9pbnRcIixcIkhvbGUgbGllcyBvdXRzaWRlIHNoZWxsXCIsXCJIb2xlcyBhcmUgbmVzdGVkXCIsXCJJbnRlcmlvciBpcyBkaXNjb25uZWN0ZWRcIixcIlNlbGYtaW50ZXJzZWN0aW9uXCIsXCJSaW5nIFNlbGYtaW50ZXJzZWN0aW9uXCIsXCJOZXN0ZWQgc2hlbGxzXCIsXCJEdXBsaWNhdGUgUmluZ3NcIixcIlRvbyBmZXcgZGlzdGluY3QgcG9pbnRzIGluIGdlb21ldHJ5IGNvbXBvbmVudFwiLFwiSW52YWxpZCBDb29yZGluYXRlXCIsXCJSaW5nIGlzIG5vdCBjbG9zZWRcIl07Y2xhc3MgRnJ7Y29uc3RydWN0b3IoKXtGci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wYXJlbnRHZW9tZXRyeT1udWxsLHRoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9ITEsdGhpcy5fdmFsaWRFcnI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnRHZW9tZXRyeT10fXN0YXRpYyBmaW5kUHROb3ROb2RlKHQsZSxuKXtjb25zdCBzPW4uZmluZEVkZ2UoZSkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO2lmKCFzLmlzSW50ZXJzZWN0aW9uKG4pKXJldHVybiBufXJldHVybiBudWxsfXN0YXRpYyBpc1ZhbGlkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtyZXR1cm4gbmV3IEZyKGFyZ3VtZW50c1swXSkuaXNWYWxpZCgpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXIuaXNOYU4odC54KSYmKCFyLmlzSW5maW5pdGUodC54KSYmKCFyLmlzTmFOKHQueSkmJiFyLmlzSW5maW5pdGUodC55KSkpfX1jaGVja0ludmFsaWRDb29yZGluYXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCFGci5pc1ZhbGlkKHRbZV0pKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgQXIoQXIuSU5WQUxJRF9DT09SRElOQVRFLHRbZV0pLG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGl0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1jaGVja0hvbGVzTm90TmVzdGVkKHQsZSl7aWYodC5nZXROdW1JbnRlcmlvclJpbmcoKTw9MClyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBEcihlKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBzPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTtzLmlzRW1wdHkoKXx8bi5hZGQocyl9bi5pc05vbk5lc3RlZCgpfHwodGhpcy5fdmFsaWRFcnI9bmV3IEFyKEFyLk5FU1RFRF9IT0xFUyxuLmdldE5lc3RlZFBvaW50KCkpKX1jaGVja0NvbnNpc3RlbnRBcmVhKHQpe2NvbnN0IGU9bmV3IGJyKHQpO2lmKCFlLmlzTm9kZUNvbnNpc3RlbnRBcmVhKCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5TRUxGX0lOVEVSU0VDVElPTixlLmdldEludmFsaWRQb2ludCgpKSxudWxsO2UuaGFzRHVwbGljYXRlUmluZ3MoKSYmKHRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5EVVBMSUNBVEVfUklOR1MsZS5nZXRJbnZhbGlkUG9pbnQoKSkpfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMuX3BhcmVudEdlb21ldHJ5KSxudWxsPT09dGhpcy5fdmFsaWRFcnJ9Y2hlY2tTaGVsbEluc2lkZUhvbGUodCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRDb29yZGluYXRlcygpLHI9RnIuZmluZFB0Tm90Tm9kZShzLGUsbik7aWYobnVsbCE9PXIpe2lmKCFVZS5pc0luUmluZyhyLGkpKXJldHVybiByfWNvbnN0IG89RnIuZmluZFB0Tm90Tm9kZShpLHQsbik7aWYobnVsbCE9PW8pe3JldHVybiBVZS5pc0luUmluZyhvLHMpP286bnVsbH1yZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZShcInBvaW50cyBpbiBzaGVsbCBhbmQgaG9sZSBhcHBlYXIgdG8gYmUgZXF1YWxcIiksbnVsbH1jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKHQpe2ZvcihsZXQgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyh0LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19Y2hlY2tDb25uZWN0ZWRJbnRlcmlvcnModCl7Y29uc3QgZT1uZXcgTHIodCk7ZS5pc0ludGVyaW9yc0Nvbm5lY3RlZCgpfHwodGhpcy5fdmFsaWRFcnI9bmV3IEFyKEFyLkRJU0NPTk5FQ1RFRF9JTlRFUklPUixlLmdldENvb3JkaW5hdGUoKSkpfWNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyh0KXtjb25zdCBlPW5ldyBsdDtsZXQgbj0hMDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZihuKW49ITE7ZWxzZXtpZihlLmNvbnRhaW5zKHQuY29vcmQpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgQXIoQXIuUklOR19TRUxGX0lOVEVSU0VDVElPTix0LmNvb3JkKSxudWxsO2UuYWRkKHQuY29vcmQpfX19Y2hlY2tIb2xlc0luU2hlbGwodCxlKXtpZih0LmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRFeHRlcmlvclJpbmcoKSxzPW4uaXNFbXB0eSgpLGk9bmV3IHplKG4pO2ZvcihsZXQgcj0wO3I8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe2NvbnN0IG89dC5nZXRJbnRlcmlvclJpbmdOKHIpO2xldCBsPW51bGw7aWYoby5pc0VtcHR5KCkpY29udGludWU7aWYobD1Gci5maW5kUHROb3ROb2RlKG8uZ2V0Q29vcmRpbmF0ZXMoKSxuLGUpLG51bGw9PT1sKXJldHVybiBudWxsO2lmKHN8fFF0LkVYVEVSSU9SPT09aS5sb2NhdGUobCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5IT0xFX09VVFNJREVfU0hFTEwsbCksbnVsbH19Y2hlY2tUb29GZXdQb2ludHModCl7aWYodC5oYXNUb29GZXdQb2ludHMoKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEFyKEFyLlRPT19GRVdfUE9JTlRTLHQuZ2V0SW52YWxpZFBvaW50KCkpLG51bGx9Z2V0VmFsaWRhdGlvbkVycm9yKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLl9wYXJlbnRHZW9tZXRyeSksdGhpcy5fdmFsaWRFcnJ9Y2hlY2tWYWxpZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgaHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IGxzKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcganQ7ZS5jb21wdXRlU2VsZk5vZGVzKG4sITAsITApLHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSil7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBscygwLHQpO3RoaXMuY2hlY2tUb29GZXdQb2ludHMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGl0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3ModCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IGxzKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKHQsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZ0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3MobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWNvbnN0IGU9bmV3IGxzKDAsdCk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0NvbnNpc3RlbnRBcmVhKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpKXJldHVybiBudWxsO2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXQuZ2V0R2VvbWV0cnlOKG4pO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwocyxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKHMsZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWlmKHRoaXMuY2hlY2tTaGVsbHNOb3ROZXN0ZWQodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKHRoaXMuY2hlY2tWYWxpZChuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl92YWxpZEVycj1udWxsLHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiB0dCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHV0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBKKXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBpdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgY3QpKXRocm93IG5ldyBqKHQuZ2V0R2VvbWV0cnlUeXBlKCkpO3RoaXMuY2hlY2tWYWxpZCh0KX19fXNldFNlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkKHQpe3RoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9dH1jaGVja1NoZWxsTm90TmVzdGVkKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0RXh0ZXJpb3JSaW5nKCk7aWYoaS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgcj1pLmdldENvb3JkaW5hdGVzKCksbz1Gci5maW5kUHROb3ROb2RlKHMsaSxuKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDtpZighVWUuaXNJblJpbmcobyxyKSlyZXR1cm4gbnVsbDtpZihlLmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgQXIoQXIuTkVTVEVEX1NIRUxMUyxvKSxudWxsO2xldCBsPW51bGw7Zm9yKGxldCBzPTA7czxlLmdldE51bUludGVyaW9yUmluZygpO3MrKyl7Y29uc3QgaT1lLmdldEludGVyaW9yUmluZ04ocyk7aWYobD10aGlzLmNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsaSxuKSxudWxsPT09bClyZXR1cm4gbnVsbH10aGlzLl92YWxpZEVycj1uZXcgQXIoQXIuTkVTVEVEX1NIRUxMUyxsKX1jaGVja0Nsb3NlZFJpbmdzKHQpe2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWNoZWNrQ2xvc2VkUmluZyh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZighdC5pc0Nsb3NlZCgpKXtsZXQgZT1udWxsO3QuZ2V0TnVtUG9pbnRzKCk+PTEmJihlPXQuZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5SSU5HX05PVF9DTE9TRUQsZSl9fWNoZWNrU2hlbGxzTm90TmVzdGVkKHQsZSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obikuZ2V0RXh0ZXJpb3JSaW5nKCk7Zm9yKGxldCBpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe2lmKG49PT1pKWNvbnRpbnVlO2NvbnN0IHI9dC5nZXRHZW9tZXRyeU4oaSk7aWYodGhpcy5jaGVja1NoZWxsTm90TmVzdGVkKHMscixlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fX19Y2xhc3MgR3J7Y29uc3RydWN0b3IoKXtHci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZGVMaXN0PW5ldyBMLHRoaXMuX2xvd2VzdEVkZ2U9bnVsbCx0aGlzLl9yaW5nPW51bGwsdGhpcy5fbG9jYXRvcj1udWxsLHRoaXMuX3JpbmdQdHM9bnVsbCx0aGlzLl9ob2xlcz1udWxsLHRoaXMuX3NoZWxsPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5faXNQcm9jZXNzZWQ9ITEsdGhpcy5faXNJbmNsdWRlZFNldD0hMSx0aGlzLl9pc0luY2x1ZGVkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH1zdGF0aWMgZmluZERpckVkZ2VzSW5SaW5nKHQpe2xldCBlPXQ7Y29uc3Qgbj1uZXcgTDtkb3tuLmFkZChlKSxlPWUuZ2V0TmV4dCgpLGcuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGcuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKGUhPT10KTtyZXR1cm4gbn1zdGF0aWMgYWRkRWRnZSh0LGUsbil7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyluLmFkZCh0W2VdLCExKTtlbHNlIGZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKW4uYWRkKHRbZV0sITEpfXN0YXRpYyBmaW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSl7Y29uc3Qgbj10LmdldFJpbmcoKSxzPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2xldCBpPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscj1udWxsLG89bnVsbDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxsPWUuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZihsLmVxdWFscyhzKSljb250aW51ZTtpZighbC5jb250YWlucyhzKSljb250aW51ZTtpPWR0LnB0Tm90SW5MaXN0KG4uZ2V0Q29vcmRpbmF0ZXMoKSxlLmdldENvb3JkaW5hdGVzKCkpO2UuaXNJblJpbmcoaSkmJihudWxsPT09cnx8by5jb250YWlucyhsKSkmJihyPWUsbz1yLmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfXJldHVybiByfWlzSW5jbHVkZWQoKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZH1nZXRDb29yZGluYXRlcygpe2lmKG51bGw9PT10aGlzLl9yaW5nUHRzKXtjb25zdCB0PW5ldyBSO2ZvcihsZXQgZT10aGlzLl9kZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldEVkZ2UoKTtHci5hZGRFZGdlKHMuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksbi5nZXRFZGdlRGlyZWN0aW9uKCksdCl9dGhpcy5fcmluZ1B0cz10LnRvQ29vcmRpbmF0ZUFycmF5KCl9cmV0dXJuIHRoaXMuX3JpbmdQdHN9aXNJbmNsdWRlZFNldCgpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkU2V0fWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLCEodGhpcy5fcmluZ1B0cy5sZW5ndGg8PTMpJiYodGhpcy5nZXRSaW5nKCksRnIuaXNWYWxpZCh0aGlzLl9yaW5nKSl9YnVpbGQodCl7bGV0IGU9dDtkb3t0aGlzLmFkZChlKSxlLnNldFJpbmcodGhpcyksZT1lLmdldE5leHQoKSxnLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxnLmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShlIT09dCl9aXNJblJpbmcodCl7cmV0dXJuIFF0LkVYVEVSSU9SIT09dGhpcy5nZXRMb2NhdG9yKCkubG9jYXRlKHQpfWlzT3V0ZXJIb2xlKCl7cmV0dXJuISF0aGlzLl9pc0hvbGUmJiF0aGlzLmhhc1NoZWxsKCl9Z2V0UG9seWdvbigpe2xldCB0PW51bGw7aWYobnVsbCE9PXRoaXMuX2hvbGVzKXt0PW5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5zaXplKCk7ZSsrKXRbZV09dGhpcy5faG9sZXMuZ2V0KGUpfXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24odGhpcy5fcmluZyx0KX1pc0hvbGUoKXtyZXR1cm4gdGhpcy5faXNIb2xlfWlzUHJvY2Vzc2VkKCl7cmV0dXJuIHRoaXMuX2lzUHJvY2Vzc2VkfWFkZEhvbGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHV0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5faG9sZXMmJih0aGlzLl9ob2xlcz1uZXcgTCksdGhpcy5faG9sZXMuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBHcil7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5zZXRTaGVsbCh0aGlzKTtjb25zdCBlPXQuZ2V0UmluZygpO251bGw9PT10aGlzLl9ob2xlcyYmKHRoaXMuX2hvbGVzPW5ldyBMKSx0aGlzLl9ob2xlcy5hZGQoZSl9fXNldEluY2x1ZGVkKHQpe3RoaXMuX2lzSW5jbHVkZWQ9dCx0aGlzLl9pc0luY2x1ZGVkU2V0PSEwfWdldE91dGVySG9sZSgpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKGxldCB0PTA7dDx0aGlzLl9kZUxpc3Quc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9kZUxpc3QuZ2V0KHQpLmdldFN5bSgpLmdldFJpbmcoKTtpZihlLmlzT3V0ZXJIb2xlKCkpcmV0dXJuIGV9cmV0dXJuIG51bGx9Y29tcHV0ZUhvbGUoKXtjb25zdCB0PXRoaXMuZ2V0UmluZygpO3RoaXMuX2lzSG9sZT1HLmlzQ0NXKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9aGFzU2hlbGwoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3NoZWxsfWlzT3V0ZXJTaGVsbCgpe3JldHVybiBudWxsIT09dGhpcy5nZXRPdXRlckhvbGUoKX1nZXRMaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5fcmluZ1B0cyl9dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKG5ldyBwdCh0aGlzLmdldENvb3JkaW5hdGVzKCkpKX1nZXRMb2NhdG9yKCl7cmV0dXJuIG51bGw9PT10aGlzLl9sb2NhdG9yJiYodGhpcy5fbG9jYXRvcj1uZXcgemUodGhpcy5nZXRSaW5nKCkpKSx0aGlzLl9sb2NhdG9yfWdldFNoZWxsKCl7cmV0dXJuIHRoaXMuaXNIb2xlKCk/dGhpcy5fc2hlbGw6dGhpc31hZGQodCl7dGhpcy5fZGVMaXN0LmFkZCh0KX1nZXRSaW5nKCl7aWYobnVsbCE9PXRoaXMuX3JpbmcpcmV0dXJuIHRoaXMuX3Jpbmc7dGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMuX3JpbmdQdHMubGVuZ3RoPDMmJkIub3V0LnByaW50bG4odGhpcy5fcmluZ1B0cyk7dHJ5e3RoaXMuX3Jpbmc9dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuX3JpbmdQdHMpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IHQ7Qi5vdXQucHJpbnRsbih0aGlzLl9yaW5nUHRzKX1yZXR1cm4gdGhpcy5fcmluZ311cGRhdGVJbmNsdWRlZCgpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKGxldCB0PTA7dDx0aGlzLl9kZUxpc3Quc2l6ZSgpO3QrKyl7Y29uc3QgZT10aGlzLl9kZUxpc3QuZ2V0KHQpLmdldFN5bSgpLmdldFJpbmcoKS5nZXRTaGVsbCgpO2lmKG51bGwhPT1lJiZlLmlzSW5jbHVkZWRTZXQoKSlyZXR1cm4gdGhpcy5zZXRJbmNsdWRlZCghZS5pc0luY2x1ZGVkKCkpLG51bGx9fXNldFNoZWxsKHQpe3RoaXMuX3NoZWxsPXR9c2V0UHJvY2Vzc2VkKHQpe3RoaXMuX2lzUHJvY2Vzc2VkPXR9fUdyLkVudmVsb3BlQ29tcGFyYXRvcj1jbGFzc3tjb21wYXJlKHQsZSl7Y29uc3Qgbj1lO3JldHVybiB0LmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpLmNvbXBhcmVUbyhuLmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fTtjbGFzcyBxciBleHRlbmRzIEppe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxxci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9mYWN0b3J5PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fXN0YXRpYyBmaW5kTGFiZWxlZEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyBMO2xldCBuPTE7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYodC5pc01hcmtlZCgpKWNvbnRpbnVlO2lmKHQuZ2V0TGFiZWwoKT49MCljb250aW51ZTtlLmFkZCh0KTtjb25zdCBpPUdyLmZpbmREaXJFZGdlc0luUmluZyh0KTtxci5sYWJlbChpLG4pLG4rK31yZXR1cm4gZX1zdGF0aWMgZ2V0RGVncmVlTm9uRGVsZXRlZCh0KXtsZXQgZT0wO2ZvcihsZXQgbj10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuaXNNYXJrZWQoKXx8ZSsrfXJldHVybiBlfXN0YXRpYyBkZWxldGVBbGxFZGdlcyh0KXtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRNYXJrZWQoITApO2NvbnN0IG49dC5nZXRTeW0oKTtudWxsIT09biYmbi5zZXRNYXJrZWQoITApfX1zdGF0aWMgbGFiZWwodCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuc2V0TGFiZWwoZSl9fXN0YXRpYyBjb21wdXRlTmV4dENXRWRnZXModCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKCF0LmlzTWFya2VkKCkpe2lmKG51bGw9PT1lJiYoZT10KSxudWxsIT09bil7bi5nZXRTeW0oKS5zZXROZXh0KHQpfW49dH19aWYobnVsbCE9PW4pe24uZ2V0U3ltKCkuc2V0TmV4dChlKX19c3RhdGljIGNvbXB1dGVOZXh0Q0NXRWRnZXModCxlKXtsZXQgbj1udWxsLHM9bnVsbDtjb25zdCBpPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpO2ZvcihsZXQgdD1pLnNpemUoKS0xO3Q+PTA7dC0tKXtjb25zdCByPWkuZ2V0KHQpLG89ci5nZXRTeW0oKTtsZXQgbD1udWxsO3IuZ2V0TGFiZWwoKT09PWUmJihsPXIpO2xldCBhPW51bGw7by5nZXRMYWJlbCgpPT09ZSYmKGE9byksbnVsbD09PWwmJm51bGw9PT1hfHwobnVsbCE9PWEmJihzPWEpLG51bGwhPT1sJiYobnVsbCE9PXMmJihzLnNldE5leHQobCkscz1udWxsKSxudWxsPT09biYmKG49bCkpKX1udWxsIT09cyYmKGcuaXNUcnVlKG51bGwhPT1uKSxzLnNldE5leHQobikpfXN0YXRpYyBnZXREZWdyZWUodCxlKXtsZXQgbj0wO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7cy5uZXh0KCkuZ2V0TGFiZWwoKT09PWUmJm4rK31yZXR1cm4gbn1zdGF0aWMgZmluZEludGVyc2VjdGlvbk5vZGVzKHQsZSl7bGV0IG49dCxzPW51bGw7ZG97Y29uc3QgaT1uLmdldEZyb21Ob2RlKCk7cXIuZ2V0RGVncmVlKGksZSk+MSYmKG51bGw9PT1zJiYocz1uZXcgTCkscy5hZGQoaSkpLG49bi5nZXROZXh0KCksZy5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZy5pc1RydWUobj09PXR8fCFuLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUobiE9PXQpO3JldHVybiBzfWZpbmRFZGdlUmluZyh0KXtjb25zdCBlPW5ldyBHcih0aGlzLl9mYWN0b3J5KTtyZXR1cm4gZS5idWlsZCh0KSxlfWNvbXB1dGVEZXB0aFBhcml0eSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcig7OylyZXR1cm4gbnVsbH1jb21wdXRlTmV4dENXRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5ub2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7cXIuY29tcHV0ZU5leHRDV0VkZ2VzKGUpfX1hZGRFZGdlKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IGU9ZHQucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO2NvbnN0IG49ZVswXSxzPWVbZS5sZW5ndGgtMV0saT10aGlzLmdldE5vZGUobikscj10aGlzLmdldE5vZGUocyksbz1uZXcgd3IoaSxyLGVbMV0sITApLGw9bmV3IHdyKHIsaSxlW2UubGVuZ3RoLTJdLCExKSxhPW5ldyBDcih0KTthLnNldERpcmVjdGVkRWRnZXMobyxsKSx0aGlzLmFkZChhKX1kZWxldGVDdXRFZGdlcygpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCkscXIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5fZGlyRWRnZXMpO2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0U3ltKCk7aWYobi5nZXRMYWJlbCgpPT09cy5nZXRMYWJlbCgpKXtuLnNldE1hcmtlZCghMCkscy5zZXRNYXJrZWQoITApO2NvbnN0IGU9bi5nZXRFZGdlKCk7dC5hZGQoZS5nZXRMaW5lKCkpfX1yZXR1cm4gdH1nZXRFZGdlUmluZ3MoKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLHFyLmxhYmVsKHRoaXMuX2RpckVkZ2VzLC0xKTtjb25zdCB0PXFyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuX2RpckVkZ2VzKTt0aGlzLmNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpO2NvbnN0IGU9bmV3IEw7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtpZihuLmlzSW5SaW5nKCkpY29udGludWU7Y29uc3Qgcz10aGlzLmZpbmRFZGdlUmluZyhuKTtlLmFkZChzKX1yZXR1cm4gZX1nZXROb2RlKHQpe2xldCBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgamkodCksdGhpcy5hZGQoZSkpLGV9Y29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldExhYmVsKCkscz1xci5maW5kSW50ZXJzZWN0aW9uTm9kZXModCxuKTtpZihudWxsIT09cylmb3IobGV0IHQ9cy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtxci5jb21wdXRlTmV4dENDV0VkZ2VzKGUsbil9fX1kZWxldGVEYW5nbGVzKCl7Y29uc3QgdD10aGlzLmZpbmROb2Rlc09mRGVncmVlKDEpLGU9bmV3IHh0LG49bmV3IGVuO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KW4ucHVzaChlLm5leHQoKSk7Zm9yKDshbi5pc0VtcHR5KCk7KXtjb25zdCB0PW4ucG9wKCk7cXIuZGVsZXRlQWxsRWRnZXModCk7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3Quc2V0TWFya2VkKCEwKTtjb25zdCBpPXQuZ2V0U3ltKCk7bnVsbCE9PWkmJmkuc2V0TWFya2VkKCEwKTtjb25zdCByPXQuZ2V0RWRnZSgpO2UuYWRkKHIuZ2V0TGluZSgpKTtjb25zdCBvPXQuZ2V0VG9Ob2RlKCk7MT09PXFyLmdldERlZ3JlZU5vbkRlbGV0ZWQobykmJm4ucHVzaChvKX19cmV0dXJuIGV9fWNsYXNzIEJye2NvbnN0cnVjdG9yKCl7QnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2hlbGxzPW51bGwsdGhpcy5fc2hlbGxJbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NoZWxscz10LHRoaXMuYnVpbGRJbmRleCgpfXN0YXRpYyBhc3NpZ25Ib2xlc1RvU2hlbGxzKHQsZSl7bmV3IEJyKGUpLmFzc2lnbkhvbGVzVG9TaGVsbHModCl9YXNzaWduSG9sZXNUb1NoZWxscyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmFzc2lnbkhvbGVUb1NoZWxsKHQpfX1idWlsZEluZGV4KCl7dGhpcy5fc2hlbGxJbmRleD1uZXcgdnM7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fc2hlbGxzKXRoaXMuX3NoZWxsSW5kZXguaW5zZXJ0KHQuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSx0KX1xdWVyeU92ZXJsYXBwaW5nU2hlbGxzKHQpe3JldHVybiB0aGlzLl9zaGVsbEluZGV4LnF1ZXJ5KHQpfWZpbmRTaGVsbENvbnRhaW5pbmcodCl7Y29uc3QgZT10LmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCksbj10aGlzLnF1ZXJ5T3ZlcmxhcHBpbmdTaGVsbHMoZSk7cmV0dXJuIEdyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxuKX1hc3NpZ25Ib2xlVG9TaGVsbCh0KXtjb25zdCBlPXRoaXMuZmluZFNoZWxsQ29udGFpbmluZyh0KTtudWxsIT09ZSYmZS5hZGRIb2xlKHQpfX1jbGFzcyBZcntjb25zdHJ1Y3Rvcigpe1lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xpbmVTdHJpbmdBZGRlcj1uZXcgVnIodGhpcyksdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9kYW5nbGVzPW5ldyBMLHRoaXMuX2N1dEVkZ2VzPW5ldyBMLHRoaXMuX2ludmFsaWRSaW5nTGluZXM9bmV3IEwsdGhpcy5faG9sZUxpc3Q9bnVsbCx0aGlzLl9zaGVsbExpc3Q9bnVsbCx0aGlzLl9wb2x5TGlzdD1udWxsLHRoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkPSEwLHRoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsPW51bGwsdGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClZci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLCExKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD10fX1zdGF0aWMgZXh0cmFjdFBvbHlnb25zKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTsoZXx8dC5pc0luY2x1ZGVkKCkpJiZuLmFkZCh0LmdldFBvbHlnb24oKSl9cmV0dXJuIG59c3RhdGljIGZpbmRPdXRlclNoZWxscyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0T3V0ZXJIb2xlKCk7bnVsbD09PW58fG4uaXNQcm9jZXNzZWQoKXx8KHQuc2V0SW5jbHVkZWQoITApLG4uc2V0UHJvY2Vzc2VkKCEwKSl9fXN0YXRpYyBmaW5kRGlzam9pbnRTaGVsbHModCl7WXIuZmluZE91dGVyU2hlbGxzKHQpO2xldCBlPW51bGw7ZG97ZT0hMTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0LmlzSW5jbHVkZWRTZXQoKXx8KHQudXBkYXRlSW5jbHVkZWQoKSx0LmlzSW5jbHVkZWRTZXQoKXx8KGU9ITApKX19d2hpbGUoZSl9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2dlb21GYWN0b3J5JiYodGhpcy5fZ2VvbUZhY3Rvcnk9bmV3IEN0KSx0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD90aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMuX3BvbHlMaXN0KTp0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oQ3QudG9HZW9tZXRyeUFycmF5KHRoaXMuX3BvbHlMaXN0KSl9Z2V0SW52YWxpZFJpbmdMaW5lcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzfWZpbmRWYWxpZFJpbmdzKHQsZSxuKXtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzVmFsaWQoKT9lLmFkZCh0KTpuLmFkZCh0LmdldExpbmVTdHJpbmcoKSl9fXBvbHlnb25pemUoKXtpZihudWxsIT09dGhpcy5fcG9seUxpc3QpcmV0dXJuIG51bGw7aWYodGhpcy5fcG9seUxpc3Q9bmV3IEwsbnVsbD09PXRoaXMuX2dyYXBoKXJldHVybiBudWxsO3RoaXMuX2RhbmdsZXM9dGhpcy5fZ3JhcGguZGVsZXRlRGFuZ2xlcygpLHRoaXMuX2N1dEVkZ2VzPXRoaXMuX2dyYXBoLmRlbGV0ZUN1dEVkZ2VzKCk7Y29uc3QgdD10aGlzLl9ncmFwaC5nZXRFZGdlUmluZ3MoKTtsZXQgZT1uZXcgTDt0aGlzLl9pbnZhbGlkUmluZ0xpbmVzPW5ldyBMLHRoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkP3RoaXMuZmluZFZhbGlkUmluZ3ModCxlLHRoaXMuX2ludmFsaWRSaW5nTGluZXMpOmU9dCx0aGlzLmZpbmRTaGVsbHNBbmRIb2xlcyhlKSxCci5hc3NpZ25Ib2xlc1RvU2hlbGxzKHRoaXMuX2hvbGVMaXN0LHRoaXMuX3NoZWxsTGlzdCkseGUuc29ydCh0aGlzLl9zaGVsbExpc3QsbmV3IEdyLkVudmVsb3BlQ29tcGFyYXRvcik7bGV0IG49ITA7dGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWwmJihZci5maW5kRGlzam9pbnRTaGVsbHModGhpcy5fc2hlbGxMaXN0KSxuPSExKSx0aGlzLl9wb2x5TGlzdD1Zci5leHRyYWN0UG9seWdvbnModGhpcy5fc2hlbGxMaXN0LG4pfWdldERhbmdsZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fZGFuZ2xlc31nZXRDdXRFZGdlcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9jdXRFZGdlc31nZXRQb2x5Z29ucygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9wb2x5TGlzdH1hZGQoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEope2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLG51bGw9PT10aGlzLl9ncmFwaCYmKHRoaXMuX2dyYXBoPW5ldyBxcih0aGlzLl9nZW9tRmFjdG9yeSkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2FyZ3VtZW50c1swXS5hcHBseSh0aGlzLl9saW5lU3RyaW5nQWRkZXIpfX1zZXRDaGVja1JpbmdzVmFsaWQodCl7dGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ9dH1maW5kU2hlbGxzQW5kSG9sZXModCl7dGhpcy5faG9sZUxpc3Q9bmV3IEwsdGhpcy5fc2hlbGxMaXN0PW5ldyBMO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuY29tcHV0ZUhvbGUoKSx0LmlzSG9sZSgpP3RoaXMuX2hvbGVMaXN0LmFkZCh0KTp0aGlzLl9zaGVsbExpc3QuYWRkKHQpfX19Y2xhc3MgVnJ7Y29uc3RydWN0b3IoKXtWci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnA9dH1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIEomJnRoaXMucC5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfX1Zci5MaW5lU3RyaW5nQWRkZXI9VnI7dmFyIHpyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFBvbHlnb25pemVyOllyfSk7Y2xhc3Mga3J7Y29uc3RydWN0b3IoKXtrci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fcHRMb2NhdG9yPW5ldyBmbix0aGlzLl9hcmc9bnVsbCx0aGlzLl9ub2Rlcz1uZXcgZXMobmV3IHZyKSx0aGlzLl9pbT1udWxsLHRoaXMuX2lzb2xhdGVkRWRnZXM9bmV3IEwsdGhpcy5faW52YWxpZFBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJnPXR9aW5zZXJ0RWRnZUVuZHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkKHQpfX1jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0odCxlKXtjb25zdCBuPXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLHM9dGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCksaT10Lmhhc1Byb3BlckludGVyc2VjdGlvbigpLHI9dC5oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpOzI9PT1uJiYyPT09cz9pJiZlLnNldEF0TGVhc3QoXCIyMTIxMDEyMTJcIik6Mj09PW4mJjE9PT1zPyhpJiZlLnNldEF0TGVhc3QoXCJGRkYwRkZGRjJcIiksciYmZS5zZXRBdExlYXN0KFwiMUZGRkZGMUZGXCIpKToxPT09biYmMj09PXM/KGkmJmUuc2V0QXRMZWFzdChcIkYwRkZGRkZGMlwiKSxyJiZlLnNldEF0TGVhc3QoXCIxRjFGRkZGRkZcIikpOjE9PT1uJiYxPT09cyYmciYmZS5zZXRBdExlYXN0KFwiMEZGRkZGRkZGXCIpfWxhYmVsSXNvbGF0ZWRFZGdlcyh0LGUpe2ZvcihsZXQgbj10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3QuaXNJc29sYXRlZCgpJiYodGhpcy5sYWJlbElzb2xhdGVkRWRnZSh0LGUsdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpLHRoaXMuX2lzb2xhdGVkRWRnZXMuYWRkKHQpKX19bGFiZWxJc29sYXRlZEVkZ2UodCxlLG4pe2lmKG4uZ2V0RGltZW5zaW9uKCk+MCl7Y29uc3Qgcz10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLG4pO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxzKX1lbHNlIHQuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxRdC5FWFRFUklPUil9Y29tcHV0ZUlNKCl7Y29uc3QgdD1uZXcgSnQ7aWYodC5zZXQoUXQuRVhURVJJT1IsUXQuRVhURVJJT1IsMiksIXRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuIHRoaXMuY29tcHV0ZURpc2pvaW50SU0odCksdDt0aGlzLl9hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpO2NvbnN0IGU9dGhpcy5fYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLl9hcmdbMV0sdGhpcy5fbGksITEpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDApLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDEpLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDEpLHRoaXMubGFiZWxJc29sYXRlZE5vZGVzKCksdGhpcy5jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0oZSx0KTtjb25zdCBuPW5ldyBUcixzPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuX2FyZ1swXS5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhzKTtjb25zdCBpPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuX2FyZ1sxXS5nZXRFZGdlSXRlcmF0b3IoKSk7cmV0dXJuIHRoaXMuaW5zZXJ0RWRnZUVuZHMoaSksdGhpcy5sYWJlbE5vZGVFZGdlcygpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDAsMSksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMSwwKSx0aGlzLnVwZGF0ZUlNKHQpLHR9bGFiZWxOb2RlRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLl9hcmcpfX1jb3B5Tm9kZXNBbmRMYWJlbHModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX1sYWJlbEludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2ZvcihsZXQgZT1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCksaT10aGlzLl9ub2Rlcy5maW5kKG4uY29vcmQpO2kuZ2V0TGFiZWwoKS5pc051bGwodCkmJihzPT09UXQuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KHQpOmkuc2V0TGFiZWwodCxRdC5JTlRFUklPUikpfX19bGFiZWxJc29sYXRlZE5vZGUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxuKX1jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxpPXRoaXMuX25vZGVzLmFkZE5vZGUobi5jb29yZCk7cz09PVF0LkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeSh0KTppLmdldExhYmVsKCkuaXNOdWxsKHQpJiZpLnNldExhYmVsKHQsUXQuSU5URVJJT1IpfX19bGFiZWxJc29sYXRlZE5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO2cuaXNUcnVlKG4uZ2V0R2VvbWV0cnlDb3VudCgpPjAsXCJub2RlIHdpdGggZW1wdHkgbGFiZWwgZm91bmRcIiksZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMCk6dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDEpKX19dXBkYXRlSU0odCl7Zm9yKGxldCBlPXRoaXMuX2lzb2xhdGVkRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnVwZGF0ZUlNKHQpfWZvcihsZXQgZT10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuLnVwZGF0ZUlNKHQpLG4udXBkYXRlSU1Gcm9tRWRnZXModCl9fWNvbXB1dGVEaXNqb2ludElNKHQpe2NvbnN0IGU9dGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCk7ZS5pc0VtcHR5KCl8fCh0LnNldChRdC5JTlRFUklPUixRdC5FWFRFUklPUixlLmdldERpbWVuc2lvbigpKSx0LnNldChRdC5CT1VOREFSWSxRdC5FWFRFUklPUixlLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKTtjb25zdCBuPXRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpO24uaXNFbXB0eSgpfHwodC5zZXQoUXQuRVhURVJJT1IsUXQuSU5URVJJT1Isbi5nZXREaW1lbnNpb24oKSksdC5zZXQoUXQuRVhURVJJT1IsUXQuQk9VTkRBUlksbi5nZXRCb3VuZGFyeURpbWVuc2lvbigpKSl9fWNsYXNzIFhye2NvbnN0cnVjdG9yKCl7WHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdEVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9c3RhdGljIGNvbnRhaW5zKHQsZSl7cmV0dXJuIG5ldyBYcih0KS5jb250YWlucyhlKX1pc0NvbnRhaW5lZEluQm91bmRhcnkodCl7aWYodCBpbnN0YW5jZW9mIGl0KXJldHVybiExO2lmKHQgaW5zdGFuY2VvZiB0dClyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0IGluc3RhbmNlb2YgSilyZXR1cm4gdGhpcy5pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeShuKSlyZXR1cm4hMX1yZXR1cm4hMH1pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LGUpe2lmKHQuZXF1YWxzKGUpKXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQueD09PWUueCl7aWYodC54PT09dGhpcy5fcmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpKXJldHVybiEwfWVsc2UgaWYodC55PT09ZS55JiYodC55PT09dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpKSlyZXR1cm4hMDtyZXR1cm4hMX1pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPW5ldyBtLHM9bmV3IG07Zm9yKGxldCB0PTA7dDxlLnNpemUoKS0xO3QrKylpZihlLmdldENvb3JkaW5hdGUodCxuKSxlLmdldENvb3JkaW5hdGUodCsxLHMpLCF0aGlzLmlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KG4scykpcmV0dXJuITE7cmV0dXJuITB9aXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHR0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LmdldENvb3JkaW5hdGUoKSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC54PT09dGhpcy5fcmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNYXhZKCl9fWNvbnRhaW5zKHQpe3JldHVybiEhdGhpcy5fcmVjdEVudi5jb250YWlucyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJiF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KX19Y2xhc3MgVXJ7Y29uc3RydWN0b3IoKXtVci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2RpYWdVcDA9bnVsbCx0aGlzLl9kaWFnVXAxPW51bGwsdGhpcy5fZGlhZ0Rvd24wPW51bGwsdGhpcy5fZGlhZ0Rvd24xPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LHRoaXMuX2RpYWdVcDA9bmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuX2RpYWdVcDE9bmV3IG0odC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLHRoaXMuX2RpYWdEb3duMD1uZXcgbSh0LmdldE1pblgoKSx0LmdldE1heFkoKSksdGhpcy5fZGlhZ0Rvd24xPW5ldyBtKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKX1pbnRlcnNlY3RzKHQsZSl7Y29uc3Qgbj1uZXcgTyh0LGUpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMobikpcmV0dXJuITE7aWYodGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKHQpKXJldHVybiEwO2lmKHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4hMDtpZih0LmNvbXBhcmVUbyhlKT4wKXtjb25zdCBuPXQ7dD1lLGU9bn1sZXQgcz0hMTtyZXR1cm4gZS55PnQueSYmKHM9ITApLHM/dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fZGlhZ0Rvd24wLHRoaXMuX2RpYWdEb3duMSk6dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fZGlhZ1VwMCx0aGlzLl9kaWFnVXAxKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfX1jbGFzcyBIcntjb25zdHJ1Y3Rvcigpe0hyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RhbmdsZT1udWxsLHRoaXMuX3JlY3RFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0YW5nbGU9dCx0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfXN0YXRpYyBpbnRlcnNlY3RzKHQsZSl7cmV0dXJuIG5ldyBIcih0KS5pbnRlcnNlY3RzKGUpfWludGVyc2VjdHModCl7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuITE7Y29uc3QgZT1uZXcgV3IodGhpcy5fcmVjdEVudik7aWYoZS5hcHBseVRvKHQpLGUuaW50ZXJzZWN0cygpKXJldHVybiEwO2NvbnN0IG49bmV3IFpyKHRoaXMuX3JlY3RhbmdsZSk7aWYobi5hcHBseVRvKHQpLG4uY29udGFpbnNQb2ludCgpKXJldHVybiEwO2NvbnN0IHM9bmV3IGpyKHRoaXMuX3JlY3RhbmdsZSk7cmV0dXJuIHMuYXBwbHlUbyh0KSwhIXMuaW50ZXJzZWN0cygpfX1jbGFzcyBXciBleHRlbmRzIE5le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxXci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5faW50ZXJzZWN0cz0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXR9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9pbnRlcnNlY3RzfXZpc2l0KHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKT90aGlzLl9yZWN0RW52LmNvbnRhaW5zKGUpfHxlLmdldE1pblgoKT49dGhpcy5fcmVjdEVudi5nZXRNaW5YKCkmJmUuZ2V0TWF4WCgpPD10aGlzLl9yZWN0RW52LmdldE1heFgoKXx8ZS5nZXRNaW5ZKCk+PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpJiZlLmdldE1heFkoKTw9dGhpcy5fcmVjdEVudi5nZXRNYXhZKCk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6dm9pZCAwOm51bGx9aW50ZXJzZWN0cygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzfX1jbGFzcyBaciBleHRlbmRzIE5le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxaci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0U2VxPW51bGwsdGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdFNlcT10LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHRoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9jb250YWluc1BvaW50fXZpc2l0KHQpe2lmKCEodCBpbnN0YW5jZW9mIGl0KSlyZXR1cm4gbnVsbDtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgbTtmb3IobGV0IHM9MDtzPDQ7cysrKWlmKHRoaXMuX3JlY3RTZXEuZ2V0Q29vcmRpbmF0ZShzLG4pLGUuY29udGFpbnMobikmJlplLmNvbnRhaW5zUG9pbnRJblBvbHlnb24obix0KSlyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD0hMCxudWxsfWNvbnRhaW5zUG9pbnQoKXtyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludH19Y2xhc3MganIgZXh0ZW5kcyBOZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksanIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1udWxsLHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9wMD1uZXcgbSx0aGlzLl9wMT1uZXcgbTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1uZXcgVXIodGhpcy5fcmVjdEVudil9aW50ZXJzZWN0cygpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9oYXNJbnRlcnNlY3Rpb259dmlzaXQodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO2NvbnN0IG49eWUuZ2V0TGluZXModCk7dGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5ncyhuKX1jaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5ncyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKHQpLHRoaXMuX2hhc0ludGVyc2VjdGlvbilyZXR1cm4gbnVsbH19Y2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHModCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKWlmKGUuZ2V0Q29vcmRpbmF0ZSh0LTEsdGhpcy5fcDApLGUuZ2V0Q29vcmRpbmF0ZSh0LHRoaXMuX3AxKSx0aGlzLl9yZWN0SW50ZXJzZWN0b3IuaW50ZXJzZWN0cyh0aGlzLl9wMCx0aGlzLl9wMSkpcmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCxudWxsfX1jbGFzcyBLciBleHRlbmRzIElye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxLci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9yZWxhdGU9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX3JlbGF0ZT1uZXcga3IodGhpcy5fYXJnKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtJci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuKSx0aGlzLl9yZWxhdGU9bmV3IGtyKHRoaXMuX2FyZyl9fXN0YXRpYyBjb3ZlcnModCxlKXtyZXR1cm4hKDI9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDIpJiYoISgxPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwxJiZlLmdldExlbmd0aCgpPjApJiYoISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb3ZlcnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYoISF0LmlzUmVjdGFuZ2xlKCl8fG5ldyBLcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ292ZXJzKCkpKSl9c3RhdGljIGludGVyc2VjdHModCxlKXtpZighdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuITE7aWYodC5pc1JlY3RhbmdsZSgpKXJldHVybiBIci5pbnRlcnNlY3RzKHQsZSk7aWYoZS5pc1JlY3RhbmdsZSgpKXJldHVybiBIci5pbnRlcnNlY3RzKGUsdCk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe2ZvcihsZXQgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWZvcihsZXQgcz0wO3M8ZS5nZXROdW1HZW9tZXRyaWVzKCk7cysrKWlmKHQuZ2V0R2VvbWV0cnlOKG4pLmludGVyc2VjdHMoZS5nZXRHZW9tZXRyeU4ocykpKXJldHVybiEwO3JldHVybiExfXJldHVybiBuZXcgS3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0ludGVyc2VjdHMoKX1zdGF0aWMgdG91Y2hlcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBLcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzVG91Y2hlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBlcXVhbHNUb3BvKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5lcXVhbHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZLci5yZWxhdGUodCxlKS5pc0VxdWFscyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyByZWxhdGUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBLcihhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBLcihhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCl9fXN0YXRpYyBvdmVybGFwcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBLcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzT3ZlcmxhcHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgY3Jvc3Nlcyh0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJm5ldyBLcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ3Jvc3Nlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBjb250YWlucyh0LGUpe3JldHVybiEoMj09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MikmJighKDE9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDEmJmUuZ2V0TGVuZ3RoKCk+MCkmJighIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvbnRhaW5zKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKHQuaXNSZWN0YW5nbGUoKT9Yci5jb250YWlucyh0LGUpOm5ldyBLcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzQ29udGFpbnMoKSkpKX1nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKXtyZXR1cm4gdGhpcy5fcmVsYXRlLmNvbXB1dGVJTSgpfX12YXIgUXI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUmVsYXRlT3A6S3J9KTtjbGFzcyBKcntjb25zdHJ1Y3Rvcigpe0pyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BvaW50R2VvbT1udWxsLHRoaXMuX290aGVyR2VvbT1udWxsLHRoaXMuX2dlb21GYWN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcG9pbnRHZW9tPXQsdGhpcy5fb3RoZXJHZW9tPWUsdGhpcy5fZ2VvbUZhY3Q9ZS5nZXRGYWN0b3J5KCl9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIG5ldyBKcih0LGUpLnVuaW9uKCl9dW5pb24oKXtjb25zdCB0PW5ldyBmbixlPW5ldyBsdDtmb3IobGV0IG49MDtuPHRoaXMuX3BvaW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXtjb25zdCBzPXRoaXMuX3BvaW50R2VvbS5nZXRHZW9tZXRyeU4obikuZ2V0Q29vcmRpbmF0ZSgpO3QubG9jYXRlKHMsdGhpcy5fb3RoZXJHZW9tKT09PVF0LkVYVEVSSU9SJiZlLmFkZChzKX1pZigwPT09ZS5zaXplKCkpcmV0dXJuIHRoaXMuX290aGVyR2VvbTtsZXQgbj1udWxsO2NvbnN0IHM9ZHQudG9Db29yZGluYXRlQXJyYXkoZSk7cmV0dXJuIG49MT09PXMubGVuZ3RoP3RoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KHNbMF0pOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKHMpLGhlLmNvbWJpbmUobix0aGlzLl9vdGhlckdlb20pfX1jbGFzcyAkcntjb25zdHJ1Y3RvcigpeyRyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5fcG9seWdvbnM9bmV3IEwsdGhpcy5fbGluZXM9bmV3IEwsdGhpcy5fcG9pbnRzPW5ldyBMLHRoaXMuX2RpbWVuc2lvbj1LLkZBTFNFfXN0YXRpYyBleHRyYWN0KCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3ICRyO3JldHVybiBlLmFkZCh0KSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgJHI7cmV0dXJuIGUuYWRkKHQpLGV9fWdldEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fZ2VvbUZhY3Rvcnl9cmVjb3JkRGltZW5zaW9uKHQpe3Q+dGhpcy5fZGltZW5zaW9uJiYodGhpcy5fZGltZW5zaW9uPXQpfWdldERpbWVuc2lvbigpe3JldHVybiB0aGlzLl9kaW1lbnNpb259ZmlsdGVyKHQpe3JldHVybiB0aGlzLnJlY29yZERpbWVuc2lvbih0LmdldERpbWVuc2lvbigpKSx0IGluc3RhbmNlb2YgY3R8fHQuaXNFbXB0eSgpP251bGw6dCBpbnN0YW5jZW9mIGl0Pyh0aGlzLl9wb2x5Z29ucy5hZGQodCksbnVsbCk6dCBpbnN0YW5jZW9mIEo/KHRoaXMuX2xpbmVzLmFkZCh0KSxudWxsKTp0IGluc3RhbmNlb2YgdHQ/KHRoaXMuX3BvaW50cy5hZGQodCksbnVsbCk6dm9pZCBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5oYW5kbGVkIGdlb21ldHJ5IHR5cGU6IFwiK3QuZ2V0R2VvbWV0cnlUeXBlKCkpfWdldEV4dHJhY3QodCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gdGhpcy5fcG9pbnRzO2Nhc2UgMTpyZXR1cm4gdGhpcy5fbGluZXM7Y2FzZSAyOnJldHVybiB0aGlzLl9wb2x5Z29uc31yZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZShcIkludmFsaWQgZGltZW5zaW9uOiBcIit0KSxudWxsfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fcG9seWdvbnMuaXNFbXB0eSgpJiZ0aGlzLl9saW5lcy5pc0VtcHR5KCkmJnRoaXMuX3BvaW50cy5pc0VtcHR5KCl9YWRkKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2Zvcihjb25zdCBlIG9mIHQpdGhpcy5hZGQoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9nZW9tRmFjdG9yeSYmKHRoaXMuX2dlb21GYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0LmFwcGx5KHRoaXMpfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUV19fWNsYXNzIHRve2NvbnN0cnVjdG9yKCl7dG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9nMD1udWxsLHRoaXMuX2cxPW51bGwsdGhpcy5faXNVbmlvblNhZmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nMD10LHRoaXMuX2cxPWUsdGhpcy5fZ2VvbUZhY3Rvcnk9dC5nZXRGYWN0b3J5KCl9c3RhdGljIGNvbnRhaW5zUHJvcGVybHkoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXQuaXNOdWxsKCkmJihlLmdldFgoKT50LmdldE1pblgoKSYmZS5nZXRYKCk8dC5nZXRNYXhYKCkmJmUuZ2V0WSgpPnQuZ2V0TWluWSgpJiZlLmdldFkoKTx0LmdldE1heFkoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0by5jb250YWluc1Byb3Blcmx5KHQsZSkmJnRvLmNvbnRhaW5zUHJvcGVybHkodCxuKX19c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIG5ldyB0byh0LGUpLnVuaW9uKCl9c3RhdGljIGludGVyc2VjdHModCxlLG4pe3JldHVybiB0LmludGVyc2VjdHMoZSl8fHQuaW50ZXJzZWN0cyhuKX1zdGF0aWMgb3ZlcmxhcEVudmVsb3BlKHQsZSl7Y29uc3Qgbj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxzPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiBuLmludGVyc2VjdGlvbihzKX1zdGF0aWMgZXh0cmFjdEJvcmRlclNlZ21lbnRzKHQsZSxuKXt0LmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUF19ZmlsdGVyKHQscyl7aWYoczw9MClyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZShzLTEpLHI9dC5nZXRDb29yZGluYXRlKHMpO2lmKHRvLmludGVyc2VjdHMoZSxpLHIpJiYhdG8uY29udGFpbnNQcm9wZXJseShlLGkscikpe2NvbnN0IHQ9bmV3IEt0KGkscik7bi5hZGQodCl9fWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITF9fSl9c3RhdGljIHVuaW9uQnVmZmVyKHQsZSl7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbdCxlXSkuYnVmZmVyKDApfWlzQm9yZGVyU2VnbWVudHNTYW1lKHQsZSl7Y29uc3Qgbj10aGlzLmV4dHJhY3RCb3JkZXJTZWdtZW50cyh0aGlzLl9nMCx0aGlzLl9nMSxlKSxzPW5ldyBMO3JldHVybiB0by5leHRyYWN0Qm9yZGVyU2VnbWVudHModCxlLHMpLHRoaXMuaXNFcXVhbChuLHMpfWV4dHJhY3RCeUVudmVsb3BlKHQsZSxuKXtjb25zdCBzPW5ldyBMO2ZvcihsZXQgaT0wO2k8ZS5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtjb25zdCByPWUuZ2V0R2VvbWV0cnlOKGkpO2lmKHIuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCkpcy5hZGQocik7ZWxzZXtjb25zdCB0PXIuY29weSgpO24uYWRkKHQpfX1yZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShzKX1pc0VxdWFsKHQsZSl7aWYodC5zaXplKCkhPT1lLnNpemUoKSlyZXR1cm4hMTtjb25zdCBuPW5ldyB4dCh0KTtmb3IoY29uc3QgdCBvZiBlKWlmKCFuLmNvbnRhaW5zKHQpKXJldHVybiExO3JldHVybiEwfXVuaW9uKCl7Y29uc3QgdD10by5vdmVybGFwRW52ZWxvcGUodGhpcy5fZzAsdGhpcy5fZzEpO2lmKHQuaXNOdWxsKCkpe2NvbnN0IHQ9dGhpcy5fZzAuY29weSgpLGU9dGhpcy5fZzEuY29weSgpO3JldHVybiBoZS5jb21iaW5lKHQsZSl9Y29uc3QgZT1uZXcgTCxuPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUodCx0aGlzLl9nMCxlKSxzPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUodCx0aGlzLl9nMSxlKSxpPXRoaXMudW5pb25GdWxsKG4scyk7bGV0IHI9bnVsbDtyZXR1cm4gdGhpcy5faXNVbmlvblNhZmU9dGhpcy5pc0JvcmRlclNlZ21lbnRzU2FtZShpLHQpLHI9dGhpcy5faXNVbmlvblNhZmU/dGhpcy5jb21iaW5lKGksZSk6dGhpcy51bmlvbkZ1bGwodGhpcy5fZzAsdGhpcy5fZzEpLHJ9Y29tYmluZSh0LGUpe2lmKGUuc2l6ZSgpPD0wKXJldHVybiB0O2UuYWRkKHQpO3JldHVybiBoZS5jb21iaW5lKGUpfXVuaW9uRnVsbCh0LGUpe3RyeXtyZXR1cm4gdC51bmlvbihlKX1jYXRjaChuKXtpZihuIGluc3RhbmNlb2Ygc3MpcmV0dXJuIHRvLnVuaW9uQnVmZmVyKHQsZSk7dGhyb3cgbn19ZXh0cmFjdEJvcmRlclNlZ21lbnRzKHQsZSxuKXtjb25zdCBzPW5ldyBMO3JldHVybiB0by5leHRyYWN0Qm9yZGVyU2VnbWVudHModCxuLHMpLG51bGwhPT1lJiZ0by5leHRyYWN0Qm9yZGVyU2VnbWVudHMoZSxuLHMpLHN9aXNVbmlvbk9wdGltaXplZCgpe3JldHVybiB0aGlzLl9pc1VuaW9uU2FmZX19Y2xhc3MgZW97Y29uc3RydWN0b3IoKXtlby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dFBvbHlzPW51bGwsdGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dFBvbHlzPXQsbnVsbD09PXRoaXMuX2lucHV0UG9seXMmJih0aGlzLl9pbnB1dFBvbHlzPW5ldyBMKX1zdGF0aWMgcmVzdHJpY3RUb1BvbHlnb25zKHQpe2lmKEkodCxzdCkpcmV0dXJuIHQ7Y29uc3QgZT1JZS5nZXRQb2x5Z29ucyh0KTtyZXR1cm4gMT09PWUuc2l6ZSgpP2UuZ2V0KDApOnQuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihDdC50b1BvbHlnb25BcnJheShlKSl9c3RhdGljIGdldEdlb21ldHJ5KHQsZSl7cmV0dXJuIGU+PXQuc2l6ZSgpP251bGw6dC5nZXQoZSl9c3RhdGljIHVuaW9uKHQpe3JldHVybiBuZXcgZW8odCkudW5pb24oKX1yZWR1Y2VUb0dlb21ldHJpZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtsZXQgcz1udWxsO0kodCx3KT9zPXRoaXMudW5pb25UcmVlKHQpOnQgaW5zdGFuY2VvZiBYJiYocz10KSxlLmFkZChzKX1yZXR1cm4gZX11bmlvbigpe2lmKG51bGw9PT10aGlzLl9pbnB1dFBvbHlzKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJ1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlXCIpO2lmKHRoaXMuX2lucHV0UG9seXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuX2dlb21GYWN0b3J5PXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO2NvbnN0IHQ9bmV3IHZzKGVvLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWSk7Zm9yKGxldCBlPXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5pbnNlcnQobi5nZXRFbnZlbG9wZUludGVybmFsKCksbil9dGhpcy5faW5wdXRQb2x5cz1udWxsO2NvbnN0IGU9dC5pdGVtc1RyZWUoKTtyZXR1cm4gdGhpcy51bmlvblRyZWUoZSl9YmluYXJ5VW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24odCwwLHQuc2l6ZSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYobi1lPD0xKXtjb25zdCBuPWVvLmdldEdlb21ldHJ5KHQsZSk7cmV0dXJuIHRoaXMudW5pb25TYWZlKG4sbnVsbCl9aWYobi1lPT0yKXJldHVybiB0aGlzLnVuaW9uU2FmZShlby5nZXRHZW9tZXRyeSh0LGUpLGVvLmdldEdlb21ldHJ5KHQsZSsxKSk7e2NvbnN0IHM9TWF0aC50cnVuYygobitlKS8yKSxpPXRoaXMuYmluYXJ5VW5pb24odCxlLHMpLHI9dGhpcy5iaW5hcnlVbmlvbih0LHMsbik7cmV0dXJuIHRoaXMudW5pb25TYWZlKGkscil9fX1yZXBlYXRlZFVuaW9uKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZT1udWxsPT09ZT90LmNvcHkoKTplLnVuaW9uKHQpfXJldHVybiBlfXVuaW9uU2FmZSh0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09dD9lLmNvcHkoKTpudWxsPT09ZT90LmNvcHkoKTp0aGlzLnVuaW9uQWN0dWFsKHQsZSl9dW5pb25BY3R1YWwodCxlKXtjb25zdCBuPXRvLnVuaW9uKHQsZSk7cmV0dXJuIGVvLnJlc3RyaWN0VG9Qb2x5Z29ucyhuKX11bmlvblRyZWUodCl7Y29uc3QgZT10aGlzLnJlZHVjZVRvR2VvbWV0cmllcyh0KTtyZXR1cm4gdGhpcy5iaW5hcnlVbmlvbihlKX1idWZmZXJVbmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXQoMCkuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkodCkuYnVmZmVyKDApfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFt0LGVdKS5idWZmZXIoMCl9fX1lby5TVFJUUkVFX05PREVfQ0FQQUNJVFk9NDtjbGFzcyBub3tjb25zdHJ1Y3Rvcigpe25vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fZXh0cmFjdGVyPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbUZhY3Q9ZSx0aGlzLmV4dHJhY3QodCl9fXN0YXRpYyB1bmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7cmV0dXJuIG5ldyBubyhhcmd1bWVudHNbMF0pLnVuaW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtyZXR1cm4gbmV3IG5vKGFyZ3VtZW50c1swXSkudW5pb24oKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBubyhhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS51bmlvbigpfX11bmlvbk5vT3B0KHQpe2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoKTtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSxOci5VTklPTil9dW5pb25XaXRoTnVsbCh0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09ZT90Om51bGw9PT10P2U6dC51bmlvbihlKX1leHRyYWN0KCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2V4dHJhY3Rlcj0kci5leHRyYWN0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9leHRyYWN0ZXI9JHIuZXh0cmFjdCh0KX19dW5pb24oKXtpZihudWxsPT09dGhpcy5fZ2VvbUZhY3QmJih0aGlzLl9nZW9tRmFjdD10aGlzLl9leHRyYWN0ZXIuZ2V0RmFjdG9yeSgpKSxudWxsPT09dGhpcy5fZ2VvbUZhY3QpcmV0dXJuIG51bGw7aWYodGhpcy5fZXh0cmFjdGVyLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlRW1wdHkodGhpcy5fZXh0cmFjdGVyLmdldERpbWVuc2lvbigpKTtjb25zdCB0PXRoaXMuX2V4dHJhY3Rlci5nZXRFeHRyYWN0KDApLGU9dGhpcy5fZXh0cmFjdGVyLmdldEV4dHJhY3QoMSksbj10aGlzLl9leHRyYWN0ZXIuZ2V0RXh0cmFjdCgyKTtsZXQgcz1udWxsO2lmKHQuc2l6ZSgpPjApe2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0KTtzPXRoaXMudW5pb25Ob09wdChlKX1sZXQgaT1udWxsO2lmKGUuc2l6ZSgpPjApe2NvbnN0IHQ9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShlKTtpPXRoaXMudW5pb25Ob09wdCh0KX1sZXQgcj1udWxsO24uc2l6ZSgpPjAmJihyPWVvLnVuaW9uKG4pKTtjb25zdCBvPXRoaXMudW5pb25XaXRoTnVsbChpLHIpO2xldCBsPW51bGw7cmV0dXJuIGw9bnVsbD09PXM/bzpudWxsPT09bz9zOkpyLnVuaW9uKHMsbyksbnVsbD09PWw/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6bH19dmFyIHNvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFVuYXJ5VW5pb25PcDpub30pLGlvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLElzVmFsaWRPcDpGcixDb25zaXN0ZW50QXJlYVRlc3Rlcjpicn0pLHJvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEJvdW5kYXJ5T3A6c2ksSXNTaW1wbGVPcDpyaSxidWZmZXI6cWksZGlzdGFuY2U6emksbGluZW1lcmdlOmlyLG92ZXJsYXk6U3IscG9seWdvbml6ZTp6cixyZWxhdGU6UXIsdW5pb246c28sdmFsaWQ6aW99KTtjbGFzcyBvbyBleHRlbmRzIHVlLkNvb3JkaW5hdGVPcGVyYXRpb257Y29uc3RydWN0b3IoKXtzdXBlcigpLG9vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3RhcmdldFBNPW51bGwsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3RhcmdldFBNPXQsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPWV9ZWRpdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgcz1uZXcgbSh0W2VdKTt0aGlzLl90YXJnZXRQTS5tYWtlUHJlY2lzZShzKSxuW2VdPXN9Y29uc3Qgcz1uZXcgUihuLCExKS50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBpPTA7ZSBpbnN0YW5jZW9mIEomJihpPTIpLGUgaW5zdGFuY2VvZiB1dCYmKGk9NCk7bGV0IHI9bjtyZXR1cm4gdGhpcy5fcmVtb3ZlQ29sbGFwc2VkJiYocj1udWxsKSxzLmxlbmd0aDxpP3I6c31yZXR1cm4gc3VwZXIuZWRpdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fWNsYXNzIGxve2NvbnN0cnVjdG9yKCl7bG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdGFyZ2V0UE09bnVsbCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ITAsdGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWw9ITEsdGhpcy5faXNQb2ludHdpc2U9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fdGFyZ2V0UE09dH1zdGF0aWMgcmVkdWNlKHQsZSl7cmV0dXJuIG5ldyBsbyhlKS5yZWR1Y2UodCl9c3RhdGljIHJlZHVjZVBvaW50d2lzZSh0LGUpe2NvbnN0IG49bmV3IGxvKGUpO3JldHVybiBuLnNldFBvaW50d2lzZSghMCksbi5yZWR1Y2UodCl9Zml4UG9seWdvbmFsVG9wb2xvZ3kodCl7bGV0IGU9dDt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGU9dGhpcy5jaGFuZ2VQTSh0LHRoaXMuX3RhcmdldFBNKSk7cmV0dXJuIEdpLmJ1ZmZlck9wKGUsMCl9cmVkdWNlUG9pbnR3aXNlKHQpe2xldCBlPW51bGw7aWYodGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWwpe2NvbnN0IG49dGhpcy5jcmVhdGVGYWN0b3J5KHQuZ2V0RmFjdG9yeSgpLHRoaXMuX3RhcmdldFBNKTtlPW5ldyB1ZShuKX1lbHNlIGU9bmV3IHVlO2xldCBuPXRoaXMuX3JlbW92ZUNvbGxhcHNlZDt0LmdldERpbWVuc2lvbigpPj0yJiYobj0hMCk7cmV0dXJuIGUuZWRpdCh0LG5ldyBvbyh0aGlzLl90YXJnZXRQTSxuKSl9Y2hhbmdlUE0odCxlKXtyZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IodC5nZXRGYWN0b3J5KCksZSkuZWRpdCh0LG5ldyB1ZS5Ob09wR2VvbWV0cnlPcGVyYXRpb24pfXNldFJlbW92ZUNvbGxhcHNlZENvbXBvbmVudHModCl7dGhpcy5fcmVtb3ZlQ29sbGFwc2VkPXR9Y3JlYXRlRmFjdG9yeSh0LGUpe3JldHVybiBuZXcgQ3QoZSx0LmdldFNSSUQoKSx0LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9c2V0Q2hhbmdlUHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fY2hhbmdlUHJlY2lzaW9uTW9kZWw9dH1yZWR1Y2UodCl7Y29uc3QgZT10aGlzLnJlZHVjZVBvaW50d2lzZSh0KTtyZXR1cm4gdGhpcy5faXNQb2ludHdpc2U/ZTpJKGUsc3QpP0ZyLmlzVmFsaWQoZSk/ZTp0aGlzLmZpeFBvbHlnb25hbFRvcG9sb2d5KGUpOmV9c2V0UG9pbnR3aXNlKHQpe3RoaXMuX2lzUG9pbnR3aXNlPXR9Y3JlYXRlRWRpdG9yKHQsZSl7aWYodC5nZXRQcmVjaXNpb25Nb2RlbCgpPT09ZSlyZXR1cm4gbmV3IHVlO2NvbnN0IG49dGhpcy5jcmVhdGVGYWN0b3J5KHQsZSk7cmV0dXJuIG5ldyB1ZShuKX19dmFyIGFvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5UHJlY2lzaW9uUmVkdWNlcjpsb30pO2NsYXNzIGNve2NvbnN0cnVjdG9yKCl7Y28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fdXNlUHQ9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX3NlZz1uZXcgS3Q7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgY28odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5zaW1wbGlmeSgpfXNpbXBsaWZ5U2VjdGlvbih0LGUpe2lmKHQrMT09PWUpcmV0dXJuIG51bGw7dGhpcy5fc2VnLnAwPXRoaXMuX3B0c1t0XSx0aGlzLl9zZWcucDE9dGhpcy5fcHRzW2VdO2xldCBuPS0xLHM9dDtmb3IobGV0IGk9dCsxO2k8ZTtpKyspe2NvbnN0IHQ9dGhpcy5fc2VnLmRpc3RhbmNlKHRoaXMuX3B0c1tpXSk7dD5uJiYobj10LHM9aSl9aWYobjw9dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpZm9yKGxldCBuPXQrMTtuPGU7bisrKXRoaXMuX3VzZVB0W25dPSExO2Vsc2UgdGhpcy5zaW1wbGlmeVNlY3Rpb24odCxzKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihzLGUpfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnkoKXt0aGlzLl91c2VQdD1uZXcgQXJyYXkodGhpcy5fcHRzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3B0cy5sZW5ndGg7dCsrKXRoaXMuX3VzZVB0W3RdPSEwO3RoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5fcHRzLmxlbmd0aC0xKTtjb25zdCB0PW5ldyBSO2ZvcihsZXQgZT0wO2U8dGhpcy5fcHRzLmxlbmd0aDtlKyspdGhpcy5fdXNlUHRbZV0mJnQuYWRkKG5ldyBtKHRoaXMuX3B0c1tlXSkpO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9fWNsYXNzIGhve2NvbnN0cnVjdG9yKCl7aG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgaG8odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfXNldEVuc3VyZVZhbGlkKHQpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10fWdldFJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5pc0VtcHR5KCk/dGhpcy5faW5wdXRHZW9tLmNvcHkoKTpuZXcgdW8odGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PDApdGhyb3cgbmV3IHMoXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH19Y2xhc3MgdW8gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9ZX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgZnQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7Y29uc3Qgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IHM9bnVsbDtyZXR1cm4gcz0wPT09bi5sZW5ndGg/bmV3IEFycmF5KDApLmZpbGwobnVsbCk6Y28uc2ltcGxpZnkobix0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj1lIGluc3RhbmNlb2YgaXQscz1zdXBlci50cmFuc2Zvcm1MaW5lYXJSaW5nLmNhbGwodGhpcyx0LGUpO3JldHVybiFufHxzIGluc3RhbmNlb2YgdXQ/czpudWxsfX1oby5EUFRyYW5zZm9ybWVyPXVvO2NsYXNzIGdvIGV4dGVuZHMgS3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLGdvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BhcmVudD1udWxsLHRoaXMuX2luZGV4PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2dvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG51bGwsLTEpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO0t0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9wYXJlbnQ9bix0aGlzLl9pbmRleD1zfX1nZXRJbmRleCgpe3JldHVybiB0aGlzLl9pbmRleH1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50fX1jbGFzcyBfb3tjb25zdHJ1Y3Rvcigpe19vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BhcmVudExpbmU9bnVsbCx0aGlzLl9zZWdzPW51bGwsdGhpcy5fcmVzdWx0U2Vncz1uZXcgTCx0aGlzLl9taW5pbXVtU2l6ZT1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtfby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcGFyZW50TGluZT10LHRoaXMuX21pbmltdW1TaXplPWUsdGhpcy5pbml0KCl9fXN0YXRpYyBleHRyYWN0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkrMSkuZmlsbChudWxsKTtsZXQgbj1udWxsO2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKW49dC5nZXQocyksZVtzXT1uLnAwO3JldHVybiBlW2UubGVuZ3RoLTFdPW4ucDEsZX1hZGRUb1Jlc3VsdCh0KXt0aGlzLl9yZXN1bHRTZWdzLmFkZCh0KX1hc0xpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhfby5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2VncykpfWdldFJlc3VsdFNpemUoKXtjb25zdCB0PXRoaXMuX3Jlc3VsdFNlZ3Muc2l6ZSgpO3JldHVybiAwPT09dD8wOnQrMX1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZX1nZXRTZWdtZW50KHQpe3JldHVybiB0aGlzLl9zZWdzW3RdfWdldFBhcmVudENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKX1nZXRNaW5pbXVtU2l6ZSgpe3JldHVybiB0aGlzLl9taW5pbXVtU2l6ZX1hc0xpbmVhclJpbmcoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhfby5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2VncykpfWdldFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3NlZ3N9aW5pdCgpe2NvbnN0IHQ9dGhpcy5fcGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpO3RoaXMuX3NlZ3M9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0xO2UrKyl7Y29uc3Qgbj1uZXcgZ28odFtlXSx0W2UrMV0sdGhpcy5fcGFyZW50TGluZSxlKTt0aGlzLl9zZWdzW2VdPW59fWdldFJlc3VsdENvb3JkaW5hdGVzKCl7cmV0dXJuIF9vLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKX19Y2xhc3MgcG97Y29uc3RydWN0b3IoKXtwby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbmRleD1uZXcgSXN9cmVtb3ZlKHQpe3RoaXMuX2luZGV4LnJlbW92ZShuZXcgTyh0LnAwLHQucDEpLHQpfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgX28pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldFNlZ21lbnRzKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49dFtlXTt0aGlzLmFkZChuKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbmRleC5pbnNlcnQobmV3IE8odC5wMCx0LnAxKSx0KX19cXVlcnkodCl7Y29uc3QgZT1uZXcgTyh0LnAwLHQucDEpLG49bmV3IG1vKHQpO3RoaXMuX2luZGV4LnF1ZXJ5KGUsbik7cmV0dXJuIG4uZ2V0SXRlbXMoKX19Y2xhc3MgbW97Y29uc3RydWN0b3IoKXttby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9xdWVyeVNlZz1udWxsLHRoaXMuX2l0ZW1zPW5ldyBMO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3F1ZXJ5U2VnPXR9dmlzaXRJdGVtKHQpe2NvbnN0IGU9dDtPLmludGVyc2VjdHMoZS5wMCxlLnAxLHRoaXMuX3F1ZXJ5U2VnLnAwLHRoaXMuX3F1ZXJ5U2VnLnAxKSYmdGhpcy5faXRlbXMuYWRkKHQpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltEZV19fWNsYXNzIGZve2NvbnN0cnVjdG9yKCl7Zm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX2lucHV0SW5kZXg9bmV3IHBvLHRoaXMuX291dHB1dEluZGV4PW5ldyBwbyx0aGlzLl9saW5lPW51bGwsdGhpcy5fbGluZVB0cz1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRJbmRleD10LHRoaXMuX291dHB1dEluZGV4PWV9c3RhdGljIGlzSW5MaW5lU2VjdGlvbih0LGUsbil7aWYobi5nZXRQYXJlbnQoKSE9PXQuZ2V0UGFyZW50KCkpcmV0dXJuITE7Y29uc3Qgcz1uLmdldEluZGV4KCk7cmV0dXJuIHM+PWVbMF0mJnM8ZVsxXX1mbGF0dGVuKHQsZSl7Y29uc3Qgbj10aGlzLl9saW5lUHRzW3RdLHM9dGhpcy5fbGluZVB0c1tlXSxpPW5ldyBLdChuLHMpO3JldHVybiB0aGlzLnJlbW92ZSh0aGlzLl9saW5lLHQsZSksdGhpcy5fb3V0cHV0SW5kZXguYWRkKGkpLGl9aGFzQmFkSW50ZXJzZWN0aW9uKHQsZSxuKXtyZXR1cm4hIXRoaXMuaGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKG4pfHwhIXRoaXMuaGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnlTZWN0aW9uKHQsZSxuKXtuKz0xO2NvbnN0IHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodCsxPT09ZSl7Y29uc3QgZT10aGlzLl9saW5lLmdldFNlZ21lbnQodCk7cmV0dXJuIHRoaXMuX2xpbmUuYWRkVG9SZXN1bHQoZSksbnVsbH1sZXQgaT0hMDtpZih0aGlzLl9saW5lLmdldFJlc3VsdFNpemUoKTx0aGlzLl9saW5lLmdldE1pbmltdW1TaXplKCkpe24rMTx0aGlzLl9saW5lLmdldE1pbmltdW1TaXplKCkmJihpPSExKX1jb25zdCByPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG89dGhpcy5maW5kRnVydGhlc3RQb2ludCh0aGlzLl9saW5lUHRzLHQsZSxyKTtyWzBdPnRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlJiYoaT0hMSk7Y29uc3QgbD1uZXcgS3Q7aWYobC5wMD10aGlzLl9saW5lUHRzW3RdLGwucDE9dGhpcy5fbGluZVB0c1tlXSxzWzBdPXQsc1sxXT1lLHRoaXMuaGFzQmFkSW50ZXJzZWN0aW9uKHRoaXMuX2xpbmUscyxsKSYmKGk9ITEpLGkpe2NvbnN0IG49dGhpcy5mbGF0dGVuKHQsZSk7cmV0dXJuIHRoaXMuX2xpbmUuYWRkVG9SZXN1bHQobiksbnVsbH10aGlzLnNpbXBsaWZ5U2VjdGlvbih0LG8sbiksdGhpcy5zaW1wbGlmeVNlY3Rpb24obyxlLG4pfWhhc0JhZE91dHB1dEludGVyc2VjdGlvbih0KXtmb3IobGV0IGU9dGhpcy5fb3V0cHV0SW5kZXgucXVlcnkodCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihuLHQpKXJldHVybiEwfXJldHVybiExfWZpbmRGdXJ0aGVzdFBvaW50KHQsZSxuLHMpe2NvbnN0IGk9bmV3IEt0O2kucDA9dFtlXSxpLnAxPXRbbl07bGV0IHI9LTEsbz1lO2ZvcihsZXQgcz1lKzE7czxuO3MrKyl7Y29uc3QgZT10W3NdLG49aS5kaXN0YW5jZShlKTtuPnImJihyPW4sbz1zKX1yZXR1cm4gc1swXT1yLG99c2ltcGxpZnkodCl7dGhpcy5fbGluZT10LHRoaXMuX2xpbmVQdHM9dC5nZXRQYXJlbnRDb29yZGluYXRlcygpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5fbGluZVB0cy5sZW5ndGgtMSwwKX1yZW1vdmUodCxlLG4pe2ZvcihsZXQgcz1lO3M8bjtzKyspe2NvbnN0IGU9dC5nZXRTZWdtZW50KHMpO3RoaXMuX2lucHV0SW5kZXgucmVtb3ZlKGUpfX1oYXNJbnRlcmlvckludGVyc2VjdGlvbih0LGUpe3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQucDAsdC5wMSxlLnAwLGUucDEpLHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKX1oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil7Zm9yKGxldCBzPXRoaXMuX2lucHV0SW5kZXgucXVlcnkobikuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihpLG4pKXtpZihmby5pc0luTGluZVNlY3Rpb24odCxlLGkpKWNvbnRpbnVlO3JldHVybiEwfX1yZXR1cm4hMX19Y2xhc3MgeW97Y29uc3RydWN0b3IoKXt5by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEluZGV4PW5ldyBwbyx0aGlzLl9vdXRwdXRJbmRleD1uZXcgcG8sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9MH1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5KHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuX2lucHV0SW5kZXguYWRkKGUubmV4dCgpKTtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1uZXcgZm8odGhpcy5faW5wdXRJbmRleCx0aGlzLl9vdXRwdXRJbmRleCk7dC5zZXREaXN0YW5jZVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSksdC5zaW1wbGlmeShlLm5leHQoKSl9fX1jbGFzcyB4b3tjb25zdHJ1Y3Rvcigpe3hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2xpbmVTaW1wbGlmaWVyPW5ldyB5byx0aGlzLl9saW5lc3RyaW5nTWFwPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIHNpbXBsaWZ5KHQsZSl7Y29uc3Qgbj1uZXcgeG8odCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfWdldFJlc3VsdEdlb21ldHJ5KCl7aWYodGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmNvcHkoKTt0aGlzLl9saW5lc3RyaW5nTWFwPW5ldyBJdCx0aGlzLl9pbnB1dEdlb20uYXBwbHkobmV3IElvKHRoaXMpKSx0aGlzLl9saW5lU2ltcGxpZmllci5zaW1wbGlmeSh0aGlzLl9saW5lc3RyaW5nTWFwLnZhbHVlcygpKTtyZXR1cm4gbmV3IEVvKHRoaXMuX2xpbmVzdHJpbmdNYXApLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgcyhcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9saW5lU2ltcGxpZmllci5zZXREaXN0YW5jZVRvbGVyYW5jZSh0KX19Y2xhc3MgRW8gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZXN0cmluZ01hcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVzdHJpbmdNYXA9dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2lmKDA9PT10LnNpemUoKSlyZXR1cm4gbnVsbDtpZihlIGluc3RhbmNlb2YgSil7Y29uc3QgdD10aGlzLl9saW5lc3RyaW5nTWFwLmdldChlKTtyZXR1cm4gdGhpcy5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UodC5nZXRSZXN1bHRDb29yZGluYXRlcygpKX1yZXR1cm4gc3VwZXIudHJhbnNmb3JtQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQsZSl9fWNsYXNzIElve2NvbnN0cnVjdG9yKCl7SW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy50cHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRwcz10fWZpbHRlcih0KXtpZih0IGluc3RhbmNlb2YgSil7Y29uc3QgZT10O2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49ZS5pc0Nsb3NlZCgpPzQ6MixzPW5ldyBfbyhlLG4pO3RoaXMudHBzLl9saW5lc3RyaW5nTWFwLnB1dChlLHMpfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119fXhvLkxpbmVTdHJpbmdUcmFuc2Zvcm1lcj1Fbyx4by5MaW5lU3RyaW5nTWFwQnVpbGRlckZpbHRlcj1JbztjbGFzcyBOb3tjb25zdHJ1Y3Rvcigpe05vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX3RvbGVyYW5jZT1lKmV9c3RhdGljIHNpbXBsaWZ5KHQsZSl7cmV0dXJuIG5ldyBObyh0LGUpLnNpbXBsaWZ5KCl9c2ltcGxpZnlWZXJ0ZXgodCl7bGV0IGU9dCxuPWUuZ2V0QXJlYSgpLHM9bnVsbDtmb3IoO251bGwhPT1lOyl7Y29uc3QgdD1lLmdldEFyZWEoKTt0PG4mJihuPXQscz1lKSxlPWUuX25leHR9cmV0dXJuIG51bGwhPT1zJiZuPHRoaXMuX3RvbGVyYW5jZSYmcy5yZW1vdmUoKSx0LmlzTGl2ZSgpP246LTF9c2ltcGxpZnkoKXtjb25zdCB0PVNvLmJ1aWxkTGluZSh0aGlzLl9wdHMpO2xldCBlPXRoaXMuX3RvbGVyYW5jZTtkb3tlPXRoaXMuc2ltcGxpZnlWZXJ0ZXgodCl9d2hpbGUoZTx0aGlzLl90b2xlcmFuY2UpO2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBuLmxlbmd0aDwyP1tuWzBdLG5ldyBtKG5bMF0pXTpufX1jbGFzcyBTb3tjb25zdHJ1Y3Rvcigpe1NvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0PW51bGwsdGhpcy5fcHJldj1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9hcmVhPVNvLk1BWF9BUkVBLHRoaXMuX2lzTGl2ZT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdD10fXN0YXRpYyBidWlsZExpbmUodCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IGk9bmV3IFNvKHRbc10pO251bGw9PT1lJiYoZT1pKSxpLnNldFByZXYobiksbnVsbCE9PW4mJihuLnNldE5leHQoaSksbi51cGRhdGVBcmVhKCkpLG49aX1yZXR1cm4gZX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IFI7bGV0IGU9dGhpcztkb3t0LmFkZChlLl9wdCwhMSksZT1lLl9uZXh0fXdoaWxlKG51bGwhPT1lKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldEFyZWEoKXtyZXR1cm4gdGhpcy5fYXJlYX11cGRhdGVBcmVhKCl7aWYobnVsbD09PXRoaXMuX3ByZXZ8fG51bGw9PT10aGlzLl9uZXh0KXJldHVybiB0aGlzLl9hcmVhPVNvLk1BWF9BUkVBLG51bGw7dGhpcy5fYXJlYT1NYXRoLmFicyhuZS5hcmVhKHRoaXMuX3ByZXYuX3B0LHRoaXMuX3B0LHRoaXMuX25leHQuX3B0KSl9cmVtb3ZlKCl7Y29uc3QgdD10aGlzLl9wcmV2LGU9dGhpcy5fbmV4dDtsZXQgbj1udWxsO3JldHVybiBudWxsIT09dGhpcy5fcHJldiYmKHRoaXMuX3ByZXYuc2V0TmV4dChlKSx0aGlzLl9wcmV2LnVwZGF0ZUFyZWEoKSxuPXRoaXMuX3ByZXYpLG51bGwhPT10aGlzLl9uZXh0JiYodGhpcy5fbmV4dC5zZXRQcmV2KHQpLHRoaXMuX25leHQudXBkYXRlQXJlYSgpLG51bGw9PT1uJiYobj10aGlzLl9uZXh0KSksdGhpcy5faXNMaXZlPSExLG59aXNMaXZlKCl7cmV0dXJuIHRoaXMuX2lzTGl2ZX1zZXRQcmV2KHQpe3RoaXMuX3ByZXY9dH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH19U28uTUFYX0FSRUE9ci5NQVhfVkFMVUUsTm8uVldWZXJ0ZXg9U287Y2xhc3Mgd297Y29uc3RydWN0b3IoKXt3by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyB3byh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9c2V0RW5zdXJlVmFsaWQodCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLl9pbnB1dEdlb20uY29weSgpOm5ldyBDbyh0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgcyhcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fX1jbGFzcyBDbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxDby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITAsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1lfXRyYW5zZm9ybVBvbHlnb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBmdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1udWxsO3JldHVybiBzPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpOby5zaW1wbGlmeShuLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPWUgaW5zdGFuY2VvZiBpdCxzPXN1cGVyLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fHMgaW5zdGFuY2VvZiB1dD9zOm51bGx9fXdvLlZXVHJhbnNmb3JtZXI9Q287dmFyIExvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERvdWdsYXNQZXVja2VyU2ltcGxpZmllcjpobyxUb3BvbG9neVByZXNlcnZpbmdTaW1wbGlmaWVyOnhvLFZXU2ltcGxpZmllcjp3b30pO2NsYXNzIFRve2NvbnN0cnVjdG9yKCl7VG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2VnPW51bGwsdGhpcy5fc2VnTGVuPW51bGwsdGhpcy5fc3BsaXRQdD1udWxsLHRoaXMuX21pbmltdW1MZW49MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWc9dCx0aGlzLl9zZWdMZW49dC5nZXRMZW5ndGgoKX1zdGF0aWMgcG9pbnRBbG9uZ1JldmVyc2UodCxlKXtjb25zdCBuPW5ldyBtO3JldHVybiBuLng9dC5wMS54LWUqKHQucDEueC10LnAwLngpLG4ueT10LnAxLnktZSoodC5wMS55LXQucDAueSksbn1zcGxpdEF0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fbWluaW11bUxlbi90aGlzLl9zZWdMZW47aWYodC5kaXN0YW5jZSh0aGlzLl9zZWcucDApPHRoaXMuX21pbmltdW1MZW4pcmV0dXJuIHRoaXMuX3NwbGl0UHQ9dGhpcy5fc2VnLnBvaW50QWxvbmcoZSksbnVsbDtpZih0LmRpc3RhbmNlKHRoaXMuX3NlZy5wMSk8dGhpcy5fbWluaW11bUxlbilyZXR1cm4gdGhpcy5fc3BsaXRQdD1Uby5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLl9zZWcsZSksbnVsbDt0aGlzLl9zcGxpdFB0PXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLmdldENvbnN0cmFpbmVkTGVuZ3RoKHQpL3RoaXMuX3NlZ0xlbjtlLmVxdWFsczJEKHRoaXMuX3NlZy5wMCk/dGhpcy5fc3BsaXRQdD10aGlzLl9zZWcucG9pbnRBbG9uZyhuKTp0aGlzLl9zcGxpdFB0PVRvLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuX3NlZyxuKX19c2V0TWluaW11bUxlbmd0aCh0KXt0aGlzLl9taW5pbXVtTGVuPXR9Z2V0Q29uc3RyYWluZWRMZW5ndGgodCl7cmV0dXJuIHQ8dGhpcy5fbWluaW11bUxlbj90aGlzLl9taW5pbXVtTGVuOnR9Z2V0U3BsaXRQb2ludCgpe3JldHVybiB0aGlzLl9zcGxpdFB0fX1jbGFzcyBSb3tmaW5kU3BsaXRQb2ludCh0LGUpe319Y2xhc3MgUG97c3RhdGljIHByb2plY3RlZFNwbGl0UG9pbnQodCxlKXtyZXR1cm4gdC5nZXRMaW5lU2VnbWVudCgpLnByb2plY3QoZSl9ZmluZFNwbGl0UG9pbnQodCxlKXtjb25zdCBuPXQuZ2V0TGluZVNlZ21lbnQoKSxzPW4uZ2V0TGVuZ3RoKCkvMixpPW5ldyBUbyhuKSxyPVBvLnByb2plY3RlZFNwbGl0UG9pbnQodCxlKTtsZXQgbz0yKnIuZGlzdGFuY2UoZSkqLjg7cmV0dXJuIG8+cyYmKG89cyksaS5zZXRNaW5pbXVtTGVuZ3RoKG8pLGkuc3BsaXRBdChyKSxpLmdldFNwbGl0UG9pbnQoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUm9dfX1jbGFzcyBPb3tzdGF0aWMgdHJpQXJlYSh0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0oZS55LXQueSkqKG4ueC10LngpfXN0YXRpYyBpc0luQ2lyY2xlREROb3JtYWxpemVkKHQsZSxuLHMpe2NvbnN0IGk9RC52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KHMueCkscj1ELnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qocy55KSxvPUQudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdChzLngpLGw9RC52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHMueSksYT1ELnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3Qocy54KSxjPUQudmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdChzLnkpLGg9aS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoby5tdWx0aXBseShyKSksdT1vLm11bHRpcGx5KGMpLnNlbGZTdWJ0cmFjdChhLm11bHRpcGx5KGwpKSxnPWEubXVsdGlwbHkocikuc2VsZlN1YnRyYWN0KGkubXVsdGlwbHkoYykpLGQ9aS5tdWx0aXBseShpKS5zZWxmQWRkKHIubXVsdGlwbHkocikpLF89by5tdWx0aXBseShvKS5zZWxmQWRkKGwubXVsdGlwbHkobCkpLHA9YS5tdWx0aXBseShhKS5zZWxmQWRkKGMubXVsdGlwbHkoYykpO3JldHVybiBkLnNlbGZNdWx0aXBseSh1KS5zZWxmQWRkKF8uc2VsZk11bHRpcGx5KGcpKS5zZWxmQWRkKHAuc2VsZk11bHRpcGx5KGgpKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGNoZWNrUm9idXN0SW5DaXJjbGUodCxlLG4scyl7Y29uc3QgaT1Pby5pc0luQ2lyY2xlTm9uUm9idXN0KHQsZSxuLHMpLHI9T28uaXNJbkNpcmNsZUREU2xvdyh0LGUsbixzKSxvPU9vLmlzSW5DaXJjbGVDQyh0LGUsbixzKSxsPW5lLmNpcmN1bWNlbnRyZSh0LGUsbik7Qi5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCktdC5kaXN0YW5jZShsKSkvdC5kaXN0YW5jZShsKSksaT09PXImJmk9PT1vfHwoQi5vdXQucHJpbnRsbihcImluQ2lyY2xlIHJvYnVzdG5lc3MgZmFpbHVyZSAoZG91YmxlIHJlc3VsdCA9IFwiK2krXCIsIEREIHJlc3VsdCA9IFwiK3IrXCIsIENDIHJlc3VsdCA9IFwiK28rXCIpXCIpLEIub3V0LnByaW50bG4oV3QudG9MaW5lU3RyaW5nKG5ldyBwdChbdCxlLG4sc10pKSksQi5vdXQucHJpbnRsbihcIkNpcmN1bWNlbnRyZSA9IFwiK1d0LnRvUG9pbnQobCkrXCIgcmFkaXVzID0gXCIrdC5kaXN0YW5jZShsKSksQi5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvdC5kaXN0YW5jZShsKS0xKSksQi5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYiA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvZS5kaXN0YW5jZShsKS0xKSksQi5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYyA9IFwiK01hdGguYWJzKHMuZGlzdGFuY2UobCkvbi5kaXN0YW5jZShsKS0xKSksQi5vdXQucHJpbnRsbigpKX1zdGF0aWMgaXNJbkNpcmNsZURERmFzdCh0LGUsbixzKXtjb25zdCBpPUQuc3FyKHQueCkuc2VsZkFkZChELnNxcih0LnkpKS5zZWxmTXVsdGlwbHkoT28udHJpQXJlYURERmFzdChlLG4scykpLHI9RC5zcXIoZS54KS5zZWxmQWRkKEQuc3FyKGUueSkpLnNlbGZNdWx0aXBseShPby50cmlBcmVhRERGYXN0KHQsbixzKSksbz1ELnNxcihuLngpLnNlbGZBZGQoRC5zcXIobi55KSkuc2VsZk11bHRpcGx5KE9vLnRyaUFyZWFEREZhc3QodCxlLHMpKSxsPUQuc3FyKHMueCkuc2VsZkFkZChELnNxcihzLnkpKS5zZWxmTXVsdGlwbHkoT28udHJpQXJlYURERmFzdCh0LGUsbikpO3JldHVybiBpLnNlbGZTdWJ0cmFjdChyKS5zZWxmQWRkKG8pLnNlbGZTdWJ0cmFjdChsKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGlzSW5DaXJjbGVDQyh0LGUsbixzKXtjb25zdCBpPW5lLmNpcmN1bWNlbnRyZSh0LGUsbikscj10LmRpc3RhbmNlKGkpO3JldHVybiBzLmRpc3RhbmNlKGkpLXI8PTB9c3RhdGljIGlzSW5DaXJjbGVOb3JtYWxpemVkKHQsZSxuLHMpe2NvbnN0IGk9dC54LXMueCxyPXQueS1zLnksbz1lLngtcy54LGw9ZS55LXMueSxhPW4ueC1zLngsYz1uLnktcy55O3JldHVybihpKmkrcipyKSoobypjLWEqbCkrKG8qbytsKmwpKihhKnItaSpjKSsoYSphK2MqYykqKGkqbC1vKnIpPjB9c3RhdGljIGlzSW5DaXJjbGVERFNsb3codCxlLG4scyl7Y29uc3QgaT1ELnZhbHVlT2Yocy54KSxyPUQudmFsdWVPZihzLnkpLG89RC52YWx1ZU9mKHQueCksbD1ELnZhbHVlT2YodC55KSxhPUQudmFsdWVPZihlLngpLGM9RC52YWx1ZU9mKGUueSksaD1ELnZhbHVlT2Yobi54KSx1PUQudmFsdWVPZihuLnkpLGc9by5tdWx0aXBseShvKS5hZGQobC5tdWx0aXBseShsKSkubXVsdGlwbHkoT28udHJpQXJlYUREU2xvdyhhLGMsaCx1LGkscikpLGQ9YS5tdWx0aXBseShhKS5hZGQoYy5tdWx0aXBseShjKSkubXVsdGlwbHkoT28udHJpQXJlYUREU2xvdyhvLGwsaCx1LGkscikpLF89aC5tdWx0aXBseShoKS5hZGQodS5tdWx0aXBseSh1KSkubXVsdGlwbHkoT28udHJpQXJlYUREU2xvdyhvLGwsYSxjLGkscikpLHA9aS5tdWx0aXBseShpKS5hZGQoci5tdWx0aXBseShyKSkubXVsdGlwbHkoT28udHJpQXJlYUREU2xvdyhvLGwsYSxjLGgsdSkpO3JldHVybiBnLnN1YnRyYWN0KGQpLmFkZChfKS5zdWJ0cmFjdChwKS5kb3VibGVWYWx1ZSgpPjB9c3RhdGljIGlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4scyl7cmV0dXJuKHQueCp0LngrdC55KnQueSkqT28udHJpQXJlYShlLG4scyktKGUueCplLngrZS55KmUueSkqT28udHJpQXJlYSh0LG4scykrKG4ueCpuLngrbi55Km4ueSkqT28udHJpQXJlYSh0LGUscyktKHMueCpzLngrcy55KnMueSkqT28udHJpQXJlYSh0LGUsbik+MH1zdGF0aWMgaXNJbkNpcmNsZVJvYnVzdCh0LGUsbixzKXtyZXR1cm4gT28uaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4scyl9c3RhdGljIHRyaUFyZWFERFNsb3codCxlLG4scyxpLHIpe3JldHVybiBuLnN1YnRyYWN0KHQpLm11bHRpcGx5KHIuc3VidHJhY3QoZSkpLnN1YnRyYWN0KHMuc3VidHJhY3QoZSkubXVsdGlwbHkoaS5zdWJ0cmFjdCh0KSkpfXN0YXRpYyB0cmlBcmVhRERGYXN0KHQsZSxuKXtjb25zdCBzPUQudmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShELnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3QodC55KSksaT1ELnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KS5zZWxmTXVsdGlwbHkoRC52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KHQueCkpO3JldHVybiBzLnNlbGZTdWJ0cmFjdChpKX19Y2xhc3Mgdm97Y29uc3RydWN0b3IoKXt2by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3A9bmV3IG0odCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD1uZXcgbSh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3A9bmV3IG0odCxlLG4pfX1zdGF0aWMgaW50ZXJwb2xhdGVaKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5kaXN0YW5jZShuKSxpPXQuZGlzdGFuY2UoZSkscj1uLmdldFooKS1lLmdldFooKTtyZXR1cm4gZS5nZXRaKCkrciooaS9zKX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1lLngscj1lLnksbz1uLngtaSxsPXMueC1pLGE9bi55LXIsYz1zLnktcixoPW8qYy1sKmEsdT10LngtaSxnPXQueS1yLGQ9KGMqdS1sKmcpL2gsXz0oLWEqdStvKmcpL2g7cmV0dXJuIGUuZ2V0WigpK2QqKG4uZ2V0WigpLWUuZ2V0WigpKStfKihzLmdldFooKS1lLmdldFooKSl9fWNpcmNsZUNlbnRlcih0LGUpe2NvbnN0IG49bmV3IHZvKHRoaXMuZ2V0WCgpLHRoaXMuZ2V0WSgpKSxzPXRoaXMuYmlzZWN0b3Iobix0KSxpPXRoaXMuYmlzZWN0b3IodCxlKSxyPW5ldyBlZShzLGkpO2xldCBvPW51bGw7dHJ5e289bmV3IHZvKHIuZ2V0WCgpLHIuZ2V0WSgpKX1jYXRjaChzKXtpZighKHMgaW5zdGFuY2VvZiB0ZSkpdGhyb3cgcztCLmVyci5wcmludGxuKFwiYTogXCIrbitcIiAgYjogXCIrdCtcIiAgYzogXCIrZSksQi5lcnIucHJpbnRsbihzKX1yZXR1cm4gb31kb3QodCl7cmV0dXJuIHRoaXMuX3AueCp0LmdldFgoKSt0aGlzLl9wLnkqdC5nZXRZKCl9bWFnbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy5fcC54KnRoaXMuX3AueCt0aGlzLl9wLnkqdGhpcy5fcC55KX1nZXRaKCl7cmV0dXJuIHRoaXMuX3AuZ2V0WigpfWJpc2VjdG9yKHQsZSl7Y29uc3Qgbj1lLmdldFgoKS10LmdldFgoKSxzPWUuZ2V0WSgpLXQuZ2V0WSgpLGk9bmV3IGVlKHQuZ2V0WCgpK24vMix0LmdldFkoKStzLzIsMSkscj1uZXcgZWUodC5nZXRYKCktcytuLzIsdC5nZXRZKCkrbitzLzIsMSk7cmV0dXJuIG5ldyBlZShpLHIpfWVxdWFscygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fcC54PT09dC5nZXRYKCkmJnRoaXMuX3AueT09PXQuZ2V0WSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fcC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSk8ZX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wfWlzSW5DaXJjbGUodCxlLG4pe3JldHVybiBPby5pc0luQ2lyY2xlUm9idXN0KHQuX3AsZS5fcCxuLl9wLHRoaXMuX3ApfWludGVycG9sYXRlWlZhbHVlKHQsZSxuKXtjb25zdCBzPXQuZ2V0WCgpLGk9dC5nZXRZKCkscj1lLmdldFgoKS1zLG89bi5nZXRYKCktcyxsPWUuZ2V0WSgpLWksYT1uLmdldFkoKS1pLGM9ciphLW8qbCxoPXRoaXMuZ2V0WCgpLXMsdT10aGlzLmdldFkoKS1pLGc9KGEqaC1vKnUpL2MsZD0oLWwqaCtyKnUpL2M7cmV0dXJuIHQuZ2V0WigpK2cqKGUuZ2V0WigpLXQuZ2V0WigpKStkKihuLmdldFooKS10LmdldFooKSl9bWlkUG9pbnQodCl7Y29uc3QgZT0odGhpcy5fcC54K3QuZ2V0WCgpKS8yLG49KHRoaXMuX3AueSt0LmdldFkoKSkvMixzPSh0aGlzLl9wLmdldFooKSt0LmdldFooKSkvMjtyZXR1cm4gbmV3IHZvKGUsbixzKX1yaWdodE9mKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQuZGVzdCgpLHQub3JpZygpKX1pc0NDVyh0LGUpe3JldHVybih0Ll9wLngtdGhpcy5fcC54KSooZS5fcC55LXRoaXMuX3AueSktKHQuX3AueS10aGlzLl9wLnkpKihlLl9wLngtdGhpcy5fcC54KT4wfWdldFgoKXtyZXR1cm4gdGhpcy5fcC54fWNyb3NzUHJvZHVjdCh0KXtyZXR1cm4gdGhpcy5fcC54KnQuZ2V0WSgpLXRoaXMuX3AueSp0LmdldFgoKX1zZXRaKHQpe3RoaXMuX3Auc2V0Wih0KX10aW1lcyh0KXtyZXR1cm4gbmV3IHZvKHQqdGhpcy5fcC54LHQqdGhpcy5fcC55KX1jcm9zcygpe3JldHVybiBuZXcgdm8odGhpcy5fcC55LC10aGlzLl9wLngpfWxlZnRPZih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0Lm9yaWcoKSx0LmRlc3QoKSl9dG9TdHJpbmcoKXtyZXR1cm5cIlBPSU5UIChcIit0aGlzLl9wLngrXCIgXCIrdGhpcy5fcC55K1wiKVwifXN1Yih0KXtyZXR1cm4gbmV3IHZvKHRoaXMuX3AueC10LmdldFgoKSx0aGlzLl9wLnktdC5nZXRZKCkpfWdldFkoKXtyZXR1cm4gdGhpcy5fcC55fWNsYXNzaWZ5KHQsZSl7Y29uc3Qgbj10aGlzLHM9ZS5zdWIodCksaT1uLnN1Yih0KSxyPXMuY3Jvc3NQcm9kdWN0KGkpO3JldHVybiByPjA/dm8uTEVGVDpyPDA/dm8uUklHSFQ6cy5nZXRYKCkqaS5nZXRYKCk8MHx8cy5nZXRZKCkqaS5nZXRZKCk8MD92by5CRUhJTkQ6cy5tYWduKCk8aS5tYWduKCk/dm8uQkVZT05EOnQuZXF1YWxzKG4pP3ZvLk9SSUdJTjplLmVxdWFscyhuKT92by5ERVNUSU5BVElPTjp2by5CRVRXRUVOfXN1bSh0KXtyZXR1cm4gbmV3IHZvKHRoaXMuX3AueCt0LmdldFgoKSx0aGlzLl9wLnkrdC5nZXRZKCkpfWRpc3RhbmNlKHQsZSl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlLmdldFgoKS10LmdldFgoKSwyKStNYXRoLnBvdyhlLmdldFkoKS10LmdldFkoKSwyKSl9Y2lyY3VtUmFkaXVzUmF0aW8odCxlKXtjb25zdCBuPXRoaXMuY2lyY2xlQ2VudGVyKHQsZSkscz10aGlzLmRpc3RhbmNlKG4sdCk7bGV0IGk9dGhpcy5kaXN0YW5jZSh0aGlzLHQpLHI9dGhpcy5kaXN0YW5jZSh0LGUpO3JldHVybiByPGkmJihpPXIpLHI9dGhpcy5kaXN0YW5jZShlLHRoaXMpLHI8aSYmKGk9cikscy9pfX12by5MRUZUPTAsdm8uUklHSFQ9MSx2by5CRVlPTkQ9Mix2by5CRUhJTkQ9Myx2by5CRVRXRUVOPTQsdm8uT1JJR0lOPTUsdm8uREVTVElOQVRJT049NjtjbGFzcyBNbyBleHRlbmRzIHZve2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxNby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc09uQ29uc3RyYWludD1udWxsLHRoaXMuX2NvbnN0cmFpbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt2by5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWdldENvbnN0cmFpbnQoKXtyZXR1cm4gdGhpcy5fY29uc3RyYWludH1zZXRPbkNvbnN0cmFpbnQodCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9dH1tZXJnZSh0KXt0Ll9pc09uQ29uc3RyYWludCYmKHRoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuX2NvbnN0cmFpbnQ9dC5fY29uc3RyYWludCl9aXNPbkNvbnN0cmFpbnQoKXtyZXR1cm4gdGhpcy5faXNPbkNvbnN0cmFpbnR9c2V0Q29uc3RyYWludCh0KXt0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLl9jb25zdHJhaW50PXR9fWNsYXNzIGJve2NvbnN0cnVjdG9yKCl7Ym8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcm90PW51bGwsdGhpcy5fdmVydGV4PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2RhdGE9bnVsbH1zdGF0aWMgbWFrZUVkZ2UodCxlKXtjb25zdCBuPW5ldyBibyxzPW5ldyBibyxpPW5ldyBibyxyPW5ldyBibztuLl9yb3Q9cyxzLl9yb3Q9aSxpLl9yb3Q9cixyLl9yb3Q9bixuLnNldE5leHQobikscy5zZXROZXh0KHIpLGkuc2V0TmV4dChpKSxyLnNldE5leHQocyk7Y29uc3Qgbz1uO3JldHVybiBvLnNldE9yaWcodCksby5zZXREZXN0KGUpLG99c3RhdGljIHN3YXAodCl7Y29uc3QgZT10Lm9QcmV2KCksbj10LnN5bSgpLm9QcmV2KCk7Ym8uc3BsaWNlKHQsZSksYm8uc3BsaWNlKHQuc3ltKCksbiksYm8uc3BsaWNlKHQsZS5sTmV4dCgpKSxiby5zcGxpY2UodC5zeW0oKSxuLmxOZXh0KCkpLHQuc2V0T3JpZyhlLmRlc3QoKSksdC5zZXREZXN0KG4uZGVzdCgpKX1zdGF0aWMgc3BsaWNlKHQsZSl7Y29uc3Qgbj10Lm9OZXh0KCkucm90KCkscz1lLm9OZXh0KCkucm90KCksaT1lLm9OZXh0KCkscj10Lm9OZXh0KCksbz1zLm9OZXh0KCksbD1uLm9OZXh0KCk7dC5zZXROZXh0KGkpLGUuc2V0TmV4dChyKSxuLnNldE5leHQobykscy5zZXROZXh0KGwpfXN0YXRpYyBjb25uZWN0KHQsZSl7Y29uc3Qgbj1iby5tYWtlRWRnZSh0LmRlc3QoKSxlLm9yaWcoKSk7cmV0dXJuIGJvLnNwbGljZShuLHQubE5leHQoKSksYm8uc3BsaWNlKG4uc3ltKCksZSksbn1lcXVhbHNOb25PcmllbnRlZCh0KXtyZXR1cm4hIXRoaXMuZXF1YWxzT3JpZW50ZWQodCl8fCEhdGhpcy5lcXVhbHNPcmllbnRlZCh0LnN5bSgpKX10b0xpbmVTZWdtZW50KCl7cmV0dXJuIG5ldyBLdCh0aGlzLl92ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9ZGVzdCgpe3JldHVybiB0aGlzLnN5bSgpLm9yaWcoKX1vTmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fWVxdWFsc09yaWVudGVkKHQpe3JldHVybiEoIXRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCkpfHwhdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSkpfWROZXh0KCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKS5zeW0oKX1sUHJldigpe3JldHVybiB0aGlzLl9uZXh0LnN5bSgpfXJQcmV2KCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKX1yb3QoKXtyZXR1cm4gdGhpcy5fcm90fW9QcmV2KCl7cmV0dXJuIHRoaXMuX3JvdC5fbmV4dC5fcm90fXN5bSgpe3JldHVybiB0aGlzLl9yb3QuX3JvdH1zZXRPcmlnKHQpe3RoaXMuX3ZlcnRleD10fWxOZXh0KCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5yb3QoKX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9aW52Um90KCl7cmV0dXJuIHRoaXMuX3JvdC5zeW0oKX1zZXREZXN0KHQpe3RoaXMuc3ltKCkuc2V0T3JpZyh0KX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9ZGVsZXRlKCl7dGhpcy5fcm90PW51bGx9b3JpZygpe3JldHVybiB0aGlzLl92ZXJ0ZXh9ck5leHQoKXtyZXR1cm4gdGhpcy5fcm90Ll9uZXh0LmludlJvdCgpfXRvU3RyaW5nKCl7Y29uc3QgdD10aGlzLl92ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLGU9dGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpO3JldHVybiBXdC50b0xpbmVTdHJpbmcodCxlKX1pc0xpdmUoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX3JvdH1nZXRQcmltYXJ5KCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTw9MD90aGlzOnRoaXMuc3ltKCl9ZFByZXYoKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLmludlJvdCgpfXNldE5leHQodCl7dGhpcy5fbmV4dD10fX1jbGFzcyBEb3tjb25zdHJ1Y3Rvcigpe0RvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2lzVXNpbmdUb2xlcmFuY2U9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZGl2PXQsdGhpcy5faXNVc2luZ1RvbGVyYW5jZT10LmdldFRvbGVyYW5jZSgpPjB9aW5zZXJ0U2l0ZSh0KXtsZXQgZT10aGlzLl9zdWJkaXYubG9jYXRlKHQpO2lmKHRoaXMuX3N1YmRpdi5pc1ZlcnRleE9mRWRnZShlLHQpKXJldHVybiBlO3RoaXMuX3N1YmRpdi5pc09uRWRnZShlLHQuZ2V0Q29vcmRpbmF0ZSgpKSYmKGU9ZS5vUHJldigpLHRoaXMuX3N1YmRpdi5kZWxldGUoZS5vTmV4dCgpKSk7bGV0IG49dGhpcy5fc3ViZGl2Lm1ha2VFZGdlKGUub3JpZygpLHQpO2JvLnNwbGljZShuLGUpO2NvbnN0IHM9bjtkb3tuPXRoaXMuX3N1YmRpdi5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCl9d2hpbGUoZS5sTmV4dCgpIT09cyk7Zm9yKDs7KXtjb25zdCBpPWUub1ByZXYoKTtpZihpLmRlc3QoKS5yaWdodE9mKGUpJiZ0LmlzSW5DaXJjbGUoZS5vcmlnKCksaS5kZXN0KCksZS5kZXN0KCkpKWJvLnN3YXAoZSksZT1lLm9QcmV2KCk7ZWxzZXtpZihlLm9OZXh0KCk9PT1zKXJldHVybiBuO2U9ZS5vTmV4dCgpLmxQcmV2KCl9fX1pbnNlcnRTaXRlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUodCl9fX1jbGFzcyBBb3tsb2NhdGUodCl7fX1jbGFzcyBGb3tjb25zdHJ1Y3Rvcigpe0ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2xhc3RFZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZGl2PXQsdGhpcy5pbml0KCl9aW5pdCgpe3RoaXMuX2xhc3RFZGdlPXRoaXMuZmluZEVkZ2UoKX1sb2NhdGUodCl7dGhpcy5fbGFzdEVkZ2UuaXNMaXZlKCl8fHRoaXMuaW5pdCgpO2NvbnN0IGU9dGhpcy5fc3ViZGl2LmxvY2F0ZUZyb21FZGdlKHQsdGhpcy5fbGFzdEVkZ2UpO3JldHVybiB0aGlzLl9sYXN0RWRnZT1lLGV9ZmluZEVkZ2UoKXtyZXR1cm4gdGhpcy5fc3ViZGl2LmdldEVkZ2VzKCkuaXRlcmF0b3IoKS5uZXh0KCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FvXX19Y2xhc3MgR28gZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxHby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zZWc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFwiTG9jYXRlIGZhaWxlZCB0byBjb252ZXJnZSAoYXQgZWRnZTogXCIrdCtcIikuICBQb3NzaWJsZSBjYXVzZXMgaW5jbHVkZSBpbnZhbGlkIFN1YmRpdmlzaW9uIHRvcG9sb2d5IG9yIHZlcnkgY2xvc2Ugc2l0ZXNcIiksdGhpcy5fc2VnPW5ldyBLdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLEdvLm1zZ1dpdGhTcGF0aWFsKHQsZSkpLHRoaXMuX3NlZz1uZXcgS3QoZSl9fXN0YXRpYyBtc2dXaXRoU3BhdGlhbCh0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrZStcIiBdXCI6dH1nZXRTZWdtZW50KCl7cmV0dXJuIHRoaXMuX3NlZ319Y2xhc3MgcW97dmlzaXQodCl7fX1jbGFzcyBCb3tjb25zdHJ1Y3Rvcigpe0JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Zpc2l0ZWRLZXk9MCx0aGlzLl9xdWFkRWRnZXM9bmV3IEwsdGhpcy5fc3RhcnRpbmdFZGdlPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGwsdGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5fZnJhbWVWZXJ0ZXg9bmV3IEFycmF5KDMpLmZpbGwobnVsbCksdGhpcy5fZnJhbWVFbnY9bnVsbCx0aGlzLl9sb2NhdG9yPW51bGwsdGhpcy5fc2VnPW5ldyBLdCx0aGlzLl90cmlFZGdlcz1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl90b2xlcmFuY2U9ZSx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9ZS9Cby5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1IsdGhpcy5jcmVhdGVGcmFtZSh0KSx0aGlzLl9zdGFydGluZ0VkZ2U9dGhpcy5pbml0U3ViZGl2KCksdGhpcy5fbG9jYXRvcj1uZXcgRm8odGhpcyl9c3RhdGljIGdldFRyaWFuZ2xlRWRnZXModCxlKXtpZihlWzBdPXQsZVsxXT1lWzBdLmxOZXh0KCksZVsyXT1lWzFdLmxOZXh0KCksZVsyXS5sTmV4dCgpIT09ZVswXSl0aHJvdyBuZXcgcyhcIkVkZ2VzIGRvIG5vdCBmb3JtIGEgdHJpYW5nbGVcIil9Z2V0VHJpYW5nbGVWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyB6bztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcygpfWlzRnJhbWVWZXJ0ZXgodCl7cmV0dXJuISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFswXSl8fCghIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzFdKXx8ISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFsyXSkpfWlzVmVydGV4T2ZFZGdlKHQsZSl7cmV0dXJuISghZS5lcXVhbHModC5vcmlnKCksdGhpcy5fdG9sZXJhbmNlKSYmIWUuZXF1YWxzKHQuZGVzdCgpLHRoaXMuX3RvbGVyYW5jZSkpfWNvbm5lY3QodCxlKXtjb25zdCBuPWJvLmNvbm5lY3QodCxlKTtyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzLmFkZChuKSxufWdldFZvcm9ub2lDZWxsUG9seWdvbih0LGUpe2NvbnN0IG49bmV3IEwscz10O2Rve2NvbnN0IGU9dC5yb3QoKS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpO24uYWRkKGUpLHQ9dC5vUHJldigpfXdoaWxlKHQhPT1zKTtjb25zdCBpPW5ldyBSO2kuYWRkQWxsKG4sITEpLGkuY2xvc2VSaW5nKCksaS5zaXplKCk8NCYmKEIub3V0LnByaW50bG4oaSksaS5hZGQoaS5nZXQoaS5zaXplKCktMSksITApKTtjb25zdCByPWkudG9Db29yZGluYXRlQXJyYXkoKSxvPWUuY3JlYXRlUG9seWdvbihlLmNyZWF0ZUxpbmVhclJpbmcocikpLGw9cy5vcmlnKCk7cmV0dXJuIG8uc2V0VXNlckRhdGEobC5nZXRDb29yZGluYXRlKCkpLG99c2V0TG9jYXRvcih0KXt0aGlzLl9sb2NhdG9yPXR9aW5pdFN1YmRpdigpe2NvbnN0IHQ9dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFswXSx0aGlzLl9mcmFtZVZlcnRleFsxXSksZT10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzFdLHRoaXMuX2ZyYW1lVmVydGV4WzJdKTtiby5zcGxpY2UodC5zeW0oKSxlKTtjb25zdCBuPXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMl0sdGhpcy5fZnJhbWVWZXJ0ZXhbMF0pO3JldHVybiBiby5zcGxpY2UoZS5zeW0oKSxuKSxiby5zcGxpY2Uobi5zeW0oKSx0KSx0fWlzRnJhbWVCb3JkZXJFZGdlKHQpe2NvbnN0IGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Qm8uZ2V0VHJpYW5nbGVFZGdlcyh0LGUpO2NvbnN0IG49bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Qm8uZ2V0VHJpYW5nbGVFZGdlcyh0LnN5bSgpLG4pO2NvbnN0IHM9dC5sTmV4dCgpLmRlc3QoKTtpZih0aGlzLmlzRnJhbWVWZXJ0ZXgocykpcmV0dXJuITA7Y29uc3QgaT10LnN5bSgpLmxOZXh0KCkuZGVzdCgpO3JldHVybiEhdGhpcy5pc0ZyYW1lVmVydGV4KGkpfW1ha2VFZGdlKHQsZSl7Y29uc3Qgbj1iby5tYWtlRWRnZSh0LGUpO3JldHVybiB0aGlzLl9xdWFkRWRnZXMuYWRkKG4pLG59dmlzaXRUcmlhbmdsZXModCxlKXt0aGlzLl92aXNpdGVkS2V5Kys7Y29uc3Qgbj1uZXcgZW47bi5wdXNoKHRoaXMuX3N0YXJ0aW5nRWRnZSk7Y29uc3Qgcz1uZXcgeHQ7Zm9yKDshbi5lbXB0eSgpOyl7Y29uc3QgaT1uLnBvcCgpO2lmKCFzLmNvbnRhaW5zKGkpKXtjb25zdCByPXRoaXMuZmV0Y2hUcmlhbmdsZVRvVmlzaXQoaSxuLGUscyk7bnVsbCE9PXImJnQudmlzaXQocil9fX1pc0ZyYW1lRWRnZSh0KXtyZXR1cm4hKCF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5vcmlnKCkpJiYhdGhpcy5pc0ZyYW1lVmVydGV4KHQuZGVzdCgpKSl9aXNPbkVkZ2UodCxlKXt0aGlzLl9zZWcuc2V0Q29vcmRpbmF0ZXModC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk7cmV0dXJuIHRoaXMuX3NlZy5kaXN0YW5jZShlKTx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2V9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gbmV3IE8odGhpcy5fZnJhbWVFbnYpfWNyZWF0ZUZyYW1lKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKTtsZXQgcz0wO3M9ZT5uPzEwKmU6MTAqbix0aGlzLl9mcmFtZVZlcnRleFswXT1uZXcgdm8oKHQuZ2V0TWF4WCgpK3QuZ2V0TWluWCgpKS8yLHQuZ2V0TWF4WSgpK3MpLHRoaXMuX2ZyYW1lVmVydGV4WzFdPW5ldyB2byh0LmdldE1pblgoKS1zLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lVmVydGV4WzJdPW5ldyB2byh0LmdldE1heFgoKStzLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lRW52PW5ldyBPKHRoaXMuX2ZyYW1lVmVydGV4WzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLl9mcmFtZVZlcnRleFsxXS5nZXRDb29yZGluYXRlKCkpLHRoaXMuX2ZyYW1lRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9mcmFtZVZlcnRleFsyXS5nZXRDb29yZGluYXRlKCkpfWdldFRyaWFuZ2xlQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcga287cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlcygpfWdldFZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IHh0O2ZvcihsZXQgbj10aGlzLl9xdWFkRWRnZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCksaT1zLm9yaWcoKTshdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGkpfHxlLmFkZChpKTtjb25zdCByPXMuZGVzdCgpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKHIpfXJldHVybiBlfWZldGNoVHJpYW5nbGVUb1Zpc2l0KHQsZSxuLHMpe2xldCBpPXQscj0wLG89ITE7ZG97dGhpcy5fdHJpRWRnZXNbcl09aSx0aGlzLmlzRnJhbWVFZGdlKGkpJiYobz0hMCk7Y29uc3QgdD1pLnN5bSgpO3MuY29udGFpbnModCl8fGUucHVzaCh0KSxzLmFkZChpKSxyKyssaT1pLmxOZXh0KCl9d2hpbGUoaSE9PXQpO3JldHVybiBvJiYhbj9udWxsOnRoaXMuX3RyaUVkZ2VzfWdldEVkZ2VzKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3F1YWRFZGdlcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLmdldFByaW1hcnlFZGdlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7bGV0IHM9MDtmb3IobGV0IGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgZT1pLm5leHQoKTtuW3MrK109dC5jcmVhdGVMaW5lU3RyaW5nKFtlLm9yaWcoKS5nZXRDb29yZGluYXRlKCksZS5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpXSl9cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfX1nZXRWZXJ0ZXhVbmlxdWVFZGdlcyh0KXtjb25zdCBlPW5ldyBMLG49bmV3IHh0O2ZvcihsZXQgcz10aGlzLl9xdWFkRWRnZXMuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IGk9cy5uZXh0KCkscj1pLm9yaWcoKTtuLmNvbnRhaW5zKHIpfHwobi5hZGQociksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQoaSkpO2NvbnN0IG89aS5zeW0oKSxsPW8ub3JpZygpO24uY29udGFpbnMobCl8fChuLmFkZChsKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGwpfHxlLmFkZChvKSl9cmV0dXJuIGV9Z2V0VHJpYW5nbGVFZGdlcyh0KXtjb25zdCBlPW5ldyBWbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVFZGdlcygpfWdldFByaW1hcnlFZGdlcyh0KXt0aGlzLl92aXNpdGVkS2V5Kys7Y29uc3QgZT1uZXcgTCxuPW5ldyBlbjtuLnB1c2godGhpcy5fc3RhcnRpbmdFZGdlKTtjb25zdCBzPW5ldyB4dDtmb3IoOyFuLmVtcHR5KCk7KXtjb25zdCBpPW4ucG9wKCk7aWYoIXMuY29udGFpbnMoaSkpe2NvbnN0IHI9aS5nZXRQcmltYXJ5KCk7IXQmJnRoaXMuaXNGcmFtZUVkZ2Uocil8fGUuYWRkKHIpLG4ucHVzaChpLm9OZXh0KCkpLG4ucHVzaChpLnN5bSgpLm9OZXh0KCkpLHMuYWRkKGkpLHMuYWRkKGkuc3ltKCkpfX1yZXR1cm4gZX1kZWxldGUodCl7Ym8uc3BsaWNlKHQsdC5vUHJldigpKSxiby5zcGxpY2UodC5zeW0oKSx0LnN5bSgpLm9QcmV2KCkpO2NvbnN0IGU9dC5zeW0oKSxuPXQucm90KCkscz10LnJvdCgpLnN5bSgpO3RoaXMuX3F1YWRFZGdlcy5yZW1vdmUodCksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShlKSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUocyksdC5kZWxldGUoKSxlLmRlbGV0ZSgpLG4uZGVsZXRlKCkscy5kZWxldGUoKX1sb2NhdGVGcm9tRWRnZSh0LGUpe2xldCBuPTA7Y29uc3Qgcz10aGlzLl9xdWFkRWRnZXMuc2l6ZSgpO2xldCBpPWU7Zm9yKDs7KXtpZihuKyssbj5zKXRocm93IG5ldyBHbyhpLnRvTGluZVNlZ21lbnQoKSk7aWYodC5lcXVhbHMoaS5vcmlnKCkpfHx0LmVxdWFscyhpLmRlc3QoKSkpYnJlYWs7aWYodC5yaWdodE9mKGkpKWk9aS5zeW0oKTtlbHNlIGlmKHQucmlnaHRPZihpLm9OZXh0KCkpKXtpZih0LnJpZ2h0T2YoaS5kUHJldigpKSlicmVhaztpPWkuZFByZXYoKX1lbHNlIGk9aS5vTmV4dCgpfXJldHVybiBpfWdldFRvbGVyYW5jZSgpe3JldHVybiB0aGlzLl90b2xlcmFuY2V9Z2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KXt0aGlzLnZpc2l0VHJpYW5nbGVzKG5ldyBZbywhMCk7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dGhpcy5nZXRWZXJ0ZXhVbmlxdWVFZGdlcyghMSkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7ZS5hZGQodGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb24ocyx0KSl9cmV0dXJuIGV9Z2V0Vm9yb25vaURpYWdyYW0odCl7Y29uc3QgZT10aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbnModCk7cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEN0LnRvR2VvbWV0cnlBcnJheShlKSl9Z2V0VHJpYW5nbGVzKHQpe2NvbnN0IGU9dGhpcy5nZXRUcmlhbmdsZUNvb3JkaW5hdGVzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZVBvbHlnb24odC5jcmVhdGVMaW5lYXJSaW5nKGUpKX1yZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9aW5zZXJ0U2l0ZSh0KXtsZXQgZT10aGlzLmxvY2F0ZSh0KTtpZih0LmVxdWFscyhlLm9yaWcoKSx0aGlzLl90b2xlcmFuY2UpfHx0LmVxdWFscyhlLmRlc3QoKSx0aGlzLl90b2xlcmFuY2UpKXJldHVybiBlO2xldCBuPXRoaXMubWFrZUVkZ2UoZS5vcmlnKCksdCk7Ym8uc3BsaWNlKG4sZSk7Y29uc3Qgcz1uO2Rve249dGhpcy5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCl9d2hpbGUoZS5sTmV4dCgpIT09cyk7cmV0dXJuIHN9bG9jYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Ygdm8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZShuZXcgdm8odCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX2xvY2F0b3IubG9jYXRlKG5ldyB2byh0KSk7aWYobnVsbD09PW4pcmV0dXJuIG51bGw7bGV0IHM9bjtuLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodCkmJihzPW4uc3ltKCkpO2xldCBpPXM7ZG97aWYoaS5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKGUpKXJldHVybiBpO2k9aS5vTmV4dCgpfXdoaWxlKGkhPT1zKTtyZXR1cm4gbnVsbH19fWNsYXNzIFlve3Zpc2l0KHQpe2NvbnN0IGU9dFswXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLG49dFsxXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHM9dFsyXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGk9bmUuY2lyY3VtY2VudHJlREQoZSxuLHMpLHI9bmV3IHZvKGkpO2ZvcihsZXQgZT0wO2U8MztlKyspdFtlXS5yb3QoKS5zZXRPcmlnKHIpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltxb119fWNsYXNzIFZve2NvbnN0cnVjdG9yKCl7Vm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdHJpTGlzdD1uZXcgTH1nZXRUcmlhbmdsZUVkZ2VzKCl7cmV0dXJuIHRoaXMuX3RyaUxpc3R9dmlzaXQodCl7dGhpcy5fdHJpTGlzdC5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3FvXX19Y2xhc3Mgem97Y29uc3RydWN0b3IoKXt6by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90cmlMaXN0PW5ldyBMfXZpc2l0KHQpe3RoaXMuX3RyaUxpc3QuYWRkKFt0WzBdLm9yaWcoKSx0WzFdLm9yaWcoKSx0WzJdLm9yaWcoKV0pfWdldFRyaWFuZ2xlVmVydGljZXMoKXtyZXR1cm4gdGhpcy5fdHJpTGlzdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcW9dfX1jbGFzcyBrb3tjb25zdHJ1Y3Rvcigpe2tvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3JkTGlzdD1uZXcgUix0aGlzLl90cmlDb29yZHM9bmV3IEx9Y2hlY2tUcmlhbmdsZVNpemUodCl7bGV0IGU9XCJcIjt0Lmxlbmd0aD49Mj9lPVd0LnRvTGluZVN0cmluZyh0WzBdLHRbMV0pOnQubGVuZ3RoPj0xJiYoZT1XdC50b1BvaW50KHRbMF0pKX12aXNpdCh0KXt0aGlzLl9jb29yZExpc3QuY2xlYXIoKTtmb3IobGV0IGU9MDtlPDM7ZSsrKXtjb25zdCBuPXRbZV0ub3JpZygpO3RoaXMuX2Nvb3JkTGlzdC5hZGQobi5nZXRDb29yZGluYXRlKCkpfWlmKHRoaXMuX2Nvb3JkTGlzdC5zaXplKCk+MCl7dGhpcy5fY29vcmRMaXN0LmNsb3NlUmluZygpO2NvbnN0IHQ9dGhpcy5fY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7aWYoNCE9PXQubGVuZ3RoKXJldHVybiBudWxsO3RoaXMuX3RyaUNvb3Jkcy5hZGQodCl9fWdldFRyaWFuZ2xlcygpe3JldHVybiB0aGlzLl90cmlDb29yZHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3FvXX19Qm8uVHJpYW5nbGVDaXJjdW1jZW50cmVWaXNpdG9yPVlvLEJvLlRyaWFuZ2xlRWRnZXNMaXN0VmlzaXRvcj1WbyxCby5UcmlhbmdsZVZlcnRleExpc3RWaXNpdG9yPXpvLEJvLlRyaWFuZ2xlQ29vcmRpbmF0ZXNWaXNpdG9yPWtvLEJvLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUj0xZTM7Y2xhc3MgWG97Y29uc3RydWN0b3IoKXtYby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9scz1udWxsLHRoaXMuX2RhdGE9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbHM9bmV3IEt0KHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbHM9bmV3IEt0KHQsZSksdGhpcy5fZGF0YT1ufWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO1hvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IG0odCxlLG4pLG5ldyBtKHMsaSxyKSl9ZWxzZSBpZig3PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV0sbz1hcmd1bWVudHNbNl07WG8uY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSh0LGUsbiksbmV3IG0ocyxpLHIpLG8pfX1nZXRMaW5lU2VnbWVudCgpe3JldHVybiB0aGlzLl9sc31nZXRFbmRaKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkuZ2V0WigpfWdldFN0YXJ0Wigpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDApLmdldFooKX1pbnRlcnNlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2xzLmludGVyc2VjdGlvbih0LmdldExpbmVTZWdtZW50KCkpfWdldFN0YXJ0KCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCl9Z2V0RW5kKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSl9Z2V0RW5kWSgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLnl9Z2V0U3RhcnRYKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkueH1lcXVhbHNUb3BvKHQpe3JldHVybiB0aGlzLl9scy5lcXVhbHNUb3BvKHQuZ2V0TGluZVNlZ21lbnQoKSl9Z2V0U3RhcnRZKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkueX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9Z2V0RW5kWCgpe3JldHVybiB0aGlzLl9scy5nZXRDb29yZGluYXRlKDEpLnh9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fbHMudG9TdHJpbmcoKX19Y2xhc3MgVW8gZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxVby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFVvLm1zZ1dpdGhDb29yZCh0LGUpKSx0aGlzLl9wdD1uZXcgbShlKX19c3RhdGljIG1zZ1dpdGhDb29yZCh0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrV3QudG9Qb2ludChlKStcIiBdXCI6dH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fX1jbGFzcyBIb3tjb25zdHJ1Y3Rvcigpe0hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2luaXRpYWxWZXJ0aWNlcz1udWxsLHRoaXMuX3NlZ1ZlcnRpY2VzPW51bGwsdGhpcy5fc2VnbWVudHM9bmV3IEwsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5faW5jRGVsPW51bGwsdGhpcy5fY29udmV4SHVsbD1udWxsLHRoaXMuX3NwbGl0RmluZGVyPW5ldyBQbyx0aGlzLl9rZHQ9bnVsbCx0aGlzLl92ZXJ0ZXhGYWN0b3J5PW51bGwsdGhpcy5fY29tcHV0ZUFyZWFFbnY9bnVsbCx0aGlzLl9zcGxpdFB0PW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5pdGlhbFZlcnRpY2VzPW5ldyBMKHQpLHRoaXMuX3RvbGVyYW5jZT1lLHRoaXMuX2tkdD1uZXcgdXMoZSl9c3RhdGljIGNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBPO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0Q29vcmRpbmF0ZSgpKX1yZXR1cm4gZX1nZXRJbml0aWFsVmVydGljZXMoKXtyZXR1cm4gdGhpcy5faW5pdGlhbFZlcnRpY2VzfWdldEtEVCgpe3JldHVybiB0aGlzLl9rZHR9ZW5mb3JjZUNvbnN0cmFpbnRzKCl7dGhpcy5hZGRDb25zdHJhaW50VmVydGljZXMoKTtsZXQgdD0wLGU9MDtkb3tlPXRoaXMuZW5mb3JjZUdhYnJpZWwodGhpcy5fc2VnbWVudHMpLHQrK313aGlsZShlPjAmJnQ8SG8uTUFYX1NQTElUX0lURVIpO2lmKHQ9PT1Iby5NQVhfU1BMSVRfSVRFUil0aHJvdyBuZXcgVW8oXCJUb28gbWFueSBzcGxpdHRpbmcgaXRlcmF0aW9ucyB3aGlsZSBlbmZvcmNpbmcgY29uc3RyYWludHMuICBMYXN0IHNwbGl0IHBvaW50IHdhcyBhdDogXCIsdGhpcy5fc3BsaXRQdCl9aW5zZXJ0U2l0ZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKHQpfX1nZXRWZXJ0ZXhGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX3ZlcnRleEZhY3Rvcnl9Z2V0UG9pbnRBcnJheSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2luaXRpYWxWZXJ0aWNlcy5zaXplKCkrdGhpcy5fc2VnVmVydGljZXMuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuX2luaXRpYWxWZXJ0aWNlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTt0W2UrK109cy5nZXRDb29yZGluYXRlKCl9Zm9yKGxldCBuPXRoaXMuX3NlZ1ZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3RbZSsrXT1zLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gdH1zZXRDb25zdHJhaW50cyh0LGUpe3RoaXMuX3NlZ21lbnRzPXQsdGhpcy5fc2VnVmVydGljZXM9ZX1jb21wdXRlQ29udmV4SHVsbCgpe2NvbnN0IHQ9bmV3IEN0LGU9dGhpcy5nZXRQb2ludEFycmF5KCksbj1uZXcgc24oZSx0KTt0aGlzLl9jb252ZXhIdWxsPW4uZ2V0Q29udmV4SHVsbCgpfWFkZENvbnN0cmFpbnRWZXJ0aWNlcygpe3RoaXMuY29tcHV0ZUNvbnZleEh1bGwoKSx0aGlzLmluc2VydFNpdGVzKHRoaXMuX3NlZ1ZlcnRpY2VzKX1maW5kTm9uR2FicmllbFBvaW50KHQpe2NvbnN0IGU9dC5nZXRTdGFydCgpLG49dC5nZXRFbmQoKSxzPW5ldyBtKChlLngrbi54KS8yLChlLnkrbi55KS8yKSxpPWUuZGlzdGFuY2Uocyksbz1uZXcgTyhzKTtvLmV4cGFuZEJ5KGkpO2NvbnN0IGw9dGhpcy5fa2R0LnF1ZXJ5KG8pO2xldCBhPW51bGwsYz1yLk1BWF9WQUxVRTtmb3IobGV0IHQ9bC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgcj10Lm5leHQoKS5nZXRDb29yZGluYXRlKCk7aWYoci5lcXVhbHMyRChlKXx8ci5lcXVhbHMyRChuKSljb250aW51ZTtjb25zdCBvPXMuZGlzdGFuY2Uocik7aWYobzxpKXtjb25zdCB0PW87KG51bGw9PT1hfHx0PGMpJiYoYT1yLGM9dCl9fXJldHVybiBhfWdldENvbnN0cmFpbnRTZWdtZW50cygpe3JldHVybiB0aGlzLl9zZWdtZW50c31zZXRTcGxpdFBvaW50RmluZGVyKHQpe3RoaXMuX3NwbGl0RmluZGVyPXR9Z2V0Q29udmV4SHVsbCgpe3JldHVybiB0aGlzLl9jb252ZXhIdWxsfWdldFRvbGVyYW5jZSgpe3JldHVybiB0aGlzLl90b2xlcmFuY2V9ZW5mb3JjZUdhYnJpZWwodCl7Y29uc3QgZT1uZXcgTDtsZXQgbj0wO2NvbnN0IHM9bmV3IEw7Zm9yKGxldCBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IHQ9aS5uZXh0KCkscj10aGlzLmZpbmROb25HYWJyaWVsUG9pbnQodCk7aWYobnVsbD09PXIpY29udGludWU7dGhpcy5fc3BsaXRQdD10aGlzLl9zcGxpdEZpbmRlci5maW5kU3BsaXRQb2ludCh0LHIpO2NvbnN0IG89dGhpcy5jcmVhdGVWZXJ0ZXgodGhpcy5fc3BsaXRQdCx0KTt0aGlzLmluc2VydFNpdGUobykuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHRoaXMuX3NwbGl0UHQpO2NvbnN0IGw9bmV3IFhvKHQuZ2V0U3RhcnRYKCksdC5nZXRTdGFydFkoKSx0LmdldFN0YXJ0WigpLG8uZ2V0WCgpLG8uZ2V0WSgpLG8uZ2V0WigpLHQuZ2V0RGF0YSgpKSxhPW5ldyBYbyhvLmdldFgoKSxvLmdldFkoKSxvLmdldFooKSx0LmdldEVuZFgoKSx0LmdldEVuZFkoKSx0LmdldEVuZFooKSx0LmdldERhdGEoKSk7ZS5hZGQobCksZS5hZGQoYSkscy5hZGQodCksbis9MX1yZXR1cm4gdC5yZW1vdmVBbGwocyksdC5hZGRBbGwoZSksbn1jcmVhdGVWZXJ0ZXgoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbDtyZXR1cm4gZT1udWxsIT09dGhpcy5fdmVydGV4RmFjdG9yeT90aGlzLl92ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleCh0LG51bGwpOm5ldyBNbyh0KSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsO3JldHVybiBuPW51bGwhPT10aGlzLl92ZXJ0ZXhGYWN0b3J5P3RoaXMuX3ZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsZSk6bmV3IE1vKHQpLG4uc2V0T25Db25zdHJhaW50KCEwKSxufX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLl9zdWJkaXZ9Y29tcHV0ZUJvdW5kaW5nQm94KCl7Y29uc3QgdD1Iby5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5faW5pdGlhbFZlcnRpY2VzKSxlPUhvLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLl9zZWdWZXJ0aWNlcyksbj1uZXcgTyh0KTtuLmV4cGFuZFRvSW5jbHVkZShlKTtjb25zdCBzPS4yKm4uZ2V0V2lkdGgoKSxpPS4yKm4uZ2V0SGVpZ2h0KCkscj1NYXRoLm1heChzLGkpO3RoaXMuX2NvbXB1dGVBcmVhRW52PW5ldyBPKG4pLHRoaXMuX2NvbXB1dGVBcmVhRW52LmV4cGFuZEJ5KHIpfXNldFZlcnRleEZhY3RvcnkodCl7dGhpcy5fdmVydGV4RmFjdG9yeT10fWZvcm1Jbml0aWFsRGVsYXVuYXkoKXt0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuX3N1YmRpdj1uZXcgQm8odGhpcy5fY29tcHV0ZUFyZWFFbnYsdGhpcy5fdG9sZXJhbmNlKSx0aGlzLl9zdWJkaXYuc2V0TG9jYXRvcihuZXcgRm8odGhpcy5fc3ViZGl2KSksdGhpcy5faW5jRGVsPW5ldyBEbyh0aGlzLl9zdWJkaXYpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5faW5pdGlhbFZlcnRpY2VzKX1pbnNlcnRTaXRlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBNbyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9rZHQuaW5zZXJ0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpO2lmKGUuaXNSZXBlYXRlZCgpKXtjb25zdCBuPWUuZ2V0RGF0YSgpO3JldHVybiBuLm1lcmdlKHQpLG59cmV0dXJuIHRoaXMuX2luY0RlbC5pbnNlcnRTaXRlKHQpLHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFNpdGUodGhpcy5jcmVhdGVWZXJ0ZXgodCkpfX19SG8uTUFYX1NQTElUX0lURVI9OTk7Y2xhc3MgV297Y29uc3RydWN0b3IoKXtXby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGx9c3RhdGljIGV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KXtpZihudWxsPT09dClyZXR1cm4gbmV3IFI7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIFdvLnVuaXF1ZShlKX1zdGF0aWMgZW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTztmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZSh0KX1yZXR1cm4gZX1zdGF0aWMgdW5pcXVlKHQpe2NvbnN0IGU9ZHQuY29weURlZXAodCk7bnQuc29ydChlKTtyZXR1cm4gbmV3IFIoZSwhMSl9c3RhdGljIHRvVmVydGljZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgdm8odCkpfXJldHVybiBlfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1Xby5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKSxlPVdvLnRvVmVydGljZXModGhpcy5fc2l0ZUNvb3Jkcyk7dGhpcy5fc3ViZGl2PW5ldyBCbyh0LHRoaXMuX3RvbGVyYW5jZSk7bmV3IERvKHRoaXMuX3N1YmRpdikuaW5zZXJ0U2l0ZXMoZSl9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldFNpdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPVdvLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaXRlQ29vcmRzPVdvLnVuaXF1ZShkdC50b0Nvb3JkaW5hdGVBcnJheSh0KSl9fWdldEVkZ2VzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRFZGdlcyh0KX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn1nZXRUcmlhbmdsZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX19Y2xhc3MgWm97Y29uc3RydWN0b3IoKXtaby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fY29uc3RyYWludExpbmVzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fY29uc3RyYWludFZlcnRleE1hcD1uZXcgSG59c3RhdGljIGNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXllLmdldExpbmVzKHQpLG49bmV3IEw7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7Wm8uY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKGUsbil9cmV0dXJuIG59aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDtuKyspdC5hZGQobmV3IFhvKGVbbi0xXSxlW25dKSl9fWNyZWF0ZVNpdGVWZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAuY29udGFpbnNLZXkodCl8fGUuYWRkKG5ldyBNbyh0KSl9cmV0dXJuIGV9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PVdvLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpO2xldCBlPW5ldyBMO251bGwhPT10aGlzLl9jb25zdHJhaW50TGluZXMmJih0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb25zdHJhaW50TGluZXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSx0aGlzLmNyZWF0ZVZlcnRpY2VzKHRoaXMuX2NvbnN0cmFpbnRMaW5lcyksZT1aby5jcmVhdGVDb25zdHJhaW50U2VnbWVudHModGhpcy5fY29uc3RyYWludExpbmVzKSk7Y29uc3Qgbj10aGlzLmNyZWF0ZVNpdGVWZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKSxzPW5ldyBIbyhuLHRoaXMuX3RvbGVyYW5jZSk7cy5zZXRDb25zdHJhaW50cyhlLG5ldyBMKHRoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXAudmFsdWVzKCkpKSxzLmZvcm1Jbml0aWFsRGVsYXVuYXkoKSxzLmVuZm9yY2VDb25zdHJhaW50cygpLHRoaXMuX3N1YmRpdj1zLmdldFN1YmRpdmlzaW9uKCl9c2V0VG9sZXJhbmNlKHQpe3RoaXMuX3RvbGVyYW5jZT10fXNldENvbnN0cmFpbnRzKHQpe3RoaXMuX2NvbnN0cmFpbnRMaW5lcz10fXNldFNpdGVzKHQpe3RoaXMuX3NpdGVDb29yZHM9V28uZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWdldEVkZ2VzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRFZGdlcyh0KX1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn1nZXRUcmlhbmdsZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX1jcmVhdGVWZXJ0aWNlcyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgbj1uZXcgTW8oZVt0XSk7dGhpcy5fY29uc3RyYWludFZlcnRleE1hcC5wdXQoZVt0XSxuKX19fWNsYXNzIGpve2NvbnN0cnVjdG9yKCl7am8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2NsaXBFbnY9bnVsbCx0aGlzLl9kaWFncmFtRW52PW51bGx9c3RhdGljIGNsaXBHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoZSkscz1uZXcgTDtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7Y29uc3Qgcj10LmdldEdlb21ldHJ5TihpKTtsZXQgbz1udWxsO2UuY29udGFpbnMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpP289cjplLmludGVyc2VjdHMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYobz1Oci5pbnRlcnNlY3Rpb24obixyKSxvLnNldFVzZXJEYXRhKHIuZ2V0VXNlckRhdGEoKSkpLG51bGw9PT1vfHxvLmlzRW1wdHkoKXx8cy5hZGQobyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihDdC50b0dlb21ldHJ5QXJyYXkocykpfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1Xby5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKTtpZih0aGlzLl9kaWFncmFtRW52PXRoaXMuX2NsaXBFbnYsbnVsbD09PXRoaXMuX2RpYWdyYW1FbnYpe3RoaXMuX2RpYWdyYW1FbnY9dDtjb25zdCBlPXRoaXMuX2RpYWdyYW1FbnYuZ2V0RGlhbWV0ZXIoKTt0aGlzLl9kaWFncmFtRW52LmV4cGFuZEJ5KGUpfWNvbnN0IGU9V28udG9WZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9zdWJkaXY9bmV3IEJvKHQsdGhpcy5fdG9sZXJhbmNlKTtuZXcgRG8odGhpcy5fc3ViZGl2KS5pbnNlcnRTaXRlcyhlKX1nZXREaWFncmFtKHQpe3RoaXMuY3JlYXRlKCk7Y29uc3QgZT10aGlzLl9zdWJkaXYuZ2V0Vm9yb25vaURpYWdyYW0odCk7cmV0dXJuIGpvLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb24oZSx0aGlzLl9kaWFncmFtRW52KX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0U2l0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9V28uZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9V28udW5pcXVlKGR0LnRvQ29vcmRpbmF0ZUFycmF5KHQpKX19c2V0Q2xpcEVudmVsb3BlKHQpe3RoaXMuX2NsaXBFbnY9dH1nZXRTdWJkaXZpc2lvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdn19dmFyIEtvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFZlcnRleDp2b30pLFFvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvbmZvcm1pbmdEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOlpvLERlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6V28sVm9yb25vaURpYWdyYW1CdWlsZGVyOmpvLHF1YWRlZGdlOktvfSk7Y2xhc3MgSm97Y29uc3RydWN0b3IoKXtKby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9saW5lYXJHZW9tPW51bGwsdGhpcy5fbnVtTGluZXM9bnVsbCx0aGlzLl9jdXJyZW50TGluZT1udWxsLHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fdmVydGV4SW5kZXg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Sm8uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDAsMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Sm8uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUuZ2V0Q29tcG9uZW50SW5kZXgoKSxKby5zZWdtZW50RW5kVmVydGV4SW5kZXgoZSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKCFJKHQsVykpdGhyb3cgbmV3IHMoXCJMaW5lYWwgZ2VvbWV0cnkgaXMgcmVxdWlyZWRcIik7dGhpcy5fbGluZWFyR2VvbT10LHRoaXMuX251bUxpbmVzPXQuZ2V0TnVtR2VvbWV0cmllcygpLHRoaXMuX2NvbXBvbmVudEluZGV4PWUsdGhpcy5fdmVydGV4SW5kZXg9bix0aGlzLmxvYWRDdXJyZW50TGluZSgpfX1zdGF0aWMgc2VnbWVudEVuZFZlcnRleEluZGV4KHQpe3JldHVybiB0LmdldFNlZ21lbnRGcmFjdGlvbigpPjA/dC5nZXRTZWdtZW50SW5kZXgoKSsxOnQuZ2V0U2VnbWVudEluZGV4KCl9Z2V0Q29tcG9uZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXh9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9jdXJyZW50TGluZX1nZXRWZXJ0ZXhJbmRleCgpe3JldHVybiB0aGlzLl92ZXJ0ZXhJbmRleH1nZXRTZWdtZW50RW5kKCl7cmV0dXJuIHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuZ2V0TGluZSgpLmdldE51bVBvaW50cygpLTE/dGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgrMSk6bnVsbH1uZXh0KCl7aWYoIXRoaXMuaGFzTmV4dCgpKXJldHVybiBudWxsO3RoaXMuX3ZlcnRleEluZGV4KyssdGhpcy5fdmVydGV4SW5kZXg+PXRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpJiYodGhpcy5fY29tcG9uZW50SW5kZXgrKyx0aGlzLmxvYWRDdXJyZW50TGluZSgpLHRoaXMuX3ZlcnRleEluZGV4PTApfWxvYWRDdXJyZW50TGluZSgpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcylyZXR1cm4gdGhpcy5fY3VycmVudExpbmU9bnVsbCxudWxsO3RoaXMuX2N1cnJlbnRMaW5lPXRoaXMuX2xpbmVhckdlb20uZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KX1nZXRTZWdtZW50U3RhcnQoKXtyZXR1cm4gdGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgpfWlzRW5kT2ZMaW5lKCl7cmV0dXJuISh0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpJiYhKHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpLTEpfWhhc05leHQoKXtyZXR1cm4hKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcykmJiEodGhpcy5fY29tcG9uZW50SW5kZXg9PT10aGlzLl9udW1MaW5lcy0xJiZ0aGlzLl92ZXJ0ZXhJbmRleD49dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCkpfX1jbGFzcyAkb3tjb25zdHJ1Y3RvcigpeyRvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9c3RhdGljIGluZGV4T2YodCxlKXtyZXR1cm4gbmV3ICRvKHQpLmluZGV4T2YoZSl9c3RhdGljIGluZGV4T2ZBZnRlcih0LGUsbil7cmV0dXJuIG5ldyAkbyh0KS5pbmRleE9mQWZ0ZXIoZSxuKX1pbmRleE9mKHQpe3JldHVybiB0aGlzLmluZGV4T2ZGcm9tU3RhcnQodCwtMSl9aW5kZXhPZkZyb21TdGFydCh0LGUpe2xldCBuPXIuTUFYX1ZBTFVFLHM9ZSxpPTA7Y29uc3Qgbz1uZXcgS3QsbD1uZXcgSm8odGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtsLmhhc05leHQoKTspe2lmKCFsLmlzRW5kT2ZMaW5lKCkpe28ucDA9bC5nZXRTZWdtZW50U3RhcnQoKSxvLnAxPWwuZ2V0U2VnbWVudEVuZCgpO2NvbnN0IHI9by5kaXN0YW5jZSh0KSxhPXRoaXMuc2VnbWVudE5lYXJlc3RNZWFzdXJlKG8sdCxpKTtyPG4mJmE+ZSYmKHM9YSxuPXIpLGkrPW8uZ2V0TGVuZ3RoKCl9bC5uZXh0KCl9cmV0dXJuIHN9aW5kZXhPZkFmdGVyKHQsZSl7aWYoZTwwKXJldHVybiB0aGlzLmluZGV4T2YodCk7Y29uc3Qgbj10aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpO2lmKG48ZSlyZXR1cm4gbjtjb25zdCBzPXRoaXMuaW5kZXhPZkZyb21TdGFydCh0LGUpO3JldHVybiBnLmlzVHJ1ZShzPj1lLFwiY29tcHV0ZWQgaW5kZXggaXMgYmVmb3JlIHNwZWNpZmllZCBtaW5pbXVtIGluZGV4XCIpLHN9c2VnbWVudE5lYXJlc3RNZWFzdXJlKHQsZSxuKXtjb25zdCBzPXQucHJvamVjdGlvbkZhY3RvcihlKTtyZXR1cm4gczw9MD9uOnM8PTE/bitzKnQuZ2V0TGVuZ3RoKCk6bit0LmdldExlbmd0aCgpfX1jbGFzcyB0bHtjb25zdHJ1Y3Rvcigpe3RsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fc2VnbWVudEluZGV4PTAsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQuX2NvbXBvbmVudEluZGV4LHRoaXMuX3NlZ21lbnRJbmRleD10Ll9zZWdtZW50SW5kZXgsdGhpcy5fc2VnbWVudEZyYWN0aW9uPXQuX3NlZ21lbnRGcmFjdGlvbn1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0bC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDAsdCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9jb21wb25lbnRJbmRleD10LHRoaXMuX3NlZ21lbnRJbmRleD1lLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj1uLHRoaXMubm9ybWFsaXplKCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fY29tcG9uZW50SW5kZXg9dCx0aGlzLl9zZWdtZW50SW5kZXg9ZSx0aGlzLl9zZWdtZW50RnJhY3Rpb249bixzJiZ0aGlzLm5vcm1hbGl6ZSgpfX1zdGF0aWMgZ2V0RW5kTG9jYXRpb24odCl7Y29uc3QgZT1uZXcgdGw7cmV0dXJuIGUuc2V0VG9FbmQodCksZX1zdGF0aWMgcG9pbnRBbG9uZ1NlZ21lbnRCeUZyYWN0aW9uKHQsZSxuKXtpZihuPD0wKXJldHVybiB0O2lmKG4+PTEpcmV0dXJuIGU7Y29uc3Qgcz0oZS54LXQueCkqbit0LngsaT0oZS55LXQueSkqbit0Lnkscj0oZS5nZXRaKCktdC5nZXRaKCkpKm4rdC5nZXRaKCk7cmV0dXJuIG5ldyBtKHMsaSxyKX1zdGF0aWMgY29tcGFyZUxvY2F0aW9uVmFsdWVzKHQsZSxuLHMsaSxyKXtyZXR1cm4gdDxzPy0xOnQ+cz8xOmU8aT8tMTplPmk/MTpuPHI/LTE6bj5yPzE6MH1zdGF0aWMgbnVtU2VnbWVudHModCl7Y29uc3QgZT10LmdldE51bVBvaW50cygpO3JldHVybiBlPD0xPzA6ZS0xfWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXh9Z2V0Q29tcG9uZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXh9aXNFbmRwb2ludCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPXRsLm51bVNlZ21lbnRzKGUpO3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXg+PW58fHRoaXMuX3NlZ21lbnRJbmRleD09PW4tMSYmdGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xfWlzVmFsaWQodCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg8MHx8dGhpcy5fY29tcG9uZW50SW5kZXg+PXQuZ2V0TnVtR2VvbWV0cmllcygpKXJldHVybiExO2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3JldHVybiEodGhpcy5fc2VnbWVudEluZGV4PDB8fHRoaXMuX3NlZ21lbnRJbmRleD5lLmdldE51bVBvaW50cygpKSYmKCh0aGlzLl9zZWdtZW50SW5kZXghPT1lLmdldE51bVBvaW50cygpfHwwPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uKSYmISh0aGlzLl9zZWdtZW50RnJhY3Rpb248MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPjEpKX1ub3JtYWxpemUoKXt0aGlzLl9zZWdtZW50RnJhY3Rpb248MCYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSx0aGlzLl9zZWdtZW50RnJhY3Rpb24+MSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKSx0aGlzLl9jb21wb25lbnRJbmRleDwwJiYodGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksdGhpcy5fc2VnbWVudEluZGV4PDAmJih0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksMT09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbiYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wLHRoaXMuX3NlZ21lbnRJbmRleCs9MSl9dG9Mb3dlc3QodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj10bC5udW1TZWdtZW50cyhlKTtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4PG4/dGhpczpuZXcgdGwodGhpcy5fY29tcG9uZW50SW5kZXgsbi0xLDEsITEpfWdldENvb3JkaW5hdGUodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCk7aWYodGhpcy5fc2VnbWVudEluZGV4Pj10bC5udW1TZWdtZW50cyhlKSlyZXR1cm4gbjtjb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KzEpO3JldHVybiB0bC5wb2ludEFsb25nU2VnbWVudEJ5RnJhY3Rpb24obixzLHRoaXMuX3NlZ21lbnRGcmFjdGlvbil9Z2V0U2VnbWVudEZyYWN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRGcmFjdGlvbn1nZXRTZWdtZW50KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgpO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49dGwubnVtU2VnbWVudHMoZSkpe2NvbnN0IHQ9ZS5nZXRDb29yZGluYXRlTihlLmdldE51bVBvaW50cygpLTIpO3JldHVybiBuZXcgS3QodCxuKX1jb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KzEpO3JldHVybiBuZXcgS3QobixzKX1jbGFtcCh0KXtpZih0aGlzLl9jb21wb25lbnRJbmRleD49dC5nZXROdW1HZW9tZXRyaWVzKCkpcmV0dXJuIHRoaXMuc2V0VG9FbmQodCksbnVsbDtpZih0aGlzLl9zZWdtZW50SW5kZXg+PXQuZ2V0TnVtUG9pbnRzKCkpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3RoaXMuX3NlZ21lbnRJbmRleD10bC5udW1TZWdtZW50cyhlKSx0aGlzLl9zZWdtZW50RnJhY3Rpb249MX19c2V0VG9FbmQodCl7dGhpcy5fY29tcG9uZW50SW5kZXg9dC5nZXROdW1HZW9tZXRyaWVzKCktMTtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTt0aGlzLl9zZWdtZW50SW5kZXg9dGwubnVtU2VnbWVudHMoZSksdGhpcy5fc2VnbWVudEZyYWN0aW9uPTB9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg8ZS5fY29tcG9uZW50SW5kZXg/LTE6dGhpcy5fY29tcG9uZW50SW5kZXg+ZS5fY29tcG9uZW50SW5kZXg/MTp0aGlzLl9zZWdtZW50SW5kZXg8ZS5fc2VnbWVudEluZGV4Py0xOnRoaXMuX3NlZ21lbnRJbmRleD5lLl9zZWdtZW50SW5kZXg/MTp0aGlzLl9zZWdtZW50RnJhY3Rpb248ZS5fc2VnbWVudEZyYWN0aW9uPy0xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbj5lLl9zZWdtZW50RnJhY3Rpb24/MTowfWNvcHkoKXtyZXR1cm4gbmV3IHRsKHRoaXMuX2NvbXBvbmVudEluZGV4LHRoaXMuX3NlZ21lbnRJbmRleCx0aGlzLl9zZWdtZW50RnJhY3Rpb24pfXRvU3RyaW5nKCl7cmV0dXJuXCJMaW5lYXJMb2NbXCIrdGhpcy5fY29tcG9uZW50SW5kZXgrXCIsIFwiK3RoaXMuX3NlZ21lbnRJbmRleCtcIiwgXCIrdGhpcy5fc2VnbWVudEZyYWN0aW9uK1wiXVwifWlzT25TYW1lU2VnbWVudCh0KXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg9PT10Ll9jb21wb25lbnRJbmRleCYmKHRoaXMuX3NlZ21lbnRJbmRleD09PXQuX3NlZ21lbnRJbmRleHx8KHQuX3NlZ21lbnRJbmRleC10aGlzLl9zZWdtZW50SW5kZXg9PTEmJjA9PT10Ll9zZWdtZW50RnJhY3Rpb258fHRoaXMuX3NlZ21lbnRJbmRleC10Ll9zZWdtZW50SW5kZXg9PTEmJjA9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24pKX1zbmFwVG9WZXJ0ZXgodCxlKXtpZih0aGlzLl9zZWdtZW50RnJhY3Rpb248PTB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MSlyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuZ2V0U2VnbWVudExlbmd0aCh0KSxzPXRoaXMuX3NlZ21lbnRGcmFjdGlvbipuLGk9bi1zO3M8PWkmJnM8ZT90aGlzLl9zZWdtZW50RnJhY3Rpb249MDppPD1zJiZpPGUmJih0aGlzLl9zZWdtZW50RnJhY3Rpb249MSl9Y29tcGFyZUxvY2F0aW9uVmFsdWVzKHQsZSxuKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXg8dD8tMTp0aGlzLl9jb21wb25lbnRJbmRleD50PzE6dGhpcy5fc2VnbWVudEluZGV4PGU/LTE6dGhpcy5fc2VnbWVudEluZGV4PmU/MTp0aGlzLl9zZWdtZW50RnJhY3Rpb248bj8tMTp0aGlzLl9zZWdtZW50RnJhY3Rpb24+bj8xOjB9Z2V0U2VnbWVudExlbmd0aCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KTtsZXQgbj10aGlzLl9zZWdtZW50SW5kZXg7dGhpcy5fc2VnbWVudEluZGV4Pj10bC5udW1TZWdtZW50cyhlKSYmKG49ZS5nZXROdW1Qb2ludHMoKS0yKTtjb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4obiksaT1lLmdldENvb3JkaW5hdGVOKG4rMSk7cmV0dXJuIHMuZGlzdGFuY2UoaSl9aXNWZXJ0ZXgoKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9uPD0wfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBlbHtjb25zdHJ1Y3Rvcigpe2VsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9c3RhdGljIGluZGV4T2YodCxlKXtyZXR1cm4gbmV3IGVsKHQpLmluZGV4T2YoZSl9c3RhdGljIGluZGV4T2ZBZnRlcih0LGUsbil7cmV0dXJuIG5ldyBlbCh0KS5pbmRleE9mQWZ0ZXIoZSxuKX1pbmRleE9mKHQpe3JldHVybiB0aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxudWxsKX1pbmRleE9mRnJvbVN0YXJ0KHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz0wLGk9MCxvPS0xO2NvbnN0IGw9bmV3IEt0O2ZvcihsZXQgcj1uZXcgSm8odGhpcy5fbGluZWFyR2VvbSk7ci5oYXNOZXh0KCk7ci5uZXh0KCkpaWYoIXIuaXNFbmRPZkxpbmUoKSl7bC5wMD1yLmdldFNlZ21lbnRTdGFydCgpLGwucDE9ci5nZXRTZWdtZW50RW5kKCk7Y29uc3QgYT1sLmRpc3RhbmNlKHQpLGM9bC5zZWdtZW50RnJhY3Rpb24odCksaD1yLmdldENvbXBvbmVudEluZGV4KCksdT1yLmdldFZlcnRleEluZGV4KCk7YTxuJiYobnVsbD09PWV8fGUuY29tcGFyZUxvY2F0aW9uVmFsdWVzKGgsdSxjKTwwKSYmKHM9aCxpPXUsbz1jLG49YSl9aWYobj09PXIuTUFYX1ZBTFVFKXJldHVybiBuZXcgdGwoZSk7cmV0dXJuIG5ldyB0bChzLGksbyl9aW5kZXhPZkFmdGVyKHQsZSl7aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuaW5kZXhPZih0KTtjb25zdCBuPXRsLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pO2lmKG4uY29tcGFyZVRvKGUpPD0wKXJldHVybiBuO2NvbnN0IHM9dGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsZSk7cmV0dXJuIGcuaXNUcnVlKHMuY29tcGFyZVRvKGUpPj0wLFwiY29tcHV0ZWQgbG9jYXRpb24gaXMgYmVmb3JlIHNwZWNpZmllZCBtaW5pbXVtIGxvY2F0aW9uXCIpLHN9fWNsYXNzIG5se2NvbnN0cnVjdG9yKCl7bmwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgaW5kaWNlc09mKHQsZSl7cmV0dXJuIG5ldyBubCh0KS5pbmRpY2VzT2YoZSl9aW5kaWNlc09mKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4oMCkuZ2V0Q29vcmRpbmF0ZU4oMCksbj10LmdldEdlb21ldHJ5Tih0LmdldE51bUdlb21ldHJpZXMoKS0xKSxzPW4uZ2V0Q29vcmRpbmF0ZU4obi5nZXROdW1Qb2ludHMoKS0xKSxpPW5ldyBlbCh0aGlzLl9saW5lYXJHZW9tKSxyPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiByWzBdPWkuaW5kZXhPZihlKSwwPT09dC5nZXRMZW5ndGgoKT9yWzFdPXJbMF0uY29weSgpOnJbMV09aS5pbmRleE9mQWZ0ZXIocyxyWzBdKSxyfX1jbGFzcyBzbHtjb25zdHJ1Y3Rvcigpe3NsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9c3RhdGljIGdldExlbmd0aCh0LGUpe3JldHVybiBuZXcgc2wodCkuZ2V0TGVuZ3RoKGUpfXN0YXRpYyBnZXRMb2NhdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHNsKGFyZ3VtZW50c1swXSkuZ2V0TG9jYXRpb24odCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO3JldHVybiBuZXcgc2woYXJndW1lbnRzWzBdKS5nZXRMb2NhdGlvbih0LGUpfX1nZXRMZW5ndGgodCl7bGV0IGU9MDtjb25zdCBuPW5ldyBKbyh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO24uaGFzTmV4dCgpOyl7aWYoIW4uaXNFbmRPZkxpbmUoKSl7Y29uc3Qgcz1uLmdldFNlZ21lbnRTdGFydCgpLGk9bi5nZXRTZWdtZW50RW5kKCkuZGlzdGFuY2Uocyk7aWYodC5nZXRDb21wb25lbnRJbmRleCgpPT09bi5nZXRDb21wb25lbnRJbmRleCgpJiZ0LmdldFNlZ21lbnRJbmRleCgpPT09bi5nZXRWZXJ0ZXhJbmRleCgpKXJldHVybiBlK2kqdC5nZXRTZWdtZW50RnJhY3Rpb24oKTtlKz1pfW4ubmV4dCgpfXJldHVybiBlfXJlc29sdmVIaWdoZXIodCl7aWYoIXQuaXNFbmRwb2ludCh0aGlzLl9saW5lYXJHZW9tKSlyZXR1cm4gdDtsZXQgZT10LmdldENvbXBvbmVudEluZGV4KCk7aWYoZT49dGhpcy5fbGluZWFyR2VvbS5nZXROdW1HZW9tZXRyaWVzKCktMSlyZXR1cm4gdDtkb3tlKyt9d2hpbGUoZTx0aGlzLl9saW5lYXJHZW9tLmdldE51bUdlb21ldHJpZXMoKS0xJiYwPT09dGhpcy5fbGluZWFyR2VvbS5nZXRHZW9tZXRyeU4oZSkuZ2V0TGVuZ3RoKCkpO3JldHVybiBuZXcgdGwoZSwwLDApfWdldExvY2F0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdldExvY2F0aW9uKHQsITApfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj10O2lmKHQ8MCl7bj10aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpK3R9Y29uc3Qgcz10aGlzLmdldExvY2F0aW9uRm9yd2FyZChuKTtyZXR1cm4gZT9zOnRoaXMucmVzb2x2ZUhpZ2hlcihzKX19Z2V0TG9jYXRpb25Gb3J3YXJkKHQpe2lmKHQ8PTApcmV0dXJuIG5ldyB0bDtsZXQgZT0wO2NvbnN0IG49bmV3IEpvKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bi5oYXNOZXh0KCk7KXtpZihuLmlzRW5kT2ZMaW5lKCkpe2lmKGU9PT10KXtjb25zdCB0PW4uZ2V0Q29tcG9uZW50SW5kZXgoKSxlPW4uZ2V0VmVydGV4SW5kZXgoKTtyZXR1cm4gbmV3IHRsKHQsZSwwKX19ZWxzZXtjb25zdCBzPW4uZ2V0U2VnbWVudFN0YXJ0KCksaT1uLmdldFNlZ21lbnRFbmQoKS5kaXN0YW5jZShzKTtpZihlK2k+dCl7Y29uc3Qgcz0odC1lKS9pLHI9bi5nZXRDb21wb25lbnRJbmRleCgpLG89bi5nZXRWZXJ0ZXhJbmRleCgpO3JldHVybiBuZXcgdGwocixvLHMpfWUrPWl9bi5uZXh0KCl9cmV0dXJuIHRsLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pfX1jbGFzcyBpbHtjb25zdHJ1Y3Rvcigpe2lsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fbGluZXM9bmV3IEwsdGhpcy5fY29vcmRMaXN0PW51bGwsdGhpcy5faWdub3JlSW52YWxpZExpbmVzPSExLHRoaXMuX2ZpeEludmFsaWRMaW5lcz0hMSx0aGlzLl9sYXN0UHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdD10fWdldEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuZW5kTGluZSgpLHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpfWdldExhc3RDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2xhc3RQdH1lbmRMaW5lKCl7aWYobnVsbD09PXRoaXMuX2Nvb3JkTGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXMmJnRoaXMuX2Nvb3JkTGlzdC5zaXplKCk8MilyZXR1cm4gdGhpcy5fY29vcmRMaXN0PW51bGwsbnVsbDtjb25zdCB0PXRoaXMuX2Nvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBlPXQ7dGhpcy5fZml4SW52YWxpZExpbmVzJiYoZT10aGlzLnZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpKSx0aGlzLl9jb29yZExpc3Q9bnVsbDtsZXQgbj1udWxsO3RyeXtuPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgcykpdGhyb3cgdDtpZighdGhpcy5faWdub3JlSW52YWxpZExpbmVzKXRocm93IHR9bnVsbCE9PW4mJnRoaXMuX2xpbmVzLmFkZChuKX1zZXRGaXhJbnZhbGlkTGluZXModCl7dGhpcy5fZml4SW52YWxpZExpbmVzPXR9YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLl9jb29yZExpc3QmJih0aGlzLl9jb29yZExpc3Q9bmV3IFIpLHRoaXMuX2Nvb3JkTGlzdC5hZGQodCxlKSx0aGlzLl9sYXN0UHQ9dH19c2V0SWdub3JlSW52YWxpZExpbmVzKHQpe3RoaXMuX2lnbm9yZUludmFsaWRMaW5lcz10fXZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpe2lmKHQubGVuZ3RoPj0yKXJldHVybiB0O3JldHVyblt0WzBdLHRbMF1dfX1jbGFzcyBybHtjb25zdHJ1Y3Rvcigpe3JsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9c3RhdGljIGV4dHJhY3QodCxlLG4pe3JldHVybiBuZXcgcmwodCkuZXh0cmFjdChlLG4pfWNvbXB1dGVMaW5lYXIodCxlKXtjb25zdCBuPW5ldyBpbCh0aGlzLl9saW5lLmdldEZhY3RvcnkoKSk7bi5zZXRGaXhJbnZhbGlkTGluZXMoITApLHQuaXNWZXJ0ZXgoKXx8bi5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtmb3IobGV0IHM9bmV3IEpvKHRoaXMuX2xpbmUsdCk7cy5oYXNOZXh0KCkmJiEoZS5jb21wYXJlTG9jYXRpb25WYWx1ZXMocy5nZXRDb21wb25lbnRJbmRleCgpLHMuZ2V0VmVydGV4SW5kZXgoKSwwKTwwKTtzLm5leHQoKSl7Y29uc3QgdD1zLmdldFNlZ21lbnRTdGFydCgpO24uYWRkKHQpLHMuaXNFbmRPZkxpbmUoKSYmbi5lbmRMaW5lKCl9cmV0dXJuIGUuaXNWZXJ0ZXgoKXx8bi5hZGQoZS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKSxuLmdldEdlb21ldHJ5KCl9Y29tcHV0ZUxpbmUodCxlKXtjb25zdCBuPXRoaXMuX2xpbmUuZ2V0Q29vcmRpbmF0ZXMoKSxzPW5ldyBSO2xldCBpPXQuZ2V0U2VnbWVudEluZGV4KCk7dC5nZXRTZWdtZW50RnJhY3Rpb24oKT4wJiYoaSs9MSk7bGV0IHI9ZS5nZXRTZWdtZW50SW5kZXgoKTsxPT09ZS5nZXRTZWdtZW50RnJhY3Rpb24oKSYmKHIrPTEpLHI+PW4ubGVuZ3RoJiYocj1uLmxlbmd0aC0xKSx0LmlzVmVydGV4KCl8fHMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7Zm9yKGxldCB0PWk7dDw9cjt0Kyspcy5hZGQoblt0XSk7ZS5pc1ZlcnRleCgpfHxzLmFkZChlLmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpLHMuc2l6ZSgpPD0wJiZzLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2xldCBvPXMudG9Db29yZGluYXRlQXJyYXkoKTtyZXR1cm4gby5sZW5ndGg8PTEmJihvPVtvWzBdLG9bMF1dKSx0aGlzLl9saW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKG8pfWV4dHJhY3QodCxlKXtyZXR1cm4gZS5jb21wYXJlVG8odCk8MD90aGlzLnJldmVyc2UodGhpcy5jb21wdXRlTGluZWFyKGUsdCkpOnRoaXMuY29tcHV0ZUxpbmVhcih0LGUpfXJldmVyc2UodCl7cmV0dXJuIEkodCxXKT90LnJldmVyc2UoKTooZy5zaG91bGROZXZlclJlYWNoSGVyZShcIm5vbi1saW5lYXIgZ2VvbWV0cnkgZW5jb3VudGVyZWRcIiksbnVsbCl9fWNsYXNzIGxse2NvbnN0cnVjdG9yKCl7bGwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dGhpcy5wb3NpdGl2ZUluZGV4KHQpLG49dGhpcy5nZXRTdGFydEluZGV4KCk7aWYoZTxuKXJldHVybiBuO2NvbnN0IHM9dGhpcy5nZXRFbmRJbmRleCgpO3JldHVybiBlPnM/czplfWxvY2F0aW9uT2YoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHNsLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBzbC5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQsZSl9fXByb2plY3QodCl7cmV0dXJuICRvLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1wb3NpdGl2ZUluZGV4KHQpe3JldHVybiB0Pj0wP3Q6dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKSt0fWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc2wuZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmVhckdlb20pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXNsLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCkudG9Mb3dlc3QodGhpcy5fbGluZWFyR2VvbSk7cmV0dXJuIG4uZ2V0U2VnbWVudCh0aGlzLl9saW5lYXJHZW9tKS5wb2ludEFsb25nT2Zmc2V0KG4uZ2V0U2VnbWVudEZyYWN0aW9uKCksZSl9fWlzVmFsaWRJbmRleCh0KXtyZXR1cm4gdD49dGhpcy5nZXRTdGFydEluZGV4KCkmJnQ8PXRoaXMuZ2V0RW5kSW5kZXgoKX1nZXRFbmRJbmRleCgpe3JldHVybiB0aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gMH1pbmRleE9mQWZ0ZXIodCxlKXtyZXR1cm4gJG8uaW5kZXhPZkFmdGVyKHRoaXMuX2xpbmVhckdlb20sdCxlKX1leHRyYWN0TGluZSh0LGUpe2NvbnN0IG49dGhpcy5jbGFtcEluZGV4KHQpLHM9dGhpcy5jbGFtcEluZGV4KGUpLGk9bj09PXMscj10aGlzLmxvY2F0aW9uT2YobixpKSxvPXRoaXMubG9jYXRpb25PZihzKTtyZXR1cm4gcmwuZXh0cmFjdCh0aGlzLl9saW5lYXJHZW9tLHIsbyl9aW5kZXhPZih0KXtyZXR1cm4gJG8uaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWluZGljZXNPZih0KXtjb25zdCBlPW5sLmluZGljZXNPZih0aGlzLl9saW5lYXJHZW9tLHQpO3JldHVybltzbC5nZXRMZW5ndGgodGhpcy5fbGluZWFyR2VvbSxlWzBdKSxzbC5nZXRMZW5ndGgodGhpcy5fbGluZWFyR2VvbSxlWzFdKV19fWNsYXNzIGFse2NvbnN0cnVjdG9yKCl7YWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dCx0aGlzLmNoZWNrR2VvbWV0cnlUeXBlKCl9Y2xhbXBJbmRleCh0KXtjb25zdCBlPXQuY29weSgpO3JldHVybiBlLmNsYW1wKHRoaXMuX2xpbmVhckdlb20pLGV9cHJvamVjdCh0KXtyZXR1cm4gZWwuaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWNoZWNrR2VvbWV0cnlUeXBlKCl7aWYoISh0aGlzLl9saW5lYXJHZW9tIGluc3RhbmNlb2YgSnx8dGhpcy5fbGluZWFyR2VvbSBpbnN0YW5jZW9mIHd0KSl0aHJvdyBuZXcgcyhcIklucHV0IGdlb21ldHJ5IG11c3QgYmUgbGluZWFyXCIpfWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gYXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGUodGhpcy5fbGluZWFyR2VvbSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLnRvTG93ZXN0KHRoaXMuX2xpbmVhckdlb20pO3JldHVybiBlLmdldFNlZ21lbnQodGhpcy5fbGluZWFyR2VvbSkucG9pbnRBbG9uZ09mZnNldChlLmdldFNlZ21lbnRGcmFjdGlvbigpLHQpfX1pc1ZhbGlkSW5kZXgodCl7cmV0dXJuIHQuaXNWYWxpZCh0aGlzLl9saW5lYXJHZW9tKX1nZXRFbmRJbmRleCgpe3JldHVybiB0bC5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKX1nZXRTdGFydEluZGV4KCl7cmV0dXJuIG5ldyB0bH1pbmRleE9mQWZ0ZXIodCxlKXtyZXR1cm4gZWwuaW5kZXhPZkFmdGVyKHRoaXMuX2xpbmVhckdlb20sdCxlKX1leHRyYWN0TGluZSh0LGUpe3JldHVybiBybC5leHRyYWN0KHRoaXMuX2xpbmVhckdlb20sdCxlKX1pbmRleE9mKHQpe3JldHVybiBlbC5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9aW5kaWNlc09mKHQpe3JldHVybiBubC5pbmRpY2VzT2YodGhpcy5fbGluZWFyR2VvbSx0KX19dmFyIGNsPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExlbmd0aEluZGV4ZWRMaW5lOmxsLExlbmd0aExvY2F0aW9uTWFwOnNsLExpbmVhckdlb21ldHJ5QnVpbGRlcjppbCxMaW5lYXJJdGVyYXRvcjpKbyxMaW5lYXJMb2NhdGlvbjp0bCxMb2NhdGlvbkluZGV4ZWRMaW5lOmFsfSk7Y2xhc3MgaGx7c3RhdGljIHRyYW5zZm9ybSh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspbi5hZGQoZS5leGVjdXRlKHMubmV4dCgpKSk7cmV0dXJuIG59c3RhdGljIHNlbGVjdCh0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7Qm9vbGVhbi5UUlVFLmVxdWFscyhlLmV4ZWN1dGUodCkpJiZuLmFkZCh0KX1yZXR1cm4gbn1zdGF0aWMgYXBwbHkodCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmV4ZWN1dGUobi5uZXh0KCkpfX1obC5GdW5jdGlvbj1mdW5jdGlvbigpe307Y2xhc3MgdWx7Y29uc3RydWN0b3IoKXt1bC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnB0cz1udWxsLHRoaXMubj0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpfWZpbHRlcih0KXt0aGlzLnB0c1t0aGlzLm4rK109dH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLnB0c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVV19fWNsYXNzIGdse2NvbnN0cnVjdG9yKCl7Z2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbj0wfWZpbHRlcih0KXt0aGlzLl9uKyt9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVV19fWNsYXNzIGRse2NvbnN0cnVjdG9yKCl7ZGwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY291bnRzPW5ldyBJdH1jb3VudCh0KXtjb25zdCBlPXRoaXMuX2NvdW50cy5nZXQodCk7cmV0dXJuIG51bGw9PT1lPzA6ZS5jb3VudCgpfWFkZCh0KXtjb25zdCBlPXRoaXMuX2NvdW50cy5nZXQodCk7bnVsbD09PWU/dGhpcy5fY291bnRzLnB1dCh0LG5ldyBfbCgxKSk6ZS5pbmNyZW1lbnQoKX19Y2xhc3MgX2x7Y29uc3RydWN0b3IoKXtfbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLmNvdW50PTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY291bnQ9dH19Y291bnQoKXtyZXR1cm4gdGhpcy5jb3VudH1pbmNyZW1lbnQoKXt0aGlzLmNvdW50Kyt9fWZ1bmN0aW9uIHBsKCl7fWZ1bmN0aW9uIG1sKCl7fWZ1bmN0aW9uIGZsKCl7fWRsLkNvdW50ZXI9X2w7Y2xhc3MgeWwgZXh0ZW5kcyBue31mdW5jdGlvbiB4bCgpe31jbGFzcyBFbHtzdGF0aWMgY2hhcnModCxlKXtjb25zdCBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2ZvcihsZXQgcz0wO3M8ZTtzKyspbltzXT10O3JldHVybiBuZXcgU3RyaW5nKG4pfXN0YXRpYyBnZXRTdGFja1RyYWNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IGZsLG49bmV3IHBsKGUpO3JldHVybiB0LnByaW50U3RhY2tUcmFjZShuKSxlLnRvU3RyaW5nKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPVwiXCI7Y29uc3Qgcz1uZXcgeGwobmV3IG1sKEVsLmdldFN0YWNrVHJhY2UodCkpKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXRyeXtuKz1zLnJlYWRMaW5lKCkrRWwuTkVXTElORX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiB5bCkpdGhyb3cgdDtnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG59fXN0YXRpYyBzcGFjZXModCl7cmV0dXJuIEVsLmNoYXJzKFwiIFwiLHQpfXN0YXRpYyBzcGxpdCh0LGUpe2NvbnN0IG49ZS5sZW5ndGgscz1uZXcgTDtsZXQgaT1cIlwiK3Qscj1pLmluZGV4T2YoZSk7Zm9yKDtyPj0wOyl7Y29uc3QgdD1pLnN1YnN0cmluZygwLHIpO3MuYWRkKHQpLGk9aS5zdWJzdHJpbmcocituKSxyPWkuaW5kZXhPZihlKX1pLmxlbmd0aD4wJiZzLmFkZChpKTtjb25zdCBvPW5ldyBBcnJheShzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKylvW3RdPXMuZ2V0KHQpO3JldHVybiBvfX1FbC5ORVdMSU5FPUIuZ2V0UHJvcGVydHkoXCJsaW5lLnNlcGFyYXRvclwiKTt2YXIgSWw9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29sbGVjdGlvblV0aWw6aGwsQ29vcmRpbmF0ZUFycmF5RmlsdGVyOnVsLENvb3JkaW5hdGVDb3VudEZpbHRlcjpnbCxHZW9tZXRyaWNTaGFwZUZhY3Rvcnk6U2UsTnVtYmVyVXRpbDplLE9iamVjdENvdW50ZXI6ZGwsUHJpb3JpdHlRdWV1ZTpDcyxTdHJpbmdVdGlsOkVsLFVuaXF1ZUNvb3JkaW5hdGVBcnJheUZpbHRlcjpubn0pO2NsYXNzIE5se2dldCBpbnRlcmZhY2VzXygpe3JldHVybltdfWdldENsYXNzKCl7cmV0dXJuIE5sfXN0YXRpYyB1bmlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBOci5jcmVhdGVFbXB0eVJlc3VsdChOci5VTklPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9cmV0dXJuIHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxFci5vdmVybGF5T3AodCxlLE5yLlVOSU9OKX19Si5wcm90b3R5cGUuZ2V0Qm91bmRhcnk9ZnVuY3Rpb24oKXtyZXR1cm4gc2kuZ2V0Qm91bmRhcnkodGhpcyl9LHd0LnByb3RvdHlwZS5nZXRCb3VuZGFyeT1mdW5jdGlvbigpe3JldHVybiBzaS5nZXRCb3VuZGFyeSh0aGlzKX0sWC5wcm90b3R5cGUuZXF1YWxzVG9wbz1mdW5jdGlvbih0KXtyZXR1cm4gS3IuZXF1YWxzVG9wbyh0aGlzLHQpfSxYLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiZLci5lcXVhbHNUb3BvKHRoaXMsdCl9LFgucHJvdG90eXBlLnVuaW9uPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5vLnVuaW9uKHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTmwudW5pb24odGhpcyx0KX19LFgucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gRnIuaXNWYWxpZCh0aGlzKX0sWC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBOci5pbnRlcnNlY3Rpb24odGhpcyx0KX0sWC5wcm90b3R5cGUuY292ZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBLci5jb3ZlcnModGhpcyx0KX0sWC5wcm90b3R5cGUuY292ZXJlZEJ5PWZ1bmN0aW9uKHQpe3JldHVybiBLci5jb3ZlcnModCx0aGlzKX0sWC5wcm90b3R5cGUudG91Y2hlcz1mdW5jdGlvbih0KXtyZXR1cm4gS3IudG91Y2hlcyh0aGlzLHQpfSxYLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKHQpe3JldHVybiBLci5pbnRlcnNlY3RzKHRoaXMsdCl9LFgucHJvdG90eXBlLndpdGhpbj1mdW5jdGlvbih0KXtyZXR1cm4gS3IuY29udGFpbnModCx0aGlzKX0sWC5wcm90b3R5cGUub3ZlcmxhcHM9ZnVuY3Rpb24odCl7cmV0dXJuIEtyLm92ZXJsYXBzKHRoaXMsdCl9LFgucHJvdG90eXBlLmRpc2pvaW50PWZ1bmN0aW9uKHQpe3JldHVybiBLci5kaXNqb2ludCh0aGlzLHQpfSxYLnByb3RvdHlwZS5jcm9zc2VzPWZ1bmN0aW9uKHQpe3JldHVybiBLci5jcm9zc2VzKHRoaXMsdCl9LFgucHJvdG90eXBlLmJ1ZmZlcj1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gR2kuYnVmZmVyT3AodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIEdpLmJ1ZmZlck9wKHRoaXMsdCxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIEdpLmJ1ZmZlck9wKHRoaXMsdCxlLG4pfX0sWC5wcm90b3R5cGUuY29udmV4SHVsbD1mdW5jdGlvbigpe3JldHVybiBuZXcgc24odGhpcykuZ2V0Q29udmV4SHVsbCgpfSxYLnByb3RvdHlwZS5yZWxhdGU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEtyLnJlbGF0ZSh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gS3IucmVsYXRlKHRoaXMsdCkubWF0Y2hlcyhlKX19LFgucHJvdG90eXBlLmdldENlbnRyb2lkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQoKTtjb25zdCB0PSRlLmdldENlbnRyb2lkKHRoaXMpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCx0aGlzKX0sWC5wcm90b3R5cGUuZ2V0SW50ZXJpb3JQb2ludD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KCk7bGV0IHQ9bnVsbDtjb25zdCBlPXRoaXMuZ2V0RGltZW5zaW9uKCk7dD0wPT09ZT9uZXcgdW4odGhpcyk6MT09PWU/bmV3IGhuKHRoaXMpOm5ldyBvbih0aGlzKTtjb25zdCBuPXQuZ2V0SW50ZXJpb3JQb2ludCgpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQobix0aGlzKX0sWC5wcm90b3R5cGUuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gTnIuc3ltRGlmZmVyZW5jZSh0aGlzLHQpfSxYLnByb3RvdHlwZS5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX0sWC5wcm90b3R5cGUudG9UZXh0PWZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBXdCkud3JpdGUodGhpcyl9LFgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dGhpcy50b1RleHQoKX0sWC5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7cmV0dXJuIEtyLmNvbnRhaW5zKHRoaXMsdCl9LFgucHJvdG90eXBlLmRpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIE5yLmRpZmZlcmVuY2UodGhpcyx0KX0sWC5wcm90b3R5cGUuaXNTaW1wbGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHJpKHRoaXMpLmlzU2ltcGxlKCl9LFgucHJvdG90eXBlLmlzV2l0aGluRGlzdGFuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT5lKSYmVmkuaXNXaXRoaW5EaXN0YW5jZSh0aGlzLHQsZSl9LFgucHJvdG90eXBlLmRpc3RhbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBWaS5kaXN0YW5jZSh0aGlzLHQpfTt0LmFsZ29yaXRobT1Fbix0LmRlbnNpZnk9U24sdC5kaXNzb2x2ZT12bix0Lmdlb209VGUsdC5nZW9tZ3JhcGg9YXMsdC5pbmRleD1Ecyx0LmlvPVlzLHQubGluZWFycmVmPWNsLHQubm9kaW5nPW5pLHQub3BlcmF0aW9uPXJvLHQucHJlY2lzaW9uPWFvLHQuc2ltcGxpZnk9TG8sdC50cmlhbmd1bGF0ZT1Rbyx0LnV0aWw9SWwsdC52ZXJzaW9uPVwiMi42LjAgKGRkYWU4NjYpXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc3RzLm1pbi5qcy5tYXAiLCIhZnVuY3Rpb24odCxpKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1pKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShpKToodD10fHxzZWxmKS5SQnVzaD1pKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQscixlLGEsaCl7IWZ1bmN0aW9uIHQobixyLGUsYSxoKXtmb3IoO2E+ZTspe2lmKGEtZT42MDApe3ZhciBvPWEtZSsxLHM9ci1lKzEsbD1NYXRoLmxvZyhvKSxmPS41Kk1hdGguZXhwKDIqbC8zKSx1PS41Kk1hdGguc3FydChsKmYqKG8tZikvbykqKHMtby8yPDA/LTE6MSksbT1NYXRoLm1heChlLE1hdGguZmxvb3Ioci1zKmYvbyt1KSksYz1NYXRoLm1pbihhLE1hdGguZmxvb3Iocisoby1zKSpmL28rdSkpO3QobixyLG0sYyxoKX12YXIgcD1uW3JdLGQ9ZSx4PWE7Zm9yKGkobixlLHIpLGgoblthXSxwKT4wJiZpKG4sZSxhKTtkPHg7KXtmb3IoaShuLGQseCksZCsrLHgtLTtoKG5bZF0scCk8MDspZCsrO2Zvcig7aChuW3hdLHApPjA7KXgtLX0wPT09aChuW2VdLHApP2kobixlLHgpOmkobiwrK3gsYSkseDw9ciYmKGU9eCsxKSxyPD14JiYoYT14LTEpfX0odCxyLGV8fDAsYXx8dC5sZW5ndGgtMSxofHxuKX1mdW5jdGlvbiBpKHQsaSxuKXt2YXIgcj10W2ldO3RbaV09dFtuXSx0W25dPXJ9ZnVuY3Rpb24gbih0LGkpe3JldHVybiB0PGk/LTE6dD5pPzE6MH12YXIgcj1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD05KSx0aGlzLl9tYXhFbnRyaWVzPU1hdGgubWF4KDQsdCksdGhpcy5fbWluRW50cmllcz1NYXRoLm1heCgyLE1hdGguY2VpbCguNCp0aGlzLl9tYXhFbnRyaWVzKSksdGhpcy5jbGVhcigpfTtmdW5jdGlvbiBlKHQsaSxuKXtpZighbilyZXR1cm4gaS5pbmRleE9mKHQpO2Zvcih2YXIgcj0wO3I8aS5sZW5ndGg7cisrKWlmKG4odCxpW3JdKSlyZXR1cm4gcjtyZXR1cm4tMX1mdW5jdGlvbiBhKHQsaSl7aCh0LDAsdC5jaGlsZHJlbi5sZW5ndGgsaSx0KX1mdW5jdGlvbiBoKHQsaSxuLHIsZSl7ZXx8KGU9cChudWxsKSksZS5taW5YPTEvMCxlLm1pblk9MS8wLGUubWF4WD0tMS8wLGUubWF4WT0tMS8wO2Zvcih2YXIgYT1pO2E8bjthKyspe3ZhciBoPXQuY2hpbGRyZW5bYV07byhlLHQubGVhZj9yKGgpOmgpfXJldHVybiBlfWZ1bmN0aW9uIG8odCxpKXtyZXR1cm4gdC5taW5YPU1hdGgubWluKHQubWluWCxpLm1pblgpLHQubWluWT1NYXRoLm1pbih0Lm1pblksaS5taW5ZKSx0Lm1heFg9TWF0aC5tYXgodC5tYXhYLGkubWF4WCksdC5tYXhZPU1hdGgubWF4KHQubWF4WSxpLm1heFkpLHR9ZnVuY3Rpb24gcyh0LGkpe3JldHVybiB0Lm1pblgtaS5taW5YfWZ1bmN0aW9uIGwodCxpKXtyZXR1cm4gdC5taW5ZLWkubWluWX1mdW5jdGlvbiBmKHQpe3JldHVybih0Lm1heFgtdC5taW5YKSoodC5tYXhZLXQubWluWSl9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gdC5tYXhYLXQubWluWCsodC5tYXhZLXQubWluWSl9ZnVuY3Rpb24gbSh0LGkpe3JldHVybiB0Lm1pblg8PWkubWluWCYmdC5taW5ZPD1pLm1pblkmJmkubWF4WDw9dC5tYXhYJiZpLm1heFk8PXQubWF4WX1mdW5jdGlvbiBjKHQsaSl7cmV0dXJuIGkubWluWDw9dC5tYXhYJiZpLm1pblk8PXQubWF4WSYmaS5tYXhYPj10Lm1pblgmJmkubWF4WT49dC5taW5ZfWZ1bmN0aW9uIHAodCl7cmV0dXJue2NoaWxkcmVuOnQsaGVpZ2h0OjEsbGVhZjohMCxtaW5YOjEvMCxtaW5ZOjEvMCxtYXhYOi0xLzAsbWF4WTotMS8wfX1mdW5jdGlvbiBkKGksbixyLGUsYSl7Zm9yKHZhciBoPVtuLHJdO2gubGVuZ3RoOylpZighKChyPWgucG9wKCkpLShuPWgucG9wKCkpPD1lKSl7dmFyIG89bitNYXRoLmNlaWwoKHItbikvZS8yKSplO3QoaSxvLG4scixhKSxoLnB1c2gobixvLG8scil9fXJldHVybiByLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSxbXSl9LHIucHJvdG90eXBlLnNlYXJjaD1mdW5jdGlvbih0KXt2YXIgaT10aGlzLmRhdGEsbj1bXTtpZighYyh0LGkpKXJldHVybiBuO2Zvcih2YXIgcj10aGlzLnRvQkJveCxlPVtdO2k7KXtmb3IodmFyIGE9MDthPGkuY2hpbGRyZW4ubGVuZ3RoO2ErKyl7dmFyIGg9aS5jaGlsZHJlblthXSxvPWkubGVhZj9yKGgpOmg7Yyh0LG8pJiYoaS5sZWFmP24ucHVzaChoKTptKHQsbyk/dGhpcy5fYWxsKGgsbik6ZS5wdXNoKGgpKX1pPWUucG9wKCl9cmV0dXJuIG59LHIucHJvdG90eXBlLmNvbGxpZGVzPWZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZGF0YTtpZighYyh0LGkpKXJldHVybiExO2Zvcih2YXIgbj1bXTtpOyl7Zm9yKHZhciByPTA7cjxpLmNoaWxkcmVuLmxlbmd0aDtyKyspe3ZhciBlPWkuY2hpbGRyZW5bcl0sYT1pLmxlYWY/dGhpcy50b0JCb3goZSk6ZTtpZihjKHQsYSkpe2lmKGkubGVhZnx8bSh0LGEpKXJldHVybiEwO24ucHVzaChlKX19aT1uLnBvcCgpfXJldHVybiExfSxyLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKHQpe2lmKCF0fHwhdC5sZW5ndGgpcmV0dXJuIHRoaXM7aWYodC5sZW5ndGg8dGhpcy5fbWluRW50cmllcyl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspdGhpcy5pbnNlcnQodFtpXSk7cmV0dXJuIHRoaXN9dmFyIG49dGhpcy5fYnVpbGQodC5zbGljZSgpLDAsdC5sZW5ndGgtMSwwKTtpZih0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKWlmKHRoaXMuZGF0YS5oZWlnaHQ9PT1uLmhlaWdodCl0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLG4pO2Vsc2V7aWYodGhpcy5kYXRhLmhlaWdodDxuLmhlaWdodCl7dmFyIHI9dGhpcy5kYXRhO3RoaXMuZGF0YT1uLG49cn10aGlzLl9pbnNlcnQobix0aGlzLmRhdGEuaGVpZ2h0LW4uaGVpZ2h0LTEsITApfWVsc2UgdGhpcy5kYXRhPW47cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLmluc2VydD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5faW5zZXJ0KHQsdGhpcy5kYXRhLmhlaWdodC0xKSx0aGlzfSxyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGE9cChbXSksdGhpc30sci5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQsaSl7aWYoIXQpcmV0dXJuIHRoaXM7Zm9yKHZhciBuLHIsYSxoPXRoaXMuZGF0YSxvPXRoaXMudG9CQm94KHQpLHM9W10sbD1bXTtofHxzLmxlbmd0aDspe2lmKGh8fChoPXMucG9wKCkscj1zW3MubGVuZ3RoLTFdLG49bC5wb3AoKSxhPSEwKSxoLmxlYWYpe3ZhciBmPWUodCxoLmNoaWxkcmVuLGkpO2lmKC0xIT09ZilyZXR1cm4gaC5jaGlsZHJlbi5zcGxpY2UoZiwxKSxzLnB1c2goaCksdGhpcy5fY29uZGVuc2UocyksdGhpc31hfHxoLmxlYWZ8fCFtKGgsbyk/cj8obisrLGg9ci5jaGlsZHJlbltuXSxhPSExKTpoPW51bGw6KHMucHVzaChoKSxsLnB1c2gobiksbj0wLHI9aCxoPWguY2hpbGRyZW5bMF0pfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS50b0JCb3g9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHIucHJvdG90eXBlLmNvbXBhcmVNaW5YPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQubWluWC1pLm1pblh9LHIucHJvdG90eXBlLmNvbXBhcmVNaW5ZPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQubWluWS1pLm1pbll9LHIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LHIucHJvdG90eXBlLmZyb21KU09OPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGE9dCx0aGlzfSxyLnByb3RvdHlwZS5fYWxsPWZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBuPVtdO3Q7KXQubGVhZj9pLnB1c2guYXBwbHkoaSx0LmNoaWxkcmVuKTpuLnB1c2guYXBwbHkobix0LmNoaWxkcmVuKSx0PW4ucG9wKCk7cmV0dXJuIGl9LHIucHJvdG90eXBlLl9idWlsZD1mdW5jdGlvbih0LGksbixyKXt2YXIgZSxoPW4taSsxLG89dGhpcy5fbWF4RW50cmllcztpZihoPD1vKXJldHVybiBhKGU9cCh0LnNsaWNlKGksbisxKSksdGhpcy50b0JCb3gpLGU7cnx8KHI9TWF0aC5jZWlsKE1hdGgubG9nKGgpL01hdGgubG9nKG8pKSxvPU1hdGguY2VpbChoL01hdGgucG93KG8sci0xKSkpLChlPXAoW10pKS5sZWFmPSExLGUuaGVpZ2h0PXI7dmFyIHM9TWF0aC5jZWlsKGgvbyksbD1zKk1hdGguY2VpbChNYXRoLnNxcnQobykpO2QodCxpLG4sbCx0aGlzLmNvbXBhcmVNaW5YKTtmb3IodmFyIGY9aTtmPD1uO2YrPWwpe3ZhciB1PU1hdGgubWluKGYrbC0xLG4pO2QodCxmLHUscyx0aGlzLmNvbXBhcmVNaW5ZKTtmb3IodmFyIG09ZjttPD11O20rPXMpe3ZhciBjPU1hdGgubWluKG0rcy0xLHUpO2UuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZCh0LG0sYyxyLTEpKX19cmV0dXJuIGEoZSx0aGlzLnRvQkJveCksZX0sci5wcm90b3R5cGUuX2Nob29zZVN1YnRyZWU9ZnVuY3Rpb24odCxpLG4scil7Zm9yKDtyLnB1c2goaSksIWkubGVhZiYmci5sZW5ndGgtMSE9PW47KXtmb3IodmFyIGU9MS8wLGE9MS8wLGg9dm9pZCAwLG89MDtvPGkuY2hpbGRyZW4ubGVuZ3RoO28rKyl7dmFyIHM9aS5jaGlsZHJlbltvXSxsPWYocyksdT0obT10LGM9cywoTWF0aC5tYXgoYy5tYXhYLG0ubWF4WCktTWF0aC5taW4oYy5taW5YLG0ubWluWCkpKihNYXRoLm1heChjLm1heFksbS5tYXhZKS1NYXRoLm1pbihjLm1pblksbS5taW5ZKSktbCk7dTxhPyhhPXUsZT1sPGU/bDplLGg9cyk6dT09PWEmJmw8ZSYmKGU9bCxoPXMpfWk9aHx8aS5jaGlsZHJlblswXX12YXIgbSxjO3JldHVybiBpfSxyLnByb3RvdHlwZS5faW5zZXJ0PWZ1bmN0aW9uKHQsaSxuKXt2YXIgcj1uP3Q6dGhpcy50b0JCb3godCksZT1bXSxhPXRoaXMuX2Nob29zZVN1YnRyZWUocix0aGlzLmRhdGEsaSxlKTtmb3IoYS5jaGlsZHJlbi5wdXNoKHQpLG8oYSxyKTtpPj0wJiZlW2ldLmNoaWxkcmVuLmxlbmd0aD50aGlzLl9tYXhFbnRyaWVzOyl0aGlzLl9zcGxpdChlLGkpLGktLTt0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMocixlLGkpfSxyLnByb3RvdHlwZS5fc3BsaXQ9ZnVuY3Rpb24odCxpKXt2YXIgbj10W2ldLHI9bi5jaGlsZHJlbi5sZW5ndGgsZT10aGlzLl9taW5FbnRyaWVzO3RoaXMuX2Nob29zZVNwbGl0QXhpcyhuLGUscik7dmFyIGg9dGhpcy5fY2hvb3NlU3BsaXRJbmRleChuLGUsciksbz1wKG4uY2hpbGRyZW4uc3BsaWNlKGgsbi5jaGlsZHJlbi5sZW5ndGgtaCkpO28uaGVpZ2h0PW4uaGVpZ2h0LG8ubGVhZj1uLmxlYWYsYShuLHRoaXMudG9CQm94KSxhKG8sdGhpcy50b0JCb3gpLGk/dFtpLTFdLmNoaWxkcmVuLnB1c2gobyk6dGhpcy5fc3BsaXRSb290KG4sbyl9LHIucHJvdG90eXBlLl9zcGxpdFJvb3Q9ZnVuY3Rpb24odCxpKXt0aGlzLmRhdGE9cChbdCxpXSksdGhpcy5kYXRhLmhlaWdodD10LmhlaWdodCsxLHRoaXMuZGF0YS5sZWFmPSExLGEodGhpcy5kYXRhLHRoaXMudG9CQm94KX0sci5wcm90b3R5cGUuX2Nob29zZVNwbGl0SW5kZXg9ZnVuY3Rpb24odCxpLG4pe2Zvcih2YXIgcixlLGEsbyxzLGwsdSxtPTEvMCxjPTEvMCxwPWk7cDw9bi1pO3ArKyl7dmFyIGQ9aCh0LDAscCx0aGlzLnRvQkJveCkseD1oKHQscCxuLHRoaXMudG9CQm94KSx2PShlPWQsYT14LG89dm9pZCAwLHM9dm9pZCAwLGw9dm9pZCAwLHU9dm9pZCAwLG89TWF0aC5tYXgoZS5taW5YLGEubWluWCkscz1NYXRoLm1heChlLm1pblksYS5taW5ZKSxsPU1hdGgubWluKGUubWF4WCxhLm1heFgpLHU9TWF0aC5taW4oZS5tYXhZLGEubWF4WSksTWF0aC5tYXgoMCxsLW8pKk1hdGgubWF4KDAsdS1zKSksTT1mKGQpK2YoeCk7djxtPyhtPXYscj1wLGM9TTxjP006Yyk6dj09PW0mJk08YyYmKGM9TSxyPXApfXJldHVybiByfHxuLWl9LHIucHJvdG90eXBlLl9jaG9vc2VTcGxpdEF4aXM9ZnVuY3Rpb24odCxpLG4pe3ZhciByPXQubGVhZj90aGlzLmNvbXBhcmVNaW5YOnMsZT10LmxlYWY/dGhpcy5jb21wYXJlTWluWTpsO3RoaXMuX2FsbERpc3RNYXJnaW4odCxpLG4scik8dGhpcy5fYWxsRGlzdE1hcmdpbih0LGksbixlKSYmdC5jaGlsZHJlbi5zb3J0KHIpfSxyLnByb3RvdHlwZS5fYWxsRGlzdE1hcmdpbj1mdW5jdGlvbih0LGksbixyKXt0LmNoaWxkcmVuLnNvcnQocik7Zm9yKHZhciBlPXRoaXMudG9CQm94LGE9aCh0LDAsaSxlKSxzPWgodCxuLWksbixlKSxsPXUoYSkrdShzKSxmPWk7ZjxuLWk7ZisrKXt2YXIgbT10LmNoaWxkcmVuW2ZdO28oYSx0LmxlYWY/ZShtKTptKSxsKz11KGEpfWZvcih2YXIgYz1uLWktMTtjPj1pO2MtLSl7dmFyIHA9dC5jaGlsZHJlbltjXTtvKHMsdC5sZWFmP2UocCk6cCksbCs9dShzKX1yZXR1cm4gbH0sci5wcm90b3R5cGUuX2FkanVzdFBhcmVudEJCb3hlcz1mdW5jdGlvbih0LGksbil7Zm9yKHZhciByPW47cj49MDtyLS0pbyhpW3JdLHQpfSxyLnByb3RvdHlwZS5fY29uZGVuc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBpPXQubGVuZ3RoLTEsbj12b2lkIDA7aT49MDtpLS0pMD09PXRbaV0uY2hpbGRyZW4ubGVuZ3RoP2k+MD8obj10W2ktMV0uY2hpbGRyZW4pLnNwbGljZShuLmluZGV4T2YodFtpXSksMSk6dGhpcy5jbGVhcigpOmEodFtpXSx0aGlzLnRvQkJveCl9LHJ9KTtcbiIsIi8vQHRzLWNoZWNrXG5cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEFnZW50UG9pbnQge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBzeD0wLCBzeT0wKSB7XG5cbiAgICAgICAgLy9wb3NpdGlvblxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5XG5cbiAgICAgICAgLy9zcGVlZFxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnN4ID0gc3hcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc3kgPSBzeVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zID0gdW5kZWZpbmVkXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNhID0gdW5kZWZpbmVkXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FnZW50UG9pbnR9IGFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgdG8gYW5vdGhlciBhZ2VudC5cbiAgICAgKi9cbiAgICBkKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZFAoYS54LCBhLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSB0byBhIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGRQKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguaHlwb3QoKHggLSB0aGlzLngpLCAoeSAtIHRoaXMueSkpO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAqIFNldCByYW5kb20gc3BlZWRcbiAgICAqIFxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWRcbiAgICAqL1xuICAgIHNldFJhbmRvbVNwZWVkKG1pblNwZWVkID0gMCwgbWF4U3BlZWQgPSAwLjEpIHtcbiAgICAgICAgdGhpcy5zID0gbWluU3BlZWQgKyBNYXRoLnJhbmRvbSgpICogKG1heFNwZWVkIC0gbWluU3BlZWQpO1xuICAgICAgICB0aGlzLnNhID0gMiAqIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJO1xuICAgICAgICB0aGlzLnN4ID0gdGhpcy5zICogTWF0aC5jb3ModGhpcy5zYSlcbiAgICAgICAgdGhpcy5zeSA9IHRoaXMucyAqIE1hdGguc2luKHRoaXMuc2EpXG4gICAgfVxuXG4gICAgLyoqICovXG4gICAgY29tcHV0ZVNwZWVkKCkge1xuICAgICAgICB0aGlzLnMgPSBNYXRoLmh5cG90KHRoaXMuc3gsIHRoaXMuc3kpO1xuICAgICAgICByZXR1cm4gdGhpcy5zXG4gICAgfVxuXG4gICAgLyoqICovXG4gICAgY29tcHV0ZVNwZWVkQW5nbGUoKSB7XG4gICAgICAgIHRoaXMuc2EgPSBNYXRoLmF0YW4yKHRoaXMuc3ksIHRoaXMuc3gpO1xuICAgICAgICByZXR1cm4gdGhpcy5zYVxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbi8qKiBAdHlwZWRlZiB7IHt4TWluOiBudW1iZXIsIHhNYXg6IG51bWJlciwgeU1pbjogbnVtYmVyLCB5TWF4OiBudW1iZXJ9IH0gRW52ZWxvcGUgKi9cblxuaW1wb3J0IHsgem9vbSBhcyBkM3pvb20sIHpvb21JZGVudGl0eSB9IGZyb20gXCJkMy16b29tXCI7XG5pbXBvcnQgeyBzZWxlY3QgYXMgZDNzZWxlY3QgfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbi8qKlxuICogQSBIVE1MIGNhbnZhcyBmb3IgZ2VvIGRhdGEgZGlzcGxheSwgZW5oYW5jZWQgd2l0aCB6b29tIGFuZCBwYW4gY2FwYWJpbGl0aWVzLlxuICogXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXG4gKi9cbmV4cG9ydCBjbGFzcyBHZW9DYW52YXMge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNlbnRlciBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6ZiBUaGUgem9vbSBmYWN0b3IgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhc0lkID0gXCJ2YWNhbnZhc1wiLCBjZW50ZXIgPSB1bmRlZmluZWQsIHpmID0gMSkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLnc7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaDtcblxuICAgICAgICAvKipAdHlwZSB7b2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAvLyBzZXQgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXJcbiAgICAgICAgdGhpcy5zZXRDZW50ZXIoY2VudGVyIHx8IHsgeDogdGhpcy53ICogMC41LCB5OiB0aGlzLmggKiAwLjUgfSlcblxuICAgICAgICAvLyBzZXQgem9vbSBmYWN0b3I6IHBpeGVsIHNpemUsIGluIG0vcGl4XG4gICAgICAgIHRoaXMuc2V0WmYoemYpO1xuXG4gICAgICAgIC8vZXh0ZW50XG4gICAgICAgIC8qKiBAdHlwZSB7RW52ZWxvcGV9ICovXG4gICAgICAgIHRoaXMuZXh0R2VvID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG5cbiAgICAgICAgLy9yZWx5IG9uIGQzIHpvb20gZm9yIHBhbi96b29tXG4gICAgICAgIGxldCB0UCA9IHpvb21JZGVudGl0eVxuICAgICAgICBkM3NlbGVjdCh0aGlzLmNhbnZhcykuY2FsbChcbiAgICAgICAgICAgIGQzem9vbSgpLm9uKFwiem9vbVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSB0UC5rIC8gdC5rXG4gICAgICAgICAgICAgICAgaWYgKGYgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3BhblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHRQLnggLSB0LnhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSB0UC55IC0gdC55XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFuKGR4ICogdGhpcy5nZXRaZigpLCAtZHkgKiB0aGlzLmdldFpmKCkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2UgPSBlLnNvdXJjZUV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2UgaW5zdGFuY2VvZiBXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3pvb20gYXQgdGhlIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20oZiwgdGhpcy5waXhUb0dlb1goZS5zb3VyY2VFdmVudC5vZmZzZXRYKSwgdGhpcy5waXhUb0dlb1koZS5zb3VyY2VFdmVudC5vZmZzZXRZKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSB0b3VjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHggPSAwLCB0eSA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR0IG9mIHNlLnRhcmdldFRvdWNoZXMpIHsgdHggKz0gdHQuY2xpZW50WDsgdHkgKz0gdHQuY2xpZW50WSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCAvPSBzZS50YXJnZXRUb3VjaGVzLmxlbmd0aDsgdHkgLz0gc2UudGFyZ2V0VG91Y2hlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vem9vbSBhdCB0aGlzIGF2ZXJhZ2UgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbShmLCB0aGlzLnBpeFRvR2VvWCh0eCksIHRoaXMucGl4VG9HZW9ZKHR5KSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0UCA9IHRcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSB2IEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyICovXG4gICAgc2V0Q2VudGVyKHYpIHsgdGhpcy5jZW50ZXIgPSB2OyB9XG4gICAgLyoqIEByZXR1cm5zIHt7eDpudW1iZXIseTpudW1iZXJ9fSBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciAqL1xuICAgIGdldENlbnRlcigpIHsgcmV0dXJuIHRoaXMuY2VudGVyOyB9XG5cbiAgICAvKiogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHpvb20gZmFjdG9yIChwaXhlbCBzaXplLCBpbiBncm91bmQgbSkgKi9cbiAgICBzZXRaZih2KSB7IHRoaXMuemYgPSB2OyB9XG4gICAgLyoqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pICovXG4gICAgZ2V0WmYoKSB7IHJldHVybiB0aGlzLnpmOyB9XG5cblxuXG5cbiAgICAvKiogSW5pdGlhbGlzZSBjYW52YXMgdHJhbnNmb3JtIHdpdGggaWRlbnRpdHkgdHJhbnNmb3JtYXRpb24uICovXG4gICAgaW5pdENhbnZhc1RyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIH1cblxuICAgIC8qKiBJbml0aWFsaXNlIGNhbnZhcyB0cmFuc2Zvcm0gd2l0aCBnZW8gdG8gc2NyZWVuIHRyYW5zZm9ybWF0aW9uLCBzbyB0aGF0IGdlbyBvYmplY3RzIGNhbiBiZSBkcmF3biBkaXJlY3RseSBpbiBnZW8gY29vcmRpbmF0ZXMuICovXG4gICAgc2V0Q2FudmFzVHJhbnNmb3JtKCkge1xuICAgICAgICBjb25zdCBrID0gMSAvIHRoaXMuZ2V0WmYoKTtcbiAgICAgICAgY29uc3QgdHggPSAtdGhpcy5jZW50ZXIueCAvIHRoaXMuZ2V0WmYoKSArIHRoaXMudyAqIDAuNTtcbiAgICAgICAgY29uc3QgdHkgPSB0aGlzLmNlbnRlci55IC8gdGhpcy5nZXRaZigpICsgdGhpcy5oICogMC41O1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oaywgMCwgMCwgLWssIHR4LCB0eSk7XG4gICAgfVxuXG5cbiAgICAvKiogVGhlIGZ1bmN0aW9uIHNwZWNpZnlpbmcgaG93IHRvIGRyYXcgdGhlIG1hcC4gKi9cbiAgICByZWRyYXcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIHJlZHJhdyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGFwcCBzY3JlZW4uIFRvIGJlIHVzZWQgYmVmb3JlIGEgcmVkcmF3IGZvciBleGFtcGxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBcbiAgICAgKi9cbiAgICBjbGVhcihjb2xvciA9IFwid2hpdGVcIikge1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpO1xuICAgIH1cblxuICAgIC8vY29udmVyc2lvbiBmdW5jdGlvbnNcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBHZW8geCBjb29yZGluYXRlLCBpbiBtLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNjcmVlbiB4IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAqL1xuICAgIGdlb1RvUGl4WCh4R2VvKSB7IHJldHVybiAoeEdlbyAtIHRoaXMuY2VudGVyLngpIC8gdGhpcy5nZXRaZigpICsgdGhpcy53ICogMC41OyB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlHZW8gR2VvIHkgY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTY3JlZW4geSBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgKi9cbiAgICBnZW9Ub1BpeFkoeUdlbykgeyByZXR1cm4gLSh5R2VvIC0gdGhpcy5jZW50ZXIueSkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLmggKiAwLjU7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBTY3JlZW4geCBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHggY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAqL1xuICAgIHBpeFRvR2VvWCh4KSB7IHJldHVybiAoeCAtIHRoaXMudyAqIDAuNSkgKiB0aGlzLmdldFpmKCkgKyB0aGlzLmNlbnRlci54OyB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgU2NyZWVuIHkgY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEdlbyB5IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgKi9cbiAgICBwaXhUb0dlb1koeSkgeyByZXR1cm4gLSh5IC0gdGhpcy5oICogMC41KSAqIHRoaXMuZ2V0WmYoKSArIHRoaXMuY2VudGVyLnk7IH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeEdlb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeUdlb1xuICAgICAqL1xuICAgIHBhbihkeEdlbywgZHlHZW8pIHtcbiAgICAgICAgLy9UT0RPIGZvcmNlIGV4dGVuZCB0byByZW1haW5cbiAgICAgICAgdGhpcy5jZW50ZXIueCArPSBkeEdlbztcbiAgICAgICAgdGhpcy5jZW50ZXIueSArPSBkeUdlbztcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRHZW8oKVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb20uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYgVGhlIHpvb20gZmFjdG9yLCB3aXRoaW4gXTAsIEluZmluaXR5XS4gMSBpcyBmb3Igbm8gY2hhbmdlLiA8MSB0byB6b29tLWluLCA+MSB0byB6b29tLW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBUaGUgeCBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUdlbyBUaGUgeSBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cbiAgICAgKi9cbiAgICB6b29tKGYgPSAxLCB4R2VvID0gdGhpcy5jZW50ZXIueCwgeUdlbyA9IHRoaXMuY2VudGVyLnkpIHtcbiAgICAgICAgLy9UT0RPIGZvcmNlIGV4dGVuZCB0byByZW1haW5cbiAgICAgICAgdGhpcy5zZXRaZihmICogdGhpcy5nZXRaZigpKTtcbiAgICAgICAgdGhpcy5jZW50ZXIueCArPSAoeEdlbyAtIHRoaXMuY2VudGVyLngpICogKDEgLSBmKVxuICAgICAgICB0aGlzLmNlbnRlci55ICs9ICh5R2VvIC0gdGhpcy5jZW50ZXIueSkgKiAoMSAtIGYpXG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luUHggXG4gICAgICogQHJldHVybnMge0VudmVsb3BlfSBUaGUgZW52ZWxvcGUgb2YgdGhlIHZpZXcsIGluIGdlbyBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICB1cGRhdGVFeHRlbnRHZW8obWFyZ2luUHggPSAyMCkge1xuICAgICAgICB0aGlzLmV4dEdlbyA9IHtcbiAgICAgICAgICAgIHhNaW46IHRoaXMucGl4VG9HZW9YKC1tYXJnaW5QeCksXG4gICAgICAgICAgICB4TWF4OiB0aGlzLnBpeFRvR2VvWCh0aGlzLncgKyBtYXJnaW5QeCksXG4gICAgICAgICAgICB5TWluOiB0aGlzLnBpeFRvR2VvWSh0aGlzLmggKyBtYXJnaW5QeCksXG4gICAgICAgICAgICB5TWF4OiB0aGlzLnBpeFRvR2VvWSgtbWFyZ2luUHgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0R2VvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgaGFzIHRvIGJlIGRyYXduXG4gICAgICogXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBvYmogXG4gICAgICovXG4gICAgdG9EcmF3KG9iaikge1xuICAgICAgICBpZiAob2JqLnggPCB0aGlzLmV4dEdlby54TWluKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvYmoueCA+IHRoaXMuZXh0R2VvLnhNYXgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9iai55IDwgdGhpcy5leHRHZW8ueU1pbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob2JqLnkgPiB0aGlzLmV4dEdlby55TWF4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuXG4vL3NlZSBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaFxuaW1wb3J0IFJCdXNoIGZyb20gJ3JidXNoJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgY2xhc3MgU3BhdGlhbEluZGV4IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjbGFzcyBNeVJCdXNoIGV4dGVuZHMgUkJ1c2gge1xuICAgICAgICAgICAgLyoqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gb2JqICAqL1xuICAgICAgICAgICAgdG9CQm94KG9iaikgeyByZXR1cm4geyBtaW5YOiBvYmoueCwgbWluWTogb2JqLnksIG1heFg6IG9iai54LCBtYXhZOiBvYmoueSB9OyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYSBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYiBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29tcGFyZU1pblgoYSwgYikgeyByZXR1cm4gYS54IC0gYi54OyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYSBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gYiBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29tcGFyZU1pblkoYSwgYikgeyByZXR1cm4gYS55IC0gYi55OyB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge015UkJ1c2h9ICovXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBNeVJCdXNoKCk7XG4gICAgfVxuXG4gICAgLy9UT0RPIGJ1bGsgcmVtb3ZlID9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4bWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHltaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5bWF4XG4gICAgICogQHJldHVybiB7QXJyYXkuPFQ+fVxuICAgICAqL1xuICAgIGdldCh4bWluLCB5bWluLCB4bWF4LCB5bWF4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuc2VhcmNoKHtcbiAgICAgICAgICAgIG1pblg6IHhtaW4sXG4gICAgICAgICAgICBtaW5ZOiB5bWluLFxuICAgICAgICAgICAgbWF4WDogeG1heCxcbiAgICAgICAgICAgIG1heFk6IHltYXhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUfSBvYmpcbiAgICAgKi9cbiAgICBpbnNlcnQob2JqKSB7XG4gICAgICAgIHRoaXMudHJlZS5pbnNlcnQob2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWxrIGluc2VydFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBvYmpzXG4gICAgICovXG4gICAgbG9hZChvYmpzKSB7XG4gICAgICAgIHRoaXMudHJlZS5sb2FkKG9ianMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VH0gb2JqXG4gICAgICovXG4gICAgcmVtb3ZlKG9iaikge1xuICAgICAgICB0aGlzLnRyZWUucmVtb3ZlKG9iailcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy50cmVlLmNsZWFyKClcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge09iamVjdC48PywgVD59IG9ialxuICogQHJldHVybnMge0FycmF5LjxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG9ialRvQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgIG91dC5wdXNoKG9ialtrZXldKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheS48VD59IGFyclxuICogQHBhcmFtIHtUfSBvYmpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXNnIFxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gZnVuY3Rpb24gKGFyciwgb2JqLCBtc2cgPSB0cnVlKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2Yob2JqKTtcbiAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgZWxzZVxuICAgICAgICBpZiAobXNnKSBjb25zb2xlLmxvZyhcIkltcG9zc2libGUgdG8gcmVtb3ZlIGVsZW1lbnQgbm90IHByZXNlbnQgaW4gYXJyYXkuXCIpO1xufTtcblxuLyoqXG4gKiBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyXG4gKiBAcGFyYW0ge0FycmF5LjxUPn0gb2JqcyBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXNnIFxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRnJvbUFycmF5UyA9IGZ1bmN0aW9uIChhcnIsIG9ianMsIG1zZyA9IHRydWUpIHtcbiAgICBmb3IgKGxldCBvYmogb2Ygb2JqcylcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGFyciwgb2JqLCBtc2cpXG59O1xuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNlYSB9IGZyb20gXCIuL1NlYVwiXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgQWdlbnRQb2ludCB9IGZyb20gXCIuLi9iYXNlL0FnZW50UG9pbnRcIjtcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcblxuLyoqICovXG5leHBvcnQgY2xhc3MgU2FyZGluIGV4dGVuZHMgQWdlbnRQb2ludCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NlYX0gc2VhIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3kgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VhLCB4ID0gc2VhLncgKiBNYXRoLnJhbmRvbSgpLCB5ID0gc2VhLmggKiBNYXRoLnJhbmRvbSgpLCBzeCA9IHVuZGVmaW5lZCwgc3kgPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvL1xuICAgICAgICBzdXBlcih4LCB5LCBzeCwgc3kpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtTZWF9ICovXG4gICAgICAgIHRoaXMuc2VhID0gc2VhO1xuXG4gICAgICAgIC8vcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHggPCAwID8gMCA6IHggPiBzZWEudyA/IHNlYS53IDogeFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geSA8IDAgPyAwIDogeSA+IHNlYS5oID8gc2VhLmggOiB5XG5cbiAgICAgICAgLy9zcGVlZFxuICAgICAgICBpZiAoIXN4ICYmICFzeSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSYW5kb21TcGVlZCgwLCB0aGlzLnNlYS5WX01BWClcblxuICAgICAgICAgICAgLy9hY2NlbGVyYXRpb25cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgdGhpcy5heCA9IDBcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgdGhpcy5heSA9IDBcblxuICAgICAgICAgICAgLy9saXN0IG9mIHNhcmRpbnMgaW4gdmlzaW9uIGZpZWxkXG4gICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICAgICAgdGhpcy5vYnMgPSBbXVxuICAgICAgICAgICAgLy9saXN0IG9mIHNhcmRpbnMgaW4gY29sbGlzaW9uIGZpZWxkXG4gICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICAgICAgdGhpcy5jb2wgPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48U2FyZGluPn0gc2luZGV4IFxuICAgICAqL1xuICAgIG9ic2VydmUoc2luZGV4KSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtTZWF9ICovXG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnNlYVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3QgZE8gPSBzLkRfT0JTXG5cbiAgICAgICAgLy9pbml0aWFsaXNlIGxpc3RzXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMub2JzID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMuY29sID0gW107XG5cbiAgICAgICAgLy9nZXQgc2FyZGlucyBhcm91bmQgdXNpbmcgc3BhdGlhbCBpbmRleFxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICBjb25zdCBzcyA9IHNpbmRleC5nZXQodGhpcy54IC0gZE8sIHRoaXMueSAtIGRPLCB0aGlzLnggKyBkTywgdGhpcy55ICsgZE8pO1xuXG4gICAgICAgIC8vZ2V0IHNhcmRpbnMgaW4gb2JzZXJ2YXRpb24gYW5kIGNvbGxpc2lvbiBmaWVsZHNcbiAgICAgICAgZm9yIChsZXQgZiBvZiBzcykge1xuICAgICAgICAgICAgaWYgKGYgPT0gdGhpcykgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5kKGYpIDw9IHMuRF9DT0wpXG4gICAgICAgICAgICAgICAgdGhpcy5jb2wucHVzaChmKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmQoZikgPD0gZE8pIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGFuZ2xlXG4gICAgICAgICAgICAgICAgbGV0IGRhID0gTWF0aC5hdGFuMihmLnkgLSB0aGlzLnksIGYueCAtIHRoaXMueCkgLSB0aGlzLnNhO1xuICAgICAgICAgICAgICAgIGlmIChkYSA+IE1hdGguUEkpIGRhIC09IDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhIDw9IC1NYXRoLlBJKSBkYSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgICAgICAgICBkYSA9IE1hdGguYWJzKGRhKTtcbiAgICAgICAgICAgICAgICBpZiAoZGEgPiBzLkFfT0JTICogMC41KSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9icy5wdXNoKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9pbml0aWFsaXNlIGFjY2VsZXJhdGlvblxuICAgICAgICB0aGlzLmF4ID0gMDsgdGhpcy5heSA9IDA7XG5cbiAgICAgICAgLy9jb2xsaXNpb246IHJlcHVsc2lvblxuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuY29sKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5kKGYpO1xuICAgICAgICAgICAgY29uc3QgYSA9IDEuMCAqICgxIC8gKGQgKiBkKSAtIDEgLyAocy5EX0NPTCAqIHMuRF9DT0wpKTtcbiAgICAgICAgICAgIHRoaXMuYXggKz0gYSAqICh0aGlzLnggLSBmLngpIC8gZDtcbiAgICAgICAgICAgIHRoaXMuYXkgKz0gYSAqICh0aGlzLnkgLSBmLnkpIC8gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvd2FyZCB0YXJnZXQgc3BlZWRcbiAgICAgICAgY29uc3QgZHYgPSAocy5WX1RBUkdFVCAtIHRoaXMucykgKiAwLjAxO1xuICAgICAgICB0aGlzLmF4ICs9IGR2ICogdGhpcy5zeCAvIHRoaXMucztcbiAgICAgICAgdGhpcy5heSArPSBkdiAqIHRoaXMuc3kgLyB0aGlzLnM7XG5cbiAgICAgICAgLy90b3dhcmQgdGhlIG9ic2VydmVkIG1lYW4gcG9zaXRpb25cbiAgICAgICAgLyppZihvYnMuc2l6ZSgpPjEpe1xuICAgICAgICAgICAgZG91YmxlIHhuPTAseW49MDtcbiAgICAgICAgICAgIGZvcihTYXJkaW4gczpvYnMpe1xuICAgICAgICAgICAgICAgIHhuKz1zLng7XG4gICAgICAgICAgICAgICAgeW4rPXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhuPXhuL29icy5zaXplKCk7XG4gICAgICAgICAgICB5bj15bi9vYnMuc2l6ZSgpO1xuICAgICAgICAgICAgZG91YmxlIGQ9TWF0aC5oeXBvdCh4bi14LHluLXkpO1xuICAgICAgICAgICAgYXgrPS0wLjEqKHgteG4pL2Q7XG4gICAgICAgICAgICBheSs9LTAuMSooeS15bikvZDtcbiAgICAgICAgfSovXG5cbiAgICAgICAgLy90b3dhcmQgdGhlIG9ic2VydmVkIHNwZWVkXG4gICAgICAgIGNvbnN0IHQgPSAwLjk7XG4gICAgICAgIGlmICh0aGlzLm9icy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgZHN4ID0gMCwgZHN5ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5vYnMpIHtcbiAgICAgICAgICAgICAgICBkc3ggKz0gcy5zeDtcbiAgICAgICAgICAgICAgICBkc3kgKz0gcy5zeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzeCA9ICh0IC0gMSkgKiB0aGlzLnN4ICsgKDEgLSB0KSAqIGRzeCAvIHRoaXMub2JzLmxlbmd0aDtcbiAgICAgICAgICAgIGRzeSA9ICh0IC0gMSkgKiB0aGlzLnN5ICsgKDEgLSB0KSAqIGRzeSAvIHRoaXMub2JzLmxlbmd0aDtcblxuICAgICAgICAgICAgY29uc3QgYSA9IDAuMTtcbiAgICAgICAgICAgIHRoaXMuYXggKz0gYSAqIGRzeDtcbiAgICAgICAgICAgIHRoaXMuYXkgKz0gYSAqIGRzeTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYXZvaWQgc2hhcmtcbiAgICAgICAgY29uc3Qgc2ggPSBzLnNoYXJrO1xuICAgICAgICBpZiAoc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IE1hdGguaHlwb3QoKHNoLnggLSB0aGlzLngpLCAoc2gueSAtIHRoaXMueSkpO1xuICAgICAgICAgICAgaWYgKGQgPD0gcy5EX09CUykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSA1LjAgKiAoMSAvIChkICogZCkgLSAxIC8gKGRPICogZE8pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF4ICs9IGEgKiAodGhpcy54IC0gc2gueCkgLyBkO1xuICAgICAgICAgICAgICAgIHRoaXMuYXkgKz0gYSAqICh0aGlzLnkgLSBzaC55KSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgbW92ZSh0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHNwZWVkXG4gICAgICAgIHRoaXMuc3ggKz0gdGhpcy5heCAqIHRpbWVTdGVwTXMgKyAoMSAtIDIgKiBNYXRoLnJhbmRvbSgpKSAqIDAuMDI7XG4gICAgICAgIHRoaXMuc3kgKz0gdGhpcy5heSAqIHRpbWVTdGVwTXMgKyAoMSAtIDIgKiBNYXRoLnJhbmRvbSgpKSAqIDAuMDI7XG4gICAgICAgIHRoaXMucyA9IHRoaXMuY29tcHV0ZVNwZWVkKClcbiAgICAgICAgaWYgKHRoaXMucyA+IHRoaXMuc2VhLlZfTUFYKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLnNlYS5WX01BWDtcbiAgICAgICAgICAgIHRoaXMuc3ggPSB0aGlzLnNlYS5WX01BWCAqIE1hdGguY29zKHRoaXMuc2EpO1xuICAgICAgICAgICAgdGhpcy5zeSA9IHRoaXMuc2VhLlZfTUFYICogTWF0aC5zaW4odGhpcy5zYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHBvc2l0aW9uXG4gICAgICAgIHRoaXMueCArPSB0aGlzLnN4ICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuc3kgKiB0aW1lU3RlcE1zO1xuXG4gICAgICAgIC8vbGltaXRcbiAgICAgICAgaWYgKHRoaXMueCA8IDApIHRoaXMueCA9IHRoaXMuc2VhLnc7XG4gICAgICAgIGlmICh0aGlzLnkgPCAwKSB0aGlzLnkgPSB0aGlzLnNlYS5oO1xuICAgICAgICBpZiAodGhpcy54ID4gdGhpcy5zZWEudykgdGhpcy54ID0gMDtcbiAgICAgICAgaWYgKHRoaXMueSA+IHRoaXMuc2VhLmgpIHRoaXMueSA9IDA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGEgc2FyZGluIGJvZHlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5KGNwLCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgY29uc3QgYyA9IE1hdGguZmxvb3IoMjU1ICogTWF0aC5hYnModGhpcy5zYSkgLyBNYXRoLlBJKTtcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcInJnYigyNTUsIDI1NSwgXCIgKyBjICsgXCIpXCJcbiAgICAgICAgY29uc3QgYSA9IGxlbmd0aCAvIHRoaXMucztcbiAgICAgICAgY29uc3QgZHggPSBhICogdGhpcy5zeCAqIDAuNTtcbiAgICAgICAgY29uc3QgZHkgPSBhICogdGhpcy5zeSAqIDAuNTtcblxuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIubW92ZVRvKHRoaXMueCAtIGR4LCB0aGlzLnkgLSBkeSk7XG4gICAgICAgIGMyLmxpbmVUbyh0aGlzLnggKyBkeCwgdGhpcy55ICsgZHkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBzYXJkaW4gdmlzaW9uIGZpZWxkXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5VmlzaW9uRmllbGQoY3AsIGZpbGxTdHlsZSwgbGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5tb3ZlVG8odGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuc2VhLkRfT0JTIC8gY3AuZ2V0WmYoKSxcbiAgICAgICAgICAgIHRoaXMuc2EgLSB0aGlzLnNlYS5BX09CUyAqIDAuNSxcbiAgICAgICAgICAgIHRoaXMuc2EgKyB0aGlzLnNlYS5BX09CUyAqIDAuNVxuICAgICAgICApO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuZmlsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgc2FyZGluIHZpc2lvbiBsaW5rc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5VmlzaW9uTGlua3MoY3AsIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBmb3IgKGxldCBzYTIgb2YgdGhpcy5vYnMpIHtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIubW92ZVRvKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGMyLmxpbmVUbyhzYTIueCwgc2EyLnkpO1xuICAgICAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgc2FyZGluIGNvbGxpc2lvbiBmaWVsZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5Q29sbGlzaW9uRmllbGQoY3AsIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIuYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnNlYS5EX0NPTCAqIDAuNSAvIGNwLmdldFpmKCksIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLnN0cm9rZSgpO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNhcmRpbiB9IGZyb20gJy4vU2FyZGluJztcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcbmltcG9ydCB7IHJlbW92ZUZyb21BcnJheSB9IGZyb20gJy4uL2Jhc2UvbGliJztcblxuLyoqICovXG5leHBvcnQgY2xhc3MgU2VhIHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoIFxuICAgICAqLyAgICAgICAgLy9nZXQgMTAgcmFuZG9tIGxvY2F0aW9uc1xuXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8vVE9ETyBzaG91bGQgYmVjb21lIHN0YXRpYyBhdHRyaWJ1dGVzIG9mIFNhcmRpbiBjbGFzc1xuXG4gICAgICAgIC8vb2JzZXJ2YXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuRF9PQlMgPSA1MFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5BX09CUyA9IDIwMCAqIE1hdGguUEkgLyAxODBcblxuICAgICAgICAvL2NvbGxpc2lvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5EX0NPTCA9IDEwXG5cbiAgICAgICAgLy9zcGVlZFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5WX1RBUkdFVCA9IDAuM1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5WX01BWCA9IDAuNlxuXG4gICAgICAgIC8vc2hhcmtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuRF9TSEFSS19FQVQgPSAxMlxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5FQVRFTl9TQVJESU5fTkIgPSAwXG5cblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5maXNoID0gW11cblxuICAgICAgICAvL1RPRE9cbiAgICAgICAgdGhpcy5zaGFyayA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5raWxsZWQgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBzdGVwKHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vaW5pXG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5maXNoKSB7XG4gICAgICAgICAgICBmLmNvbXB1dGVTcGVlZCgpXG4gICAgICAgICAgICBmLmNvbXB1dGVTcGVlZEFuZ2xlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbWFrZSBzcGF0aWFsIGluZGV4XG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxTYXJkaW4+fSAqL1xuICAgICAgICBjb25zdCBzaW5kZXggPSBuZXcgU3BhdGlhbEluZGV4KCk7XG4gICAgICAgIHNpbmRleC5sb2FkKHRoaXMuZmlzaClcblxuICAgICAgICAvL29ic2VydmVcbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmZpc2gpXG4gICAgICAgICAgICBmLm9ic2VydmUoc2luZGV4KTtcblxuICAgICAgICAvL3NoYXJrIGVhdCBmaXNoXG4gICAgICAgIHRoaXMuc2hhcmtFYXQoc2luZGV4KTtcblxuICAgICAgICAvL2Rpc3Bvc2Ugc3BhdGlhbCBpbmRleFxuICAgICAgICAvL3NpbmRleC5jbGVhcigpXG5cbiAgICAgICAgLy9tb3ZlXG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5maXNoKVxuICAgICAgICAgICAgZi5tb3ZlKHRpbWVTdGVwTXMpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPFNhcmRpbj59IHNpbmRleCBcbiAgICAgKi9cbiAgICBzaGFya0VhdChzaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hhcmsgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIHRoaXMua2lsbGVkID0gW107XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuc2hhcmsueCwgeSA9IHRoaXMuc2hhcmsueTtcbiAgICAgICAgY29uc3Qgc3MgPSBzaW5kZXguZ2V0KHggLSB0aGlzLkRfU0hBUktfRUFULCB5IC0gdGhpcy5EX1NIQVJLX0VBVCwgeCArIHRoaXMuRF9TSEFSS19FQVQsIHkgKyB0aGlzLkRfU0hBUktfRUFUKTtcbiAgICAgICAgZm9yIChsZXQgcyBvZiBzcykge1xuICAgICAgICAgICAgY29uc3QgZCA9IE1hdGguaHlwb3QoKHggLSBzLngpLCAoeSAtIHMueSkpO1xuICAgICAgICAgICAgaWYgKGQgPiB0aGlzLkRfU0hBUktfRUFUKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMua2lsbGVkLnB1c2gocyk7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5maXNoLCBzKVxuICAgICAgICAgICAgLy9zaW5kZXgucmVtb3ZlKHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRUFURU5fU0FSRElOX05CICs9IHRoaXMua2lsbGVkLmxlbmd0aDtcbiAgICAgICAgLy9lYXRlbkZpc2hOYi5zZXRUZXh0KFwiRWF0ZW4gZmlzaDogXCIgKyBFQVRFTl9TQVJESU5fTkIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZmlzaFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBhZGRGaXNoKG5iID0gMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspXG4gICAgICAgICAgICB0aGlzLmZpc2gucHVzaChuZXcgU2FyZGluKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcmFuZG9tIHNwZWVkIGZvciBhbGwgZmlzaFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFJhbmRvbVNwZWVkKCkge1xuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuZmlzaClcbiAgICAgICAgICAgIGYuc2V0UmFuZG9tU3BlZWQoKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNlYSB9IGZyb20gJy4vU2VhJztcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4uL2Jhc2UvR2VvQ2FudmFzJztcblxuY2xhc3MgRmlzaFNpbXVsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy9UT0RPXG4gICAgICAgIC8vYWRkIGVhdGVuIGZpc2ggbmIgbGFiZWxcblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dGaXNoVmlzaW9uRmllbGQgPSBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd0Zpc2hWaXNpb25MaW5rcyA9IGZhbHNlXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zaG93RmlzaENvbGxpc2lvbkZpZWxkID0gZmFsc2VcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuICAgICAgICAgICAgY29uc3QgcyA9IHRoLnNlYVxuXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL2NsZWFyXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJnYmEoMTIwLDEyMCwyNTUsMC42KVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9zaG93IHZpc2lvbiBmaWVsZFxuICAgICAgICAgICAgaWYgKHRoLnNob3dGaXNoVmlzaW9uRmllbGQpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5maXNoKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoc2EpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2EuZGlzcGxheVZpc2lvbkZpZWxkKHRoaXMsIFwicmdiYSgyMDAsMjAwLDIwMCwwLjE1KVwiLCAxKVxuICAgICAgICAgICAgLy9zaG93IHZpc2lvbiBsaW5rc1xuICAgICAgICAgICAgaWYgKHRoLnNob3dGaXNoVmlzaW9uTGlua3MpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5maXNoKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoc2EpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2EuZGlzcGxheVZpc2lvbkxpbmtzKHRoaXMsIFwicmdiYSgyNTUsMTAwLDEwMCwwLjMpXCIsIDEpXG4gICAgICAgICAgICAvL3Nob3cgY29sbGlzaW9uIGZpZWxkXG4gICAgICAgICAgICBpZiAodGguc2hvd0Zpc2hDb2xsaXNpb25GaWVsZClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzYS5kaXNwbGF5Q29sbGlzaW9uRmllbGQodGhpcywgXCJwdXJwbGVcIiwgMSlcblxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgc2FyZGluc1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMlxuICAgICAgICAgICAgY29uc3Qgc2FyZGluTGVuZ3RoID0gN1xuICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5maXNoKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgIHNhLmRpc3BsYXkodGhpcywgc2FyZGluTGVuZ3RoKVxuXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBzaGFya1xuICAgICAgICAgICAgaWYgKHMuc2hhcmsgIT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgYzIubGluZVdpZHRoID0gNFxuICAgICAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJibGFja1wiXG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGFya0xlbmd0aCA9IDEyXG4gICAgICAgICAgICAgICAgY29uc3QgZHggPSBzaGFya0xlbmd0aCAqIE1hdGguY29zKHMuc2hhcmsuYW5nbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gc2hhcmtMZW5ndGggKiBNYXRoLnNpbihzLnNoYXJrLmFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLm1vdmVUbyhzLnNoYXJrLngsIHMuc2hhcmsueSk7XG4gICAgICAgICAgICAgICAgYzIubGluZVRvKHMuc2hhcmsueCAtIGR4LCBzLnNoYXJrLnkgKyBkeSk7XG4gICAgICAgICAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBibG9vZCBzcG90XG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMVxuICAgICAgICAgICAgZm9yIChsZXQgc2Egb2Ygcy5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5tb3ZlVG8oc2EueCwgc2EueSk7XG4gICAgICAgICAgICAgICAgYzIuYXJjKHNhLngsIHNhLnksIDQsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5maWxsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZnJhbWVcbiAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJkYXJrZ3JheVwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMSAqIHRoLmNwbHVzLmdldFpmKCk7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLnJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jcGx1cy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoLnNlYS5zaGFyayA9IHsgeDogdGguY3BsdXMucGl4VG9HZW9YKGUub2Zmc2V0WCksIHk6IHRoLmNwbHVzLnBpeFRvR2VvWShlLm9mZnNldFkpLCBhbmdsZTogMCB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNwbHVzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgeEcgPSB0aC5jcGx1cy5waXhUb0dlb1goZS5vZmZzZXRYKTtcbiAgICAgICAgICAgIGNvbnN0IHlHID0gdGguY3BsdXMucGl4VG9HZW9ZKGUub2Zmc2V0WSk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoLXlHICsgdGguc2VhLnNoYXJrLnksIHhHIC0gdGguc2VhLnNoYXJrLngpO1xuICAgICAgICAgICAgdGguc2VhLnNoYXJrID0geyB4OiB4RywgeTogeUcsIGFuZ2xlOiBhbmdsZSB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNwbHVzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZSA9PiB7XG4gICAgICAgICAgICB0aC5zZWEuc2hhcmsgPSBudWxsO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7U2VhfSAqL1xuICAgICAgICB0aGlzLnNlYSA9IG5ldyBTZWEodGhpcy53LCB0aGlzLmgpXG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZW5zaXR5IFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGluaXRSYW5kb20oZGVuc2l0eSA9IDAuMDAxKSB7XG4gICAgICAgIHRoaXMuc2VhLmFkZEZpc2goZGVuc2l0eSAqIHRoaXMuc2VhLncgKiB0aGlzLnNlYS5oKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmJJdGVyYXRpb25zIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0YXJ0KHRpbWVTdGVwTXMgPSAxMCwgbmJJdGVyYXRpb25zID0gLTEpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCB0ID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdC5zZWEuc3RlcCh0aW1lU3RlcE1zKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAqL1xuZXhwb3J0IGNvbnN0IGZpc2ggPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgRmlzaFNpbXVsYXRpb24ob3B0cylcbn1cbiIsIi8vQHRzLWNoZWNrXG5cbi8qKlxuICogXG4gKi9cbmV4cG9ydCBjbGFzcyBDZWxsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBuYj0wKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm5iID0gbmJcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBvYmpUb0FycmF5IH0gZnJvbSAnLi4vYmFzZS9saWInO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbCc7XG5cbi8qKlxuICogXG4gKi9cbmV4cG9ydCBjbGFzcyBVbml2ZXJzZSB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsQ2VsbD59ICovXG4gICAgICAgIHRoaXMucG9wdWxhdGlvbkkgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge0NlbGx8bnVsbH1cbiAgICAgKi9cbiAgICBhZGQoeCwgeSkge1xuXG4gICAgICAgIC8vZmluZCBjZWxsIGF0IGxvY2F0aW9uXG4gICAgICAgIC8qKkB0eXBlIHtzdHJpbmd9Ki9cbiAgICAgICAgY29uc3QgaWQgPSB4ICsgXCJfXCIgKyB5O1xuICAgICAgICBpZiAodGhpcy5wb3B1bGF0aW9uSVtpZF0pIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vY3JlYXRlIG5ldyBjZWxsXG4gICAgICAgIC8qKkB0eXBlIHtDZWxsfSAqL1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGwoeCwgeSwgMClcbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uLnB1c2goY2VsbClcbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uSVtpZF0gPSBjZWxsXG4gICAgICAgIHJldHVybiBjZWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RlcCgpIHtcblxuICAgICAgICAvL1RPRE8gZG91YmxlIGluZGV4aW5nPyBieSByYXcgYW5kIHRoZW4gY29sdW1uID9cbiAgICAgICAgLy9wb3B1bGF0ZSBjZWxsIHN1cnJvdW5kaW5nc1xuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBDZWxsPn1cbiAgICAgICAgICogQGRpY3QgKi9cbiAgICAgICAgY29uc3Qgc3VySSA9IHt9O1xuICAgICAgICAvL2dvIHRocm91Z2ggbGlzdCBvZiBjZWxsc1xuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHRoaXMucG9wdWxhdGlvbikge1xuICAgICAgICAgICAgLy8gKzEgc3Vycm91bmRpbmcgY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IHNycyA9IFVuaXZlcnNlLmdldENlbGxTdXJyb3VuZGluZyhjZWxsLCB0aGlzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHN1ciBvZiBzcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBzdXIueCArIFwiX1wiICsgc3VyLnk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VyXyA9IHN1cklba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc3VyXykge1xuICAgICAgICAgICAgICAgICAgICBzdXJfLm5iKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VyLm5iID0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3VySVtrZXldID0gc3VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vQjMvUzIzXG4gICAgICAgIC8va2lsbCBjZWxsc1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cbiAgICAgICAgY29uc3QgY2VsbHNUb0tlZXAgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQ2VsbD59XG4gICAgICAgICAqIEBkaWN0ICovXG4gICAgICAgIGNvbnN0IGNlbGxzVG9LZWVwSSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHRoaXMucG9wdWxhdGlvbikge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY2VsbC54ICsgXCJfXCIgKyBjZWxsLnk7XG4gICAgICAgICAgICBjb25zdCBjZWxsXyA9IHN1cklba2V5XTtcbiAgICAgICAgICAgIGlmICghY2VsbF8pIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy9pZiAobmI8MiBvciBuYj4zKSAtPiBraWxsXG4gICAgICAgICAgICBpZiAoY2VsbF8ubmIgPCAyIHx8IGNlbGxfLm5iID4gMykgY29udGludWU7XG4gICAgICAgICAgICBjZWxsc1RvS2VlcC5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgY2VsbHNUb0tlZXBJW2tleV0gPSBjZWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wdWxhdGlvbiA9IGNlbGxzVG9LZWVwO1xuICAgICAgICB0aGlzLnBvcHVsYXRpb25JID0gY2VsbHNUb0tlZXBJO1xuXG4gICAgICAgIC8vY3JlYXRlIG5ldyBjZWxsc1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cbiAgICAgICAgY29uc3Qgc3VycyA9IG9ialRvQXJyYXkoc3VySSk7XG4gICAgICAgIGZvciAobGV0IHN1ciBvZiBzdXJzKSB7XG5cbiAgICAgICAgICAgIGlmIChzdXIubmIgIT09IDMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL2NoZWNrIGlmIGFscmVhZHkgYWxpdmVcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHN1ci54ICsgXCJfXCIgKyBzdXIueTtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wb3B1bGF0aW9uSVtrZXldO1xuICAgICAgICAgICAgaWYgKGNlbGwpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL2NyZWF0ZSBuZXcgY2VsbFxuICAgICAgICAgICAgdGhpcy5wb3B1bGF0aW9uLnB1c2goc3VyKTtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGlvbklba2V5XSA9IHN1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TVNcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3BsdXNcbiAgICAgKiBAcmV0dXJuIHtVbml2ZXJzZX1cbiAgICAgKi9cbiAgICBzdGFydChuYiwgdGltZW91dE1TLCBjcGx1cykge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHVuaSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaSk7XG4gICAgICAgICAgICB1bmkuc3RlcCgpO1xuICAgICAgICAgICAgY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmIgPiAwICYmIGkrKyA+IG5iKSByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgdGltZW91dE1TKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW5naW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2VsbH0gY2VsbFxuICAgICAqIEBwYXJhbSB7VW5pdmVyc2V9IHVuaVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxDZWxsPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2VsbFN1cnJvdW5kaW5nKGNlbGwsIHVuaSkge1xuICAgICAgICBjb25zdCB4MSA9IGNlbGwueCA9PT0gMCA/IHVuaS53IC0gMSA6IGNlbGwueCAtIDE7XG4gICAgICAgIGNvbnN0IHgyID0gY2VsbC54ID09PSB1bmkudyAtIDEgPyAwIDogY2VsbC54ICsgMTtcbiAgICAgICAgY29uc3QgeTEgPSBjZWxsLnkgPT09IDAgPyB1bmkuaCAtIDEgOiBjZWxsLnkgLSAxO1xuICAgICAgICBjb25zdCB5MiA9IGNlbGwueSA9PT0gdW5pLmggLSAxID8gMCA6IGNlbGwueSArIDE7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MSwgeTEpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDEsIGNlbGwueSksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MSwgeTIpLFxuICAgICAgICAgICAgbmV3IENlbGwoY2VsbC54LCB5MSksXG4gICAgICAgICAgICBuZXcgQ2VsbChjZWxsLngsIHkyKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgyLCB5MSksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MiwgY2VsbC55KSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgyLCB5MiksXG4gICAgICAgIF07XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuaW1wb3J0IHsgVW5pdmVyc2UgfSBmcm9tICcuL1VuaXZlcnNlJztcbmltcG9ydCB7IENlbGwgfSBmcm9tICcuL0NlbGwnO1xuXG4vL1RPRE8gem9vbS9wYW4sIHdpdGggY2FudmFzIHRyYW5zZm9ybTogYmV0dGVyIHVuaXZlcnNlIGxpbWl0c1xuLy9UT0RPIGJ1dHRvbnMgKHBsYXksIHN0b3AsIHNwZWVkLCBkcmF3LCBwYW4pXG4vL1RPRE8gY2hlY2sgY2FudmFzIGFuaW1hdGlvblxuXG5cbmNsYXNzIEdvTFNpbXVsYXRpb24ge1xuXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtHZW9DYW52YXN9ICovXG4gICAgICAgIHRoaXMuY3BsdXMgPSBuZXcgR2VvQ2FudmFzKCk7XG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgLy9jbGVhclxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuXG4gICAgICAgICAgICAvL2RyYXcgY2VsbHNcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwiYmx1ZVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgY2VsbCBvZiB0aC51bmkucG9wdWxhdGlvbilcbiAgICAgICAgICAgICAgICBjMi5maWxsUmVjdCgoY2VsbC54KSwgKGNlbGwueSksIDEsIDEpO1xuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bmkgPSBuZXcgVW5pdmVyc2UodGhpcy53LCB0aGlzLmgpO1xuICAgIH1cblxuXG4gICAgLy9cbiAgICBpbml0UmFuZG9tKGRlbnNpdHkgPSAwLjA1KSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGNvbnN0IG5iID0gdGhpcy51bmkudyAqIHRoaXMudW5pLmggKiBkZW5zaXR5O1xuICAgICAgICB3aGlsZSAoaSA8IG5iKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh0aGlzLnVuaS53ICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh0aGlzLnVuaS5oICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICAvKiogQHR5cGUge0NlbGx9ICovXG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy51bmkuYWRkKHgsIHkpO1xuICAgICAgICAgICAgaWYgKGNlbGwpIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8vXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudW5pLnN0YXJ0KC0xLCAwLCB0aGlzLmNwbHVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cblxuZXhwb3J0IGNvbnN0IGdhbWVPZkxpZmUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgR29MU2ltdWxhdGlvbihvcHRzKVxufVxuIiwiLy9AdHMtY2hlY2tcblxuZXhwb3J0ICogZnJvbSBcIi4vcGxhbmV0cy9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi9nb2wvaW5kZXhcIlxuZXhwb3J0ICogZnJvbSBcIi4vZmlzaC9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi9wcC9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi91cmJhbi9pbmRleFwiXG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgVW5pdmVyc2UgfSBmcm9tIFwiLi9Vbml2ZXJzZVwiO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCJcbmltcG9ydCB7IEFnZW50UG9pbnQgfSBmcm9tIFwiLi4vYmFzZS9BZ2VudFBvaW50XCI7XG5cbmV4cG9ydCBjbGFzcyBQbGFuZXQgZXh0ZW5kcyBBZ2VudFBvaW50IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7VW5pdmVyc2V9IHUgVGhlIHVuaXZlcnNlIHRoZSBwbGFuZXQgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgbWFzc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ggVGhlIHNwZWVkIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3kgVGhlIHNwZWVkIHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1LCBtLCB4LCB5LCBzeCA9IDAsIHN5ID0gMCkge1xuXG4gICAgICAgIC8vXG4gICAgICAgIHN1cGVyKHgsIHksIHN4LCBzeSlcblxuICAgICAgICAvKiogQHR5cGUge1VuaXZlcnNlfSAqL1xuICAgICAgICB0aGlzLnUgPSB1O1xuICAgICAgICB1LnBzLnB1c2godGhpcylcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5tID0gbTtcblxuICAgICAgICAvL2NvbXB1dGUgcmFkaXVzXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBjb25zdCByID0gdGhpcy5yKCk7XG5cbiAgICAgICAgLy9zZXQgcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHggPCByID8gciA6IHggPiB1LncgLSByID8gdS53IC0gciA6IHg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5IDwgciA/IHIgOiB5ID4gdS5oIC0gciA/IHUuaCAtIHIgOiB5O1xuXG4gICAgICAgIC8vYWNjZWxlcmF0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmF4ID0gMDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXkgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZm9yY2UsIGJhc2VkIG9uIHRoZSBncmF2aXR5IG9mIG90aGVyIHBsYW5ldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAgICovXG4gICAgb2JzZXJ2ZShleHBvbmVudCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBncmF2aXR5IGZpZWxkIGF0IHBsYW5ldCBsb2NhdGlvblxuICAgICAgICBjb25zdCBnID0gdGhpcy51LmdldEdyYXZpdHlGaWVsZCh0aGlzLngsIHRoaXMueSwgdGhpcywgZXhwb25lbnQpO1xuXG4gICAgICAgIC8vc2V0IGFjY2VsZXJhdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5heCA9IGcuZ3g7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmF5ID0gZy5neTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJhZGl1cyBvZiB0aGUgcGxhbmV0LCBkZXBlbmRpbmcgb24gaXRzIG1hc3MuXG4gICAgICovXG4gICAgcigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMubSAvIE1hdGguUEksIDAuNSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvdW5jZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgY2hhbmdlKGJvdW5jZSA9IGZhbHNlLCBtYXhTcGVlZCA9IDAuOCwgdGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9jb21wdXRlIG5ldyBzcGVlZFxuICAgICAgICB0aGlzLnN4ICs9IHRoaXMuYXggKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnN5ICs9IHRoaXMuYXkgKiB0aW1lU3RlcE1zO1xuXG4gICAgICAgIC8vY2hlY2sgdm1heFxuICAgICAgICBpZiAobWF4U3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIGNvbnN0IHYgPSBNYXRoLnNxcnQodGhpcy5zeCAqIHRoaXMuc3ggKyB0aGlzLnN5ICogdGhpcy5zeSk7XG4gICAgICAgICAgICBpZiAodiA+IG1heFNwZWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zeCA9IG1heFNwZWVkICogdGhpcy5zeCAvIHY7XG4gICAgICAgICAgICAgICAgdGhpcy5zeSA9IG1heFNwZWVkICogdGhpcy5zeSAvIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHBvc2l0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgbnggPSB0aGlzLnggKyB0aGlzLnN4ICogdGltZVN0ZXBNcztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBueSA9IHRoaXMueSArIHRoaXMuc3kgKiB0aW1lU3RlcE1zO1xuXG4gICAgICAgIC8vaGFuZGxlIHBvc2l0aW9uIGxpbWl0XG4gICAgICAgIGlmIChib3VuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSAxO1xuICAgICAgICAgICAgaWYgKG54IDwgcikgeyBueCA9IHI7IHRoaXMuc3ggPSAtdGhpcy5zeCAqIGU7IH1cbiAgICAgICAgICAgIGlmIChueSA8IHIpIHsgbnkgPSByOyB0aGlzLnN5ID0gLXRoaXMuc3kgKiBlOyB9XG4gICAgICAgICAgICBpZiAobnggPiB0aGlzLnUudyAtIHIpIHsgbnggPSB0aGlzLnUudyAtIHI7IHRoaXMuc3ggPSAtdGhpcy5zeCAqIGU7IH1cbiAgICAgICAgICAgIGlmIChueSA+IHRoaXMudS5oIC0gcikgeyBueSA9IHRoaXMudS5oIC0gcjsgdGhpcy5zeSA9IC10aGlzLnN5ICogZTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG54IDwgMCkgeyBueCA9IHRoaXMudS53OyB9XG4gICAgICAgICAgICBpZiAobnkgPCAwKSB7IG55ID0gdGhpcy51Lmg7IH1cbiAgICAgICAgICAgIGlmIChueCA+IHRoaXMudS53KSB7IG54ID0gMDsgfVxuICAgICAgICAgICAgaWYgKG55ID4gdGhpcy51LmgpIHsgbnkgPSAwOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvL21vdmVcbiAgICAgICAgdGhpcy54ID0gbng7XG4gICAgICAgIHRoaXMueSA9IG55O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBwbGFuZXRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGxTdHlsZSBcbiAgICAgKi9cbiAgICBkaXNwbGF5KGNwLCBmaWxsU3R5bGUpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIuYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnIoKSAvIGNwLmdldFpmKCksIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLmZpbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHBsYW5ldCBhY2NlbGVyYXRpb25cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cm9rZVN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciBcbiAgICAgKi9cbiAgICBkaXNwbGF5QWNjZWxlcmF0aW9uKGNwLCBzdHJva2VTdHlsZSA9IFwiY3lhblwiLCBsaW5lV2lkdGggPSAxLCBmYWN0b3IgPSA1MDAwKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGMyLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgYzIubW92ZVRvKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgYzIubGluZVRvKHRoaXMueCArIGZhY3RvciAqIHRoaXMuYXgsIHRoaXMueSArIGZhY3RvciAqIHRoaXMuYXkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgcmVtb3ZlRnJvbUFycmF5IH0gZnJvbSAnLi4vYmFzZS9saWInO1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgUGxhbmV0IH0gZnJvbSAnLi9QbGFuZXQnO1xuXG5leHBvcnQgY2xhc3MgVW5pdmVyc2Uge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHcsIGgpIHtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48UGxhbmV0Pn0gKi9cbiAgICAgICAgdGhpcy5wcyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG1hc3Mgb2YgdGhlIHVuaXZlcnNlLCBhcyB0aGUgc3VtIG9mIHRoZSBtYXNzIG9mIGl0cyBwbGFuZXRzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbSgpIHtcbiAgICAgICAgbGV0IG0gPSAwO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBtICs9IHAubTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcElnbm9yZSBBIHBsYW5ldCB0byBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAgICAgKiBAcmV0dXJucyB7e2d4Om51bWJlcixneTpudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldEdyYXZpdHlGaWVsZCh4LCB5LCBwSWdub3JlID0gdW5kZWZpbmVkLCBleHBvbmVudCA9IDIpIHtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IGd4ID0gMFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IGd5ID0gMFxuXG4gICAgICAgIC8vZ290aHJvdWdoIGFsbCBwbGFuZXRzIGluIHRoZSB1bml2ZXJzZVxuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpIHtcblxuICAgICAgICAgICAgLy9pZ25vcmUgcGxhbmV0XG4gICAgICAgICAgICBpZiAocElnbm9yZSAmJiBwID09IHBJZ25vcmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vY29tcHV0ZSBkaXN0YW5jZVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICBsZXQgZCA9IHAuZFAoeCwgeSk7XG4gICAgICAgICAgICBpZiAoZCA9PT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy9jb21wdXRlIGFuZCBhZGQgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBkID0gZCAqIE1hdGgucG93KGQsIGV4cG9uZW50KTtcbiAgICAgICAgICAgIGd4ICs9IDAuMDEgKiAocC54IC0geCkgKiBwLm0gLyBkO1xuICAgICAgICAgICAgZ3kgKz0gMC4wMSAqIChwLnkgLSB5KSAqIHAubSAvIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ3g6IGd4LCBneTogZ3kgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlIHR3byBwbGFuZXRzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtQbGFuZXR9IHAxXG4gICAgICogQHBhcmFtIHtQbGFuZXR9IHAyXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPFBsYW5ldD59IHNpbmRleFxuICAgICAqIEByZXR1cm5zIHtQbGFuZXR9XG4gICAgICovXG4gICAgYWdncmVnYXRlKHAxLCBwMiwgc2luZGV4KSB7XG4gICAgICAgIGNvbnN0IG0gPSBwMS5tICsgcDIubTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQbGFuZXQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIChwMS54ICogcDEubSArIHAyLnggKiBwMi5tKSAvIG0sXG4gICAgICAgICAgICAocDEueSAqIHAxLm0gKyBwMi55ICogcDIubSkgLyBtLFxuICAgICAgICAgICAgKHAxLnN4ICogcDEubSArIHAyLnN4ICogcDIubSkgLyBtLFxuICAgICAgICAgICAgKHAxLnN5ICogcDEubSArIHAyLnN5ICogcDIubSkgLyBtXG4gICAgICAgICk7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLnBzLCBwMSk7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLnBzLCBwMik7XG5cbiAgICAgICAgaWYgKHNpbmRleCkge1xuICAgICAgICAgICAgc2luZGV4LnJlbW92ZShwMSlcbiAgICAgICAgICAgIHNpbmRleC5yZW1vdmUocDIpXG4gICAgICAgICAgICBzaW5kZXguaW5zZXJ0KHApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPFBsYW5ldD59IHNpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xsaXNpb25GYWN0b3JcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFBsYW5ldD59XG4gICAgICovXG4gICAgZmluZENvbGxpc2lvbihzaW5kZXgsIGNvbGxpc2lvbkZhY3RvciA9IDEpIHtcbiAgICAgICAgZm9yIChsZXQgcGkgb2YgdGhpcy5wcykge1xuXG4gICAgICAgICAgICBjb25zdCB3ID0gMiAqIHBpLnIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmQgPSBzaW5kZXguZ2V0KHBpLnggLSB3LCBwaS55IC0gdywgcGkueCArIHcsIHBpLnkgKyB3KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcGogb2YgY2FuZCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBpID09IHBqKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGQxID0gcGkuZChwaik7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICAgICAgY29uc3QgZDIgPSAocGkucigpICsgcGoucigpKSAqIGNvbGxpc2lvbkZhY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwaSwgcGpdO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgcGxhbmV0cyB3aXRoIHJhbmRvbSBzcGVlZFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgYWRkUGxhbmV0cyhuYiA9IDEsIG1pID0gMC41LCBtaW5TcGVlZCA9IDAsIG1heFNwZWVkID0gMC4xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQbGFuZXQodGhpcywgbWksIHRoaXMudyAqIE1hdGgucmFuZG9tKCksIHRoaXMuaCAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgcC5zZXRSYW5kb21TcGVlZChtaW5TcGVlZCwgbWF4U3BlZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvdW5jZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdm1heCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpc2lvbkZhY3RvciBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGVwKGJvdW5jZSA9IGZhbHNlLCB2bWF4ID0gMC44LCBleHBvbmVudCA9IDIsIGNvbGxpc2lvbkZhY3RvciA9IDEsIHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vb2JzZXJ2YXRpb25cbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKVxuICAgICAgICAgICAgcC5vYnNlcnZlKGV4cG9uZW50KTtcblxuICAgICAgICAvL2FjdGlvblxuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBwLmNoYW5nZShib3VuY2UsIHZtYXgsIHRpbWVTdGVwTXMpO1xuXG5cbiAgICAgICAgLy9jb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIHRoaXMuZGV0ZWN0Q29sbGlzaW9ucyhjb2xsaXNpb25GYWN0b3IpXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpc2lvbkZhY3RvciBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBkZXRlY3RDb2xsaXNpb25zKGNvbGxpc2lvbkZhY3RvciA9IDEpIHtcblxuICAgICAgICAvKiogQHR5cGUge1NwYXRpYWxJbmRleC48UGxhbmV0Pn0gKi9cbiAgICAgICAgY29uc3Qgc2luZGV4ID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuICAgICAgICBzaW5kZXgubG9hZCh0aGlzLnBzKVxuXG4gICAgICAgIC8vZmluZCBmaXJzdCBjb2xsaXNpb25cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48UGxhbmV0Pn0gKi9cbiAgICAgICAgbGV0IHBhaXIgPSB0aGlzLmZpbmRDb2xsaXNpb24oc2luZGV4LCBjb2xsaXNpb25GYWN0b3IpO1xuICAgICAgICB3aGlsZSAocGFpciAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAvL2FnZ3JlZ2F0ZVxuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuYWdncmVnYXRlKHBhaXJbMF0sIHBhaXJbMV0sIHNpbmRleClcblxuICAgICAgICAgICAgLy9maW5kIG5leHQgY29sbGlzaW9uXG4gICAgICAgICAgICBwYWlyID0gdGhpcy5maW5kQ29sbGlzaW9uKHNpbmRleCwgY29sbGlzaW9uRmFjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIHJhbmRvbSBzcGVlZCB0byBhbGwgcGxhbmV0c1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0UmFuZG9tU3BlZWQobWluU3BlZWQgPSAwLCBtYXhTcGVlZCA9IDAuMSkge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBwLnNldFJhbmRvbVNwZWVkKG1pblNwZWVkLCBtYXhTcGVlZClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UGxhbmV0fSBUaGUgbGFyZ2VzdCBwbGFuZXQgb2YgdGhlIHVuaXZlcnNlLCB1c3VhbGx5IHRoZSBzdGFyLlxuICAgICAqL1xuICAgIGdldExhcmdlc3RQbGFuZXQoKSB7XG4gICAgICAgIGxldCBwTSA9IG51bGwsIG1NID0gMDtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBzKVxuICAgICAgICAgICAgaWYgKHAubSA+IG1NKSB7IHBNID0gcDsgbU0gPSBwLm0gfVxuICAgICAgICByZXR1cm4gcE1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGFyZ2VzdCBwbGFuZXQgYW5kIGV4cGxvZGUgaXQuXG4gICAgICovXG4gICAgZXhwbG9kZUxhcmdlc3RQbGFuZXQoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldExhcmdlc3RQbGFuZXQoKVxuICAgICAgICB0aGlzLmV4cGxvZGUocClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBsb2RlIGEgcGxhbmV0IGludG8gcGllY2VzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtQbGFuZXR9IHAgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCBcbiAgICAgKi9cbiAgICBleHBsb2RlKHAsIG5iID0gLTEsIG1pblNwZWVkID0gMC44LCBtYXhTcGVlZCA9IDEuNSwgcmFkID0gLTEpIHtcbiAgICAgICAgaWYgKG5iIDw9IDApIG5iID0gTWF0aC5mbG9vcihwLm0pO1xuICAgICAgICBpZiAobmIgPD0gMCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhbmdsZVN0ZXAgPSAyICogTWF0aC5QSSAvIG5iO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcbiAgICAgICAgICAgIC8vY3JlYXRlIHBsYW5ldFxuXG4gICAgICAgICAgICAvL3Bvc2l0aW9uXG4gICAgICAgICAgICBpZiAocmFkIDwgMCkgcmFkID0gMiAqIHAucigpXG4gICAgICAgICAgICBjb25zdCBkID0gcmFkICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBpICogYW5nbGVTdGVwO1xuICAgICAgICAgICAgY29uc3QgeCA9IGQgKiBNYXRoLmNvcyhhKSwgeSA9IGQgKiBNYXRoLnNpbihhKTtcblxuICAgICAgICAgICAgLy9zcGVlZFxuICAgICAgICAgICAgY29uc3Qgc3BlZWQgPSBtaW5TcGVlZCArIE1hdGgucmFuZG9tKCkgKiAobWF4U3BlZWQgLSBtaW5TcGVlZCk7XG4gICAgICAgICAgICBjb25zdCBhUyA9IGEgKyAyICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMiAqIE1hdGguUEkgLyAzO1xuICAgICAgICAgICAgY29uc3Qgc3ggPSBzcGVlZCAqIE1hdGguY29zKGFTKSwgc3kgPSBzcGVlZCAqIE1hdGguc2luKGFTKTtcblxuICAgICAgICAgICAgbmV3IFBsYW5ldCh0aGlzLCBwLm0gLyBuYiwgcC54ICsgeCwgcC55ICsgeSwgcC5zeCArIHN4LCBwLnN5ICsgc3kpXG4gICAgICAgIH1cbiAgICAgICAgLy9yZW1vdmUgcCBmcm9tIHVuaXZlcnNlXG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLnBzLCBwKTtcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBVbml2ZXJzZSB9IGZyb20gJy4vVW5pdmVyc2UnO1xuaW1wb3J0IHsgUGxhbmV0IH0gZnJvbSAnLi9QbGFuZXQnO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuXG4vKiogICovXG5jbGFzcyBQbGFuZXRTaW11bGF0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgb3B0cy5jYW52YXNJZCA9IG9wdHMuY2FudmFzSWQgfHwgXCJ2YWNhbnZhc1wiO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRzLmNhbnZhc0lkKTtcbiAgICAgICAgaWYgKGNhbnZhcyA9PSBudWxsKSB0aHJvdyBcIk5vIGNhbnZhcyBcIiArIG9wdHMuY2FudmFzSWQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5tYXhTcGVlZCA9IG9wdHMubWF4U3BlZWQgfHwgMC44O1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuYm91bmNlID0gb3B0cy5ib3VuY2UgfHwgZmFsc2VcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSBvcHRzLmV4cG9uZW50IHx8IDI7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmNvbGxpc2lvbkZhY3RvciA9IG9wdHMuY29sbGlzaW9uRmFjdG9yIHx8IDE7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dQbGFuZXRBY2NlbGVyYXRpb24gPSBmYWxzZVxuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgdGhpcy5zaG93RmllbGQgPSB1bmRlZmluZWRcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZmllbGRSZXMgPSAyMFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5maWVsZEZhY3RvciA9IDEwMDBcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZmllbGRTdHJva2VTdHlsZSA9IFwiIzk5YmJmZlwiO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnRhaWxpbmdzID0gb3B0cy50YWlsaW5ncyB8fCAwLjE7XG5cblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIC8vY2xlYXIsIHdpdGggdHJhbnNwYXJlbmN5XG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJnYmEoMCwwLDAsXCIgKyB0aC50YWlsaW5ncyArIFwiKVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICAvL2MyLmZpbGxSZWN0KC0xZTIwLCAtMWUyMCwgMmUyMCwgMmUyMCk7IC8vdG9kb1xuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgZ3Jhdml0eSBmaWVsZFxuICAgICAgICAgICAgaWYgKHRoLnNob3dGaWVsZCA9PT0gXCJmXCIpXG4gICAgICAgICAgICAgICAgdGguZGlzcGxheUdyYXZpdHlGaWVsZCh0aGlzLCB0cnVlKVxuICAgICAgICAgICAgZWxzZSBpZiAodGguc2hvd0ZpZWxkID09PSBcImlcIilcbiAgICAgICAgICAgICAgICB0aC5kaXNwbGF5R3Jhdml0eUZpZWxkKHRoaXMsIGZhbHNlKVxuXG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9kaXNwbGF5IHBsYW5ldHNcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGgudW5pLnBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhwKSkgY29udGludWVcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gcC5tIC8gdGgudW5pLm0oKTtcbiAgICAgICAgICAgICAgICBwLmRpc3BsYXkodGhpcywgXCJyZ2IoMjU1LDI1NSxcIiArIE1hdGguZmxvb3IoMjU1ICogKDEgLSB0KSkgKyBcIilcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kaXNwbGF5IHBsYW5ldHMgYWNjZWxlcmF0aW9uXG4gICAgICAgICAgICBpZiAodGguc2hvd1BsYW5ldEFjY2VsZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGgudW5pLnBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50b0RyYXcocCkpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIHAuZGlzcGxheUFjY2VsZXJhdGlvbih0aGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogQHR5cGUge1VuaXZlcnNlfSAqL1xuICAgICAgICB0aGlzLnVuaSA9IG5ldyBVbml2ZXJzZSh0aGlzLncsIHRoaXMuaClcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpZWxkIFxuICAgICAqL1xuICAgIGRpc3BsYXlHcmF2aXR5RmllbGQoY3AsIGZpZWxkID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmZpZWxkUmVzXG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLmZpZWxkRmFjdG9yXG4gICAgICAgIGNvbnN0IGZfID0gZmllbGQgPyAwLjMgKiByZXMgOiAwLjYgKiByZXM7XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gdGhpcy5maWVsZFN0cm9rZVN0eWxlXG4gICAgICAgIGZvciAobGV0IHggPSByZXMgKiAwLjU7IHggPCB0aGlzLnc7IHggKz0gcmVzKSB7XG4gICAgICAgICAgICBjb25zdCB4RyA9IGNwLnBpeFRvR2VvWCh4KTtcbiAgICAgICAgICAgIGlmICh4RyA+IHRoaXMudW5pLncgfHwgeEcgPCAwKSBjb250aW51ZVxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHJlcyAvIDI7IHkgPCB0aGlzLmg7IHkgKz0gcmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeUcgPSBjcC5waXhUb0dlb1koeSk7XG4gICAgICAgICAgICAgICAgaWYgKHlHID4gdGhpcy51bmkuaCB8fCB5RyA8IDApIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgLy9nZXQgZ3Jhdml0eSBmaWVsZFxuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaS5nZXRHcmF2aXR5RmllbGQoeEcsIHlHLCB1bmRlZmluZWQsIHRoaXMuZXhwb25lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdfID0gTWF0aC5oeXBvdChnLmd4LCBnLmd5KVxuXG4gICAgICAgICAgICAgICAgYzIubGluZVdpZHRoID0gTWF0aC5taW4oZiAqIGdfLCAwLjMgKiByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gZl8gKiBnLmd4IC8gZ18sIGR5ID0gZl8gKiBnLmd5IC8gZ19cblxuICAgICAgICAgICAgICAgIC8vZHJhd1xuICAgICAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAvL2dyYXZpdHkgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgYzIubW92ZVRvKHggLSBkeCwgeSArIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgYzIubGluZVRvKHggKyBkeCwgeSAtIGR5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2lzb3BvdGVudGlhbCBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBjMi5tb3ZlVG8oeCArIGR5LCB5ICsgZHgpO1xuICAgICAgICAgICAgICAgICAgICBjMi5saW5lVG8oeCAtIGR5LCB5IC0gZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSB3aXRoIHJhbmRvbSBwbGFuZXRzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGluaXRSYW5kb20obmIgPSAxMDAwLCBtaSA9IDAuNSwgbWluU3BlZWQgPSAwLCBtYXhTcGVlZCA9IDAuMSkge1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICB0aGlzLnVuaS5wcyA9IFtdO1xuICAgICAgICB0aGlzLnVuaS5hZGRQbGFuZXRzKG5iLCBtaSwgbWluU3BlZWQsIG1heFNwZWVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSB3aXRoIGJpZyBiYW5nIHNldHVwXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWQgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdEJpZ0JhbmcobmIgPSAxMDAwLCBtaSA9IDEsIG1pblNwZWVkID0gMC4zNSwgbWF4U3BlZWQgPSAwLjcsIHJhZCA9IDEwMCkge1xuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICB0aGlzLnVuaS5wcyA9IFtdO1xuICAgICAgICAvL2NyZWF0ZSBiaWcgcGxhbmV0IGluIHRoZSBtaWRkbGVcbiAgICAgICAgY29uc3QgY3ggPSB0aGlzLncgKiAwLjUsIGN5ID0gdGhpcy5oICogMC41O1xuICAgICAgICBjb25zdCBwID0gbmV3IFBsYW5ldCh0aGlzLnVuaSwgbmIgKiBtaSwgY3gsIGN5LCAwLCAwKTtcbiAgICAgICAgLy9leHBsb2RlIGl0XG4gICAgICAgIHRoaXMudW5pLmV4cGxvZGUocCwgbmIsIG1pblNwZWVkLCBtYXhTcGVlZCwgcmFkKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBzaW11bGF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQudW5pLnN0ZXAodC5ib3VuY2UsIHQubWF4U3BlZWQsIHQuZXhwb25lbnQsIHQuY29sbGlzaW9uRmFjdG9yLCB0aW1lU3RlcE1zKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9zdG9wXG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy9UT0RPXG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCBwbGFuZXRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFBsYW5ldFNpbXVsYXRpb24ob3B0cylcbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBMYW5kIH0gZnJvbSBcIi4vTGFuZFwiXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgQWdlbnRQb2ludCB9IGZyb20gXCIuLi9iYXNlL0FnZW50UG9pbnRcIlxuXG4vKiogKi9cbmV4cG9ydCBjbGFzcyBBbmltYWwgZXh0ZW5kcyBBZ2VudFBvaW50IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFxuICAgICAqIEBwYXJhbSB7TGFuZH0gbCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsLCB4ID0gMCwgeSA9IDApIHtcblxuICAgICAgICBzdXBlcih4LCB5KVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKiogQHR5cGUge0xhbmR9ICovXG4gICAgICAgIHRoaXMubCA9IGw7XG5cbiAgICAgICAgLy9wb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geCA8IDAgPyAwIDogeCA+IGwudyA/IGwudyA6IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHkgPCAwID8gMCA6IHkgPiBsLmggPyBsLmggOiB5XG5cbiAgICAgICAgLy90aGUgb3RoZXIgYW5pbWFscyBhcm91bmRcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5wcmVkYXRvcnMgPSBbXVxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLnByZXlzID0gW11cblxuICAgICAgICAvL2FkZCB0byB0aGUgc3BhdGlhbCBpbmRleFxuICAgICAgICBsLmdyaWQuaW5zZXJ0KHRoaXMpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIG1vdmUodGltZVN0ZXBNcyA9IDEwKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxcbiAgICAgICAgbC5ncmlkLnJlbW92ZSh0aGlzKTtcblxuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgciA9IDAuMDEgKiBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIHRoaXMuc3ggKz0gciAqIE1hdGguY29zKGFuZ2xlKSAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMuc3ggPSB0aGlzLnN4ID4gbC5WX01BWCA/IGwuVl9NQVggOiB0aGlzLnN4IDwgLWwuVl9NQVggPyAtbC5WX01BWCA6IHRoaXMuc3hcblxuICAgICAgICB0aGlzLnN5ICs9IHIgKiBNYXRoLnNpbihhbmdsZSkgKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnN5ID0gdGhpcy5zeSA+IGwuVl9NQVggPyBsLlZfTUFYIDogdGhpcy5zeSA8IC1sLlZfTUFYID8gLWwuVl9NQVggOiB0aGlzLnN5XG5cbiAgICAgICAgdGhpcy54ICs9IHRoaXMuc3ggKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnggPSB0aGlzLnggPCAwID8gbC53IDogdGhpcy54ID4gbC53ID8gMCA6IHRoaXMueFxuXG4gICAgICAgIHRoaXMueSArPSB0aGlzLnN5ICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy55ID0gdGhpcy55IDwgMCA/IGwuaCA6IHRoaXMueSA+IGwuaCA/IDAgOiB0aGlzLnlcblxuICAgICAgICBsLmdyaWQuaW5zZXJ0KHRoaXMpO1xuICAgIH1cblxuXG4gICAgLyoqIE9ic2VydmUgKi9cbiAgICBvYnNlcnZlKCkge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sXG5cbiAgICAgICAgLy9nZXQgYW5pbWFscyBhcm91bmRcbiAgICAgICAgY29uc3QgYXMgPSBsLmdyaWQuZ2V0KHRoaXMueCAtIGwuZCwgdGhpcy55IC0gbC5kLCB0aGlzLnggKyBsLmQsIHRoaXMueSArIGwuZCk7XG5cbiAgICAgICAgdGhpcy5wcmV5cyA9IFtdO1xuICAgICAgICB0aGlzLnByZWRhdG9ycyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGEgb2YgYXMpIHtcbiAgICAgICAgICAgIGlmIChhID09IHRoaXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZChhKSA+IGwuZCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoYS50eXBlID09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV5cy5wdXNoKGEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucHJlZGF0b3JzLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHJldHVybnMge0FuaW1hbH0gKi9cbiAgICBtYWtlQ2hpbGQoKSB7XG4gICAgICAgIC8vZG8gYmV0dGVyOiBtYWtlIGNoaWxkIGFyb3VuZFxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hbCh0aGlzLnR5cGUsIHRoaXMubCwgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGFuaW1hbFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsbFN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGZpbGxTdHlsZSA9IFwiYmx1ZVwiLCBzaXplID0gMikge1xuICAgICAgICBjcC5jdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjcC5jdHguZmlsbFJlY3QodGhpcy54LCB0aGlzLnksIHNpemUsIHNpemUpO1xuICAgICAgICAvKmMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmMoYS54LCBhLnksIDAuNSwgMCwgMipNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLmZpbGwoKTsqL1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gJy4uL2Jhc2UvU3BhdGlhbEluZGV4JztcbmltcG9ydCB7IHJlbW92ZUZyb21BcnJheVMgfSBmcm9tICcuLi9iYXNlL2xpYic7XG5pbXBvcnQge0FuaW1hbH0gZnJvbSBcIi4vQW5pbWFsXCJcblxuZXhwb3J0IGNsYXNzIExhbmQge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8vdGhlIG1heCBzcGVlZFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5WX01BWCA9IDAuMVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnAgPSAwLjAyIC8vcHJlZGF0b3IgZGVhdGggcHJvYmFiaWxpdHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucSA9IDAuMSAvL3ByZXkgcmVwcm9kdWN0aW9uIHByb2JhYmlsaXR5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnIgPSAwLjUgLy9lYXRlbiBwcmV5IHRyYW5zZm9ybWF0aW9uIHByb2JhYmlsaXR5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm5iID0gMyAvL25laWdoYm9ycyBudW1iZXJcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gd1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaFxuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMucHJlZGF0b3JzID0gW11cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5wcmV5cyA9IFtdXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuZCA9IDEwXG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgU3BhdGlhbEluZGV4KCk7XG5cbiAgICAgICAgLyppbnRbXVtdIGhpc3RvO1xuICAgICAgICBpbnQgaW5kZXg9MDtcbiAgICAgICAgdGhpcy5jMkNoYXJ0PWMyQ2hhcnQ7XG4gICAgICAgIHRoaXMuaENoYXJ0PWhDaGFydDtcbiAgICAgICAgdGhpcy5oaXN0bz1uZXcgaW50W3dDaGFydF1bXTtcbiAgICAgICAgZm9yKGludCBpPTA7aTx3Q2hhcnQ7aSsrKVxuICAgICAgICAgICAgaGlzdG9baV09bmV3IGludFtdezAsMH07Ki9cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIHN0ZXAodGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9vYnNlcnZlXG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5wcmV5cykgYS5vYnNlcnZlKCk7XG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5wcmVkYXRvcnMpIGEub2JzZXJ2ZSgpO1xuXG4gICAgICAgIGNvbnN0IHByZXlzVG9Cb3JuID0gW11cbiAgICAgICAgY29uc3QgcHJleXNUb0RpZSA9IFtdXG4gICAgICAgIGNvbnN0IHByZWRzVG9Cb3JuID0gW11cbiAgICAgICAgY29uc3QgcHJlZHNUb0RpZSA9IFtdXG5cbiAgICAgICAgLy9wcmV5XG4gICAgICAgIGZvciAobGV0IHByZXkgb2YgdGhpcy5wcmV5cykge1xuICAgICAgICAgICAgLy9yZXByb2R1Y3Rpb24gaWYgbm8gcHJlZGF0b3IgYXJvdW5kXG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IHRoaXMucSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocHJleS5wcmVkYXRvcnMubGVuZ3RoICE9IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHByZXkucHJleXMubGVuZ3RoID49IHRoaXMubmIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcHJleXNUb0Jvcm4ucHVzaChwcmV5Lm1ha2VDaGlsZCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcHJlZGF0b3JcbiAgICAgICAgZm9yIChsZXQgcHJlZCBvZiB0aGlzLnByZWRhdG9ycykge1xuICAgICAgICAgICAgLy9ubyBwcmV5IGFyb3VuZDogcHJlZGF0b3IgZGllcyB3aXRoIHByb2JhYmlsaXR5IHBcbiAgICAgICAgICAgIGlmIChwcmVkLnByZXlzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCB0aGlzLnApIHByZWRzVG9EaWUucHVzaChwcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcHJleSBhcm91bmRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZWF0IHByZXlcbiAgICAgICAgICAgICAgICAvL2Nob29zZSByYW5kb21seVxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXlUb0VhdCA9IHByZWQucHJleXNbTWF0aC5mbG9vcihwcmVkLnByZXlzLmxlbmd0aCAqIE1hdGgucmFuZG9tKCkpXTtcbiAgICAgICAgICAgICAgICBwcmV5c1RvRGllLnB1c2gocHJleVRvRWF0KTtcblxuICAgICAgICAgICAgICAgIC8vcHJlZGF0b3IgcmVwcm9kdWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiB0aGlzLnIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkLnByZWRhdG9ycy5sZW5ndGggPj0gdGhpcy5uYikgY29udGludWU7XG4gICAgICAgICAgICAgICAgcHJlZHNUb0Jvcm4ucHVzaChwcmVkLm1ha2VDaGlsZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJleXMucHVzaCguLi5wcmV5c1RvQm9ybik7XG4gICAgICAgIHRoaXMucHJlZGF0b3JzLnB1c2goLi4ucHJlZHNUb0Jvcm4pO1xuXG4gICAgICAgIHJlbW92ZUZyb21BcnJheVModGhpcy5wcmV5cywgcHJleXNUb0RpZSwgZmFsc2UpXG4gICAgICAgIGZvciAobGV0IGEgb2YgcHJleXNUb0RpZSkgdGhpcy5ncmlkLnJlbW92ZShhKTtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5Uyh0aGlzLnByZWRhdG9ycywgcHJlZHNUb0RpZSwgZmFsc2UpXG4gICAgICAgIGZvciAobGV0IGEgb2YgcHJlZHNUb0RpZSkgdGhpcy5ncmlkLnJlbW92ZShhKTtcblxuICAgICAgICAvL21vdmVcbiAgICAgICAgZm9yIChsZXQgYSBvZiB0aGlzLnByZXlzKVxuICAgICAgICAgICAgYS5tb3ZlKHRpbWVTdGVwTXMpO1xuICAgICAgICBmb3IgKGxldCBhIG9mIHRoaXMucHJlZGF0b3JzKVxuICAgICAgICAgICAgYS5tb3ZlKHRpbWVTdGVwTXMpO1xuXG4gICAgICAgIC8qL2hpc3RvXG4gICAgICAgIGhpc3RvW2luZGV4XSA9IG5ldyBpbnRbXXsgcHJleXMuc2l6ZSgpLCBwcmVkYXRvcnMuc2l6ZSgpIH07XG4gICAgICAgIGlmIChpbmRleCA9PSBoaXN0by5sZW5ndGggLSAxKSBpbmRleCA9IDA7XG4gICAgICAgIGVsc2UgaW5kZXgrKzsqL1xuXG4gICAgfVxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IExhbmQgfSBmcm9tICcuL0xhbmQnO1xuaW1wb3J0IHsgQW5pbWFsIH0gZnJvbSAnLi9BbmltYWwnO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuXG4vKiogKi9cbmNsYXNzIFByZXlQcmVkYXRvclNpbXVsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gb3B0cy5oIHx8IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtHZW9DYW52YXN9ICovXG4gICAgICAgIHRoaXMuY3BsdXMgPSBuZXcgR2VvQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpO1xuXG5cbiAgICAgICAgY29uc3QgdGggPSB0aGlzO1xuICAgICAgICB0aGlzLmNwbHVzLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5jdHhcblxuICAgICAgICAgICAgLy90cmFuc3BhcmVuY3lcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBhbmltYWxzXG4gICAgICAgICAgICB0aGlzLnNldENhbnZhc1RyYW5zZm9ybSgpXG4gICAgICAgICAgICBmb3IgKGxldCBhIG9mIHRoLmxhbmQucHJleXMpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KGEpKVxuICAgICAgICAgICAgICAgICAgICBhLmRpc3BsYXkodGhpcywgXCJibHVlXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgYSBvZiB0aC5sYW5kLnByZWRhdG9ycylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoYSkpXG4gICAgICAgICAgICAgICAgICAgIGEuZGlzcGxheSh0aGlzLCBcInJlZFwiKTtcblxuICAgICAgICAgICAgLyovbGFiZWxcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwibGlnaHRncmF5XCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCA2NSwgMTMpO1xuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICAgICAgYzIuZmlsbFRleHQocHJleXMubGVuZ3RoICsgXCIvXCIgKyBwcmVkYXRvcnMubGVuZ3RoLCAyLCAxMCk7Ki9cblxuICAgICAgICAgICAgLy9jaGFydFxuICAgICAgICAgICAgLy9jMkNoYXJ0LnNldEZpbGxTdHlsZShiYWNrQ29sb3IyKTtcbiAgICAgICAgICAgIC8vYzJDaGFydC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgICAgICAgLy9kb3VibGUgbWF4ID0gZ2V0TWF4SGlzdG8oKTtcbiAgICAgICAgICAgIC8qcHVibGljIGludCBnZXRNYXhIaXN0bygpIHtcbiAgICAgICAgICAgICAgICBpbnQgbWF4PTA7XG4gICAgICAgICAgICAgICAgZm9yKGludCBpPTA7aTxoaXN0by5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGlzdG9baV1bMF0+bWF4KSBtYXg9aGlzdG9baV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGlmKGhpc3RvW2ldWzFdPm1heCkgbWF4PWhpc3RvW2ldWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlIGgxLCBoMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGhpc3RvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgxID0gaENoYXJ0ICogaGlzdG9baV1bMF0gLyBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gaENoYXJ0ICogaGlzdG9baV1bMV0gLyBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuc2V0RmlsbFN0eWxlKHByZXlDb2xvcjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LmZpbGxSZWN0KGksIGhDaGFydCAtIGgxLCAxLCBoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuc2V0RmlsbFN0eWxlKHByZWRhdG9yQ29sb3IyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5maWxsUmVjdChpLCBoQ2hhcnQgLSBoMiwgMSwgaDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuc2V0RmlsbFN0eWxlKENzc0NvbG9yLm1ha2UoMjU1LCAyNTUsIDI1NSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5maWxsUmVjdChpbmRleCwgMCwgMSwgaENoYXJ0KTtcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vZnJhbWVcbiAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJkYXJrZ3JheVwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMSAqIHRoLmNwbHVzLmdldFpmKCk7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLnJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7TGFuZH0gKi9cbiAgICAgICAgdGhpcy5sYW5kID0gbmV3IExhbmQodGhpcy53LCB0aGlzLmgpXG5cbiAgICB9XG5cblxuXG4gICAgLy9UT0RPIHRlc3QgaW5pdCBpbiBhIGJ1YmJsZSA/XG4gICAgLy9UT0RPIHVzZSBkZW5zaXR5IGFzIGlucHV0IHBhcmFtZXRlcnMgaW5zdGVhZCBvZiBuYlxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByZXlEZW5zaXR5IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVkYXRvckRlbnNpdHkgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdFJhbmRvbShwcmV5RGVuc2l0eSA9IDAuMDAzLCBwcmVkYXRvckRlbnNpdHkgPSAwLjAwMykge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sYW5kXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJleURlbnNpdHkgKiBsLncgKiBsLmg7IGkrKylcbiAgICAgICAgICAgIGwucHJleXMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgQW5pbWFsKDAsIGwsIGwudyAqIE1hdGgucmFuZG9tKCksIGwuaCAqIE1hdGgucmFuZG9tKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWRhdG9yRGVuc2l0eSAqIGwudyAqIGwuaDsgaSsrKVxuICAgICAgICAgICAgbC5wcmVkYXRvcnMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgQW5pbWFsKDEsIGwsIGwudyAqIE1hdGgucmFuZG9tKCksIGwuaCAqIE1hdGgucmFuZG9tKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYkl0ZXJhdGlvbnMgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RhcnQodGltZVN0ZXBNcyA9IDEwLCBuYkl0ZXJhdGlvbnMgPSAtMSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0LmxhbmQuc3RlcCh0aW1lU3RlcE1zKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAqL1xuZXhwb3J0IGNvbnN0IHByZXlQcmVkYXRvciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcmV5UHJlZGF0b3JTaW11bGF0aW9uKG9wdHMpXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCJcbmltcG9ydCB7IFNwYXRpYWxJbmRleCB9IGZyb20gXCIuLi9iYXNlL1NwYXRpYWxJbmRleFwiXG5cbmV4cG9ydCBjbGFzcyBCdWlsZGluZyB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZWEgVGhlIGFyZWFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBhcmVhKSB7XG5cbiAgICAgICAgLy9zZXQgcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXJlYSA9IGFyZWFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7IG51bWJlciB9XG4gICAgICovXG4gICAgcigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmFyZWEgLyBNYXRoLlBJKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QnVpbGRpbmd9IGIgXG4gICAgICovXG4gICAgb3ZlcmxhcChiKSB7XG4gICAgICAgIGNvbnN0IGQxID0gYi5yKCkgKyB0aGlzLnIoKVxuICAgICAgICBjb25zdCBkMiA9IE1hdGguaHlwb3QoKGIueCAtIHRoaXMueCksIChiLnkgLSB0aGlzLnkpKTtcbiAgICAgICAgcmV0dXJuIGQyIDwgZDFcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTcGF0aWFsSW5kZXguPEJ1aWxkaW5nPn0gc2luZGV4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzRGlzdGFuY2UgXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2hlY2tDb2xsaXNpb24oc2luZGV4LCBzRGlzdGFuY2UpIHtcblxuICAgICAgICAvL2dldCBidWlsZGluZ3MgYXJvdW5kIHVzaW5nIHNwYXRpYWwgaW5kZXhcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QnVpbGRpbmc+fSAqL1xuICAgICAgICBjb25zdCBzcyA9IHNpbmRleC5nZXQodGhpcy54IC0gc0Rpc3RhbmNlLCB0aGlzLnkgLSBzRGlzdGFuY2UsIHRoaXMueCArIHNEaXN0YW5jZSwgdGhpcy55ICsgc0Rpc3RhbmNlKTtcblxuICAgICAgICBmb3IgKGxldCBiIG9mIHNzKSB7XG4gICAgICAgICAgICBpZiAoYiA9PSB0aGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXAoYikpIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGxTdHlsZSBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKi9cbiAgICBkaXNwbGF5KGNwLCBmaWxsU3R5bGUsIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucigpLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5maWxsKCk7XG4gICAgICAgIGMyLnN0cm9rZSgpO1xuICAgIH1cblxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgQnVpbGRpbmcgfSBmcm9tICcuL0J1aWxkaW5nJztcbmltcG9ydCB7IFJvYWROZXR3b3JrIH0gZnJvbSAnLi9Sb2FkTmV0d29yayc7XG5cbmV4cG9ydCBjbGFzcyBNYXAge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHcsIGgpIHtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QnVpbGRpbmc+fSAqL1xuICAgICAgICB0aGlzLmJzID0gW107XG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxCdWlsZGluZz59ICovXG4gICAgICAgIHRoaXMuYnVJbmRleCA9IG5ldyBTcGF0aWFsSW5kZXgoKTtcblxuICAgICAgICAvKiogQHR5cGUge1JvYWROZXR3b3JrfSAqL1xuICAgICAgICB0aGlzLnJuID0gbmV3IFJvYWROZXR3b3JrKHRoaXMpO1xuXG4gICAgfVxuXG4gICAgLyoqICovXG4gICAgYWRkQnVpbGRpbmcoKSB7XG5cbiAgICAgICAgLy9jb21wdXRlIGNhbmRpZGF0ZSBsb2NhdGlvbiwgc2l6ZSBhbmQgdHlwZSBmb3IgbmV4dCBidWlsZGluZ1xuICAgICAgICAvL1RPRE8gbG93IGxvY2FsIGNvbmdlc3Rpb24gQU5EIGdvIHRvIGhpZ2ggZGVuc2l0eSAod2l0aCBnb29kIGFjY2VzcyB0byBvdGhlciBzdHVmZilcblxuICAgICAgICAvL21ha2UgcmFuZG9tIGJ1aWxkaW5nXG4gICAgICAgIGNvbnN0IG1ha2VSYW5kb21CdWlsZGluZyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLncgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuaCAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gNDAgKyAyMDAgKiBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1aWxkaW5nKHgsIHksIGFyZWEpXG4gICAgICAgIH1cblxuICAgICAgICAvL1RPRE8gc2hvdWxkIG5vdCBvdmVybGFwIHdpdGggb3RoZXIgZW50aXRpZXMgKHJvYWRzLCBidWlsZGluZylcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3Qgc0Rpc3RhbmNlID0gMTAwO1xuICAgICAgICAvKiogQHR5cGUge0J1aWxkaW5nfSAqL1xuICAgICAgICBsZXQgYnUgPSBtYWtlUmFuZG9tQnVpbGRpbmcoKTtcbiAgICAgICAgd2hpbGUgKGJ1LmNoZWNrQ29sbGlzaW9uKHRoaXMuYnVJbmRleCwgc0Rpc3RhbmNlKSkge1xuICAgICAgICAgICAgYnUgPSBtYWtlUmFuZG9tQnVpbGRpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYWRkIGJ1aWxkaW5nXG4gICAgICAgIHRoaXMuYnMucHVzaChidSk7XG4gICAgICAgIHRoaXMuYnVJbmRleC5sb2FkKFtidV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RlcCgpIHtcblxuICAgICAgICAvL2NvbXB1dGUgYnVpbGRpbmcgbmVlZFxuICAgICAgICBjb25zdCBidU5lZWQgPSAxMDtcblxuICAgICAgICAvL3VyYmFuaXNlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVOZWVkOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQnVpbGRpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZXh0ZW5kIHJvYWQgbmV0d29ya1xuICAgICAgICAvL1RPRE9cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIjtcblxuZXhwb3J0IGNsYXNzIFJvYWQge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdlb20gXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdlb20sIHdpZHRoKSB7XG5cbiAgICAgICAgdGhpcy5nZW9tID0gZ2VvbVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoXG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cm9rZVN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggXG4gICAgICovXG4gICAgZGlzcGxheShjcCwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjcyA9IHRoaXMuZ2VvbS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBpZiAoY3MubGVuZ3RoID09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgLy9tb3ZlIHRvIGZpcnN0IHBvaW50XG4gICAgICAgIGxldCBjID0gY3NbMF1cbiAgICAgICAgYzIubW92ZVRvKGMueCwgYy55KTtcblxuICAgICAgICAvL3RyYWNlIGxpbmVcbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBjc1tpXVxuICAgICAgICAgICAgYzIubGluZVRvKGMueCwgYy55KTtcbiAgICAgICAgfVxuICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFJvYWQgfSBmcm9tIFwiLi9Sb2FkXCJcbmltcG9ydCB7IE1hcCB9IGZyb20gXCIuL01hcFwiXG5pbXBvcnQganN0cyBmcm9tIFwianN0c1wiO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCI7XG5cbmV4cG9ydCBjbGFzcyBSb2FkTmV0d29yayB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7TWFwfSAqL1xuICAgICAgICB0aGlzLm1hcCA9IG1hcFxuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFJvYWQ+fSAqL1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gW11cblxuXG4gICAgICAgIC8vYWRkIHRlc3Qgcm9hZFxuICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbiAgICAgICAgLy9odHRwOi8vYmpvcm5oYXJydGVsbC5naXRodWIuaW8vanN0cy9cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLldLVFJlYWRlcigpXG4gICAgICAgIHZhciBnID0gcmVhZGVyLnJlYWQoJ0xJTkVTVFJJTkcgKDMwIDEwLCAxMCAzMDAsIDQwMCA0MDApJylcbiAgICAgICAgdGhpcy5zZWN0aW9ucy5wdXNoKG5ldyBSb2FkKGcsIDcpKTtcbiAgICB9XG5cbiAgICBidWlsZFJhbmRvbSgpIHtcblxuICAgICAgICBjb25zdCB3ID0gdGhpcy5tYXAud1xuICAgICAgICBjb25zdCBoID0gdGhpcy5tYXAuaFxuXG4gICAgICAgIC8vY29uc3QgciA9IDIgKiB3ICsgMiAqIGggKiBNYXRoLnJhbmRvbSgpO1xuXG5cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXlcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICovXG4gICAgZGlzcGxheShjcCkge1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMuc2VjdGlvbnMpXG4gICAgICAgICAgICByLmRpc3BsYXkoY3AsIFwiYmxhY2tcIiwgci53aWR0aCk7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5zZWN0aW9ucylcbiAgICAgICAgICAgIHIuZGlzcGxheShjcCwgXCJ5ZWxsb3dcIiwgci53aWR0aCAtIDMpO1xuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5pbXBvcnQgeyBNYXAgfSBmcm9tIFwiLi9NYXBcIjtcblxuLyoqICAqL1xuY2xhc3MgVXJiYW5TaW11bGF0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgb3B0cy5jYW52YXNJZCA9IG9wdHMuY2FudmFzSWQgfHwgXCJ2YWNhbnZhc1wiO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRzLmNhbnZhc0lkKTtcbiAgICAgICAgaWYgKGNhbnZhcyA9PSBudWxsKSB0aHJvdyBcIk5vIGNhbnZhcyBcIiArIG9wdHMuY2FudmFzSWQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgLy9jbGVhclxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9kaXNwbGF5IHJvYWQgbmV0d29ya1xuICAgICAgICAgICAgdGgubWFwLnJuLmRpc3BsYXkodGhpcyk7XG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBidWlsZGluZ3NcbiAgICAgICAgICAgIGZvciAobGV0IGIgb2YgdGgubWFwLmJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhiKSkgY29udGludWVcbiAgICAgICAgICAgICAgICBiLmRpc3BsYXkodGhpcywgXCJsaWdodGdyYXlcIiwgXCJibGFja1wiLCAyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7TWFwfSAqL1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAodGhpcy53LCB0aGlzLmgpXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBzaW11bGF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubWFwLnN0ZXAoKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9zdG9wXG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy9UT0RPXG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCB1cmJhbiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBVcmJhblNpbXVsYXRpb24ob3B0cylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=