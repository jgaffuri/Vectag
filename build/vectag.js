(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vectag"] = factory();
	else
		root["vectag"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/index.js ***!
  \********************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _color_js__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color_js__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: radians, degrees */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "./node_modules/d3-dispatch/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-dispatch/src/index.js ***!
  \***********************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassive"])
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view)
      .on("mousemove.drag", mousemoved, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"])
      .on("mouseup.drag", mouseupped, _noevent_js__WEBPACK_IMPORTED_MODULE_3__["nonpassivecapture"]);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(event.view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag_js__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(event.view, mousemoving);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent_js__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"]("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["pointer"])(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-drag/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/index.js ***!
  \*******************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _drag_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _nodrag_js__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });





/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__["nonpassivecapture"]);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nonpassive, nonpassivecapture, nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassive", function() { return nonpassive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonpassivecapture", function() { return nonpassivecapture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-(--t)) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(-t) * Math.sin((s - t) / p)
        : 2 - a * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-ease/src/math.js");


function expIn(t) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - +t);
}

function expOut(t) {
  return 1 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(1 - t) : 2 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tpmt"])(t - 1)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/index.js ***!
  \*******************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _linear_js__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _quad_js__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _cubic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic.js */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _cubic_js__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _poly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./poly.js */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _poly_js__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _sin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sin.js */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _sin_js__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _exp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exp.js */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _exp_js__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circle.js */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _bounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bounce.js */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _bounce_js__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _back_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./back.js */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _back_js__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _elastic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elastic.js */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _elastic_js__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });






















/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
const linear = t => +t;


/***/ }),

/***/ "./node_modules/d3-ease/src/math.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/math.js ***!
  \******************************************/
/*! exports provided: tpmt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tpmt", function() { return tpmt; });
// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default, genericArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genericArray", function() { return genericArray; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return (Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_1__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/discrete.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/discrete.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hue.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hue.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["hue"])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/index.js ***!
  \**************************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateNumberArray, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _value_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _array_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _date_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "./node_modules/d3-interpolate/src/discrete.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return _discrete_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "./node_modules/d3-interpolate/src/hue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return _hue_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _number_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _object_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _round_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _string_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _transform_index_js__WEBPACK_IMPORTED_MODULE_12__["interpolateTransformSvg"]; });

/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_14__["rgbBasisClosed"]; });

/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _hsl_js__WEBPACK_IMPORTED_MODULE_15__["hslLong"]; });

/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _lab_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _hcl_js__WEBPACK_IMPORTED_MODULE_17__["hclLong"]; });

/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__["cubehelixLong"]; });

/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _piecewise_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _quantize_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });
























/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/*! exports provided: default, isNumberArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumberArray", function() { return isNumberArray; });
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"] : Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_6__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_8__["isNumberArray"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__["genericArray"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ __webpack_exports__["default"] = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return array; });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return Object(_select_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__["xhtml"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/index.js ***!
  \************************************************/
/*! exports provided: create, creator, local, matcher, namespace, namespaces, pointer, pointers, select, selectAll, selection, selector, selectorAll, style, window */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create.js */ "./node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _creator_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local.js */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _local_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _namespace_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _namespaces_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointer", function() { return _pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _pointers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pointers.js */ "./node_modules/d3-selection/src/pointers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointers", function() { return _pointers_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _select_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _selectAll_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _selection_index_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector.js */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _selector_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _selectorAll_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _selection_style_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _selection_style_js__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./window.js */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _window_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });


















/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default, childMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "childMatcher", function() { return childMatcher; });
/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
});


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(event, node) {
  event = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointers.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/pointers.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointer.js */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(events, node) {
  if (events.target) { // i.e., instanceof Event, not TouchList or iterable
    events = Object(_sourceEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(events);
    if (node === undefined) node = events.currentTarget;
    events = events.touches || [events];
  }
  return Array.from(events, event => Object(_pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event, node));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"]([Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_1__["root"]);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ __webpack_exports__["default"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return !this.node();
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function*() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(lower);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Array.from(this);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(raise);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(remove);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = Object(_selectorAll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : Object(_matcher_js__WEBPACK_IMPORTED_MODULE_0__["childMatcher"])(match)));
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(update) {
  return new Array(update.length);
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
});


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),

/***/ "./node_modules/d3-timer/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/index.js ***!
  \********************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _timer_js__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timeout.js */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _timeout_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _interval_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });








/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? Object(_timer_js__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__["Timer"];
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return this.each(function() {
    Object(_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]
      : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/index.js");



var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["default"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        string1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_2__["set"])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate_js__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, Object(_tween_js__WEBPACK_IMPORTED_MODULE_3__["tweenValue"])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(_tween_js__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(_schedule_js__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity, ZoomTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["Transform"]; });





/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
});


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(event.view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved(event) {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(event.view, g.moved);
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["pointer"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
});


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/jsts/dist/jsts.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * @license
 */
!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}}class n extends Error{constructor(t){super(t),this.name=Object.keys({Exception:n})[0]}toString(){return this.message}}class s extends n{constructor(t){super(t),this.name=Object.keys({IllegalArgumentException:s})[0]}}class i{constructor(t,e){this.low=e||0,this.high=t||0}static toBinaryString(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n}}function r(){}function o(){}function l(){}function a(){}function c(){}r.NaN=NaN,r.isNaN=t=>Number.isNaN(t),r.isInfinite=t=>!Number.isFinite(t),r.MAX_VALUE=Number.MAX_VALUE,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=2146435072,e=new Float64Array(1),n=new Int32Array(e.buffer);r.doubleToLongBits=function(s){e[0]=s;let r=0|n[0],o=0|n[1];return(o&t)===t&&0!=(1048575&o)&&0!==r&&(r=0,o=2146959360),new i(o,r)},r.longBitsToDouble=function(t){return n[0]=t.low,n[1]=t.high,e[0]}}():function(){const t=1023,e=Math.log2,n=Math.floor,s=Math.pow,o=function(){for(let t=53;t>0;t--){const i=s(2,t)-1;if(n(e(i))+1===t)return i}return 0}();r.doubleToLongBits=function(r){let l,a,c,h,u,g,d,_,p;if(r<0||1/r===Number.NEGATIVE_INFINITY?(g=1<<31,r=-r):g=0,0===r)return p=0,_=g,new i(_,p);if(r===1/0)return p=0,_=2146435072|g,new i(_,p);if(r!=r)return p=0,_=2146959360,new i(_,p);if(h=0,p=0,l=n(r),l>1)if(l<=o)h=n(e(l)),h<=20?(p=0,_=l<<20-h&1048575):(c=h-20,a=s(2,c),p=l%a<<32-c,_=l/a&1048575);else for(c=l,p=0;a=c/2,c=n(a),0!==c;)h++,p>>>=1,p|=(1&_)<<31,_>>>=1,a!==c&&(_|=524288);if(d=h+t,u=0===l,l=r-l,h<52&&0!==l)for(c=0;;){if(a=2*l,a>=1?(l=a-1,u?(d--,u=!1):(c<<=1,c|=1,h++)):(l=a,u?0==--d&&(h++,u=!1):(c<<=1,h++)),20===h)_|=c,c=0;else if(52===h){p|=c;break}if(1===a){h<20?_|=c<<20-h:h<52&&(p|=c<<52-h);break}}return _|=d<<20,_|=g,new i(_,p)},r.longBitsToDouble=function(e){let n,i,r,o;const l=e.high,a=e.low,c=l&1<<31?-1:1;for(r=((2146435072&l)>>20)-t,o=0,i=1<<19,n=1;n<=20;n++)l&i&&(o+=s(2,-n)),i>>>=1;for(i=1<<31,n=21;n<=52;n++)a&i&&(o+=s(2,-n)),i>>>=1;if(-1023===r){if(0===o)return 0*c;r=-1022}else{if(1024===r)return 0===o?c/0:NaN;o+=1}return c*o*s(2,r)}}();class h extends n{constructor(t){super(t),this.name=Object.keys({RuntimeException:h})[0]}}class u extends h{constructor(){super(),u.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)h.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}}}class g{static shouldNeverReachHere(){if(0===arguments.length)g.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new u("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];g.isTrue(t,null)}else if(2===arguments.length){const t=arguments[1];if(!arguments[0])throw null===t?new u:new u(t)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];g.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new u("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}}const d=new ArrayBuffer(8),_=new Float64Array(d),p=new Int32Array(d);class m{constructor(){m.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)m.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];m.constructor_.call(this,t.x,t.y,t.getZ())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}}static hashCode(t){return _[0]=t,p[0]^p[1]}getM(){return r.NaN}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.setZ(e);break;default:throw new s("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}setM(t){throw new s("Invalid ordinate index: "+m.M)}getZ(){return this.z}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ()}throw new s("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.getZ()===t.getZ()||r.isNaN(this.getZ())&&r.isNaN(t.getZ()))}equals(t){return t instanceof m&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.getZ(),t.getZ(),n)}setX(t){this.x=t}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}getX(){return this.x}setZ(t){this.z=t}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return g.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new m(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.getZ()-t.getZ();return Math.sqrt(e*e+n*n+s*s)}getY(){return this.y}setY(t){this.y=t}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this.x),t=37*t+m.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}get interfaces_(){return[o,l,c]}}class f{constructor(){f.constructor_.apply(this,arguments)}static constructor_(){if(this._dimensionsToTest=2,0===arguments.length)f.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new s("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}}static compare(t,e){return t<e?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0}compare(t,e){const n=f.compare(t.x,e.x);if(0!==n)return n;const s=f.compare(t.y,e.y);if(0!==s)return s;if(this._dimensionsToTest<=2)return 0;return f.compare(t.getZ(),e.getZ())}get interfaces_(){return[a]}}m.DimensionalComparator=f,m.NULL_ORDINATE=r.NaN,m.X=0,m.Y=1,m.Z=2,m.M=3;class y extends m{constructor(){super(),y.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)m.constructor_.call(this);else if(1===arguments.length){if(arguments[0]instanceof y){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];m.constructor_.call(this,t,e,m.NULL_ORDINATE)}}setOrdinate(t,e){switch(t){case y.X:this.x=e;break;case y.Y:this.y=e;break;default:throw new s("Invalid ordinate index: "+t)}}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case y.X:return this.x;case y.Y:return this.y}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new y(this)}toString(){return"("+this.x+", "+this.y+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ()}}y.X=0,y.Y=1,y.Z=-1,y.M=-1;class x extends m{constructor(){super(),x.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof x){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t.x,t.y),this._m=this.getM()}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];m.constructor_.call(this,t,e,m.NULL_ORDINATE),this._m=n}}getM(){return this._m}setOrdinate(t,e){switch(t){case x.X:this.x=e;break;case x.Y:this.y=e;break;case x.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getZ(){return m.NULL_ORDINATE}getOrdinate(t){switch(t){case x.X:return this.x;case x.Y:return this.y;case x.M:return this._m}throw new s("Invalid ordinate index: "+t)}setZ(t){throw new s("CoordinateXY dimension 2 does not support z-ordinate")}copy(){return new x(this)}toString(){return"("+this.x+", "+this.y+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}x.X=0,x.Y=1,x.Z=-1,x.M=2;class E extends m{constructor(){super(),E.constructor_.apply(this,arguments)}static constructor_(){if(this._m=null,0===arguments.length)m.constructor_.call(this),this._m=0;else if(1===arguments.length){if(arguments[0]instanceof E){const t=arguments[0];m.constructor_.call(this,t),this._m=t._m}else if(arguments[0]instanceof m){const t=arguments[0];m.constructor_.call(this,t),this._m=this.getM()}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];m.constructor_.call(this,t,e,n),this._m=s}}getM(){return this._m}setOrdinate(t,e){switch(t){case m.X:this.x=e;break;case m.Y:this.y=e;break;case m.Z:this.z=e;break;case m.M:this._m=e;break;default:throw new s("Invalid ordinate index: "+t)}}setM(t){this._m=t}getOrdinate(t){switch(t){case m.X:return this.x;case m.Y:return this.y;case m.Z:return this.getZ();case m.M:return this.getM()}throw new s("Invalid ordinate index: "+t)}copy(){return new E(this)}toString(){return"("+this.x+", "+this.y+", "+this.getZ()+" m="+this.getM()+")"}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.getZ(),this._m=t.getM()}}function I(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}class N{add(){}addAll(){}isEmpty(){}iterator(){}size(){}toArray(){}remove(){}}class S extends n{constructor(t){super(t),this.name=Object.keys({IndexOutOfBoundsException:S})[0]}}class w extends N{get(){}set(){}isEmpty(){}}class C extends n{constructor(t){super(t),this.name=Object.keys({NoSuchElementException:C})[0]}}class L extends w{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}get interfaces_(){return[w,N]}ensureCapacity(){}add(t){return 1===arguments.length?this.array.push(t):this.array.splice(arguments[0],0,arguments[1]),!0}clear(){this.array=[]}addAll(t){for(const e of t)this.array.push(e)}set(t,e){const n=this.array[t];return this.array[t]=e,n}iterator(){return new T(this)}get(t){if(t<0||t>=this.size())throw new S;return this.array[t]}isEmpty(){return 0===this.array.length}sort(t){t?this.array.sort(((e,n)=>t.compare(e,n))):this.array.sort()}size(){return this.array.length}toArray(){return this.array.slice()}remove(t){for(let e=0,n=this.array.length;e<n;e++)if(this.array[e]===t)return!!this.array.splice(e,1);return!1}[Symbol.iterator](){return this.array.values()}}class T{constructor(t){this.arrayList=t,this.position=0}next(){if(this.position===this.arrayList.size())throw new C;return this.arrayList.get(this.position++)}hasNext(){return this.position<this.arrayList.size()}set(t){return this.arrayList.set(this.position-1,t)}remove(){this.arrayList.remove(this.arrayList.get(this.position))}}class R extends L{constructor(){super(),R.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&I(arguments[0],N)){const t=arguments[1];let e=!1;for(let n=arguments[0].iterator();n.hasNext();)this.add(n.next(),t),e=!0;return e}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){if(0===arguments.length)return this.toArray(R.coordArrayType);if(1===arguments.length){if(arguments[0])return this.toArray(R.coordArrayType);const t=this.size(),e=new Array(t).fill(null);for(let n=0;n<t;n++)e[n]=this.get(t-n-1);return e}}add(){if(1===arguments.length){const t=arguments[0];return super.add.call(this,t)}if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof m&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){if(this.size()>0){const t=this.get(0).copy();this.add(t,!1)}}}R.coordArrayType=new Array(0).fill(null);class P{filter(t,e){}isDone(){}isGeometryChanged(){}}class O{constructor(){O.constructor_.apply(this,arguments)}static constructor_(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof O))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new O;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new O(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof m){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(this.isNull())return!1;if((t.x<e.x?t.x:e.x)>this._maxx)return!1;if((t.x>e.x?t.x:e.x)<this._minx)return!1;if((t.y<e.y?t.y:e.y)>this._maxy)return!1;return!((t.y>e.y?t.y:e.y)<this._miny)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getDiameter(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return Math.sqrt(t*t+e*e)}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}copy(){return new O(this)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}disjoint(t){return!(!this.isNull()&&!t.isNull())||(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof O){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof m){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new m((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof O){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+m.hashCode(this._minx),t=37*t+m.hashCode(this._maxx),t=37*t+m.hashCode(this._miny),t=37*t+m.hashCode(this._maxy),t}get interfaces_(){return[o,c]}}class v{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class M{constructor(t){this.value=t}intValue(){return this.value}compareTo(t){return this.value<t?-1:this.value>t?1:0}static compare(t,e){return t<e?-1:t>e?1:0}static isNan(t){return Number.isNaN(t)}static valueOf(t){return new M(t)}}class b{static isWhitespace(t){return t<=32&&t>=0||127===t}static toUpperCase(t){return t.toUpperCase()}}class D{constructor(){D.constructor_.apply(this,arguments)}static constructor_(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof D){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];D.constructor_.call(this,D.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}}static determinant(){if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return D.determinant(D.valueOf(t),D.valueOf(e),D.valueOf(n),D.valueOf(s))}if(arguments[3]instanceof D&&arguments[2]instanceof D&&arguments[0]instanceof D&&arguments[1]instanceof D){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e))}}static sqr(t){return D.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return D.parse(t)}if("number"==typeof arguments[0]){return new D(arguments[0])}}static sqrt(t){return D.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;b.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new D;let r=0,o=0,l=0,a=!1;for(;!(e>=n);){const n=t.charAt(e);if(e++,b.isDigit(n)){const t=n-"0";i.selfMultiply(D.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=M.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r,a=!0}}let c=i;a||(o=r);const h=r-o-l;if(0===h)c=i;else if(h>0){const t=D.TEN.pow(h);c=i.divide(t)}else if(h<0){const t=D.TEN.pow(-h);c=i.multiply(t)}return s?c.negate():c}static createNaN(){return new D(r.NaN,r.NaN)}static copy(t){return new D(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new v;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=D.magnitude(n._hi);const i=D.TEN.pow(s);n=n.divide(i),n.gt(D.TEN)?(n=n.divide(D.TEN),s+=1):n.lt(D.ONE)&&(n=n.multiply(D.TEN),s-=1);const r=s+1,o=new v,l=D.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(D.valueOf(s)).multiply(D.TEN),i&&n.selfAdd(D.TEN);let c=!0;const h=D.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof D){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof D){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof D){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=D.SPLIT*o,n=l-o,c=D.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof D){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;r=this._hi/t._hi,o=D.SPLIT*r,e=o-r,a=D.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o;return new D(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?D.createNaN():D.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return D.valueOf(1);let e=new D(this),n=D.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return D.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new D(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof D){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return D.valueOf(0);if(this.isNegative())return D.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=D.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof D){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=D.SPLIT*this._hi,n=o-this._hi,l=D.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return D.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new D(t,e)}negate(){return this.isNaN()?this:new D(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof D){const t=arguments[0];return t.isNaN()?D.createNaN():D.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return r.isNaN(t)?D.createNaN():D.copy(this).selfMultiply(t,0)}}isNaN(){return r.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=D.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+D.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+D.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=D.SPLIT*i,t=r-i,l=D.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new D(a,i-a+r)}toSciNotation(){if(this.isZero())return D.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=D.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?D.NaN:this.isNegative()?this.negate():new D(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof D){const t=arguments[0];return D.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return D.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof D){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?D.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}get interfaces_(){return[c,o,l]}}D.PI=new D(3.141592653589793,12246467991473532e-32),D.TWO_PI=new D(6.283185307179586,24492935982947064e-32),D.PI_2=new D(1.5707963267948966,6123233995736766e-32),D.E=new D(2.718281828459045,14456468917292502e-32),D.NaN=new D(r.NaN,r.NaN),D.EPS=123259516440783e-46,D.SPLIT=134217729,D.MAX_PRINT_DIGITS=32,D.TEN=D.valueOf(10),D.ONE=D.valueOf(1),D.SCI_NOT_EXPONENT_CHAR="E",D.SCI_NOT_ZERO="0.0E0";class A{static orientationIndex(t,e,n){const s=A.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=D.valueOf(e.x).selfAdd(-t.x),r=D.valueOf(e.y).selfAdd(-t.y),o=D.valueOf(n.x).selfAdd(-e.x),l=D.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof D&&arguments[2]instanceof D&&arguments[0]instanceof D&&arguments[1]instanceof D){const t=arguments[1],e=arguments[2],n=arguments[3];return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=D.valueOf(t),r=D.valueOf(e),o=D.valueOf(n),l=D.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=new D(t.y).selfSubtract(e.y),o=new D(e.x).selfSubtract(t.x),l=new D(t.x).selfMultiply(e.y).selfSubtract(new D(e.x).selfMultiply(t.y)),a=new D(n.y).selfSubtract(s.y),c=new D(s.x).selfSubtract(n.x),h=new D(n.x).selfMultiply(s.y).selfSubtract(new D(s.x).selfMultiply(n.y)),u=o.multiply(h).selfSubtract(c.multiply(l)),g=a.multiply(l).selfSubtract(i.multiply(h)),d=i.multiply(c).selfSubtract(a.multiply(o)),_=u.selfDivide(d).doubleValue(),p=g.selfDivide(d).doubleValue();return r.isNaN(_)||r.isInfinite(_)||r.isNaN(p)||r.isInfinite(p)?null:new m(_,p)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return A.signum(o);s=i+r}else{if(!(i<0))return A.signum(o);if(r>=0)return A.signum(o);s=-i-r}const l=A.DP_SAFE_EPSILON*s;return o>=l||-o>=l?A.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}}A.DP_SAFE_EPSILON=1e-15;class F{getM(t){if(this.hasM()){const e=this.getDimension()-this.getMeasures();return this.getOrdinate(t,e)}return r.NaN}setOrdinate(t,e,n){}getZ(t){return this.hasZ()?this.getOrdinate(t,2):r.NaN}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}createCoordinate(){}getDimension(){}hasM(){return this.getMeasures()>0}getX(t){}hasZ(){return this.getDimension()-this.getMeasures()>2}getMeasures(){return 0}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}get interfaces_(){return[l]}}F.X=0,F.Y=1,F.Z=2,F.M=3;class G{static index(t,e,n){return A.orientationIndex(t,e,n)}static isCCW(){if(arguments[0]instanceof Array){const t=arguments[0],e=t.length-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t[0],i=0;for(let s=1;s<=e;s++){const e=t[s];e.y>n.y&&(n=e,i=s)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(n)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(n)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(n)||a.equals2D(n)||l.equals2D(a))return!1;const c=G.index(l,n,a);let h=null;return h=0===c?l.x>a.x:c>0,h}if(I(arguments[0],F)){const t=arguments[0],e=t.size()-1;if(e<3)throw new s("Ring has fewer than 4 points, so orientation cannot be determined");let n=t.getCoordinate(0),i=0;for(let s=1;s<=e;s++){const e=t.getCoordinate(s);e.y>n.y&&(n=e,i=s)}let r=null,o=i;do{o-=1,o<0&&(o=e),r=t.getCoordinate(o)}while(r.equals2D(n)&&o!==i);let l=null,a=i;do{a=(a+1)%e,l=t.getCoordinate(a)}while(l.equals2D(n)&&a!==i);if(r.equals2D(n)||l.equals2D(n)||r.equals2D(l))return!1;const c=G.index(r,n,l);let h=null;return h=0===c?r.x>l.x:c>0,h}}}G.CLOCKWISE=-1,G.RIGHT=G.CLOCKWISE,G.COUNTERCLOCKWISE=1,G.LEFT=G.COUNTERCLOCKWISE,G.COLLINEAR=0,G.STRAIGHT=G.COLLINEAR;class q{static intersection(t,e,n,s){const i=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((i>c?i:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2,p=t.x-d,f=t.y-_,y=e.x-d,x=e.y-_,E=n.x-d,I=n.y-_,N=s.x-d,S=s.y-_,w=f-x,C=y-p,L=p*x-y*f,T=I-S,R=N-E,P=E*S-N*I,O=w*R-T*C,v=(C*P-R*L)/O,M=(T*L-w*P)/O;return r.isNaN(v)||r.isInfinite(v)||r.isNaN(M)||r.isInfinite(M)?null:new m(v+d,M+_)}}class B{static arraycopy(t,e,n,s,i){let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++}static getProperty(t){return{"line.separator":"\n"}[t]}}class Y{static log10(t){const e=Math.log(t);return r.isInfinite(e)||r.isNaN(e)?e:e/Y.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[1],e=arguments[2];let n=arguments[0];return t>n&&(n=t),e>n&&(n=e),n}if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];let s=arguments[0];return t>s&&(s=t),e>s&&(s=e),n>s&&(s=n),s}}static average(t,e){return(t+e)/2}}Y.LOG_10=Math.log(10);class V{static segmentToSegment(t,e,n,s){if(t.equals(e))return V.pointToSegment(t,n,s);if(n.equals(s))return V.pointToSegment(s,t,e);let i=!1;if(O.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?Y.min(V.pointToSegment(t,n,s),V.pointToSegment(e,n,s),V.pointToSegment(n,t,e),V.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new s("Line array must contain at least one vertex");let n=t.distance(e[0]);for(let s=0;s<e.length-1;s++){const i=V.pointToSegment(t,e[s],e[s+1]);i<n&&(n=i)}return n}}class z{create(){if(1===arguments.length)arguments[0]instanceof Array||I(arguments[0],F);else if(2===arguments.length);else if(3===arguments.length){const t=arguments[0],e=arguments[1];return this.create(t,e)}}}class k{filter(t){}}class X{constructor(){X.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===X.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(X.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}checkNotGeometryCollection(t){if(t.getTypeCode()===X.TYPECODE_GEOMETRYCOLLECTION)throw new s("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}reverse(){const t=this.reverseInternal();return null!=this.envelope&&(t.envelope=this.envelope.copy()),t.setSRID(this.getSRID()),t}copy(){const t=this.copyInternal();return t.envelope=null==this._envelope?null:this._envelope.copy(),t._SRID=this._SRID,t._userData=this._userData,t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new O(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isEquivalentClass(t){return this.getClass()===t.getClass()}isGeometryCollectionOrDerived(){return this.getTypeCode()===X.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===X.TYPECODE_MULTIPOINT||this.getTypeCode()===X.TYPECODE_MULTILINESTRING||this.getTypeCode()===X.TYPECODE_MULTIPOLYGON}get interfaces_(){return[l,o,c]}getClass(){return X}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}X.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},X.TYPECODE_POINT=0,X.TYPECODE_MULTIPOINT=1,X.TYPECODE_LINESTRING=2,X.TYPECODE_LINEARRING=3,X.TYPECODE_MULTILINESTRING=4,X.TYPECODE_POLYGON=5,X.TYPECODE_MULTIPOLYGON=6,X.TYPECODE_GEOMETRYCOLLECTION=7,X.TYPENAME_POINT="Point",X.TYPENAME_MULTIPOINT="MultiPoint",X.TYPENAME_LINESTRING="LineString",X.TYPENAME_LINEARRING="LinearRing",X.TYPENAME_MULTILINESTRING="MultiLineString",X.TYPENAME_POLYGON="Polygon",X.TYPENAME_MULTIPOLYGON="MultiPolygon",X.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",X.geometryChangedFilter={get interfaces_(){return[k]},filter(t){t.geometryChangedAction()}};class U{filter(t){}}class H{static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new m;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}}class W{}class Z{static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,F.X)===t.getOrdinate(e-1,F.X)&&t.getOrdinate(0,F.Y)===t.getOrdinate(e-1,F.Y))}static scroll(){if(2===arguments.length){if(I(arguments[0],F)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];Z.scroll(t,e,Z.isRing(t))}else if(I(arguments[0],F)&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=Z.indexOf(e,t);if(n<=0)return null;Z.scroll(t,n)}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(e<=0)return null;const s=t.copy(),i=n?t.size()-1:t.size();for(let n=0;n<i;n++)for(let r=0;r<t.getDimension();r++)t.setOrdinate(n,r,s.getOrdinate((e+n)%i,r));if(n)for(let e=0;e<t.getDimension();e++)t.setOrdinate(i,e,t.getOrdinate(0,e))}}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let i=0;i<n;i++)for(let n=0;n<s;n++){const s=t.getOrdinate(i,n),o=e.getOrdinate(i,n);if(t.getOrdinate(i,n)!==e.getOrdinate(i,n)&&(!r.isNaN(s)||!r.isNaN(o)))return!1}return!0}static minCoordinateIndex(){if(1===arguments.length){const t=arguments[0];return Z.minCoordinateIndex(t,0,t.size()-1)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=-1,s=null;for(let i=arguments[1];i<=e;i++){const e=t.getCoordinate(i);(null===s||s.compareTo(e)>0)&&(s=e,n=i)}return n}}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(Z.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)Z.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)Z.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)Z.copyCoord(t,e+r,n,s+r)}static ensureValidRing(t,e){const n=e.size();if(0===n)return e;if(n<=3)return Z.createClosedRing(t,e,4);return e.getOrdinate(0,F.X)===e.getOrdinate(n-1,F.X)&&e.getOrdinate(0,F.Y)===e.getOrdinate(n-1,F.Y)?e:Z.createClosedRing(t,e,n+1)}static indexOf(t,e){for(let n=0;n<e.size();n++)if(t.x===e.getOrdinate(n,F.X)&&t.y===e.getOrdinate(n,F.Y))return n;return-1}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();Z.copy(e,0,s,0,i);for(let t=i;t<n;t++)Z.copy(e,0,s,t,1);return s}static minCoordinate(t){let e=null;for(let n=0;n<t.size();n++){const s=t.getCoordinate(n);(null===e||e.compareTo(s)>0)&&(e=s)}return e}}class j extends n{constructor(t){super(t),this.name=Object.keys({UnsupportedOperationException:j})[0]}}class K{static toDimensionSymbol(t){switch(t){case K.FALSE:return K.SYM_FALSE;case K.TRUE:return K.SYM_TRUE;case K.DONTCARE:return K.SYM_DONTCARE;case K.P:return K.SYM_P;case K.L:return K.SYM_L;case K.A:return K.SYM_A}throw new s("Unknown dimension value: "+t)}static toDimensionValue(t){switch(b.toUpperCase(t)){case K.SYM_FALSE:return K.FALSE;case K.SYM_TRUE:return K.TRUE;case K.SYM_DONTCARE:return K.DONTCARE;case K.SYM_P:return K.P;case K.SYM_L:return K.L;case K.SYM_A:return K.A}throw new s("Unknown dimension symbol: "+t)}}K.P=0,K.L=1,K.A=2,K.FALSE=-1,K.TRUE=-2,K.DONTCARE=-3,K.SYM_FALSE="F",K.SYM_TRUE="T",K.SYM_DONTCARE="*",K.SYM_P="0",K.SYM_L="1",K.SYM_A="2";class Q{filter(t){}}class J extends X{constructor(){super(),J.constructor_.apply(this,arguments)}static constructor_(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];X.constructor_.call(this,e),this.init(t)}}computeEnvelopeInternal(){return this.isEmpty()?new O:this._points.expandEnvelope(new O)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}copyInternal(){return new J(this._points.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Z.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?K.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}reverseInternal(){const t=this._points.copy();return Z.reverse(t),this.getFactory().createLineString(t)}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return X.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return H.ofLine(this._points)}getNumPoints(){return this._points.size()}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(I(arguments[0],U)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){throw new j}isEquivalentClass(t){return t instanceof J}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return X.TYPENAME_LINESTRING}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new s("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}get interfaces_(){return[W]}}class ${}class tt extends X{constructor(){super(),tt.constructor_.apply(this,arguments)}static constructor_(){this._coordinates=null;const t=arguments[0],e=arguments[1];X.constructor_.call(this,e),this.init(t)}computeEnvelopeInternal(){if(this.isEmpty())return new O;const t=new O;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}copyInternal(){return new tt(this._coordinates.copy(),this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return K.FALSE}reverseInternal(){return this.getFactory().createPoint(this._coordinates.copy())}getTypeCode(){return X.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}getX(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(I(arguments[0],U)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(I(arguments[0],P)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){arguments[0].filter(this)}else if(I(arguments[0],k)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return X.TYPENAME_POINT}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),g.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}get interfaces_(){return[$]}}class et{static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(et.ofRingSigned(t))}if(I(arguments[0],F)){const t=arguments[0];return Math.abs(et.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(I(arguments[0],F)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new m,s=new m,i=new m;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}}class nt{static sort(){const t=arguments[0];if(1===arguments.length)t.sort(((t,e)=>t.compareTo(e)));else if(2===arguments.length)t.sort(((t,e)=>arguments[1].compare(t,e)));else if(3===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort();const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}else if(4===arguments.length){const e=t.slice(arguments[1],arguments[2]);e.sort(((t,e)=>arguments[3].compare(t,e)));const n=t.slice(0,arguments[1]).concat(e,t.slice(arguments[2],t.length));t.splice(0,t.length);for(const e of n)t.push(e)}}static asList(t){const e=new L;for(const n of t)e.add(n);return e}static copyOf(t,e){return t.slice(0,e)}}class st{}class it extends X{constructor(){super(),it.constructor_.apply(this,arguments)}static constructor_(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1],n=arguments[2];if(X.constructor_.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),X.hasNullElements(e))throw new s("holes must not contain null elements");if(t.isEmpty()&&X.hasNonEmptyElements(e))throw new s("shell is empty but holes are not");this._shell=t,this._holes=e}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=et.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=et.ofRing(this._holes[e].getCoordinateSequence());return t}copyInternal(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new it(t,e,this._factory)}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this._shell=this.normalized(this._shell,!0);for(let t=0;t<this._holes.length;t++)this._holes[t]=this.normalized(this._holes[t],!1);nt.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=t.getCoordinateSequence(),s=Z.minCoordinateIndex(n,0,n.size()-2);Z.scroll(n,s,!0),G.isCCW(n)===e&&Z.reverse(n)}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}reverseInternal(){const t=this.getExteriorRing().reverse(),e=new Array(this.getNumInteriorRing()).fill(null);for(let t=0;t<e.length;t++)e[t]=this.getInteriorRingN(t).reverse();return this.getFactory().createPolygon(t,e)}getTypeCode(){return X.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}convexHull(){return this.getExteriorRing().convexHull()}normalized(t,e){const n=t.copy();return this.normalize(n,e),n}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this._shell,s=e._shell,i=n.compareToSameClass(s,t);if(0!==i)return i;const r=this.getNumInteriorRing(),o=e.getNumInteriorRing();let l=0;for(;l<r&&l<o;){const n=this.getInteriorRingN(l),s=e.getInteriorRingN(l),i=n.compareToSameClass(s,t);if(0!==i)return i;l++}return l<r?1:l<o?-1:0}}apply(){if(I(arguments[0],U)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){arguments[0].filter(this)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return X.TYPENAME_POLYGON}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}get interfaces_(){return[st]}}class rt extends N{contains(){}}class ot extends rt{}class lt extends ot{constructor(t){super(),this.array=[],t instanceof N&&this.addAll(t)}contains(t){for(const e of this.array)if(0===e.compareTo(t))return!0;return!1}add(t){if(this.contains(t))return!1;for(let e=0,n=this.array.length;e<n;e++){if(1===this.array[e].compareTo(t))return!!this.array.splice(e,0,t)}return this.array.push(t),!0}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new j}size(){return this.array.length}isEmpty(){return 0===this.array.length}toArray(){return this.array.slice()}iterator(){return new at(this.array)}}class at{constructor(t){this.array=t,this.position=0}next(){if(this.position===this.array.length)throw new C;return this.array[this.position++]}hasNext(){return this.position<this.array.length}remove(){throw new j}}class ct extends X{constructor(){super(),ct.constructor_.apply(this,arguments)}static constructor_(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0],e=arguments[1];if(X.constructor_.call(this,e),null===t&&(t=[]),X.hasNullElements(t))throw new s("geometries must not contain null elements");this._geometries=t}}computeEnvelopeInternal(){const t=new O;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ct(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();nt.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=K.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}reverseInternal(){const t=this._geometries.length,e=new L(t);for(let n=0;n<t;n++)e.add(this._geometries[n].reverse());return this.getFactory().buildGeometry(e)}getTypeCode(){return X.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=K.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new lt(nt.asList(this._geometries)),n=new lt(nt.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[1],e=arguments[0],n=this.getNumGeometries(),s=e.getNumGeometries();let i=0;for(;i<n&&i<s;){const n=this.getGeometryN(i),s=e.getGeometryN(i),r=n.compareToSameClass(s,t);if(0!==r)return r;i++}return i<n?1:i<s?-1:0}}apply(){if(I(arguments[0],U)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],P)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(I(arguments[0],Q)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(I(arguments[0],k)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return X.checkNotGeometryCollection(this),g.shouldNeverReachHere(),null}getGeometryType(){return X.TYPENAME_GEOMETRYCOLLECTION}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}}class ht extends ct{constructor(){super(),ht.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ct.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ht(t,this._factory)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return K.FALSE}getTypeCode(){return X.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return X.TYPENAME_MULTIPOINT}get interfaces_(){return[$]}}class ut extends J{constructor(){super(),ut.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];J.constructor_.call(this,t,e),this.validateConstruction()}copyInternal(){return new ut(this._points.copy(),this._factory)}getBoundaryDimension(){return K.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}reverseInternal(){const t=this._points.copy();return Z.reverse(t),this.getFactory().createLinearRing(t)}getTypeCode(){return X.TYPECODE_LINEARRING}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new s("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<ut.MINIMUM_VALID_SIZE)throw new s("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return X.TYPENAME_LINEARRING}}ut.MINIMUM_VALID_SIZE=4;class gt{static measures(t){return t instanceof y?0:t instanceof x||t instanceof E?1:0}static dimension(t){return t instanceof y?2:t instanceof x?3:t instanceof E?4:3}static create(){if(1===arguments.length){const t=arguments[0];return gt.create(t,0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return 2===t?new y:3===t&&0===e?new m:3===t&&1===e?new x:4===t&&1===e?new E:new m}}}class dt{static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(dt.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=dt.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);B.arraycopy(t,n,s,0,t.length-n),B.arraycopy(t,0,s,t.length-n,n),B.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new R;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static measures(t){if(null===t||0===t.length)return 0;let e=0;for(const n of t)e=Math.max(e,gt.measures(n));return e}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!dt.hasRepeatedPoints(t))return t;return new R(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=t[n].copy();return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=t[e+r].copy()}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new O;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(dt.coordArrayType)}static dimension(t){if(null===t||0===t.length)return 3;let e=0;for(const n of t)e=Math.max(e,gt.dimension(n));return e}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=Y.clamp(e,0,t.length);let s=(n=Y.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}}dt.ForwardComparator=class{compare(t,e){const n=t,s=e;return dt.compare(n,s)}get interfaces_(){return[a]}},dt.BidirectionalComparator=class{compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=dt.compare(n,s);return dt.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=dt.increasingDirection(n),r=dt.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}get interfaces_(){return[a]}},dt.coordArrayType=new Array(0).fill(null);class _t{constructor(t){this.str=t}append(t){this.str+=t}setCharAt(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)}toString(){return this.str}}class pt{constructor(){pt.constructor_.apply(this,arguments)}static constructor_(){if(this._dimension=3,this._measures=0,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];pt.constructor_.call(this,t,dt.dimension(t),dt.measures(t))}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new m}else if(I(arguments[0],F)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._measures=t.getMeasures(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length){if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];pt.constructor_.call(this,t,e,dt.measures(t))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let n=0;n<t;n++)this._coordinates[n]=gt.create(e)}}else if(3===arguments.length)if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._dimension=e,this._measures=n,this._coordinates=null===t?new Array(0).fill(null):t}else if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];this._coordinates=new Array(t).fill(null),this._dimension=e,this._measures=n;for(let e=0;e<t;e++)this._coordinates[e]=this.createCoordinate()}}getM(t){return this.hasM()?this._coordinates[t].getM():r.NaN}setOrdinate(t,e,n){switch(e){case F.X:this._coordinates[t].x=n;break;case F.Y:this._coordinates[t].y=n;break;default:this._coordinates[t].setOrdinate(e,n)}}getZ(t){return this.hasZ()?this._coordinates[t].getZ():r.NaN}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case F.X:return this._coordinates[t].x;case F.Y:return this._coordinates[t].y;default:return this._coordinates[t].getOrdinate(e)}}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0];arguments[1].setCoordinate(this._coordinates[t])}}getCoordinateCopy(t){const e=this.createCoordinate();return e.setCoordinate(this._coordinates[t]),e}createCoordinate(){return gt.create(this.getDimension(),this.getMeasures())}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}getMeasures(){return this._measures}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++){const n=this.createCoordinate();n.setCoordinate(this._coordinates[e]),t[e]=n}return new pt(t,this._dimension,this._measures)}toString(){if(this._coordinates.length>0){const t=new _t(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}get interfaces_(){return[F,c]}}class mt{static instance(){return mt.instanceObject}readResolve(){return mt.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){return new pt(arguments[0])}if(I(arguments[0],F)){return new pt(arguments[0])}}else{if(2===arguments.length){let t=arguments[1];return t>3&&(t=3),t<2&&(t=2),new pt(arguments[0],t)}if(3===arguments.length){let t=arguments[2],e=arguments[1]-t;return t>1&&(t=1),e>3&&(e=3),e<2&&(e=2),new pt(arguments[0],e+t,t)}}}get interfaces_(){return[z,c]}}mt.instanceObject=new mt;class ft extends ct{constructor(){super(),ft.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ct.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ft(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return X.TYPECODE_MULTIPOLYGON}getDimension(){return 2}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new L;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return X.TYPENAME_MULTIPOLYGON}get interfaces_(){return[st]}}class yt{get(){}put(){}size(){}values(){}entrySet(){}}class xt extends rt{constructor(t){super(),this.map=new Map,t instanceof N&&this.addAll(t)}contains(t){const e=t.hashCode?t.hashCode():t;return!!this.map.has(e)}add(t){const e=t.hashCode?t.hashCode():t;return!this.map.has(e)&&!!this.map.set(e,t)}addAll(t){for(const e of t)this.add(e);return!0}remove(){throw new j}size(){return this.map.size}isEmpty(){return 0===this.map.size}toArray(){return Array.from(this.map.values())}iterator(){return new Et(this.map)}[Symbol.iterator](){return this.map}}class Et{constructor(t){this.iterator=t.values();const{done:e,value:n}=this.iterator.next();this.done=e,this.value=n}next(){if(this.done)throw new C;const t=this.value,{done:e,value:n}=this.iterator.next();return this.done=e,this.value=n,t}hasNext(){return!this.done}remove(){throw new j}}class It extends yt{constructor(){super(),this.map=new Map}get(t){return this.map.get(t)||null}put(t,e){return this.map.set(t,e),e}values(){const t=new L,e=this.map.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t}entrySet(){const t=new xt;return this.map.entries().forEach((e=>t.add(e))),t}size(){return this.map.size()}}class Nt{constructor(){Nt.constructor_.apply(this,arguments)}static constructor_(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=Nt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof St){const t=arguments[0];this._modelType=t,t===Nt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=Nt.FIXED,this.setScale(t)}else if(arguments[0]instanceof Nt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof Nt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return M.compare(n,s)}getScale(){return this._scale}isFloating(){return this._modelType===Nt.FLOATING||this._modelType===Nt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===Nt.FLOATING?t="Floating":this._modelType===Nt.FLOATING_SINGLE?t="Floating-Single":this._modelType===Nt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(r.isNaN(t))return t;if(this._modelType===Nt.FLOATING_SINGLE){return t}return this._modelType===Nt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof m){const t=arguments[0];if(this._modelType===Nt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===Nt.FLOATING?t=16:this._modelType===Nt.FLOATING_SINGLE?t=6:this._modelType===Nt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}get interfaces_(){return[c,o]}}class St{constructor(){St.constructor_.apply(this,arguments)}static constructor_(){this._name=null;const t=arguments[0];this._name=t,St.nameToTypeMap.put(t,this)}readResolve(){return St.nameToTypeMap.get(this._name)}toString(){return this._name}get interfaces_(){return[c]}}St.nameToTypeMap=new It,Nt.Type=St,Nt.FIXED=new St("FIXED"),Nt.FLOATING=new St("FLOATING"),Nt.FLOATING_SINGLE=new St("FLOATING SINGLE"),Nt.maximumPreciseValue=9007199254740992;class wt extends ct{constructor(){super(),wt.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ct.constructor_.call(this,t,e)}copyInternal(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new wt(t,this._factory)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof X){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?K.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return X.TYPECODE_MULTILINESTRING}getDimension(){return 1}getBoundary(){throw new j}getGeometryType(){return X.TYPENAME_MULTILINESTRING}get interfaces_(){return[W]}}class Ct{constructor(){Ct.constructor_.apply(this,arguments)}static constructor_(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Ct.constructor_.call(this,new Nt,0);else if(1===arguments.length){if(I(arguments[0],z)){const t=arguments[0];Ct.constructor_.call(this,new Nt,0,t)}else if(arguments[0]instanceof Nt){const t=arguments[0];Ct.constructor_.call(this,t,0,Ct.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ct.constructor_.call(this,t,e,Ct.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return mt.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}createEmpty(t){switch(t){case-1:return this.createGeometryCollection();case 0:return this.createPoint();case 1:return this.createLineString();case 2:return this.createPolygon();default:throw new s("Invalid dimension: "+t)}}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new m(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new m(t.getMinX(),t.getMinY()),new m(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new m(t.getMinX(),t.getMinY()),new m(t.getMinX(),t.getMaxY()),new m(t.getMaxX(),t.getMaxY()),new m(t.getMaxX(),t.getMinY()),new m(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],F)){return new J(arguments[0],this)}}}createMultiLineString(){if(0===arguments.length)return new wt(null,this);if(1===arguments.length){return new wt(arguments[0],this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getTypeCode();null===e&&(e=r),r!==e&&(n=!0),t instanceof ct&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Ct.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof it)return this.createMultiPolygon(Ct.toPolygonArray(t));if(i instanceof J)return this.createMultiLineString(Ct.toLineStringArray(t));if(i instanceof tt)return this.createMultiPoint(Ct.toPointArray(t));g.shouldNeverReachHere("Unhandled geometry type: "+i.getGeometryType())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof m){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(I(arguments[0],F)){return new tt(arguments[0],this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(I(arguments[0],F)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof ut){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){return new it(arguments[0],arguments[1],this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new ct(null,this);if(1===arguments.length){return new ct(arguments[0],this)}}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(I(arguments[0],F)){return new ut(arguments[0],this)}}}createMultiPolygon(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){return new ft(arguments[0],this)}}createMultiPoint(){if(0===arguments.length)return new ht(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){return new ht(arguments[0],this)}if(I(arguments[0],F)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension(),t.getMeasures());Z.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}get interfaces_(){return[c]}}const Lt="XY",Tt="XYZ",Rt="XYM",Pt="XYZM",Ot={POINT:"Point",LINE_STRING:"LineString",LINEAR_RING:"LinearRing",POLYGON:"Polygon",MULTI_POINT:"MultiPoint",MULTI_LINE_STRING:"MultiLineString",MULTI_POLYGON:"MultiPolygon",GEOMETRY_COLLECTION:"GeometryCollection",CIRCLE:"Circle"},vt="EMPTY",Mt=1,bt=2,Dt=3,At=4,Ft=5,Gt=6,qt={};for(const t in Ot)qt[t]=Ot[t].toUpperCase();class Bt{constructor(t){this.wkt=t,this.index_=-1}isAlpha_(t){return t>="a"&&t<="z"||t>="A"&&t<="Z"}isNumeric_(t,e){return t>="0"&&t<="9"||"."==t&&!(void 0!==e&&e)}isWhiteSpace_(t){return" "==t||"\t"==t||"\r"==t||"\n"==t}nextChar_(){return this.wkt.charAt(++this.index_)}nextToken(){const t=this.nextChar_(),e=this.index_;let n,s=t;if("("==t)n=bt;else if(","==t)n=Ft;else if(")"==t)n=Dt;else if(this.isNumeric_(t)||"-"==t)n=At,s=this.readNumber_();else if(this.isAlpha_(t))n=Mt,s=this.readText_();else{if(this.isWhiteSpace_(t))return this.nextToken();if(""!==t)throw new Error("Unexpected character: "+t);n=Gt}return{position:e,value:s,type:n}}readNumber_(){let t;const e=this.index_;let n=!1,s=!1;do{"."==t?n=!0:"e"!=t&&"E"!=t||(s=!0),t=this.nextChar_()}while(this.isNumeric_(t,n)||!s&&("e"==t||"E"==t)||s&&("-"==t||"+"==t));return parseFloat(this.wkt.substring(e,this.index_--))}readText_(){let t;const e=this.index_;do{t=this.nextChar_()}while(this.isAlpha_(t));return this.wkt.substring(e,this.index_--).toUpperCase()}}class Yt{constructor(t,e){this.lexer_=t,this.token_,this.layout_=Lt,this.factory=e}consume_(){this.token_=this.lexer_.nextToken()}isTokenType(t){return this.token_.type==t}match(t){const e=this.isTokenType(t);return e&&this.consume_(),e}parse(){this.consume_();return this.parseGeometry_()}parseGeometryLayout_(){let t=Lt;const e=this.token_;if(this.isTokenType(Mt)){const n=e.value;"Z"===n?t=Tt:"M"===n?t=Rt:"ZM"===n&&(t=Pt),t!==Lt&&this.consume_()}return t}parseGeometryCollectionText_(){if(this.match(bt)){const t=[];do{t.push(this.parseGeometry_())}while(this.match(Ft));if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePointText_(){if(this.match(bt)){const t=this.parsePoint_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return null;throw new Error(this.formatErrorMessage_())}parseLineStringText_(){if(this.match(bt)){const t=this.parsePointList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePolygonText_(){if(this.match(bt)){const t=this.parseLineStringTextList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPointText_(){if(this.match(bt)){let t;if(t=this.token_.type==bt?this.parsePointTextList_():this.parsePointList_(),this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiLineStringText_(){if(this.match(bt)){const t=this.parseLineStringTextList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parseMultiPolygonText_(){if(this.match(bt)){const t=this.parsePolygonTextList_();if(this.match(Dt))return t}else if(this.isEmptyGeometry_())return[];throw new Error(this.formatErrorMessage_())}parsePoint_(){const t=[],e=this.layout_.length;for(let n=0;n<e;++n){const e=this.token_;if(!this.match(At))break;t.push(e.value)}if(t.length==e)return t;throw new Error(this.formatErrorMessage_())}parsePointList_(){const t=[this.parsePoint_()];for(;this.match(Ft);)t.push(this.parsePoint_());return t}parsePointTextList_(){const t=[this.parsePointText_()];for(;this.match(Ft);)t.push(this.parsePointText_());return t}parseLineStringTextList_(){const t=[this.parseLineStringText_()];for(;this.match(Ft);)t.push(this.parseLineStringText_());return t}parsePolygonTextList_(){const t=[this.parsePolygonText_()];for(;this.match(Ft);)t.push(this.parsePolygonText_());return t}isEmptyGeometry_(){const t=this.isTokenType(Mt)&&this.token_.value==vt;return t&&this.consume_(),t}formatErrorMessage_(){return"Unexpected `"+this.token_.value+"` at position "+this.token_.position+" in `"+this.lexer_.wkt+"`"}parseGeometry_(){const t=this.factory,e=t=>new m(...t),n=n=>{const s=n.map((n=>t.createLinearRing(n.map(e))));return s.length>1?t.createPolygon(s[0],s.slice(1)):t.createPolygon(s[0])},s=this.token_;if(this.match(Mt)){const i=s.value;if(this.layout_=this.parseGeometryLayout_(),"GEOMETRYCOLLECTION"==i){const e=this.parseGeometryCollectionText_();return t.createGeometryCollection(e)}switch(i){case"POINT":{const e=this.parsePointText_();return e?t.createPoint(new m(...e)):t.createPoint()}case"LINESTRING":{const n=this.parseLineStringText_().map(e);return t.createLineString(n)}case"LINEARRING":{const n=this.parseLineStringText_().map(e);return t.createLinearRing(n)}case"POLYGON":{const e=this.parsePolygonText_();return e&&0!==e.length?n(e):t.createPolygon()}case"MULTIPOINT":{const n=this.parseMultiPointText_();if(!n||0===n.length)return t.createMultiPoint();const s=n.map(e).map((e=>t.createPoint(e)));return t.createMultiPoint(s)}case"MULTILINESTRING":{const n=this.parseMultiLineStringText_().map((n=>t.createLineString(n.map(e))));return t.createMultiLineString(n)}case"MULTIPOLYGON":{const e=this.parseMultiPolygonText_();if(!e||0===e.length)return t.createMultiPolygon();const s=e.map(n);return t.createMultiPolygon(s)}default:throw new Error("Invalid geometry type: "+i)}}throw new Error(this.formatErrorMessage_())}}function Vt(t){if(t.isEmpty())return"";const e=t.getCoordinate(),n=[e.x,e.y];return e.z&&n.push(e.z),e.m&&n.push(e.m),n.join(" ")}function zt(t){const e=t.getCoordinates().map((t=>[t.x,t.y])),n=[];for(let t=0,s=e.length;t<s;++t)n.push(e[t].join(" "));return n.join(", ")}function kt(t){const e=[];e.push("("+zt(t.getExteriorRing())+")");for(let n=0,s=t.getNumInteriorRing();n<s;++n)e.push("("+zt(t.getInteriorRingN(n))+")");return e.join(", ")}const Xt={Point:Vt,LineString:zt,LinearRing:zt,Polygon:kt,MultiPoint:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+Vt(t.getGeometryN(n))+")");return e.join(", ")},MultiLineString:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+zt(t.getGeometryN(n))+")");return e.join(", ")},MultiPolygon:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push("("+kt(t.getGeometryN(n))+")");return e.join(", ")},GeometryCollection:function(t){const e=[];for(let n=0,s=t.getNumGeometries();n<s;++n)e.push(Ut(t.getGeometryN(n)));return e.join(", ")}};function Ut(t){let e=t.getGeometryType();const n=Xt[e];e=e.toUpperCase();const s=function(t){let e="";if(t.isEmpty())return e;const n=t.getCoordinate();return n.z&&(e+="Z"),n.m&&(e+="M"),e}(t);if(s.length>0&&(e+=" "+s),t.isEmpty())return e+" "+vt;return e+" ("+n(t)+")"}class Ht{constructor(t){this.geometryFactory=t||new Ct,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){const e=new Bt(t);return new Yt(e,this.geometryFactory).parse()}write(t){return Ut(t)}}class Wt{constructor(t){this.parser=new Ht(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class Zt{constructor(){Zt.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._inputLines=Array(2).fill().map((()=>Array(2))),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new m,this._intPt[1]=new m,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return g.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return g.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new _t;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map((()=>Array(2))),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==Zt.NO_INTERSECTION}getEdgeDistance(t,e){return Zt.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===Zt.COLLINEAR_INTERSECTION}toString(){return Wt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Wt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}}Zt.DONT_INTERSECT=0,Zt.DO_INTERSECT=1,Zt.COLLINEAR=2,Zt.NO_INTERSECTION=0,Zt.POINT_INTERSECTION=1,Zt.COLLINEAR_INTERSECTION=2;class jt extends Zt{constructor(){super()}static nearestEndpoint(t,e,n,s){let i=t,r=V.pointToSegment(t,n,s),o=V.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=V.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=V.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new O(this._inputLines[0][0],this._inputLines[0][1]),n=new O(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,O.intersects(e,n,t)&&0===G.index(e,n,t)&&0===G.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=Zt.POINT_INTERSECTION,null;this._result=Zt.NO_INTERSECTION}}intersection(t,e,n,s){let i=this.intersectionSafe(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new m(jt.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}checkDD(t,e,n,s,i){const r=A.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);B.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&B.out.println("Distance = "+i.distance(r))}intersectionSafe(t,e,n,s){let i=q.intersection(t,e,n,s);return null===i&&(i=jt.nearestEndpoint(t,e,n,s)),i}computeCollinearIntersection(t,e,n,s){const i=O.intersects(t,e,n),r=O.intersects(t,e,s),o=O.intersects(n,s,t),l=O.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,Zt.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,Zt.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?Zt.COLLINEAR_INTERSECTION:Zt.POINT_INTERSECTION):Zt.NO_INTERSECTION}computeIntersect(t,e,n,s){if(this._isProper=!1,!O.intersects(t,e,n,s))return Zt.NO_INTERSECTION;const i=G.index(t,e,n),r=G.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return Zt.NO_INTERSECTION;const o=G.index(n,s,t),l=G.index(n,s,e);if(o>0&&l>0||o<0&&l<0)return Zt.NO_INTERSECTION;return 0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new m(n):0===r?this._intPt[0]=new m(s):0===o?this._intPt[0]=new m(t):0===l&&(this._intPt[0]=new m(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),Zt.POINT_INTERSECTION)}}class Kt{constructor(){Kt.constructor_.apply(this,arguments)}static constructor_(){if(this.p0=null,this.p1=null,0===arguments.length)Kt.constructor_.call(this,new m,new m);else if(1===arguments.length){const t=arguments[0];Kt.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,new m(t,e),new m(n,s))}}static midPoint(t,e){return new m((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof Kt){const t=arguments[0],e=G.index(this.p0,this.p1,t.p0),n=G.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof m){const t=arguments[0];return G.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof Kt))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new jt;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof m){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new m(t);const e=this.projectionFactor(t),n=new m;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof Kt){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new Kt(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return V.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return Kt.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;if(s<=0)return r.NaN;return((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=r.MAX_VALUE,i=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);i=l.distance(t.p1),i<s&&(s=i,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);i=a.distance(this.p0),i<s&&(s=i,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return i=c.distance(this.p1),i<s&&(s=i,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){return q.intersection(this.p0,this.p1,t.p0,t.p1)}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new m(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||r.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}reflect(t){const e=this.p1.getY()-this.p0.getY(),n=this.p0.getX()-this.p1.getX(),s=this.p0.getY()*(this.p1.getX()-this.p0.getX())-this.p0.getX()*(this.p1.getY()-this.p0.getY()),i=e*e+n*n,r=e*e-n*n,o=t.getX(),l=t.getY();return new m((-r*o-2*e*n*l-2*e*s)/i,(r*l-2*e*n*o-2*n*s)/i)}distance(){if(arguments[0]instanceof Kt){const t=arguments[0];return V.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof m){const t=arguments[0];return V.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new m;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=r.doubleToLongBits(this.p0.x);t^=31*r.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=r.doubleToLongBits(this.p1.x);n^=31*r.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))}get interfaces_(){return[o,c]}}class Qt{static toLocationSymbol(t){switch(t){case Qt.EXTERIOR:return"e";case Qt.BOUNDARY:return"b";case Qt.INTERIOR:return"i";case Qt.NONE:return"-"}throw new s("Unknown location value: "+t)}}Qt.INTERIOR=0,Qt.BOUNDARY=1,Qt.EXTERIOR=2,Qt.NONE=-1;class Jt{constructor(){Jt.constructor_.apply(this,arguments)}static constructor_(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map((()=>Array(3))),this.setAll(K.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];Jt.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof Jt){const t=arguments[0];Jt.constructor_.call(this),this._matrix[Qt.INTERIOR][Qt.INTERIOR]=t._matrix[Qt.INTERIOR][Qt.INTERIOR],this._matrix[Qt.INTERIOR][Qt.BOUNDARY]=t._matrix[Qt.INTERIOR][Qt.BOUNDARY],this._matrix[Qt.INTERIOR][Qt.EXTERIOR]=t._matrix[Qt.INTERIOR][Qt.EXTERIOR],this._matrix[Qt.BOUNDARY][Qt.INTERIOR]=t._matrix[Qt.BOUNDARY][Qt.INTERIOR],this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]=t._matrix[Qt.BOUNDARY][Qt.BOUNDARY],this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]=t._matrix[Qt.BOUNDARY][Qt.EXTERIOR],this._matrix[Qt.EXTERIOR][Qt.INTERIOR]=t._matrix[Qt.EXTERIOR][Qt.INTERIOR],this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]=t._matrix[Qt.EXTERIOR][Qt.BOUNDARY],this._matrix[Qt.EXTERIOR][Qt.EXTERIOR]=t._matrix[Qt.EXTERIOR][Qt.EXTERIOR]}}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===K.SYM_DONTCARE||(e===K.SYM_TRUE&&(t>=0||t===K.TRUE)||(e===K.SYM_FALSE&&t===K.FALSE||(e===K.SYM_P&&t===K.P||(e===K.SYM_L&&t===K.L||e===K.SYM_A&&t===K.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[1];return new Jt(arguments[0]).matches(t)}}static isTrue(t){return t>=0||t===K.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===K.FALSE}isCoveredBy(){return(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]))&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===K.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=K.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===K.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,K.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===K.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===K.A&&e===K.A||t===K.L&&e===K.L||t===K.L&&e===K.A||t===K.P&&e===K.A||t===K.P&&e===K.L)&&(this._matrix[Qt.INTERIOR][Qt.INTERIOR]===K.FALSE&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.BOUNDARY])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.INTERIOR])||Jt.isTrue(this._matrix[Qt.BOUNDARY][Qt.BOUNDARY])))}isOverlaps(t,e){return t===K.P&&e===K.P||t===K.A&&e===K.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===K.L&&e===K.L&&(1===this._matrix[Qt.INTERIOR][Qt.INTERIOR]&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]))}isEquals(t,e){return t===e&&(Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&this._matrix[Qt.INTERIOR][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.EXTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.EXTERIOR][Qt.BOUNDARY]===K.FALSE)}toString(){const t=new _t("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,K.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new s("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!Jt.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[Qt.INTERIOR][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.INTERIOR][Qt.BOUNDARY]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.INTERIOR]===K.FALSE&&this._matrix[Qt.BOUNDARY][Qt.BOUNDARY]===K.FALSE}isCrosses(t,e){return t===K.P&&e===K.L||t===K.P&&e===K.A||t===K.L&&e===K.A?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.EXTERIOR]):t===K.L&&e===K.P||t===K.A&&e===K.P||t===K.A&&e===K.L?Jt.isTrue(this._matrix[Qt.INTERIOR][Qt.INTERIOR])&&Jt.isTrue(this._matrix[Qt.EXTERIOR][Qt.INTERIOR]):t===K.L&&e===K.L&&0===this._matrix[Qt.INTERIOR][Qt.INTERIOR]}get interfaces_(){return[l]}}class $t{static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=$t.PI_TIMES_2;for(;t<=-Math.PI;)t+=$t.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=$t.PI_TIMES_2;t>=$t.PI_TIMES_2&&(t=0)}else{for(;t>=$t.PI_TIMES_2;)t-=$t.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n);return $t.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?$t.COUNTERCLOCKWISE:n<0?$t.CLOCKWISE:$t.NONE}static angleBetweenOriented(t,e,n){const s=$t.angle(e,t),i=$t.angle(e,n)-s;return i<=-Math.PI?i+$t.PI_TIMES_2:i>Math.PI?i-$t.PI_TIMES_2:i}}$t.PI_TIMES_2=2*Math.PI,$t.PI_OVER_2=Math.PI/2,$t.PI_OVER_4=Math.PI/4,$t.COUNTERCLOCKWISE=G.COUNTERCLOCKWISE,$t.CLOCKWISE=G.CLOCKWISE,$t.NONE=G.COLLINEAR;class te extends n{constructor(){super(),te.constructor_.apply(this,arguments)}static constructor_(){n.constructor_.call(this,"Projective point not representable on the Cartesian plane.")}}class ee{constructor(){ee.constructor_.apply(this,arguments)}static constructor_(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof ee&&arguments[1]instanceof ee){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}}getY(){const t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getX(){const t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new te;return t}getCoordinate(){const t=new m;return t.x=this.getX(),t.y=this.getY(),t}}class ne{constructor(){ne.constructor_.apply(this,arguments)}static constructor_(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static circumcentreDD(t,e,n){const s=D.valueOf(t.x).subtract(n.x),i=D.valueOf(t.y).subtract(n.y),r=D.valueOf(e.x).subtract(n.x),o=D.valueOf(e.y).subtract(n.y),l=D.determinant(s,i,r,o).multiply(2),a=s.sqr().add(i.sqr()),c=r.sqr().add(o.sqr()),h=D.determinant(i,a,o,c),u=D.determinant(s,a,r,c),g=D.valueOf(n.x).subtract(h.divide(l)).doubleValue(),d=D.valueOf(n.y).add(u.divide(l)).doubleValue();return new m(g,d)}static isAcute(t,e,n){return!!$t.isAcute(t,e,n)&&(!!$t.isAcute(e,n,t)&&!!$t.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*ne.det(r,o,l,a),h=ne.det(o,r*r+o*o,a,l*l+a*a),u=ne.det(r,r*r+o*o,l,l*l+a*a);return new m(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new ee(t.x+n/2,t.y+s/2,1),r=new ee(t.x-s+n/2,t.y+n+s/2,1);return new ee(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new m(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.getZ()-t.getZ(),o=n.x-t.x,l=n.y-t.y,a=n.getZ()-t.getZ(),c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new m(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new m(l,a)}area(){return ne.area(this.p0,this.p1,this.p2)}signedArea(){return ne.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new s("Supplied point is null.");return ne.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return ne.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return ne.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return ne.circumcentre(this.p0,this.p1,this.p2)}area3D(){return ne.area3D(this.p0,this.p1,this.p2)}centroid(){return ne.centroid(this.p0,this.p1,this.p2)}inCentre(){return ne.inCentre(this.p0,this.p1,this.p2)}}class se extends n{constructor(){super(),se.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)n.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];n.constructor_.call(this,t)}}}class ie{constructor(){ie.constructor_.apply(this,arguments)}static constructor_(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof ie){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}}static translationInstance(t,e){const n=new ie;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new ie;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return ie.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return ie.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new ie;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new ie;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,n,i){if(t===n&&e===i)throw new s("Reflection line points must be distinct");const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new se("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new ie(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof ie))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(ie.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(ie.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(ie.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.rotationInstance(t,e,n,s)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof n))throw t;g.shouldNeverReachHere()}return null}translate(t,e){return this.compose(ie.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const n=Math.sqrt(t*t+e*e),i=e/n,r=t/n;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];if(t===n&&e===i)throw new s("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=n-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(ie.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(I(arguments[0],F)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(ie.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(ie.reflectionInstance(t,e,n,s)),this}}get interfaces_(){return[l,P]}}class re{static solve(t,e){const n=e.length;if(t.length!==n||t[0].length!==n)throw new s("Matrix A is incorrectly sized");for(let s=0;s<n;s++){let i=s;for(let e=s+1;e<n;e++)Math.abs(t[e][s])>Math.abs(t[i][s])&&(i=e);if(0===t[i][s])return null;re.swapRows(t,s,i),re.swapRows(e,s,i);for(let i=s+1;i<n;i++){const r=t[i][s]/t[s][s];for(let e=n-1;e>=s;e--)t[i][e]-=t[s][e]*r;e[i]-=e[s]*r}}const i=new Array(n).fill(null);for(let s=n-1;s>=0;s--){let r=0;for(let e=s+1;e<n;e++)r+=t[s][e]*i[e];i[s]=(e[s]-r)/t[s][s]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}}class oe{constructor(){oe.constructor_.apply(this,arguments)}static constructor_(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return re.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new ie(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}}class le{static createFromBaseLines(t,e,n,s){const i=new m(t.x+s.x-n.x,t.y+s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new ie;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return ie.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new s("Src and Dest arrays are not the same length");if(t.length<=0)throw new s("Too few control points");if(t.length>3)throw new s("Too many control points");return 1===t.length?le.createFromControlVectors(t[0],e[0]):2===t.length?le.createFromControlVectors(t[0],t[1],e[0],e[1]):le.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new m(s.x-n.x,s.y-n.y),r=$t.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=ie.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){return new oe(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]).getTransformation()}}}}class ae{constructor(){ae.constructor_.apply(this,arguments)}static constructor_(){this._coords=null;const t=arguments[0];this._coords=t}static getCoordinates(t){const e=new L;return t.apply(new ae(e)),e}filter(t){(t instanceof J||t instanceof tt)&&this._coords.add(t.getCoordinate())}get interfaces_(){return[k]}}class ce{constructor(){ce.constructor_.apply(this,arguments)}static constructor_(){this._mapOp=null;const t=arguments[0];this._mapOp=t}static map(t,e){return new ce(e).map(t)}map(t){const e=new L;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Ct.toGeometryArray(e))}}class he{constructor(){he.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=he.extractFactory(t),this._inputGeoms=t}static combine(){if(1===arguments.length){return new he(arguments[0]).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new he(he.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new he(he.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new L;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new L;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}}class ue{constructor(){ue.constructor_.apply(this,arguments)}static constructor_(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof ct?this.editGeometryCollection(t,e):t instanceof it?this.editPolygon(t,e):t instanceof tt||t instanceof J?e.edit(t,this._factory):(g.shouldNeverReachHere("Unsupported Geometry type: "+t.getGeometryType()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new L;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getGeometryType()===X.TYPENAME_MULTIPOINT?this._factory.createMultiPoint(s.toArray([])):n.getGeometryType()===X.TYPENAME_MULTILINESTRING?this._factory.createMultiLineString(s.toArray([])):n.getGeometryType()===X.TYPENAME_MULTIPOLYGON?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new L;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}}function ge(){}ue.GeometryEditorOperation=ge;ue.NoOpGeometryOperation=class{edit(t,e){return t}get interfaces_(){return[ge]}},ue.CoordinateOperation=class{edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof ut?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof J?null===n?e.createLineString():e.createLineString(n):t instanceof tt?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}get interfaces_(){return[ge]}},ue.CoordinateSequenceOperation=class{edit(t,e){return t instanceof ut?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof J?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof tt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}get interfaces_(){return[ge]}};class de{constructor(){de.constructor_.apply(this,arguments)}static constructor_(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e}static isOfType(t,e){return t.getGeometryType()===e||e===X.TYPENAME_LINESTRING&&t.getGeometryType()===X.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return de.extract(t,e,new L)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof ct&&t.apply(new de(e,n)),n}}filter(t){(null===this._geometryType||de.isOfType(t,this._geometryType))&&this._comps.add(t)}get interfaces_(){return[Q]}}class _e{static map(){if(arguments[0]instanceof X&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(I(arguments[0],N)&&I(arguments[1],pe)){const t=arguments[0],e=arguments[1],n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}}function pe(){}_e.MapOp=pe;class me{constructor(){me.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof ut&&!s.isEmpty()||(n=!1);const i=new L;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof ut||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new L;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new L;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Ct.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof tt)return this.transformPoint(t,null);if(t instanceof ht)return this.transformMultiPoint(t,null);if(t instanceof ut)return this.transformLinearRing(t,null);if(t instanceof J)return this.transformLineString(t,null);if(t instanceof wt)return this.transformMultiLineString(t,null);if(t instanceof it)return this.transformPolygon(t,null);if(t instanceof ft)return this.transformMultiPolygon(t,null);if(t instanceof ct)return this.transformGeometryCollection(t,null);throw new s("Unknown Geometry subtype: "+t.getGeometryType())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}}class fe{constructor(){fe.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getGeometry(t){return t.getFactory().buildGeometry(fe.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return fe.getLines(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof J?e.add(t):t instanceof ct&&t.apply(new fe(e)),e}}filter(t){t instanceof J&&this._comps.add(t)}get interfaces_(){return[Q]}}class ye{constructor(){ye.constructor_.apply(this,arguments)}static constructor_(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(ye.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(ye.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,!1)}if(2===arguments.length){if(I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();ye.getLines(n,t)}return t}if(arguments[0]instanceof X&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new L;return t.apply(new ye(n,e)),n}if(arguments[0]instanceof X&&I(arguments[1],N)){const t=arguments[0],e=arguments[1];return t instanceof J?e.add(t):t.apply(new ye(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&I(arguments[0],N)&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];for(let n=arguments[0].iterator();n.hasNext();){const s=n.next();ye.getLines(s,t,e)}return t}if("boolean"==typeof arguments[2]&&arguments[0]instanceof X&&I(arguments[1],N)){const t=arguments[1],e=arguments[2];return arguments[0].apply(new ye(t,e)),t}}}filter(t){if(this._isForcedToLineString&&t instanceof ut){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof J&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}get interfaces_(){return[k]}}const xe={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return xe.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?nt.sort(n,e):nt.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new L;return e.add(t),e}};class Ee{constructor(){Ee.constructor_.apply(this,arguments)}static constructor_(){this._pts=null;const t=arguments[0];this._pts=t}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof tt?xe.singletonList(t):Ee.getPoints(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof tt?e.add(t):t instanceof ct&&t.apply(new Ee(e)),e}}filter(t){t instanceof tt&&this._pts.add(t)}get interfaces_(){return[Q]}}class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static constructor_(){this._comps=null;const t=arguments[0];this._comps=t}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ie.getPolygons(t,new L)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof it?e.add(t):t instanceof ct&&t.apply(new Ie(e)),e}}filter(t){t instanceof it&&this._comps.add(t)}get interfaces_(){return[Q]}}class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static constructor_(){this._isDone=!1}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof ct)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}}class Se{constructor(){Se.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._precModel=null,this._dim=new we,this._nPts=100,this._rotationAngle=0,0===arguments.length)Se.constructor_.call(this,new Ct);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new m(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=ie.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new m(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new m(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}}class we{constructor(){we.constructor_.apply(this,arguments)}static constructor_(){this.base=null,this.centre=null,this.width=null,this.height=null}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new m(t.getMinX(),t.getMinY()),this.centre=new m(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new O(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new O(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new O(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new m(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}}Se.Dimensions=we;class Ce extends Se{constructor(){super(),Ce.constructor_.apply(this,arguments)}static constructor_(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)Se.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];Se.constructor_.call(this,t)}}static create(t,e,n,s,i){const r=new Ce;r.setCentre(t),r.setSize(e),r.setNumPoints(n),r.setArmLengthRatio(i),r.setNumArms(s);return r.createSineStar()}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new m(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}}var Le=Object.freeze({__proto__:null,AffineTransformation:ie,AffineTransformationBuilder:oe,AffineTransformationFactory:le,ComponentCoordinateExtracter:ae,GeometryCollectionMapper:ce,GeometryCombiner:he,GeometryEditor:ue,GeometryExtracter:de,GeometryMapper:_e,GeometryTransformer:me,LineStringExtracter:fe,LinearComponentExtracter:ye,PointExtracter:Ee,PolygonExtracter:Ie,ShortCircuitedGeometryVisitor:Ne,SineStarFactory:Ce}),Te=Object.freeze({__proto__:null,Coordinate:m,CoordinateXY:y,CoordinateXYM:x,CoordinateXYZM:E,CoordinateList:R,CoordinateSequenceFilter:P,Envelope:O,LineSegment:Kt,GeometryFactory:Ct,Geometry:X,Point:tt,LineString:J,LinearRing:ut,Polygon:it,GeometryCollection:ct,MultiPoint:ht,MultiLineString:wt,MultiPolygon:ft,Dimension:K,IntersectionMatrix:Jt,PrecisionModel:Nt,Location:Qt,Triangle:ne,util:Le});class Re{constructor(){Re.constructor_.apply(this,arguments)}static constructor_(){this._pt=[new m,new m],this._distance=r.NaN,this._isNull=!0}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Wt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}}class Pe{static computeDistance(){if(arguments[2]instanceof Re&&arguments[0]instanceof J&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Kt,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Re&&arguments[0]instanceof it&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];Pe.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)Pe.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Re&&arguments[0]instanceof X&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof J)Pe.computeDistance(t,e,n);else if(t instanceof it)Pe.computeDistance(t,e,n);else if(t instanceof ct){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);Pe.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Re&&arguments[0]instanceof Kt&&arguments[1]instanceof m){const t=arguments[1],e=arguments[2],n=arguments[0].closestPoint(t);e.setMinimum(n,t)}}}class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static constructor_(){this._g0=null,this._g1=null,this._ptDist=new Re,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e}static distance(){if(2===arguments.length){return new Oe(arguments[0],arguments[1]).distance()}if(3===arguments.length){const t=arguments[2],e=new Oe(arguments[0],arguments[1]);return e.setDensifyFraction(t),e.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new s("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new ve(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new Me(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}}class ve{constructor(){ve.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._euclideanDist=new Pe,this._geom=null;const t=arguments[0];this._geom=t}filter(t){this._minPtDist.initialize(),Pe.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[U]}}class Me{constructor(){Me.constructor_.apply(this,arguments)}static constructor_(){this._maxPtDist=new Re,this._minPtDist=new Re,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new m(e,s);this._minPtDist.initialize(),Pe.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}get interfaces_(){return[P]}}Oe.MaxPointDistanceFilter=ve,Oe.MaxDensifiedByFractionDistanceFilter=Me;var be=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:Pe,PointPairDistance:Re});class De{visitItem(t){}}class Ae{locate(t){}}class Fe{constructor(){Fe.constructor_.apply(this,arguments)}static constructor_(){this._min=r.POSITIVE_INFINITY,this._max=r.NEGATIVE_INFINITY}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Wt.toLineString(new m(this._min,0),new m(this._max,0))}}Fe.NodeComparator=class{compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}get interfaces_(){return[a]}};class Ge extends Fe{constructor(){super(),Ge.constructor_.apply(this,arguments)}static constructor_(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}}class qe extends Fe{constructor(){super(),qe.constructor_.apply(this,arguments)}static constructor_(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}}class Be{constructor(){Be.constructor_.apply(this,arguments)}static constructor_(){this._leaves=new L,this._root=null,this._level=0}buildTree(){xe.sort(this._leaves,new Fe.NodeComparator);let t=this._leaves,e=null,n=new L;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new IllegalStateException("Index cannot be added to once it has been queried");this._leaves.add(new Ge(t,e,n))}query(t,e,n){if(this.init(),null===this._root)return null;this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){B.out.println(Wt.toLineString(new m(t._min,this._level),new m(t._max,this._level)))}init(){return null!==this._root||0===this._leaves.size()?null:void this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new qe(t.get(n),t.get(n+1));e.add(s)}}}}class Ye{constructor(){Ye.constructor_.apply(this,arguments)}static constructor_(){this._items=new L}visitItem(t){this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class Ve{constructor(){Ve.constructor_.apply(this,arguments)}static constructor_(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t}static locatePointInRing(){if(arguments[0]instanceof m&&I(arguments[1],F)){const t=arguments[1],e=new Ve(arguments[0]),n=new m,s=new m;for(let i=1;i<t.size();i++)if(t.getCoordinate(i,n),t.getCoordinate(i-1,s),e.countSegment(n,s),e.isOnSegment())return e.getLocation();return e.getLocation()}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[1],e=new Ve(arguments[0]);for(let n=1;n<t.length;n++){const s=t[n],i=t[n-1];if(e.countSegment(s,i),e.isOnSegment())return e.getLocation()}return e.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=G.index(t,e,this._p);if(n===G.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===G.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==Qt.EXTERIOR}getLocation(){return this._isPointOnSegment?Qt.BOUNDARY:this._crossingCount%2==1?Qt.INTERIOR:Qt.EXTERIOR}isOnSegment(){return this._isPointOnSegment}}class ze{constructor(){ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null,this._index=null;const t=arguments[0];if(!(I(t,st)||t instanceof ut))throw new s("Argument must be Polygonal or LinearRing");this._geom=t}locate(t){null===this._index&&(this._index=new Xe(this._geom),this._geom=null);const e=new Ve(t),n=new ke(e);return this._index.query(t.y,t.y,n),e.getLocation()}get interfaces_(){return[Ae]}}class ke{constructor(){ke.constructor_.apply(this,arguments)}static constructor_(){this._counter=null;const t=arguments[0];this._counter=t}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}get interfaces_(){return[De]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}static constructor_(){this._isEmpty=!1,this._index=new Be;const t=arguments[0];t.isEmpty()?this._isEmpty=!0:this.init(t)}init(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new Kt(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isEmpty)return new L;const n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isEmpty)return null;this._index.query(t,e,n)}}}ze.SegmentVisitor=ke,ze.IntervalIndexedGeometry=Xe;class Ue{static isOnLine(){if(arguments[0]instanceof m&&I(arguments[1],F)){const t=arguments[0],e=arguments[1],n=new jt,s=new m,i=new m,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof m&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new jt;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ve.locatePointInRing(t,e)}static isInRing(t,e){return Ue.locateInRing(t,e)!==Qt.EXTERIOR}}class He{hasNext(){}next(){}remove(){}}class We{constructor(){We.constructor_.apply(this,arguments)}static constructor_(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()}static isAtomic(t){return!(t instanceof ct)}next(){if(this._atStart)return this._atStart=!1,We.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new C;const t=this._parent.getGeometryN(this._index++);return t instanceof ct?(this._subcollectionIterator=new We(t),this._subcollectionIterator.next()):t}remove(){throw new j(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}get interfaces_(){return[He]}}class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static constructor_(){this._geom=null;const t=arguments[0];this._geom=t}static locatePointInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==Qt.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===Qt.BOUNDARY)return Qt.BOUNDARY;if(i===Qt.INTERIOR)return Qt.EXTERIOR}return Qt.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}static containsPointInPolygon(t,e){return Qt.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof it)return Ze.locatePointInPolygon(t,e);if(e instanceof ct){const n=new We(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==Qt.EXTERIOR)return e}}}return Qt.EXTERIOR}static isContained(t,e){return Qt.EXTERIOR!==Ze.locate(t,e)}static locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e.getEnvelopeInternal().intersects(t)?Ze.locateInGeometry(t,e):Qt.EXTERIOR}locate(t){return Ze.locate(t,this._geom)}get interfaces_(){return[Ae]}}var je=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ze,PointOnGeometryLocator:Ae,SimplePointInAreaLocator:Ze});class Ke{measure(t,e){}}class Qe{static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,Qe.DENSIFY_FRACTION),s=new O(t.getEnvelopeInternal());s.expandToInclude(e.getEnvelopeInternal());return 1-n/Qe.diagonalSize(s)}get interfaces_(){return[Ke]}}Qe.DENSIFY_FRACTION=.25;var Je=Object.freeze({__proto__:null,AreaSimilarityMeasure:class{measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}get interfaces_(){return[Ke]}},HausdorffSimilarityMeasure:Qe,SimilarityMeasure:Ke,SimilarityMeasureCombiner:class{static combine(t,e){return Math.min(t,e)}}});class $e{constructor(){$e.constructor_.apply(this,arguments)}static constructor_(){this._areaBasePt=null,this._triangleCent3=new m,this._areasum2=0,this._cg3=new m,this._lineCentSum=new m,this._totalLength=0,this._ptCount=0,this._ptCentSum=new m;const t=arguments[0];this._areaBasePt=null,this.add(t)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new $e(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=G.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new m;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!G.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;$e.centroid3(t,e,n,this._triangleCent3);const r=$e.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof it){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof X){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof tt)this.addPoint(t.getCoordinate());else if(t instanceof J)this.addLineSegments(t.getCoordinates());else if(t instanceof it){const e=t;this.add(e)}else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}}class tn extends n{constructor(t){super(t),this.name=Object.keys({EmptyStackException:tn})[0]}}class en extends w{constructor(){super(),this.array=[]}add(t){return this.array.push(t),!0}get(t){if(t<0||t>=this.size())throw new S;return this.array[t]}push(t){return this.array.push(t),t}pop(){if(0===this.array.length)throw new tn;return this.array.pop()}peek(){if(0===this.array.length)throw new tn;return this.array[this.array.length-1]}empty(){return 0===this.array.length}isEmpty(){return this.empty()}search(t){return this.array.indexOf(t)}size(){return this.array.length}toArray(){return this.array.slice()}}class nn{constructor(){nn.constructor_.apply(this,arguments)}static constructor_(){this._coordSet=new xt,this._list=new L}static filterCoordinates(t){const e=new nn;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this._coordSet.add(t)&&this._list.add(t)}getCoordinates(){const t=new Array(this._list.size()).fill(null);return this._list.toArray(t)}get interfaces_(){return[U]}}class sn{constructor(){sn.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];sn.constructor_.call(this,sn.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=nn.filterCoordinates(t),this._geomFactory=e}}static extractCoordinates(t){const e=new nn;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return nt.sort(t,1,t.length,new rn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new R;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){g.equals(t[0],t[t.length-1]);const e=new L;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==G.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new lt;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)Ue.isInRing(t[s],e)||n.add(t[s]);const s=dt.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new en;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&G.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}}class rn{constructor(){rn.constructor_.apply(this,arguments)}static constructor_(){this._origin=null;const t=arguments[0];this._origin=t}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=G.index(t,e,n);if(l===G.COUNTERCLOCKWISE)return 1;if(l===G.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return rn.polarCompare(this._origin,n,s)}get interfaces_(){return[a]}}sn.RadialComparator=rn;class on{constructor(){on.constructor_.apply(this,arguments)}static constructor_(){this._interiorPoint=null,this._maxWidth=-1;const t=arguments[0];this.process(t)}static getInteriorPoint(t){return new on(t).getInteriorPoint()}static avg(t,e){return(t+e)/2}getInteriorPoint(){return this._interiorPoint}process(t){if(t.isEmpty())return null;if(t instanceof it)this.processPolygon(t);else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.process(e.getGeometryN(t))}}processPolygon(t){const e=new ln(t);e.process();const n=e.getWidth();n>this._maxWidth&&(this._maxWidth=n,this._interiorPoint=e.getInteriorPoint())}}class ln{constructor(){ln.constructor_.apply(this,arguments)}static constructor_(){this._polygon=null,this._interiorPointY=null,this._interiorSectionWidth=0,this._interiorPoint=null;const t=arguments[0];this._polygon=t,this._interiorPointY=cn.getScanLineY(t)}static isEdgeCrossingCounted(t,e,n){const s=t.getY(),i=e.getY();return s!==i&&(!(s===n&&i<n)&&!(i===n&&s<n))}static intersectsHorizontalLine(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!(e<t.getMinY())&&!(e>t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return!(t.getY()>n&&e.getY()>n)&&!(t.getY()<n&&e.getY()<n)}}static intersection(t,e,n){const s=t.getX(),i=e.getX();if(s===i)return s;const r=i-s,o=(e.getY()-t.getY())/r;return s+(n-t.getY())/o}findBestMidpoint(t){if(0===t.size())return null;g.isTrue(0==t.size()%2,"Interior Point robustness failure: odd number of scanline crossings"),t.sort(new an);for(let e=0;e<t.size();e+=2){const n=t.get(e),s=t.get(e+1),i=s-n;if(i>this._interiorSectionWidth){this._interiorSectionWidth=i;const t=on.avg(n,s);this._interiorPoint=new m(t,this._interiorPointY)}}}process(){if(this._polygon.isEmpty())return null;this._interiorPoint=new m(this._polygon.getCoordinate());const t=new L;this.scanRing(this._polygon.getExteriorRing(),t);for(let e=0;e<this._polygon.getNumInteriorRing();e++)this.scanRing(this._polygon.getInteriorRingN(e),t);this.findBestMidpoint(t)}scanRing(t,e){if(!ln.intersectsHorizontalLine(t.getEnvelopeInternal(),this._interiorPointY))return null;const n=t.getCoordinateSequence();for(let t=1;t<n.size();t++){const s=n.getCoordinate(t-1),i=n.getCoordinate(t);this.addEdgeCrossing(s,i,this._interiorPointY,e)}}getWidth(){return this._interiorSectionWidth}getInteriorPoint(){return this._interiorPoint}addEdgeCrossing(t,e,n,s){if(!ln.intersectsHorizontalLine(t,e,n))return null;if(!ln.isEdgeCrossingCounted(t,e,n))return null;const i=ln.intersection(t,e,n);s.add(i)}}class an{compare(t,e){return t<e?-1:t>e?1:0}get interfaces_(){return[a]}}ln.DoubleComparator=an;class cn{constructor(){cn.constructor_.apply(this,arguments)}static constructor_(){this._poly=null,this._centreY=null,this._hiY=r.MAX_VALUE,this._loY=-r.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=on.avg(this._loY,this._hiY)}static getScanLineY(t){return new cn(t).getScanLineY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getScanLineY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return on.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}}on.InteriorPointPolygon=ln,on.ScanLineYOrdinateFinder=cn;class hn{constructor(){hn.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=null:(this._centroid=$e.getCentroid(t),t.getPrecisionModel().makePrecise(this._centroid)),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)}static getInteriorPoint(t){return new hn(t).getInteriorPoint()}addEndpoints(){if(arguments[0]instanceof X){const t=arguments[0];if(t instanceof J)this.addEndpoints(t.getCoordinates());else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof X){const t=arguments[0];if(t instanceof J)this.addInterior(t.getCoordinates());else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}class un{constructor(){un.constructor_.apply(this,arguments)}static constructor_(){this._centroid=null,this._minDistance=r.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=$e.getCentroid(t),this.add(t)}static getInteriorPoint(t){return new un(t).getInteriorPoint()}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof X){const t=arguments[0];if(t instanceof tt)this.add(t.getCoordinate());else if(t instanceof ct){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof m){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new m(t),this._minDistance=e)}}}class gn{isInBoundary(t){}}class dn{isInBoundary(t){return t%2==1}get interfaces_(){return[gn]}}class _n{isInBoundary(t){return t>0}get interfaces_(){return[gn]}}class pn{isInBoundary(t){return t>1}get interfaces_(){return[gn]}}class mn{isInBoundary(t){return 1===t}get interfaces_(){return[gn]}}gn.Mod2BoundaryNodeRule=dn,gn.EndPointBoundaryNodeRule=_n,gn.MultiValentEndPointBoundaryNodeRule=pn,gn.MonoValentEndPointBoundaryNodeRule=mn,gn.MOD2_BOUNDARY_RULE=new dn,gn.ENDPOINT_BOUNDARY_RULE=new _n,gn.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new pn,gn.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new mn,gn.OGC_SFS_BOUNDARY_RULE=gn.MOD2_BOUNDARY_RULE;class fn{constructor(){fn.constructor_.apply(this,arguments)}static constructor_(){if(this._boundaryRule=gn.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new s("Rule must be non-null");this._boundaryRule=t}}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?Ue.locateInRing(t,e.getCoordinates()):Qt.EXTERIOR}intersects(t,e){return this.locate(t,e)!==Qt.EXTERIOR}updateLocationInfo(t){t===Qt.INTERIOR&&(this._isIn=!0),t===Qt.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof tt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof J)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof it)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof wt){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof ft){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof ct){const n=new We(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?Qt.INTERIOR:Qt.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return Qt.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?Ue.isOnLine(t,n)?Qt.INTERIOR:Qt.EXTERIOR:Qt.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return Qt.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===Qt.EXTERIOR)return Qt.EXTERIOR;if(s===Qt.BOUNDARY)return Qt.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===Qt.INTERIOR)return Qt.EXTERIOR;if(i===Qt.BOUNDARY)return Qt.BOUNDARY}return Qt.INTERIOR}locate(t,e){return e.isEmpty()?Qt.EXTERIOR:e instanceof J?this.locateOnLineString(t,e):e instanceof it?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?Qt.BOUNDARY:this._numBoundaries>0||this._isIn?Qt.INTERIOR:Qt.EXTERIOR)}}class yn{constructor(){yn.constructor_.apply(this,arguments)}static constructor_(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t}static farthestPoints(t){const e=t[0].distance(t[1]),n=t[1].distance(t[2]),s=t[2].distance(t[0]);return e>=n&&e>=s?[t[0],t[1]]:n>=e&&n>=s?[t[1],t[2]]:[t[2],t[0]]}static pointWitMinAngleWithX(t,e){let n=r.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=r.MAX_VALUE,i=null;for(let r=0;r<t.length;r++){const o=t[r];if(o===e)continue;if(o===n)continue;const l=$t.angleBetween(e,o,n);l<s&&(s=l,i=o)}return i}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new m(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),dt.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=dt.copyDeep(e),null;let n=yn.lowestPoint(e),s=yn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=yn.pointWithMinAngleWithSegment(e,n,s);if($t.isObtuse(n,t,s))return this._extremalPts=[new m(n),new m(s)],null;if($t.isObtuse(t,n,s))n=t;else{if(!$t.isObtuse(t,s,n))return this._extremalPts=[new m(n),new m(s),new m(t)],null;s=t}}g.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}getMaximumDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre);case 2:return this._input.getFactory().createLineString([this._extremalPts[0],this._extremalPts[1]]);default:const t=yn.farthestPoints(this._extremalPts);return this._input.getFactory().createLineString(t)}}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new m((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=ne.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}}class xn{constructor(){xn.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new Kt,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];xn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new xn(t).getDiameter()}static getMinimumRectangle(t){return new xn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new m(0,n/e),i=new m(1,n/e-t/e)):(s=new m(n/t,0),i=new m(n/t-e/t,1)),new Kt(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof it?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=r.MAX_VALUE;let e=1;const n=new Kt;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new sn(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=xn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new Kt(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=r.MAX_VALUE,s=-r.MAX_VALUE,i=r.MAX_VALUE,o=-r.MAX_VALUE;for(let r=0;r<this._convexHullPts.length;r++){const l=xn.computeC(t,e,this._convexHullPts[r]);l>s&&(s=l),l<n&&(n=l);const a=xn.computeC(-e,t,this._convexHullPts[r]);a>o&&(o=a),a<i&&(i=a)}const l=xn.computeSegmentForLine(-t,-e,o),a=xn.computeSegmentForLine(-t,-e,i),c=xn.computeSegmentForLine(-e,t,s),h=xn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),p=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(p)}}var En=Object.freeze({__proto__:null,distance:be,locate:je,match:Je,Angle:$t,Area:et,Centroid:$e,ConvexHull:sn,Distance:V,InteriorPointArea:on,InteriorPointLine:hn,InteriorPointPoint:un,Length:H,Orientation:G,PointLocation:Ue,PointLocator:fn,RobustLineIntersector:jt,MinimumBoundingCircle:yn,MinimumDiameter:xn});class In{constructor(){In.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t}static densifyPoints(t,e,n){const s=new Kt,i=new R;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new In(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new Nn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new s("Tolerance must be positive");this._distanceTolerance=t}}class Nn extends me{constructor(){super(),Nn.constructor_.apply(this,arguments)}static constructor_(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof ft?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=In.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof J&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}}In.DensifyTransformer=Nn;var Sn=Object.freeze({__proto__:null,Densifier:In});class wn{static isNorthern(t){return t===wn.NE||t===wn.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===wn.SE?t===wn.SE||t===wn.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?wn.NE:wn.SE:e>=0?wn.NW:wn.SW}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new s("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?wn.NE:wn.SE:e.y>=t.y?wn.NW:wn.SW}}}wn.NE=0,wn.NW=1,wn.SW=2,wn.SE=3;class Cn{constructor(){Cn.constructor_.apply(this,arguments)}static constructor_(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t}static create(t,e){const n=new Cn(t),s=new Cn(e);return n.link(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}isEdgesSorted(){const t=this.findLowest();let e=t;do{const n=e.oNext();if(n===t)break;if(!(n.compareTo(e)>0))return!1;e=n}while(e!==t);return!0}oNext(){return this._sym._next}directionY(){return this.directionPt().getY()-this._orig.getY()}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;this.insertionEdge(t).insertAfter(t)}insertAfter(t){g.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof m&&arguments[0]instanceof m){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}findLowest(){let t=this,e=this.oNext();do{e.compareTo(t)<0&&(t=e),e=e.oNext()}while(e!==this);return t}directionPt(){return this.dest()}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.directionX(),n=this.directionY(),s=t.directionX(),i=t.directionY();if(e===s&&n===i)return 0;const r=wn.quadrant(e,n),o=wn.quadrant(s,i);if(r>o)return 1;if(r<o)return-1;const l=this.directionPt(),a=t.directionPt();return G.index(t._orig,a,l)}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}directionX(){return this.directionPt().getX()-this._orig.getX()}insertionEdge(t){let e=this;do{const n=e.oNext();if(n.compareTo(e)>0&&t.compareTo(e)>=0&&t.compareTo(n)<=0)return e;if(n.compareTo(e)<=0&&(t.compareTo(n)<=0||t.compareTo(e)>=0))return e;e=n}while(e!==this);return g.shouldNeverReachHere(),null}compareTo(t){const e=t;return this.compareAngularDirection(e)}toStringNode(){const t=this.orig(),e=(this.dest(),new _t);e.append("Node( "+Wt.format(t)+" )\n");let n=this;do{e.append("  -> "+n),e.append("\n"),n=n.oNext()}while(n!==this);return e.toString()}link(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}toStringNodeEdge(){return"  -> ("+Wt.format(this.dest())}setNext(t){this._next=t}}class Ln extends Cn{constructor(){super(),Ln.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1;const t=arguments[0];Cn.constructor_.call(this,t)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}}class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static constructor_(){this._vertexMap=new It}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return n.link(s),n}createEdge(t){return new Cn(t)}addEdge(t,e){if(!Tn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}}class Rn extends Ln{constructor(){super(),Rn.constructor_.apply(this,arguments)}static constructor_(){this._isStart=!1;const t=arguments[0];Ln.constructor_.call(this,t)}setStart(){this._isStart=!0}isStart(){return this._isStart}}class Pn extends Tn{constructor(){super()}createEdge(t){return new Rn(t)}}class On{constructor(){On.constructor_.apply(this,arguments)}static constructor_(){this._result=null,this._factory=null,this._graph=null,this._lines=new L,this._nodeEdgeStack=new en,this._ringStartEdge=null,this._graph=new Pn}static dissolve(t){const e=new On;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new R;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new R;let n=t;for(this._ringStartEdge=null,Ln.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Ln.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Ln.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Ln.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Ln.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof X){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof J&&this.add(t)}})}else if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof J){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}}var vn=Object.freeze({__proto__:null,LineDissolver:On});class Mn{static opposite(t){return t===Mn.LEFT?Mn.RIGHT:t===Mn.RIGHT?Mn.LEFT:t}}Mn.ON=0,Mn.LEFT=1,Mn.RIGHT=2;class bn{constructor(){bn.constructor_.apply(this,arguments)}static constructor_(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}}class Dn{constructor(){Dn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=Dn.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=Dn.INSERT,this._label=t,this._xValue=e,this._obj=n}}isDelete(){return this._eventType===Dn.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===Dn.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}get interfaces_(){return[o]}}Dn.INSERT=1,Dn.DELETE=2;class An{constructor(){An.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(An.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}}class Fn extends class{}{constructor(){super(),Fn.constructor_.apply(this,arguments)}static constructor_(){this.events=new L,this.nOverlaps=null}prepareEvents(){xe.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&I(arguments[0],w)&&I(arguments[1],w)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&I(arguments[0],w)&&arguments[1]instanceof An){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new bn(n,t),i=new Dn(e,n.getMinX(t),s);this.events.add(i),this.events.add(new Dn(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){const n=e.next();this.addEdge(n,t)}}}}class Gn{constructor(){Gn.constructor_.apply(this,arguments)}static constructor_(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[Mn.ON]=t}else if(arguments[0]instanceof Gn){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[Mn.ON]=t,this.location[Mn.LEFT]=e,this.location[Mn.RIGHT]=n}}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==Qt.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[Mn.ON]=this.location[Mn.ON],t[Mn.LEFT]=Qt.NONE,t[Mn.RIGHT]=Qt.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===Qt.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[Mn.LEFT];this.location[Mn.LEFT]=this.location[Mn.RIGHT],this.location[Mn.RIGHT]=t}toString(){const t=new v;return this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[Mn.LEFT])),t.append(Qt.toLocationSymbol(this.location[Mn.ON])),this.location.length>1&&t.append(Qt.toLocationSymbol(this.location[Mn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[Mn.ON]=t,this.location[Mn.LEFT]=e,this.location[Mn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:Qt.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===Qt.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(Mn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(Qt.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}}class qn{constructor(){qn.constructor_.apply(this,arguments)}static constructor_(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new Gn(t),this.elt[1]=new Gn(t)}else if(arguments[0]instanceof qn){const t=arguments[0];this.elt[0]=new Gn(t.elt[0]),this.elt[1]=new Gn(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new Gn(Qt.NONE),this.elt[1]=new Gn(Qt.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new Gn(t,e,n),this.elt[1]=new Gn(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new Gn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[1]=new Gn(Qt.NONE,Qt.NONE,Qt.NONE),this.elt[t].setLocations(e,n,s)}}static toLineLabel(t){const e=new qn(Qt.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Gn(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(Mn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new v;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(Mn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new Gn(this.elt[t].location[0]))}}class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static constructor_(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new m(t),this.segmentIndex=e,this.dist=n}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}get interfaces_(){return[o]}}class Yn extends yt{}function Vn(t){return null==t?0:t.color}function zn(t){return null==t?null:t.parent}function kn(t,e){null!==t&&(t.color=e)}function Xn(t){return null==t?null:t.left}function Un(t){return null==t?null:t.right}class Hn extends Yn{constructor(){super(),this.root_=null,this.size_=0}get(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null}put(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;let n,s,i=this.root_;do{if(n=i,s=t.compareTo(i.key),s<0)i=i.left;else{if(!(s>0)){const t=i.value;return i.value=e,t}i=i.right}}while(null!==i);const r={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=r:n.right=r,this.fixAfterInsertion(r),this.size_++,null}fixAfterInsertion(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)zn(t)===Xn(zn(zn(t)))?(e=Un(zn(zn(t))),1===Vn(e)?(kn(zn(t),0),kn(e,0),kn(zn(zn(t)),1),t=zn(zn(t))):(t===Un(zn(t))&&(t=zn(t),this.rotateLeft(t)),kn(zn(t),0),kn(zn(zn(t)),1),this.rotateRight(zn(zn(t))))):(e=Xn(zn(zn(t))),1===Vn(e)?(kn(zn(t),0),kn(e,0),kn(zn(zn(t)),1),t=zn(zn(t))):(t===Xn(zn(t))&&(t=zn(t),this.rotateRight(t)),kn(zn(t),0),kn(zn(zn(t)),1),this.rotateLeft(zn(zn(t)))));this.root_.color=0}values(){const t=new L;let e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=Hn.successor(e));)t.add(e.value);return t}entrySet(){const t=new xt;let e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=Hn.successor(e));)t.add(e);return t}rotateLeft(t){if(null!=t){const e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}}rotateRight(t){if(null!=t){const e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}}getFirstEntry(){let t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t}static successor(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}{e=t.parent;let n=t;for(;null!==e&&n===e.right;)n=e,e=e.parent;return e}}size(){return this.size_}containsKey(t){let e=this.root_;for(;null!==e;){const n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1}}class Wn{constructor(){Wn.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Hn,this.edge=null;const t=arguments[0];this.edge=t}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new $n(r,new qn(this.edge._label))}add(t,e,n){const s=new Bn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}}class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static constructor_(){if(this._data=null,this._size=0,0===arguments.length)Zn.constructor_.call(this,10);else if(1===arguments.length){const t=arguments[0];this._data=new Array(t).fill(null)}}size(){return this._size}addAll(t){return null===t||0===t.length?null:(this.ensureCapacity(this._size+t.length),B.arraycopy(t,0,this._data,this._size,t.length),void(this._size+=t.length))}ensureCapacity(t){if(t<=this._data.length)return null;const e=Math.max(t,2*this._data.length);this._data=nt.copyOf(this._data,e)}toArray(){const t=new Array(this._size).fill(null);return B.arraycopy(this._data,0,t,0,this._size),t}add(t){this.ensureCapacity(this._size+1),this._data[this._size]=t,++this._size}}class jn{static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new Zn(Math.trunc(t.length/2));n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return n.toArray()}findChainEnd(t,e){const n=wn.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(wn.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}OLDgetChainStartIndices(t){let e=0;const n=new L;n.add(e);do{const s=this.findChainEnd(t,e);n.add(s),e=s}while(e<t.length-1);return jn.toIntArray(n)}}class Kn{constructor(){Kn.constructor_.apply(this,arguments)}static constructor_(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new jn;this.startIndex=e.getChainStartIndices(this.pts)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return O.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}}class Qn{constructor(){Qn.constructor_.apply(this,arguments)}static constructor_(){this._depth=Array(2).fill().map((()=>Array(3)));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=Qn.NULL_VALUE}static depthAtLocation(t){return t===Qt.EXTERIOR?0:t===Qt.INTERIOR?1:Qn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===Qn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===Qn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][Mn.RIGHT]-this._depth[t][Mn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?Qt.EXTERIOR:Qt.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==Qt.EXTERIOR&&s!==Qt.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=Qn.depthAtLocation(s):this._depth[e][n]+=Qn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===Qt.INTERIOR&&this._depth[t][e]++}}}Qn.NULL_VALUE=-1;class Jn{constructor(){Jn.constructor_.apply(this,arguments)}static constructor_(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){g.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}}class $n extends Jn{constructor(){super(),$n.constructor_.apply(this,arguments)}static constructor_(){if(this.pts=null,this._env=null,this.eiList=new Wn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new Qn,this._depthDelta=0,1===arguments.length){const t=arguments[0];$n.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof Jt&&arguments[0]instanceof qn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,Mn.ON),t.getLocation(1,Mn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,Mn.LEFT),t.getLocation(1,Mn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,Mn.RIGHT),t.getLocation(1,Mn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new $n(t,qn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof $n))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){$n.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Kn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new O;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new m(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new _t;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}}class ts extends Jn{constructor(){super(),ts.constructor_.apply(this,arguments)}static constructor_(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new qn(0,Qt.NONE)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=Qt.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==Qt.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new qn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof ts){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof qn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===Qt.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=Qt.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case Qt.BOUNDARY:n=Qt.INTERIOR;break;case Qt.INTERIOR:default:n=Qt.BOUNDARY}this._label.setLocation(t,n)}}class es{constructor(){es.constructor_.apply(this,arguments)}static constructor_(){this.nodeMap=new Hn,this.nodeFact=null;const t=arguments[0];this.nodeFact=t}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof m){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof ts){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new L;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===Qt.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}}class ns{constructor(){ns.constructor_.apply(this,arguments)}static constructor_(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ns.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ns.constructor_.call(this,t),this.init(e,n),this._label=s}}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:G.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=wn.quadrant(this._dx,this._dy),g.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}get interfaces_(){return[o]}}class ss extends h{constructor(t,e){super(e?t+" [ "+e+" ]":t),this.pt=e?new m(e):void 0,this.name=Object.keys({TopologyException:ss})[0]}getCoordinate(){return this.pt}}class is extends ns{constructor(){super(),is.constructor_.apply(this,arguments)}static constructor_(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(ns.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()}static depthFactor(t,e){return t===Qt.EXTERIOR&&e===Qt.INTERIOR?1:t===Qt.INTERIOR&&e===Qt.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new qn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new ss("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Mn.LEFT)===Qt.INTERIOR&&this._label.getLocation(e,Mn.RIGHT)===Qt.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[Mn.LEFT]+"/"+this._depth[Mn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,Qt.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,Qt.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===Mn.LEFT&&(s=-1);const i=Mn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}}class rs{createNode(t){return new ts(t,null)}}class os{constructor(){os.constructor_.apply(this,arguments)}static constructor_(){if(this._edges=new L,this._nodes=null,this._edgeEndList=new L,0===arguments.length)this._nodes=new es(new rs);else if(1===arguments.length){const t=arguments[0];this._nodes=new es(t)}}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof ts){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){B.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===Qt.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(G.index(t,e,s)===G.COLLINEAR&&wn.quadrant(t,e)===wn.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){B.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new is(t,!0),s=new is(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}}class ls extends os{constructor(){super(),ls.constructor_.apply(this,arguments)}static constructor_(){if(this._parentGeom=null,this._lineEdgeMap=new It,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new fn,2===arguments.length){const t=arguments[0],e=arguments[1];ls.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}}static determineBoundary(t,e){return t.isInBoundary(e)?Qt.BOUNDARY:Qt.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=Qt.NONE;i=n.getLocation(t,Mn.ON),i===Qt.BOUNDARY&&s++;const r=ls.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[1],e=arguments[2],n=new An(arguments[0],!0,!1);n.setIsDoneIfProperInt(e);const s=this.createEdgeSetIntersector(),i=this._parentGeom instanceof ut||this._parentGeom instanceof it||this._parentGeom instanceof ft,r=t||!i;return s.computeIntersections(this._edges,n,r),this.addSelfIntersectionNodes(this._argIndex),n}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new An(e,n,!0);s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof tt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,Qt.INTERIOR)}else if(arguments[0]instanceof m){const t=arguments[0];this.insertPoint(this._argIndex,t,Qt.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),Qt.EXTERIOR,Qt.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,Qt.INTERIOR,Qt.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],Qt.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],Qt.BOUNDARY)}addLineString(t){const e=dt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new $n(e,new qn(this._argIndex,Qt.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),g.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===Qt.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=dt.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;G.isCCW(s)&&(i=n,r=e);const o=new $n(s,new qn(this._argIndex,Qt.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],Qt.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new qn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Fn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof X))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof ft&&(this._useBoundaryDeterminationRule=!1),t instanceof it)this.addPolygon(t);else if(t instanceof J)this.addLineString(t);else if(t instanceof tt)this.addPoint(t);else if(t instanceof ht)this.addCollection(t);else if(t instanceof wt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else{if(!(t instanceof ct))throw new j(t.getGeometryType());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return I(this._parentGeom,st)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ze(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof J){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}}var as=Object.freeze({__proto__:null,GeometryGraph:ls});class cs{visit(t){}}class hs{constructor(){hs.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e),this._left=null,this._right=null,this._count=1,this._data=n}}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}}class us{constructor(){us.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)us.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return us.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new R;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new hs(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new L;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof O&&I(arguments[1],w)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[cs]}visit(t){e.add(t)}})}else if(arguments[0]instanceof O&&I(arguments[1],cs)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new gs(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new hs(t,e);return r?s.setLeft(o):s.setRight(o),o}}class gs{constructor(){gs.constructor_.apply(this,arguments)}static constructor_(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new O(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}get interfaces_(){return[cs]}}us.BestMatchVisitor=gs;var ds=Object.freeze({__proto__:null,KdTree:us});class _s{constructor(){_s.constructor_.apply(this,arguments)}static constructor_(){this._items=new L,this._subnode=new Array(4).fill(null)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}get interfaces_(){return[c]}}function ps(){}ps.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},ps.powerOf2=function(t){return Math.pow(2,t)};class ms{constructor(){ms.constructor_.apply(this,arguments)}static constructor_(){this._pt=new m,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return ps.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=ms.computeQuadLevel(t),this._env=new O,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ps.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new m((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}}class fs extends _s{constructor(){super(),fs.constructor_.apply(this,arguments)}static constructor_(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2}static createNode(t){const e=new ms(t);return new fs(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new O(e);null!==t&&n.expandToInclude(t._env);const s=fs.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=_s.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=_s.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new O(e,n,s,i);return new fs(r,this._level-1)}insertNode(t){g.isTrue(null===this._env||this._env.contains(t._env));const e=_s.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}}class ys{static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return ps.exponent(s)<=ys.MIN_BINARY_EXPONENT}}ys.MIN_BINARY_EXPONENT=-50;class xs extends _s{constructor(){super()}insert(t,e){const n=_s.getSubnodeIndex(t,xs.origin.x,xs.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=fs.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){g.isTrue(t.getEnvelope().contains(e));const s=ys.isZeroWidth(e.getMinX(),e.getMaxX()),i=ys.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}}xs.origin=new m(0,0);class Es{insert(t,e){}remove(t,e){}query(){}}class Is{constructor(){Is.constructor_.apply(this,arguments)}static constructor_(){this._root=null,this._minExtent=1,this._root=new xs}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s+=e/2),i===r&&(i-=e/2,r+=e/2),new O(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=Is.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new L;return this._root.addAllItems(t),t}remove(t,e){const n=Is.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}get interfaces_(){return[Es,c]}}var Ns=Object.freeze({__proto__:null,Quadtree:Is});class Ss{getBounds(){}}class ws{constructor(){ws.constructor_.apply(this,arguments)}static constructor_(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e}getItem(){return this._item}getBounds(){return this._bounds}get interfaces_(){return[Ss,c]}}class Cs{constructor(){Cs.constructor_.apply(this,arguments)}static constructor_(){this._size=null,this._items=null,this._size=0,this._items=new L,this._items.add(null)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}}class Ls{constructor(){Ls.constructor_.apply(this,arguments)}static constructor_(){if(this._childBoundables=new L,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){g.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}get interfaces_(){return[Ss,c]}}class Ts{static maxDistance(t,e,n,s,i,r,o,l){let a=Ts.distance(t,e,i,r);return a=Math.max(a,Ts.distance(t,e,o,l)),a=Math.max(a,Ts.distance(n,s,i,r)),a=Math.max(a,Ts.distance(n,s,o,l)),a}static distance(t,e,n,s){const i=n-t,r=s-e;return Math.sqrt(i*i+r*r)}static maximumDistance(t,e){const n=Math.min(t.getMinX(),e.getMinX()),s=Math.min(t.getMinY(),e.getMinY()),i=Math.max(t.getMaxX(),e.getMaxX()),r=Math.max(t.getMaxY(),e.getMaxY());return Ts.distance(n,s,i,r)}static minMaxDistance(t,e){const n=t.getMinX(),s=t.getMinY(),i=t.getMaxX(),r=t.getMaxY(),o=e.getMinX(),l=e.getMinY(),a=e.getMaxX(),c=e.getMaxY();let h=Ts.maxDistance(n,s,n,r,o,l,o,c);return h=Math.min(h,Ts.maxDistance(n,s,n,r,o,l,a,l)),h=Math.min(h,Ts.maxDistance(n,s,n,r,a,c,o,c)),h=Math.min(h,Ts.maxDistance(n,s,n,r,a,c,a,l)),h=Math.min(h,Ts.maxDistance(n,s,i,s,o,l,o,c)),h=Math.min(h,Ts.maxDistance(n,s,i,s,o,l,a,l)),h=Math.min(h,Ts.maxDistance(n,s,i,s,a,c,o,c)),h=Math.min(h,Ts.maxDistance(n,s,i,s,a,c,a,l)),h=Math.min(h,Ts.maxDistance(i,r,n,r,o,l,o,c)),h=Math.min(h,Ts.maxDistance(i,r,n,r,o,l,a,l)),h=Math.min(h,Ts.maxDistance(i,r,n,r,a,c,o,c)),h=Math.min(h,Ts.maxDistance(i,r,n,r,a,c,a,l)),h=Math.min(h,Ts.maxDistance(i,r,i,s,o,l,o,c)),h=Math.min(h,Ts.maxDistance(i,r,i,s,o,l,a,l)),h=Math.min(h,Ts.maxDistance(i,r,i,s,a,c,o,c)),h=Math.min(h,Ts.maxDistance(i,r,i,s,a,c,a,l)),h}}class Rs{constructor(){Rs.constructor_.apply(this,arguments)}static constructor_(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof Ls}maximumDistance(){return Ts.maximumDistance(this._boundable1.getBounds(),this._boundable2.getBounds())}expandToQueue(t,e){const n=Rs.isComposite(this._boundable1),i=Rs.isComposite(this._boundable2);if(n&&i)return Rs.area(this._boundable1)>Rs.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,!1,t,e),null):(this.expand(this._boundable2,this._boundable1,!0,t,e),null);if(n)return this.expand(this._boundable1,this._boundable2,!1,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,!0,t,e),null;throw new s("neither boundable is composite")}isLeaves(){return!(Rs.isComposite(this._boundable1)||Rs.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s,i){for(let r=t.getChildBoundables().iterator();r.hasNext();){const t=r.next();let o=null;o=n?new Rs(e,t,this._itemDistance):new Rs(t,e,this._itemDistance),o.getDistance()<i&&s.add(o)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}get interfaces_(){return[o]}}class Ps{constructor(){Ps.constructor_.apply(this,arguments)}static constructor_(){if(this._root=null,this._built=!1,this._itemBoundables=new L,this._nodeCapacity=null,0===arguments.length)Ps.constructor_.call(this,Ps.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];g.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(I(arguments[2],De)&&arguments[0]instanceof Object&&arguments[1]instanceof Ls){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ls?this.queryInternal(t,i,e):i instanceof ws?e.visitItem(i.getItem()):g.shouldNeverReachHere())}}else if(I(arguments[2],w)&&arguments[0]instanceof Object&&arguments[1]instanceof Ls){const t=arguments[0],e=arguments[2],n=arguments[1].getChildBoundables();for(let s=0;s<n.size();s++){const i=n.get(s);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof Ls?this.queryInternal(t,i,e):i instanceof ws?e.add(i.getItem()):g.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof Ls?t+=this.size(n):n instanceof ws&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof ws&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new L:t}if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof Ls){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof ws?e.add(t.getItem()):g.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){g.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new ws(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new L;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(g.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof Ls?this.boundablesAtLevel(t,e,n):(g.isTrue(e instanceof ws),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new L;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof Ls&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){g.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof Ls){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=new L;n.add(this.createNode(e));const s=new L(t);xe.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}get interfaces_(){return[c]}}Ps.IntersectsOp=function(){},Ps.DEFAULT_NODE_CAPACITY=10;class Os{distance(t,e){}}class vs extends Ps{constructor(){super(),vs.constructor_.apply(this,arguments)}static constructor_(){if(0===arguments.length)vs.constructor_.call(this,vs.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];Ps.constructor_.call(this,t)}}static centreX(t){return vs.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return vs.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){g.isTrue(t.length>0);const n=new L;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}nearestNeighbourK(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.nearestNeighbourK(t,r.POSITIVE_INFINITY,e)}if(3===arguments.length){const t=arguments[0],e=arguments[2];let n=arguments[1];const s=new Cs;s.add(t);const i=new Cs;for(;!s.isEmpty()&&n>=0;){const t=s.poll(),r=t.getDistance();if(r>=n)break;if(t.isLeaves())if(i.size()<e)i.add(t);else{i.peek().getDistance()>r&&(i.poll(),i.add(t));n=i.peek().getDistance()}else t.expandToQueue(s,n)}return vs.getItems(i)}}createNode(t){return new Ms(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return vs.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new L;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return vs.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof O){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){g.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new L(t);xe.sort(s,vs.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(I(arguments[0],Os)){const t=arguments[0];if(this.isEmpty())return null;const e=new Rs(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof Rs){const t=arguments[0];let e=r.POSITIVE_INFINITY,n=null;const s=new Cs;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return null===n?null:[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}}else{if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isEmpty()||t.isEmpty())return null;const n=new Rs(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(3===arguments.length){const t=arguments[2],e=new ws(arguments[0],arguments[1]),n=new Rs(this.getRoot(),e,t);return this.nearestNeighbour(n)[0]}if(4===arguments.length){const t=arguments[2],e=arguments[3],n=new ws(arguments[0],arguments[1]),s=new Rs(this.getRoot(),n,t);return this.nearestNeighbourK(s,e)}}}isWithinDistance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=r.POSITIVE_INFINITY;const s=new Cs;for(s.add(t);!s.isEmpty();){const t=s.poll(),i=t.getDistance();if(i>e)return!1;if(t.maximumDistance()<=e)return!0;if(t.isLeaves()){if(n=i,n<=e)return!0}else t.expandToQueue(s,n)}return!1}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Rs(this.getRoot(),t.getRoot(),e);return this.isWithinDistance(s,n)}}get interfaces_(){return[Es,c]}}class Ms extends Ls{constructor(){super(),Ms.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0];Ls.constructor_.call(this,t)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new O(n.getBounds()):t.expandToInclude(n.getBounds())}return t}}vs.STRtreeNode=Ms,vs.xComparator=new class{get interfaces_(){return[a]}compare(t,e){return Ps.compareDoubles(vs.centreX(t.getBounds()),vs.centreX(e.getBounds()))}},vs.yComparator=new class{get interfaces_(){return[a]}compare(t,e){return Ps.compareDoubles(vs.centreY(t.getBounds()),vs.centreY(e.getBounds()))}},vs.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},vs.DEFAULT_NODE_CAPACITY=10;var bs=Object.freeze({__proto__:null,STRtree:vs}),Ds=Object.freeze({__proto__:null,kdtree:ds,quadtree:Ns,strtree:bs});const As=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class Fs{constructor(t){this.geometryFactory=t||new Ct}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!Gs[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==As.indexOf(n)?Gs[n].call(this,e.coordinates):"GeometryCollection"===n?Gs[n].call(this,e.geometries):Gs[n].call(this,e)}write(t){const e=t.getGeometryType();if(!qs[e])throw new Error("Geometry is not supported");return qs[e].call(this,t)}}const Gs={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!Gs[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Gs.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new m(s[0],s[1]))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new m(t[0],t[1]),new m(t[2],t[1]),new m(t[2],t[3]),new m(t[0],t[3]),new m(t[0],t[1])])},Point:function(t){const e=new m(...t);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Gs.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=Gs.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Gs.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=Gs.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=Gs.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(Gs.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},qs={coordinate:function(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e},Point:function(t){return{type:"Point",coordinates:qs.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=qs.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(qs.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=qs.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=qs.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=qs.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=qs.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(qs[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Bs(t){return[t.x,t.y]}var Ys=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new Fs(t||new Ct)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new Fs(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Ct,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new m(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new m(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Bs);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Bs);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Bs)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Bs));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Bs))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Ht(t||new Ct)}read(t){return this.parser.read(t)}},WKTWriter:Wt});class Vs{static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=Vs.relativeSign(e.x,n.x),i=Vs.relativeSign(e.y,n.y);switch(t){case 0:return Vs.compareValue(s,i);case 1:return Vs.compareValue(i,s);case 2:return Vs.compareValue(i,-s);case 3:return Vs.compareValue(-s,i);case 4:return Vs.compareValue(-s,-i);case 5:return Vs.compareValue(-i,-s);case 6:return Vs.compareValue(-i,s);case 7:return Vs.compareValue(s,-i)}return g.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}}class zs{constructor(){zs.constructor_.apply(this,arguments)}static constructor_(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new m(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:this._isInterior?e._isInterior?Vs.compare(this._segmentOctant,this.coord,e.coord):1:-1}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}toString(){return this.segmentIndex+":"+this.coord.toString()}isInterior(){return this._isInterior}get interfaces_(){return[o]}}class ks{constructor(){ks.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Hn,this._edge=null;const t=arguments[0];this._edge=t}getSplitCoordinates(){const t=new R;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new L;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}createSplitEdgePts(t,e){let n=e.segmentIndex-t.segmentIndex+2;if(2===n)return[new m(t.coord),new m(e.coord)];const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new m(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new m(e.coord)),r}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e),s=(this._edge.getCoordinate(e+1),this._edge.getCoordinate(e+2));n.equals2D(s)&&t.add(M.valueOf(e+1))}}addEdgeCoordinates(t,e,n){const s=this.createSplitEdgePts(t,e);n.add(s,!1)}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(M.valueOf(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){const n=this.createSplitEdgePts(t,e);return new Ws(n,this._edge.getData())}add(t,e){const n=new zs(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(g.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new h("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new h("bad split edge end point at "+i)}}class Xs{static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new s("Cannot compute the octant for point ( "+t+", "+e+" )");const n=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?n>=i?0:1:n>=i?7:6:e>=0?n>=i?3:2:n>=i?4:5}if(arguments[0]instanceof m&&arguments[1]instanceof m){const t=arguments[0],e=arguments[1],n=e.x-t.x,i=e.y-t.y;if(0===n&&0===i)throw new s("Cannot compute the octant for two identical points "+t);return Xs.octant(n,i)}}}class Us{getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}}class Hs{addIntersection(t,e){}get interfaces_(){return[Us]}}class Ws{constructor(){Ws.constructor_.apply(this,arguments)}static constructor_(){this._nodeList=new ks(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new L;return Ws.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[1];for(let e=arguments[0].iterator();e.hasNext();){e.next().getNodeList().addSplitEdges(t)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Xs.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[1],e=arguments[3],n=new m(arguments[0].getIntersection(e));this.addIntersection(n,t)}}toString(){return Wt.toLineString(new pt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}get interfaces_(){return[Hs]}}class Zs{constructor(){Zs.constructor_.apply(this,arguments)}static constructor_(){this._overlapSeg1=new Kt,this._overlapSeg2=new Kt}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3];arguments[0].getLineSegment(t,this._overlapSeg1),e.getLineSegment(n,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}}class js{constructor(){js.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new O(t,e)}return this._env}overlaps(t,e,n,s,i){return O.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}}class Ks{static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=wn.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(wn.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Ks.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new L;let s=0;do{const i=Ks.findChainEnd(t,s),r=new js(t,s,i,e);n.add(r),s=i}while(s<t.length-1);return n}}}class Qs{computeNodes(t){}getNodedSubstrings(){}}class Js{constructor(){Js.constructor_.apply(this,arguments)}static constructor_(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}}setSegmentIntersector(t){this._segInt=t}get interfaces_(){return[Qs]}}class $s extends Js{constructor(){super(),$s.constructor_.apply(this,arguments)}static constructor_(){if(this._monoChains=new L,this._index=new vs,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];Js.constructor_.call(this,t)}}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Ws.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Ks.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new ti(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}}class ti extends Zs{constructor(){super(),ti.constructor_.apply(this,arguments)}static constructor_(){this._si=null;const t=arguments[0];this._si=t}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[1],e=arguments[2],n=arguments[3],s=arguments[0].getContext(),i=e.getContext();this._si.processIntersections(s,t,i,n)}}}$s.SegmentOverlapAction=ti;class ei{constructor(){ei.constructor_.apply(this,arguments)}static constructor_(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ei.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}}rescale(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&B.out.println(t)}}scale(){if(I(arguments[0],N)){const t=arguments[0],e=new L(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Ws(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new m(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].getZ());return dt.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}get interfaces_(){return[Qs]}}var ni=Object.freeze({__proto__:null,MCIndexNoder:$s,ScaledNoder:ei,SegmentString:Us});class si{constructor(){si.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];si.constructor_.call(this,t,gn.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}}static getBoundary(){if(1===arguments.length){return new si(arguments[0]).getBoundary()}if(2===arguments.length){return new si(arguments[0],arguments[1]).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof J?this.boundaryLineString(this._geom):this._geom instanceof wt?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new L;this._endpointMap=new Hn;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return dt.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new ii,this._endpointMap.put(t,e)),e.count++}}class ii{constructor(){ii.constructor_.apply(this,arguments)}static constructor_(){this.count=null}}class ri{constructor(){ri.constructor_.apply(this,arguments)}static constructor_(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}}static isSimple(){if(1===arguments.length){return new ri(arguments[0]).isSimple()}if(2===arguments.length){return new ri(arguments[0],arguments[1]).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new lt;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=ye.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new Hn;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.isClosed(),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new ls(0,t),n=new jt,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new oi(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof J||t instanceof wt?this.isSimpleLinearGeometry(t):t instanceof ht?this.isSimpleMultiPoint(t):I(t,st)?this.isSimplePolygonal(t):!(t instanceof ct)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}}class oi{constructor(){oi.constructor_.apply(this,arguments)}static constructor_(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}}ri.EndpointInfo=oi;class li{constructor(){li.constructor_.apply(this,arguments)}static constructor_(){if(this._quadrantSegments=li.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=li.CAP_ROUND,this._joinStyle=li.JOIN_ROUND,this._mitreLimit=li.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=li.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=li.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=li.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==li.JOIN_ROUND&&(this._quadrantSegments=li.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}}li.CAP_ROUND=1,li.CAP_FLAT=2,li.CAP_SQUARE=3,li.JOIN_ROUND=1,li.JOIN_MITRE=2,li.JOIN_BEVEL=3,li.DEFAULT_QUADRANT_SEGMENTS=8,li.DEFAULT_MITRE_LIMIT=5,li.DEFAULT_SIMPLIFY_FACTOR=.01;class ai{constructor(){ai.constructor_.apply(this,arguments)}static constructor_(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();g.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=G.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===G.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===G.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=Mn.LEFT;return n[e].y<n[e+1].y&&(s=Mn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}g.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe;this.getRightmostSide(this._minDe,this._minIndex)===Mn.LEFT&&(this._orientedDe=this._minDe.getSym())}}class ci{constructor(){this.array=[]}addLast(t){this.array.push(t)}removeFirst(){return this.array.shift()}isEmpty(){return 0===this.array.length}}class hi{constructor(){hi.constructor_.apply(this,arguments)}static constructor_(){this._finder=null,this._dirEdgeList=new L,this._nodes=new L,this._rightMostCoord=null,this._env=null,this._finder=new ai}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new ss("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(Mn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(Mn.RIGHT)>=1&&e.getDepth(Mn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new xt,n=new ci,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new O;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new en;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(Mn.LEFT,t.getDepth(Mn.RIGHT)),e.setDepth(Mn.RIGHT,t.getDepth(Mn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}get interfaces_(){return[o]}}class ui{constructor(){ui.constructor_.apply(this,arguments)}static constructor_(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new L,this._pts=new L,this._label=new qn(Qt.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new L,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=G.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new ss("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new ss("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();g.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!Ue.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[1],e=arguments[0].getLocation(t,Mn.RIGHT);if(e===Qt.NONE)return null;if(this._label.getLocation(t)===Qt.NONE)return this._label.setLocation(t,e),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}}class gi extends ui{constructor(){super(),gi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ui.constructor_.call(this,t,e)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}}class di extends ui{constructor(){super(),di.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ui.constructor_.call(this,t,e)}buildMinimalRings(){const t=new L;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new gi(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}}class _i{constructor(){_i.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=null,this._shellList=new L;const t=arguments[0];this._geometryFactory=t}static findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getLinearRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=dt.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;Ue.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getLinearRing().getEnvelopeInternal())}return r}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=_i.findEdgeRingContaining(e,t);if(null===n)throw new ss("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}buildMaximalEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new di(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return g.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];os.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new L,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}}class pi{constructor(){pi.constructor_.apply(this,arguments)}static constructor_(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=G.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t}static simplify(t,e){return new pi(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=pi.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){if(!(G.index(t,e,n)===this._angleOrientation))return!1;return V.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/pi.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return G.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=G.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===pi.DELETE;)e++;return e}isShallow(t,e,n,s){return V.pointToSegment(e,t,n)<s}collapseLine(){const t=new R;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==pi.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}}pi.INIT=0,pi.DELETE=1,pi.KEEP=1,pi.NUM_PTS_TO_CHECK=10;class mi{constructor(){mi.constructor_.apply(this,arguments)}static constructor_(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new L}getCoordinates(){return this._ptList.toArray(mi.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new m(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Ct).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new m(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}}mi.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class fi{constructor(){fi.constructor_.apply(this,arguments)}static constructor_(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new Kt,this._seg1=new Kt,this._offset0=new Kt,this._offset1=new Kt,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new jt,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===li.JOIN_ROUND&&(this._closingSegLengthFactor=fi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=G.index(this._s0,this._s1,this._s2),s=n===G.CLOCKWISE&&this._side===Mn.LEFT||n===G.COUNTERCLOCKWISE&&this._side===Mn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new Kt(t,e),s=new Kt;this.computeOffsetSegment(n,Mn.LEFT,this._distance,s);const i=new Kt;this.computeOffsetSegment(n,Mn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case li.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,G.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case li.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case li.CAP_SQUARE:const t=new m;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new m(s.p1.x+t.x,s.p1.y+t.y),r=new m(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){const i=q.intersection(e.p0,e.p1,n.p0,n.p1);if(null!==i){if((s<=0?1:i.distance(t)/Math.abs(s))<=this._bufParams.getMitreLimit())return this._segList.addPt(i),null}this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*fi.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===li.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===li.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new m(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new m(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new m(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===G.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=$t.angle(i,this._seg0.p0),o=$t.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2,l=$t.normalize(r+o),a=$t.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),g=i.y+c*Math.sin(a),d=new m(u,g),_=new Kt(i,d),p=_.pointAlongOffset(1,h),f=_.pointAlongOffset(1,-h);this._side===Mn.LEFT?(this._segList.addPt(p),this._segList.addPt(f)):(this._segList.addPt(f),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===G.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;const a=o/l,c=new m;for(let n=0;n<l;n++){const s=e+r*n*a;c.x=t.x+i*Math.cos(s),c.y=t.y+i*Math.sin(s),this._segList.addPt(c)}}computeOffsetSegment(t,e,n,s){const i=e===Mn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*fi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new m((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new m((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new m(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new mi,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*fi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2);this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===li.JOIN_BEVEL||this._bufParams.getJoinStyle()===li.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,G.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}}fi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,fi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,fi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,fi.MAX_CLOSING_SEG_LEN_FACTOR=80;class yi{constructor(){yi.constructor_.apply(this,arguments)}static constructor_(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new m(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&dt.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=pi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Mn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=pi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Mn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===Mn.RIGHT&&(s=-s);const i=pi.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=pi.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],Mn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=pi.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],Mn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case li.CAP_ROUND:e.createCircle(t);break;case li.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,this.isLineOffsetEmpty(e))return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return yi.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=pi.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Mn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=pi.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Mn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}isLineOffsetEmpty(t){return 0===t||t<0&&!this._bufParams.isSingleSided()}getSegGen(t){return new fi(this._precisionModel,this._bufParams,t)}}class xi{constructor(){xi.constructor_.apply(this,arguments)}static constructor_(){this._subgraphs=null,this._seg=new Kt;const t=arguments[0];this._subgraphs=t}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(I(arguments[2],w)&&arguments[0]instanceof m&&arguments[1]instanceof is){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse();if(Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(G.index(this._seg.p0,this._seg.p1,t)===G.RIGHT)continue;let r=e.getDepth(Mn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(Mn.RIGHT));const o=new Ei(this._seg,r);n.add(o)}}else if(I(arguments[2],w)&&arguments[0]instanceof m&&I(arguments[1],w)){const t=arguments[0],e=arguments[2];for(let n=arguments[1].iterator();n.hasNext();){const s=n.next();s.isForward()&&this.findStabbedSegments(t,s,e)}}}getDepth(t){const e=this.findStabbedSegments(t);if(0===e.size())return 0;return xe.min(e)._leftDepth}}class Ei{constructor(){Ei.constructor_.apply(this,arguments)}static constructor_(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new Kt(t),this._leftDepth=e}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}get interfaces_(){return[o]}}xi.DepthSegment=Ei;class Ii{constructor(){Ii.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n}addRingSide(t,e,n,s,i){if(0===e&&t.length<ut.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=ut.MINIMUM_VALID_SIZE&&G.isCCW(t)&&(r=i,o=s,n=Mn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}addRingBothSides(t,e){this.addRingSide(t,e,Mn.LEFT,Qt.EXTERIOR,Qt.INTERIOR),this.addRingSide(t,e,Mn.RIGHT,Qt.INTERIOR,Qt.EXTERIOR)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,Qt.EXTERIOR,Qt.INTERIOR)}addPolygon(t){let e=this._distance,n=Mn.LEFT;this._distance<0&&(e=-this._distance,n=Mn.RIGHT);const s=t.getExteriorRing(),i=dt.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addRingSide(i,e,n,Qt.EXTERIOR,Qt.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=dt.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addRingSide(r,e,Mn.opposite(n),Qt.INTERIOR,Qt.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new ne(t[0],t[1],t[2]),s=n.inCentre();return V.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._curveBuilder.isLineOffsetEmpty(this._distance))return null;const e=dt.removeRepeatedPoints(t.getCoordinates());if(dt.isRing(e)&&!this._curveBuilder.getBufferParameters().isSingleSided())this.addRingBothSides(e,this._distance);else{const t=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(t,Qt.EXTERIOR,Qt.INTERIOR)}}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Ws(t,new qn(0,Qt.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}add(t){if(t.isEmpty())return null;if(t instanceof it)this.addPolygon(t);else if(t instanceof J)this.addLineString(t);else if(t instanceof tt)this.addPoint(t);else if(t instanceof ht)this.addCollection(t);else if(t instanceof wt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else{if(!(t instanceof ct))throw new j(t.getGeometryType());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}}class Ni{constructor(){Ni.constructor_.apply(this,arguments)}static constructor_(){this._edgeMap=new Hn,this._edgeList=null,this._ptInAreaLocation=[Qt.NONE,Qt.NONE]}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=Qt.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,Mn.LEFT)!==Qt.NONE&&(e=s.getLocation(t,Mn.LEFT))}if(e===Qt.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,Mn.ON)===Qt.NONE&&i.setLocation(t,Mn.ON,n),i.isArea(t)){const e=i.getLocation(t,Mn.LEFT),r=i.getLocation(t,Mn.RIGHT);if(r!==Qt.NONE){if(r!==n)throw new ss("side location conflict",s.getCoordinate());e===Qt.NONE&&g.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else g.isTrue(i.getLocation(t,Mn.LEFT)===Qt.NONE,"found single null side"),i.setLocation(t,Mn.RIGHT,n),i.setLocation(t,Mn.LEFT,n)}}}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}print(t){B.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,Mn.LEFT);g.isTrue(s!==Qt.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();g.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,Mn.LEFT),r=n.getLocation(t,Mn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new L(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===Qt.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new v;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===Qt.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=Qt.NONE;if(e[n])r=Qt.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}}class Si extends Ni{constructor(){super(),Si.constructor_.apply(this,arguments)}static constructor_(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new ss("no outgoing dirEdge found",this.getCoordinate());g.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return wn.isNorthern(i)&&wn.isNorthern(r)?n:wn.isNorthern(i)||wn.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(g.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){B.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new L;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(Mn.LEFT),s=t.getDepth(Mn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new ss("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[1];let e=arguments[2];for(let n=arguments[0];n<t;n++){const t=this._edgeList.get(n);t.setEdgeDepths(Mn.RIGHT,e),e=t.getDepth(Mn.LEFT)}return e}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(g.isTrue(null!==e,"found null for first outgoing dirEdge"),g.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=Qt.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=Qt.INTERIOR;break}if(s.isInResult()){t=Qt.EXTERIOR;break}}}if(t===Qt.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===Qt.INTERIOR):(n.isInResult()&&(e=Qt.EXTERIOR),s.isInResult()&&(e=Qt.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new qn(Qt.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==Qt.INTERIOR&&n!==Qt.BOUNDARY||this._label.setLocation(t,Qt.INTERIOR)}}}}class wi extends rs{constructor(){super()}createNode(t){return new ts(t,new Si)}}class Ci{constructor(){Ci.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=Ci.orientation(t)}static orientation(t){return 1===dt.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return Ci.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}get interfaces_(){return[o]}}class Li{constructor(){Li.constructor_.apply(this,arguments)}static constructor_(){this._edges=new L,this._ocaMap=new Hn}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new Ci(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new Ci(t.getCoordinates());this._ocaMap.put(e,t)}}class Ti{processIntersections(t,e,n,s){}isDone(){}}class Ri{constructor(){Ri.constructor_.apply(this,arguments)}static constructor_(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Ri.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}get interfaces_(){return[Ti]}}class Pi{constructor(){Pi.constructor_.apply(this,arguments)}static constructor_(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Li;const t=arguments[0];this._bufParams=t}static depthDelta(t){const e=t.getLocation(0,Mn.LEFT),n=t.getLocation(0,Mn.RIGHT);return e===Qt.INTERIOR&&n===Qt.EXTERIOR?1:e===Qt.EXTERIOR&&n===Qt.INTERIOR?-1:0}static convertSegStrings(t){const e=new Ct,n=new L;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new qn(t.getLabel()),s.flip()),n.merge(s);const i=Pi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(Pi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new xi(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new L;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new hi;n.create(t),e.add(n)}}return xe.sort(e,xe.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new $s,n=new jt;return n.setPrecisionModel(t),e.setSegmentIntersector(new Ri(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new yi(n,this._bufParams),i=new Ii(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new os(new wi),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new _i(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();if(l.size()<=0)return this.createEmptyResultGeometry();return this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new $n(e.getCoordinates(),new qn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}}class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null;const t=arguments[0];this._segStrings=t}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new h("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new h("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new h("found non-noded collapse at "+Oi.fact.createLineString([t,e,n]))}}Oi.fact=new Ct;class vi{constructor(){vi.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new s("Scale factor must be non-zero");1!==e&&(this._pt=new m(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new m,this._p1Scaled=new m),this.initCorners(this._pt)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return g.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){const e=.5;this._minx=t.x-e,this._maxx=t.x+e,this._miny=t.y-e,this._maxy=t.y+e,this._corner[0]=new m(this._maxx,this._maxy),this._corner[1]=new m(this._minx,this._maxy),this._corner[2]=new m(this._minx,this._miny),this._corner[3]=new m(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=vi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new O(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}}vi.SAFE_ENV_EXPANSION_FACTOR=.75;class Mi{constructor(){Mi.constructor_.apply(this,arguments)}static constructor_(){this.selectedSegment=new Kt}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[1];arguments[0].getLineSegment(t,this.selectedSegment),this.select(this.selectedSegment)}}}class bi{constructor(){bi.constructor_.apply(this,arguments)}static constructor_(){this._index=null;const t=arguments[0];this._index=t}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Di(t,e,n);return this._index.query(s,new class{get interfaces_(){return[De]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}}class Di extends Mi{constructor(){super(),Di.constructor_.apply(this,arguments)}static constructor_(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof js))return super.select.apply(this,arguments);{const t=arguments[1],e=arguments[0].getContext();if(this._parentEdge===e&&(t===this._hotPixelVertexIndex||t+1===this._hotPixelVertexIndex))return null;this._isNodeAdded|=this._hotPixel.addSnappedNode(e,t)}}}bi.HotPixelSnapAction=Di;class Ai{constructor(){Ai.constructor_.apply(this,arguments)}static constructor_(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new L}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}get interfaces_(){return[Ti]}}class Fi{constructor(){Fi.constructor_.apply(this,arguments)}static constructor_(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new jt,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()}checkCorrectness(t){const e=Ws.getNodedSubstrings(t),s=new Oi(e);try{s.checkValid()}catch(t){if(!(t instanceof n))throw t;t.printStackTrace()}}getNodedSubstrings(){return Ws.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Ai(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Ws){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new vi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new $s,this._pointSnapper=new bi(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new vi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}get interfaces_(){return[Qs]}}class Gi{constructor(){Gi.constructor_.apply(this,arguments)}static constructor_(){if(this._argGeom=null,this._distance=null,this._bufParams=new li,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}}static bufferOp(){if(2===arguments.length){const t=arguments[1];return new Gi(arguments[0]).getResultGeometry(t)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof X&&"number"==typeof arguments[1]){const t=arguments[1],e=arguments[2],n=new Gi(arguments[0]);n.setQuadrantSegments(e);return n.getResultGeometry(t)}if(arguments[2]instanceof li&&arguments[0]instanceof X&&"number"==typeof arguments[1]){const t=arguments[1];return new Gi(arguments[0],arguments[2]).getResultGeometry(t)}}else if(4===arguments.length){const t=arguments[1],e=arguments[2],n=arguments[3],s=new Gi(arguments[0]);s.setQuadrantSegments(e),s.setEndCapStyle(n);return s.getResultGeometry(t)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=Y.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ei(new Fi(new Nt(1)),t.getScale()),n=new Pi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=Gi.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof ss))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=Gi.precisionScaleFactor(this._argGeom,this._distance,t),n=new Nt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===Nt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new Pi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof h))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}}Gi.CAP_ROUND=li.CAP_ROUND,Gi.CAP_BUTT=li.CAP_FLAT,Gi.CAP_FLAT=li.CAP_FLAT,Gi.CAP_SQUARE=li.CAP_SQUARE,Gi.MAX_PRECISION_DIGITS=12;var qi=Object.freeze({__proto__:null,BufferOp:Gi,BufferParameters:li});class Bi{constructor(){Bi.constructor_.apply(this,arguments)}static constructor_(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Bi.constructor_.call(this,t,Bi.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}}getSegmentIndex(){return this._segIndex}getCoordinate(){return this._pt}isInsideArea(){return this._segIndex===Bi.INSIDE_AREA}toString(){return this._component.getGeometryType()+"["+this._segIndex+"]-"+Wt.toPoint(this._pt)}getGeometryComponent(){return this._component}}Bi.INSIDE_AREA=-1;class Yi{constructor(){Yi.constructor_.apply(this,arguments)}static constructor_(){this._locations=null;const t=arguments[0];this._locations=t}static getLocations(t){const e=new L;return t.apply(new Yi(e)),e}filter(t){if(t.isEmpty())return null;(t instanceof tt||t instanceof J||t instanceof it)&&this._locations.add(new Bi(t,0,t.getCoordinate()))}get interfaces_(){return[Q]}}class Vi{constructor(){Vi.constructor_.apply(this,arguments)}static constructor_(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new fn,this._minDistanceLocation=null,this._minDistance=r.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];Vi.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}}static distance(t,e){return new Vi(t,e).distance()}static isWithinDistance(t,e,n){if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)return!1;return new Vi(t,e,n).distance()<=n}static nearestPoints(t,e){return new Vi(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ie.getPolygons(n);if(i.size()>0){const n=Yi.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&I(arguments[0],w)&&I(arguments[1],w)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Bi&&arguments[1]instanceof it){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(Qt.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Bi(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=ye.getLines(this._geom[0]),n=ye.getLines(this._geom[1]),s=Ee.getPoints(this._geom[0]),i=Ee.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){this.computeMinDistance();return[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof J&&arguments[1]instanceof tt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=V.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new Kt(s[r],s[r+1]).closestPoint(i);n[0]=new Bi(t,r,l),n[1]=new Bi(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof J&&arguments[1]instanceof J){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++){const o=new O(s[r],s[r+1]);if(!(o.distance(e.getEnvelopeInternal())>this._minDistance))for(let l=0;l<i.length-1;l++){const a=new O(i[l],i[l+1]);if(o.distance(a)>this._minDistance)continue;const c=V.segmentToSegment(s[r],s[r+1],i[l],i[l+1]);if(c<this._minDistance){this._minDistance=c;const o=new Kt(s[r],s[r+1]),a=new Kt(i[l],i[l+1]),h=o.closestPoints(a);n[0]=new Bi(t,r,h[0]),n[1]=new Bi(e,l,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Bi(i,0,i.getCoordinate()),n[1]=new Bi(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new s("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}}var zi=Object.freeze({__proto__:null,DistanceOp:Vi});class ki{constructor(){ki.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._directedEdges=new L,this._coordinates=null;const t=arguments[0];this._factory=t}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new R;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&dt.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}}class Xi{constructor(){Xi.constructor_.apply(this,arguments)}static constructor_(){this._isMarked=!1,this._isVisited=!1,this._data=null}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}}class Ui extends Xi{constructor(){super(),Ui.constructor_.apply(this,arguments)}static constructor_(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=wn.quadrant(i,r),this._angle=Math.atan2(r,i)}}static toEdges(t){const e=new L;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:G.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}get interfaces_(){return[o]}}class Hi extends Ui{constructor(){super(),Hi.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Ui.constructor_.call(this,t,e,n,s)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(g.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}}class Wi extends Xi{constructor(){super(),Wi.constructor_.apply(this,arguments)}static constructor_(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof ji){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}}class Zi{constructor(){Zi.constructor_.apply(this,arguments)}static constructor_(){this._outEdges=new L,this._sorted=!1}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(xe.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Wi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof Ui){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}}class ji extends Xi{constructor(){super(),ji.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];ji.constructor_.call(this,t,new Zi)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}}static getEdgesBetween(t,e){const n=Ui.toEdges(t.getOutEdges().getEdges()),s=new xt(n),i=Ui.toEdges(e.getOutEdges().getEdges());return s.retainAll(i),s}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}}class Ki extends Wi{constructor(){super(),Ki.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Qi{constructor(){Qi.constructor_.apply(this,arguments)}static constructor_(){this._nodeMap=new Hn}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}}class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static constructor_(){this._edges=new xt,this._dirEdges=new xt,this._nodeMap=new Qi}findNodesOfDegree(t){const e=new L;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Wi){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof Ui){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof ji){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Wi){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof Ui){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof ji){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Wi){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof Ui){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}}class $i extends Ji{constructor(){super()}addEdge(t){if(t.isEmpty())return null;const e=dt.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Hi(i,r,e[1],!0),l=new Hi(r,i,e[e.length-2],!1),a=new Ki(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new ji(t),this.add(e)),e}}class tr{constructor(){tr.constructor_.apply(this,arguments)}static constructor_(){this._graph=new $i,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(g.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Xi.setMarked(this._graph.nodeIterator(),!1),Xi.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new L,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new L;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new ki(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof X){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof J&&this.addLineString(n)}}else if(I(arguments[0],N)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}}class er{constructor(){er.constructor_.apply(this,arguments)}static constructor_(){this._parentGraph=null,this._edges=new xt,this._dirEdges=new L,this._nodeMap=new Qi;const t=arguments[0];this._parentGraph=t}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}}class nr{constructor(){nr.constructor_.apply(this,arguments)}static constructor_(){this._graph=null;const t=arguments[0];this._graph=t}addReachable(t,e){const n=new en;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new er(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new L;Xi.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}}class sr{constructor(){sr.constructor_.apply(this,arguments)}static constructor_(){this._graph=new $i,this._factory=new Ct,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=M.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof wt))return!0;const e=t,n=new lt;let s=null;const i=new L;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new m(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new sr;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();g.isTrue(this._lineCount===e,"Lines were missing from result"),g.isTrue(this._sequencedGeometry instanceof J||this._sequencedGeometry instanceof wt,"Result is not lineal")}findSequences(){const t=new L;for(let e=new nr(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=sr.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&g.isTrue(i===s,"path not contiguous")}findSequence(t){Xi.setVisited(t.edgeIterator(),!1);const e=sr.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new ci,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=sr.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new ci;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new L;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=sr.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof X){arguments[0].apply(new class{get interfaces_(){return[k]}filter(t){t instanceof J&&this.addLine(t)}})}}}var ir=Object.freeze({__proto__:null,LineMerger:tr,LineSequencer:sr});class rr{constructor(){rr.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new Kt,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof J&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];rr.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=rr.isClosed(t),this._snapTolerance=e}}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new m(i)),0===s&&this._isClosed&&t.set(t.size()-1,new m(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new R(this._srcPts);this.snapVertices(e,t),this.snapSegments(e,t);return e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new m(n),!1)}}findSegmentIndexToSnap(t,e){let n=r.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}}class or{constructor(){or.constructor_.apply(this,arguments)}static constructor_(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t}static snap(t,e,n){const s=new Array(2).fill(null),i=new or(t);s[0]=i.snapTo(e,n);const r=new or(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=or.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===Nt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(or.computeOverlaySnapTolerance(t),or.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*or.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new or(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new lr(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new lr(t,n,!0).transform(this._srcGeom);let i=s;return e&&I(i,st)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new lt,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=r.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}}or.SNAP_PRECISION_FACTOR=1e-9;class lr extends me{constructor(){super(),lr.constructor_.apply(this,arguments)}static constructor_(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}}snapLine(t,e){const n=new rr(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}}var ar=Object.freeze({__proto__:null,GeometrySnapper:or,LineStringSnapper:rr});class cr{constructor(){cr.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Xs.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Wt.toLineString(new pt(this._pts))}get interfaces_(){return[Us]}}class hr{constructor(){hr.constructor_.apply(this,arguments)}static constructor_(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._keepIntersections=!0,this._isInteriorIntersectionsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new L,this._intersectionCount=0;const t=arguments[0];this._li=t,this._interiorIntersection=null}static createAllIntersectionsFinder(t){const e=new hr(t);return e.setFindAllIntersections(!0),e}static isInteriorVertexIntersection(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3];return(!arguments[2]||!n)&&!!t.equals2D(e)}if(8===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6],l=arguments[7];return!!hr.isInteriorVertexIntersection(t,n,i,o)||(!!hr.isInteriorVertexIntersection(t,s,i,l)||(!!hr.isInteriorVertexIntersection(e,n,r,o)||!!hr.isInteriorVertexIntersection(e,s,r,l)))}}static createInteriorIntersectionCounter(t){const e=new hr(t);return e.setInteriorIntersectionsOnly(!0),e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static createIntersectionCounter(t){const e=new hr(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}static isEndSegment(t,e){return 0===e||e>=t.size()-2}static createAnyIntersectionFinder(t){return new hr(t)}static createInteriorIntersectionsFinder(t){const e=new hr(t);return e.setFindAllIntersections(!0),e.setInteriorIntersectionsOnly(!0),e}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}getIntersection(){return this._interiorIntersection}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;const i=t===n;if(i&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(hr.isEndSegment(t,e)||hr.isEndSegment(n,s)))return null}const r=t.getCoordinate(e),o=t.getCoordinate(e+1),l=n.getCoordinate(s),a=n.getCoordinate(s+1),c=0===e,h=e+2===t.size(),u=0===s,g=s+2===n.size();this._li.computeIntersection(r,o,l,a);const d=this._li.hasIntersection()&&this._li.isInteriorIntersection();let _=!1;if(!this._isInteriorIntersectionsOnly){_=!(i&&Math.abs(s-e)<=1)&&hr.isInteriorVertexIntersection(r,o,l,a,c,h,u,g)}(d||_)&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=r,this._intSegments[1]=o,this._intSegments[2]=l,this._intSegments[3]=a,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}setInteriorIntersectionsOnly(t){this._isInteriorIntersectionsOnly=t}get interfaces_(){return[Ti]}}class ur{constructor(){ur.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t}static computeIntersections(t){const e=new ur(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new hr(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new $s;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new ss(this.getErrorMessage(),this._segInt.getIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Wt.toLineString(t[0],t[1])+" and "+Wt.toLineString(t[2],t[3])}}class gr{constructor(){gr.constructor_.apply(this,arguments)}static constructor_(){this._nv=null;const t=arguments[0];this._nv=new ur(gr.toSegmentStrings(t))}static toSegmentStrings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new cr(t.getCoordinates(),t))}return e}static checkValid(t){new gr(t).checkValid()}checkValid(){this._nv.checkValid()}}class dr{constructor(){dr.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new L,this._resultLineList=new L;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!Nr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=this._geometryFactory.createLineString(e.getCoordinates());this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(g.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(Nr.isResultOfOp(s,e)&&e===Nr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}}class _r{constructor(){_r.constructor_.apply(this,arguments)}static constructor_(){this._op=null,this._geometryFactory=null,this._resultPointList=new L;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===Nr.INTERSECTION))){const e=n.getLabel();Nr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}}class pr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new i,this._commonSignExp=null}getCommon(){return r.longBitsToDouble(this._commonBits)}add(t){const e=r.doubleToLongBits(t);if(this._isFirst)return this._commonBits=e,this._commonSignExp=pr.signExpBits(this._commonBits),this._isFirst=!1,null;if(pr.signExpBits(e)!==this._commonSignExp)return this._commonBits.high=0,this._commonBits.low=0,null;this._commonMantissaBitsCount=pr.numCommonMostSigMantissaBits(this._commonBits,e),this._commonBits=pr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))}toString(){if(1===arguments.length){const t=arguments[0],e=r.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+i.toBinaryString(t),s=n.substring(n.length-64);return s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]"}}getClass(){return pr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(pr.getBit(t,s)!==pr.getBit(e,s))return n;n++}return 52}}class mr{constructor(){mr.constructor_.apply(this,arguments)}static constructor_(){this._commonCoord=null,this._ccFilter=new fr}addCommonBits(t){const e=new yr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new m(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new yr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}}class fr{constructor(){fr.constructor_.apply(this,arguments)}static constructor_(){this._commonBitsX=new pr,this._commonBitsY=new pr}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new m(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}get interfaces_(){return[U]}}class yr{constructor(){yr.constructor_.apply(this,arguments)}static constructor_(){this.trans=null;const t=arguments[0];this.trans=t}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}get interfaces_(){return[P]}}mr.CommonCoordinateFilter=fr,mr.Translater=yr;class xr{constructor(){xr.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()}static overlayOp(t,e,n){return new xr(t,e).getResultGeometry(n)}static union(t,e){return xr.overlayOp(t,e,Nr.UNION)}static intersection(t,e){return xr.overlayOp(t,e,Nr.INTERSECTION)}static symDifference(t,e){return xr.overlayOp(t,e,Nr.SYMDIFFERENCE)}static difference(t,e){return xr.overlayOp(t,e,Nr.DIFFERENCE)}selfSnap(t){return new or(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new mr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=Nr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||B.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=or.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return or.snap(e[0],e[1],this._snapTolerance)}}class Er{constructor(){Er.constructor_.apply(this,arguments)}static constructor_(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e}static overlayOp(t,e,n){return new Er(t,e).getResultGeometry(n)}static union(t,e){return Er.overlayOp(t,e,Nr.UNION)}static intersection(t,e){return Er.overlayOp(t,e,Nr.INTERSECTION)}static symDifference(t,e){return Er.overlayOp(t,e,Nr.SYMDIFFERENCE)}static difference(t,e){return Er.overlayOp(t,e,Nr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=Nr.overlayOp(this._geom[0],this._geom[1],t); true&&(n=!0)}catch(t){if(!(t instanceof h))throw t;s=t}if(!n)try{e=xr.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof h?s:t}return e}}class Ir{constructor(){Ir.constructor_.apply(this,arguments)}static constructor_(){if(this._li=new jt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new ls(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ir.constructor_.call(this,t,e,gn.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new ls(0,t,n),this._arg[1]=new ls(1,e,n)}}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}}class Nr extends Ir{constructor(){super(),Nr.constructor_.apply(this,arguments)}static constructor_(){this._ptLocator=new fn,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new Li,this._resultPolyList=new L,this._resultLineList=new L,this._resultPointList=new L;const t=arguments[0],e=arguments[1];Ir.constructor_.call(this,t,e),this._graph=new os(new wi),this._geomFact=t.getFactory()}static overlayOp(t,e,n){return new Nr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Nr.createEmptyResult(Nr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Er.overlayOp(t,e,Nr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return Nr.createEmptyResult(Nr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ce.map(t,new class{get interfaces_(){return[MapOp]}map(t){return Nr.intersection(t,n)}})}return Er.overlayOp(t,e,Nr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Nr.createEmptyResult(Nr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Er.overlayOp(t,e,Nr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case Nr.INTERSECTION:r=Math.min(s,i);break;case Nr.UNION:r=Math.max(s,i);break;case Nr.DIFFERENCE:r=s;break;case Nr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){const i=Nr.resultDimension(t,e,n);return s.createEmpty(i)}static difference(t,e){if(t.isEmpty())return Nr.createEmptyResult(Nr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new s("This method does not support GeometryCollection arguments");return Er.overlayOp(t,e,Nr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return Nr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1],n=arguments[2];switch(t===Qt.BOUNDARY&&(t=Qt.INTERIOR),e===Qt.BOUNDARY&&(e=Qt.INTERIOR),n){case Nr.INTERSECTION:return t===Qt.INTERIOR&&e===Qt.INTERIOR;case Nr.UNION:return t===Qt.INTERIOR||e===Qt.INTERIOR;case Nr.DIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR;case Nr.SYMDIFFERENCE:return t===Qt.INTERIOR&&e!==Qt.INTERIOR||t!==Qt.INTERIOR&&e===Qt.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new qn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new L;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?Nr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==Qt.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new L;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new L;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),gr.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new _i(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new dr(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new _r(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&Nr.isResultOfOp(s.getLocation(0,Mn.RIGHT),s.getLocation(1,Mn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(g.isTrue(!s.isNull(t,Mn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,Mn.LEFT,s.getLocation(t,Mn.LEFT)),g.isTrue(!s.isNull(t,Mn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,Mn.RIGHT,s.getLocation(t,Mn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}}Nr.INTERSECTION=1,Nr.UNION=2,Nr.DIFFERENCE=3,Nr.SYMDIFFERENCE=4;var Sr=Object.freeze({__proto__:null,snap:ar,OverlayOp:Nr});class wr extends Ui{constructor(){super(),wr.constructor_.apply(this,arguments)}static constructor_(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Ui.constructor_.call(this,t,e,n,s)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}}class Cr extends Wi{constructor(){super(),Cr.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}getLine(){return this._line}}class Lr{constructor(){Lr.constructor_.apply(this,arguments)}static constructor_(){this._geometryFactory=new Ct,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){if(t.isEmpty())return null;const n=t.getCoordinates(),s=n[0],i=Lr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR&&(l=o.getSym()),g.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof it){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof ft){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{g.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new di(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,Mn.RIGHT)===Qt.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new L;this._geomGraph.computeSplitEdges(t);const e=new os(new wi);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}}class Tr{createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new ns(t,n.coord,r,new qn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new qn(t.getLabel());o.flip();const l=new ns(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new L;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}}class Rr extends ns{constructor(){super(),Rr.constructor_.apply(this,arguments)}static constructor_(){if(this._edgeEnds=new L,1===arguments.length){const t=arguments[0];Rr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];ns.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new qn(t.getLabel())),this.insert(t)}}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===Qt.BOUNDARY&&n++,i===Qt.INTERIOR&&(s=!0)}let i=Qt.NONE;s&&(i=Qt.INTERIOR),n>0&&(i=ls.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===Qt.INTERIOR)return this._label.setLocation(t,e,Qt.INTERIOR),null;n===Qt.EXTERIOR&&this._label.setLocation(t,e,Qt.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,Mn.LEFT),this.computeLabelSide(t,Mn.RIGHT)}updateIM(t){$n.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new qn(Qt.NONE,Qt.NONE,Qt.NONE):new qn(Qt.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}}class Pr extends Ni{constructor(){super()}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new Rr(t),this.insertEdgeEnd(t,e)):e.insert(t)}}class Or extends ts{constructor(){super(),Or.constructor_.apply(this,arguments)}static constructor_(){const t=arguments[0],e=arguments[1];ts.constructor_.call(this,t,e)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}}class vr extends rs{constructor(){super()}createNode(t){return new Or(t,new Pr)}}class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static constructor_(){this._nodes=new es(new vr)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new Tr).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===Qt.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,Qt.INTERIOR)}}}}class br{constructor(){br.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._geomGraph=null,this._nodeGraph=new Mr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}}class Dr{constructor(){Dr.constructor_.apply(this,arguments)}static constructor_(){this._graph=null,this._rings=new L,this._totalEnv=new O,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t}buildIndex(){this._index=new vs;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Fr.findPtNotNode(n,i,this._graph);if(null===o)continue;if(Ue.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}}class Ar{constructor(){Ar.constructor_.apply(this,arguments)}static constructor_(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Ar.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}}getErrorType(){return this._errorType}getMessage(){return Ar.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}}Ar.ERROR=0,Ar.REPEATED_POINT=1,Ar.HOLE_OUTSIDE_SHELL=2,Ar.NESTED_HOLES=3,Ar.DISCONNECTED_INTERIOR=4,Ar.SELF_INTERSECTION=5,Ar.RING_SELF_INTERSECTION=6,Ar.NESTED_SHELLS=7,Ar.DUPLICATE_RINGS=8,Ar.TOO_FEW_POINTS=9,Ar.INVALID_COORDINATE=10,Ar.RING_NOT_CLOSED=11,Ar.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Fr{constructor(){Fr.constructor_.apply(this,arguments)}static constructor_(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof X){return new Fr(arguments[0]).isValid()}if(arguments[0]instanceof m){const t=arguments[0];return!r.isNaN(t.x)&&(!r.isInfinite(t.x)&&(!r.isNaN(t.y)&&!r.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Fr.isValid(t[e]))return this._validErr=new Ar(Ar.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof it){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){if(t.getNumInteriorRing()<=0)return null;const n=new Dr(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);s.isEmpty()||n.add(s)}n.isNonNested()||(this._validErr=new Ar(Ar.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new br(t);if(!e.isNodeConsistentArea())return this._validErr=new Ar(Ar.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Ar(Ar.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Fr.findPtNotNode(s,e,n);if(null!==r){if(!Ue.isInRing(r,i))return r}const o=Fr.findPtNotNode(i,t,n);if(null!==o){return Ue.isInRing(o,s)?o:null}return g.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new Lr(t);e.isInteriorsConnected()||(this._validErr=new Ar(Ar.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new lt;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Ar(Ar.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){if(t.getNumInteriorRing()<=0)return null;const n=t.getExteriorRing(),s=n.isEmpty(),i=new ze(n);for(let r=0;r<t.getNumInteriorRing();r++){const o=t.getInteriorRingN(r);let l=null;if(o.isEmpty())continue;if(l=Fr.findPtNotNode(o.getCoordinates(),n,e),null===l)return null;if(s||Qt.EXTERIOR===i.locate(l))return this._validErr=new Ar(Ar.HOLE_OUTSIDE_SHELL,l),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Ar(Ar.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof tt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof ht){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof ut){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new ls(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new jt;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof J){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new ls(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof it){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new ls(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof ft){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new ls(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof ct){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof X){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof tt)this.checkValid(t);else if(t instanceof ht)this.checkValid(t);else if(t instanceof ut)this.checkValid(t);else if(t instanceof J)this.checkValid(t);else if(t instanceof it)this.checkValid(t);else if(t instanceof ft)this.checkValid(t);else{if(!(t instanceof ct))throw new j(t.getGeometryType());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing();if(i.isEmpty())return null;const r=i.getCoordinates(),o=Fr.findPtNotNode(s,i,n);if(null===o)return null;if(!Ue.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Ar(Ar.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Ar(Ar.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(t.isEmpty())return null;if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Ar(Ar.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}}class Gr{constructor(){Gr.constructor_.apply(this,arguments)}static constructor_(){this._factory=null,this._deList=new L,this._lowestEdge=null,this._ring=null,this._locator=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t}static findDirEdgesInRing(t){let e=t;const n=new L;do{n.add(e),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing().getEnvelopeInternal();if(l.equals(s))continue;if(!l.contains(s))continue;i=dt.ptNotInList(n.getCoordinates(),e.getCoordinates());e.isInRing(i)&&(null===r||o.contains(l))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new R;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();Gr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Fr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),g.isTrue(null!==e,"found null DE in ring"),g.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isInRing(t){return Qt.EXTERIOR!==this.getLocator().locate(t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof ut){const t=arguments[0];null===this._holes&&(this._holes=new L),this._holes.add(t)}else if(arguments[0]instanceof Gr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new L),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=G.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Wt.toLineString(new pt(this.getCoordinates()))}getLocator(){return null===this._locator&&(this._locator=new ze(this.getRing())),this._locator}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&B.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof n))throw t;B.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}}Gr.EnvelopeComparator=class{compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}get interfaces_(){return[a]}};class qr extends Ji{constructor(){super(),qr.constructor_.apply(this,arguments)}static constructor_(){this._factory=null;const t=arguments[0];this._factory=t}static findLabeledEdgeRings(t){const e=new L;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=Gr.findDirEdgesInRing(t);qr.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(g.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();qr.getDegree(i,e)>1&&(null===s&&(s=new L),s.add(i)),n=n.getNext(),g.isTrue(null!==n,"found null DE in ring"),g.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new Gr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();qr.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=dt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new wr(i,r,e[1],!0),l=new wr(r,i,e[e.length-2],!1),a=new Cr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),qr.findLabeledEdgeRings(this._dirEdges);const t=new L;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),qr.label(this._dirEdges,-1);const t=qr.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new L;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new ji(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=qr.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();qr.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new xt,n=new en;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();qr.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===qr.getDegreeNonDeleted(o)&&n.push(o)}}return e}}class Br{constructor(){Br.constructor_.apply(this,arguments)}static constructor_(){this._shells=null,this._shellIndex=null;const t=arguments[0];this._shells=t,this.buildIndex()}static assignHolesToShells(t,e){new Br(e).assignHolesToShells(t)}assignHolesToShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.assignHoleToShell(t)}}buildIndex(){this._shellIndex=new vs;for(const t of this._shells)this._shellIndex.insert(t.getRing().getEnvelopeInternal(),t)}queryOverlappingShells(t){return this._shellIndex.query(t)}findShellContaining(t){const e=t.getRing().getEnvelopeInternal(),n=this.queryOverlappingShells(e);return Gr.findEdgeRingContaining(t,n)}assignHoleToShell(t){const e=this.findShellContaining(t);null!==e&&e.addHole(t)}}class Yr{constructor(){Yr.constructor_.apply(this,arguments)}static constructor_(){if(this._lineStringAdder=new Vr(this),this._graph=null,this._dangles=new L,this._cutEdges=new L,this._invalidRingLines=new L,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Yr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}}static extractPolygons(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static findDisjointShells(t){Yr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Ct),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Ct.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new L,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new L;this._invalidRingLines=new L,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Br.assignHolesToShells(this._holeList,this._shellList),xe.sort(this._shellList,new Gr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Yr.findDisjointShells(this._shellList),n=!1),this._polyList=Yr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(I(arguments[0],N)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof J){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new qr(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof X){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new L,this._shellList=new L;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}}class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static constructor_(){this.p=null;const t=arguments[0];this.p=t}filter(t){t instanceof J&&this.p.add(t)}get interfaces_(){return[k]}}Yr.LineStringAdder=Vr;var zr=Object.freeze({__proto__:null,Polygonizer:Yr});class kr{constructor(){kr.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._ptLocator=new fn,this._arg=null,this._nodes=new es(new vr),this._im=null,this._isolatedEdges=new L,this._invalidPoint=null;const t=arguments[0];this._arg=t}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,Qt.EXTERIOR)}computeIM(){const t=new Jt;if(t.set(Qt.EXTERIOR,Qt.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new Tr,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===Qt.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,Qt.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===Qt.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,Qt.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();g.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(Qt.INTERIOR,Qt.EXTERIOR,e.getDimension()),t.set(Qt.BOUNDARY,Qt.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(Qt.EXTERIOR,Qt.INTERIOR,n.getDimension()),t.set(Qt.EXTERIOR,Qt.BOUNDARY,n.getBoundaryDimension()))}}class Xr{constructor(){Xr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()}static contains(t,e){return new Xr(t).contains(e)}isContainedInBoundary(t){if(t instanceof it)return!1;if(t instanceof tt)return this.isPointContainedInBoundary(t);if(t instanceof J)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new m,s=new m;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof tt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof m){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}}class Ur{constructor(){Ur.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new m(t.getMinX(),t.getMinY()),this._diagUp1=new m(t.getMaxX(),t.getMaxY()),this._diagDown0=new m(t.getMinX(),t.getMaxY()),this._diagDown1=new m(t.getMaxX(),t.getMinY())}intersects(t,e){const n=new O(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}}class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static constructor_(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()}static intersects(t,e){return new Hr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Wr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new Zr(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new jr(this._rectangle);return s.applyTo(t),!!s.intersects()}}class Wr extends Ne{constructor(){super(),Wr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}}class Zr extends Ne{constructor(){super(),Zr.constructor_.apply(this,arguments)}static constructor_(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof it))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new m;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}}class jr extends Ne{constructor(){super(),jr.constructor_.apply(this,arguments)}static constructor_(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new m,this._p1=new m;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new Ur(this._rectEnv)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=ye.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}}class Kr extends Ir{constructor(){super(),Kr.constructor_.apply(this,arguments)}static constructor_(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];Ir.constructor_.call(this,t,e),this._relate=new kr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Ir.constructor_.call(this,t,e,n),this._relate=new kr(this._arg)}}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Kr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Hr.intersects(t,e);if(e.isRectangle())return Hr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Kr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Kr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Kr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){return new Kr(arguments[0],arguments[1]).getIntersectionMatrix()}if(3===arguments.length){return new Kr(arguments[0],arguments[1],arguments[2]).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Kr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Kr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Xr.contains(t,e):new Kr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}}var Qr=Object.freeze({__proto__:null,RelateOp:Kr});class Jr{constructor(){Jr.constructor_.apply(this,arguments)}static constructor_(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()}static union(t,e){return new Jr(t,e).union()}union(){const t=new fn,e=new lt;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===Qt.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=dt.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),he.combine(n,this._otherGeom)}}class $r{constructor(){$r.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._polygons=new L,this._lines=new L,this._points=new L,this._dimension=K.FALSE}static extract(){if(I(arguments[0],N)){const t=arguments[0],e=new $r;return e.add(t),e}if(arguments[0]instanceof X){const t=arguments[0],e=new $r;return e.add(t),e}}getFactory(){return this._geomFactory}recordDimension(t){t>this._dimension&&(this._dimension=t)}getDimension(){return this._dimension}filter(t){return this.recordDimension(t.getDimension()),t instanceof ct||t.isEmpty()?null:t instanceof it?(this._polygons.add(t),null):t instanceof J?(this._lines.add(t),null):t instanceof tt?(this._points.add(t),null):void g.shouldNeverReachHere("Unhandled geometry type: "+t.getGeometryType())}getExtract(t){switch(t){case 0:return this._points;case 1:return this._lines;case 2:return this._polygons}return g.shouldNeverReachHere("Invalid dimension: "+t),null}isEmpty(){return this._polygons.isEmpty()&&this._lines.isEmpty()&&this._points.isEmpty()}add(){if(I(arguments[0],N)){const t=arguments[0];for(const e of t)this.add(e)}else if(arguments[0]instanceof X){const t=arguments[0];null===this._geomFactory&&(this._geomFactory=t.getFactory()),t.apply(this)}}get interfaces_(){return[Q]}}class to{constructor(){to.constructor_.apply(this,arguments)}static constructor_(){this._geomFactory=null,this._g0=null,this._g1=null,this._isUnionSafe=null;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e,this._geomFactory=t.getFactory()}static containsProperly(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return!t.isNull()&&(e.getX()>t.getMinX()&&e.getX()<t.getMaxX()&&e.getY()>t.getMinY()&&e.getY()<t.getMaxY())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return to.containsProperly(t,e)&&to.containsProperly(t,n)}}static union(t,e){return new to(t,e).union()}static intersects(t,e,n){return t.intersects(e)||t.intersects(n)}static overlapEnvelope(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();return n.intersection(s)}static extractBorderSegments(t,e,n){t.apply(new class{get interfaces_(){return[P]}filter(t,s){if(s<=0)return null;const i=t.getCoordinate(s-1),r=t.getCoordinate(s);if(to.intersects(e,i,r)&&!to.containsProperly(e,i,r)){const t=new Kt(i,r);n.add(t)}}isDone(){return!1}isGeometryChanged(){return!1}})}static unionBuffer(t,e){return t.getFactory().createGeometryCollection([t,e]).buffer(0)}isBorderSegmentsSame(t,e){const n=this.extractBorderSegments(this._g0,this._g1,e),s=new L;return to.extractBorderSegments(t,e,s),this.isEqual(n,s)}extractByEnvelope(t,e,n){const s=new L;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);if(r.getEnvelopeInternal().intersects(t))s.add(r);else{const t=r.copy();n.add(t)}}return this._geomFactory.buildGeometry(s)}isEqual(t,e){if(t.size()!==e.size())return!1;const n=new xt(t);for(const t of e)if(!n.contains(t))return!1;return!0}union(){const t=to.overlapEnvelope(this._g0,this._g1);if(t.isNull()){const t=this._g0.copy(),e=this._g1.copy();return he.combine(t,e)}const e=new L,n=this.extractByEnvelope(t,this._g0,e),s=this.extractByEnvelope(t,this._g1,e),i=this.unionFull(n,s);let r=null;return this._isUnionSafe=this.isBorderSegmentsSame(i,t),r=this._isUnionSafe?this.combine(i,e):this.unionFull(this._g0,this._g1),r}combine(t,e){if(e.size()<=0)return t;e.add(t);return he.combine(e)}unionFull(t,e){try{return t.union(e)}catch(n){if(n instanceof ss)return to.unionBuffer(t,e);throw n}}extractBorderSegments(t,e,n){const s=new L;return to.extractBorderSegments(t,n,s),null!==e&&to.extractBorderSegments(e,n,s),s}isUnionOptimized(){return this._isUnionSafe}}class eo{constructor(){eo.constructor_.apply(this,arguments)}static constructor_(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new L)}static restrictToPolygons(t){if(I(t,st))return t;const e=Ie.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Ct.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new eo(t).union()}reduceToGeometries(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;I(t,w)?s=this.unionTree(t):t instanceof X&&(s=t),e.add(s)}return e}union(){if(null===this._inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new vs(eo.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=eo.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(eo.getGeometry(t,e),eo.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionActual(t,e)}unionActual(t,e){const n=to.union(t,e);return eo.restrictToPolygons(n)}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}}eo.STRTREE_NODE_CAPACITY=4;class no{constructor(){no.constructor_.apply(this,arguments)}static constructor_(){if(this._geomFact=null,this._extracter=null,1===arguments.length){if(I(arguments[0],N)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof X){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}}static union(){if(1===arguments.length){if(I(arguments[0],N)){return new no(arguments[0]).union()}if(arguments[0]instanceof X){return new no(arguments[0]).union()}}else if(2===arguments.length){return new no(arguments[0],arguments[1]).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return Er.overlayOp(t,e,Nr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)}extract(){if(I(arguments[0],N)){const t=arguments[0];this._extracter=$r.extract(t)}else if(arguments[0]instanceof X){const t=arguments[0];this._extracter=$r.extract(t)}}union(){if(null===this._geomFact&&(this._geomFact=this._extracter.getFactory()),null===this._geomFact)return null;if(this._extracter.isEmpty())return this._geomFact.createEmpty(this._extracter.getDimension());const t=this._extracter.getExtract(0),e=this._extracter.getExtract(1),n=this._extracter.getExtract(2);let s=null;if(t.size()>0){const e=this._geomFact.buildGeometry(t);s=this.unionNoOpt(e)}let i=null;if(e.size()>0){const t=this._geomFact.buildGeometry(e);i=this.unionNoOpt(t)}let r=null;n.size()>0&&(r=eo.union(n));const o=this.unionWithNull(i,r);let l=null;return l=null===s?o:null===o?s:Jr.union(s,o),null===l?this._geomFact.createGeometryCollection():l}}var so=Object.freeze({__proto__:null,UnaryUnionOp:no}),io=Object.freeze({__proto__:null,IsValidOp:Fr,ConsistentAreaTester:br}),ro=Object.freeze({__proto__:null,BoundaryOp:si,IsSimpleOp:ri,buffer:qi,distance:zi,linemerge:ir,overlay:Sr,polygonize:zr,relate:Qr,union:so,valid:io});class oo extends ue.CoordinateOperation{constructor(){super(),oo.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e}edit(){if(2===arguments.length&&arguments[1]instanceof X&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new m(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new R(n,!1).toCoordinateArray();let i=0;e instanceof J&&(i=2),e instanceof ut&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}}class lo{constructor(){lo.constructor_.apply(this,arguments)}static constructor_(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t}static reduce(t,e){return new lo(e).reduce(t)}static reducePointwise(t,e){const n=new lo(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));return Gi.bufferOp(e,0)}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new ue(n)}else e=new ue;let n=this._removeCollapsed;t.getDimension()>=2&&(n=!0);return e.edit(t,new oo(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new ue.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Ct(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:I(e,st)?Fr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new ue;const n=this.createFactory(t,e);return new ue(n)}}var ao=Object.freeze({__proto__:null,GeometryPrecisionReducer:lo});class co{constructor(){co.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new Kt;const t=arguments[0];this._pts=t}static simplify(t,e){const n=new co(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new R;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new m(this._pts[e]));return t.toCoordinateArray()}}class ho{constructor(){ho.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new ho(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new uo(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class uo extends me{constructor(){super(),uo.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof ft?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):co.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof it,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof ut?s:null}}ho.DPTransformer=uo;class go extends Kt{constructor(){super(),go.constructor_.apply(this,arguments)}static constructor_(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];go.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Kt.constructor_.call(this,t,e),this._parent=n,this._index=s}}getIndex(){return this._index}getParent(){return this._parent}}class _o{constructor(){_o.constructor_.apply(this,arguments)}static constructor_(){if(this._parentLine=null,this._segs=null,this._resultSegs=new L,this._minimumSize=null,1===arguments.length){const t=arguments[0];_o.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(_o.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(_o.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new go(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return _o.extractCoordinates(this._resultSegs)}}class po{constructor(){po.constructor_.apply(this,arguments)}static constructor_(){this._index=new Is}remove(t){this._index.remove(new O(t.p0,t.p1),t)}add(){if(arguments[0]instanceof _o){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof Kt){const t=arguments[0];this._index.insert(new O(t.p0,t.p1),t)}}query(t){const e=new O(t.p0,t.p1),n=new mo(t);this._index.query(e,n);return n.getItems()}}class mo{constructor(){mo.constructor_.apply(this,arguments)}static constructor_(){this._querySeg=null,this._items=new L;const t=arguments[0];this._querySeg=t}visitItem(t){const e=t;O.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}get interfaces_(){return[De]}}class fo{constructor(){fo.constructor_.apply(this,arguments)}static constructor_(){this._li=new jt,this._inputIndex=new po,this._outputIndex=new po,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new Kt(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new Kt;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new Kt;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(fo.isInLineSection(t,e,i))continue;return!0}}return!1}}class yo{constructor(){yo.constructor_.apply(this,arguments)}static constructor_(){this._inputIndex=new po,this._outputIndex=new po,this._distanceTolerance=0}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new fo(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}}class xo{constructor(){xo.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._lineSimplifier=new yo,this._linestringMap=null;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new xo(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();this._linestringMap=new It,this._inputGeom.apply(new Io(this)),this._lineSimplifier.simplify(this._linestringMap.values());return new Eo(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}}class Eo extends me{constructor(){super(),Eo.constructor_.apply(this,arguments)}static constructor_(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof J){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}}class Io{constructor(){Io.constructor_.apply(this,arguments)}static constructor_(){this.tps=null;const t=arguments[0];this.tps=t}filter(t){if(t instanceof J){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new _o(e,n);this.tps._linestringMap.put(e,s)}}get interfaces_(){return[k]}}xo.LineStringTransformer=Eo,xo.LineStringMapBuilderFilter=Io;class No{constructor(){No.constructor_.apply(this,arguments)}static constructor_(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e}static simplify(t,e){return new No(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=So.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new m(n[0])]:n}}class So{constructor(){So.constructor_.apply(this,arguments)}static constructor_(){this._pt=null,this._prev=null,this._next=null,this._area=So.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new So(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new R;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=So.MAX_AREA,null;this._area=Math.abs(ne.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}}So.MAX_AREA=r.MAX_VALUE,No.VWVertex=So;class wo{constructor(){wo.constructor_.apply(this,arguments)}static constructor_(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t}static simplify(t,e){const n=new wo(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Co(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new s("Tolerance must be non-negative");this._distanceTolerance=t}}class Co extends me{constructor(){super(),Co.constructor_.apply(this,arguments)}static constructor_(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof ft?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):No.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof it,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof ut?s:null}}wo.VWTransformer=Co;var Lo=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:ho,TopologyPreservingSimplifier:xo,VWSimplifier:wo});class To{constructor(){To.constructor_.apply(this,arguments)}static constructor_(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()}static pointAlongReverse(t,e){const n=new m;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=To.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=To.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}}class Ro{findSplitPoint(t,e){}}class Po{static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new To(n),r=Po.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}get interfaces_(){return[Ro]}}class Oo{static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=D.valueOf(t.x).selfSubtract(s.x),r=D.valueOf(t.y).selfSubtract(s.y),o=D.valueOf(e.x).selfSubtract(s.x),l=D.valueOf(e.y).selfSubtract(s.y),a=D.valueOf(n.x).selfSubtract(s.x),c=D.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),p=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(p.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=Oo.isInCircleNonRobust(t,e,n,s),r=Oo.isInCircleDDSlow(t,e,n,s),o=Oo.isInCircleCC(t,e,n,s),l=ne.circumcentre(t,e,n);B.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(B.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),B.out.println(Wt.toLineString(new pt([t,e,n,s]))),B.out.println("Circumcentre = "+Wt.toPoint(l)+" radius = "+t.distance(l)),B.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),B.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),B.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),B.out.println())}static isInCircleDDFast(t,e,n,s){const i=D.sqr(t.x).selfAdd(D.sqr(t.y)).selfMultiply(Oo.triAreaDDFast(e,n,s)),r=D.sqr(e.x).selfAdd(D.sqr(e.y)).selfMultiply(Oo.triAreaDDFast(t,n,s)),o=D.sqr(n.x).selfAdd(D.sqr(n.y)).selfMultiply(Oo.triAreaDDFast(t,e,s)),l=D.sqr(s.x).selfAdd(D.sqr(s.y)).selfMultiply(Oo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=ne.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=D.valueOf(s.x),r=D.valueOf(s.y),o=D.valueOf(t.x),l=D.valueOf(t.y),a=D.valueOf(e.x),c=D.valueOf(e.y),h=D.valueOf(n.x),u=D.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(Oo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(Oo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(Oo.triAreaDDSlow(o,l,a,c,i,r)),p=i.multiply(i).add(r.multiply(r)).multiply(Oo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(p).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*Oo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*Oo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*Oo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*Oo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return Oo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=D.valueOf(e.x).selfSubtract(t.x).selfMultiply(D.valueOf(n.y).selfSubtract(t.y)),i=D.valueOf(e.y).selfSubtract(t.y).selfMultiply(D.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}}class vo{constructor(){vo.constructor_.apply(this,arguments)}static constructor_(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new m(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new m(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new m(t,e,n)}}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.getZ()-e.getZ();return e.getZ()+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.getZ()+d*(n.getZ()-e.getZ())+_*(s.getZ()-e.getZ())}}circleCenter(t,e){const n=new vo(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new ee(s,i);let o=null;try{o=new vo(r.getX(),r.getY())}catch(s){if(!(s instanceof te))throw s;B.err.println("a: "+n+"  b: "+t+"  c: "+e),B.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.getZ()}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new ee(t.getX()+n/2,t.getY()+s/2,1),r=new ee(t.getX()-s+n/2,t.getY()+n+s/2,1);return new ee(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return Oo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.getZ()+t.getZ())/2;return new vo(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.setZ(t)}times(t){return new vo(t*this._p.x,t*this._p.y)}cross(){return new vo(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new vo(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=this,s=e.sub(t),i=n.sub(t),r=s.crossProduct(i);return r>0?vo.LEFT:r<0?vo.RIGHT:s.getX()*i.getX()<0||s.getY()*i.getY()<0?vo.BEHIND:s.magn()<i.magn()?vo.BEYOND:t.equals(n)?vo.ORIGIN:e.equals(n)?vo.DESTINATION:vo.BETWEEN}sum(t){return new vo(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}}vo.LEFT=0,vo.RIGHT=1,vo.BEYOND=2,vo.BEHIND=3,vo.BETWEEN=4,vo.ORIGIN=5,vo.DESTINATION=6;class Mo extends vo{constructor(){super(),Mo.constructor_.apply(this,arguments)}static constructor_(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];vo.constructor_.call(this,t)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}}class bo{constructor(){bo.constructor_.apply(this,arguments)}static constructor_(){this._rot=null,this._vertex=null,this._next=null,this._data=null}static makeEdge(t,e){const n=new bo,s=new bo,i=new bo,r=new bo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();bo.splice(t,e),bo.splice(t.sym(),n),bo.splice(t,e.lNext()),bo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=bo.makeEdge(t.dest(),e.orig());return bo.splice(n,t.lNext()),bo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new Kt(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Wt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}}class Do{constructor(){Do.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);bo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))bo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}}class Ao{locate(t){}}class Fo{constructor(){Fo.constructor_.apply(this,arguments)}static constructor_(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}get interfaces_(){return[Ao]}}class Go extends h{constructor(){super(),Go.constructor_.apply(this,arguments)}static constructor_(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];h.constructor_.call(this,t)}else if(arguments[0]instanceof Kt){const t=arguments[0];h.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new Kt(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,Go.msgWithSpatial(t,e)),this._seg=new Kt(e)}}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}}class qo{visit(t){}}class Bo{constructor(){Bo.constructor_.apply(this,arguments)}static constructor_(){this._visitedKey=0,this._quadEdges=new L,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new Kt,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/Bo.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Fo(this)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new s("Edges do not form a triangle")}getTriangleVertices(t){const e=new zo;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=bo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new L,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new R;i.addAll(n,!1),i.closeRing(),i.size()<4&&(B.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);bo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return bo.splice(e.sym(),n),bo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);Bo.getTriangleEdges(t,e);const n=new Array(3).fill(null);Bo.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=bo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new en;n.push(this._startingEdge);const s=new xt;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());return this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new O(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new vo((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new vo(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new vo(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new O(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new ko;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new xt;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new L,n=new xt;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Vo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new L,n=new en;n.push(this._startingEdge);const s=new xt;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){bo.splice(t,t.oPrev()),bo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new Go(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new Yo,!0);const e=new L;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Ct.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);bo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof vo){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof m){const t=arguments[0];return this._locator.locate(new vo(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new vo(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}}class Yo{visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=ne.circumcentreDD(e,n,s),r=new vo(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}get interfaces_(){return[qo]}}class Vo{constructor(){Vo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}get interfaces_(){return[qo]}}class zo{constructor(){zo.constructor_.apply(this,arguments)}static constructor_(){this._triList=new L}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}get interfaces_(){return[qo]}}class ko{constructor(){ko.constructor_.apply(this,arguments)}static constructor_(){this._coordList=new R,this._triCoords=new L}checkTriangleSize(t){let e="";t.length>=2?e=Wt.toLineString(t[0],t[1]):t.length>=1&&(e=Wt.toPoint(t[0]))}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}get interfaces_(){return[qo]}}Bo.TriangleCircumcentreVisitor=Yo,Bo.TriangleEdgesListVisitor=Vo,Bo.TriangleVertexListVisitor=zo,Bo.TriangleCoordinatesVisitor=ko,Bo.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class Xo{constructor(){Xo.constructor_.apply(this,arguments)}static constructor_(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new Kt(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new Kt(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];Xo.constructor_.call(this,new m(t,e,n),new m(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];Xo.constructor_.call(this,new m(t,e,n),new m(s,i,r),o)}}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).getZ()}getStartZ(){return this._ls.getCoordinate(0).getZ()}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}}class Uo extends h{constructor(){super(),Uo.constructor_.apply(this,arguments)}static constructor_(){if(this._pt=null,1===arguments.length){const t=arguments[0];h.constructor_.call(this,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];h.constructor_.call(this,Uo.msgWithCoord(t,e)),this._pt=new m(e)}}static msgWithCoord(t,e){return null!==e?t+" [ "+Wt.toPoint(e)+" ]":t}getCoordinate(){return this._pt}}class Ho{constructor(){Ho.constructor_.apply(this,arguments)}static constructor_(){this._initialVertices=null,this._segVertices=null,this._segments=new L,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new Po,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new L(t),this._tolerance=e,this._kdt=new us(e)}static computeVertexEnvelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<Ho.MAX_SPLIT_ITER);if(t===Ho.MAX_SPLIT_ITER)throw new Uo("Too many splitting iterations while enforcing constraints.  Last split point was at: ",this._splitPt)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Ct,e=this.getPointArray(),n=new sn(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new m((e.x+n.x)/2,(e.y+n.y)/2),i=e.distance(s),o=new O(s);o.expandBy(i);const l=this._kdt.query(o);let a=null,c=r.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const r=t.next().getCoordinate();if(r.equals2D(e)||r.equals2D(n))continue;const o=s.distance(r);if(o<i){const t=o;(null===a||t<c)&&(a=r,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new L;let n=0;const s=new L;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new Xo(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new Xo(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new Mo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new Mo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=Ho.computeVertexEnvelope(this._initialVertices),e=Ho.computeVertexEnvelope(this._segVertices),n=new O(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new O(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new Bo(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Fo(this._subdiv)),this._incDel=new Do(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof Mo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof m){const t=arguments[0];this.insertSite(this.createVertex(t))}}}Ho.MAX_SPLIT_ITER=99;class Wo{constructor(){Wo.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null}static extractUniqueCoordinates(t){if(null===t)return new R;const e=t.getCoordinates();return Wo.unique(e)}static envelope(t){const e=new O;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=dt.copyDeep(t);nt.sort(e);return new R(e,!1)}static toVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new vo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Wo.envelope(this._siteCoords),e=Wo.toVertices(this._siteCoords);this._subdiv=new Bo(t,this._tolerance);new Do(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof X){const t=arguments[0];this._siteCoords=Wo.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=Wo.unique(dt.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}}class Zo{constructor(){Zo.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new Hn}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=ye.getLines(t),n=new L;for(let t=e.iterator();t.hasNext();){const e=t.next();Zo.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[1],e=arguments[0].getCoordinates();for(let n=1;n<e.length;n++)t.add(new Xo(e[n-1],e[n]))}}createSiteVertices(t){const e=new L;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new Mo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Wo.envelope(this._siteCoords);let e=new L;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=Zo.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new Ho(n,this._tolerance);s.setConstraints(e,new L(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=Wo.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new Mo(e[t]);this._constraintVertexMap.put(e[t],n)}}}class jo{constructor(){jo.constructor_.apply(this,arguments)}static constructor_(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new L;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=Nr.intersection(n,r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Ct.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=Wo.envelope(this._siteCoords);if(this._diagramEnv=this._clipEnv,null===this._diagramEnv){this._diagramEnv=t;const e=this._diagramEnv.getDiameter();this._diagramEnv.expandBy(e)}const e=Wo.toVertices(this._siteCoords);this._subdiv=new Bo(t,this._tolerance);new Do(this._subdiv).insertSites(e)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return jo.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof X){const t=arguments[0];this._siteCoords=Wo.extractUniqueCoordinates(t)}else if(I(arguments[0],N)){const t=arguments[0];this._siteCoords=Wo.unique(dt.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}}var Ko=Object.freeze({__proto__:null,Vertex:vo}),Qo=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:Zo,DelaunayTriangulationBuilder:Wo,VoronoiDiagramBuilder:jo,quadedge:Ko});class Jo{constructor(){Jo.constructor_.apply(this,arguments)}static constructor_(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];Jo.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Jo.constructor_.call(this,t,e.getComponentIndex(),Jo.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!I(t,W))throw new s("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=n,this.loadCurrentLine()}}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}}class $o{constructor(){$o.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new $o(t).indexOf(e)}static indexOfAfter(t,e,n){return new $o(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=e,i=0;const o=new Kt,l=new Jo(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const r=o.distance(t),a=this.segmentNearestMeasure(o,t,i);r<n&&a>e&&(s=a,n=r),i+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}}class tl{constructor(){tl.constructor_.apply(this,arguments)}static constructor_(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];tl.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}}static getEndLocation(t){const e=new tl;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.getZ()-t.getZ())*n+t.getZ();return new m(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}static numSegments(t){const e=t.getNumPoints();return e<=1?0:e-1}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex),n=tl.numSegments(e);return this._segmentIndex>=n||this._segmentIndex===n-1&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex),n=tl.numSegments(e);return this._segmentIndex<n?this:new tl(this._componentIndex,n-1,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=tl.numSegments(e))return n;const s=e.getCoordinateN(this._segmentIndex+1);return tl.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=tl.numSegments(e)){const t=e.getCoordinateN(e.getNumPoints()-2);return new Kt(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new Kt(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=tl.numSegments(e),this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=tl.numSegments(e),this._segmentFraction=0}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new tl(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=tl.numSegments(e)&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}get interfaces_(){return[o]}}class el{constructor(){el.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indexOf(t,e){return new el(t).indexOf(e)}static indexOfAfter(t,e,n){return new el(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=r.MAX_VALUE,s=0,i=0,o=-1;const l=new Kt;for(let r=new Jo(this._linearGeom);r.hasNext();r.next())if(!r.isEndOfLine()){l.p0=r.getSegmentStart(),l.p1=r.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=r.getComponentIndex(),u=r.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,i=u,o=c,n=a)}if(n===r.MAX_VALUE)return new tl(e);return new tl(s,i,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=tl.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return g.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}}class nl{constructor(){nl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static indicesOf(t,e){return new nl(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new el(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}}class sl{constructor(){sl.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}static getLength(t,e){return new sl(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[1];return new sl(arguments[0]).getLocation(t)}if(3===arguments.length){const t=arguments[1],e=arguments[2];return new sl(arguments[0]).getLocation(t,e)}}getLength(t){let e=0;const n=new Jo(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new tl(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new tl;let e=0;const n=new Jo(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new tl(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new tl(r,o,s)}e+=i}n.next()}return tl.getEndLocation(this._linearGeom)}}class il{constructor(){il.constructor_.apply(this,arguments)}static constructor_(){this._geomFact=null,this._lines=new L,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let n=null;try{n=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof s))throw t;if(!this._ignoreInvalidLines)throw t}null!==n&&this._lines.add(n)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new R),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}}class rl{constructor(){rl.constructor_.apply(this,arguments)}static constructor_(){this._line=null;const t=arguments[0];this._line=t}static extract(t,e,n){return new rl(t).extract(e,n)}computeLinear(t,e){const n=new il(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new Jo(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new R;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return I(t,W)?t.reverse():(g.shouldNeverReachHere("non-linear geometry encountered"),null)}}class ll{constructor(){ll.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return sl.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return sl.getLocation(this._linearGeom,t,e)}}project(t){return $o.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return sl.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=sl.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return $o.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return rl.extract(this._linearGeom,r,o)}indexOf(t){return $o.indexOf(this._linearGeom,t)}indicesOf(t){const e=nl.indicesOf(this._linearGeom,t);return[sl.getLength(this._linearGeom,e[0]),sl.getLength(this._linearGeom,e[1])]}}class al{constructor(){al.constructor_.apply(this,arguments)}static constructor_(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return el.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof J||this._linearGeom instanceof wt))throw new s("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[1],e=arguments[0].toLowest(this._linearGeom);return e.getSegment(this._linearGeom).pointAlongOffset(e.getSegmentFraction(),t)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return tl.getEndLocation(this._linearGeom)}getStartIndex(){return new tl}indexOfAfter(t,e){return el.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return rl.extract(this._linearGeom,t,e)}indexOf(t){return el.indexOf(this._linearGeom,t)}indicesOf(t){return nl.indicesOf(this._linearGeom,t)}}var cl=Object.freeze({__proto__:null,LengthIndexedLine:ll,LengthLocationMap:sl,LinearGeometryBuilder:il,LinearIterator:Jo,LinearLocation:tl,LocationIndexedLine:al});class hl{static transform(t,e){const n=new L;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new L;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}}hl.Function=function(){};class ul{constructor(){ul.constructor_.apply(this,arguments)}static constructor_(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}get interfaces_(){return[U]}}class gl{constructor(){gl.constructor_.apply(this,arguments)}static constructor_(){this._n=0}filter(t){this._n++}getCount(){return this._n}get interfaces_(){return[U]}}class dl{constructor(){dl.constructor_.apply(this,arguments)}static constructor_(){this._counts=new It}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new _l(1)):e.increment()}}class _l{constructor(){_l.constructor_.apply(this,arguments)}static constructor_(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}}count(){return this.count}increment(){this.count++}}function pl(){}function ml(){}function fl(){}dl.Counter=_l;class yl extends n{}function xl(){}class El{static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new fl,n=new pl(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";const s=new xl(new ml(El.getStackTrace(t)));for(let t=0;t<e;t++)try{n+=s.readLine()+El.NEWLINE}catch(t){if(!(t instanceof yl))throw t;g.shouldNeverReachHere()}return n}}static spaces(t){return El.chars(" ",t)}static split(t,e){const n=e.length,s=new L;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}}El.NEWLINE=B.getProperty("line.separator");var Il=Object.freeze({__proto__:null,CollectionUtil:hl,CoordinateArrayFilter:ul,CoordinateCountFilter:gl,GeometricShapeFactory:Se,NumberUtil:e,ObjectCounter:dl,PriorityQueue:Cs,StringUtil:El,UniqueCoordinateArrayFilter:nn});class Nl{get interfaces_(){return[]}getClass(){return Nl}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Nr.createEmptyResult(Nr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),Er.overlayOp(t,e,Nr.UNION)}}J.prototype.getBoundary=function(){return si.getBoundary(this)},wt.prototype.getBoundary=function(){return si.getBoundary(this)},X.prototype.equalsTopo=function(t){return Kr.equalsTopo(this,t)},X.prototype.equals=function(t){return null!==t&&Kr.equalsTopo(this,t)},X.prototype.union=function(){if(0===arguments.length)return no.union(this);if(1===arguments.length){const t=arguments[0];return Nl.union(this,t)}},X.prototype.isValid=function(){return Fr.isValid(this)},X.prototype.intersection=function(t){return Nr.intersection(this,t)},X.prototype.covers=function(t){return Kr.covers(this,t)},X.prototype.coveredBy=function(t){return Kr.covers(t,this)},X.prototype.touches=function(t){return Kr.touches(this,t)},X.prototype.intersects=function(t){return Kr.intersects(this,t)},X.prototype.within=function(t){return Kr.contains(t,this)},X.prototype.overlaps=function(t){return Kr.overlaps(this,t)},X.prototype.disjoint=function(t){return Kr.disjoint(this,t)},X.prototype.crosses=function(t){return Kr.crosses(this,t)},X.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return Gi.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Gi.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return Gi.bufferOp(this,t,e,n)}},X.prototype.convexHull=function(){return new sn(this).getConvexHull()},X.prototype.relate=function(){if(1===arguments.length){const t=arguments[0];return Kr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Kr.relate(this,t).matches(e)}},X.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=$e.getCentroid(this);return this.createPointFromInternalCoord(t,this)},X.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new un(this):1===e?new hn(this):new on(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},X.prototype.symDifference=function(t){return Nr.symDifference(this,t)},X.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},X.prototype.toText=function(){return(new Wt).write(this)},X.prototype.toString=function(){this.toText()},X.prototype.contains=function(t){return Kr.contains(this,t)},X.prototype.difference=function(t){return Nr.difference(this,t)},X.prototype.isSimple=function(){return new ri(this).isSimple()},X.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&Vi.isWithinDistance(this,t,e)},X.prototype.distance=function(t){return Vi.distance(this,t)};t.algorithm=En,t.densify=Sn,t.dissolve=vn,t.geom=Te,t.geomgraph=as,t.index=Ds,t.io=Ys,t.linearref=cl,t.noding=ni,t.operation=ro,t.precision=ao,t.simplify=Lo,t.triangulate=Qo,t.util=Il,t.version="2.6.0 (ddae866)",Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=jsts.min.js.map

/***/ }),

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./src/base/AgentPoint.js":
/*!********************************!*\
  !*** ./src/base/AgentPoint.js ***!
  \********************************/
/*! exports provided: AgentPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgentPoint", function() { return AgentPoint; });
//@ts-check

/** */
class AgentPoint {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(x, y, sx=0, sy=0) {

        //position

        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y

        //speed

        /** @type {number} */
        this.sx = sx
        /** @type {number} */
        this.sy = sy
        /** @type {number} */
        this.s = undefined
        /** @type {number} */
        this.sa = undefined
    }


    /**
     * @param {AgentPoint} a
     * @returns {number} The distance to another agent.
     */
    d(a) {
        return this.dP(a.x, a.y);
    }

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @returns {number} The distance to a position.
     */
    dP(x, y) {
        return Math.hypot((x - this.x), (y - this.y));
    }

    /** 
    * Set random speed
    * 
    * @param {number} minSpeed
    * @param {number} maxSpeed
    */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        this.s = minSpeed + Math.random() * (maxSpeed - minSpeed);
        this.sa = 2 * Math.random() * Math.PI;
        this.sx = this.s * Math.cos(this.sa)
        this.sy = this.s * Math.sin(this.sa)
    }

    /** */
    computeSpeed() {
        this.s = Math.hypot(this.sx, this.sy);
        return this.s
    }

    /** */
    computeSpeedAngle() {
        this.sa = Math.atan2(this.sy, this.sx);
        return this.sa
    }

}


/***/ }),

/***/ "./src/base/GeoCanvas.js":
/*!*******************************!*\
  !*** ./src/base/GeoCanvas.js ***!
  \*******************************/
/*! exports provided: GeoCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoCanvas", function() { return GeoCanvas; });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/index.js");
//@ts-check
/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */




/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 * 
 * @author Julien Gaffuri
 */
class GeoCanvas {

    /**
     * @constructor
     * @param {string} canvasId
     * @param {object} center Geographical coordinates of the center
     * @param {number} zf The zoom factor (pixel size, in ground m)
     */
    constructor(canvasId = "vacanvas", center = undefined, zf = 1) {

        /** @type {object} */
        this.canvas = document.getElementById(canvasId);

        /** @type {number} */
        this.w = this.canvas.offsetWidth;
        /** @type {number} */
        this.h = this.canvas.offsetHeight;

        this.canvas.width = this.w;
        this.canvas.height = this.h;

        /**@type {object} */
        this.ctx = this.canvas.getContext("2d");

        // set geo coordinates of the center
        this.setCenter(center || { x: this.w * 0.5, y: this.h * 0.5 })

        // set zoom factor: pixel size, in m/pix
        this.setZf(zf);

        //extent
        /** @type {Envelope} */
        this.extGeo = undefined;
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoomIdentity"]
        Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(this.canvas).call(
            Object(d3_zoom__WEBPACK_IMPORTED_MODULE_0__["zoom"])().on("zoom", (e) => {
                const t = e.transform
                const f = tP.k / t.k
                if (f == 1) {
                    //pan
                    const dx = tP.x - t.x
                    const dy = tP.y - t.y
                    this.pan(dx * this.getZf(), -dy * this.getZf())
                } else {
                    const se = e.sourceEvent;
                    if (se instanceof WheelEvent) {
                        //zoom at the mouse position
                        this.zoom(f, this.pixToGeoX(e.sourceEvent.offsetX), this.pixToGeoY(e.sourceEvent.offsetY))
                    } else if (se instanceof TouchEvent) {
                        //compute average position of the touches
                        let tx = 0, ty = 0
                        for (let tt of se.targetTouches) { tx += tt.clientX; ty += tt.clientY }
                        tx /= se.targetTouches.length; ty /= se.targetTouches.length
                        //zoom at this average position
                        this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                    }
                }
                tP = t
            }));
    }

    /** @param {{x:number,y:number}} v Geographical coordinates of the center */
    setCenter(v) { this.center = v; }
    /** @returns {{x:number,y:number}} Geographical coordinates of the center */
    getCenter() { return this.center; }

    /** @param {number} v The zoom factor (pixel size, in ground m) */
    setZf(v) { this.zf = v; }
    /** @returns {number} The zoom factor (pixel size, in ground m) */
    getZf() { return this.zf; }




    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.getZf();
        const tx = -this.center.x / this.getZf() + this.w * 0.5;
        const ty = this.center.y / this.getZf() + this.h * 0.5;
        this.ctx.setTransform(k, 0, 0, -k, tx, ty);
    }


    /** The function specifying how to draw the map. */
    redraw() {
        throw new Error('Method redraw not implemented.');
    }

    /**
     * Clear the app screen. To be used before a redraw for example.
     * @param {string} color 
     */
    clear(color = "white") {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.w, this.h);
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
    */
    geoToPixX(xGeo) { return (xGeo - this.center.x) / this.getZf() + this.w * 0.5; }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
    */
    geoToPixY(yGeo) { return -(yGeo - this.center.y) / this.getZf() + this.h * 0.5; }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
    */
    pixToGeoX(x) { return (x - this.w * 0.5) * this.getZf() + this.center.x; }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
    */
    pixToGeoY(y) { return -(y - this.h * 0.5) * this.getZf() + this.center.y; }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo, dyGeo) {
        //TODO force extend to remain
        this.center.x += dxGeo;
        this.center.y += dyGeo;
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.center.x, yGeo = this.center.y) {
        //TODO force extend to remain
        this.setZf(f * this.getZf());
        this.center.x += (xGeo - this.center.x) * (1 - f)
        this.center.y += (yGeo - this.center.y) * (1 - f)
        this.updateExtentGeo()
        this.redraw();
    }

    /**
     * @param {number} marginPx 
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx)
        }
        return this.extGeo;
    }

    /**
     * Check if the object has to be drawn
     * 
     * @param {{x:number,y:number}} obj 
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false;
        if (obj.x > this.extGeo.xMax) return false;
        if (obj.y < this.extGeo.yMin) return false;
        if (obj.y > this.extGeo.yMax) return false;
        return true
    }

}


/***/ }),

/***/ "./src/base/SpatialIndex.js":
/*!**********************************!*\
  !*** ./src/base/SpatialIndex.js ***!
  \**********************************/
/*! exports provided: SpatialIndex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpatialIndex", function() { return SpatialIndex; });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
//@ts-check

//see https://github.com/mourner/rbush


/**
 * @template T
 */
class SpatialIndex {

    /**
     * @constructor
     */
    constructor() {
        class MyRBush extends rbush__WEBPACK_IMPORTED_MODULE_0___default.a {
            /** @param {{x:number,y:number}} obj  */
            toBBox(obj) { return { minX: obj.x, minY: obj.y, maxX: obj.x, maxY: obj.y }; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinX(a, b) { return a.x - b.x; }
            /**
             * @param {{x:number,y:number}} a 
             * @param {{x:number,y:number}} b 
             */
            compareMinY(a, b) { return a.y - b.y; }
        }

        /** @type {MyRBush} */
        this.tree = new MyRBush();
    }

    //TODO bulk remove ?

    /**
     * @param {number} xmin
     * @param {number} ymin
     * @param {number} xmax
     * @param {number} ymax
     * @return {Array.<T>}
     */
    get(xmin, ymin, xmax, ymax) {
        return this.tree.search({
            minX: xmin,
            minY: ymin,
            maxX: xmax,
            maxY: ymax
        });
    }

    /**
     * @param {T} obj
     */
    insert(obj) {
        this.tree.insert(obj);
    }

    /**
     * Bulk insert
     * 
     * @param {Array.<T>} objs
     */
    load(objs) {
        this.tree.load(objs);
    }

    /**
     * @param {T} obj
     */
    remove(obj) {
        this.tree.remove(obj)
    }

    /**
     */
    clear() {
        this.tree.clear()
    }

}


/***/ }),

/***/ "./src/base/lib.js":
/*!*************************!*\
  !*** ./src/base/lib.js ***!
  \*************************/
/*! exports provided: objToArray, removeFromArray, removeFromArrayS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objToArray", function() { return objToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArray", function() { return removeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromArrayS", function() { return removeFromArrayS; });
//@ts-check
/**
 * @template T
 * @param {Object.<?, T>} obj
 * @returns {Array.<T>}
 */
const objToArray = function (obj) {
    var out = [];
    for (var key in obj)
        if (obj.hasOwnProperty(key))
            out.push(obj[key]);
    return out;
};

/**
 * @template T
 * @param {Array.<T>} arr
 * @param {T} obj
 * @param {boolean} msg 
 */
const removeFromArray = function (arr, obj, msg = true) {
    /** @type {number} */
    var index = arr.indexOf(obj);
    if (index > -1)
        arr.splice(index, 1);
    else
        if (msg) console.log("Impossible to remove element not present in array.");
};

/**
 * 
 * @template T
 * @param {Array.<T>} arr
 * @param {Array.<T>} objs 
 * @param {boolean} msg 
 */
const removeFromArrayS = function (arr, objs, msg = true) {
    for (let obj of objs)
        removeFromArray(arr, obj, msg)
};


/***/ }),

/***/ "./src/fish/Sardin.js":
/*!****************************!*\
  !*** ./src/fish/Sardin.js ***!
  \****************************/
/*! exports provided: Sardin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sardin", function() { return Sardin; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check





/** */
class Sardin extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {Sea} sea 
     * @param {number} x 
     * @param {number} y 
     * @param {number} sx 
     * @param {number} sy 
     */
    constructor(sea, x = sea.w * Math.random(), y = sea.h * Math.random(), sx = undefined, sy = undefined) {

        //
        super(x, y, sx, sy)

        /** @type {Sea} */
        this.sea = sea;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > sea.w ? sea.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > sea.h ? sea.h : y

        //speed
        if (!sx && !sy) {
            this.setRandomSpeed(0, this.sea.V_MAX)

            //acceleration
            /** @type {number} */
            this.ax = 0
            /** @type {number} */
            this.ay = 0

            //list of sardins in vision field
            /** @type {Array.<Sardin>} */
            this.obs = []
            //list of sardins in collision field
            /** @type {Array.<Sardin>} */
            this.col = []
        }
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    observe(sindex) {

        /** @type {Sea} */
        const s = this.sea
        /** @type {number} */
        const dO = s.D_OBS

        //initialise lists
        /** @type {Array.<Sardin>} */
        this.obs = [];
        /** @type {Array.<Sardin>} */
        this.col = [];

        //get sardins around using spatial index
        /** @type {Array.<Sardin>} */
        const ss = sindex.get(this.x - dO, this.y - dO, this.x + dO, this.y + dO);

        //get sardins in observation and collision fields
        for (let f of ss) {
            if (f == this) continue;
            if (this.d(f) <= s.D_COL)
                this.col.push(f);
            if (this.d(f) <= dO) {
                //check angle
                let da = Math.atan2(f.y - this.y, f.x - this.x) - this.sa;
                if (da > Math.PI) da -= 2 * Math.PI;
                else if (da <= -Math.PI) da += 2 * Math.PI;
                da = Math.abs(da);
                if (da > s.A_OBS * 0.5) continue;
                this.obs.push(f);
            }
        }

        //initialise acceleration
        this.ax = 0; this.ay = 0;

        //collision: repulsion
        for (let f of this.col) {
            const d = this.d(f);
            const a = 1.0 * (1 / (d * d) - 1 / (s.D_COL * s.D_COL));
            this.ax += a * (this.x - f.x) / d;
            this.ay += a * (this.y - f.y) / d;
        }

        // toward target speed
        const dv = (s.V_TARGET - this.s) * 0.01;
        this.ax += dv * this.sx / this.s;
        this.ay += dv * this.sy / this.s;

        //toward the observed mean position
        /*if(obs.size()>1){
            double xn=0,yn=0;
            for(Sardin s:obs){
                xn+=s.x;
                yn+=s.y;
            }
            xn=xn/obs.size();
            yn=yn/obs.size();
            double d=Math.hypot(xn-x,yn-y);
            ax+=-0.1*(x-xn)/d;
            ay+=-0.1*(y-yn)/d;
        }*/

        //toward the observed speed
        const t = 0.9;
        if (this.obs.length > 1) {
            let dsx = 0, dsy = 0;
            for (let s of this.obs) {
                dsx += s.sx;
                dsy += s.sy;
            }
            dsx = (t - 1) * this.sx + (1 - t) * dsx / this.obs.length;
            dsy = (t - 1) * this.sy + (1 - t) * dsy / this.obs.length;

            const a = 0.1;
            this.ax += a * dsx;
            this.ay += a * dsy;
        }

        //avoid shark
        const sh = s.shark;
        if (sh != null) {
            const d = Math.hypot((sh.x - this.x), (sh.y - this.y));
            if (d <= s.D_OBS) {
                const a = 5.0 * (1 / (d * d) - 1 / (dO * dO));
                this.ax += a * (this.x - sh.x) / d;
                this.ay += a * (this.y - sh.y) / d;
            }
        }

    }


    /**
     * @param {number} timeStepMs 
     */
    move(timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.sy += this.ay * timeStepMs + (1 - 2 * Math.random()) * 0.02;
        this.s = this.computeSpeed()
        if (this.s > this.sea.V_MAX) {
            this.s = this.sea.V_MAX;
            this.sx = this.sea.V_MAX * Math.cos(this.sa);
            this.sy = this.sea.V_MAX * Math.sin(this.sa);
        }

        //compute new position
        this.x += this.sx * timeStepMs;
        this.y += this.sy * timeStepMs;

        //limit
        if (this.x < 0) this.x = this.sea.w;
        if (this.y < 0) this.y = this.sea.h;
        if (this.x > this.sea.w) this.x = 0;
        if (this.y > this.sea.h) this.y = 0;
    }


    /**
     * Display a sardin body
     * 
     * @param {GeoCanvas} cp 
     * @param {number} length 
     */
    display(cp, length) {
        const c2 = cp.ctx
        const c = Math.floor(255 * Math.abs(this.sa) / Math.PI);
        c2.strokeStyle = "rgb(255, 255, " + c + ")"
        const a = length / this.s;
        const dx = a * this.sx * 0.5;
        const dy = a * this.sy * 0.5;

        c2.beginPath();
        c2.moveTo(this.x - dx, this.y - dy);
        c2.lineTo(this.x + dx, this.y + dy);
        c2.closePath();
        c2.stroke();
    }

    /**
     * Display sardin vision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} lineWidth 
     */
    displayVisionField(cp, fillStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.arc(this.x, this.y, this.sea.D_OBS / cp.getZf(),
            this.sa - this.sea.A_OBS * 0.5,
            this.sa + this.sea.A_OBS * 0.5
        );
        c2.closePath();
        c2.fill();
    }

    /**
     * Display sardin vision links
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayVisionLinks(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        for (let sa2 of this.obs) {
            c2.beginPath();
            c2.moveTo(this.x, this.y);
            c2.lineTo(sa2.x, sa2.y);
            c2.closePath();
            c2.stroke();
        }
    }

    /**
     * Display sardin collision field
     * 
     * @param {GeoCanvas} cp 
     * @param {string} strokeStyle 
     * @param {number} lineWidth 
     */
    displayCollisionField(cp, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.sea.D_COL * 0.5 / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/fish/Sea.js":
/*!*************************!*\
  !*** ./src/fish/Sea.js ***!
  \*************************/
/*! exports provided: Sea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sea", function() { return Sea; });
/* harmony import */ var _Sardin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sardin */ "./src/fish/Sardin.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
//@ts-check




/** */
class Sea {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */        //get 10 random locations

    constructor(w, h) {

        //TODO should become static attributes of Sardin class

        //observation
        /** @type {number} */
        this.D_OBS = 50
        /** @type {number} */
        this.A_OBS = 200 * Math.PI / 180

        //collision
        /** @type {number} */
        this.D_COL = 10

        //speed
        /** @type {number} */
        this.V_TARGET = 0.3
        /** @type {number} */
        this.V_MAX = 0.6

        //shark
        /** @type {number} */
        this.D_SHARK_EAT = 12
        /** @type {number} */
        this.EATEN_SARDIN_NB = 0


        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Sardin>} */
        this.fish = []

        //TODO
        this.shark = null;

        /** @type {Array.<Sardin>} */
        this.killed = [];
    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //ini
        for (let f of this.fish) {
            f.computeSpeed()
            f.computeSpeedAngle()
        }

        //make spatial index
        /** @type {SpatialIndex.<Sardin>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.fish)

        //observe
        for (let f of this.fish)
            f.observe(sindex);

        //shark eat fish
        this.sharkEat(sindex);

        //dispose spatial index
        //sindex.clear()

        //move
        for (let f of this.fish)
            f.move(timeStepMs);
    }


    /**
     * @param {SpatialIndex.<Sardin>} sindex 
     */
    sharkEat(sindex) {
        if (this.shark == null) return;

        /** @type {Array.<Sardin>} */
        this.killed = [];

        const x = this.shark.x, y = this.shark.y;
        const ss = sindex.get(x - this.D_SHARK_EAT, y - this.D_SHARK_EAT, x + this.D_SHARK_EAT, y + this.D_SHARK_EAT);
        for (let s of ss) {
            const d = Math.hypot((x - s.x), (y - s.y));
            if (d > this.D_SHARK_EAT) continue;
            this.killed.push(s);
            Object(_base_lib__WEBPACK_IMPORTED_MODULE_2__["removeFromArray"])(this.fish, s)
            //sindex.remove(s);
        }
        this.EATEN_SARDIN_NB += this.killed.length;
        //eatenFishNb.setText("Eaten fish: " + EATEN_SARDIN_NB);
        return this;
    }

    /**
     * Add fish
     * 
     * @param {number} nb 
     * @returns {this}
     */
    addFish(nb = 1) {
        for (let i = 0; i < nb; i++)
            this.fish.push(new _Sardin__WEBPACK_IMPORTED_MODULE_0__["Sardin"](this));
        return this
    }

    /**
     * Set random speed for all fish
     * @returns {this}
     */
    setRandomSpeed() {
        for (let f of this.fish)
            f.setRandomSpeed()
        return this
    }

}


/***/ }),

/***/ "./src/fish/index.js":
/*!***************************!*\
  !*** ./src/fish/index.js ***!
  \***************************/
/*! exports provided: fish */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return fish; });
/* harmony import */ var _Sea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sea */ "./src/fish/Sea.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check



class FishSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        //TODO
        //add eaten fish nb label

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        /** @type {boolean} */
        this.showFishVisionField = false
        /** @type {boolean} */
        this.showFishVisionLinks = false
        /** @type {boolean} */
        this.showFishCollisionField = false

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx
            const s = th.sea

            this.initCanvasTransform()

            //clear
            c2.fillStyle = "rgba(120,120,255,0.6)";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //show vision field
            if (th.showFishVisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionField(this, "rgba(200,200,200,0.15)", 1)
            //show vision links
            if (th.showFishVisionLinks)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayVisionLinks(this, "rgba(255,100,100,0.3)", 1)
            //show collision field
            if (th.showFishCollisionField)
                for (let sa of s.fish)
                    if (this.toDraw(sa))
                        sa.displayCollisionField(this, "purple", 1)


            //display sardins
            c2.lineWidth = 2
            const sardinLength = 7
            for (let sa of s.fish)
                if (this.toDraw(sa))
                    sa.display(this, sardinLength)


            //display shark
            if (s.shark != null) {

                c2.lineWidth = 4
                c2.strokeStyle = "black"

                const sharkLength = 12
                const dx = sharkLength * Math.cos(s.shark.angle);
                const dy = sharkLength * Math.sin(s.shark.angle);

                c2.beginPath();
                c2.moveTo(s.shark.x, s.shark.y);
                c2.lineTo(s.shark.x - dx, s.shark.y + dy);
                c2.closePath();
                c2.stroke();
            }

            //display blood spot
            c2.fillStyle = "red";
            c2.lineWidth = 1
            for (let sa of s.killed) {
                c2.beginPath();
                c2.moveTo(sa.x, sa.y);
                c2.arc(sa.x, sa.y, 4, 0, 2 * Math.PI);
                c2.closePath();
                c2.fill();
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        this.cplus.canvas.addEventListener("mouseover", e => {
            th.sea.shark = { x: th.cplus.pixToGeoX(e.offsetX), y: th.cplus.pixToGeoY(e.offsetY), angle: 0 }
        });
        this.cplus.canvas.addEventListener("mousemove", e => {
            const xG = th.cplus.pixToGeoX(e.offsetX);
            const yG = th.cplus.pixToGeoY(e.offsetY);
            const angle = Math.atan2(-yG + th.sea.shark.y, xG - th.sea.shark.x);
            th.sea.shark = { x: xG, y: yG, angle: angle }
        });
        this.cplus.canvas.addEventListener("mouseout", e => {
            th.sea.shark = null;
        });


        /** @type {Sea} */
        this.sea = new _Sea__WEBPACK_IMPORTED_MODULE_0__["Sea"](this.w, this.h)

    }


    /**
     * @param {number} density 
     * @returns {this}
     */
    initRandom(density = 0.001) {
        this.sea.addFish(density * this.sea.w * this.sea.h);
        return this
    }

    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.sea.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this
    }

}

/**
 * @param {Object} opts 
 */
const fish = function (opts) {
    return new FishSimulation(opts)
}


/***/ }),

/***/ "./src/gol/Cell.js":
/*!*************************!*\
  !*** ./src/gol/Cell.js ***!
  \*************************/
/*! exports provided: Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return Cell; });
//@ts-check

/**
 * 
 */
class Cell {

    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} nb 
     */
    constructor(x, y, nb=0) {
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.nb = nb
    }

}


/***/ }),

/***/ "./src/gol/Universe.js":
/*!*****************************!*\
  !*** ./src/gol/Universe.js ***!
  \*****************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




/**
 * 
 */
class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Cell>} */
        this.population = [];
        /** @type {Object.<string,Cell>} */
        this.populationI = {};
    }

    /**
     * @param {number} x
     * @param {number} y
     * @returns {Cell|null}
     */
    add(x, y) {

        //find cell at location
        /**@type {string}*/
        const id = x + "_" + y;
        if (this.populationI[id]) return null;

        //create new cell
        /**@type {Cell} */
        const cell = new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x, y, 0)
        this.population.push(cell)
        this.populationI[id] = cell
        return cell
    }

    /**
     * @returns {this}
     */
    step() {

        //TODO double indexing? by raw and then column ?
        //populate cell surroundings
        /** @type {Object.<string, Cell>}
         * @dict */
        const surI = {};
        //go through list of cells
        for (let cell of this.population) {
            // +1 surrounding cells
            const srs = Universe.getCellSurrounding(cell, this);
            for (let sur of srs) {
                const key = sur.x + "_" + sur.y;
                const sur_ = surI[key];
                if (sur_) {
                    sur_.nb++;
                } else {
                    sur.nb = 1;
                    surI[key] = sur;
                }
            }
        }

        //B3/S23
        //kill cells
        /** @type {Array.<Cell>} */
        const cellsToKeep = [];
        /** @type {Object.<string, Cell>}
         * @dict */
        const cellsToKeepI = {};
        for (let cell of this.population) {
            const key = cell.x + "_" + cell.y;
            const cell_ = surI[key];
            if (!cell_) continue;
            //if (nb<2 or nb>3) -> kill
            if (cell_.nb < 2 || cell_.nb > 3) continue;
            cellsToKeep.push(cell);
            cellsToKeepI[key] = cell;
        }
        this.population = cellsToKeep;
        this.populationI = cellsToKeepI;

        //create new cells
        /** @type {Array.<Cell>} */
        const surs = Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["objToArray"])(surI);
        for (let sur of surs) {

            if (sur.nb !== 3) continue;

            //check if already alive
            const key = sur.x + "_" + sur.y;
            let cell = this.populationI[key];
            if (cell) continue;

            //create new cell
            this.population.push(sur);
            this.populationI[key] = sur;
        }
        return this;
    }


    /**
     * @param {number} nb
     * @param {number} timeoutMS
     * @param {GeoCanvas} cplus
     * @return {Universe}
     */
    start(nb, timeoutMS, cplus) {
        let i = 0;
        const uni = this;
        const engine = function () {
            //console.log(i);
            uni.step();
            cplus.redraw();
            if (nb > 0 && i++ > nb) return;
            setTimeout(engine, timeoutMS);
        };
        engine();
        return this;
    }

    /**
     * @param {Cell} cell
     * @param {Universe} uni
     * @return {Array.<Cell>}
     */
    static getCellSurrounding(cell, uni) {
        const x1 = cell.x === 0 ? uni.w - 1 : cell.x - 1;
        const x2 = cell.x === uni.w - 1 ? 0 : cell.x + 1;
        const y1 = cell.y === 0 ? uni.h - 1 : cell.y - 1;
        const y2 = cell.y === uni.h - 1 ? 0 : cell.y + 1;
        return [
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x1, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](cell.x, y2),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y1),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, cell.y),
            new _Cell__WEBPACK_IMPORTED_MODULE_2__["Cell"](x2, y2),
        ];
    }

}


/***/ }),

/***/ "./src/gol/index.js":
/*!**************************!*\
  !*** ./src/gol/index.js ***!
  \**************************/
/*! exports provided: gameOfLife */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return gameOfLife; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Universe */ "./src/gol/Universe.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cell */ "./src/gol/Cell.js");
//@ts-check




//TODO zoom/pan, with canvas transform: better universe limits
//TODO buttons (play, stop, speed, draw, pan)
//TODO check canvas animation


class GoLSimulation {

    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //clear
            this.initCanvasTransform()
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            //draw cells
            this.setCanvasTransform()
            c2.fillStyle = "blue";
            for (let cell of th.uni.population)
                c2.fillRect((cell.x), (cell.y), 1, 1);

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };

        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_1__["Universe"](this.w, this.h);
    }


    //
    initRandom(density = 0.05) {
        let i = 0;
        /** @type {number} */
        const nb = this.uni.w * this.uni.h * density;
        while (i < nb) {
            const x = Math.round(this.uni.w * Math.random());
            const y = Math.round(this.uni.h * Math.random());
            /** @type {Cell} */
            const cell = this.uni.add(x, y);
            if (cell) i++;
        }
        return this;
    }


    //
    start() {
        this.uni.start(-1, 0, this.cplus);
        return this;
    }

}


const gameOfLife = function (opts) {
    return new GoLSimulation(opts)
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: planets, gameOfLife, fish, preyPredator, urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _planets_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planets/index */ "./src/planets/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return _planets_index__WEBPACK_IMPORTED_MODULE_0__["planets"]; });

/* harmony import */ var _gol_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gol/index */ "./src/gol/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gameOfLife", function() { return _gol_index__WEBPACK_IMPORTED_MODULE_1__["gameOfLife"]; });

/* harmony import */ var _fish_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fish/index */ "./src/fish/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fish", function() { return _fish_index__WEBPACK_IMPORTED_MODULE_2__["fish"]; });

/* harmony import */ var _pp_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pp/index */ "./src/pp/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return _pp_index__WEBPACK_IMPORTED_MODULE_3__["preyPredator"]; });

/* harmony import */ var _urban_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./urban/index */ "./src/urban/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return _urban_index__WEBPACK_IMPORTED_MODULE_4__["urban"]; });

//@ts-check








/***/ }),

/***/ "./src/planets/Planet.js":
/*!*******************************!*\
  !*** ./src/planets/Planet.js ***!
  \*******************************/
/*! exports provided: Planet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Planet", function() { return Planet; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




class Planet extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @constructor
     * @param {Universe} u The universe the planet belongs to.
     * @param {number} m The mass
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} sx The speed x
     * @param {number} sy The speed y
     */
    constructor(u, m, x, y, sx = 0, sy = 0) {

        //
        super(x, y, sx, sy)

        /** @type {Universe} */
        this.u = u;
        u.ps.push(this)

        /** @type {number} */
        this.m = m;

        //compute radius
        /** @type {number} */
        const r = this.r();

        //set position
        /** @type {number} */
        this.x = x < r ? r : x > u.w - r ? u.w - r : x;
        /** @type {number} */
        this.y = y < r ? r : y > u.h - r ? u.h - r : y;

        //acceleration
        /** @type {number} */
        this.ax = 0;
        /** @type {number} */
        this.ay = 0;
    }

    /**
     * Update the force, based on the gravity of other planets.
     * @param {number} exponent
     */
    observe(exponent) {

        //compute gravity field at planet location
        const g = this.u.getGravityField(this.x, this.y, this, exponent);

        //set acceleration
        /** @type {number} */
        this.ax = g.gx;
        /** @type {number} */
        this.ay = g.gy;
    }


    /**
     * @return {number} The radius of the planet, depending on its mass.
     */
    r() {
        return Math.pow(this.m / Math.PI, 0.5);
    }


    /**
     * 
     * @param {boolean} bounce 
     * @param {number} maxSpeed 
     * @param {number} timeStepMs 
     */
    change(bounce = false, maxSpeed = 0.8, timeStepMs = 10) {

        //compute new speed
        this.sx += this.ax * timeStepMs;
        this.sy += this.ay * timeStepMs;

        //check vmax
        if (maxSpeed > 0) {
            /** @type {number} */
            const v = Math.sqrt(this.sx * this.sx + this.sy * this.sy);
            if (v > maxSpeed) {
                this.sx = maxSpeed * this.sx / v;
                this.sy = maxSpeed * this.sy / v;
            }
        }

        //compute new position
        /** @type {number} */
        let nx = this.x + this.sx * timeStepMs;
        /** @type {number} */
        let ny = this.y + this.sy * timeStepMs;

        //handle position limit
        if (bounce) {
            const r = this.r();
            const e = 1;
            if (nx < r) { nx = r; this.sx = -this.sx * e; }
            if (ny < r) { ny = r; this.sy = -this.sy * e; }
            if (nx > this.u.w - r) { nx = this.u.w - r; this.sx = -this.sx * e; }
            if (ny > this.u.h - r) { ny = this.u.h - r; this.sy = -this.sy * e; }
        } else {
            if (nx < 0) { nx = this.u.w; }
            if (ny < 0) { ny = this.u.h; }
            if (nx > this.u.w) { nx = 0; }
            if (ny > this.u.h) { ny = 0; }
        }

        //move
        this.x = nx;
        this.y = ny;
    }


    /**
     * Display planet
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     */
    display(cp, fillStyle) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r() / cp.getZf(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
    }

    /**
     * Display planet acceleration
     * 
     * @param {GeoCanvas} cp 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     * @param {number} factor 
     */
    displayAcceleration(cp, strokeStyle = "cyan", lineWidth = 1, factor = 5000) {
        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;

        c2.beginPath();
        c2.moveTo(this.x, this.y);
        c2.lineTo(this.x + factor * this.ax, this.y + factor * this.ay);
        c2.closePath();
        c2.stroke();
    }

}


/***/ }),

/***/ "./src/planets/Universe.js":
/*!*********************************!*\
  !*** ./src/planets/Universe.js ***!
  \*********************************/
/*! exports provided: Universe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Universe", function() { return Universe; });
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
//@ts-check




class Universe {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Planet>} */
        this.ps = [];
    }

    /**
     * Compute the mass of the universe, as the sum of the mass of its planets.
     * @returns {number}
     */
    m() {
        let m = 0;
        for (let p of this.ps)
            m += p.m;
        return m;
    }


    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {Planet} pIgnore A planet to ignore
     * @param {number} exponent
     * @returns {{gx:number,gy:number}}
     */
    getGravityField(x, y, pIgnore = undefined, exponent = 2) {

        /** @type {number} */
        let gx = 0
        /** @type {number} */
        let gy = 0

        //gothrough all planets in the universe
        for (let p of this.ps) {

            //ignore planet
            if (pIgnore && p == pIgnore)
                continue;

            //compute distance
            /** @type {number} */
            let d = p.dP(x, y);
            if (d === 0)
                continue;

            //compute and add contribution
            d = d * Math.pow(d, exponent);
            gx += 0.01 * (p.x - x) * p.m / d;
            gy += 0.01 * (p.y - y) * p.m / d;
        }
        return { gx: gx, gy: gy }
    }


    /**
     * Aggregate two planets
     * 
     * @param {Planet} p1
     * @param {Planet} p2
     * @param {SpatialIndex.<Planet>} sindex
     * @returns {Planet}
     */
    aggregate(p1, p2, sindex) {
        const m = p1.m + p2.m;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](
            this,
            m,
            (p1.x * p1.m + p2.x * p2.m) / m,
            (p1.y * p1.m + p2.y * p2.m) / m,
            (p1.sx * p1.m + p2.sx * p2.m) / m,
            (p1.sy * p1.m + p2.sy * p2.m) / m
        );
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p1);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p2);

        if (sindex) {
            sindex.remove(p1)
            sindex.remove(p2)
            sindex.insert(p)
        }

        return p;
    }



    /**
     * @param {SpatialIndex.<Planet>} sindex
     * @param {number} collisionFactor
     * @returns {Array.<Planet>}
     */
    findCollision(sindex, collisionFactor = 1) {
        for (let pi of this.ps) {

            const w = 2 * pi.r();
            const cand = sindex.get(pi.x - w, pi.y - w, pi.x + w, pi.y + w);

            for (let pj of cand) {

                if (pi == pj) continue;

                /** @type {number} */
                const d1 = pi.d(pj);
                /** @type {number} */
                const d2 = (pi.r() + pj.r()) * collisionFactor;
                if (d1 > d2)
                    continue;
                return [pi, pj];

            }
        }
        return null;
    }


    /**
     * Add planets with random speed
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed
     * @param {number} maxSpeed
     * @returns {this}
     */
    addPlanets(nb = 1, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        for (let i = 0; i < nb; i++) {
            const p = new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, mi, this.w * Math.random(), this.h * Math.random());
            p.setRandomSpeed(minSpeed, maxSpeed);
        }
        return this;
    }



    /**
     * 
     * @param {boolean} bounce 
     * @param {number} vmax 
     * @param {number} exponent 
     * @param {number} collisionFactor 
     * @param {number} timeStepMs 
     * @returns {this}
     */
    step(bounce = false, vmax = 0.8, exponent = 2, collisionFactor = 1, timeStepMs = 10) {

        //observation
        for (let p of this.ps)
            p.observe(exponent);

        //action
        for (let p of this.ps)
            p.change(bounce, vmax, timeStepMs);


        //collision detection
        this.detectCollisions(collisionFactor)

        return this;
    }

    /**
     * @param {number} collisionFactor 
     * @returns {this}
     */
    detectCollisions(collisionFactor = 1) {

        /** @type {SpatialIndex.<Planet>} */
        const sindex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__["SpatialIndex"]();
        sindex.load(this.ps)

        //find first collision
        /** @type {Array.<Planet>} */
        let pair = this.findCollision(sindex, collisionFactor);
        while (pair !== null) {

            //aggregate
            const p = this.aggregate(pair[0], pair[1], sindex)

            //find next collision
            pair = this.findCollision(sindex, collisionFactor);
        }

        return this;
    }


    /**
     * Assign random speed to all planets
     * 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    setRandomSpeed(minSpeed = 0, maxSpeed = 0.1) {
        for (let p of this.ps)
            p.setRandomSpeed(minSpeed, maxSpeed)
        return this
    }

    /**
     * @returns {Planet} The largest planet of the universe, usually the star.
     */
    getLargestPlanet() {
        let pM = null, mM = 0;
        for (let p of this.ps)
            if (p.m > mM) { pM = p; mM = p.m }
        return pM
    }

    /**
     * Get largest planet and explode it.
     */
    explodeLargestPlanet() {
        const p = this.getLargestPlanet()
        this.explode(p)
    }

    /**
     * Explode a planet into pieces
     * 
     * @param {Planet} p 
     * @param {number} nb 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     */
    explode(p, nb = -1, minSpeed = 0.8, maxSpeed = 1.5, rad = -1) {
        if (nb <= 0) nb = Math.floor(p.m);
        if (nb <= 0) return;
        const angleStep = 2 * Math.PI / nb;
        for (let i = 0; i < nb; i++) {
            //create planet

            //position
            if (rad < 0) rad = 2 * p.r()
            const d = rad * Math.random();
            const a = i * angleStep;
            const x = d * Math.cos(a), y = d * Math.sin(a);

            //speed
            const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
            const aS = a + 2 * (Math.random() - 0.5) * 2 * Math.PI / 3;
            const sx = speed * Math.cos(aS), sy = speed * Math.sin(aS);

            new _Planet__WEBPACK_IMPORTED_MODULE_2__["Planet"](this, p.m / nb, p.x + x, p.y + y, p.sx + sx, p.sy + sy)
        }
        //remove p from universe
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_0__["removeFromArray"])(this.ps, p);
    }

}


/***/ }),

/***/ "./src/planets/index.js":
/*!******************************!*\
  !*** ./src/planets/index.js ***!
  \******************************/
/*! exports provided: planets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "planets", function() { return planets; });
/* harmony import */ var _Universe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Universe */ "./src/planets/Universe.js");
/* harmony import */ var _Planet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Planet */ "./src/planets/Planet.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/**  */
class PlanetSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {number} */
        this.maxSpeed = opts.maxSpeed || 0.8;
        /** @type {boolean} */
        this.bounce = opts.bounce || false
        /** @type {number} */
        this.exponent = opts.exponent || 2;
        /** @type {number} */
        this.collisionFactor = opts.collisionFactor || 1;

        /** @type {boolean} */
        this.showPlanetAcceleration = false

        /** @type {string|undefined} */
        this.showField = undefined
        /** @type {number} */
        this.fieldRes = 20
        /** @type {number} */
        this.fieldFactor = 1000
        /** @type {string} */
        this.fieldStrokeStyle = "#99bbff";

        /** @type {number} */
        this.tailings = opts.tailings || 0.1;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "black";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear, with transparency
            c2.fillStyle = "rgba(0,0,0," + th.tailings + ")";
            c2.fillRect(0, 0, th.w, th.h);
            //c2.fillRect(-1e20, -1e20, 2e20, 2e20); //todo

            //display gravity field
            if (th.showField === "f")
                th.displayGravityField(this, true)
            else if (th.showField === "i")
                th.displayGravityField(this, false)


            this.setCanvasTransform()

            //display planets
            for (let p of th.uni.ps) {
                if (!this.toDraw(p)) continue
                const t = p.m / th.uni.m();
                p.display(this, "rgb(255,255," + Math.floor(255 * (1 - t)) + ")")
            }

            //display planets acceleration
            if (th.showPlanetAcceleration) {
                for (let p of th.uni.ps) {
                    if (!this.toDraw(p)) continue
                    p.displayAcceleration(this)
                }
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Universe} */
        this.uni = new _Universe__WEBPACK_IMPORTED_MODULE_0__["Universe"](this.w, this.h)
    }


    /**
     * @param {GeoCanvas} cp 
     * @param {boolean} field 
     */
    displayGravityField(cp, field = true) {
        const c2 = cp.ctx
        const res = this.fieldRes
        const f = this.fieldFactor
        const f_ = field ? 0.3 * res : 0.6 * res;
        c2.strokeStyle = this.fieldStrokeStyle
        for (let x = res * 0.5; x < this.w; x += res) {
            const xG = cp.pixToGeoX(x);
            if (xG > this.uni.w || xG < 0) continue
            for (let y = res / 2; y < this.h; y += res) {
                const yG = cp.pixToGeoY(y);
                if (yG > this.uni.h || yG < 0) continue
                //get gravity field
                const g = this.uni.getGravityField(xG, yG, undefined, this.exponent);
                const g_ = Math.hypot(g.gx, g.gy)

                c2.lineWidth = Math.min(f * g_, 0.3 * res);
                const dx = f_ * g.gx / g_, dy = f_ * g.gy / g_

                //draw
                c2.beginPath();
                if (field) {
                    //gravity field
                    c2.moveTo(x - dx, y + dy);
                    c2.lineTo(x + dx, y - dy);
                } else {
                    //isopotential lines
                    c2.moveTo(x + dy, y + dx);
                    c2.lineTo(x - dy, y - dx);
                }
                c2.closePath();
                c2.stroke();
            }
        }
    }


    /**
     * Initialise with random planets
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @returns {this}
     */
    initRandom(nb = 1000, mi = 0.5, minSpeed = 0, maxSpeed = 0.1) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        this.uni.addPlanets(nb, mi, minSpeed, maxSpeed);
        return this;
    }

    /**
     * Initialise with big bang setup
     * 
     * @param {number} nb 
     * @param {number} mi 
     * @param {number} minSpeed 
     * @param {number} maxSpeed 
     * @param {number} rad 
     * @returns {this}
     */
    initBigBang(nb = 1000, mi = 1, minSpeed = 0.35, maxSpeed = 0.7, rad = 100) {
        /** @type {Array.<Planet>} */
        this.uni.ps = [];
        //create big planet in the middle
        const cx = this.w * 0.5, cy = this.h * 0.5;
        const p = new _Planet__WEBPACK_IMPORTED_MODULE_1__["Planet"](this.uni, nb * mi, cx, cy, 0, 0);
        //explode it
        this.uni.explode(p, nb, minSpeed, maxSpeed, rad)
        return this;
    }

    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.uni.step(t.bounce, t.maxSpeed, t.exponent, t.collisionFactor, timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const planets = function (opts) {
    return new PlanetSimulation(opts)
}


/***/ }),

/***/ "./src/pp/Animal.js":
/*!**************************!*\
  !*** ./src/pp/Animal.js ***!
  \**************************/
/*! exports provided: Animal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animal", function() { return Animal; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/AgentPoint */ "./src/base/AgentPoint.js");
//@ts-check




/** */
class Animal extends _base_AgentPoint__WEBPACK_IMPORTED_MODULE_2__["AgentPoint"] {

    /**
     * @param {number} type 
     * @param {Land} l 
     * @param {number} x 
     * @param {number} y 
     */
    constructor(type, l, x = 0, y = 0) {

        super(x, y)

        /** @type {number} */
        this.type = type;
        /** @type {Land} */
        this.l = l;

        //position
        /** @type {number} */
        this.x = x < 0 ? 0 : x > l.w ? l.w : x
        /** @type {number} */
        this.y = y < 0 ? 0 : y > l.h ? l.h : y

        //the other animals around
        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        //add to the spatial index
        l.grid.insert(this);
    }


    /**
     * @param {*} timeStepMs 
     */
    move(timeStepMs = 10) {
        const l = this.l
        l.grid.remove(this);

        const angle = Math.random() * 2 * Math.PI;
        const r = 0.01 * Math.random();

        this.sx += r * Math.cos(angle) * timeStepMs;
        this.sx = this.sx > l.V_MAX ? l.V_MAX : this.sx < -l.V_MAX ? -l.V_MAX : this.sx

        this.sy += r * Math.sin(angle) * timeStepMs;
        this.sy = this.sy > l.V_MAX ? l.V_MAX : this.sy < -l.V_MAX ? -l.V_MAX : this.sy

        this.x += this.sx * timeStepMs;
        this.x = this.x < 0 ? l.w : this.x > l.w ? 0 : this.x

        this.y += this.sy * timeStepMs;
        this.y = this.y < 0 ? l.h : this.y > l.h ? 0 : this.y

        l.grid.insert(this);
    }


    /** Observe */
    observe() {
        const l = this.l

        //get animals around
        const as = l.grid.get(this.x - l.d, this.y - l.d, this.x + l.d, this.y + l.d);

        this.preys = [];
        this.predators = [];

        for (let a of as) {
            if (a == this) continue;
            if (this.d(a) > l.d) continue;
            if (a.type == 0)
                this.preys.push(a);
            else
                this.predators.push(a);
        }
    }

    /** @returns {Animal} */
    makeChild() {
        //do better: make child around
        return new Animal(this.type, this.l, this.x, this.y);
    }



    /**
     * Display animal
     * 
     * @param {GeoCanvas} cp 
     * @param {string} fillStyle 
     * @param {number} size 
     */
    display(cp, fillStyle = "blue", size = 2) {
        cp.ctx.fillStyle = fillStyle;
        cp.ctx.fillRect(this.x, this.y, size, size);
        /*c2.beginPath();
        c2.arc(a.x, a.y, 0.5, 0, 2*Math.PI);
        c2.closePath();
        c2.fill();*/
    }

}


/***/ }),

/***/ "./src/pp/Land.js":
/*!************************!*\
  !*** ./src/pp/Land.js ***!
  \************************/
/*! exports provided: Land */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Land", function() { return Land; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _base_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/lib */ "./src/base/lib.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
//@ts-check




class Land {

    /**
     * 
     * @param {number} w 
     * @param {number} h 
     */
    constructor(w, h) {

        //the max speed
        /** @type {number} */
        this.V_MAX = 0.1

        /** @type {number} */
        this.p = 0.02 //predator death probability
        /** @type {number} */
        this.q = 0.1 //prey reproduction probability
        /** @type {number} */
        this.r = 0.5 //eaten prey transformation probability
        /** @type {number} */
        this.nb = 3 //neighbors number

        /** @type {number} */
        this.w = w
        /** @type {number} */
        this.h = h

        /** @type {Array.<Animal>} */
        this.predators = []
        /** @type {Array.<Animal>} */
        this.preys = []

        /** @type {number} */
        this.d = 10
        /** @type {SpatialIndex.<Animal>} */
        this.grid = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /*int[][] histo;
        int index=0;
        this.c2Chart=c2Chart;
        this.hChart=hChart;
        this.histo=new int[wChart][];
        for(int i=0;i<wChart;i++)
            histo[i]=new int[]{0,0};*/

    }

    /**
     * @param {number} timeStepMs 
     */
    step(timeStepMs = 10) {

        //observe
        for (let a of this.preys) a.observe();
        for (let a of this.predators) a.observe();

        const preysToBorn = []
        const preysToDie = []
        const predsToBorn = []
        const predsToDie = []

        //prey
        for (let prey of this.preys) {
            //reproduction if no predator around
            if (Math.random() > this.q) continue;
            if (prey.predators.length != 0) continue;
            if (prey.preys.length >= this.nb) continue;
            preysToBorn.push(prey.makeChild());
        }

        //predator
        for (let pred of this.predators) {
            //no prey around: predator dies with probability p
            if (pred.preys.length == 0) {
                if (Math.random() < this.p) predsToDie.push(pred);
            }
            //prey around
            else {
                //eat prey
                //choose randomly
                const preyToEat = pred.preys[Math.floor(pred.preys.length * Math.random())];
                preysToDie.push(preyToEat);

                //predator reproduction
                if (Math.random() > this.r) continue;
                if (pred.predators.length >= this.nb) continue;
                predsToBorn.push(pred.makeChild());
            }
        }

        this.preys.push(...preysToBorn);
        this.predators.push(...predsToBorn);

        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.preys, preysToDie, false)
        for (let a of preysToDie) this.grid.remove(a);
        Object(_base_lib__WEBPACK_IMPORTED_MODULE_1__["removeFromArrayS"])(this.predators, predsToDie, false)
        for (let a of predsToDie) this.grid.remove(a);

        //move
        for (let a of this.preys)
            a.move(timeStepMs);
        for (let a of this.predators)
            a.move(timeStepMs);

        /*/histo
        histo[index] = new int[]{ preys.size(), predators.size() };
        if (index == histo.length - 1) index = 0;
        else index++;*/

    }
}


/***/ }),

/***/ "./src/pp/index.js":
/*!*************************!*\
  !*** ./src/pp/index.js ***!
  \*************************/
/*! exports provided: preyPredator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preyPredator", function() { return preyPredator; });
/* harmony import */ var _Land__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Land */ "./src/pp/Land.js");
/* harmony import */ var _Animal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animal */ "./src/pp/Animal.js");
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check




/** */
class PreyPredatorSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;

        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_2__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);


        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            //transparency
            this.initCanvasTransform()
            c2.fillStyle = "rgba(255,255,255,0.5)";
            c2.fillRect(0, 0, th.w, th.h);

            //display animals
            this.setCanvasTransform()
            for (let a of th.land.preys)
                if (this.toDraw(a))
                    a.display(this, "blue");
            for (let a of th.land.predators)
                if (this.toDraw(a))
                    a.display(this, "red");

            /*/label
            c2.fillStyle = "lightgray";
            c2.fillRect(0, 0, 65, 13);
            c2.fillStyle = "black";
            c2.fillText(preys.length + "/" + predators.length, 2, 10);*/

            //chart
            //c2Chart.setFillStyle(backColor2);
            //c2Chart.fillRect(0, 0, w, h);

            //double max = getMaxHisto();
            /*public int getMaxHisto() {
                int max=0;
                for(int i=0;i<histo.length;i++){
                    if(histo[i][0]>max) max=histo[i][0];
                    if(histo[i][1]>max) max=histo[i][1];
                }
                return max;
            }*/
            /*
                        if (max != 0) {
                            double h1, h2;
                            for (int i = 0; i < histo.length; i++) {
                                h1 = hChart * histo[i][0] / max;
                                h2 = hChart * histo[i][1] / max;
                                c2Chart.setFillStyle(preyColor2);
                                c2Chart.fillRect(i, hChart - h1, 1, h1);
                                c2Chart.setFillStyle(predatorColor2);
                                c2Chart.fillRect(i, hChart - h2, 1, h2);
                            }
                        }
                        c2Chart.setFillStyle(CssColor.make(255, 255, 255));
                        c2Chart.fillRect(index, 0, 1, hChart);
            */

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this
        };


        /** @type {Land} */
        this.land = new _Land__WEBPACK_IMPORTED_MODULE_0__["Land"](this.w, this.h)

    }



    //TODO test init in a bubble ?
    //TODO use density as input parameters instead of nb

    /**
     * 
     * @param {number} preyDensity 
     * @param {number} predatorDensity 
     * @returns {this}
     */
    initRandom(preyDensity = 0.003, predatorDensity = 0.003) {
        const l = this.land
        for (let i = 0; i < preyDensity * l.w * l.h; i++)
            l.preys.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](0, l, l.w * Math.random(), l.h * Math.random())
            );
        for (let i = 0; i < predatorDensity * l.w * l.h; i++)
            l.predators.push(
                new _Animal__WEBPACK_IMPORTED_MODULE_1__["Animal"](1, l, l.w * Math.random(), l.h * Math.random())
            );
        return this;
    }


    /**
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.land.step(timeStepMs);
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

}


/**
 * @param {Object} opts 
 */
const preyPredator = function (opts) {
    return new PreyPredatorSimulation(opts)
}


/***/ }),

/***/ "./src/urban/Building.js":
/*!*******************************!*\
  !*** ./src/urban/Building.js ***!
  \*******************************/
/*! exports provided: Building */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Building", function() { return Building; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
//@ts-check



class Building {

    /**
     * @constructor
     * @param {number} x The x position
     * @param {number} y The y position
     * @param {number} area The area
     */
    constructor(x, y, area) {

        //set position
        /** @type {number} */
        this.x = x
        /** @type {number} */
        this.y = y
        /** @type {number} */
        this.area = area
    }

    /**
     * @returns { number }
     */
    r() {
        return Math.sqrt(this.area / Math.PI)
    }

    /**
     * @param {Building} b 
     */
    overlap(b) {
        const d1 = b.r() + this.r()
        const d2 = Math.hypot((b.x - this.x), (b.y - this.y));
        return d2 < d1
    }



    /**
     * @param {SpatialIndex.<Building>} sindex 
     * @param {number} sDistance 
     * @returns {boolean}
     */
    checkCollision(sindex, sDistance) {

        //get buildings around using spatial index
        /** @type {Array.<Building>} */
        const ss = sindex.get(this.x - sDistance, this.y - sDistance, this.x + sDistance, this.y + sDistance);

        for (let b of ss) {
            if (b == this) continue;
            if (this.overlap(b)) return true
        }
        return false;
    }




    /**
     * Display
     * 
     * @param {GeoCanvas} cp 
     * @param {String} fillStyle 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     */
    display(cp, fillStyle, strokeStyle, lineWidth) {
        const c2 = cp.ctx
        c2.fillStyle = fillStyle;
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;
        c2.beginPath();
        c2.arc(this.x, this.y, this.r(), 0, 2 * Math.PI);
        c2.closePath();
        c2.fill();
        c2.stroke();
    }


}


/***/ }),

/***/ "./src/urban/Map.js":
/*!**************************!*\
  !*** ./src/urban/Map.js ***!
  \**************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });
/* harmony import */ var _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/SpatialIndex */ "./src/base/SpatialIndex.js");
/* harmony import */ var _Building__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Building */ "./src/urban/Building.js");
/* harmony import */ var _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RoadNetwork */ "./src/urban/RoadNetwork.js");
//@ts-check




class Map {

    /**
     * @constructor
     * @param {number} w
     * @param {number} h
     */
    constructor(w, h) {

        /** @type {number} */
        this.w = w;
        /** @type {number} */
        this.h = h;

        /** @type {Array.<Building>} */
        this.bs = [];
        /** @type {SpatialIndex.<Building>} */
        this.buIndex = new _base_SpatialIndex__WEBPACK_IMPORTED_MODULE_0__["SpatialIndex"]();

        /** @type {RoadNetwork} */
        this.rn = new _RoadNetwork__WEBPACK_IMPORTED_MODULE_2__["RoadNetwork"](this);

    }

    /** */
    addBuilding() {

        //compute candidate location, size and type for next building
        //TODO low local congestion AND go to high density (with good access to other stuff)

        //make random building
        const makeRandomBuilding = () => {
            const x = this.w * Math.random();
            const y = this.h * Math.random();
            const area = 40 + 200 * Math.random()
            return new _Building__WEBPACK_IMPORTED_MODULE_1__["Building"](x, y, area)
        }

        //TODO should not overlap with other entities (roads, building)

        /** @type {number} */
        const sDistance = 100;
        /** @type {Building} */
        let bu = makeRandomBuilding();
        while (bu.checkCollision(this.buIndex, sDistance)) {
            bu = makeRandomBuilding();
        }

        //add building
        this.bs.push(bu);
        this.buIndex.load([bu])
    }

    /**
     * @returns {this}
     */
    step() {

        //compute building need
        const buNeed = 10;

        //urbanise
        for (let i = 0; i < buNeed; i++) {
            this.addBuilding();
        }

        //extend road network
        //TODO

        return this;
    }

}


/***/ }),

/***/ "./src/urban/Road.js":
/*!***************************!*\
  !*** ./src/urban/Road.js ***!
  \***************************/
/*! exports provided: Road */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Road", function() { return Road; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check


class Road {

    /**
     * 
     * @param {object} geom 
     * @param {number} width 
     */
    constructor(geom, width) {

        /** @type {jsts.geom.Geometry} */
        this.geom = geom
        /** @type {number} */
        this.width = width

    }


    /**
     * Display
     * 
     * @param {GeoCanvas} cp 
     * @param {String} strokeStyle 
     * @param {number} lineWidth 
     */
    display(cp, strokeStyle, lineWidth) {
        const cs = this.geom.getCoordinates();
        if (cs.length == 0) return;

        const c2 = cp.ctx
        c2.strokeStyle = strokeStyle;
        c2.lineWidth = lineWidth;

        //move to first point
        let c = cs[0]
        c2.moveTo(c.x, c.y);

        //trace line
        c2.beginPath();
        for (let i = 1; i < cs.length; i++) {
            c = cs[i]
            c2.lineTo(c.x, c.y);
        }
        c2.stroke();

    }

}


/***/ }),

/***/ "./src/urban/RoadNetwork.js":
/*!**********************************!*\
  !*** ./src/urban/RoadNetwork.js ***!
  \**********************************/
/*! exports provided: RoadNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoadNetwork", function() { return RoadNetwork; });
/* harmony import */ var _Road__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Road */ "./src/urban/Road.js");
/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map */ "./src/urban/Map.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");
/* harmony import */ var jsts__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jsts__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
//@ts-check





class RoadNetwork {

    /**
     * @param {Map} map 
     */
    constructor(map) {

        /** @type {Map} */
        this.map = map

        /** @type {Array.<Road>} */
        this.sections = []


        //add test road
        //https://github.com/bjornharrtell/jsts
        //http://bjornharrtell.github.io/jsts/
        var reader = new jsts__WEBPACK_IMPORTED_MODULE_2___default.a.io.WKTReader()
        var g = reader.read('LINESTRING (30 10, 10 300, 400 400)')
        this.sections.push(new _Road__WEBPACK_IMPORTED_MODULE_0__["Road"](g, 7));
    }

    buildRandom() {

        const w = this.map.w
        const h = this.map.h

        //const r = 2 * w + 2 * h * Math.random();



    }

    /**
     * Display
     * @param {GeoCanvas} cp 
     */
    display(cp) {
        for (let r of this.sections)
            r.display(cp, "black", r.width);
        for (let r of this.sections)
            r.display(cp, "yellow", r.width - 3);
    }
}


/***/ }),

/***/ "./src/urban/index.js":
/*!****************************!*\
  !*** ./src/urban/index.js ***!
  \****************************/
/*! exports provided: urban */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urban", function() { return urban; });
/* harmony import */ var _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/GeoCanvas */ "./src/base/GeoCanvas.js");
/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Map */ "./src/urban/Map.js");
//@ts-check



/**  */
class UrbanSimulation {

    /**
     * @param {Object} opts 
     */
    constructor(opts) {
        opts = opts || {};

        opts.canvasId = opts.canvasId || "vacanvas";
        const canvas = document.getElementById(opts.canvasId);
        if (canvas == null) throw "No canvas " + opts.canvasId;

        /** @type {number} */
        this.w = opts.w || canvas.offsetWidth;
        /** @type {number} */
        this.h = opts.h || canvas.offsetHeight;


        /** @type {GeoCanvas} */
        this.cplus = new _base_GeoCanvas__WEBPACK_IMPORTED_MODULE_0__["GeoCanvas"]();
        this.cplus.ctx.fillStyle = "white";
        this.cplus.ctx.fillRect(0, 0, this.w, this.h);

        const th = this;
        this.cplus.redraw = function () {
            const c2 = this.ctx

            this.initCanvasTransform();

            //clear
            c2.fillStyle = "white";
            c2.fillRect(0, 0, th.w, th.h);

            this.setCanvasTransform()

            //display road network
            th.map.rn.display(this);

            //display buildings
            for (let b of th.map.bs) {
                if (!this.toDraw(b)) continue
                b.display(this, "lightgray", "black", 2)
            }

            //frame
            c2.strokeStyle = "darkgray";
            c2.lineWidth = 1 * th.cplus.getZf();
            c2.beginPath();
            c2.rect(0, 0, th.w, th.h);
            c2.stroke();

            return this;
        };

        /** @type {Map} */
        this.map = new _Map__WEBPACK_IMPORTED_MODULE_1__["Map"](this.w, this.h)
    }


    /**
     * Start simulation
     * 
     * @param {number} timeStepMs 
     * @param {number} nbIterations 
     * @returns {this}
     */
    start(timeStepMs = 10, nbIterations = -1) {
        let i = 0;
        const t = this;
        const engine = function () {
            t.map.step();
            t.cplus.redraw();
            if (nbIterations > 0 && i++ > nbIterations)
                return;
            setTimeout(engine, 0);
        };
        engine();
        return this;
    }

    //stop
    stop() {
        //TODO
    }

}

/**
 * @param {Object} opts 
 */
const urban = function (opts) {
    return new UrbanSimulation(opts)
}


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZWN0YWcvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3ZlY3RhZy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY3ViZWhlbGl4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2RyYWcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9iYWNrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9ib3VuY2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2VsYXN0aWMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2V4cC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcG9seS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvc2luLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kaXNjcmV0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hjbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hzbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2h1ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbGFiLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JvdW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRvci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9sb2NhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tYXRjaGVyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlcnMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2xvd2VyLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZXMuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvd2luZG93LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW50ZXJydXB0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0clR3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2RlbGF5LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZVZhcnlpbmcuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2NoZWR1bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3R3ZWVuLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vbm9kZV9tb2R1bGVzL2pzdHMvZGlzdC9qc3RzLm1pbi5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9ub2RlX21vZHVsZXMvcmJ1c2gvcmJ1c2gubWluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL0FnZW50UG9pbnQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Jhc2UvR2VvQ2FudmFzLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9iYXNlL1NwYXRpYWxJbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvYmFzZS9saWIuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2Zpc2gvU2FyZGluLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9maXNoL1NlYS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZmlzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL0NlbGwuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL2dvbC9Vbml2ZXJzZS5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvZ29sL2luZGV4LmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcGxhbmV0cy9QbGFuZXQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvVW5pdmVyc2UuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BsYW5ldHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3BwL0FuaW1hbC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvTGFuZC5qcyIsIndlYnBhY2s6Ly92ZWN0YWcvLi9zcmMvcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL0J1aWxkaW5nLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9NYXAuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWQuanMiLCJ3ZWJwYWNrOi8vdmVjdGFnLy4vc3JjL3VyYmFuL1JvYWROZXR3b3JrLmpzIiwid2VicGFjazovL3ZlY3RhZy8uL3NyYy91cmJhbi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDOztBQUVwQzs7QUFFQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBTSxXQUFXLHlEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FB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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUM3UEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ2tDO0FBQ2tCO0FBQ047O0FBRTlDO0FBQ087O0FBRVA7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7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QzFCOzs7QUFHQSxtQkFBbUIsVUFBVTtBQUM3Qix5QkFBeUIseURBQVM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsSUFBSTtBQUN2Qix1QkFBdUIsd0NBQUc7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDTztBQUNQO0FBQ0EiLCJmaWxlIjoidmVjdGFnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmVjdGFnXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZlY3RhZ1wiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJidWlsZC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENvbG9yKCkge31cblxuZXhwb3J0IHZhciBkYXJrZXIgPSAwLjc7XG5leHBvcnQgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weTogZnVuY3Rpb24oY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gcmdiYShtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IHJnYmEoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gXCIjXCIgKyBoZXgodGhpcy5yKSArIGhleCh0aGlzLmcpICsgaGV4KHRoaXMuYik7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICByZXR1cm4gKGEgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIilcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmcpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iKSB8fCAwKSlcbiAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCIpXG4gICAgICAgICsgKHRoaXMuaCB8fCAwKSArIFwiLCBcIlxuICAgICAgICArICh0aGlzLnMgfHwgMCkgKiAxMDAgKyBcIiUsIFwiXG4gICAgICAgICsgKHRoaXMubCB8fCAwKSAqIDEwMCArIFwiJVwiXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2IsIGRhcmtlciwgYnJpZ2h0ZXJ9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxudmFyIEEgPSAtMC4xNDg2MSxcbiAgICBCID0gKzEuNzgyNzcsXG4gICAgQyA9IC0wLjI5MjI3LFxuICAgIEQgPSAtMC45MDY0OSxcbiAgICBFID0gKzEuOTcyOTQsXG4gICAgRUQgPSBFICogRCxcbiAgICBFQiA9IEUgKiBCLFxuICAgIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSByZXR1cm4gbmV3IEN1YmVoZWxpeChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcbiAgICAgIGJsID0gYiAtIGwsXG4gICAgICBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQsXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSwgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiBkZWdyZWVzIC0gMTIwIDogTmFOO1xuICByZXR1cm4gbmV3IEN1YmVoZWxpeChoIDwgMCA/IGggKyAzNjAgOiBoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGN1YmVoZWxpeENvbnZlcnQoaCkgOiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoQ3ViZWhlbGl4LCBjdWJlaGVsaXgsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogcmFkaWFucyxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBjb2xvciwgcmdiLCBoc2x9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbGFiLCBoY2wsIGxjaCwgZ3JheX0gZnJvbSBcIi4vbGFiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3ViZWhlbGl4fSBmcm9tIFwiLi9jdWJlaGVsaXguanNcIjtcbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdifSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWdyZWVzLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbi8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbmNvbnN0IEsgPSAxOCxcbiAgICBYbiA9IDAuOTY0MjIsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMC44MjUyMSxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gaGNsMmxhYihvKTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBuZXcgTGFiKGwsIDAsIDAsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBsYWJDb252ZXJ0KGwpIDogbmV3IExhYihsLCBhLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5hID0gK2E7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKExhYiwgbGFiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBscmdiMnJnYiggMy4xMzM4NTYxICogeCAtIDEuNjE2ODY2NyAqIHkgLSAwLjQ5MDYxNDYgKiB6KSxcbiAgICAgIGxyZ2IycmdiKC0wLjk3ODc2ODQgKiB4ICsgMS45MTYxNDE1ICogeSArIDAuMDMzNDU0MCAqIHopLFxuICAgICAgbHJnYjJyZ2IoIDAuMDcxOTQ1MyAqIHggLSAwLjIyODk5MTQgKiB5ICsgMS40MDUyNDI3ICogeiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24gbHJnYjJyZ2IoeCkge1xuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cblxuZnVuY3Rpb24gcmdiMmxyZ2IoeCkge1xuICByZXR1cm4gKHggLz0gMjU1KSA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gaGNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gbmV3IEhjbChvLmgsIG8uYywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XG4gIGlmIChvLmEgPT09IDAgJiYgby5iID09PSAwKSByZXR1cm4gbmV3IEhjbChOYU4sIDAgPCBvLmwgJiYgby5sIDwgMTAwID8gMCA6IE5hTiwgby5sLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogZGVncmVlcztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxjaChsLCBjLCBoLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChsKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5jID0gK2M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZnVuY3Rpb24gaGNsMmxhYihvKSB7XG4gIGlmIChpc05hTihvLmgpKSByZXR1cm4gbmV3IExhYihvLmwsIDAsIDAsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gby5oICogcmFkaWFucztcbiAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG59XG5cbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGhjbDJsYWIodGhpcykucmdiKCk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBjb25zdCByYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGRpc3BhdGNofSBmcm9tIFwiLi9kaXNwYXRjaC5qc1wiO1xuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3NlbGVjdCwgcG9pbnRlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IG5vZHJhZywge3llc2RyYWd9IGZyb20gXCIuL25vZHJhZy5qc1wiO1xuaW1wb3J0IG5vZXZlbnQsIHtub25wYXNzaXZlLCBub25wYXNzaXZlY2FwdHVyZSwgbm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgRHJhZ0V2ZW50IGZyb20gXCIuL2V2ZW50LmpzXCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcihldmVudCkge1xuICByZXR1cm4gIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRhaW5lcigpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN1YmplY3QoZXZlbnQsIGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBldmVudC54LCB5OiBldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gZGVmYXVsdFN1YmplY3QsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgZ2VzdHVyZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxuICAgICAgYWN0aXZlID0gMCxcbiAgICAgIG1vdXNlZG93bngsXG4gICAgICBtb3VzZWRvd255LFxuICAgICAgbW91c2Vtb3ZpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiBkcmFnKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd25lZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuZHJhZ1wiLCB0b3VjaG1vdmVkLCBub25wYXNzaXZlKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC5kcmFnIHRvdWNoY2FuY2VsLmRyYWdcIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoZXZlbnQsIGQpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5jYWxsKHRoaXMsIGV2ZW50LCBkKSkgcmV0dXJuO1xuICAgIHZhciBnZXN0dXJlID0gYmVmb3Jlc3RhcnQodGhpcywgY29udGFpbmVyLmNhbGwodGhpcywgZXZlbnQsIGQpLCBldmVudCwgZCwgXCJtb3VzZVwiKTtcbiAgICBpZiAoIWdlc3R1cmUpIHJldHVybjtcbiAgICBzZWxlY3QoZXZlbnQudmlldylcbiAgICAgIC5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIG5vbnBhc3NpdmVjYXB0dXJlKVxuICAgICAgLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgICBub2RyYWcoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgbW91c2Vtb3ZpbmcgPSBmYWxzZTtcbiAgICBtb3VzZWRvd254ID0gZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZXZlbnQuY2xpZW50WTtcbiAgICBnZXN0dXJlKFwic3RhcnRcIiwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vtb3ZlZChldmVudCkge1xuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGlmICghbW91c2Vtb3ZpbmcpIHtcbiAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBtb3VzZWRvd254LCBkeSA9IGV2ZW50LmNsaWVudFkgLSBtb3VzZWRvd255O1xuICAgICAgbW91c2Vtb3ZpbmcgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgIH1cbiAgICBnZXN0dXJlcy5tb3VzZShcImRyYWdcIiwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZChldmVudCkge1xuICAgIHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKTtcbiAgICB5ZXNkcmFnKGV2ZW50LnZpZXcsIG1vdXNlbW92aW5nKTtcbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBnZXN0dXJlcy5tb3VzZShcImVuZFwiLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoZXZlbnQsIGQpIHtcbiAgICBpZiAoIWZpbHRlci5jYWxsKHRoaXMsIGV2ZW50LCBkKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIGMgPSBjb250YWluZXIuY2FsbCh0aGlzLCBldmVudCwgZCksXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodGhpcywgYywgZXZlbnQsIGQsIHRvdWNoZXNbaV0uaWRlbnRpZmllciwgdG91Y2hlc1tpXSkpIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiLCBldmVudCwgdG91Y2hlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZChldmVudCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgICAgZ2VzdHVyZShcImRyYWdcIiwgZXZlbnQsIHRvdWNoZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgICAgIGdlc3R1cmUoXCJlbmRcIiwgZXZlbnQsIHRvdWNoZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZXN0YXJ0KHRoYXQsIGNvbnRhaW5lciwgZXZlbnQsIGQsIGlkZW50aWZpZXIsIHRvdWNoKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbGlzdGVuZXJzLmNvcHkoKSxcbiAgICAgICAgcCA9IHBvaW50ZXIodG91Y2ggfHwgZXZlbnQsIGNvbnRhaW5lciksIGR4LCBkeSxcbiAgICAgICAgcztcblxuICAgIGlmICgocyA9IHN1YmplY3QuY2FsbCh0aGF0LCBuZXcgRHJhZ0V2ZW50KFwiYmVmb3Jlc3RhcnRcIiwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICAgIHRhcmdldDogZHJhZyxcbiAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICB4OiBwWzBdLFxuICAgICAgICB5OiBwWzFdLFxuICAgICAgICBkeDogMCxcbiAgICAgICAgZHk6IDAsXG4gICAgICAgIGRpc3BhdGNoXG4gICAgICB9KSwgZCkpID09IG51bGwpIHJldHVybjtcblxuICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgIGR5ID0gcy55IC0gcFsxXSB8fCAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSwgZXZlbnQsIHRvdWNoKSB7XG4gICAgICB2YXIgcDAgPSBwLCBuO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOiBnZXN0dXJlc1tpZGVudGlmaWVyXSA9IGdlc3R1cmUsIG4gPSBhY3RpdmUrKzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbmRcIjogZGVsZXRlIGdlc3R1cmVzW2lkZW50aWZpZXJdLCAtLWFjdGl2ZTsgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnRlcih0b3VjaCB8fCBldmVudCwgY29udGFpbmVyKSwgbiA9IGFjdGl2ZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaC5jYWxsKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGF0LFxuICAgICAgICBuZXcgRHJhZ0V2ZW50KHR5cGUsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICAgICAgc3ViamVjdDogcyxcbiAgICAgICAgICB0YXJnZXQ6IGRyYWcsXG4gICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICBhY3RpdmU6IG4sXG4gICAgICAgICAgeDogcFswXSArIGR4LFxuICAgICAgICAgIHk6IHBbMV0gKyBkeSxcbiAgICAgICAgICBkeDogcFswXSAtIHAwWzBdLFxuICAgICAgICAgIGR5OiBwWzFdIC0gcDBbMV0sXG4gICAgICAgICAgZGlzcGF0Y2hcbiAgICAgICAgfSksXG4gICAgICAgIGRcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIGRyYWcuZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiBmaWx0ZXI7XG4gIH07XG5cbiAgZHJhZy5jb250YWluZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGFpbmVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBjb250YWluZXI7XG4gIH07XG5cbiAgZHJhZy5zdWJqZWN0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN1YmplY3QgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IHN1YmplY3Q7XG4gIH07XG5cbiAgZHJhZy50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICBkcmFnLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGRyYWcgOiB2YWx1ZTtcbiAgfTtcblxuICBkcmFnLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIGRyYWcpIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICByZXR1cm4gZHJhZztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERyYWdFdmVudCh0eXBlLCB7XG4gIHNvdXJjZUV2ZW50LFxuICBzdWJqZWN0LFxuICB0YXJnZXQsXG4gIGlkZW50aWZpZXIsXG4gIGFjdGl2ZSxcbiAgeCwgeSwgZHgsIGR5LFxuICBkaXNwYXRjaFxufSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHlwZToge3ZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHNvdXJjZUV2ZW50OiB7dmFsdWU6IHNvdXJjZUV2ZW50LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHN1YmplY3Q6IHt2YWx1ZTogc3ViamVjdCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0YXJnZXQ6IHt2YWx1ZTogdGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIGlkZW50aWZpZXI6IHt2YWx1ZTogaWRlbnRpZmllciwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBhY3RpdmU6IHt2YWx1ZTogYWN0aXZlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHg6IHt2YWx1ZTogeCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB5OiB7dmFsdWU6IHksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgZHg6IHt2YWx1ZTogZHgsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgZHk6IHt2YWx1ZTogZHksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgXzoge3ZhbHVlOiBkaXNwYXRjaH1cbiAgfSk7XG59XG5cbkRyYWdFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5fLm9uLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHZhbHVlID09PSB0aGlzLl8gPyB0aGlzIDogdmFsdWU7XG59O1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWd9IGZyb20gXCIuL2RyYWcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkcmFnRGlzYWJsZSwgeWVzZHJhZyBhcyBkcmFnRW5hYmxlfSBmcm9tIFwiLi9ub2RyYWcuanNcIjtcbiIsImltcG9ydCB7c2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9ldmVudCwge25vbnBhc3NpdmVjYXB0dXJlfSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHllc2RyYWcodmlldywgbm9jbGljaykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIGlmIChub2NsaWNrKSB7XG4gICAgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG4iLCIvLyBUaGVzZSBhcmUgdHlwaWNhbGx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBub2V2ZW50IHRvIGVuc3VyZSB0aGF0IHdlIGNhblxuLy8gcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50LlxuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmUgPSB7cGFzc2l2ZTogZmFsc2V9O1xuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmVjYXB0dXJlID0ge2NhcHR1cmU6IHRydWUsIHBhc3NpdmU6IGZhbHNlfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwidmFyIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG5cbmV4cG9ydCB2YXIgYmFja0luID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrSW4odCkge1xuICAgIHJldHVybiAodCA9ICt0KSAqIHQgKiAocyAqICh0IC0gMSkgKyB0KTtcbiAgfVxuXG4gIGJhY2tJbi5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tJbjtcbn0pKG92ZXJzaG9vdCk7XG5cbmV4cG9ydCB2YXIgYmFja091dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHQgKyAxKSAqIHMgKyB0KSArIDE7XG4gIH1cblxuICBiYWNrT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja091dDtcbn0pKG92ZXJzaG9vdCk7XG5cbmV4cG9ydCB2YXIgYmFja0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrSW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgKj0gMikgPCAxID8gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSA6ICh0IC09IDIpICogdCAqICgocyArIDEpICogdCArIHMpICsgMikgLyAyO1xuICB9XG5cbiAgYmFja0luT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja0luT3V0O1xufSkob3ZlcnNob290KTtcbiIsInZhciBiMSA9IDQgLyAxMSxcbiAgICBiMiA9IDYgLyAxMSxcbiAgICBiMyA9IDggLyAxMSxcbiAgICBiNCA9IDMgLyA0LFxuICAgIGI1ID0gOSAvIDExLFxuICAgIGI2ID0gMTAgLyAxMSxcbiAgICBiNyA9IDE1IC8gMTYsXG4gICAgYjggPSAyMSAvIDIyLFxuICAgIGI5ID0gNjMgLyA2NCxcbiAgICBiMCA9IDEgLyBiMSAvIGIxO1xuXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0gdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VPdXQodCkge1xuICByZXR1cm4gKHQgPSArdCkgPCBiMSA/IGIwICogdCAqIHQgOiB0IDwgYjMgPyBiMCAqICh0IC09IGIyKSAqIHQgKyBiNCA6IHQgPCBiNiA/IGIwICogKHQgLT0gYjUpICogdCArIGI3IDogYjAgKiAodCAtPSBiOCkgKiB0ICsgYjk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBib3VuY2VPdXQoMSAtIHQpIDogYm91bmNlT3V0KHQgLSAxKSArIDEpIC8gMjtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjaXJjbGVJbih0KSB7XG4gIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVPdXQodCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZUluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpIDogTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgLyAyO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG4iLCJpbXBvcnQge3RwbXR9IGZyb20gXCIuL21hdGguanNcIjtcblxudmFyIHRhdSA9IDIgKiBNYXRoLlBJLFxuICAgIGFtcGxpdHVkZSA9IDEsXG4gICAgcGVyaW9kID0gMC4zO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNJbiA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBhICogdHBtdCgtKC0tdCkpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY0luLmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luLnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luO1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBhICogdHBtdCh0ID0gK3QpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG5leHBvcnQgdmFyIGVsYXN0aWNJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgPSB0ICogMiAtIDEpIDwgMFxuICAgICAgICA/IGEgKiB0cG10KC10KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKVxuICAgICAgICA6IDIgLSBhICogdHBtdCh0KSAqIE1hdGguc2luKChzICsgdCkgLyBwKSkgLyAyO1xuICB9XG5cbiAgZWxhc3RpY0luT3V0LmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luT3V0LnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuIiwiaW1wb3J0IHt0cG10fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBJbih0KSB7XG4gIHJldHVybiB0cG10KDEgLSArdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBPdXQodCkge1xuICByZXR1cm4gMSAtIHRwbXQodCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHRwbXQoMSAtIHQpIDogMiAtIHRwbXQodCAtIDEpKSAvIDI7XG59XG4iLCJleHBvcnQge1xuICBsaW5lYXIgYXMgZWFzZUxpbmVhclxufSBmcm9tIFwiLi9saW5lYXIuanNcIjtcblxuZXhwb3J0IHtcbiAgcXVhZEluT3V0IGFzIGVhc2VRdWFkLFxuICBxdWFkSW4gYXMgZWFzZVF1YWRJbixcbiAgcXVhZE91dCBhcyBlYXNlUXVhZE91dCxcbiAgcXVhZEluT3V0IGFzIGVhc2VRdWFkSW5PdXRcbn0gZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQge1xuICBjdWJpY0luT3V0IGFzIGVhc2VDdWJpYyxcbiAgY3ViaWNJbiBhcyBlYXNlQ3ViaWNJbixcbiAgY3ViaWNPdXQgYXMgZWFzZUN1YmljT3V0LFxuICBjdWJpY0luT3V0IGFzIGVhc2VDdWJpY0luT3V0XG59IGZyb20gXCIuL2N1YmljLmpzXCI7XG5cbmV4cG9ydCB7XG4gIHBvbHlJbk91dCBhcyBlYXNlUG9seSxcbiAgcG9seUluIGFzIGVhc2VQb2x5SW4sXG4gIHBvbHlPdXQgYXMgZWFzZVBvbHlPdXQsXG4gIHBvbHlJbk91dCBhcyBlYXNlUG9seUluT3V0XG59IGZyb20gXCIuL3BvbHkuanNcIjtcblxuZXhwb3J0IHtcbiAgc2luSW5PdXQgYXMgZWFzZVNpbixcbiAgc2luSW4gYXMgZWFzZVNpbkluLFxuICBzaW5PdXQgYXMgZWFzZVNpbk91dCxcbiAgc2luSW5PdXQgYXMgZWFzZVNpbkluT3V0XG59IGZyb20gXCIuL3Npbi5qc1wiO1xuXG5leHBvcnQge1xuICBleHBJbk91dCBhcyBlYXNlRXhwLFxuICBleHBJbiBhcyBlYXNlRXhwSW4sXG4gIGV4cE91dCBhcyBlYXNlRXhwT3V0LFxuICBleHBJbk91dCBhcyBlYXNlRXhwSW5PdXRcbn0gZnJvbSBcIi4vZXhwLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGNpcmNsZUluT3V0IGFzIGVhc2VDaXJjbGUsXG4gIGNpcmNsZUluIGFzIGVhc2VDaXJjbGVJbixcbiAgY2lyY2xlT3V0IGFzIGVhc2VDaXJjbGVPdXQsXG4gIGNpcmNsZUluT3V0IGFzIGVhc2VDaXJjbGVJbk91dFxufSBmcm9tIFwiLi9jaXJjbGUuanNcIjtcblxuZXhwb3J0IHtcbiAgYm91bmNlT3V0IGFzIGVhc2VCb3VuY2UsXG4gIGJvdW5jZUluIGFzIGVhc2VCb3VuY2VJbixcbiAgYm91bmNlT3V0IGFzIGVhc2VCb3VuY2VPdXQsXG4gIGJvdW5jZUluT3V0IGFzIGVhc2VCb3VuY2VJbk91dFxufSBmcm9tIFwiLi9ib3VuY2UuanNcIjtcblxuZXhwb3J0IHtcbiAgYmFja0luT3V0IGFzIGVhc2VCYWNrLFxuICBiYWNrSW4gYXMgZWFzZUJhY2tJbixcbiAgYmFja091dCBhcyBlYXNlQmFja091dCxcbiAgYmFja0luT3V0IGFzIGVhc2VCYWNrSW5PdXRcbn0gZnJvbSBcIi4vYmFjay5qc1wiO1xuXG5leHBvcnQge1xuICBlbGFzdGljT3V0IGFzIGVhc2VFbGFzdGljLFxuICBlbGFzdGljSW4gYXMgZWFzZUVsYXN0aWNJbixcbiAgZWxhc3RpY091dCBhcyBlYXNlRWxhc3RpY091dCxcbiAgZWxhc3RpY0luT3V0IGFzIGVhc2VFbGFzdGljSW5PdXRcbn0gZnJvbSBcIi4vZWxhc3RpYy5qc1wiO1xuIiwiZXhwb3J0IGNvbnN0IGxpbmVhciA9IHQgPT4gK3Q7XG4iLCIvLyB0cG10IGlzIHR3byBwb3dlciBtaW51cyB0ZW4gdGltZXMgdCBzY2FsZWQgdG8gWzAsMV1cbmV4cG9ydCBmdW5jdGlvbiB0cG10KHgpIHtcbiAgcmV0dXJuIChNYXRoLnBvdygyLCAtMTAgKiB4KSAtIDAuMDAwOTc2NTYyNSkgKiAxLjAwMDk3NzUxNzEwNjU0OTQ7XG59XG4iLCJ2YXIgZXhwb25lbnQgPSAzO1xuXG5leHBvcnQgdmFyIHBvbHlJbiA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gIH1cblxuICBwb2x5SW4uZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbjtcbn0pKGV4cG9uZW50KTtcblxuZXhwb3J0IHZhciBwb2x5T3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5T3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBlKTtcbiAgfVxuXG4gIHBvbHlPdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlPdXQ7XG59KShleHBvbmVudCk7XG5cbmV4cG9ydCB2YXIgcG9seUluT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5SW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KHQsIGUpIDogMiAtIE1hdGgucG93KDIgLSB0LCBlKSkgLyAyO1xuICB9XG5cbiAgcG9seUluT3V0LmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW5PdXQ7XG59KShleHBvbmVudCk7XG4iLCJleHBvcnQgZnVuY3Rpb24gcXVhZEluKHQpIHtcbiAgcmV0dXJuIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhZE91dCh0KSB7XG4gIHJldHVybiB0ICogKDIgLSB0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcbn1cbiIsInZhciBwaSA9IE1hdGguUEksXG4gICAgaGFsZlBpID0gcGkgLyAyO1xuXG5leHBvcnQgZnVuY3Rpb24gc2luSW4odCkge1xuICByZXR1cm4gKCt0ID09PSAxKSA/IDEgOiAxIC0gTWF0aC5jb3ModCAqIGhhbGZQaSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5PdXQodCkge1xuICByZXR1cm4gTWF0aC5zaW4odCAqIGhhbGZQaSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5Jbk91dCh0KSB7XG4gIHJldHVybiAoMSAtIE1hdGguY29zKHBpICogdCkpIC8gMjtcbn1cbiIsImltcG9ydCB2YWx1ZSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuaW1wb3J0IG51bWJlckFycmF5LCB7aXNOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gKGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheSA6IGdlbmVyaWNBcnJheSkoYSwgYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmljQXJyYXkoYSwgYikge1xuICB2YXIgbmIgPSBiID8gYi5sZW5ndGggOiAwLFxuICAgICAgbmEgPSBhID8gTWF0aC5taW4obmIsIGEubGVuZ3RoKSA6IDAsXG4gICAgICB4ID0gbmV3IEFycmF5KG5hKSxcbiAgICAgIGMgPSBuZXcgQXJyYXkobmIpLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgeFtpXSA9IHZhbHVlKGFbaV0sIGJbaV0pO1xuICBmb3IgKDsgaSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiaW1wb3J0IHtjdWJlaGVsaXggYXMgY29sb3JDdWJlaGVsaXh9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaHVlKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBjb2xvckN1YmVoZWxpeChlbmQpKS5oKSxcbiAgICAgICAgICBzID0gY29sb3Ioc3RhcnQucywgZW5kLnMpLFxuICAgICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4LmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG5cbiAgICByZXR1cm4gY3ViZWhlbGl4O1xuICB9KSgxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3ViZWhlbGl4KGh1ZSk7XG5leHBvcnQgdmFyIGN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXgoY29sb3IpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgZCA9IG5ldyBEYXRlO1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZC5zZXRUaW1lKGEgKiAoMSAtIHQpICsgYiAqIHQpLCBkO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cbiIsImltcG9ydCB7aGNsIGFzIGNvbG9ySGNsfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gaGNsKGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IGNvbG9ySGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGNvbG9ySGNsKGVuZCkpLmgpLFxuICAgICAgICBjID0gY29sb3Ioc3RhcnQuYywgZW5kLmMpLFxuICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBoY2woaHVlKTtcbmV4cG9ydCB2YXIgaGNsTG9uZyA9IGhjbChjb2xvcik7XG4iLCJpbXBvcnQge2hzbCBhcyBjb2xvckhzbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhzbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhzbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhzbChlbmQpKS5oKSxcbiAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaHNsKGh1ZSk7XG5leHBvcnQgdmFyIGhzbExvbmcgPSBoc2woY29sb3IpO1xuIiwiaW1wb3J0IHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSBodWUoK2EsICtiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgeCA9IGkodCk7XG4gICAgcmV0dXJuIHggLSAzNjAgKiBNYXRoLmZsb29yKHggLyAzNjApO1xuICB9O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQXJyYXl9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUJhc2lzQ2xvc2VkfSBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGF0ZX0gZnJvbSBcIi4vZGF0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGlzY3JldGV9IGZyb20gXCIuL2Rpc2NyZXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIdWV9IGZyb20gXCIuL2h1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlTnVtYmVyfSBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlT2JqZWN0fSBmcm9tIFwiLi9vYmplY3QuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiLi9yb3VuZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlU3RyaW5nfSBmcm9tIFwiLi9zdHJpbmcuanNcIjtcbmV4cG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MsIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnfSBmcm9tIFwiLi90cmFuc2Zvcm0vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVpvb219IGZyb20gXCIuL3pvb20uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJnYiwgcmdiQmFzaXMgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpcywgcmdiQmFzaXNDbG9zZWQgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vcmdiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIc2wsIGhzbExvbmcgYXMgaW50ZXJwb2xhdGVIc2xMb25nfSBmcm9tIFwiLi9oc2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUxhYn0gZnJvbSBcIi4vbGFiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIY2wsIGhjbExvbmcgYXMgaW50ZXJwb2xhdGVIY2xMb25nfSBmcm9tIFwiLi9oY2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeCwgY3ViZWhlbGl4TG9uZyBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmd9IGZyb20gXCIuL2N1YmVoZWxpeC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZWNld2lzZX0gZnJvbSBcIi4vcGllY2V3aXNlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG4iLCJpbXBvcnQge2xhYiBhcyBjb2xvckxhYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBjb2xvcigoc3RhcnQgPSBjb2xvckxhYihzdGFydCkpLmwsIChlbmQgPSBjb2xvckxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBjb2xvcihzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFiKSBiID0gW107XG4gIHZhciBuID0gYSA/IE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgYyA9IGIuc2xpY2UoKSxcbiAgICAgIGk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY1tpXSA9IGFbaV0gKiAoMSAtIHQpICsgYltpXSAqIHQ7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlckFycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgaSA9IHt9LFxuICAgICAgYyA9IHt9LFxuICAgICAgaztcblxuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IHZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyB2YWx1ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB2YWx1ZXMgPSBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJwb2xhdG9yLCBuKSB7XG4gIHZhciBzYW1wbGVzID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgc2FtcGxlc1tpXSA9IGludGVycG9sYXRvcihpIC8gKG4gLSAxKSk7XG4gIHJldHVybiBzYW1wbGVzO1xufVxuIiwiaW1wb3J0IHtyZ2IgYXMgY29sb3JSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGJhc2lzIGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5pbXBvcnQgYmFzaXNDbG9zZWQgZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmltcG9ydCBub2dhbW1hLCB7Z2FtbWF9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBjb2xvclJnYihzdGFydCkpLnIsIChlbmQgPSBjb2xvclJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGNvbG9yUmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMpO1xuZXhwb3J0IHZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiAoMSAtIHQpICsgYiAqIHQpO1xuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHJnYiBmcm9tIFwiLi9yZ2IuanNcIjtcbmltcG9ydCB7Z2VuZXJpY0FycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGRhdGUgZnJvbSBcIi4vZGF0ZS5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCBvYmplY3QgZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5pbXBvcnQgc3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG4iLCJ2YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHpvb21SaG8ocmhvLCByaG8yLCByaG80KSB7XG5cbiAgLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuICAvLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG4gIGZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGksXG4gICAgICAgIFM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhbCBjYXNlLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwICogcmhvIC8gTWF0aC5TUVJUMjtcblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgem9vbS5yaG8gPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIF8xID0gTWF0aC5tYXgoMWUtMywgK18pLCBfMiA9IF8xICogXzEsIF80ID0gXzIgKiBfMjtcbiAgICByZXR1cm4gem9vbVJobyhfMSwgXzIsIF80KTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn0pKE1hdGguU1FSVDIsIDIsIDQpO1xuIiwiLy8gR2l2ZW4gc29tZXRoaW5nIGFycmF5IGxpa2UgKG9yIG51bGwpLCByZXR1cm5zIHNvbWV0aGluZyB0aGF0IGlzIHN0cmljdGx5IGFuXG4vLyBhcnJheS4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGFycmF5LWxpa2Ugb2JqZWN0cyBwYXNzZWQgdG8gZDMuc2VsZWN0QWxsXG4vLyBvciBzZWxlY3Rpb24uc2VsZWN0QWxsIGFyZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgYXJyYXlzIHdoZW4gY3JlYXRpbmcgYVxuLy8gc2VsZWN0aW9uOyB3ZSBkb27igJl0IGV2ZXIgd2FudCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gYmFja2VkIGJ5IGEgbGl2ZVxuLy8gSFRNTENvbGxlY3Rpb24gb3IgTm9kZUxpc3QuIEhvd2V2ZXIsIG5vdGUgdGhhdCBzZWxlY3Rpb24uc2VsZWN0QWxsIHdpbGwgdXNlIGFcbi8vIHN0YXRpYyBOb2RlTGlzdCBhcyBhIGdyb3VwLCBzaW5jZSBpdCBzYWZlbHkgZGVyaXZlZCBmcm9tIHF1ZXJ5U2VsZWN0b3JBbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcnJheSh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyBbXSA6IEFycmF5LmlzQXJyYXkoeCkgPyB4IDogQXJyYXkuZnJvbSh4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0KGNyZWF0b3IobmFtZSkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4vbmFtZXNwYWNlLmpzXCI7XG5pbXBvcnQge3hodG1sfSBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgY3JlYXRlfSBmcm9tIFwiLi9jcmVhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdG9yfSBmcm9tIFwiLi9jcmVhdG9yLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbG9jYWx9IGZyb20gXCIuL2xvY2FsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWF0Y2hlcn0gZnJvbSBcIi4vbWF0Y2hlci5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5hbWVzcGFjZX0gZnJvbSBcIi4vbmFtZXNwYWNlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmFtZXNwYWNlc30gZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBvaW50ZXJ9IGZyb20gXCIuL3BvaW50ZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwb2ludGVyc30gZnJvbSBcIi4vcG9pbnRlcnMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3R9IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdEFsbH0gZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0aW9ufSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3Rvcn0gZnJvbSBcIi4vc2VsZWN0b3IuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RvckFsbH0gZnJvbSBcIi4vc2VsZWN0b3JBbGwuanNcIjtcbmV4cG9ydCB7c3R5bGVWYWx1ZSBhcyBzdHlsZX0gZnJvbSBcIi4vc2VsZWN0aW9uL3N0eWxlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgd2luZG93fSBmcm9tIFwiLi93aW5kb3cuanNcIjtcbiIsInZhciBuZXh0SWQgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb2NhbCgpIHtcbiAgcmV0dXJuIG5ldyBMb2NhbDtcbn1cblxuZnVuY3Rpb24gTG9jYWwoKSB7XG4gIHRoaXMuXyA9IFwiQFwiICsgKCsrbmV4dElkKS50b1N0cmluZygzNik7XG59XG5cbkxvY2FsLnByb3RvdHlwZSA9IGxvY2FsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExvY2FsLFxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG4gICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIG5vZGVbaWRdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZE1hdGNoZXIoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuIiwiaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xufVxuIiwiZXhwb3J0IHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuIiwiaW1wb3J0IHNvdXJjZUV2ZW50IGZyb20gXCIuL3NvdXJjZUV2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG4gIGV2ZW50ID0gc291cmNlRXZlbnQoZXZlbnQpO1xuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSBub2RlID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcbiAgICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gICAgfVxuICAgIGlmIChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiBbZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZXTtcbn1cbiIsImltcG9ydCBwb2ludGVyIGZyb20gXCIuL3BvaW50ZXIuanNcIjtcbmltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudHMsIG5vZGUpIHtcbiAgaWYgKGV2ZW50cy50YXJnZXQpIHsgLy8gaS5lLiwgaW5zdGFuY2VvZiBFdmVudCwgbm90IFRvdWNoTGlzdCBvciBpdGVyYWJsZVxuICAgIGV2ZW50cyA9IHNvdXJjZUV2ZW50KGV2ZW50cyk7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgbm9kZSA9IGV2ZW50cy5jdXJyZW50VGFyZ2V0O1xuICAgIGV2ZW50cyA9IGV2ZW50cy50b3VjaGVzIHx8IFtldmVudHNdO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cywgZXZlbnQgPT4gcG9pbnRlcihldmVudCwgbm9kZSkpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbYXJyYXkoc2VsZWN0b3IpXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi4vbmFtZXNwYWNlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cbiIsImZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUodHJ1ZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7RW50ZXJOb2RlfSBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IG5ldyBNYXAsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApICsgXCJcIjtcbiAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUpKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKSArIFwiXCI7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUpKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZS5kZWxldGUoa2V5VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdHVtKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX19kYXRhX187XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLCBkYXR1bSk7XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gYXJyYXlsaWtlKHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG4vLyBHaXZlbiBzb21lIGRhdGEsIHRoaXMgcmV0dXJucyBhbiBhcnJheS1saWtlIHZpZXcgb2YgaXQ6IGFuIG9iamVjdCB0aGF0XG4vLyBleHBvc2VzIGEgbGVuZ3RoIHByb3BlcnR5IGFuZCBhbGxvd3MgbnVtZXJpYyBpbmRleGluZy4gTm90ZSB0aGF0IHVubGlrZVxuLy8gc2VsZWN0QWxsLCB0aGlzIGlzbuKAmXQgd29ycmllZCBhYm91dCDigJxsaXZl4oCdIGNvbGxlY3Rpb25zIGJlY2F1c2UgdGhlIHJlc3VsdGluZ1xuLy8gYXJyYXkgd2lsbCBvbmx5IGJlIHVzZWQgYnJpZWZseSB3aGlsZSBkYXRhIGlzIGJlaW5nIGJvdW5kLiAoSXQgaXMgcG9zc2libGUgdG9cbi8vIGNhdXNlIHRoZSBkYXRhIHRvIGNoYW5nZSB3aGlsZSBpdGVyYXRpbmcgYnkgdXNpbmcgYSBrZXkgZnVuY3Rpb24sIGJ1dCBwbGVhc2Vcbi8vIGRvbuKAmXQ7IHdl4oCZZCByYXRoZXIgYXZvaWQgYSBncmF0dWl0b3VzIGNvcHkuKVxuZnVuY3Rpb24gYXJyYXlsaWtlKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4gZGF0YVxuICAgID8gZGF0YSAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oZGF0YSk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQgZnJvbSBcIi4vc2VsZWN0Q2hpbGQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4gZnJvbSBcIi4vc2VsZWN0Q2hpbGRyZW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pdGVyYXRvciBmcm9tIFwiLi9pdGVyYXRvci5qc1wiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBqb2luOiBzZWxlY3Rpb25fam9pbixcbiAgbWVyZ2U6IHNlbGVjdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiBzZWxlY3Rpb25fc2VsZWN0aW9uLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX2l0ZXJhdG9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qKCkge1xuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9uZW50ZXIsIG9udXBkYXRlLCBvbmV4aXQpIHtcbiAgdmFyIGVudGVyID0gdGhpcy5lbnRlcigpLCB1cGRhdGUgPSB0aGlzLCBleGl0ID0gdGhpcy5leGl0KCk7XG4gIGlmICh0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZW50ZXIgPSBvbmVudGVyKGVudGVyKTtcbiAgICBpZiAoZW50ZXIpIGVudGVyID0gZW50ZXIuc2VsZWN0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgZW50ZXIgPSBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICB9XG4gIGlmIChvbnVwZGF0ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgICBpZiAodXBkYXRlKSB1cGRhdGUgPSB1cGRhdGUuc2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dDtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gc2VsZWN0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbiIsImZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCB0aGlzLl9fZGF0YV9fKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcih2YWx1ZSk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5vcHRpb25zID0gb3B0aW9ucyk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIG9wdGlvbnM6IG9wdGlvbnN9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5leHQpIF4gNCkgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn1cbiIsImZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IGFycmF5IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yQWxsIGZyb20gXCIuLi9zZWxlY3RvckFsbC5qc1wiO1xuXG5mdW5jdGlvbiBhcnJheUFsbChzZWxlY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcnJheShzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBhcnJheUFsbChzZWxlY3QpO1xuICBlbHNlIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbmQgPSBBcnJheS5wcm90b3R5cGUuZmluZDtcblxuZnVuY3Rpb24gY2hpbGRGaW5kKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmluZC5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRGaXJzdCgpIHtcbiAgcmV0dXJuIHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChtYXRjaCA9PSBudWxsID8gY2hpbGRGaXJzdFxuICAgICAgOiBjaGlsZEZpbmQodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcblxuZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjaGlsZHJlbkZpbHRlcihtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKG1hdGNoID09IG51bGwgPyBjaGlsZHJlblxuICAgICAgOiBjaGlsZHJlbkZpbHRlcih0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpICsrc2l6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGxldCBzb3VyY2VFdmVudDtcbiAgd2hpbGUgKHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQpIGV2ZW50ID0gc291cmNlRXZlbnQ7XG4gIHJldHVybiBldmVudDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJleHBvcnQge1xuICBub3csXG4gIHRpbWVyLFxuICB0aW1lckZsdXNoXG59IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZW91dFxufSBmcm9tIFwiLi90aW1lb3V0LmpzXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgaW50ZXJ2YWxcbn0gZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbiIsImltcG9ydCB7VGltZXIsIG5vd30gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyLCB0b3RhbCA9IGRlbGF5O1xuICBpZiAoZGVsYXkgPT0gbnVsbCkgcmV0dXJuIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpLCB0O1xuICB0Ll9yZXN0YXJ0ID0gdC5yZXN0YXJ0O1xuICB0LnJlc3RhcnQgPSBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBkZWxheSA9ICtkZWxheSwgdGltZSA9IHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWU7XG4gICAgdC5fcmVzdGFydChmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICAgIGVsYXBzZWQgKz0gdG90YWw7XG4gICAgICB0Ll9yZXN0YXJ0KHRpY2ssIHRvdGFsICs9IGRlbGF5LCB0aW1lKTtcbiAgICAgIGNhbGxiYWNrKGVsYXBzZWQpO1xuICAgIH0sIGRlbGF5LCB0aW1lKTtcbiAgfVxuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iLCJpbXBvcnQge1RpbWVyfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XG4gIHQucmVzdGFydChlbGFwc2VkID0+IHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwidmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbCh1bmRlZmluZWQsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtTQ0hFRFVMRUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBpO1xuXG4gIGlmIChzY2hlZHVsZXMpIHtcbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLnN0YXRlID4gU0NIRURVTEVEICYmIHNjaGVkdWxlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKFtbbm9kZV1dLCByb290LCBuYW1lLCAraSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhY3RpdmV9IGZyb20gXCIuL2FjdGl2ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycnVwdH0gZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG4iLCJpbXBvcnQge1NUQVJUSU5HLCBFTkRJTkcsIEVOREVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbXB0eSA9IHRydWUsXG4gICAgICBpO1xuXG4gIGlmICghc2NoZWR1bGVzKSByZXR1cm47XG5cbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcgJiYgc2NoZWR1bGUuc3RhdGUgPCBFTkRJTkc7XG4gICAgc2NoZWR1bGUuc3RhdGUgPSBFTkRFRDtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgc2NoZWR1bGUub24uY2FsbChhY3RpdmUgPyBcImludGVycnVwdFwiIDogXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2NoZWR1bGUuaW5kZXgsIHNjaGVkdWxlLmdyb3VwKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICB9XG5cbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnRlcnJ1cHQgZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuXG5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XG5zZWxlY3Rpb24ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBzZWxlY3Rpb25fdHJhbnNpdGlvbjtcbiIsImltcG9ydCBpbnRlcnJ1cHQgZnJvbSBcIi4uL2ludGVycnVwdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJydXB0KHRoaXMsIG5hbWUpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUgZnJvbSBcIi4uL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7ZWFzZUN1YmljSW5PdXR9IGZyb20gXCJkMy1lYXNlXCI7XG5pbXBvcnQge25vd30gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBkZWZhdWx0VGltaW5nID0ge1xuICB0aW1lOiBudWxsLCAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogZWFzZUN1YmljSW5PdXRcbn07XG5cbmZ1bmN0aW9uIGluaGVyaXQobm9kZSwgaWQpIHtcbiAgdmFyIHRpbWluZztcbiAgd2hpbGUgKCEodGltaW5nID0gbm9kZS5fX3RyYW5zaXRpb24pIHx8ICEodGltaW5nID0gdGltaW5nW2lkXSkpIHtcbiAgICBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2l0aW9uICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGltaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBpZCxcbiAgICAgIHRpbWluZztcblxuICBpZiAobmFtZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICBpZCA9IG5hbWUuX2lkLCBuYW1lID0gbmFtZS5fbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IG5ld0lkKCksICh0aW1pbmcgPSBkZWZhdWx0VGltaW5nKS50aW1lID0gbm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSksIGkgPSBmdWxsbmFtZSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KShmdWxsbmFtZSwgaSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge2dldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZGVsYXlGdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGF5Q29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZGVsYXk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkdXJhdGlvbkZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZHVyYXRpb25GdW5jdGlvblxuICAgICAgICAgIDogZHVyYXRpb25Db25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZHVyYXRpb247XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaChlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlVmFyeWluZyhpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy5lYWNoKGVhc2VWYXJ5aW5nKHRoaXMuX2lkLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgb24wLCBvbjEsIHRoYXQgPSB0aGlzLCBpZCA9IHRoYXQuX2lkLCBzaXplID0gdGhhdC5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgY2FuY2VsID0ge3ZhbHVlOiByZWplY3R9LFxuICAgICAgICBlbmQgPSB7dmFsdWU6IGZ1bmN0aW9uKCkgeyBpZiAoLS1zaXplID09PSAwKSByZXNvbHZlKCk7IH19O1xuXG4gICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgICAgaWYgKG9uICE9PSBvbjApIHtcbiAgICAgICAgb24xID0gKG9uMCA9IG9uKS5jb3B5KCk7XG4gICAgICAgIG9uMS5fLmNhbmNlbC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmludGVycnVwdC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmVuZC5wdXNoKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHNlbGVjdGlvbiB3YXMgZW1wdHksIHJlc29sdmUgZW5kIGltbWVkaWF0ZWx5XG4gICAgaWYgKHNpemUgPT09IDApIHJlc29sdmUoKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge21hdGNoZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHJUd2VlbiBmcm9tIFwiLi9hdHRyVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2RlbGF5IGZyb20gXCIuL2RlbGF5LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZSBmcm9tIFwiLi9lYXNlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlVmFyeWluZyBmcm9tIFwiLi9lYXNlVmFyeWluZy5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3Rpb24gZnJvbSBcIi4vc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGVUd2VlbiBmcm9tIFwiLi9zdHlsZVR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHRUd2VlbiBmcm9tIFwiLi90ZXh0VHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHdlZW4gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2VuZCBmcm9tIFwiLi9lbmQuanNcIjtcblxudmFyIGlkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zaXRpb24oZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCkge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3Rpb24oKS50cmFuc2l0aW9uKG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3SWQoKSB7XG4gIHJldHVybiArK2lkO1xufVxuXG52YXIgc2VsZWN0aW9uX3Byb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGU7XG5cblRyYW5zaXRpb24ucHJvdG90eXBlID0gdHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICBzZWxlY3Q6IHRyYW5zaXRpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHRyYW5zaXRpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogdHJhbnNpdGlvbl9maWx0ZXIsXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHRyYW5zaXRpb25fc2VsZWN0aW9uLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uX3RyYW5zaXRpb24sXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX3Byb3RvdHlwZS5lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX3Byb3RvdHlwZS5lYWNoLFxuICBvbjogdHJhbnNpdGlvbl9vbixcbiAgYXR0cjogdHJhbnNpdGlvbl9hdHRyLFxuICBhdHRyVHdlZW46IHRyYW5zaXRpb25fYXR0clR3ZWVuLFxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcbiAgc3R5bGVUd2VlbjogdHJhbnNpdGlvbl9zdHlsZVR3ZWVuLFxuICB0ZXh0OiB0cmFuc2l0aW9uX3RleHQsXG4gIHRleHRUd2VlbjogdHJhbnNpdGlvbl90ZXh0VHdlZW4sXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXG4gIHR3ZWVuOiB0cmFuc2l0aW9uX3R3ZWVuLFxuICBkZWxheTogdHJhbnNpdGlvbl9kZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXG4gIGVhc2U6IHRyYW5zaXRpb25fZWFzZSxcbiAgZWFzZVZhcnlpbmc6IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcsXG4gIGVuZDogdHJhbnNpdGlvbl9lbmQsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25fcHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl1cbn07XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUmdiLCBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGM7XG4gIHJldHVybiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIgPyBpbnRlcnBvbGF0ZU51bWJlclxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyBpbnRlcnBvbGF0ZVJnYlxuICAgICAgOiAoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gc3RhcnQobmFtZSkge1xuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsIG9uMSwgc2l0ID0gc3RhcnQobmFtZSkgPyBpbml0IDogc2V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2l0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCkgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihuYW1lLCBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyXG4gICAgICA/IGdldCh0aGlzLm5vZGUoKSwgaWQpLm9uLm9uKG5hbWUpXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyLCB0aW1lb3V0fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGVtcHR5T24gPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2FuY2VsXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxuZXhwb3J0IHZhciBDUkVBVEVEID0gMDtcbmV4cG9ydCB2YXIgU0NIRURVTEVEID0gMTtcbmV4cG9ydCB2YXIgU1RBUlRJTkcgPSAyO1xuZXhwb3J0IHZhciBTVEFSVEVEID0gMztcbmV4cG9ydCB2YXIgUlVOTklORyA9IDQ7XG5leHBvcnQgdmFyIEVORElORyA9IDU7XG5leHBvcnQgdmFyIEVOREVEID0gNjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSwgaWQsIGluZGV4LCBncm91cCwgdGltaW5nKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZXMpIG5vZGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKGlkIGluIHNjaGVkdWxlcykgcmV0dXJuO1xuICBjcmVhdGUobm9kZSwgaWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBlbXB0eU9uLFxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxuICAgIHRpbWU6IHRpbWluZy50aW1lLFxuICAgIGRlbGF5OiB0aW1pbmcuZGVsYXksXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcbiAgICBlYXNlOiB0aW1pbmcuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogQ1JFQVRFRFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gQ1JFQVRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgc2NoZWR1bGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gU1RBUlRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgcnVubmluZ1wiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgaWQsIHNlbGYpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgdHdlZW47XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuICBzY2hlZHVsZXNbaWRdID0gc2VsZjtcbiAgc2VsZi50aW1lciA9IHRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcblxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChzZWxmLmRlbGF5IDw9IGVsYXBzZWQpIHN0YXJ0KGVsYXBzZWQgLSBzZWxmLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICB2YXIgaSwgaiwgbiwgbztcblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgbyA9IHNjaGVkdWxlc1tpXTtcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XG5cbiAgICAgIC8vIFdoaWxlIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHN0YXJ0aW5nIHRyYW5zaXRpb24gZHVyaW5nIHRoaXMgZnJhbWUsXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcbiAgICAgIC8vIGNoYW5jZSB0byB0aWNrIChhbmQgcG9zc2libHkgZW5kKTsgc2VlIGQzL2QzLXRyYW5zaXRpb24jNTQhXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIHRpbWVvdXQoc3RhcnQpO1xuXG4gICAgICAvLyBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBhbnkgcHJlLWVtcHRlZCB0cmFuc2l0aW9ucy5cbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXG4gICAgLy8gTm90ZSB0aGUgdHJhbnNpdGlvbiBtYXkgYmUgY2FuY2VsZWQgYWZ0ZXIgc3RhcnQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdGljayFcbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBzY2hlZHVsZWQgYmVmb3JlIHRoZSBzdGFydCBldmVudDsgc2VlIGQzL2QzLXRyYW5zaXRpb24jMTYhXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxuICAgIHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gUlVOTklORztcbiAgICAgICAgc2VsZi50aW1lci5yZXN0YXJ0KHRpY2ssIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG4gICAgICAgIHRpY2soZWxhcHNlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgc3RhcnQgZXZlbnQuXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIHR3ZWVuIGFyZSBpbml0aWFsaXplZC5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0d2VlbiwgZGVsZXRpbmcgbnVsbCB0d2Vlbi5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGogPSAtMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG8gPSBzZWxmLnR3ZWVuW2ldLnZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCkpIHtcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgdmFyIHQgPSBlbGFwc2VkIDwgc2VsZi5kdXJhdGlvbiA/IHNlbGYuZWFzZS5jYWxsKG51bGwsIGVsYXBzZWQgLyBzZWxmLmR1cmF0aW9uKSA6IChzZWxmLnRpbWVyLnJlc3RhcnQoc3RvcCksIHNlbGYuc3RhdGUgPSBFTkRJTkcsIDEpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgdHdlZW5baV0uY2FsbChub2RlLCB0KTtcbiAgICB9XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuICAgIGlmIChzZWxmLnN0YXRlID09PSBFTkRJTkcpIHtcbiAgICAgIHNlbGYub24uY2FsbChcImVuZFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHNlbGYuc3RhdGUgPSBFTkRFRDtcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgICBzY2hlZHVsZShzdWJncm91cFtpXSwgbmFtZSwgaWQsIGksIHN1Ymdyb3VwLCBnZXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yQWxsfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCksIGNoaWxkLCBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkKSwgayA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGsgPCBsOyArK2spIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPSBjaGlsZHJlbltrXSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoY2hpbGQsIG5hbWUsIGlkLCBrLCBjaGlsZHJlbiwgaW5oZXJpdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbnZhciBTZWxlY3Rpb24gPSBzZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzdHlsZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVOdWxsKG5hbWUsIGludGVycG9sYXRlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgc3RyaW5nMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHN0cmluZzEwID0gc3RyaW5nMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgdmFsdWUxID0gdmFsdWUodGhpcyksXG4gICAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgc3RyaW5nMSA9IHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZU1heWJlUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciBvbjAsIG9uMSwgbGlzdGVuZXIwLCBrZXkgPSBcInN0eWxlLlwiICsgbmFtZSwgZXZlbnQgPSBcImVuZC5cIiArIGtleSwgcmVtb3ZlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbixcbiAgICAgICAgbGlzdGVuZXIgPSBzY2hlZHVsZS52YWx1ZVtrZXldID09IG51bGwgPyByZW1vdmUgfHwgKHJlbW92ZSA9IHN0eWxlUmVtb3ZlKG5hbWUpKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCB8fCBsaXN0ZW5lcjAgIT09IGxpc3RlbmVyKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKGV2ZW50LCBsaXN0ZW5lcjAgPSBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBpID0gKG5hbWUgKz0gXCJcIikgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlTnVsbChuYW1lLCBpKSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIHN0eWxlUmVtb3ZlKG5hbWUpKVxuICAgIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUZ1bmN0aW9uKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSkpXG4gICAgICAuZWFjaChzdHlsZU1heWJlUmVtb3ZlKHRoaXMuX2lkLCBuYW1lKSlcbiAgICA6IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUpLCBwcmlvcml0eSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIG51bGwpO1xufVxuIiwiZnVuY3Rpb24gc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaS5jYWxsKHRoaXMsIHQpLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciB0LCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdCA9IChpMCA9IGkpICYmIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIga2V5ID0gXCJzdHlsZS5cIiArIChuYW1lICs9IFwiXCIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpO1xufVxuIiwiaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlMSA9PSBudWxsID8gXCJcIiA6IHZhbHVlMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IHRleHRGdW5jdGlvbih0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufVxuIiwiZnVuY3Rpb24gdGV4dEludGVycG9sYXRlKGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gaS5jYWxsKHRoaXMsIHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0VHdlZW4odmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiB0ZXh0SW50ZXJwb2xhdGUoaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcInRleHRcIjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHRleHRUd2Vlbih2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxuICAgICAgaWQxID0gbmV3SWQoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldChub2RlLCBpZDApO1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZDEsIGksIGdyb3VwLCB7XG4gICAgICAgICAgdGltZTogaW5oZXJpdC50aW1lICsgaW5oZXJpdC5kZWxheSArIGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiB0d2VlblJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gdHdlZW4wID0gdHdlZW47XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xID0gdHdlZW4xLnNsaWNlKCk7XG4gICAgICAgICAgdHdlZW4xLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0d2VlbkZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9ICh0d2VlbjAgPSB0d2Vlbikuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIHQgPSB7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSwgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMVtpXSA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBuKSB0d2VlbjEucHVzaCh0KTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgbmFtZSArPSBcIlwiO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciB0d2VlbiA9IGdldCh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4ubGVuZ3RoLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHQgPSB0d2VlbltpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gdHdlZW5SZW1vdmUgOiB0d2VlbkZ1bmN0aW9uKShpZCwgbmFtZSwgdmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG5cbiAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlLnZhbHVlIHx8IChzY2hlZHVsZS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBnZXQobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9vbUV2ZW50KHR5cGUsIHtcbiAgc291cmNlRXZlbnQsXG4gIHRhcmdldCxcbiAgdHJhbnNmb3JtLFxuICBkaXNwYXRjaFxufSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHlwZToge3ZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHNvdXJjZUV2ZW50OiB7dmFsdWU6IHNvdXJjZUV2ZW50LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRhcmdldDoge3ZhbHVlOiB0YXJnZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdHJhbnNmb3JtOiB7dmFsdWU6IHRyYW5zZm9ybSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBfOiB7dmFsdWU6IGRpc3BhdGNofVxuICB9KTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgem9vbVRyYW5zZm9ybSwgaWRlbnRpdHkgYXMgem9vbUlkZW50aXR5LCBUcmFuc2Zvcm0gYXMgWm9vbVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKGssIHgsIHkpIHtcbiAgdGhpcy5rID0gaztcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuayAqIGssIHRoaXMueCwgdGhpcy55KTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IDAgJiB5ID09PSAwID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB4LCB0aGlzLnkgKyB0aGlzLmsgKiB5KTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludFswXSAqIHRoaXMuayArIHRoaXMueCwgcG9pbnRbMV0gKiB0aGlzLmsgKyB0aGlzLnldO1xuICB9LFxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCAqIHRoaXMuayArIHRoaXMueDtcbiAgfSxcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLmsgKyB0aGlzLnk7XG4gIH0sXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gWyhsb2NhdGlvblswXSAtIHRoaXMueCkgLyB0aGlzLmssIChsb2NhdGlvblsxXSAtIHRoaXMueSkgLyB0aGlzLmtdO1xuICB9LFxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4IC0gdGhpcy54KSAvIHRoaXMuaztcbiAgfSxcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoeSAtIHRoaXMueSkgLyB0aGlzLms7XG4gIH0sXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguY29weSgpLmRvbWFpbih4LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCwgdGhpcykubWFwKHguaW52ZXJ0LCB4KSk7XG4gIH0sXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkuY29weSgpLmRvbWFpbih5LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WSwgdGhpcykubWFwKHkuaW52ZXJ0LCB5KSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtkcmFnRGlzYWJsZSwgZHJhZ0VuYWJsZX0gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVab29tfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c2VsZWN0LCBwb2ludGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2ludGVycnVwdH0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IFpvb21FdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuaW1wb3J0IHtUcmFuc2Zvcm0sIGlkZW50aXR5fSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbi8vIGV4Y2VwdCBmb3IgcGluY2gtdG8tem9vbSwgd2hpY2ggaXMgc2VudCBhcyBhIHdoZWVsK2N0cmxLZXkgZXZlbnRcbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoZXZlbnQpIHtcbiAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBldmVudC50eXBlID09PSAnd2hlZWwnKSAmJiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXh0ZW50KCkge1xuICB2YXIgZSA9IHRoaXM7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIGlmIChlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICAgIGUgPSBlLnZpZXdCb3guYmFzZVZhbDtcbiAgICAgIHJldHVybiBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV07XG4gICAgfVxuICAgIHJldHVybiBbWzAsIDBdLCBbZS53aWR0aC5iYXNlVmFsLnZhbHVlLCBlLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtlLmNsaWVudFdpZHRoLCBlLmNsaWVudEhlaWdodF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKGV2ZW50KSB7XG4gIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogKGV2ZW50LmN0cmxLZXkgPyAxMCA6IDEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29uc3RyYWluKHRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpIHtcbiAgdmFyIGR4MCA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFswXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMF0sXG4gICAgICBkeDEgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMV1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzBdLFxuICAgICAgZHkwID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzBdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVsxXSxcbiAgICAgIGR5MSA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFsxXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMV07XG4gIHJldHVybiB0cmFuc2Zvcm0udHJhbnNsYXRlKFxuICAgIGR4MSA+IGR4MCA/IChkeDAgKyBkeDEpIC8gMiA6IE1hdGgubWluKDAsIGR4MCkgfHwgTWF0aC5tYXgoMCwgZHgxKSxcbiAgICBkeTEgPiBkeTAgPyAoZHkwICsgZHkxKSAvIDIgOiBNYXRoLm1pbigwLCBkeTApIHx8IE1hdGgubWF4KDAsIGR5MSlcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGNvbnN0cmFpbiA9IGRlZmF1bHRDb25zdHJhaW4sXG4gICAgICB3aGVlbERlbHRhID0gZGVmYXVsdFdoZWVsRGVsdGEsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgc2NhbGVFeHRlbnQgPSBbMCwgSW5maW5pdHldLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVpvb20sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSxcbiAgICAgIHRvdWNoc3RhcnRpbmcsXG4gICAgICB0b3VjaGZpcnN0LFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMCxcbiAgICAgIHRhcERpc3RhbmNlID0gMTA7XG5cbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZCwge3Bhc3NpdmU6IGZhbHNlfSlcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vkb3duZWQpXG4gICAgICAgIC5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuem9vbVwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcbiAgICBzZWxlY3Rpb24ucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSk7XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW50ZXJydXB0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgLmV2ZW50KGV2ZW50KVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLnpvb20obnVsbCwgdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0cmFuc2Zvcm0pXG4gICAgICAgICAgLmVuZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHpvb20uc2NhbGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHAsXG4gICAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBudWxsLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbihpZGVudGl0eS50cmFuc2xhdGUocDBbMF0sIHAwWzFdKS5zY2FsZSh0LmspLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IC15LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteVxuICAgICAgKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCBrKSB7XG4gICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgaykpO1xuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xuICAgIHZhciB4ID0gcDBbMF0gLSBwMVswXSAqIHRyYW5zZm9ybS5rLCB5ID0gcDBbMV0gLSBwMVsxXSAqIHRyYW5zZm9ybS5rO1xuICAgIHJldHVybiB4ID09PSB0cmFuc2Zvcm0ueCAmJiB5ID09PSB0cmFuc2Zvcm0ueSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtLmssIHgsIHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB0cmFuc2l0aW9uXG4gICAgICAgIC5vbihcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuZW5kKCk7IH0pXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgICAgICAgIGUgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyksXG4gICAgICAgICAgICAgIHAgPSBwb2ludCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcG9pbnQgPT09IFwiZnVuY3Rpb25cIiA/IHBvaW50LmFwcGx5KHRoYXQsIGFyZ3MpIDogcG9pbnQsXG4gICAgICAgICAgICAgIHcgPSBNYXRoLm1heChlWzFdWzBdIC0gZVswXVswXSwgZVsxXVsxXSAtIGVbMF1bMV0pLFxuICAgICAgICAgICAgICBhID0gdGhhdC5fX3pvb20sXG4gICAgICAgICAgICAgIGIgPSB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhhdCwgYXJncykgOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGkgPSBpbnRlcnBvbGF0ZShhLmludmVydChwKS5jb25jYXQodyAvIGEuayksIGIuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYi5rKSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0ID0gYjsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3Igb24gZW5kLlxuICAgICAgICAgICAgZWxzZSB7IHZhciBsID0gaSh0KSwgayA9IHcgLyBsWzJdOyB0ID0gbmV3IFRyYW5zZm9ybShrLCBwWzBdIC0gbFswXSAqIGssIHBbMV0gLSBsWzFdICogayk7IH1cbiAgICAgICAgICAgIGcuem9vbShudWxsLCB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlc3R1cmUodGhhdCwgYXJncywgY2xlYW4pIHtcbiAgICByZXR1cm4gKCFjbGVhbiAmJiB0aGF0Ll9fem9vbWluZykgfHwgbmV3IEdlc3R1cmUodGhhdCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBHZXN0dXJlKHRoYXQsIGFyZ3MpIHtcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIHRoaXMuc291cmNlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIHRoaXMudGFwcyA9IDA7XG4gIH1cblxuICBHZXN0dXJlLnByb3RvdHlwZSA9IHtcbiAgICBldmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkgdGhpcy5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkge1xuICAgICAgICB0aGlzLnRoYXQuX196b29taW5nID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhcnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uKGtleSwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodGhpcy5tb3VzZSAmJiBrZXkgIT09IFwibW91c2VcIikgdGhpcy5tb3VzZVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy5tb3VzZVswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDAgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gwWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMFswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDEgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gxWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMVswXSk7XG4gICAgICB0aGlzLnRoYXQuX196b29tID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5lbWl0KFwiem9vbVwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRoYXQuX196b29taW5nO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBkID0gc2VsZWN0KHRoaXMudGhhdCkuZGF0dW0oKTtcbiAgICAgIGxpc3RlbmVycy5jYWxsKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLnRoYXQsXG4gICAgICAgIG5ldyBab29tRXZlbnQodHlwZSwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiB0aGlzLnNvdXJjZUV2ZW50LFxuICAgICAgICAgIHRhcmdldDogem9vbSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy50aGF0Ll9fem9vbSxcbiAgICAgICAgICBkaXNwYXRjaDogbGlzdGVuZXJzXG4gICAgICAgIH0pLFxuICAgICAgICBkXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgdC5rICogTWF0aC5wb3coMiwgd2hlZWxEZWx0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCk7XG5cbiAgICAvLyBJZiB0aGUgbW91c2UgaXMgaW4gdGhlIHNhbWUgbG9jYXRpb24gYXMgYmVmb3JlLCByZXVzZSBpdC5cbiAgICAvLyBJZiB0aGVyZSB3ZXJlIHJlY2VudCB3aGVlbCBldmVudHMsIHJlc2V0IHRoZSB3aGVlbCBpZGxlIHRpbWVvdXQuXG4gICAgaWYgKGcud2hlZWwpIHtcbiAgICAgIGlmIChnLm1vdXNlWzBdWzBdICE9PSBwWzBdIHx8IGcubW91c2VbMF1bMV0gIT09IHBbMV0pIHtcbiAgICAgICAgZy5tb3VzZVsxXSA9IHQuaW52ZXJ0KGcubW91c2VbMF0gPSBwKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChnLndoZWVsKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHdoZWVsIGV2ZW50IHdvbuKAmXQgdHJpZ2dlciBhIHRyYW5zZm9ybSBjaGFuZ2UsIGlnbm9yZSBpdC5cbiAgICBlbHNlIGlmICh0LmsgPT09IGspIHJldHVybjtcblxuICAgIC8vIE90aGVyd2lzZSwgY2FwdHVyZSB0aGUgbW91c2UgcG9pbnQgYW5kIGxvY2F0aW9uIGF0IHRoZSBzdGFydC5cbiAgICBlbHNlIHtcbiAgICAgIGcubW91c2UgPSBbcCwgdC5pbnZlcnQocCldO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgdHJ1ZSkuZXZlbnQoZXZlbnQpLFxuICAgICAgICB2ID0gc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLnpvb21cIiwgbW91c2V1cHBlZCwgdHJ1ZSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgeDAgPSBldmVudC5jbGllbnRYLFxuICAgICAgICB5MCA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICBkcmFnRGlzYWJsZShldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBnLm1vdXNlID0gW3AsIHRoaXMuX196b29tLmludmVydChwKV07XG4gICAgaW50ZXJydXB0KHRoaXMpO1xuICAgIGcuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZWQoZXZlbnQpIHtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKCFnLm1vdmVkKSB7XG4gICAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSB4MCwgZHkgPSBldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy5ldmVudChldmVudClcbiAgICAgICAuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXBwZWQoZXZlbnQpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkcmFnRW5hYmxlKGV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBnLmV2ZW50KGV2ZW50KS5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICBwMCA9IHBvaW50ZXIoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50LCB0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmdzKSwgdHJhbnNsYXRlRXh0ZW50KTtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCwgZXZlbnQpO1xuICAgIGVsc2Ugc2VsZWN0KHRoaXMpLmNhbGwoem9vbS50cmFuc2Zvcm0sIHQxLCBwMCwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgc3RhcnRlZCwgaSwgdCwgcDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaGZpcnN0ID0gcFswXSwgdG91Y2hzdGFydGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoc3RhcnRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0LCBwLCBsO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gwWzBdID0gcDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gxWzBdID0gcDtcbiAgICB9XG4gICAgdCA9IGcudGhhdC5fX3pvb207XG4gICAgaWYgKGcudG91Y2gxKSB7XG4gICAgICB2YXIgcDAgPSBnLnRvdWNoMFswXSwgbDAgPSBnLnRvdWNoMFsxXSxcbiAgICAgICAgICBwMSA9IGcudG91Y2gxWzBdLCBsMSA9IGcudG91Y2gxWzFdLFxuICAgICAgICAgIGRwID0gKGRwID0gcDFbMF0gLSBwMFswXSkgKiBkcCArIChkcCA9IHAxWzFdIC0gcDBbMV0pICogZHAsXG4gICAgICAgICAgZGwgPSAoZGwgPSBsMVswXSAtIGwwWzBdKSAqIGRsICsgKGRsID0gbDFbMV0gLSBsMFsxXSkgKiBkbDtcbiAgICAgIHQgPSBzY2FsZSh0LCBNYXRoLnNxcnQoZHAgLyBkbCkpO1xuICAgICAgcCA9IFsocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyXTtcbiAgICAgIGwgPSBbKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGcudG91Y2gwKSBwID0gZy50b3VjaDBbMF0sIGwgPSBnLnRvdWNoMFsxXTtcbiAgICBlbHNlIHJldHVybjtcblxuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQ7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICB9XG4gICAgaWYgKGcudG91Y2gxICYmICFnLnRvdWNoMCkgZy50b3VjaDAgPSBnLnRvdWNoMSwgZGVsZXRlIGcudG91Y2gxO1xuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgZy5lbmQoKTtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgZGJsdGFwLCByZXJvdXRlIHRvIHRoZSAob3B0aW9uYWwpIGRibGNsaWNrLnpvb20gaGFuZGxlci5cbiAgICAgIGlmIChnLnRhcHMgPT09IDIpIHtcbiAgICAgICAgdCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICAgIGlmIChNYXRoLmh5cG90KHRvdWNoZmlyc3RbMF0gLSB0WzBdLCB0b3VjaGZpcnN0WzFdIC0gdFsxXSkgPCB0YXBEaXN0YW5jZSkge1xuICAgICAgICAgIHZhciBwID0gc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgICBpZiAocCkgcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdoZWVsRGVsdGEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgem9vbSkgOiB3aGVlbERlbHRhO1xuICB9O1xuXG4gIHpvb20uZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgem9vbS50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgem9vbSkgOiBleHRlbnQ7XG4gIH07XG5cbiAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZUV4dGVudFswXSA9ICtfWzBdLCBzY2FsZUV4dGVudFsxXSA9ICtfWzFdLCB6b29tKSA6IFtzY2FsZUV4dGVudFswXSwgc2NhbGVFeHRlbnRbMV1dO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25zdHJhaW4gPSBfLCB6b29tKSA6IGNvbnN0cmFpbjtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgem9vbS50YXBEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXBEaXN0YW5jZSA9ICtfLCB6b29tKSA6IHRhcERpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufVxuIiwiLyoqXG4gKiBKU1RTLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0c1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VETHYxLnR4dFxuICogaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VQTHYxLnR4dFxuICogQGxpY2Vuc2VcbiAqL1xuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZSk6ZSgodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmpzdHM9e30pfSh0aGlzLChmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtjbGFzcyBle3N0YXRpYyBlcXVhbHNXaXRoVG9sZXJhbmNlKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnModC1lKTw9bn19Y2xhc3MgbiBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7RXhjZXB0aW9uOm59KVswXX10b1N0cmluZygpe3JldHVybiB0aGlzLm1lc3NhZ2V9fWNsYXNzIHMgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7SWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uOnN9KVswXX19Y2xhc3MgaXtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMubG93PWV8fDAsdGhpcy5oaWdoPXR8fDB9c3RhdGljIHRvQmluYXJ5U3RyaW5nKHQpe2xldCBlLG49XCJcIjtmb3IoZT0yMTQ3NDgzNjQ4O2U+MDtlPj4+PTEpbis9KHQuaGlnaCZlKT09PWU/XCIxXCI6XCIwXCI7Zm9yKGU9MjE0NzQ4MzY0ODtlPjA7ZT4+Pj0xKW4rPSh0LmxvdyZlKT09PWU/XCIxXCI6XCIwXCI7cmV0dXJuIG59fWZ1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gYygpe31yLk5hTj1OYU4sci5pc05hTj10PT5OdW1iZXIuaXNOYU4odCksci5pc0luZmluaXRlPXQ9PiFOdW1iZXIuaXNGaW5pdGUodCksci5NQVhfVkFMVUU9TnVtYmVyLk1BWF9WQUxVRSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBGbG9hdDY0QXJyYXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEludDMyQXJyYXk/ZnVuY3Rpb24oKXtjb25zdCB0PTIxNDY0MzUwNzIsZT1uZXcgRmxvYXQ2NEFycmF5KDEpLG49bmV3IEludDMyQXJyYXkoZS5idWZmZXIpO3IuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbihzKXtlWzBdPXM7bGV0IHI9MHxuWzBdLG89MHxuWzFdO3JldHVybihvJnQpPT09dCYmMCE9KDEwNDg1NzUmbykmJjAhPT1yJiYocj0wLG89MjE0Njk1OTM2MCksbmV3IGkobyxyKX0sci5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKHQpe3JldHVybiBuWzBdPXQubG93LG5bMV09dC5oaWdoLGVbMF19fSgpOmZ1bmN0aW9uKCl7Y29uc3QgdD0xMDIzLGU9TWF0aC5sb2cyLG49TWF0aC5mbG9vcixzPU1hdGgucG93LG89ZnVuY3Rpb24oKXtmb3IobGV0IHQ9NTM7dD4wO3QtLSl7Y29uc3QgaT1zKDIsdCktMTtpZihuKGUoaSkpKzE9PT10KXJldHVybiBpfXJldHVybiAwfSgpO3IuZG91YmxlVG9Mb25nQml0cz1mdW5jdGlvbihyKXtsZXQgbCxhLGMsaCx1LGcsZCxfLHA7aWYocjwwfHwxL3I9PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk/KGc9MTw8MzEscj0tcik6Zz0wLDA9PT1yKXJldHVybiBwPTAsXz1nLG5ldyBpKF8scCk7aWYocj09PTEvMClyZXR1cm4gcD0wLF89MjE0NjQzNTA3MnxnLG5ldyBpKF8scCk7aWYociE9cilyZXR1cm4gcD0wLF89MjE0Njk1OTM2MCxuZXcgaShfLHApO2lmKGg9MCxwPTAsbD1uKHIpLGw+MSlpZihsPD1vKWg9bihlKGwpKSxoPD0yMD8ocD0wLF89bDw8MjAtaCYxMDQ4NTc1KTooYz1oLTIwLGE9cygyLGMpLHA9bCVhPDwzMi1jLF89bC9hJjEwNDg1NzUpO2Vsc2UgZm9yKGM9bCxwPTA7YT1jLzIsYz1uKGEpLDAhPT1jOyloKysscD4+Pj0xLHB8PSgxJl8pPDwzMSxfPj4+PTEsYSE9PWMmJihffD01MjQyODgpO2lmKGQ9aCt0LHU9MD09PWwsbD1yLWwsaDw1MiYmMCE9PWwpZm9yKGM9MDs7KXtpZihhPTIqbCxhPj0xPyhsPWEtMSx1PyhkLS0sdT0hMSk6KGM8PD0xLGN8PTEsaCsrKSk6KGw9YSx1PzA9PS0tZCYmKGgrKyx1PSExKTooYzw8PTEsaCsrKSksMjA9PT1oKV98PWMsYz0wO2Vsc2UgaWYoNTI9PT1oKXtwfD1jO2JyZWFrfWlmKDE9PT1hKXtoPDIwP198PWM8PDIwLWg6aDw1MiYmKHB8PWM8PDUyLWgpO2JyZWFrfX1yZXR1cm4gX3w9ZDw8MjAsX3w9ZyxuZXcgaShfLHApfSxyLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24oZSl7bGV0IG4saSxyLG87Y29uc3QgbD1lLmhpZ2gsYT1lLmxvdyxjPWwmMTw8MzE/LTE6MTtmb3Iocj0oKDIxNDY0MzUwNzImbCk+PjIwKS10LG89MCxpPTE8PDE5LG49MTtuPD0yMDtuKyspbCZpJiYobys9cygyLC1uKSksaT4+Pj0xO2ZvcihpPTE8PDMxLG49MjE7bjw9NTI7bisrKWEmaSYmKG8rPXMoMiwtbikpLGk+Pj49MTtpZigtMTAyMz09PXIpe2lmKDA9PT1vKXJldHVybiAwKmM7cj0tMTAyMn1lbHNle2lmKDEwMjQ9PT1yKXJldHVybiAwPT09bz9jLzA6TmFOO28rPTF9cmV0dXJuIGMqbypzKDIscil9fSgpO2NsYXNzIGggZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7UnVudGltZUV4Y2VwdGlvbjpofSlbMF19fWNsYXNzIHUgZXh0ZW5kcyBoe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx1LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWguY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX19Y2xhc3MgZ3tzdGF0aWMgc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClnLnNob3VsZE5ldmVyUmVhY2hIZXJlKG51bGwpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3Rocm93IG5ldyB1KFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIisobnVsbCE9PXQ/XCI6IFwiK3Q6XCJcIikpfX1zdGF0aWMgaXNUcnVlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2cuaXNUcnVlKHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07aWYoIWFyZ3VtZW50c1swXSl0aHJvdyBudWxsPT09dD9uZXcgdTpuZXcgdSh0KX19c3RhdGljIGVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtnLmVxdWFscyh0LGUsbnVsbCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoIWUuZXF1YWxzKHQpKXRocm93IG5ldyB1KFwiRXhwZWN0ZWQgXCIrdCtcIiBidXQgZW5jb3VudGVyZWQgXCIrZSsobnVsbCE9PW4/XCI6IFwiK246XCJcIikpfX19Y29uc3QgZD1uZXcgQXJyYXlCdWZmZXIoOCksXz1uZXcgRmxvYXQ2NEFycmF5KGQpLHA9bmV3IEludDMyQXJyYXkoZCk7Y2xhc3MgbXtjb25zdHJ1Y3Rvcigpe20uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy56PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpbS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDAsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQueCx0LnksdC5nZXRaKCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbS5OVUxMX09SRElOQVRFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9bn19c3RhdGljIGhhc2hDb2RlKHQpe3JldHVybiBfWzBdPXQscFswXV5wWzFdfWdldE0oKXtyZXR1cm4gci5OYU59c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSBtLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBtLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBtLlo6dGhpcy5zZXRaKGUpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19ZXF1YWxzMkQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4hIWUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLngsdC54LG4pJiYhIWUuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnksdC55LG4pfX1zZXRNKHQpe3Rocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrbS5NKX1nZXRaKCl7cmV0dXJuIHRoaXMuen1nZXRPcmRpbmF0ZSh0KXtzd2l0Y2godCl7Y2FzZSBtLlg6cmV0dXJuIHRoaXMueDtjYXNlIG0uWTpyZXR1cm4gdGhpcy55O2Nhc2UgbS5aOnJldHVybiB0aGlzLmdldFooKX10aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfWVxdWFsczNEKHQpe3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueSYmKHRoaXMuZ2V0WigpPT09dC5nZXRaKCl8fHIuaXNOYU4odGhpcy5nZXRaKCkpJiZyLmlzTmFOKHQuZ2V0WigpKSl9ZXF1YWxzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgbSYmdGhpcy5lcXVhbHMyRCh0KX1lcXVhbEluWih0LG4pe3JldHVybiBlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy5nZXRaKCksdC5nZXRaKCksbil9c2V0WCh0KXt0aGlzLng9dH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLng8ZS54Py0xOnRoaXMueD5lLng/MTp0aGlzLnk8ZS55Py0xOnRoaXMueT5lLnk/MTowfWdldFgoKXtyZXR1cm4gdGhpcy54fXNldFoodCl7dGhpcy56PXR9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhpcyBjbGFzcyBpcyBDbG9uZWFibGVcIiksbnVsbDt0aHJvdyB0fX1jb3B5KCl7cmV0dXJuIG5ldyBtKHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIsIFwiK3RoaXMuZ2V0WigpK1wiKVwifWRpc3RhbmNlM0QodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueSxzPXRoaXMuZ2V0WigpLXQuZ2V0WigpO3JldHVybiBNYXRoLnNxcnQoZSplK24qbitzKnMpfWdldFkoKXtyZXR1cm4gdGhpcy55fXNldFkodCl7dGhpcy55PXR9ZGlzdGFuY2UodCl7Y29uc3QgZT10aGlzLngtdC54LG49dGhpcy55LXQueTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfWhhc2hDb2RlKCl7bGV0IHQ9MTc7cmV0dXJuIHQ9MzcqdCttLmhhc2hDb2RlKHRoaXMueCksdD0zNyp0K20uaGFzaENvZGUodGhpcy55KSx0fXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxsLGNdfX1jbGFzcyBme2NvbnN0cnVjdG9yKCl7Zi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9kaW1lbnNpb25zVG9UZXN0PTIsMD09PWFyZ3VtZW50cy5sZW5ndGgpZi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLDIpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDIhPT10JiYzIT09dCl0aHJvdyBuZXcgcyhcIm9ubHkgMiBvciAzIGRpbWVuc2lvbnMgbWF5IGJlIHNwZWNpZmllZFwiKTt0aGlzLl9kaW1lbnNpb25zVG9UZXN0PXR9fXN0YXRpYyBjb21wYXJlKHQsZSl7cmV0dXJuIHQ8ZT8tMTp0PmU/MTpyLmlzTmFOKHQpP3IuaXNOYU4oZSk/MDotMTpyLmlzTmFOKGUpPzE6MH1jb21wYXJlKHQsZSl7Y29uc3Qgbj1mLmNvbXBhcmUodC54LGUueCk7aWYoMCE9PW4pcmV0dXJuIG47Y29uc3Qgcz1mLmNvbXBhcmUodC55LGUueSk7aWYoMCE9PXMpcmV0dXJuIHM7aWYodGhpcy5fZGltZW5zaW9uc1RvVGVzdDw9MilyZXR1cm4gMDtyZXR1cm4gZi5jb21wYXJlKHQuZ2V0WigpLGUuZ2V0WigpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fW0uRGltZW5zaW9uYWxDb21wYXJhdG9yPWYsbS5OVUxMX09SRElOQVRFPXIuTmFOLG0uWD0wLG0uWT0xLG0uWj0yLG0uTT0zO2NsYXNzIHkgZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx5LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW0uY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB5KXtjb25zdCB0PWFyZ3VtZW50c1swXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxtLk5VTExfT1JESU5BVEUpfX1zZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaCh0KXtjYXNlIHkuWDp0aGlzLng9ZTticmVhaztjYXNlIHkuWTp0aGlzLnk9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fWdldFooKXtyZXR1cm4gbS5OVUxMX09SRElOQVRFfWdldE9yZGluYXRlKHQpe3N3aXRjaCh0KXtjYXNlIHkuWDpyZXR1cm4gdGhpcy54O2Nhc2UgeS5ZOnJldHVybiB0aGlzLnl9dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX1zZXRaKHQpe3Rocm93IG5ldyBzKFwiQ29vcmRpbmF0ZVhZIGRpbWVuc2lvbiAyIGRvZXMgbm90IHN1cHBvcnQgei1vcmRpbmF0ZVwiKX1jb3B5KCl7cmV0dXJuIG5ldyB5KHRoaXMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIpXCJ9c2V0Q29vcmRpbmF0ZSh0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuZ2V0WigpfX15Llg9MCx5Llk9MSx5Llo9LTEseS5NPS0xO2NsYXNzIHggZXh0ZW5kcyBte2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx4LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX209bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCltLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuX209MDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55KSx0aGlzLl9tPXQuX219ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LngsdC55KSx0aGlzLl9tPXRoaXMuZ2V0TSgpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTttLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG0uTlVMTF9PUkRJTkFURSksdGhpcy5fbT1ufX1nZXRNKCl7cmV0dXJuIHRoaXMuX219c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSB4Llg6dGhpcy54PWU7YnJlYWs7Y2FzZSB4Llk6dGhpcy55PWU7YnJlYWs7Y2FzZSB4Lk06dGhpcy5fbT1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19c2V0TSh0KXt0aGlzLl9tPXR9Z2V0Wigpe3JldHVybiBtLk5VTExfT1JESU5BVEV9Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgeC5YOnJldHVybiB0aGlzLng7Y2FzZSB4Llk6cmV0dXJuIHRoaXMueTtjYXNlIHguTTpyZXR1cm4gdGhpcy5fbX10aHJvdyBuZXcgcyhcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfXNldFoodCl7dGhyb3cgbmV3IHMoXCJDb29yZGluYXRlWFkgZGltZW5zaW9uIDIgZG9lcyBub3Qgc3VwcG9ydCB6LW9yZGluYXRlXCIpfWNvcHkoKXtyZXR1cm4gbmV3IHgodGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiBtPVwiK3RoaXMuZ2V0TSgpK1wiKVwifXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKSx0aGlzLl9tPXQuZ2V0TSgpfX14Llg9MCx4Llk9MSx4Llo9LTEseC5NPTI7Y2xhc3MgRSBleHRlbmRzIG17Y29uc3RydWN0b3IoKXtzdXBlcigpLEUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKW0uY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5fbT0wO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuX209dC5fbX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuX209dGhpcy5nZXRNKCl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO20uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbiksdGhpcy5fbT1zfX1nZXRNKCl7cmV0dXJuIHRoaXMuX219c2V0T3JkaW5hdGUodCxlKXtzd2l0Y2godCl7Y2FzZSBtLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBtLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBtLlo6dGhpcy56PWU7YnJlYWs7Y2FzZSBtLk06dGhpcy5fbT1lO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHMoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX19c2V0TSh0KXt0aGlzLl9tPXR9Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgbS5YOnJldHVybiB0aGlzLng7Y2FzZSBtLlk6cmV0dXJuIHRoaXMueTtjYXNlIG0uWjpyZXR1cm4gdGhpcy5nZXRaKCk7Y2FzZSBtLk06cmV0dXJuIHRoaXMuZ2V0TSgpfXRocm93IG5ldyBzKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9Y29weSgpe3JldHVybiBuZXcgRSh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLmdldFooKStcIiBtPVwiK3RoaXMuZ2V0TSgpK1wiKVwifXNldENvb3JkaW5hdGUodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LmdldFooKSx0aGlzLl9tPXQuZ2V0TSgpfX1mdW5jdGlvbiBJKHQsZSl7cmV0dXJuIHQuaW50ZXJmYWNlc18mJnQuaW50ZXJmYWNlc18uaW5kZXhPZihlKT4tMX1jbGFzcyBOe2FkZCgpe31hZGRBbGwoKXt9aXNFbXB0eSgpe31pdGVyYXRvcigpe31zaXplKCl7fXRvQXJyYXkoKXt9cmVtb3ZlKCl7fX1jbGFzcyBTIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLm5hbWU9T2JqZWN0LmtleXMoe0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb246U30pWzBdfX1jbGFzcyB3IGV4dGVuZHMgTntnZXQoKXt9c2V0KCl7fWlzRW1wdHkoKXt9fWNsYXNzIEMgZXh0ZW5kcyBue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7Tm9TdWNoRWxlbWVudEV4Y2VwdGlvbjpDfSlbMF19fWNsYXNzIEwgZXh0ZW5kcyB3e2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5hcnJheT1bXSx0IGluc3RhbmNlb2YgTiYmdGhpcy5hZGRBbGwodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3csTl19ZW5zdXJlQ2FwYWNpdHkoKXt9YWRkKHQpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLmFycmF5LnB1c2godCk6dGhpcy5hcnJheS5zcGxpY2UoYXJndW1lbnRzWzBdLDAsYXJndW1lbnRzWzFdKSwhMH1jbGVhcigpe3RoaXMuYXJyYXk9W119YWRkQWxsKHQpe2Zvcihjb25zdCBlIG9mIHQpdGhpcy5hcnJheS5wdXNoKGUpfXNldCh0LGUpe2NvbnN0IG49dGhpcy5hcnJheVt0XTtyZXR1cm4gdGhpcy5hcnJheVt0XT1lLG59aXRlcmF0b3IoKXtyZXR1cm4gbmV3IFQodGhpcyl9Z2V0KHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IFM7cmV0dXJuIHRoaXMuYXJyYXlbdF19aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9c29ydCh0KXt0P3RoaXMuYXJyYXkuc29ydCgoKGUsbik9PnQuY29tcGFyZShlLG4pKSk6dGhpcy5hcnJheS5zb3J0KCl9c2l6ZSgpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aH10b0FycmF5KCl7cmV0dXJuIHRoaXMuYXJyYXkuc2xpY2UoKX1yZW1vdmUodCl7Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Lmxlbmd0aDtlPG47ZSsrKWlmKHRoaXMuYXJyYXlbZV09PT10KXJldHVybiEhdGhpcy5hcnJheS5zcGxpY2UoZSwxKTtyZXR1cm4hMX1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLmFycmF5LnZhbHVlcygpfX1jbGFzcyBUe2NvbnN0cnVjdG9yKHQpe3RoaXMuYXJyYXlMaXN0PXQsdGhpcy5wb3NpdGlvbj0wfW5leHQoKXtpZih0aGlzLnBvc2l0aW9uPT09dGhpcy5hcnJheUxpc3Quc2l6ZSgpKXRocm93IG5ldyBDO3JldHVybiB0aGlzLmFycmF5TGlzdC5nZXQodGhpcy5wb3NpdGlvbisrKX1oYXNOZXh0KCl7cmV0dXJuIHRoaXMucG9zaXRpb248dGhpcy5hcnJheUxpc3Quc2l6ZSgpfXNldCh0KXtyZXR1cm4gdGhpcy5hcnJheUxpc3Quc2V0KHRoaXMucG9zaXRpb24tMSx0KX1yZW1vdmUoKXt0aGlzLmFycmF5TGlzdC5yZW1vdmUodGhpcy5hcnJheUxpc3QuZ2V0KHRoaXMucG9zaXRpb24pKX19Y2xhc3MgUiBleHRlbmRzIEx7Y29uc3RydWN0b3IoKXtzdXBlcigpLFIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsZSl9fWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuZ2V0KHQpfWFkZEFsbCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2xldCBlPSExO2ZvcihsZXQgbj1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtuLmhhc05leHQoKTspdGhpcy5hZGQobi5uZXh0KCksdCksZT0hMDtyZXR1cm4gZX1yZXR1cm4gc3VwZXIuYWRkQWxsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbG9uZSgpe2NvbnN0IHQ9c3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuc2l6ZSgpO2UrKyl0LmFkZChlLHRoaXMuZ2V0KGUpLmNsb25lKCkpO3JldHVybiB0fXRvQ29vcmRpbmF0ZUFycmF5KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMudG9BcnJheShSLmNvb3JkQXJyYXlUeXBlKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdKXJldHVybiB0aGlzLnRvQXJyYXkoUi5jb29yZEFycmF5VHlwZSk7Y29uc3QgdD10aGlzLnNpemUoKSxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dDtuKyspZVtuXT10aGlzLmdldCh0LW4tMSk7cmV0dXJuIGV9fWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3VwZXIuYWRkLmNhbGwodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZCh0LGUsITApLCEwfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCFhcmd1bWVudHNbMV0mJnRoaXMuc2l6ZSgpPj0xKXtpZih0aGlzLmdldCh0aGlzLnNpemUoKS0xKS5lcXVhbHMyRCh0KSlyZXR1cm4gbnVsbH1zdXBlci5hZGQuY2FsbCh0aGlzLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQodCxlKSwhMH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihhcmd1bWVudHNbMl0pZm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpcy5hZGQodFtuXSxlKTtlbHNlIGZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKXRoaXMuYWRkKHRbbl0sZSk7cmV0dXJuITB9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighYXJndW1lbnRzWzJdKXtjb25zdCBuPXRoaXMuc2l6ZSgpO2lmKG4+MCl7aWYodD4wKXtpZih0aGlzLmdldCh0LTEpLmVxdWFsczJEKGUpKXJldHVybiBudWxsfWlmKHQ8bil7aWYodGhpcy5nZXQodCkuZXF1YWxzMkQoZSkpcmV0dXJuIG51bGx9fX1zdXBlci5hZGQuY2FsbCh0aGlzLHQsZSl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2xldCBpPTE7bj5zJiYoaT0tMSk7Zm9yKGxldCByPW47ciE9PXM7cis9aSl0aGlzLmFkZCh0W3JdLGUpO3JldHVybiEwfX1jbG9zZVJpbmcoKXtpZih0aGlzLnNpemUoKT4wKXtjb25zdCB0PXRoaXMuZ2V0KDApLmNvcHkoKTt0aGlzLmFkZCh0LCExKX19fVIuY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCk7Y2xhc3MgUHtmaWx0ZXIodCxlKXt9aXNEb25lKCl7fWlzR2VvbWV0cnlDaGFuZ2VkKCl7fX1jbGFzcyBPe2NvbnN0cnVjdG9yKCl7Ty5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9taW54PW51bGwsdGhpcy5fbWF4eD1udWxsLHRoaXMuX21pbnk9bnVsbCx0aGlzLl9tYXh5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodC54LGUueCx0LnksZS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLmluaXQodCxlLG4scyl9fXN0YXRpYyBpbnRlcnNlY3RzKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuLng+PSh0Lng8ZS54P3QueDplLngpJiZuLng8PSh0Lng+ZS54P3QueDplLngpJiZuLnk+PSh0Lnk8ZS55P3QueTplLnkpJiZuLnk8PSh0Lnk+ZS55P3QueTplLnkpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtsZXQgaT1NYXRoLm1pbihuLngscy54KSxyPU1hdGgubWF4KG4ueCxzLngpLG89TWF0aC5taW4odC54LGUueCksbD1NYXRoLm1heCh0LngsZS54KTtyZXR1cm4hKG8+cikmJighKGw8aSkmJihpPU1hdGgubWluKG4ueSxzLnkpLHI9TWF0aC5tYXgobi55LHMueSksbz1NYXRoLm1pbih0LnksZS55KSxsPU1hdGgubWF4KHQueSxlLnkpLCEobz5yKSYmIShsPGkpKSl9fWdldEFyZWEoKXtyZXR1cm4gdGhpcy5nZXRXaWR0aCgpKnRoaXMuZ2V0SGVpZ2h0KCl9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIE8pKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpOnRoaXMuX21heHg9PT1lLmdldE1heFgoKSYmdGhpcy5fbWF4eT09PWUuZ2V0TWF4WSgpJiZ0aGlzLl9taW54PT09ZS5nZXRNaW5YKCkmJnRoaXMuX21pbnk9PT1lLmdldE1pblkoKX1pbnRlcnNlY3Rpb24odCl7aWYodGhpcy5pc051bGwoKXx8dC5pc051bGwoKXx8IXRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gbmV3IE87Y29uc3QgZT10aGlzLl9taW54PnQuX21pbng/dGhpcy5fbWlueDp0Ll9taW54LG49dGhpcy5fbWlueT50Ll9taW55P3RoaXMuX21pbnk6dC5fbWlueSxzPXRoaXMuX21heHg8dC5fbWF4eD90aGlzLl9tYXh4OnQuX21heHgsaT10aGlzLl9tYXh5PHQuX21heHk/dGhpcy5fbWF4eTp0Ll9tYXh5O3JldHVybiBuZXcgTyhlLHMsbixpKX1pc051bGwoKXtyZXR1cm4gdGhpcy5fbWF4eDx0aGlzLl9taW54fWdldE1heFgoKXtyZXR1cm4gdGhpcy5fbWF4eH1jb3ZlcnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModC54LHQueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkmJih0LmdldE1pblgoKT49dGhpcy5fbWlueCYmdC5nZXRNYXhYKCk8PXRoaXMuX21heHgmJnQuZ2V0TWluWSgpPj10aGlzLl9taW55JiZ0LmdldE1heFkoKTw9dGhpcy5fbWF4eSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYodD49dGhpcy5fbWlueCYmdDw9dGhpcy5fbWF4eCYmZT49dGhpcy5fbWlueSYmZTw9dGhpcy5fbWF4eSl9fWludGVyc2VjdHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkmJiEodC5fbWlueD50aGlzLl9tYXh4fHx0Ll9tYXh4PHRoaXMuX21pbnh8fHQuX21pbnk+dGhpcy5fbWF4eXx8dC5fbWF4eTx0aGlzLl9taW55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmludGVyc2VjdHModC54LHQueSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmlzTnVsbCgpKXJldHVybiExO2lmKCh0Lng8ZS54P3QueDplLngpPnRoaXMuX21heHgpcmV0dXJuITE7aWYoKHQueD5lLng/dC54OmUueCk8dGhpcy5fbWlueClyZXR1cm4hMTtpZigodC55PGUueT90Lnk6ZS55KT50aGlzLl9tYXh5KXJldHVybiExO3JldHVybiEoKHQueT5lLnk/dC55OmUueSk8dGhpcy5fbWlueSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiEodD50aGlzLl9tYXh4fHx0PHRoaXMuX21pbnh8fGU+dGhpcy5fbWF4eXx8ZTx0aGlzLl9taW55KX19fWdldE1pblkoKXtyZXR1cm4gdGhpcy5fbWlueX1nZXREaWFtZXRlcigpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiBNYXRoLnNxcnQodCp0K2UqZSl9Z2V0TWluWCgpe3JldHVybiB0aGlzLl9taW54fWV4cGFuZFRvSW5jbHVkZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kVG9JbmNsdWRlKHQueCx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaXNOdWxsKCk/KHRoaXMuX21pbng9dC5nZXRNaW5YKCksdGhpcy5fbWF4eD10LmdldE1heFgoKSx0aGlzLl9taW55PXQuZ2V0TWluWSgpLHRoaXMuX21heHk9dC5nZXRNYXhZKCkpOih0Ll9taW54PHRoaXMuX21pbngmJih0aGlzLl9taW54PXQuX21pbngpLHQuX21heHg+dGhpcy5fbWF4eCYmKHRoaXMuX21heHg9dC5fbWF4eCksdC5fbWlueTx0aGlzLl9taW55JiYodGhpcy5fbWlueT10Ll9taW55KSx0Ll9tYXh5PnRoaXMuX21heHkmJih0aGlzLl9tYXh5PXQuX21heHkpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pc051bGwoKT8odGhpcy5fbWlueD10LHRoaXMuX21heHg9dCx0aGlzLl9taW55PWUsdGhpcy5fbWF4eT1lKToodDx0aGlzLl9taW54JiYodGhpcy5fbWlueD10KSx0PnRoaXMuX21heHgmJih0aGlzLl9tYXh4PXQpLGU8dGhpcy5fbWlueSYmKHRoaXMuX21pbnk9ZSksZT50aGlzLl9tYXh5JiYodGhpcy5fbWF4eT1lKSl9fW1pbkV4dGVudCgpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiB0PGU/dDplfWdldFdpZHRoKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLl9tYXh4LXRoaXMuX21pbnh9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpPzA6LTE6ZS5pc051bGwoKT8xOnRoaXMuX21pbng8ZS5fbWlueD8tMTp0aGlzLl9taW54PmUuX21pbng/MTp0aGlzLl9taW55PGUuX21pbnk/LTE6dGhpcy5fbWlueT5lLl9taW55PzE6dGhpcy5fbWF4eDxlLl9tYXh4Py0xOnRoaXMuX21heHg+ZS5fbWF4eD8xOnRoaXMuX21heHk8ZS5fbWF4eT8tMTp0aGlzLl9tYXh5PmUuX21heHk/MTowfXRyYW5zbGF0ZSh0LGUpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5pbml0KHRoaXMuZ2V0TWluWCgpK3QsdGhpcy5nZXRNYXhYKCkrdCx0aGlzLmdldE1pblkoKStlLHRoaXMuZ2V0TWF4WSgpK2UpfWNvcHkoKXtyZXR1cm4gbmV3IE8odGhpcyl9dG9TdHJpbmcoKXtyZXR1cm5cIkVudltcIit0aGlzLl9taW54K1wiIDogXCIrdGhpcy5fbWF4eCtcIiwgXCIrdGhpcy5fbWlueStcIiA6IFwiK3RoaXMuX21heHkrXCJdXCJ9c2V0VG9OdWxsKCl7dGhpcy5fbWlueD0wLHRoaXMuX21heHg9LTEsdGhpcy5fbWlueT0wLHRoaXMuX21heHk9LTF9ZGlzam9pbnQodCl7cmV0dXJuISghdGhpcy5pc051bGwoKSYmIXQuaXNOdWxsKCkpfHwodC5fbWlueD50aGlzLl9tYXh4fHx0Ll9tYXh4PHRoaXMuX21pbnh8fHQuX21pbnk+dGhpcy5fbWF4eXx8dC5fbWF4eTx0aGlzLl9taW55KX1nZXRIZWlnaHQoKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMuX21heHktdGhpcy5fbWlueX1tYXhFeHRlbnQoKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO2NvbnN0IHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdD5lP3Q6ZX1leHBhbmRCeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZEJ5KHQsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLl9taW54LT10LHRoaXMuX21heHgrPXQsdGhpcy5fbWlueS09ZSx0aGlzLl9tYXh5Kz1lLCh0aGlzLl9taW54PnRoaXMuX21heHh8fHRoaXMuX21pbnk+dGhpcy5fbWF4eSkmJnRoaXMuc2V0VG9OdWxsKCl9fWNvbnRhaW5zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb3ZlcnModCxlKX19Y2VudHJlKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/bnVsbDpuZXcgbSgodGhpcy5nZXRNaW5YKCkrdGhpcy5nZXRNYXhYKCkpLzIsKHRoaXMuZ2V0TWluWSgpK3RoaXMuZ2V0TWF4WSgpKS8yKX1pbml0KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb051bGwoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9taW54PXQuX21pbngsdGhpcy5fbWF4eD10Ll9tYXh4LHRoaXMuX21pbnk9dC5fbWlueSx0aGlzLl9tYXh5PXQuX21heHl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LngsZS54LHQueSxlLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3Q8ZT8odGhpcy5fbWlueD10LHRoaXMuX21heHg9ZSk6KHRoaXMuX21pbng9ZSx0aGlzLl9tYXh4PXQpLG48cz8odGhpcy5fbWlueT1uLHRoaXMuX21heHk9cyk6KHRoaXMuX21pbnk9cyx0aGlzLl9tYXh5PW4pfX1nZXRNYXhZKCl7cmV0dXJuIHRoaXMuX21heHl9ZGlzdGFuY2UodCl7aWYodGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiAwO2xldCBlPTA7dGhpcy5fbWF4eDx0Ll9taW54P2U9dC5fbWlueC10aGlzLl9tYXh4OnRoaXMuX21pbng+dC5fbWF4eCYmKGU9dGhpcy5fbWlueC10Ll9tYXh4KTtsZXQgbj0wO3JldHVybiB0aGlzLl9tYXh5PHQuX21pbnk/bj10Ll9taW55LXRoaXMuX21heHk6dGhpcy5fbWlueT50Ll9tYXh5JiYobj10aGlzLl9taW55LXQuX21heHkpLDA9PT1lP246MD09PW4/ZTpNYXRoLnNxcnQoZSplK24qbil9aGFzaENvZGUoKXtsZXQgdD0xNztyZXR1cm4gdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWlueCksdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWF4eCksdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWlueSksdD0zNyp0K20uaGFzaENvZGUodGhpcy5fbWF4eSksdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxjXX19Y2xhc3Mgdntjb25zdHJ1Y3Rvcih0KXt0aGlzLnN0cj10fWFwcGVuZCh0KXt0aGlzLnN0cis9dH1zZXRDaGFyQXQodCxlKXt0aGlzLnN0cj10aGlzLnN0ci5zdWJzdHIoMCx0KStlK3RoaXMuc3RyLnN1YnN0cih0KzEpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc3RyfX1jbGFzcyBNe2NvbnN0cnVjdG9yKHQpe3RoaXMudmFsdWU9dH1pbnRWYWx1ZSgpe3JldHVybiB0aGlzLnZhbHVlfWNvbXBhcmVUbyh0KXtyZXR1cm4gdGhpcy52YWx1ZTx0Py0xOnRoaXMudmFsdWU+dD8xOjB9c3RhdGljIGNvbXBhcmUodCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9c3RhdGljIGlzTmFuKHQpe3JldHVybiBOdW1iZXIuaXNOYU4odCl9c3RhdGljIHZhbHVlT2YodCl7cmV0dXJuIG5ldyBNKHQpfX1jbGFzcyBie3N0YXRpYyBpc1doaXRlc3BhY2UodCl7cmV0dXJuIHQ8PTMyJiZ0Pj0wfHwxMjc9PT10fXN0YXRpYyB0b1VwcGVyQ2FzZSh0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfX1jbGFzcyBEe2NvbnN0cnVjdG9yKCl7RC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9oaT0wLHRoaXMuX2xvPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07RC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLEQucGFyc2UodCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodCxlKX19c3RhdGljIGRldGVybWluYW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1szXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIEQuZGV0ZXJtaW5hbnQoRC52YWx1ZU9mKHQpLEQudmFsdWVPZihlKSxELnZhbHVlT2YobiksRC52YWx1ZU9mKHMpKX1pZihhcmd1bWVudHNbM11pbnN0YW5jZW9mIEQmJmFyZ3VtZW50c1syXWluc3RhbmNlb2YgRCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdO3JldHVybiBhcmd1bWVudHNbMF0ubXVsdGlwbHkobikuc2VsZlN1YnRyYWN0KHQubXVsdGlwbHkoZSkpfX1zdGF0aWMgc3FyKHQpe3JldHVybiBELnZhbHVlT2YodCkuc2VsZk11bHRpcGx5KHQpfXN0YXRpYyB2YWx1ZU9mKCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEQucGFyc2UodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7cmV0dXJuIG5ldyBEKGFyZ3VtZW50c1swXSl9fXN0YXRpYyBzcXJ0KHQpe3JldHVybiBELnZhbHVlT2YodCkuc3FydCgpfXN0YXRpYyBwYXJzZSh0KXtsZXQgZT0wO2NvbnN0IG49dC5sZW5ndGg7Zm9yKDtiLmlzV2hpdGVzcGFjZSh0LmNoYXJBdChlKSk7KWUrKztsZXQgcz0hMTtpZihlPG4pe2NvbnN0IG49dC5jaGFyQXQoZSk7XCItXCIhPT1uJiZcIitcIiE9PW58fChlKyssXCItXCI9PT1uJiYocz0hMCkpfWNvbnN0IGk9bmV3IEQ7bGV0IHI9MCxvPTAsbD0wLGE9ITE7Zm9yKDshKGU+PW4pOyl7Y29uc3Qgbj10LmNoYXJBdChlKTtpZihlKyssYi5pc0RpZ2l0KG4pKXtjb25zdCB0PW4tXCIwXCI7aS5zZWxmTXVsdGlwbHkoRC5URU4pLGkuc2VsZkFkZCh0KSxyKyt9ZWxzZXtpZihcIi5cIiE9PW4pe2lmKFwiZVwiPT09bnx8XCJFXCI9PT1uKXtjb25zdCBuPXQuc3Vic3RyaW5nKGUpO3RyeXtsPU0ucGFyc2VJbnQobil9Y2F0Y2goZSl7dGhyb3cgZSBpbnN0YW5jZW9mIE51bWJlckZvcm1hdEV4Y2VwdGlvbj9uZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiSW52YWxpZCBleHBvbmVudCBcIituK1wiIGluIHN0cmluZyBcIit0KTplfWJyZWFrfXRocm93IG5ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIrbitcIicgYXQgcG9zaXRpb24gXCIrZStcIiBpbiBzdHJpbmcgXCIrdCl9bz1yLGE9ITB9fWxldCBjPWk7YXx8KG89cik7Y29uc3QgaD1yLW8tbDtpZigwPT09aCljPWk7ZWxzZSBpZihoPjApe2NvbnN0IHQ9RC5URU4ucG93KGgpO2M9aS5kaXZpZGUodCl9ZWxzZSBpZihoPDApe2NvbnN0IHQ9RC5URU4ucG93KC1oKTtjPWkubXVsdGlwbHkodCl9cmV0dXJuIHM/Yy5uZWdhdGUoKTpjfXN0YXRpYyBjcmVhdGVOYU4oKXtyZXR1cm4gbmV3IEQoci5OYU4sci5OYU4pfXN0YXRpYyBjb3B5KHQpe3JldHVybiBuZXcgRCh0KX1zdGF0aWMgbWFnbml0dWRlKHQpe2NvbnN0IGU9TWF0aC5hYnModCksbj1NYXRoLmxvZyhlKS9NYXRoLmxvZygxMCk7bGV0IHM9TWF0aC50cnVuYyhNYXRoLmZsb29yKG4pKTtyZXR1cm4gMTAqTWF0aC5wb3coMTAscyk8PWUmJihzKz0xKSxzfXN0YXRpYyBzdHJpbmdPZkNoYXIodCxlKXtjb25zdCBuPW5ldyB2O2ZvcihsZXQgcz0wO3M8ZTtzKyspbi5hcHBlbmQodCk7cmV0dXJuIG4udG9TdHJpbmcoKX1sZSh0KXtyZXR1cm4gdGhpcy5faGk8dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPD10Ll9sb31leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModCxlKXtsZXQgbj10aGlzLmFicygpLHM9RC5tYWduaXR1ZGUobi5faGkpO2NvbnN0IGk9RC5URU4ucG93KHMpO249bi5kaXZpZGUoaSksbi5ndChELlRFTik/KG49bi5kaXZpZGUoRC5URU4pLHMrPTEpOm4ubHQoRC5PTkUpJiYobj1uLm11bHRpcGx5KEQuVEVOKSxzLT0xKTtjb25zdCByPXMrMSxvPW5ldyB2LGw9RC5NQVhfUFJJTlRfRElHSVRTLTE7Zm9yKGxldCBlPTA7ZTw9bDtlKyspe3QmJmU9PT1yJiZvLmFwcGVuZChcIi5cIik7Y29uc3Qgcz1NYXRoLnRydW5jKG4uX2hpKTtpZihzPDApYnJlYWs7bGV0IGk9ITEsYT0wO3M+OT8oaT0hMCxhPVwiOVwiKTphPVwiMFwiK3Msby5hcHBlbmQoYSksbj1uLnN1YnRyYWN0KEQudmFsdWVPZihzKSkubXVsdGlwbHkoRC5URU4pLGkmJm4uc2VsZkFkZChELlRFTik7bGV0IGM9ITA7Y29uc3QgaD1ELm1hZ25pdHVkZShuLl9oaSk7aWYoaDwwJiZNYXRoLmFicyhoKT49bC1lJiYoYz0hMSksIWMpYnJlYWt9cmV0dXJuIGVbMF09cyxvLnRvU3RyaW5nKCl9c3FyKCl7cmV0dXJuIHRoaXMubXVsdGlwbHkodGhpcyl9ZG91YmxlVmFsdWUoKXtyZXR1cm4gdGhpcy5faGkrdGhpcy5fbG99c3VidHJhY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCh0Lm5lZ2F0ZSgpKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQoLXQpfX1lcXVhbHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG89PT10Ll9sb319aXNaZXJvKCl7cmV0dXJuIDA9PT10aGlzLl9oaSYmMD09PXRoaXMuX2xvfXNlbGZTdWJ0cmFjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtdC5faGksLXQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10LDApfX1nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCl7cmV0dXJuIHRoaXMuaXNaZXJvKCk/XCIwLjBcIjp0aGlzLmlzTmFOKCk/XCJOYU4gXCI6bnVsbH1taW4odCl7cmV0dXJuIHRoaXMubGUodCk/dGhpczp0fXNlbGZEaXZpZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHQsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGwsYz1udWxsO3JldHVybiBvPXRoaXMuX2hpL3QsbD1ELlNQTElUKm8sbj1sLW8sYz1ELlNQTElUKnQsbj1sLW4scz1vLW4saT1jLXQsYT1vKnQsaT1jLWkscj10LWksYz1uKmktYStuKnIrcyppK3MqcixsPSh0aGlzLl9oaS1hLWMrdGhpcy5fbG8tbyplKS90LGM9bytsLHRoaXMuX2hpPWMsdGhpcy5fbG89by1jK2wsdGhpc319ZHVtcCgpe3JldHVyblwiREQ8XCIrdGhpcy5faGkrXCIsIFwiK3RoaXMuX2xvK1wiPlwifWRpdmlkZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbCxhPW51bGw7cj10aGlzLl9oaS90Ll9oaSxvPUQuU1BMSVQqcixlPW8tcixhPUQuU1BMSVQqdC5faGksZT1vLWUsbj1yLWUscz1hLXQuX2hpLGw9cip0Ll9oaSxzPWEtcyxpPXQuX2hpLXMsYT1lKnMtbCtlKmkrbipzK24qaSxvPSh0aGlzLl9oaS1sLWErdGhpcy5fbG8tcip0Ll9sbykvdC5faGksYT1yK287cmV0dXJuIG5ldyBEKGEsci1hK28pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKHQpP0QuY3JlYXRlTmFOKCk6RC5jb3B5KHRoaXMpLnNlbGZEaXZpZGUodCwwKX19Z2UodCl7cmV0dXJuIHRoaXMuX2hpPnQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz49dC5fbG99cG93KHQpe2lmKDA9PT10KXJldHVybiBELnZhbHVlT2YoMSk7bGV0IGU9bmV3IEQodGhpcyksbj1ELnZhbHVlT2YoMSkscz1NYXRoLmFicyh0KTtpZihzPjEpZm9yKDtzPjA7KXMlMj09MSYmbi5zZWxmTXVsdGlwbHkoZSkscy89MixzPjAmJihlPWUuc3FyKCkpO2Vsc2Ugbj1lO3JldHVybiB0PDA/bi5yZWNpcHJvY2FsKCk6bn1jZWlsKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBELk5hTjtjb25zdCB0PU1hdGguY2VpbCh0aGlzLl9oaSk7bGV0IGU9MDtyZXR1cm4gdD09PXRoaXMuX2hpJiYoZT1NYXRoLmNlaWwodGhpcy5fbG8pKSxuZXcgRCh0LGUpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX2hpPGUuX2hpPy0xOnRoaXMuX2hpPmUuX2hpPzE6dGhpcy5fbG88ZS5fbG8/LTE6dGhpcy5fbG8+ZS5fbG8/MTowfXJpbnQoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIHRoaXM7cmV0dXJuIHRoaXMuYWRkKC41KS5mbG9vcigpfXNldFZhbHVlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KHQpLHRoaXN9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfX1tYXgodCl7cmV0dXJuIHRoaXMuZ2UodCk/dGhpczp0fXNxcnQoKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBELnZhbHVlT2YoMCk7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIEQuTmFOO2NvbnN0IHQ9MS9NYXRoLnNxcnQodGhpcy5faGkpLGU9dGhpcy5faGkqdCxuPUQudmFsdWVPZihlKSxzPXRoaXMuc3VidHJhY3Qobi5zcXIoKSkuX2hpKiguNSp0KTtyZXR1cm4gbi5hZGQocyl9c2VsZkFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZBZGQodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbDtyZXR1cm4gcz10aGlzLl9oaSt0LHI9cy10aGlzLl9oaSxpPXMtcixpPXQtcisodGhpcy5faGktaSksbz1pK3RoaXMuX2xvLGU9cytvLG49bysocy1lKSx0aGlzLl9oaT1lK24sdGhpcy5fbG89bisoZS10aGlzLl9oaSksdGhpc319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbCxjPW51bGw7bz10aGlzLl9oaSt0LGk9dGhpcy5fbG8rZSxhPW8tdGhpcy5faGksYz1pLXRoaXMuX2xvLGw9by1hLHI9aS1jLGw9dC1hKyh0aGlzLl9oaS1sKSxyPWUtYysodGhpcy5fbG8tciksYT1sK2ksbj1vK2Escz1hKyhvLW4pLGE9citzO2NvbnN0IGg9bithLHU9YSsobi1oKTtyZXR1cm4gdGhpcy5faGk9aCx0aGlzLl9sbz11LHRoaXN9fXNlbGZNdWx0aXBseSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHQsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbDtvPUQuU1BMSVQqdGhpcy5faGksbj1vLXRoaXMuX2hpLGw9RC5TUExJVCp0LG49by1uLHM9dGhpcy5faGktbixpPWwtdCxvPXRoaXMuX2hpKnQsaT1sLWkscj10LWksbD1uKmktbytuKnIrcyppK3MqcisodGhpcy5faGkqZSt0aGlzLl9sbyp0KTtjb25zdCBhPW8rbDtuPW8tYTtjb25zdCBjPWwrbjtyZXR1cm4gdGhpcy5faGk9YSx0aGlzLl9sbz1jLHRoaXN9fXNlbGZTcXIoKXtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodGhpcyl9Zmxvb3IoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIEQuTmFOO2NvbnN0IHQ9TWF0aC5mbG9vcih0aGlzLl9oaSk7bGV0IGU9MDtyZXR1cm4gdD09PXRoaXMuX2hpJiYoZT1NYXRoLmZsb29yKHRoaXMuX2xvKSksbmV3IEQodCxlKX1uZWdhdGUoKXtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6bmV3IEQoLXRoaXMuX2hpLC10aGlzLl9sbyl9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBudWxsO3Rocm93IHR9fW11bHRpcGx5KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5pc05hTigpP0QuY3JlYXRlTmFOKCk6RC5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTih0KT9ELmNyZWF0ZU5hTigpOkQuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCwwKX19aXNOYU4oKXtyZXR1cm4gci5pc05hTih0aGlzLl9oaSl9aW50VmFsdWUoKXtyZXR1cm4gTWF0aC50cnVuYyh0aGlzLl9oaSl9dG9TdHJpbmcoKXtjb25zdCB0PUQubWFnbml0dWRlKHRoaXMuX2hpKTtyZXR1cm4gdD49LTMmJnQ8PTIwP3RoaXMudG9TdGFuZGFyZE5vdGF0aW9uKCk6dGhpcy50b1NjaU5vdGF0aW9uKCl9dG9TdGFuZGFyZE5vdGF0aW9uKCl7Y29uc3QgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITAsZSkscz1lWzBdKzE7bGV0IGk9bjtpZihcIi5cIj09PW4uY2hhckF0KDApKWk9XCIwXCIrbjtlbHNlIGlmKHM8MClpPVwiMC5cIitELnN0cmluZ09mQ2hhcihcIjBcIiwtcykrbjtlbHNlIGlmKC0xPT09bi5pbmRleE9mKFwiLlwiKSl7Y29uc3QgdD1zLW4ubGVuZ3RoO2k9bitELnN0cmluZ09mQ2hhcihcIjBcIix0KStcIi4wXCJ9cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK2k6aX1yZWNpcHJvY2FsKCl7bGV0IHQ9bnVsbCxlPW51bGwsbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGw7aT0xL3RoaXMuX2hpLHI9RC5TUExJVCppLHQ9ci1pLGw9RC5TUExJVCp0aGlzLl9oaSx0PXItdCxlPWktdCxuPWwtdGhpcy5faGksbz1pKnRoaXMuX2hpLG49bC1uLHM9dGhpcy5faGktbixsPXQqbi1vK3QqcytlKm4rZSpzLHI9KDEtby1sLWkqdGhpcy5fbG8pL3RoaXMuX2hpO2NvbnN0IGE9aStyO3JldHVybiBuZXcgRChhLGktYStyKX10b1NjaU5vdGF0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gRC5TQ0lfTk9UX1pFUk87Y29uc3QgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDtjb25zdCBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITEsZSkscz1ELlNDSV9OT1RfRVhQT05FTlRfQ0hBUitlWzBdO2lmKFwiMFwiPT09bi5jaGFyQXQoMCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkZvdW5kIGxlYWRpbmcgemVybzogXCIrbik7bGV0IGk9XCJcIjtuLmxlbmd0aD4xJiYoaT1uLnN1YnN0cmluZygxKSk7Y29uc3Qgcj1uLmNoYXJBdCgwKStcIi5cIitpO3JldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIityK3M6citzfWFicygpe3JldHVybiB0aGlzLmlzTmFOKCk/RC5OYU46dGhpcy5pc05lZ2F0aXZlKCk/dGhpcy5uZWdhdGUoKTpuZXcgRCh0aGlzKX1pc1Bvc2l0aXZlKCl7cmV0dXJuIHRoaXMuX2hpPjB8fDA9PT10aGlzLl9oaSYmdGhpcy5fbG8+MH1sdCh0KXtyZXR1cm4gdGhpcy5faGk8dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPHQuX2xvfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEQuY29weSh0aGlzKS5zZWxmQWRkKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBELmNvcHkodGhpcykuc2VsZkFkZCh0KX19aW5pdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9oaT10LHRoaXMuX2xvPTB9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2hpPXQuX2hpLHRoaXMuX2xvPXQuX2xvfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9oaT10LHRoaXMuX2xvPWV9fWd0KHQpe3JldHVybiB0aGlzLl9oaT50Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG8+dC5fbG99aXNOZWdhdGl2ZSgpe3JldHVybiB0aGlzLl9oaTwwfHwwPT09dGhpcy5faGkmJnRoaXMuX2xvPDB9dHJ1bmMoKXtyZXR1cm4gdGhpcy5pc05hTigpP0QuTmFOOnRoaXMuaXNQb3NpdGl2ZSgpP3RoaXMuZmxvb3IoKTp0aGlzLmNlaWwoKX1zaWdudW0oKXtyZXR1cm4gdGhpcy5faGk+MD8xOnRoaXMuX2hpPDA/LTE6dGhpcy5fbG8+MD8xOnRoaXMuX2xvPDA/LTE6MH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYyxvLGxdfX1ELlBJPW5ldyBEKDMuMTQxNTkyNjUzNTg5NzkzLDEyMjQ2NDY3OTkxNDczNTMyZS0zMiksRC5UV09fUEk9bmV3IEQoNi4yODMxODUzMDcxNzk1ODYsMjQ0OTI5MzU5ODI5NDcwNjRlLTMyKSxELlBJXzI9bmV3IEQoMS41NzA3OTYzMjY3OTQ4OTY2LDYxMjMyMzM5OTU3MzY3NjZlLTMyKSxELkU9bmV3IEQoMi43MTgyODE4Mjg0NTkwNDUsMTQ0NTY0Njg5MTcyOTI1MDJlLTMyKSxELk5hTj1uZXcgRChyLk5hTixyLk5hTiksRC5FUFM9MTIzMjU5NTE2NDQwNzgzZS00NixELlNQTElUPTEzNDIxNzcyOSxELk1BWF9QUklOVF9ESUdJVFM9MzIsRC5URU49RC52YWx1ZU9mKDEwKSxELk9ORT1ELnZhbHVlT2YoMSksRC5TQ0lfTk9UX0VYUE9ORU5UX0NIQVI9XCJFXCIsRC5TQ0lfTk9UX1pFUk89XCIwLjBFMFwiO2NsYXNzIEF7c3RhdGljIG9yaWVudGF0aW9uSW5kZXgodCxlLG4pe2NvbnN0IHM9QS5vcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKTtpZihzPD0xKXJldHVybiBzO2NvbnN0IGk9RC52YWx1ZU9mKGUueCkuc2VsZkFkZCgtdC54KSxyPUQudmFsdWVPZihlLnkpLnNlbGZBZGQoLXQueSksbz1ELnZhbHVlT2Yobi54KS5zZWxmQWRkKC1lLngpLGw9RC52YWx1ZU9mKG4ueSkuc2VsZkFkZCgtZS55KTtyZXR1cm4gaS5zZWxmTXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHIuc2VsZk11bHRpcGx5KG8pKS5zaWdudW0oKX1zdGF0aWMgc2lnbk9mRGV0MngyKCl7aWYoYXJndW1lbnRzWzNdaW5zdGFuY2VvZiBEJiZhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEQmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgRCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBEKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXTtyZXR1cm4gYXJndW1lbnRzWzBdLm11bHRpcGx5KG4pLnNlbGZTdWJ0cmFjdCh0Lm11bHRpcGx5KGUpKS5zaWdudW0oKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPUQudmFsdWVPZih0KSxyPUQudmFsdWVPZihlKSxvPUQudmFsdWVPZihuKSxsPUQudmFsdWVPZihzKTtyZXR1cm4gaS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoci5tdWx0aXBseShvKSkuc2lnbnVtKCl9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1uZXcgRCh0LnkpLnNlbGZTdWJ0cmFjdChlLnkpLG89bmV3IEQoZS54KS5zZWxmU3VidHJhY3QodC54KSxsPW5ldyBEKHQueCkuc2VsZk11bHRpcGx5KGUueSkuc2VsZlN1YnRyYWN0KG5ldyBEKGUueCkuc2VsZk11bHRpcGx5KHQueSkpLGE9bmV3IEQobi55KS5zZWxmU3VidHJhY3Qocy55KSxjPW5ldyBEKHMueCkuc2VsZlN1YnRyYWN0KG4ueCksaD1uZXcgRChuLngpLnNlbGZNdWx0aXBseShzLnkpLnNlbGZTdWJ0cmFjdChuZXcgRChzLngpLnNlbGZNdWx0aXBseShuLnkpKSx1PW8ubXVsdGlwbHkoaCkuc2VsZlN1YnRyYWN0KGMubXVsdGlwbHkobCkpLGc9YS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3QoaS5tdWx0aXBseShoKSksZD1pLm11bHRpcGx5KGMpLnNlbGZTdWJ0cmFjdChhLm11bHRpcGx5KG8pKSxfPXUuc2VsZkRpdmlkZShkKS5kb3VibGVWYWx1ZSgpLHA9Zy5zZWxmRGl2aWRlKGQpLmRvdWJsZVZhbHVlKCk7cmV0dXJuIHIuaXNOYU4oXyl8fHIuaXNJbmZpbml0ZShfKXx8ci5pc05hTihwKXx8ci5pc0luZmluaXRlKHApP251bGw6bmV3IG0oXyxwKX1zdGF0aWMgb3JpZW50YXRpb25JbmRleEZpbHRlcih0LGUsbil7bGV0IHM9bnVsbDtjb25zdCBpPSh0Lngtbi54KSooZS55LW4ueSkscj0odC55LW4ueSkqKGUueC1uLngpLG89aS1yO2lmKGk+MCl7aWYocjw9MClyZXR1cm4gQS5zaWdudW0obyk7cz1pK3J9ZWxzZXtpZighKGk8MCkpcmV0dXJuIEEuc2lnbnVtKG8pO2lmKHI+PTApcmV0dXJuIEEuc2lnbnVtKG8pO3M9LWktcn1jb25zdCBsPUEuRFBfU0FGRV9FUFNJTE9OKnM7cmV0dXJuIG8+PWx8fC1vPj1sP0Euc2lnbnVtKG8pOjJ9c3RhdGljIHNpZ251bSh0KXtyZXR1cm4gdD4wPzE6dDwwPy0xOjB9fUEuRFBfU0FGRV9FUFNJTE9OPTFlLTE1O2NsYXNzIEZ7Z2V0TSh0KXtpZih0aGlzLmhhc00oKSl7Y29uc3QgZT10aGlzLmdldERpbWVuc2lvbigpLXRoaXMuZ2V0TWVhc3VyZXMoKTtyZXR1cm4gdGhpcy5nZXRPcmRpbmF0ZSh0LGUpfXJldHVybiByLk5hTn1zZXRPcmRpbmF0ZSh0LGUsbil7fWdldFoodCl7cmV0dXJuIHRoaXMuaGFzWigpP3RoaXMuZ2V0T3JkaW5hdGUodCwyKTpyLk5hTn1zaXplKCl7fWdldE9yZGluYXRlKHQsZSl7fWdldENvb3JkaW5hdGUoKXt9Z2V0Q29vcmRpbmF0ZUNvcHkodCl7fWNyZWF0ZUNvb3JkaW5hdGUoKXt9Z2V0RGltZW5zaW9uKCl7fWhhc00oKXtyZXR1cm4gdGhpcy5nZXRNZWFzdXJlcygpPjB9Z2V0WCh0KXt9aGFzWigpe3JldHVybiB0aGlzLmdldERpbWVuc2lvbigpLXRoaXMuZ2V0TWVhc3VyZXMoKT4yfWdldE1lYXN1cmVzKCl7cmV0dXJuIDB9ZXhwYW5kRW52ZWxvcGUodCl7fWNvcHkoKXt9Z2V0WSh0KXt9dG9Db29yZGluYXRlQXJyYXkoKXt9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1GLlg9MCxGLlk9MSxGLlo9MixGLk09MztjbGFzcyBHe3N0YXRpYyBpbmRleCh0LGUsbil7cmV0dXJuIEEub3JpZW50YXRpb25JbmRleCh0LGUsbil9c3RhdGljIGlzQ0NXKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10Lmxlbmd0aC0xO2lmKGU8Myl0aHJvdyBuZXcgcyhcIlJpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkXCIpO2xldCBuPXRbMF0saT0wO2ZvcihsZXQgcz0xO3M8PWU7cysrKXtjb25zdCBlPXRbc107ZS55Pm4ueSYmKG49ZSxpPXMpfWxldCByPWk7ZG97ci09MSxyPDAmJihyPWUpfXdoaWxlKHRbcl0uZXF1YWxzMkQobikmJnIhPT1pKTtsZXQgbz1pO2Rve289KG8rMSklZX13aGlsZSh0W29dLmVxdWFsczJEKG4pJiZvIT09aSk7Y29uc3QgbD10W3JdLGE9dFtvXTtpZihsLmVxdWFsczJEKG4pfHxhLmVxdWFsczJEKG4pfHxsLmVxdWFsczJEKGEpKXJldHVybiExO2NvbnN0IGM9Ry5pbmRleChsLG4sYSk7bGV0IGg9bnVsbDtyZXR1cm4gaD0wPT09Yz9sLng+YS54OmM+MCxofWlmKEkoYXJndW1lbnRzWzBdLEYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpLTE7aWYoZTwzKXRocm93IG5ldyBzKFwiUmluZyBoYXMgZmV3ZXIgdGhhbiA0IHBvaW50cywgc28gb3JpZW50YXRpb24gY2Fubm90IGJlIGRldGVybWluZWRcIik7bGV0IG49dC5nZXRDb29yZGluYXRlKDApLGk9MDtmb3IobGV0IHM9MTtzPD1lO3MrKyl7Y29uc3QgZT10LmdldENvb3JkaW5hdGUocyk7ZS55Pm4ueSYmKG49ZSxpPXMpfWxldCByPW51bGwsbz1pO2Rve28tPTEsbzwwJiYobz1lKSxyPXQuZ2V0Q29vcmRpbmF0ZShvKX13aGlsZShyLmVxdWFsczJEKG4pJiZvIT09aSk7bGV0IGw9bnVsbCxhPWk7ZG97YT0oYSsxKSVlLGw9dC5nZXRDb29yZGluYXRlKGEpfXdoaWxlKGwuZXF1YWxzMkQobikmJmEhPT1pKTtpZihyLmVxdWFsczJEKG4pfHxsLmVxdWFsczJEKG4pfHxyLmVxdWFsczJEKGwpKXJldHVybiExO2NvbnN0IGM9Ry5pbmRleChyLG4sbCk7bGV0IGg9bnVsbDtyZXR1cm4gaD0wPT09Yz9yLng+bC54OmM+MCxofX19Ry5DTE9DS1dJU0U9LTEsRy5SSUdIVD1HLkNMT0NLV0lTRSxHLkNPVU5URVJDTE9DS1dJU0U9MSxHLkxFRlQ9Ry5DT1VOVEVSQ0xPQ0tXSVNFLEcuQ09MTElORUFSPTAsRy5TVFJBSUdIVD1HLkNPTExJTkVBUjtjbGFzcyBxe3N0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT10Lng8ZS54P3QueDplLngsbz10Lnk8ZS55P3QueTplLnksbD10Lng+ZS54P3QueDplLngsYT10Lnk+ZS55P3QueTplLnksYz1uLng8cy54P24ueDpzLngsaD1uLnk8cy55P24ueTpzLnksdT1uLng+cy54P24ueDpzLngsZz1uLnk+cy55P24ueTpzLnksZD0oKGk+Yz9pOmMpKyhsPHU/bDp1KSkvMixfPSgobz5oP286aCkrKGE8Zz9hOmcpKS8yLHA9dC54LWQsZj10LnktXyx5PWUueC1kLHg9ZS55LV8sRT1uLngtZCxJPW4ueS1fLE49cy54LWQsUz1zLnktXyx3PWYteCxDPXktcCxMPXAqeC15KmYsVD1JLVMsUj1OLUUsUD1FKlMtTipJLE89dypSLVQqQyx2PShDKlAtUipMKS9PLE09KFQqTC13KlApL087cmV0dXJuIHIuaXNOYU4odil8fHIuaXNJbmZpbml0ZSh2KXx8ci5pc05hTihNKXx8ci5pc0luZmluaXRlKE0pP251bGw6bmV3IG0oditkLE0rXyl9fWNsYXNzIEJ7c3RhdGljIGFycmF5Y29weSh0LGUsbixzLGkpe2xldCByPTA7Zm9yKGxldCBvPWU7bzxlK2k7bysrKW5bcytyXT10W29dLHIrK31zdGF0aWMgZ2V0UHJvcGVydHkodCl7cmV0dXJue1wibGluZS5zZXBhcmF0b3JcIjpcIlxcblwifVt0XX19Y2xhc3MgWXtzdGF0aWMgbG9nMTAodCl7Y29uc3QgZT1NYXRoLmxvZyh0KTtyZXR1cm4gci5pc0luZmluaXRlKGUpfHxyLmlzTmFOKGUpP2U6ZS9ZLkxPR18xMH1zdGF0aWMgbWluKHQsZSxuLHMpe2xldCBpPXQ7cmV0dXJuIGU8aSYmKGk9ZSksbjxpJiYoaT1uKSxzPGkmJihpPXMpLGl9c3RhdGljIGNsYW1wKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQ8ZT9lOnQ+bj9uOnR9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQ8ZT9lOnQ+bj9uOnR9fXN0YXRpYyB3cmFwKHQsZSl7cmV0dXJuIHQ8MD9lLSAtdCVlOnQlZX1zdGF0aWMgbWF4KCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO2xldCBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdD5uJiYobj10KSxlPm4mJihuPWUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdO2xldCBzPWFyZ3VtZW50c1swXTtyZXR1cm4gdD5zJiYocz10KSxlPnMmJihzPWUpLG4+cyYmKHM9biksc319c3RhdGljIGF2ZXJhZ2UodCxlKXtyZXR1cm4odCtlKS8yfX1ZLkxPR18xMD1NYXRoLmxvZygxMCk7Y2xhc3MgVntzdGF0aWMgc2VnbWVudFRvU2VnbWVudCh0LGUsbixzKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gVi5wb2ludFRvU2VnbWVudCh0LG4scyk7aWYobi5lcXVhbHMocykpcmV0dXJuIFYucG9pbnRUb1NlZ21lbnQocyx0LGUpO2xldCBpPSExO2lmKE8uaW50ZXJzZWN0cyh0LGUsbixzKSl7Y29uc3Qgcj0oZS54LXQueCkqKHMueS1uLnkpLShlLnktdC55KSoocy54LW4ueCk7aWYoMD09PXIpaT0hMDtlbHNle2NvbnN0IG89KHQueS1uLnkpKihzLngtbi54KS0odC54LW4ueCkqKHMueS1uLnkpLGw9KCh0Lnktbi55KSooZS54LXQueCktKHQueC1uLngpKihlLnktdC55KSkvcixhPW8vcjsoYTwwfHxhPjF8fGw8MHx8bD4xKSYmKGk9ITApfX1lbHNlIGk9ITA7cmV0dXJuIGk/WS5taW4oVi5wb2ludFRvU2VnbWVudCh0LG4scyksVi5wb2ludFRvU2VnbWVudChlLG4scyksVi5wb2ludFRvU2VnbWVudChuLHQsZSksVi5wb2ludFRvU2VnbWVudChzLHQsZSkpOjB9c3RhdGljIHBvaW50VG9TZWdtZW50KHQsZSxuKXtpZihlLng9PT1uLngmJmUueT09PW4ueSlyZXR1cm4gdC5kaXN0YW5jZShlKTtjb25zdCBzPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxpPSgodC54LWUueCkqKG4ueC1lLngpKyh0LnktZS55KSoobi55LWUueSkpL3M7aWYoaTw9MClyZXR1cm4gdC5kaXN0YW5jZShlKTtpZihpPj0xKXJldHVybiB0LmRpc3RhbmNlKG4pO2NvbnN0IHI9KChlLnktdC55KSoobi54LWUueCktKGUueC10LngpKihuLnktZS55KSkvcztyZXR1cm4gTWF0aC5hYnMocikqTWF0aC5zcXJ0KHMpfXN0YXRpYyBwb2ludFRvTGluZVBlcnBlbmRpY3VsYXIodCxlLG4pe2NvbnN0IHM9KG4ueC1lLngpKihuLngtZS54KSsobi55LWUueSkqKG4ueS1lLnkpLGk9KChlLnktdC55KSoobi54LWUueCktKGUueC10LngpKihuLnktZS55KSkvcztyZXR1cm4gTWF0aC5hYnMoaSkqTWF0aC5zcXJ0KHMpfXN0YXRpYyBwb2ludFRvU2VnbWVudFN0cmluZyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgcyhcIkxpbmUgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB2ZXJ0ZXhcIik7bGV0IG49dC5kaXN0YW5jZShlWzBdKTtmb3IobGV0IHM9MDtzPGUubGVuZ3RoLTE7cysrKXtjb25zdCBpPVYucG9pbnRUb1NlZ21lbnQodCxlW3NdLGVbcysxXSk7aTxuJiYobj1pKX1yZXR1cm4gbn19Y2xhc3MgentjcmVhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5fHxJKGFyZ3VtZW50c1swXSxGKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jcmVhdGUodCxlKX19fWNsYXNzIGt7ZmlsdGVyKHQpe319Y2xhc3MgWHtjb25zdHJ1Y3Rvcigpe1guY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0dlb21ldHJ5Q29sbGVjdGlvbigpe3JldHVybiB0aGlzLmdldFR5cGVDb2RlKCk9PT1YLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTn1nZXRGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2ZhY3Rvcnl9Z2V0R2VvbWV0cnlOKHQpe3JldHVybiB0aGlzfWdldEFyZWEoKXtyZXR1cm4gMH1pc1JlY3RhbmdsZSgpe3JldHVybiExfWVxdWFsc0V4YWN0KHQpe3JldHVybiB0aGlzPT09dHx8dGhpcy5lcXVhbHNFeGFjdCh0LDApfWdlb21ldHJ5Q2hhbmdlZCgpe3RoaXMuYXBwbHkoWC5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIpfWdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpe3RoaXMuX2VudmVsb3BlPW51bGx9ZXF1YWxzTm9ybSh0KXtyZXR1cm4gbnVsbCE9PXQmJnRoaXMubm9ybSgpLmVxdWFsc0V4YWN0KHQubm9ybSgpKX1nZXRMZW5ndGgoKXtyZXR1cm4gMH1nZXROdW1HZW9tZXRyaWVzKCl7cmV0dXJuIDF9Y29tcGFyZVRvKCl7bGV0IHQ7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IGU9YXJndW1lbnRzWzBdO3JldHVybiB0PWUsdGhpcy5nZXRUeXBlQ29kZSgpIT09dC5nZXRUeXBlQ29kZSgpP3RoaXMuZ2V0VHlwZUNvZGUoKS10LmdldFR5cGVDb2RlKCk6dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6dC5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhlKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHQ9ZSx0aGlzLmdldFR5cGVDb2RlKCkhPT10LmdldFR5cGVDb2RlKCk/dGhpcy5nZXRUeXBlQ29kZSgpLXQuZ2V0VHlwZUNvZGUoKTp0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTp0LmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKGUsbil9fWdldFVzZXJEYXRhKCl7cmV0dXJuIHRoaXMuX3VzZXJEYXRhfWdldFNSSUQoKXtyZXR1cm4gdGhpcy5fU1JJRH1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KXtpZih0LmdldFR5cGVDb2RlKCk9PT1YLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTil0aHJvdyBuZXcgcyhcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKX1lcXVhbCh0LGUsbil7cmV0dXJuIDA9PT1uP3QuZXF1YWxzKGUpOnQuZGlzdGFuY2UoZSk8PW59bm9ybSgpe2NvbnN0IHQ9dGhpcy5jb3B5KCk7cmV0dXJuIHQubm9ybWFsaXplKCksdH1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLnJldmVyc2VJbnRlcm5hbCgpO3JldHVybiBudWxsIT10aGlzLmVudmVsb3BlJiYodC5lbnZlbG9wZT10aGlzLmVudmVsb3BlLmNvcHkoKSksdC5zZXRTUklEKHRoaXMuZ2V0U1JJRCgpKSx0fWNvcHkoKXtjb25zdCB0PXRoaXMuY29weUludGVybmFsKCk7cmV0dXJuIHQuZW52ZWxvcGU9bnVsbD09dGhpcy5fZW52ZWxvcGU/bnVsbDp0aGlzLl9lbnZlbG9wZS5jb3B5KCksdC5fU1JJRD10aGlzLl9TUklELHQuX3VzZXJEYXRhPXRoaXMuX3VzZXJEYXRhLHR9Z2V0UHJlY2lzaW9uTW9kZWwoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfWdldEVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2VudmVsb3BlJiYodGhpcy5fZW52ZWxvcGU9dGhpcy5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpKSxuZXcgTyh0aGlzLl9lbnZlbG9wZSl9c2V0U1JJRCh0KXt0aGlzLl9TUklEPXR9c2V0VXNlckRhdGEodCl7dGhpcy5fdXNlckRhdGE9dH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10Lml0ZXJhdG9yKCkscz1lLml0ZXJhdG9yKCk7Zm9yKDtuLmhhc05leHQoKSYmcy5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLGU9cy5uZXh0KCksaT10LmNvbXBhcmVUbyhlKTtpZigwIT09aSlyZXR1cm4gaX1yZXR1cm4gbi5oYXNOZXh0KCk/MTpzLmhhc05leHQoKT8tMTowfWhhc2hDb2RlKCl7cmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmhhc2hDb2RlKCl9aXNFcXVpdmFsZW50Q2xhc3ModCl7cmV0dXJuIHRoaXMuZ2V0Q2xhc3MoKT09PXQuZ2V0Q2xhc3MoKX1pc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCgpe3JldHVybiB0aGlzLmdldFR5cGVDb2RlKCk9PT1YLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTnx8dGhpcy5nZXRUeXBlQ29kZSgpPT09WC5UWVBFQ09ERV9NVUxUSVBPSU5UfHx0aGlzLmdldFR5cGVDb2RlKCk9PT1YLlRZUEVDT0RFX01VTFRJTElORVNUUklOR3x8dGhpcy5nZXRUeXBlQ29kZSgpPT09WC5UWVBFQ09ERV9NVUxUSVBPTFlHT059Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2wsbyxjXX1nZXRDbGFzcygpe3JldHVybiBYfXN0YXRpYyBoYXNOb25FbXB0eUVsZW1lbnRzKHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCF0W2VdLmlzRW1wdHkoKSlyZXR1cm4hMDtyZXR1cm4hMX1zdGF0aWMgaGFzTnVsbEVsZW1lbnRzKHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKG51bGw9PT10W2VdKXJldHVybiEwO3JldHVybiExfX1YLmNvbnN0cnVjdG9yXz1mdW5jdGlvbih0KXt0JiYodGhpcy5fZW52ZWxvcGU9bnVsbCx0aGlzLl91c2VyRGF0YT1udWxsLHRoaXMuX2ZhY3Rvcnk9dCx0aGlzLl9TUklEPXQuZ2V0U1JJRCgpKX0sWC5UWVBFQ09ERV9QT0lOVD0wLFguVFlQRUNPREVfTVVMVElQT0lOVD0xLFguVFlQRUNPREVfTElORVNUUklORz0yLFguVFlQRUNPREVfTElORUFSUklORz0zLFguVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HPTQsWC5UWVBFQ09ERV9QT0xZR09OPTUsWC5UWVBFQ09ERV9NVUxUSVBPTFlHT049NixYLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTj03LFguVFlQRU5BTUVfUE9JTlQ9XCJQb2ludFwiLFguVFlQRU5BTUVfTVVMVElQT0lOVD1cIk11bHRpUG9pbnRcIixYLlRZUEVOQU1FX0xJTkVTVFJJTkc9XCJMaW5lU3RyaW5nXCIsWC5UWVBFTkFNRV9MSU5FQVJSSU5HPVwiTGluZWFyUmluZ1wiLFguVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HPVwiTXVsdGlMaW5lU3RyaW5nXCIsWC5UWVBFTkFNRV9QT0xZR09OPVwiUG9seWdvblwiLFguVFlQRU5BTUVfTVVMVElQT0xZR09OPVwiTXVsdGlQb2x5Z29uXCIsWC5UWVBFTkFNRV9HRU9NRVRSWUNPTExFQ1RJT049XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixYLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcj17Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfSxmaWx0ZXIodCl7dC5nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKX19O2NsYXNzIFV7ZmlsdGVyKHQpe319Y2xhc3MgSHtzdGF0aWMgb2ZMaW5lKHQpe2NvbnN0IGU9dC5zaXplKCk7aWYoZTw9MSlyZXR1cm4gMDtsZXQgbj0wO2NvbnN0IHM9bmV3IG07dC5nZXRDb29yZGluYXRlKDAscyk7bGV0IGk9cy54LHI9cy55O2ZvcihsZXQgbz0xO288ZTtvKyspe3QuZ2V0Q29vcmRpbmF0ZShvLHMpO2NvbnN0IGU9cy54LGw9cy55LGE9ZS1pLGM9bC1yO24rPU1hdGguc3FydChhKmErYypjKSxpPWUscj1sfXJldHVybiBufX1jbGFzcyBXe31jbGFzcyBae3N0YXRpYyBjb3B5Q29vcmQodCxlLG4scyl7Y29uc3QgaT1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLG4uZ2V0RGltZW5zaW9uKCkpO2ZvcihsZXQgcj0wO3I8aTtyKyspbi5zZXRPcmRpbmF0ZShzLHIsdC5nZXRPcmRpbmF0ZShlLHIpKX1zdGF0aWMgaXNSaW5nKHQpe2NvbnN0IGU9dC5zaXplKCk7cmV0dXJuIDA9PT1lfHwhKGU8PTMpJiYodC5nZXRPcmRpbmF0ZSgwLEYuWCk9PT10LmdldE9yZGluYXRlKGUtMSxGLlgpJiZ0LmdldE9yZGluYXRlKDAsRi5ZKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEYuWSkpfXN0YXRpYyBzY3JvbGwoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sRikmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Wi5zY3JvbGwodCxlLFouaXNSaW5nKHQpKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEYpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49Wi5pbmRleE9mKGUsdCk7aWYobjw9MClyZXR1cm4gbnVsbDtaLnNjcm9sbCh0LG4pfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPD0wKXJldHVybiBudWxsO2NvbnN0IHM9dC5jb3B5KCksaT1uP3Quc2l6ZSgpLTE6dC5zaXplKCk7Zm9yKGxldCBuPTA7bjxpO24rKylmb3IobGV0IHI9MDtyPHQuZ2V0RGltZW5zaW9uKCk7cisrKXQuc2V0T3JkaW5hdGUobixyLHMuZ2V0T3JkaW5hdGUoKGUrbiklaSxyKSk7aWYobilmb3IobGV0IGU9MDtlPHQuZ2V0RGltZW5zaW9uKCk7ZSsrKXQuc2V0T3JkaW5hdGUoaSxlLHQuZ2V0T3JkaW5hdGUoMCxlKSl9fXN0YXRpYyBpc0VxdWFsKHQsZSl7Y29uc3Qgbj10LnNpemUoKTtpZihuIT09ZS5zaXplKCkpcmV0dXJuITE7Y29uc3Qgcz1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpO2ZvcihsZXQgaT0wO2k8bjtpKyspZm9yKGxldCBuPTA7bjxzO24rKyl7Y29uc3Qgcz10LmdldE9yZGluYXRlKGksbiksbz1lLmdldE9yZGluYXRlKGksbik7aWYodC5nZXRPcmRpbmF0ZShpLG4pIT09ZS5nZXRPcmRpbmF0ZShpLG4pJiYoIXIuaXNOYU4ocyl8fCFyLmlzTmFOKG8pKSlyZXR1cm4hMX1yZXR1cm4hMH1zdGF0aWMgbWluQ29vcmRpbmF0ZUluZGV4KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBaLm1pbkNvb3JkaW5hdGVJbmRleCh0LDAsdC5zaXplKCktMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdO2xldCBuPS0xLHM9bnVsbDtmb3IobGV0IGk9YXJndW1lbnRzWzFdO2k8PWU7aSsrKXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZShpKTsobnVsbD09PXN8fHMuY29tcGFyZVRvKGUpPjApJiYocz1lLG49aSl9cmV0dXJuIG59fXN0YXRpYyBleHRlbmQodCxlLG4pe2NvbnN0IHM9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxpPWUuc2l6ZSgpO2lmKFouY29weShlLDAscywwLGkpLGk+MClmb3IobGV0IHQ9aTt0PG47dCsrKVouY29weShlLGktMSxzLHQsMSk7cmV0dXJuIHN9c3RhdGljIHJldmVyc2UodCl7Y29uc3QgZT10LnNpemUoKS0xLG49TWF0aC50cnVuYyhlLzIpO2ZvcihsZXQgcz0wO3M8PW47cysrKVouc3dhcCh0LHMsZS1zKX1zdGF0aWMgc3dhcCh0LGUsbil7aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKGxldCBzPTA7czx0LmdldERpbWVuc2lvbigpO3MrKyl7Y29uc3QgaT10LmdldE9yZGluYXRlKGUscyk7dC5zZXRPcmRpbmF0ZShlLHMsdC5nZXRPcmRpbmF0ZShuLHMpKSx0LnNldE9yZGluYXRlKG4scyxpKX19c3RhdGljIGNvcHkodCxlLG4scyxpKXtmb3IobGV0IHI9MDtyPGk7cisrKVouY29weUNvb3JkKHQsZStyLG4scytyKX1zdGF0aWMgZW5zdXJlVmFsaWRSaW5nKHQsZSl7Y29uc3Qgbj1lLnNpemUoKTtpZigwPT09bilyZXR1cm4gZTtpZihuPD0zKXJldHVybiBaLmNyZWF0ZUNsb3NlZFJpbmcodCxlLDQpO3JldHVybiBlLmdldE9yZGluYXRlKDAsRi5YKT09PWUuZ2V0T3JkaW5hdGUobi0xLEYuWCkmJmUuZ2V0T3JkaW5hdGUoMCxGLlkpPT09ZS5nZXRPcmRpbmF0ZShuLTEsRi5ZKT9lOlouY3JlYXRlQ2xvc2VkUmluZyh0LGUsbisxKX1zdGF0aWMgaW5kZXhPZih0LGUpe2ZvcihsZXQgbj0wO248ZS5zaXplKCk7bisrKWlmKHQueD09PWUuZ2V0T3JkaW5hdGUobixGLlgpJiZ0Lnk9PT1lLmdldE9yZGluYXRlKG4sRi5ZKSlyZXR1cm4gbjtyZXR1cm4tMX1zdGF0aWMgY3JlYXRlQ2xvc2VkUmluZyh0LGUsbil7Y29uc3Qgcz10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLGk9ZS5zaXplKCk7Wi5jb3B5KGUsMCxzLDAsaSk7Zm9yKGxldCB0PWk7dDxuO3QrKylaLmNvcHkoZSwwLHMsdCwxKTtyZXR1cm4gc31zdGF0aWMgbWluQ29vcmRpbmF0ZSh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZShuKTsobnVsbD09PWV8fGUuY29tcGFyZVRvKHMpPjApJiYoZT1zKX1yZXR1cm4gZX19Y2xhc3MgaiBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjpqfSlbMF19fWNsYXNzIEt7c3RhdGljIHRvRGltZW5zaW9uU3ltYm9sKHQpe3N3aXRjaCh0KXtjYXNlIEsuRkFMU0U6cmV0dXJuIEsuU1lNX0ZBTFNFO2Nhc2UgSy5UUlVFOnJldHVybiBLLlNZTV9UUlVFO2Nhc2UgSy5ET05UQ0FSRTpyZXR1cm4gSy5TWU1fRE9OVENBUkU7Y2FzZSBLLlA6cmV0dXJuIEsuU1lNX1A7Y2FzZSBLLkw6cmV0dXJuIEsuU1lNX0w7Y2FzZSBLLkE6cmV0dXJuIEsuU1lNX0F9dGhyb3cgbmV3IHMoXCJVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogXCIrdCl9c3RhdGljIHRvRGltZW5zaW9uVmFsdWUodCl7c3dpdGNoKGIudG9VcHBlckNhc2UodCkpe2Nhc2UgSy5TWU1fRkFMU0U6cmV0dXJuIEsuRkFMU0U7Y2FzZSBLLlNZTV9UUlVFOnJldHVybiBLLlRSVUU7Y2FzZSBLLlNZTV9ET05UQ0FSRTpyZXR1cm4gSy5ET05UQ0FSRTtjYXNlIEsuU1lNX1A6cmV0dXJuIEsuUDtjYXNlIEsuU1lNX0w6cmV0dXJuIEsuTDtjYXNlIEsuU1lNX0E6cmV0dXJuIEsuQX10aHJvdyBuZXcgcyhcIlVua25vd24gZGltZW5zaW9uIHN5bWJvbDogXCIrdCl9fUsuUD0wLEsuTD0xLEsuQT0yLEsuRkFMU0U9LTEsSy5UUlVFPS0yLEsuRE9OVENBUkU9LTMsSy5TWU1fRkFMU0U9XCJGXCIsSy5TWU1fVFJVRT1cIlRcIixLLlNZTV9ET05UQ0FSRT1cIipcIixLLlNZTV9QPVwiMFwiLEsuU1lNX0w9XCIxXCIsSy5TWU1fQT1cIjJcIjtjbGFzcyBRe2ZpbHRlcih0KXt9fWNsYXNzIEogZXh0ZW5kcyBYe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxKLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BvaW50cz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtYLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9uZXcgTzp0aGlzLl9wb2ludHMuZXhwYW5kRW52ZWxvcGUobmV3IE8pfWlzUmluZygpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCkmJnRoaXMuaXNTaW1wbGUoKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wb2ludHMudG9Db29yZGluYXRlQXJyYXkoKX1jb3B5SW50ZXJuYWwoKXtyZXR1cm4gbmV3IEoodGhpcy5fcG9pbnRzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dDtpZih0aGlzLl9wb2ludHMuc2l6ZSgpIT09bi5fcG9pbnRzLnNpemUoKSlyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX3BvaW50cy5zaXplKCk7dCsrKWlmKCF0aGlzLmVxdWFsKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLG4uX3BvaW50cy5nZXRDb29yZGluYXRlKHQpLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDxNYXRoLnRydW5jKHRoaXMuX3BvaW50cy5zaXplKCkvMik7dCsrKXtjb25zdCBlPXRoaXMuX3BvaW50cy5zaXplKCktMS10O2lmKCF0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5lcXVhbHModGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpKXtpZih0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5jb21wYXJlVG8odGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkpPjApe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtaLnJldmVyc2UodCksdGhpcy5fcG9pbnRzPXR9cmV0dXJuIG51bGx9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoMCl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP0suRkFMU0U6MH1pc0Nsb3NlZCgpe3JldHVybiF0aGlzLmlzRW1wdHkoKSYmdGhpcy5nZXRDb29yZGluYXRlTigwKS5lcXVhbHMyRCh0aGlzLmdldENvb3JkaW5hdGVOKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSkpfXJldmVyc2VJbnRlcm5hbCgpe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtyZXR1cm4gWi5yZXZlcnNlKHQpLHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodCl9Z2V0RW5kUG9pbnQoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50Tih0aGlzLmdldE51bVBvaW50cygpLTEpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFguVFlQRUNPREVfTElORVNUUklOR31nZXREaW1lbnNpb24oKXtyZXR1cm4gMX1nZXRMZW5ndGgoKXtyZXR1cm4gSC5vZkxpbmUodGhpcy5fcG9pbnRzKX1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5fcG9pbnRzLnNpemUoKX1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9MCxuPTA7Zm9yKDtlPHRoaXMuX3BvaW50cy5zaXplKCkmJm48dC5fcG9pbnRzLnNpemUoKTspe2NvbnN0IHM9dGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuY29tcGFyZVRvKHQuX3BvaW50cy5nZXRDb29yZGluYXRlKG4pKTtpZigwIT09cylyZXR1cm4gcztlKyssbisrfXJldHVybiBlPHRoaXMuX3BvaW50cy5zaXplKCk/MTpuPHQuX3BvaW50cy5zaXplKCk/LTE6MH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1sxXS5jb21wYXJlKHRoaXMuX3BvaW50cyx0Ll9wb2ludHMpfX1hcHBseSgpe2lmKEkoYXJndW1lbnRzWzBdLFUpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCk7ZSsrKXQuZmlsdGVyKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFApKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5fcG9pbnRzLnNpemUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCkmJih0LmZpbHRlcih0aGlzLl9wb2ludHMsZSksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUSkpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxrKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX19Z2V0Qm91bmRhcnkoKXt0aHJvdyBuZXcgan1pc0VxdWl2YWxlbnRDbGFzcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEp9Z2V0Q29vcmRpbmF0ZU4odCl7cmV0dXJuIHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX0xJTkVTVFJJTkd9Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCl7cmV0dXJuIHRoaXMuX3BvaW50c31pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9wb2ludHMuc2l6ZSgpfWluaXQodCl7aWYobnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSwxPT09dC5zaXplKCkpdGhyb3cgbmV3IHMoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZVN0cmluZyAoZm91bmQgXCIrdC5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gMilcIik7dGhpcy5fcG9pbnRzPXR9aXNDb29yZGluYXRlKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKTtlKyspaWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuZXF1YWxzKHQpKXJldHVybiEwO3JldHVybiExfWdldFN0YXJ0UG9pbnQoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50TigwKX1nZXRQb2ludE4odCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bV119fWNsYXNzICR7fWNsYXNzIHR0IGV4dGVuZHMgWHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmRpbmF0ZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtYLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfWNvbXB1dGVFbnZlbG9wZUludGVybmFsKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG5ldyBPO2NvbnN0IHQ9bmV3IE87cmV0dXJuIHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2Nvb3JkaW5hdGVzLmdldFgoMCksdGhpcy5fY29vcmRpbmF0ZXMuZ2V0WSgwKSksdH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9bXTpbdGhpcy5nZXRDb29yZGluYXRlKCldfWNvcHlJbnRlcm5hbCgpe3JldHVybiBuZXcgdHQodGhpcy5fY29vcmRpbmF0ZXMuY29weSgpLHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiYoISghdGhpcy5pc0VtcHR5KCl8fCF0LmlzRW1wdHkoKSl8fHRoaXMuaXNFbXB0eSgpPT09dC5pc0VtcHR5KCkmJnRoaXMuZXF1YWwodC5nZXRDb29yZGluYXRlKCksdGhpcy5nZXRDb29yZGluYXRlKCksZSkpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gMCE9PXRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKT90aGlzLl9jb29yZGluYXRlcy5nZXRDb29yZGluYXRlKDApOm51bGx9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gSy5GQUxTRX1yZXZlcnNlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY29vcmRpbmF0ZXMuY29weSgpKX1nZXRUeXBlQ29kZSgpe3JldHVybiBYLlRZUEVDT0RFX1BPSU5UfWdldERpbWVuc2lvbigpe3JldHVybiAwfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8wOjF9Z2V0WCgpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiZ2V0WCBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnh9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odC5nZXRDb29yZGluYXRlKCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzFdLmNvbXBhcmUodGhpcy5fY29vcmRpbmF0ZXMsdC5fY29vcmRpbmF0ZXMpfX1hcHBseSgpe2lmKEkoYXJndW1lbnRzWzBdLFUpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0LmZpbHRlcih0aGlzLmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxQKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5fY29vcmRpbmF0ZXMsMCksdC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUSkpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxrKSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX19Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFguVFlQRU5BTUVfUE9JTlR9Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfWdldFkoKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFkgY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55fWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKX1pbml0KHQpe251bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksZy5pc1RydWUodC5zaXplKCk8PTEpLHRoaXMuX2Nvb3JkaW5hdGVzPXR9aXNTaW1wbGUoKXtyZXR1cm4hMH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bJF19fWNsYXNzIGV0e3N0YXRpYyBvZlJpbmcoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hYnMoZXQub2ZSaW5nU2lnbmVkKHQpKX1pZihJKGFyZ3VtZW50c1swXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYWJzKGV0Lm9mUmluZ1NpZ25lZCh0KSl9fXN0YXRpYyBvZlJpbmdTaWduZWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0Lmxlbmd0aDwzKXJldHVybiAwO2xldCBlPTA7Y29uc3Qgbj10WzBdLng7Zm9yKGxldCBzPTE7czx0Lmxlbmd0aC0xO3MrKyl7Y29uc3QgaT10W3NdLngtbixyPXRbcysxXS55O2UrPWkqKHRbcy0xXS55LXIpfXJldHVybiBlLzJ9aWYoSShhcmd1bWVudHNbMF0sRikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCk7aWYoZTwzKXJldHVybiAwO2NvbnN0IG49bmV3IG0scz1uZXcgbSxpPW5ldyBtO3QuZ2V0Q29vcmRpbmF0ZSgwLHMpLHQuZ2V0Q29vcmRpbmF0ZSgxLGkpO2NvbnN0IHI9cy54O2kueC09cjtsZXQgbz0wO2ZvcihsZXQgbD0xO2w8ZS0xO2wrKyluLnk9cy55LHMueD1pLngscy55PWkueSx0LmdldENvb3JkaW5hdGUobCsxLGkpLGkueC09cixvKz1zLngqKG4ueS1pLnkpO3JldHVybiBvLzJ9fX1jbGFzcyBudHtzdGF0aWMgc29ydCgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXQuc29ydCgoKHQsZSk9PnQuY29tcGFyZVRvKGUpKSk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl0LnNvcnQoKCh0LGUpPT5hcmd1bWVudHNbMV0uY29tcGFyZSh0LGUpKSk7ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT10LnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO2Uuc29ydCgpO2NvbnN0IG49dC5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsdC5zbGljZShhcmd1bWVudHNbMl0sdC5sZW5ndGgpKTt0LnNwbGljZSgwLHQubGVuZ3RoKTtmb3IoY29uc3QgZSBvZiBuKXQucHVzaChlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPXQuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSk7ZS5zb3J0KCgodCxlKT0+YXJndW1lbnRzWzNdLmNvbXBhcmUodCxlKSkpO2NvbnN0IG49dC5zbGljZSgwLGFyZ3VtZW50c1sxXSkuY29uY2F0KGUsdC5zbGljZShhcmd1bWVudHNbMl0sdC5sZW5ndGgpKTt0LnNwbGljZSgwLHQubGVuZ3RoKTtmb3IoY29uc3QgZSBvZiBuKXQucHVzaChlKX19c3RhdGljIGFzTGlzdCh0KXtjb25zdCBlPW5ldyBMO2Zvcihjb25zdCBuIG9mIHQpZS5hZGQobik7cmV0dXJuIGV9c3RhdGljIGNvcHlPZih0LGUpe3JldHVybiB0LnNsaWNlKDAsZSl9fWNsYXNzIHN0e31jbGFzcyBpdCBleHRlbmRzIFh7Y29uc3RydWN0b3IoKXtzdXBlcigpLGl0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NoZWxsPW51bGwsdGhpcy5faG9sZXM9bnVsbDtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoWC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG4pLG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKCkpLG51bGw9PT1lJiYoZT1bXSksWC5oYXNOdWxsRWxlbWVudHMoZSkpdGhyb3cgbmV3IHMoXCJob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7aWYodC5pc0VtcHR5KCkmJlguaGFzTm9uRW1wdHlFbGVtZW50cyhlKSl0aHJvdyBuZXcgcyhcInNoZWxsIGlzIGVtcHR5IGJ1dCBob2xlcyBhcmUgbm90XCIpO3RoaXMuX3NoZWxsPXQsdGhpcy5faG9sZXM9ZX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe3JldHVybiB0aGlzLl9zaGVsbC5nZXRFbnZlbG9wZUludGVybmFsKCl9Z2V0Q29vcmRpbmF0ZXMoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm5bXTtjb25zdCB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO2xldCBlPS0xO2NvbnN0IG49dGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyllKyssdFtlXT1uW3NdO2ZvcihsZXQgbj0wO248dGhpcy5faG9sZXMubGVuZ3RoO24rKyl7Y29uc3Qgcz10aGlzLl9ob2xlc1tuXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKWUrKyx0W2VdPXNbbl19cmV0dXJuIHR9Z2V0QXJlYSgpe2xldCB0PTA7dCs9ZXQub2ZSaW5nKHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdC09ZXQub2ZSaW5nKHRoaXMuX2hvbGVzW2VdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtyZXR1cm4gdH1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX3NoZWxsLmNvcHkoKSxlPW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKWVbdF09dGhpcy5faG9sZXNbdF0uY29weSgpO3JldHVybiBuZXcgaXQodCxlLHRoaXMuX2ZhY3RvcnkpfWlzUmVjdGFuZ2xlKCl7aWYoMCE9PXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCkpcmV0dXJuITE7aWYobnVsbD09PXRoaXMuX3NoZWxsKXJldHVybiExO2lmKDUhPT10aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKSlyZXR1cm4hMTtjb25zdCB0PXRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLGU9dGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCk7Zm9yKGxldCBuPTA7bjw1O24rKyl7Y29uc3Qgcz10LmdldFgobik7aWYocyE9PWUuZ2V0TWluWCgpJiZzIT09ZS5nZXRNYXhYKCkpcmV0dXJuITE7Y29uc3QgaT10LmdldFkobik7aWYoaSE9PWUuZ2V0TWluWSgpJiZpIT09ZS5nZXRNYXhZKCkpcmV0dXJuITF9bGV0IG49dC5nZXRYKDApLHM9dC5nZXRZKDApO2ZvcihsZXQgZT0xO2U8PTQ7ZSsrKXtjb25zdCBpPXQuZ2V0WChlKSxyPXQuZ2V0WShlKTtpZihpIT09bj09PShyIT09cykpcmV0dXJuITE7bj1pLHM9cn1yZXR1cm4hMH1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO2NvbnN0IG49dCxzPXRoaXMuX3NoZWxsLGk9bi5fc2hlbGw7aWYoIXMuZXF1YWxzRXhhY3QoaSxlKSlyZXR1cm4hMTtpZih0aGlzLl9ob2xlcy5sZW5ndGghPT1uLl9ob2xlcy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5sZW5ndGg7dCsrKWlmKCF0aGlzLl9ob2xlc1t0XS5lcXVhbHNFeGFjdChuLl9ob2xlc1t0XSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLl9zaGVsbD10aGlzLm5vcm1hbGl6ZWQodGhpcy5fc2hlbGwsITApO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMubGVuZ3RoO3QrKyl0aGlzLl9ob2xlc1t0XT10aGlzLm5vcm1hbGl6ZWQodGhpcy5faG9sZXNbdF0sITEpO250LnNvcnQodGhpcy5faG9sZXMpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxzPVoubWluQ29vcmRpbmF0ZUluZGV4KG4sMCxuLnNpemUoKS0yKTtaLnNjcm9sbChuLHMsITApLEcuaXNDQ1cobik9PT1lJiZaLnJldmVyc2Uobil9fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZSgpfWdldE51bUludGVyaW9yUmluZygpe3JldHVybiB0aGlzLl9ob2xlcy5sZW5ndGh9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gMX1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkucmV2ZXJzZSgpLGU9bmV3IEFycmF5KHRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCkpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspZVt0XT10aGlzLmdldEludGVyaW9yUmluZ04odCkucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKHQsZSl9Z2V0VHlwZUNvZGUoKXtyZXR1cm4gWC5UWVBFQ09ERV9QT0xZR09OfWdldERpbWVuc2lvbigpe3JldHVybiAyfWdldExlbmd0aCgpe2xldCB0PTA7dCs9dGhpcy5fc2hlbGwuZ2V0TGVuZ3RoKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2hvbGVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fWdldE51bVBvaW50cygpe2xldCB0PXRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9ob2xlc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH1jb252ZXhIdWxsKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpfW5vcm1hbGl6ZWQodCxlKXtjb25zdCBuPXQuY29weSgpO3JldHVybiB0aGlzLm5vcm1hbGl6ZShuLGUpLG59Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fc2hlbGwsbj10Ll9zaGVsbDtyZXR1cm4gZS5jb21wYXJlVG9TYW1lQ2xhc3Mobil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLG49dGhpcy5fc2hlbGwscz1lLl9zaGVsbCxpPW4uY29tcGFyZVRvU2FtZUNsYXNzKHMsdCk7aWYoMCE9PWkpcmV0dXJuIGk7Y29uc3Qgcj10aGlzLmdldE51bUludGVyaW9yUmluZygpLG89ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtsZXQgbD0wO2Zvcig7bDxyJiZsPG87KXtjb25zdCBuPXRoaXMuZ2V0SW50ZXJpb3JSaW5nTihsKSxzPWUuZ2V0SW50ZXJpb3JSaW5nTihsKSxpPW4uY29tcGFyZVRvU2FtZUNsYXNzKHMsdCk7aWYoMCE9PWkpcmV0dXJuIGk7bCsrfXJldHVybiBsPHI/MTpsPG8/LTE6MH19YXBwbHkoKXtpZihJKGFyZ3VtZW50c1swXSxVKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2hlbGwuYXBwbHkodCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUCkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX3NoZWxsLmFwcGx5KHQpLCF0LmlzRG9uZSgpKWZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoJiYodGhpcy5faG9sZXNbZV0uYXBwbHkodCksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sUSkpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxrKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyksdGhpcy5fc2hlbGwuYXBwbHkodCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpfX1nZXRCb3VuZGFyeSgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgrMSkuZmlsbChudWxsKTt0WzBdPXRoaXMuX3NoZWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0W2UrMV09dGhpcy5faG9sZXNbZV07cmV0dXJuIHQubGVuZ3RoPD0xP3RoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodFswXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk6dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBYLlRZUEVOQU1FX1BPTFlHT059Z2V0RXh0ZXJpb3JSaW5nKCl7cmV0dXJuIHRoaXMuX3NoZWxsfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fc2hlbGwuaXNFbXB0eSgpfWdldEludGVyaW9yUmluZ04odCl7cmV0dXJuIHRoaXMuX2hvbGVzW3RdfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltzdF19fWNsYXNzIHJ0IGV4dGVuZHMgTntjb250YWlucygpe319Y2xhc3Mgb3QgZXh0ZW5kcyBydHt9Y2xhc3MgbHQgZXh0ZW5kcyBvdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuYXJyYXk9W10sdCBpbnN0YW5jZW9mIE4mJnRoaXMuYWRkQWxsKHQpfWNvbnRhaW5zKHQpe2Zvcihjb25zdCBlIG9mIHRoaXMuYXJyYXkpaWYoMD09PWUuY29tcGFyZVRvKHQpKXJldHVybiEwO3JldHVybiExfWFkZCh0KXtpZih0aGlzLmNvbnRhaW5zKHQpKXJldHVybiExO2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheS5sZW5ndGg7ZTxuO2UrKyl7aWYoMT09PXRoaXMuYXJyYXlbZV0uY29tcGFyZVRvKHQpKXJldHVybiEhdGhpcy5hcnJheS5zcGxpY2UoZSwwLHQpfXJldHVybiB0aGlzLmFycmF5LnB1c2godCksITB9YWRkQWxsKHQpe2Zvcihjb25zdCBlIG9mIHQpdGhpcy5hZGQoZSk7cmV0dXJuITB9cmVtb3ZlKCl7dGhyb3cgbmV3IGp9c2l6ZSgpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aH1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Lmxlbmd0aH10b0FycmF5KCl7cmV0dXJuIHRoaXMuYXJyYXkuc2xpY2UoKX1pdGVyYXRvcigpe3JldHVybiBuZXcgYXQodGhpcy5hcnJheSl9fWNsYXNzIGF0e2NvbnN0cnVjdG9yKHQpe3RoaXMuYXJyYXk9dCx0aGlzLnBvc2l0aW9uPTB9bmV4dCgpe2lmKHRoaXMucG9zaXRpb249PT10aGlzLmFycmF5Lmxlbmd0aCl0aHJvdyBuZXcgQztyZXR1cm4gdGhpcy5hcnJheVt0aGlzLnBvc2l0aW9uKytdfWhhc05leHQoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbjx0aGlzLmFycmF5Lmxlbmd0aH1yZW1vdmUoKXt0aHJvdyBuZXcgan19Y2xhc3MgY3QgZXh0ZW5kcyBYe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxjdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tZXRyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihYLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksbnVsbD09PXQmJih0PVtdKSxYLmhhc051bGxFbGVtZW50cyh0KSl0aHJvdyBuZXcgcyhcImdlb21ldHJpZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO3RoaXMuX2dlb21ldHJpZXM9dH19Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtjb25zdCB0PW5ldyBPO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gdH1nZXRHZW9tZXRyeU4odCl7cmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbdF19Z2V0Q29vcmRpbmF0ZXMoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO2xldCBlPS0xO2ZvcihsZXQgbj0wO248dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKXtjb25zdCBzPXRoaXMuX2dlb21ldHJpZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyllKyssdFtlXT1zW25dfXJldHVybiB0fWdldEFyZWEoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0QXJlYSgpO3JldHVybiB0fWNvcHlJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBjdCh0LHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10O2lmKHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoIT09bi5fZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uZXF1YWxzRXhhY3Qobi5fZ2VvbWV0cmllc1t0XSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7dCsrKXRoaXMuX2dlb21ldHJpZXNbdF0ubm9ybWFsaXplKCk7bnQuc29ydCh0aGlzLl9nZW9tZXRyaWVzKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5fZ2VvbWV0cmllc1swXS5nZXRDb29yZGluYXRlKCl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtsZXQgdD1LLkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpO3JldHVybiB0fXJldmVyc2VJbnRlcm5hbCgpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgTCh0KTtmb3IobGV0IG49MDtuPHQ7bisrKWUuYWRkKHRoaXMuX2dlb21ldHJpZXNbbl0ucmV2ZXJzZSgpKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShlKX1nZXRUeXBlQ29kZSgpe3JldHVybiBYLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTn1nZXREaW1lbnNpb24oKXtsZXQgdD1LLkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldERpbWVuc2lvbigpKTtyZXR1cm4gdH1nZXRMZW5ndGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9Z2V0TnVtUG9pbnRzKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fWdldE51bUdlb21ldHJpZXMoKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGh9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IGx0KG50LmFzTGlzdCh0aGlzLl9nZW9tZXRyaWVzKSksbj1uZXcgbHQobnQuYXNMaXN0KHQuX2dlb21ldHJpZXMpKTtyZXR1cm4gdGhpcy5jb21wYXJlKGUsbil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLG49dGhpcy5nZXROdW1HZW9tZXRyaWVzKCkscz1lLmdldE51bUdlb21ldHJpZXMoKTtsZXQgaT0wO2Zvcig7aTxuJiZpPHM7KXtjb25zdCBuPXRoaXMuZ2V0R2VvbWV0cnlOKGkpLHM9ZS5nZXRHZW9tZXRyeU4oaSkscj1uLmNvbXBhcmVUb1NhbWVDbGFzcyhzLHQpO2lmKDAhPT1yKXJldHVybiByO2krK31yZXR1cm4gaTxuPzE6aTxzPy0xOjB9fWFwcGx5KCl7aWYoSShhcmd1bWVudHNbMF0sVSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxQKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgmJih0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLFEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0saykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIFguY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksZy5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFguVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OfWlzRW1wdHkoKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5pc0VtcHR5KCkpcmV0dXJuITE7cmV0dXJuITB9fWNsYXNzIGh0IGV4dGVuZHMgY3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLGh0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2N0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgaHQodCx0aGlzLl9mYWN0b3J5KX1pc1ZhbGlkKCl7cmV0dXJuITB9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJnN1cGVyLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9nZW9tZXRyaWVzW3RdLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gc3VwZXIuZ2V0Q29vcmRpbmF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Qm91bmRhcnlEaW1lbnNpb24oKXtyZXR1cm4gSy5GQUxTRX1nZXRUeXBlQ29kZSgpe3JldHVybiBYLlRZUEVDT0RFX01VTFRJUE9JTlR9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDB9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFguVFlQRU5BTUVfTVVMVElQT0lOVH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bJF19fWNsYXNzIHV0IGV4dGVuZHMgSntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Si5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy52YWxpZGF0ZUNvbnN0cnVjdGlvbigpfWNvcHlJbnRlcm5hbCgpe3JldHVybiBuZXcgdXQodGhpcy5fcG9pbnRzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiBLLkZBTFNFfWlzQ2xvc2VkKCl7cmV0dXJuISF0aGlzLmlzRW1wdHkoKXx8c3VwZXIuaXNDbG9zZWQuY2FsbCh0aGlzKX1yZXZlcnNlSW50ZXJuYWwoKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7cmV0dXJuIFoucmV2ZXJzZSh0KSx0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHQpfWdldFR5cGVDb2RlKCl7cmV0dXJuIFguVFlQRUNPREVfTElORUFSUklOR312YWxpZGF0ZUNvbnN0cnVjdGlvbigpe2lmKCF0aGlzLmlzRW1wdHkoKSYmIXN1cGVyLmlzQ2xvc2VkLmNhbGwodGhpcykpdGhyb3cgbmV3IHMoXCJQb2ludHMgb2YgTGluZWFyUmluZyBkbyBub3QgZm9ybSBhIGNsb3NlZCBsaW5lc3RyaW5nXCIpO2lmKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPj0xJiZ0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKTx1dC5NSU5JTVVNX1ZBTElEX1NJWkUpdGhyb3cgbmV3IHMoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZWFyUmluZyAoZm91bmQgXCIrdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gNClcIil9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFguVFlQRU5BTUVfTElORUFSUklOR319dXQuTUlOSU1VTV9WQUxJRF9TSVpFPTQ7Y2xhc3MgZ3R7c3RhdGljIG1lYXN1cmVzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgeT8wOnQgaW5zdGFuY2VvZiB4fHx0IGluc3RhbmNlb2YgRT8xOjB9c3RhdGljIGRpbWVuc2lvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHk/Mjp0IGluc3RhbmNlb2YgeD8zOnQgaW5zdGFuY2VvZiBFPzQ6M31zdGF0aWMgY3JlYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBndC5jcmVhdGUodCwwKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIDI9PT10P25ldyB5OjM9PT10JiYwPT09ZT9uZXcgbTozPT09dCYmMT09PWU/bmV3IHg6ND09PXQmJjE9PT1lP25ldyBFOm5ldyBtfX19Y2xhc3MgZHR7c3RhdGljIGlzUmluZyh0KXtyZXR1cm4hKHQubGVuZ3RoPDQpJiYhIXRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9c3RhdGljIHB0Tm90SW5MaXN0KHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHM9dFtuXTtpZihkdC5pbmRleE9mKHMsZSk8MClyZXR1cm4gc31yZXR1cm4gbnVsbH1zdGF0aWMgc2Nyb2xsKHQsZSl7Y29uc3Qgbj1kdC5pbmRleE9mKGUsdCk7aWYobjwwKXJldHVybiBudWxsO2NvbnN0IHM9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO0IuYXJyYXljb3B5KHQsbixzLDAsdC5sZW5ndGgtbiksQi5hcnJheWNvcHkodCwwLHMsdC5sZW5ndGgtbixuKSxCLmFycmF5Y29weShzLDAsdCwwLHQubGVuZ3RoKX1zdGF0aWMgZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09PXR8fG51bGw9PT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspaWYoMCE9PW4uY29tcGFyZSh0W3NdLGVbc10pKXJldHVybiExO3JldHVybiEwfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgUjtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyllLmludGVyc2VjdHModFtzXSkmJm4uYWRkKHRbc10sITApO3JldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIG1lYXN1cmVzKHQpe2lmKG51bGw9PT10fHwwPT09dC5sZW5ndGgpcmV0dXJuIDA7bGV0IGU9MDtmb3IoY29uc3QgbiBvZiB0KWU9TWF0aC5tYXgoZSxndC5tZWFzdXJlcyhuKSk7cmV0dXJuIGV9c3RhdGljIGhhc1JlcGVhdGVkUG9pbnRzKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZS0xXS5lcXVhbHModFtlXSkpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIHJlbW92ZVJlcGVhdGVkUG9pbnRzKHQpe2lmKCFkdC5oYXNSZXBlYXRlZFBvaW50cyh0KSlyZXR1cm4gdDtyZXR1cm4gbmV3IFIodCwhMSkudG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQubGVuZ3RoLTEsbj1NYXRoLnRydW5jKGUvMik7Zm9yKGxldCBzPTA7czw9bjtzKyspe2NvbnN0IG49dFtzXTt0W3NdPXRbZS1zXSx0W2Utc109bn19c3RhdGljIHJlbW92ZU51bGwodCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyludWxsIT09dFtuXSYmZSsrO2NvbnN0IG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7aWYoMD09PWUpcmV0dXJuIG47bGV0IHM9MDtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyludWxsIT09dFtlXSYmKG5bcysrXT10W2VdKTtyZXR1cm4gbn1zdGF0aWMgY29weURlZXAoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT10W25dLmNvcHkoKTtyZXR1cm4gZX1pZig1PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF07Zm9yKGxldCByPTA7cjxpO3IrKyluW3Mrcl09dFtlK3JdLmNvcHkoKX19c3RhdGljIGlzRXF1YWxSZXZlcnNlZCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl0saT1lW3QubGVuZ3RoLW4tMV07aWYoMCE9PXMuY29tcGFyZVRvKGkpKXJldHVybiExfXJldHVybiEwfXN0YXRpYyBlbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBPO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWUuZXhwYW5kVG9JbmNsdWRlKHRbbl0pO3JldHVybiBlfXN0YXRpYyB0b0Nvb3JkaW5hdGVBcnJheSh0KXtyZXR1cm4gdC50b0FycmF5KGR0LmNvb3JkQXJyYXlUeXBlKX1zdGF0aWMgZGltZW5zaW9uKHQpe2lmKG51bGw9PT10fHwwPT09dC5sZW5ndGgpcmV0dXJuIDM7bGV0IGU9MDtmb3IoY29uc3QgbiBvZiB0KWU9TWF0aC5tYXgoZSxndC5kaW1lbnNpb24obikpO3JldHVybiBlfXN0YXRpYyBhdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nKHQsZSl7cmV0dXJuIGUubGVuZ3RoPj10P2U6W119c3RhdGljIGluZGV4T2YodCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylpZih0LmVxdWFscyhlW25dKSlyZXR1cm4gbjtyZXR1cm4tMX1zdGF0aWMgaW5jcmVhc2luZ0RpcmVjdGlvbih0KXtmb3IobGV0IGU9MDtlPE1hdGgudHJ1bmModC5sZW5ndGgvMik7ZSsrKXtjb25zdCBuPXQubGVuZ3RoLTEtZSxzPXRbZV0uY29tcGFyZVRvKHRbbl0pO2lmKDAhPT1zKXJldHVybiBzfXJldHVybiAxfXN0YXRpYyBjb21wYXJlKHQsZSl7bGV0IG49MDtmb3IoO248dC5sZW5ndGgmJm48ZS5sZW5ndGg7KXtjb25zdCBzPXRbbl0uY29tcGFyZVRvKGVbbl0pO2lmKDAhPT1zKXJldHVybiBzO24rK31yZXR1cm4gbjxlLmxlbmd0aD8tMTpuPHQubGVuZ3RoPzE6MH1zdGF0aWMgbWluQ29vcmRpbmF0ZSh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKShudWxsPT09ZXx8ZS5jb21wYXJlVG8odFtuXSk+MCkmJihlPXRbbl0pO3JldHVybiBlfXN0YXRpYyBleHRyYWN0KHQsZSxuKXtlPVkuY2xhbXAoZSwwLHQubGVuZ3RoKTtsZXQgcz0obj1ZLmNsYW1wKG4sLTEsdC5sZW5ndGgpKS1lKzE7bjwwJiYocz0wKSxlPj10Lmxlbmd0aCYmKHM9MCksbjxlJiYocz0wKTtjb25zdCBpPW5ldyBBcnJheShzKS5maWxsKG51bGwpO2lmKDA9PT1zKXJldHVybiBpO2xldCByPTA7Zm9yKGxldCBzPWU7czw9bjtzKyspaVtyKytdPXRbc107cmV0dXJuIGl9fWR0LkZvcndhcmRDb21wYXJhdG9yPWNsYXNze2NvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO3JldHVybiBkdC5jb21wYXJlKG4scyl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX0sZHQuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I9Y2xhc3N7Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7aWYobi5sZW5ndGg8cy5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+cy5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2NvbnN0IGk9ZHQuY29tcGFyZShuLHMpO3JldHVybiBkdC5pc0VxdWFsUmV2ZXJzZWQobixzKT8wOml9T0xEY29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7aWYobi5sZW5ndGg8cy5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+cy5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2NvbnN0IGk9ZHQuaW5jcmVhc2luZ0RpcmVjdGlvbihuKSxyPWR0LmluY3JlYXNpbmdEaXJlY3Rpb24ocyk7bGV0IG89aT4wPzA6bi5sZW5ndGgtMSxsPXI+MD8wOm4ubGVuZ3RoLTE7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IHQ9bltvXS5jb21wYXJlVG8oc1tsXSk7aWYoMCE9PXQpcmV0dXJuIHQ7bys9aSxsKz1yfXJldHVybiAwfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19LGR0LmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIF90e2NvbnN0cnVjdG9yKHQpe3RoaXMuc3RyPXR9YXBwZW5kKHQpe3RoaXMuc3RyKz10fXNldENoYXJBdCh0LGUpe3RoaXMuc3RyPXRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5zdHJ9fWNsYXNzIHB0e2NvbnN0cnVjdG9yKCl7cHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGltZW5zaW9uPTMsdGhpcy5fbWVhc3VyZXM9MCx0aGlzLl9jb29yZGluYXRlcz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtwdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZHQuZGltZW5zaW9uKHQpLGR0Lm1lYXN1cmVzKHQpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCBlPTA7ZTx0O2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT1uZXcgbX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLEYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dClyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDt0aGlzLl9kaW1lbnNpb249dC5nZXREaW1lbnNpb24oKSx0aGlzLl9tZWFzdXJlcz10LmdldE1lYXN1cmVzKCksdGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT10LmdldENvb3JkaW5hdGVDb3B5KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3B0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLGR0Lm1lYXN1cmVzKHQpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLl9kaW1lbnNpb249ZTtmb3IobGV0IG49MDtuPHQ7bisrKXRoaXMuX2Nvb3JkaW5hdGVzW25dPWd0LmNyZWF0ZShlKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZGltZW5zaW9uPWUsdGhpcy5fbWVhc3VyZXM9bix0aGlzLl9jb29yZGluYXRlcz1udWxsPT09dD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTp0fWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5fZGltZW5zaW9uPWUsdGhpcy5fbWVhc3VyZXM9bjtmb3IobGV0IGU9MDtlPHQ7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPXRoaXMuY3JlYXRlQ29vcmRpbmF0ZSgpfX1nZXRNKHQpe3JldHVybiB0aGlzLmhhc00oKT90aGlzLl9jb29yZGluYXRlc1t0XS5nZXRNKCk6ci5OYU59c2V0T3JkaW5hdGUodCxlLG4pe3N3aXRjaChlKXtjYXNlIEYuWDp0aGlzLl9jb29yZGluYXRlc1t0XS54PW47YnJlYWs7Y2FzZSBGLlk6dGhpcy5fY29vcmRpbmF0ZXNbdF0ueT1uO2JyZWFrO2RlZmF1bHQ6dGhpcy5fY29vcmRpbmF0ZXNbdF0uc2V0T3JkaW5hdGUoZSxuKX19Z2V0Wih0KXtyZXR1cm4gdGhpcy5oYXNaKCk/dGhpcy5fY29vcmRpbmF0ZXNbdF0uZ2V0WigpOnIuTmFOfXNpemUoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RofWdldE9yZGluYXRlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgRi5YOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS54O2Nhc2UgRi5ZOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS55O2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW3RdLmdldE9yZGluYXRlKGUpfX1nZXRDb29yZGluYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07YXJndW1lbnRzWzFdLnNldENvb3JkaW5hdGUodGhpcy5fY29vcmRpbmF0ZXNbdF0pfX1nZXRDb29yZGluYXRlQ29weSh0KXtjb25zdCBlPXRoaXMuY3JlYXRlQ29vcmRpbmF0ZSgpO3JldHVybiBlLnNldENvb3JkaW5hdGUodGhpcy5fY29vcmRpbmF0ZXNbdF0pLGV9Y3JlYXRlQ29vcmRpbmF0ZSgpe3JldHVybiBndC5jcmVhdGUodGhpcy5nZXREaW1lbnNpb24oKSx0aGlzLmdldE1lYXN1cmVzKCkpfWdldERpbWVuc2lvbigpe3JldHVybiB0aGlzLl9kaW1lbnNpb259Z2V0WCh0KXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueH1nZXRNZWFzdXJlcygpe3JldHVybiB0aGlzLl9tZWFzdXJlc31leHBhbmRFbnZlbG9wZSh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0fWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5jcmVhdGVDb29yZGluYXRlKCk7bi5zZXRDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKSx0W2VdPW59cmV0dXJuIG5ldyBwdCh0LHRoaXMuX2RpbWVuc2lvbix0aGlzLl9tZWFzdXJlcyl9dG9TdHJpbmcoKXtpZih0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg+MCl7Y29uc3QgdD1uZXcgX3QoMTcqdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoKTt0LmFwcGVuZChcIihcIiksdC5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbMF0pO2ZvcihsZXQgZT0xO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmFwcGVuZChcIiwgXCIpLHQuYXBwZW5kKHRoaXMuX2Nvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdC5hcHBlbmQoXCIpXCIpLHQudG9TdHJpbmcoKX1yZXR1cm5cIigpXCJ9Z2V0WSh0KXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbdF0ueX10b0Nvb3JkaW5hdGVBcnJheSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRixjXX19Y2xhc3MgbXR7c3RhdGljIGluc3RhbmNlKCl7cmV0dXJuIG10Lmluc3RhbmNlT2JqZWN0fXJlYWRSZXNvbHZlKCl7cmV0dXJuIG10Lmluc3RhbmNlKCl9Y3JlYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3JldHVybiBuZXcgcHQoYXJndW1lbnRzWzBdKX1pZihJKGFyZ3VtZW50c1swXSxGKSl7cmV0dXJuIG5ldyBwdChhcmd1bWVudHNbMF0pfX1lbHNle2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMV07cmV0dXJuIHQ+MyYmKHQ9MyksdDwyJiYodD0yKSxuZXcgcHQoYXJndW1lbnRzWzBdLHQpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMl0sZT1hcmd1bWVudHNbMV0tdDtyZXR1cm4gdD4xJiYodD0xKSxlPjMmJihlPTMpLGU8MiYmKGU9MiksbmV3IHB0KGFyZ3VtZW50c1swXSxlK3QsdCl9fX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5beixjXX19bXQuaW5zdGFuY2VPYmplY3Q9bmV3IG10O2NsYXNzIGZ0IGV4dGVuZHMgY3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLGZ0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2N0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKX1jb3B5SW50ZXJuYWwoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgZnQodCx0aGlzLl9mYWN0b3J5KX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiAxfWdldFR5cGVDb2RlKCl7cmV0dXJuIFguVFlQRUNPREVfTVVMVElQT0xZR09OfWdldERpbWVuc2lvbigpe3JldHVybiAyfWdldEJvdW5kYXJ5KCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2NvbnN0IHQ9bmV3IEw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeSgpO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXQuYWRkKG4uZ2V0R2VvbWV0cnlOKGUpKX1jb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQudG9BcnJheShlKSl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFguVFlQRU5BTUVfTVVMVElQT0xZR09OfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltzdF19fWNsYXNzIHl0e2dldCgpe31wdXQoKXt9c2l6ZSgpe312YWx1ZXMoKXt9ZW50cnlTZXQoKXt9fWNsYXNzIHh0IGV4dGVuZHMgcnR7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLm1hcD1uZXcgTWFwLHQgaW5zdGFuY2VvZiBOJiZ0aGlzLmFkZEFsbCh0KX1jb250YWlucyh0KXtjb25zdCBlPXQuaGFzaENvZGU/dC5oYXNoQ29kZSgpOnQ7cmV0dXJuISF0aGlzLm1hcC5oYXMoZSl9YWRkKHQpe2NvbnN0IGU9dC5oYXNoQ29kZT90Lmhhc2hDb2RlKCk6dDtyZXR1cm4hdGhpcy5tYXAuaGFzKGUpJiYhIXRoaXMubWFwLnNldChlLHQpfWFkZEFsbCh0KXtmb3IoY29uc3QgZSBvZiB0KXRoaXMuYWRkKGUpO3JldHVybiEwfXJlbW92ZSgpe3Rocm93IG5ldyBqfXNpemUoKXtyZXR1cm4gdGhpcy5tYXAuc2l6ZX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLm1hcC5zaXplfXRvQXJyYXkoKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1hcC52YWx1ZXMoKSl9aXRlcmF0b3IoKXtyZXR1cm4gbmV3IEV0KHRoaXMubWFwKX1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLm1hcH19Y2xhc3MgRXR7Y29uc3RydWN0b3IodCl7dGhpcy5pdGVyYXRvcj10LnZhbHVlcygpO2NvbnN0e2RvbmU6ZSx2YWx1ZTpufT10aGlzLml0ZXJhdG9yLm5leHQoKTt0aGlzLmRvbmU9ZSx0aGlzLnZhbHVlPW59bmV4dCgpe2lmKHRoaXMuZG9uZSl0aHJvdyBuZXcgQztjb25zdCB0PXRoaXMudmFsdWUse2RvbmU6ZSx2YWx1ZTpufT10aGlzLml0ZXJhdG9yLm5leHQoKTtyZXR1cm4gdGhpcy5kb25lPWUsdGhpcy52YWx1ZT1uLHR9aGFzTmV4dCgpe3JldHVybiF0aGlzLmRvbmV9cmVtb3ZlKCl7dGhyb3cgbmV3IGp9fWNsYXNzIEl0IGV4dGVuZHMgeXR7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMubWFwPW5ldyBNYXB9Z2V0KHQpe3JldHVybiB0aGlzLm1hcC5nZXQodCl8fG51bGx9cHV0KHQsZSl7cmV0dXJuIHRoaXMubWFwLnNldCh0LGUpLGV9dmFsdWVzKCl7Y29uc3QgdD1uZXcgTCxlPXRoaXMubWFwLnZhbHVlcygpO2xldCBuPWUubmV4dCgpO2Zvcig7IW4uZG9uZTspdC5hZGQobi52YWx1ZSksbj1lLm5leHQoKTtyZXR1cm4gdH1lbnRyeVNldCgpe2NvbnN0IHQ9bmV3IHh0O3JldHVybiB0aGlzLm1hcC5lbnRyaWVzKCkuZm9yRWFjaCgoZT0+dC5hZGQoZSkpKSx0fXNpemUoKXtyZXR1cm4gdGhpcy5tYXAuc2l6ZSgpfX1jbGFzcyBOdHtjb25zdHJ1Y3Rvcigpe050LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX21vZGVsVHlwZT1udWxsLHRoaXMuX3NjYWxlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbW9kZWxUeXBlPU50LkZMT0FUSU5HO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXQsdD09PU50LkZJWEVEJiZ0aGlzLnNldFNjYWxlKDEpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPU50LkZJWEVELHRoaXMuc2V0U2NhbGUodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE50KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9dC5fbW9kZWxUeXBlLHRoaXMuX3NjYWxlPXQuX3NjYWxlfX1zdGF0aWMgbW9zdFByZWNpc2UodCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSk+PTA/dDplfWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBOdCkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1lLl9tb2RlbFR5cGUmJnRoaXMuX3NjYWxlPT09ZS5fc2NhbGV9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dCxuPXRoaXMuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCkscz1lLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO3JldHVybiBNLmNvbXBhcmUobixzKX1nZXRTY2FsZSgpe3JldHVybiB0aGlzLl9zY2FsZX1pc0Zsb2F0aW5nKCl7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PU50LkZMT0FUSU5HfHx0aGlzLl9tb2RlbFR5cGU9PT1OdC5GTE9BVElOR19TSU5HTEV9Z2V0VHlwZSgpe3JldHVybiB0aGlzLl9tb2RlbFR5cGV9dG9TdHJpbmcoKXtsZXQgdD1cIlVOS05PV05cIjtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09TnQuRkxPQVRJTkc/dD1cIkZsb2F0aW5nXCI6dGhpcy5fbW9kZWxUeXBlPT09TnQuRkxPQVRJTkdfU0lOR0xFP3Q9XCJGbG9hdGluZy1TaW5nbGVcIjp0aGlzLl9tb2RlbFR5cGU9PT1OdC5GSVhFRCYmKHQ9XCJGaXhlZCAoU2NhbGU9XCIrdGhpcy5nZXRTY2FsZSgpK1wiKVwiKSx0fW1ha2VQcmVjaXNlKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoci5pc05hTih0KSlyZXR1cm4gdDtpZih0aGlzLl9tb2RlbFR5cGU9PT1OdC5GTE9BVElOR19TSU5HTEUpe3JldHVybiB0fXJldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1OdC5GSVhFRD9NYXRoLnJvdW5kKHQqdGhpcy5fc2NhbGUpL3RoaXMuX3NjYWxlOnR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLl9tb2RlbFR5cGU9PT1OdC5GTE9BVElORylyZXR1cm4gbnVsbDt0Lng9dGhpcy5tYWtlUHJlY2lzZSh0LngpLHQueT10aGlzLm1ha2VQcmVjaXNlKHQueSl9fWdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpe2xldCB0PTE2O3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1OdC5GTE9BVElORz90PTE2OnRoaXMuX21vZGVsVHlwZT09PU50LkZMT0FUSU5HX1NJTkdMRT90PTY6dGhpcy5fbW9kZWxUeXBlPT09TnQuRklYRUQmJih0PTErTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5sb2codGhpcy5nZXRTY2FsZSgpKS9NYXRoLmxvZygxMCkpKSksdH1zZXRTY2FsZSh0KXt0aGlzLl9zY2FsZT1NYXRoLmFicyh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYyxvXX19Y2xhc3MgU3R7Y29uc3RydWN0b3IoKXtTdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9uYW1lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbmFtZT10LFN0Lm5hbWVUb1R5cGVNYXAucHV0KHQsdGhpcyl9cmVhZFJlc29sdmUoKXtyZXR1cm4gU3QubmFtZVRvVHlwZU1hcC5nZXQodGhpcy5fbmFtZSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5fbmFtZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bY119fVN0Lm5hbWVUb1R5cGVNYXA9bmV3IEl0LE50LlR5cGU9U3QsTnQuRklYRUQ9bmV3IFN0KFwiRklYRURcIiksTnQuRkxPQVRJTkc9bmV3IFN0KFwiRkxPQVRJTkdcIiksTnQuRkxPQVRJTkdfU0lOR0xFPW5ldyBTdChcIkZMT0FUSU5HIFNJTkdMRVwiKSxOdC5tYXhpbXVtUHJlY2lzZVZhbHVlPTkwMDcxOTkyNTQ3NDA5OTI7Y2xhc3Mgd3QgZXh0ZW5kcyBjdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksd3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Y3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfWNvcHlJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5fZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyB3dCh0LHRoaXMuX2ZhY3RvcnkpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9LLkZBTFNFOjB9aXNDbG9zZWQoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5pc0Nsb3NlZCgpKXJldHVybiExO3JldHVybiEwfWdldFR5cGVDb2RlKCl7cmV0dXJuIFguVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HfWdldERpbWVuc2lvbigpe3JldHVybiAxfWdldEJvdW5kYXJ5KCl7dGhyb3cgbmV3IGp9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIFguVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltXXX19Y2xhc3MgQ3R7Y29uc3RydWN0b3IoKXtDdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bnVsbCx0aGlzLl9TUklEPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpQ3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgTnQsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0seikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0N0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IE50LDAsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE50KXtjb25zdCB0PWFyZ3VtZW50c1swXTtDdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMCxDdC5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Q3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsQ3QuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW4sdGhpcy5fU1JJRD1lfX1zdGF0aWMgdG9NdWx0aVBvbHlnb25BcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0dlb21ldHJ5QXJyYXkodCl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKXtyZXR1cm4gbXQuaW5zdGFuY2UoKX1zdGF0aWMgdG9NdWx0aUxpbmVTdHJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0xpbmVTdHJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b011bHRpUG9pbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b0xpbmVhclJpbmdBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b1BvaW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgdG9Qb2x5Z29uQXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX1zdGF0aWMgY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9Y3JlYXRlRW1wdHkodCl7c3dpdGNoKHQpe2Nhc2UtMTpyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtjYXNlIDA6cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQoKTtjYXNlIDE6cmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMjpyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKCk7ZGVmYXVsdDp0aHJvdyBuZXcgcyhcIkludmFsaWQgZGltZW5zaW9uOiBcIit0KX19dG9HZW9tZXRyeSh0KXtyZXR1cm4gdC5pc051bGwoKT90aGlzLmNyZWF0ZVBvaW50KCk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKSYmdC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZVBvaW50KG5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKXx8dC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgbSh0LmdldE1heFgoKSx0LmdldE1heFkoKSldKTp0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IG0odC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLG5ldyBtKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSxuZXcgbSh0LmdldE1heFgoKSx0LmdldE1pblkoKSksbmV3IG0odC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpXSksbnVsbCl9Y3JlYXRlTGluZVN0cmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKEkoYXJndW1lbnRzWzBdLEYpKXtyZXR1cm4gbmV3IEooYXJndW1lbnRzWzBdLHRoaXMpfX19Y3JlYXRlTXVsdGlMaW5lU3RyaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyB3dChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IHd0KGFyZ3VtZW50c1swXSx0aGlzKX19YnVpbGRHZW9tZXRyeSh0KXtsZXQgZT1udWxsLG49ITEscz0hMTtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPXQuZ2V0VHlwZUNvZGUoKTtudWxsPT09ZSYmKGU9ciksciE9PWUmJihuPSEwKSx0IGluc3RhbmNlb2YgY3QmJihzPSEwKX1pZihudWxsPT09ZSlyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtpZihufHxzKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihDdC50b0dlb21ldHJ5QXJyYXkodCkpO2NvbnN0IGk9dC5pdGVyYXRvcigpLm5leHQoKTtpZih0LnNpemUoKT4xKXtpZihpIGluc3RhbmNlb2YgaXQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2x5Z29uKEN0LnRvUG9seWdvbkFycmF5KHQpKTtpZihpIGluc3RhbmNlb2YgSilyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoQ3QudG9MaW5lU3RyaW5nQXJyYXkodCkpO2lmKGkgaW5zdGFuY2VvZiB0dClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KEN0LnRvUG9pbnRBcnJheSh0KSk7Zy5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuaGFuZGxlZCBnZW9tZXRyeSB0eXBlOiBcIitpLmdldEdlb21ldHJ5VHlwZSgpKX1yZXR1cm4gaX1jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3Jkcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1jcmVhdGVQb2ludCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvaW50KHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbdF0pOm51bGwpfWlmKEkoYXJndW1lbnRzWzBdLEYpKXtyZXR1cm4gbmV3IHR0KGFyZ3VtZW50c1swXSx0aGlzKX19fWdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeX1jcmVhdGVQb2x5Z29uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbihudWxsLG51bGwpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHV0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHQsbnVsbCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgaXQoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSx0aGlzKX19Z2V0U1JJRCgpe3JldHVybiB0aGlzLl9TUklEfWNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgY3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBjdChhcmd1bWVudHNbMF0sdGhpcyl9fWdldFByZWNpc2lvbk1vZGVsKCl7cmV0dXJuIHRoaXMuX3ByZWNpc2lvbk1vZGVsfWNyZWF0ZUxpbmVhclJpbmcoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihJKGFyZ3VtZW50c1swXSxGKSl7cmV0dXJuIG5ldyB1dChhcmd1bWVudHNbMF0sdGhpcyl9fX1jcmVhdGVNdWx0aVBvbHlnb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGZ0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgZnQoYXJndW1lbnRzWzBdLHRoaXMpfX1jcmVhdGVNdWx0aVBvaW50KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBodChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtyZXR1cm4gbmV3IGh0KGFyZ3VtZW50c1swXSx0aGlzKX1pZihJKGFyZ3VtZW50c1swXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKDEsdC5nZXREaW1lbnNpb24oKSx0LmdldE1lYXN1cmVzKCkpO1ouY29weSh0LG4scywwLDEpLGVbbl09dGhpcy5jcmVhdGVQb2ludChzKX1yZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGUpfX19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NdfX1jb25zdCBMdD1cIlhZXCIsVHQ9XCJYWVpcIixSdD1cIlhZTVwiLFB0PVwiWFlaTVwiLE90PXtQT0lOVDpcIlBvaW50XCIsTElORV9TVFJJTkc6XCJMaW5lU3RyaW5nXCIsTElORUFSX1JJTkc6XCJMaW5lYXJSaW5nXCIsUE9MWUdPTjpcIlBvbHlnb25cIixNVUxUSV9QT0lOVDpcIk11bHRpUG9pbnRcIixNVUxUSV9MSU5FX1NUUklORzpcIk11bHRpTGluZVN0cmluZ1wiLE1VTFRJX1BPTFlHT046XCJNdWx0aVBvbHlnb25cIixHRU9NRVRSWV9DT0xMRUNUSU9OOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsQ0lSQ0xFOlwiQ2lyY2xlXCJ9LHZ0PVwiRU1QVFlcIixNdD0xLGJ0PTIsRHQ9MyxBdD00LEZ0PTUsR3Q9NixxdD17fTtmb3IoY29uc3QgdCBpbiBPdClxdFt0XT1PdFt0XS50b1VwcGVyQ2FzZSgpO2NsYXNzIEJ0e2NvbnN0cnVjdG9yKHQpe3RoaXMud2t0PXQsdGhpcy5pbmRleF89LTF9aXNBbHBoYV8odCl7cmV0dXJuIHQ+PVwiYVwiJiZ0PD1cInpcInx8dD49XCJBXCImJnQ8PVwiWlwifWlzTnVtZXJpY18odCxlKXtyZXR1cm4gdD49XCIwXCImJnQ8PVwiOVwifHxcIi5cIj09dCYmISh2b2lkIDAhPT1lJiZlKX1pc1doaXRlU3BhY2VfKHQpe3JldHVyblwiIFwiPT10fHxcIlxcdFwiPT10fHxcIlxcclwiPT10fHxcIlxcblwiPT10fW5leHRDaGFyXygpe3JldHVybiB0aGlzLndrdC5jaGFyQXQoKyt0aGlzLmluZGV4Xyl9bmV4dFRva2VuKCl7Y29uc3QgdD10aGlzLm5leHRDaGFyXygpLGU9dGhpcy5pbmRleF87bGV0IG4scz10O2lmKFwiKFwiPT10KW49YnQ7ZWxzZSBpZihcIixcIj09dCluPUZ0O2Vsc2UgaWYoXCIpXCI9PXQpbj1EdDtlbHNlIGlmKHRoaXMuaXNOdW1lcmljXyh0KXx8XCItXCI9PXQpbj1BdCxzPXRoaXMucmVhZE51bWJlcl8oKTtlbHNlIGlmKHRoaXMuaXNBbHBoYV8odCkpbj1NdCxzPXRoaXMucmVhZFRleHRfKCk7ZWxzZXtpZih0aGlzLmlzV2hpdGVTcGFjZV8odCkpcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7aWYoXCJcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiK3QpO249R3R9cmV0dXJue3Bvc2l0aW9uOmUsdmFsdWU6cyx0eXBlOm59fXJlYWROdW1iZXJfKCl7bGV0IHQ7Y29uc3QgZT10aGlzLmluZGV4XztsZXQgbj0hMSxzPSExO2Rve1wiLlwiPT10P249ITA6XCJlXCIhPXQmJlwiRVwiIT10fHwocz0hMCksdD10aGlzLm5leHRDaGFyXygpfXdoaWxlKHRoaXMuaXNOdW1lcmljXyh0LG4pfHwhcyYmKFwiZVwiPT10fHxcIkVcIj09dCl8fHMmJihcIi1cIj09dHx8XCIrXCI9PXQpKTtyZXR1cm4gcGFyc2VGbG9hdCh0aGlzLndrdC5zdWJzdHJpbmcoZSx0aGlzLmluZGV4Xy0tKSl9cmVhZFRleHRfKCl7bGV0IHQ7Y29uc3QgZT10aGlzLmluZGV4Xztkb3t0PXRoaXMubmV4dENoYXJfKCl9d2hpbGUodGhpcy5pc0FscGhhXyh0KSk7cmV0dXJuIHRoaXMud2t0LnN1YnN0cmluZyhlLHRoaXMuaW5kZXhfLS0pLnRvVXBwZXJDYXNlKCl9fWNsYXNzIFl0e2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5sZXhlcl89dCx0aGlzLnRva2VuXyx0aGlzLmxheW91dF89THQsdGhpcy5mYWN0b3J5PWV9Y29uc3VtZV8oKXt0aGlzLnRva2VuXz10aGlzLmxleGVyXy5uZXh0VG9rZW4oKX1pc1Rva2VuVHlwZSh0KXtyZXR1cm4gdGhpcy50b2tlbl8udHlwZT09dH1tYXRjaCh0KXtjb25zdCBlPXRoaXMuaXNUb2tlblR5cGUodCk7cmV0dXJuIGUmJnRoaXMuY29uc3VtZV8oKSxlfXBhcnNlKCl7dGhpcy5jb25zdW1lXygpO3JldHVybiB0aGlzLnBhcnNlR2VvbWV0cnlfKCl9cGFyc2VHZW9tZXRyeUxheW91dF8oKXtsZXQgdD1MdDtjb25zdCBlPXRoaXMudG9rZW5fO2lmKHRoaXMuaXNUb2tlblR5cGUoTXQpKXtjb25zdCBuPWUudmFsdWU7XCJaXCI9PT1uP3Q9VHQ6XCJNXCI9PT1uP3Q9UnQ6XCJaTVwiPT09biYmKHQ9UHQpLHQhPT1MdCYmdGhpcy5jb25zdW1lXygpfXJldHVybiB0fXBhcnNlR2VvbWV0cnlDb2xsZWN0aW9uVGV4dF8oKXtpZih0aGlzLm1hdGNoKGJ0KSl7Y29uc3QgdD1bXTtkb3t0LnB1c2godGhpcy5wYXJzZUdlb21ldHJ5XygpKX13aGlsZSh0aGlzLm1hdGNoKEZ0KSk7aWYodGhpcy5tYXRjaChEdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlUG9pbnRUZXh0Xygpe2lmKHRoaXMubWF0Y2goYnQpKXtjb25zdCB0PXRoaXMucGFyc2VQb2ludF8oKTtpZih0aGlzLm1hdGNoKER0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybiBudWxsO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VMaW5lU3RyaW5nVGV4dF8oKXtpZih0aGlzLm1hdGNoKGJ0KSl7Y29uc3QgdD10aGlzLnBhcnNlUG9pbnRMaXN0XygpO2lmKHRoaXMubWF0Y2goRHQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvbHlnb25UZXh0Xygpe2lmKHRoaXMubWF0Y2goYnQpKXtjb25zdCB0PXRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dExpc3RfKCk7aWYodGhpcy5tYXRjaChEdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTXVsdGlQb2ludFRleHRfKCl7aWYodGhpcy5tYXRjaChidCkpe2xldCB0O2lmKHQ9dGhpcy50b2tlbl8udHlwZT09YnQ/dGhpcy5wYXJzZVBvaW50VGV4dExpc3RfKCk6dGhpcy5wYXJzZVBvaW50TGlzdF8oKSx0aGlzLm1hdGNoKER0KSlyZXR1cm4gdH1lbHNlIGlmKHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9cGFyc2VNdWx0aUxpbmVTdHJpbmdUZXh0Xygpe2lmKHRoaXMubWF0Y2goYnQpKXtjb25zdCB0PXRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dExpc3RfKCk7aWYodGhpcy5tYXRjaChEdCkpcmV0dXJuIHR9ZWxzZSBpZih0aGlzLmlzRW1wdHlHZW9tZXRyeV8oKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlTXVsdGlQb2x5Z29uVGV4dF8oKXtpZih0aGlzLm1hdGNoKGJ0KSl7Y29uc3QgdD10aGlzLnBhcnNlUG9seWdvblRleHRMaXN0XygpO2lmKHRoaXMubWF0Y2goRHQpKXJldHVybiB0fWVsc2UgaWYodGhpcy5pc0VtcHR5R2VvbWV0cnlfKCkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKX1wYXJzZVBvaW50Xygpe2NvbnN0IHQ9W10sZT10aGlzLmxheW91dF8ubGVuZ3RoO2ZvcihsZXQgbj0wO248ZTsrK24pe2NvbnN0IGU9dGhpcy50b2tlbl87aWYoIXRoaXMubWF0Y2goQXQpKWJyZWFrO3QucHVzaChlLnZhbHVlKX1pZih0Lmxlbmd0aD09ZSlyZXR1cm4gdDt0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpfXBhcnNlUG9pbnRMaXN0Xygpe2NvbnN0IHQ9W3RoaXMucGFyc2VQb2ludF8oKV07Zm9yKDt0aGlzLm1hdGNoKEZ0KTspdC5wdXNoKHRoaXMucGFyc2VQb2ludF8oKSk7cmV0dXJuIHR9cGFyc2VQb2ludFRleHRMaXN0Xygpe2NvbnN0IHQ9W3RoaXMucGFyc2VQb2ludFRleHRfKCldO2Zvcig7dGhpcy5tYXRjaChGdCk7KXQucHVzaCh0aGlzLnBhcnNlUG9pbnRUZXh0XygpKTtyZXR1cm4gdH1wYXJzZUxpbmVTdHJpbmdUZXh0TGlzdF8oKXtjb25zdCB0PVt0aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCldO2Zvcig7dGhpcy5tYXRjaChGdCk7KXQucHVzaCh0aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCkpO3JldHVybiB0fXBhcnNlUG9seWdvblRleHRMaXN0Xygpe2NvbnN0IHQ9W3RoaXMucGFyc2VQb2x5Z29uVGV4dF8oKV07Zm9yKDt0aGlzLm1hdGNoKEZ0KTspdC5wdXNoKHRoaXMucGFyc2VQb2x5Z29uVGV4dF8oKSk7cmV0dXJuIHR9aXNFbXB0eUdlb21ldHJ5Xygpe2NvbnN0IHQ9dGhpcy5pc1Rva2VuVHlwZShNdCkmJnRoaXMudG9rZW5fLnZhbHVlPT12dDtyZXR1cm4gdCYmdGhpcy5jb25zdW1lXygpLHR9Zm9ybWF0RXJyb3JNZXNzYWdlXygpe3JldHVyblwiVW5leHBlY3RlZCBgXCIrdGhpcy50b2tlbl8udmFsdWUrXCJgIGF0IHBvc2l0aW9uIFwiK3RoaXMudG9rZW5fLnBvc2l0aW9uK1wiIGluIGBcIit0aGlzLmxleGVyXy53a3QrXCJgXCJ9cGFyc2VHZW9tZXRyeV8oKXtjb25zdCB0PXRoaXMuZmFjdG9yeSxlPXQ9Pm5ldyBtKC4uLnQpLG49bj0+e2NvbnN0IHM9bi5tYXAoKG49PnQuY3JlYXRlTGluZWFyUmluZyhuLm1hcChlKSkpKTtyZXR1cm4gcy5sZW5ndGg+MT90LmNyZWF0ZVBvbHlnb24oc1swXSxzLnNsaWNlKDEpKTp0LmNyZWF0ZVBvbHlnb24oc1swXSl9LHM9dGhpcy50b2tlbl87aWYodGhpcy5tYXRjaChNdCkpe2NvbnN0IGk9cy52YWx1ZTtpZih0aGlzLmxheW91dF89dGhpcy5wYXJzZUdlb21ldHJ5TGF5b3V0XygpLFwiR0VPTUVUUllDT0xMRUNUSU9OXCI9PWkpe2NvbnN0IGU9dGhpcy5wYXJzZUdlb21ldHJ5Q29sbGVjdGlvblRleHRfKCk7cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfXN3aXRjaChpKXtjYXNlXCJQT0lOVFwiOntjb25zdCBlPXRoaXMucGFyc2VQb2ludFRleHRfKCk7cmV0dXJuIGU/dC5jcmVhdGVQb2ludChuZXcgbSguLi5lKSk6dC5jcmVhdGVQb2ludCgpfWNhc2VcIkxJTkVTVFJJTkdcIjp7Y29uc3Qgbj10aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCkubWFwKGUpO3JldHVybiB0LmNyZWF0ZUxpbmVTdHJpbmcobil9Y2FzZVwiTElORUFSUklOR1wiOntjb25zdCBuPXRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dF8oKS5tYXAoZSk7cmV0dXJuIHQuY3JlYXRlTGluZWFyUmluZyhuKX1jYXNlXCJQT0xZR09OXCI6e2NvbnN0IGU9dGhpcy5wYXJzZVBvbHlnb25UZXh0XygpO3JldHVybiBlJiYwIT09ZS5sZW5ndGg/bihlKTp0LmNyZWF0ZVBvbHlnb24oKX1jYXNlXCJNVUxUSVBPSU5UXCI6e2NvbnN0IG49dGhpcy5wYXJzZU11bHRpUG9pbnRUZXh0XygpO2lmKCFufHwwPT09bi5sZW5ndGgpcmV0dXJuIHQuY3JlYXRlTXVsdGlQb2ludCgpO2NvbnN0IHM9bi5tYXAoZSkubWFwKChlPT50LmNyZWF0ZVBvaW50KGUpKSk7cmV0dXJuIHQuY3JlYXRlTXVsdGlQb2ludChzKX1jYXNlXCJNVUxUSUxJTkVTVFJJTkdcIjp7Y29uc3Qgbj10aGlzLnBhcnNlTXVsdGlMaW5lU3RyaW5nVGV4dF8oKS5tYXAoKG49PnQuY3JlYXRlTGluZVN0cmluZyhuLm1hcChlKSkpKTtyZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9Y2FzZVwiTVVMVElQT0xZR09OXCI6e2NvbnN0IGU9dGhpcy5wYXJzZU11bHRpUG9seWdvblRleHRfKCk7aWYoIWV8fDA9PT1lLmxlbmd0aClyZXR1cm4gdC5jcmVhdGVNdWx0aVBvbHlnb24oKTtjb25zdCBzPWUubWFwKG4pO3JldHVybiB0LmNyZWF0ZU11bHRpUG9seWdvbihzKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ2VvbWV0cnkgdHlwZTogXCIraSl9fXRocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSl9fWZ1bmN0aW9uIFZ0KHQpe2lmKHQuaXNFbXB0eSgpKXJldHVyblwiXCI7Y29uc3QgZT10LmdldENvb3JkaW5hdGUoKSxuPVtlLngsZS55XTtyZXR1cm4gZS56JiZuLnB1c2goZS56KSxlLm0mJm4ucHVzaChlLm0pLG4uam9pbihcIiBcIil9ZnVuY3Rpb24genQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCkubWFwKCh0PT5bdC54LHQueV0pKSxuPVtdO2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzOysrdCluLnB1c2goZVt0XS5qb2luKFwiIFwiKSk7cmV0dXJuIG4uam9pbihcIiwgXCIpfWZ1bmN0aW9uIGt0KHQpe2NvbnN0IGU9W107ZS5wdXNoKFwiKFwiK3p0KHQuZ2V0RXh0ZXJpb3JSaW5nKCkpK1wiKVwiKTtmb3IobGV0IG49MCxzPXQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bjxzOysrbillLnB1c2goXCIoXCIrenQodC5nZXRJbnRlcmlvclJpbmdOKG4pKStcIilcIik7cmV0dXJuIGUuam9pbihcIiwgXCIpfWNvbnN0IFh0PXtQb2ludDpWdCxMaW5lU3RyaW5nOnp0LExpbmVhclJpbmc6enQsUG9seWdvbjprdCxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChcIihcIitWdCh0LmdldEdlb21ldHJ5TihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChcIihcIit6dCh0LmdldEdlb21ldHJ5TihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChcIihcIitrdCh0LmdldEdlb21ldHJ5TihuKSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsIFwiKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTAscz10LmdldE51bUdlb21ldHJpZXMoKTtuPHM7KytuKWUucHVzaChVdCh0LmdldEdlb21ldHJ5TihuKSkpO3JldHVybiBlLmpvaW4oXCIsIFwiKX19O2Z1bmN0aW9uIFV0KHQpe2xldCBlPXQuZ2V0R2VvbWV0cnlUeXBlKCk7Y29uc3Qgbj1YdFtlXTtlPWUudG9VcHBlckNhc2UoKTtjb25zdCBzPWZ1bmN0aW9uKHQpe2xldCBlPVwiXCI7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGU7Y29uc3Qgbj10LmdldENvb3JkaW5hdGUoKTtyZXR1cm4gbi56JiYoZSs9XCJaXCIpLG4ubSYmKGUrPVwiTVwiKSxlfSh0KTtpZihzLmxlbmd0aD4wJiYoZSs9XCIgXCIrcyksdC5pc0VtcHR5KCkpcmV0dXJuIGUrXCIgXCIrdnQ7cmV0dXJuIGUrXCIgKFwiK24odCkrXCIpXCJ9Y2xhc3MgSHR7Y29uc3RydWN0b3IodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEN0LHRoaXMucHJlY2lzaW9uTW9kZWw9dGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX1yZWFkKHQpe2NvbnN0IGU9bmV3IEJ0KHQpO3JldHVybiBuZXcgWXQoZSx0aGlzLmdlb21ldHJ5RmFjdG9yeSkucGFyc2UoKX13cml0ZSh0KXtyZXR1cm4gVXQodCl9fWNsYXNzIFd0e2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyBIdCh0KX13cml0ZSh0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9c3RhdGljIHRvTGluZVN0cmluZyh0LGUpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtyZXR1cm5cIkxJTkVTVFJJTkcgKCBcIit0LngrXCIgXCIrdC55K1wiLCBcIitlLngrXCIgXCIrZS55K1wiIClcIn19Y2xhc3MgWnR7Y29uc3RydWN0b3IoKXtadC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZXN1bHQ9bnVsbCx0aGlzLl9pbnB1dExpbmVzPUFycmF5KDIpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgyKSkpLHRoaXMuX2ludFB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2ludExpbmVJbmRleD1udWxsLHRoaXMuX2lzUHJvcGVyPW51bGwsdGhpcy5fcGE9bnVsbCx0aGlzLl9wYj1udWxsLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5faW50UHRbMF09bmV3IG0sdGhpcy5faW50UHRbMV09bmV3IG0sdGhpcy5fcGE9dGhpcy5faW50UHRbMF0sdGhpcy5fcGI9dGhpcy5faW50UHRbMV0sdGhpcy5fcmVzdWx0PTB9c3RhdGljIGNvbXB1dGVFZGdlRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9TWF0aC5hYnMobi54LWUueCksaT1NYXRoLmFicyhuLnktZS55KTtsZXQgcj0tMTtpZih0LmVxdWFscyhlKSlyPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlyPXM+aT9zOmk7ZWxzZXtjb25zdCBuPU1hdGguYWJzKHQueC1lLngpLG89TWF0aC5hYnModC55LWUueSk7cj1zPmk/bjpvLDAhPT1yfHx0LmVxdWFscyhlKXx8KHI9TWF0aC5tYXgobixvKSl9cmV0dXJuIGcuaXNUcnVlKCEoMD09PXImJiF0LmVxdWFscyhlKSksXCJCYWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1zdGF0aWMgbm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueSxyPU1hdGguc3FydChzKnMraSppKTtyZXR1cm4gZy5pc1RydWUoISgwPT09ciYmIXQuZXF1YWxzKGUpKSxcIkludmFsaWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1nZXRJbmRleEFsb25nU2VnbWVudCh0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bZV19Z2V0VG9wb2xvZ3lTdW1tYXJ5KCl7Y29uc3QgdD1uZXcgX3Q7cmV0dXJuIHRoaXMuaXNFbmRQb2ludCgpJiZ0LmFwcGVuZChcIiBlbmRwb2ludFwiKSx0aGlzLl9pc1Byb3BlciYmdC5hcHBlbmQoXCIgcHJvcGVyXCIpLHRoaXMuaXNDb2xsaW5lYXIoKSYmdC5hcHBlbmQoXCIgY29sbGluZWFyXCIpLHQudG9TdHJpbmcoKX1jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSxuLHMpe3RoaXMuX2lucHV0TGluZXNbMF1bMF09dCx0aGlzLl9pbnB1dExpbmVzWzBdWzFdPWUsdGhpcy5faW5wdXRMaW5lc1sxXVswXT1uLHRoaXMuX2lucHV0TGluZXNbMV1bMV09cyx0aGlzLl9yZXN1bHQ9dGhpcy5jb21wdXRlSW50ZXJzZWN0KHQsZSxuLHMpfWdldEludGVyc2VjdGlvbk51bSgpe3JldHVybiB0aGlzLl9yZXN1bHR9Y29tcHV0ZUludExpbmVJbmRleCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW51bGw9PT10aGlzLl9pbnRMaW5lSW5kZXgmJih0aGlzLl9pbnRMaW5lSW5kZXg9QXJyYXkoMikuZmlsbCgpLm1hcCgoKCk9PkFycmF5KDIpKSksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDApLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwwKT50aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDEpPyh0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMF09MCx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMV09MSk6KHRoaXMuX2ludExpbmVJbmRleFt0XVswXT0xLHRoaXMuX2ludExpbmVJbmRleFt0XVsxXT0wKX19aXNQcm9wZXIoKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5faXNQcm9wZXJ9c2V0UHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fcHJlY2lzaW9uTW9kZWw9dH1pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCl8fCEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDEpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX3Jlc3VsdDtlKyspaWYoIXRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHRoaXMuX2lucHV0TGluZXNbdF1bMF0pJiYhdGhpcy5faW50UHRbZV0uZXF1YWxzMkQodGhpcy5faW5wdXRMaW5lc1t0XVsxXSkpcmV0dXJuITA7cmV0dXJuITF9fWdldEludGVyc2VjdGlvbih0KXtyZXR1cm4gdGhpcy5faW50UHRbdF19aXNFbmRQb2ludCgpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpJiYhdGhpcy5faXNQcm9wZXJ9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdCE9PVp0Lk5PX0lOVEVSU0VDVElPTn1nZXRFZGdlRGlzdGFuY2UodCxlKXtyZXR1cm4gWnQuY29tcHV0ZUVkZ2VEaXN0YW5jZSh0aGlzLl9pbnRQdFtlXSx0aGlzLl9pbnB1dExpbmVzW3RdWzBdLHRoaXMuX2lucHV0TGluZXNbdF1bMV0pfWlzQ29sbGluZWFyKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdD09PVp0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT059dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sdGhpcy5faW5wdXRMaW5lc1swXVsxXSkrXCIgLSBcIitXdC50b0xpbmVTdHJpbmcodGhpcy5faW5wdXRMaW5lc1sxXVswXSx0aGlzLl9pbnB1dExpbmVzWzFdWzFdKSt0aGlzLmdldFRvcG9sb2d5U3VtbWFyeSgpfWdldEVuZHBvaW50KHQsZSl7cmV0dXJuIHRoaXMuX2lucHV0TGluZXNbdF1bZV19aXNJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9yZXN1bHQ7ZSsrKWlmKHRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHQpKXJldHVybiEwO3JldHVybiExfWdldEludGVyc2VjdGlvbkFsb25nU2VnbWVudCh0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLl9pbnRQdFt0aGlzLl9pbnRMaW5lSW5kZXhbdF1bZV1dfX1adC5ET05UX0lOVEVSU0VDVD0wLFp0LkRPX0lOVEVSU0VDVD0xLFp0LkNPTExJTkVBUj0yLFp0Lk5PX0lOVEVSU0VDVElPTj0wLFp0LlBPSU5UX0lOVEVSU0VDVElPTj0xLFp0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT049MjtjbGFzcyBqdCBleHRlbmRzIFp0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1zdGF0aWMgbmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpe2xldCBpPXQscj1WLnBvaW50VG9TZWdtZW50KHQsbixzKSxvPVYucG9pbnRUb1NlZ21lbnQoZSxuLHMpO3JldHVybiBvPHImJihyPW8saT1lKSxvPVYucG9pbnRUb1NlZ21lbnQobix0LGUpLG88ciYmKHI9byxpPW4pLG89Vi5wb2ludFRvU2VnbWVudChzLHQsZSksbzxyJiYocj1vLGk9cyksaX1pc0luU2VnbWVudEVudmVsb3Blcyh0KXtjb25zdCBlPW5ldyBPKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sdGhpcy5faW5wdXRMaW5lc1swXVsxXSksbj1uZXcgTyh0aGlzLl9pbnB1dExpbmVzWzFdWzBdLHRoaXMuX2lucHV0TGluZXNbMV1bMV0pO3JldHVybiBlLmNvbnRhaW5zKHQpJiZuLmNvbnRhaW5zKHQpfWNvbXB1dGVJbnRlcnNlY3Rpb24oKXtpZigzIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gc3VwZXIuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX2lzUHJvcGVyPSExLE8uaW50ZXJzZWN0cyhlLG4sdCkmJjA9PT1HLmluZGV4KGUsbix0KSYmMD09PUcuaW5kZXgobixlLHQpKXJldHVybiB0aGlzLl9pc1Byb3Blcj0hMCwodC5lcXVhbHMoZSl8fHQuZXF1YWxzKG4pKSYmKHRoaXMuX2lzUHJvcGVyPSExKSx0aGlzLl9yZXN1bHQ9WnQuUE9JTlRfSU5URVJTRUNUSU9OLG51bGw7dGhpcy5fcmVzdWx0PVp0Lk5PX0lOVEVSU0VDVElPTn19aW50ZXJzZWN0aW9uKHQsZSxuLHMpe2xldCBpPXRoaXMuaW50ZXJzZWN0aW9uU2FmZSh0LGUsbixzKTtyZXR1cm4gdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhpKXx8KGk9bmV3IG0oanQubmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpKSksbnVsbCE9PXRoaXMuX3ByZWNpc2lvbk1vZGVsJiZ0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShpKSxpfWNoZWNrREQodCxlLG4scyxpKXtjb25zdCByPUEuaW50ZXJzZWN0aW9uKHQsZSxuLHMpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhyKTtCLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3IpLGkuZGlzdGFuY2Uocik+MWUtNCYmQi5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIraS5kaXN0YW5jZShyKSl9aW50ZXJzZWN0aW9uU2FmZSh0LGUsbixzKXtsZXQgaT1xLmludGVyc2VjdGlvbih0LGUsbixzKTtyZXR1cm4gbnVsbD09PWkmJihpPWp0Lm5lYXJlc3RFbmRwb2ludCh0LGUsbixzKSksaX1jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHQsZSxuLHMpe2NvbnN0IGk9Ty5pbnRlcnNlY3RzKHQsZSxuKSxyPU8uaW50ZXJzZWN0cyh0LGUscyksbz1PLmludGVyc2VjdHMobixzLHQpLGw9Ty5pbnRlcnNlY3RzKG4scyxlKTtyZXR1cm4gaSYmcj8odGhpcy5faW50UHRbMF09bix0aGlzLl9pbnRQdFsxXT1zLFp0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOm8mJmw/KHRoaXMuX2ludFB0WzBdPXQsdGhpcy5faW50UHRbMV09ZSxadC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTppJiZvPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPXQsIW4uZXF1YWxzKHQpfHxyfHxsP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTppJiZsPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPWUsIW4uZXF1YWxzKGUpfHxyfHxvP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTpyJiZvPyh0aGlzLl9pbnRQdFswXT1zLHRoaXMuX2ludFB0WzFdPXQsIXMuZXF1YWxzKHQpfHxpfHxsP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTpyJiZsPyh0aGlzLl9pbnRQdFswXT1zLHRoaXMuX2ludFB0WzFdPWUsIXMuZXF1YWxzKGUpfHxpfHxvP1p0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT046WnQuUE9JTlRfSU5URVJTRUNUSU9OKTpadC5OT19JTlRFUlNFQ1RJT059Y29tcHV0ZUludGVyc2VjdCh0LGUsbixzKXtpZih0aGlzLl9pc1Byb3Blcj0hMSwhTy5pbnRlcnNlY3RzKHQsZSxuLHMpKXJldHVybiBadC5OT19JTlRFUlNFQ1RJT047Y29uc3QgaT1HLmluZGV4KHQsZSxuKSxyPUcuaW5kZXgodCxlLHMpO2lmKGk+MCYmcj4wfHxpPDAmJnI8MClyZXR1cm4gWnQuTk9fSU5URVJTRUNUSU9OO2NvbnN0IG89Ry5pbmRleChuLHMsdCksbD1HLmluZGV4KG4scyxlKTtpZihvPjAmJmw+MHx8bzwwJiZsPDApcmV0dXJuIFp0Lk5PX0lOVEVSU0VDVElPTjtyZXR1cm4gMD09PWkmJjA9PT1yJiYwPT09byYmMD09PWw/dGhpcy5jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHQsZSxuLHMpOigwPT09aXx8MD09PXJ8fDA9PT1vfHwwPT09bD8odGhpcy5faXNQcm9wZXI9ITEsdC5lcXVhbHMyRChuKXx8dC5lcXVhbHMyRChzKT90aGlzLl9pbnRQdFswXT10OmUuZXF1YWxzMkQobil8fGUuZXF1YWxzMkQocyk/dGhpcy5faW50UHRbMF09ZTowPT09aT90aGlzLl9pbnRQdFswXT1uZXcgbShuKTowPT09cj90aGlzLl9pbnRQdFswXT1uZXcgbShzKTowPT09bz90aGlzLl9pbnRQdFswXT1uZXcgbSh0KTowPT09bCYmKHRoaXMuX2ludFB0WzBdPW5ldyBtKGUpKSk6KHRoaXMuX2lzUHJvcGVyPSEwLHRoaXMuX2ludFB0WzBdPXRoaXMuaW50ZXJzZWN0aW9uKHQsZSxuLHMpKSxadC5QT0lOVF9JTlRFUlNFQ1RJT04pfX1jbGFzcyBLdHtjb25zdHJ1Y3Rvcigpe0t0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpS3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSxuZXcgbSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07S3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucDA9dCx0aGlzLnAxPWV9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107S3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSh0LGUpLG5ldyBtKG4scykpfX1zdGF0aWMgbWlkUG9pbnQodCxlKXtyZXR1cm4gbmV3IG0oKHQueCtlLngpLzIsKHQueStlLnkpLzIpfW1pblgoKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LHRoaXMucDEueCl9b3JpZW50YXRpb25JbmRleCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9Ry5pbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMCksbj1HLmluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAxKTtyZXR1cm4gZT49MCYmbj49MHx8ZTw9MCYmbjw9MD9NYXRoLm1heChlLG4pOjB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gRy5pbmRleCh0aGlzLnAwLHRoaXMucDEsdCl9fXRvR2VvbWV0cnkodCl7cmV0dXJuIHQuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5wMCx0aGlzLnAxXSl9aXNWZXJ0aWNhbCgpe3JldHVybiB0aGlzLnAwLng9PT10aGlzLnAxLnh9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIEt0KSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMucDAuZXF1YWxzKGUucDApJiZ0aGlzLnAxLmVxdWFscyhlLnAxKX1pbnRlcnNlY3Rpb24odCl7Y29uc3QgZT1uZXcganQ7cmV0dXJuIGUuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKSxlLmhhc0ludGVyc2VjdGlvbigpP2UuZ2V0SW50ZXJzZWN0aW9uKDApOm51bGx9cHJvamVjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5lcXVhbHModGhpcy5wMCl8fHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiBuZXcgbSh0KTtjb25zdCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KSxuPW5ldyBtO3JldHVybiBuLng9dGhpcy5wMC54K2UqKHRoaXMucDEueC10aGlzLnAwLngpLG4ueT10aGlzLnAwLnkrZSoodGhpcy5wMS55LXRoaXMucDAueSksbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0LnAwKSxuPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0LnAxKTtpZihlPj0xJiZuPj0xKXJldHVybiBudWxsO2lmKGU8PTAmJm48PTApcmV0dXJuIG51bGw7bGV0IHM9dGhpcy5wcm9qZWN0KHQucDApO2U8MCYmKHM9dGhpcy5wMCksZT4xJiYocz10aGlzLnAxKTtsZXQgaT10aGlzLnByb2plY3QodC5wMSk7cmV0dXJuIG48MCYmKGk9dGhpcy5wMCksbj4xJiYoaT10aGlzLnAxKSxuZXcgS3QocyxpKX19bm9ybWFsaXplKCl7dGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCk8MCYmdGhpcy5yZXZlcnNlKCl9YW5nbGUoKXtyZXR1cm4gTWF0aC5hdGFuMih0aGlzLnAxLnktdGhpcy5wMC55LHRoaXMucDEueC10aGlzLnAwLngpfWdldENvb3JkaW5hdGUodCl7cmV0dXJuIDA9PT10P3RoaXMucDA6dGhpcy5wMX1kaXN0YW5jZVBlcnBlbmRpY3VsYXIodCl7cmV0dXJuIFYucG9pbnRUb0xpbmVQZXJwZW5kaWN1bGFyKHQsdGhpcy5wMCx0aGlzLnAxKX1taW5ZKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueSx0aGlzLnAxLnkpfW1pZFBvaW50KCl7cmV0dXJuIEt0Lm1pZFBvaW50KHRoaXMucDAsdGhpcy5wMSl9cHJvamVjdGlvbkZhY3Rvcih0KXtpZih0LmVxdWFscyh0aGlzLnAwKSlyZXR1cm4gMDtpZih0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gMTtjb25zdCBlPXRoaXMucDEueC10aGlzLnAwLngsbj10aGlzLnAxLnktdGhpcy5wMC55LHM9ZSplK24qbjtpZihzPD0wKXJldHVybiByLk5hTjtyZXR1cm4oKHQueC10aGlzLnAwLngpKmUrKHQueS10aGlzLnAwLnkpKm4pL3N9Y2xvc2VzdFBvaW50cyh0KXtjb25zdCBlPXRoaXMuaW50ZXJzZWN0aW9uKHQpO2lmKG51bGwhPT1lKXJldHVybltlLGVdO2NvbnN0IG49bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7bGV0IHM9ci5NQVhfVkFMVUUsaT1udWxsO2NvbnN0IG89dGhpcy5jbG9zZXN0UG9pbnQodC5wMCk7cz1vLmRpc3RhbmNlKHQucDApLG5bMF09byxuWzFdPXQucDA7Y29uc3QgbD10aGlzLmNsb3Nlc3RQb2ludCh0LnAxKTtpPWwuZGlzdGFuY2UodC5wMSksaTxzJiYocz1pLG5bMF09bCxuWzFdPXQucDEpO2NvbnN0IGE9dC5jbG9zZXN0UG9pbnQodGhpcy5wMCk7aT1hLmRpc3RhbmNlKHRoaXMucDApLGk8cyYmKHM9aSxuWzBdPXRoaXMucDAsblsxXT1hKTtjb25zdCBjPXQuY2xvc2VzdFBvaW50KHRoaXMucDEpO3JldHVybiBpPWMuZGlzdGFuY2UodGhpcy5wMSksaTxzJiYocz1pLG5bMF09dGhpcy5wMSxuWzFdPWMpLG59Y2xvc2VzdFBvaW50KHQpe2NvbnN0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO2lmKGU+MCYmZTwxKXJldHVybiB0aGlzLnByb2plY3QodCk7cmV0dXJuIHRoaXMucDAuZGlzdGFuY2UodCk8dGhpcy5wMS5kaXN0YW5jZSh0KT90aGlzLnAwOnRoaXMucDF9bWF4WCgpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLngsdGhpcy5wMS54KX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0aGlzLnAxKX1jb21wYXJlVG8odCl7Y29uc3QgZT10LG49dGhpcy5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dGhpcy5wMS5jb21wYXJlVG8oZS5wMSl9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMucDAuZXF1YWxzKHQucDApJiZ0aGlzLnAxLmVxdWFscyh0LnAxKXx8dGhpcy5wMC5lcXVhbHModC5wMSkmJnRoaXMucDEuZXF1YWxzKHQucDApfWxpbmVJbnRlcnNlY3Rpb24odCl7cmV0dXJuIHEuaW50ZXJzZWN0aW9uKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfW1heFkoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC55LHRoaXMucDEueSl9cG9pbnRBbG9uZ09mZnNldCh0LGUpe2NvbnN0IG49dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLHM9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGk9dGhpcy5wMS54LXRoaXMucDAueCxyPXRoaXMucDEueS10aGlzLnAwLnksbz1NYXRoLnNxcnQoaSppK3Iqcik7bGV0IGw9MCxhPTA7aWYoMCE9PWUpe2lmKG88PTApdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTtsPWUqaS9vLGE9ZSpyL299cmV0dXJuIG5ldyBtKG4tYSxzK2wpfXNldENvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnAwLng9dC54LHRoaXMucDAueT10LnksdGhpcy5wMS54PWUueCx0aGlzLnAxLnk9ZS55fX1zZWdtZW50RnJhY3Rpb24odCl7bGV0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO3JldHVybiBlPDA/ZT0wOihlPjF8fHIuaXNOYU4oZSkpJiYoZT0xKSxlfXRvU3RyaW5nKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifWlzSG9yaXpvbnRhbCgpe3JldHVybiB0aGlzLnAwLnk9PT10aGlzLnAxLnl9cmVmbGVjdCh0KXtjb25zdCBlPXRoaXMucDEuZ2V0WSgpLXRoaXMucDAuZ2V0WSgpLG49dGhpcy5wMC5nZXRYKCktdGhpcy5wMS5nZXRYKCkscz10aGlzLnAwLmdldFkoKSoodGhpcy5wMS5nZXRYKCktdGhpcy5wMC5nZXRYKCkpLXRoaXMucDAuZ2V0WCgpKih0aGlzLnAxLmdldFkoKS10aGlzLnAwLmdldFkoKSksaT1lKmUrbipuLHI9ZSplLW4qbixvPXQuZ2V0WCgpLGw9dC5nZXRZKCk7cmV0dXJuIG5ldyBtKCgtcipvLTIqZSpuKmwtMiplKnMpL2ksKHIqbC0yKmUqbipvLTIqbipzKS9pKX1kaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBWLnNlZ21lbnRUb1NlZ21lbnQodGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gVi5wb2ludFRvU2VnbWVudCh0LHRoaXMucDAsdGhpcy5wMSl9fXBvaW50QWxvbmcodCl7Y29uc3QgZT1uZXcgbTtyZXR1cm4gZS54PXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxlLnk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGV9aGFzaENvZGUoKXtsZXQgdD1yLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC54KTt0Xj0zMSpyLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC55KTtjb25zdCBlPU1hdGgudHJ1bmModCleTWF0aC50cnVuYyh0Pj4zMik7bGV0IG49ci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueCk7bl49MzEqci5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueSk7cmV0dXJuIGVeKE1hdGgudHJ1bmMobileTWF0aC50cnVuYyhuPj4zMikpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvLGNdfX1jbGFzcyBRdHtzdGF0aWMgdG9Mb2NhdGlvblN5bWJvbCh0KXtzd2l0Y2godCl7Y2FzZSBRdC5FWFRFUklPUjpyZXR1cm5cImVcIjtjYXNlIFF0LkJPVU5EQVJZOnJldHVyblwiYlwiO2Nhc2UgUXQuSU5URVJJT1I6cmV0dXJuXCJpXCI7Y2FzZSBRdC5OT05FOnJldHVyblwiLVwifXRocm93IG5ldyBzKFwiVW5rbm93biBsb2NhdGlvbiB2YWx1ZTogXCIrdCl9fVF0LklOVEVSSU9SPTAsUXQuQk9VTkRBUlk9MSxRdC5FWFRFUklPUj0yLFF0Lk5PTkU9LTE7Y2xhc3MgSnR7Y29uc3RydWN0b3IoKXtKdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tYXRyaXg9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9tYXRyaXg9QXJyYXkoMykuZmlsbCgpLm1hcCgoKCk9PkFycmF5KDMpKSksdGhpcy5zZXRBbGwoSy5GQUxTRSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtKdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLnNldCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0p0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpLHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdPXQuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldPXQuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdPXQuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdLHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdPXQuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldPXQuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdPXQuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdLHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPXQuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdLHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldPXQuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuQk9VTkRBUlldLHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuRVhURVJJT1JdPXQuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuRVhURVJJT1JdfX1zdGF0aWMgbWF0Y2hlcygpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGU9PT1LLlNZTV9ET05UQ0FSRXx8KGU9PT1LLlNZTV9UUlVFJiYodD49MHx8dD09PUsuVFJVRSl8fChlPT09Sy5TWU1fRkFMU0UmJnQ9PT1LLkZBTFNFfHwoZT09PUsuU1lNX1AmJnQ9PT1LLlB8fChlPT09Sy5TWU1fTCYmdD09PUsuTHx8ZT09PUsuU1lNX0EmJnQ9PT1LLkEpKSkpfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgSnQoYXJndW1lbnRzWzBdKS5tYXRjaGVzKHQpfX1zdGF0aWMgaXNUcnVlKHQpe3JldHVybiB0Pj0wfHx0PT09Sy5UUlVFfWlzSW50ZXJzZWN0cygpe3JldHVybiF0aGlzLmlzRGlzam9pbnQoKX1pc0NvdmVycygpe3JldHVybihKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5JTlRFUklPUl0pfHxKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5CT1VOREFSWV0pKSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl09PT1LLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LkJPVU5EQVJZXT09PUsuRkFMU0V9aXNDb3ZlcmVkQnkoKXtyZXR1cm4oSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldKSkmJnRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuRVhURVJJT1JdPT09Sy5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkJPVU5EQVJZXVtRdC5FWFRFUklPUl09PT1LLkZBTFNFfXNldCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj1NYXRoLnRydW5jKGUvMykscz1lJTM7dGhpcy5fbWF0cml4W25dW3NdPUsudG9EaW1lbnNpb25WYWx1ZSh0LmNoYXJBdChlKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21hdHJpeFt0XVtlXT1ufX1pc0NvbnRhaW5zKCl7cmV0dXJuIEp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPT09Sy5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV09PT1LLkZBTFNFfXNldEF0TGVhc3QoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49TWF0aC50cnVuYyhlLzMpLHM9ZSUzO3RoaXMuc2V0QXRMZWFzdChuLHMsSy50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKSl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX21hdHJpeFt0XVtlXTxuJiYodGhpcy5fbWF0cml4W3RdW2VdPW4pfX1zZXRBdExlYXN0SWZWYWxpZCh0LGUsbil7dD49MCYmZT49MCYmdGhpcy5zZXRBdExlYXN0KHQsZSxuKX1pc1dpdGhpbigpe3JldHVybiBKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZ0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXT09PUsuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuRVhURVJJT1JdPT09Sy5GQUxTRX1pc1RvdWNoZXModCxlKXtyZXR1cm4gdD5lP3RoaXMuaXNUb3VjaGVzKGUsdCk6KHQ9PT1LLkEmJmU9PT1LLkF8fHQ9PT1LLkwmJmU9PT1LLkx8fHQ9PT1LLkwmJmU9PT1LLkF8fHQ9PT1LLlAmJmU9PT1LLkF8fHQ9PT1LLlAmJmU9PT1LLkwpJiYodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl09PT1LLkZBTFNFJiYoSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuQk9VTkRBUlldKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuSU5URVJJT1JdKXx8SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldKSkpfWlzT3ZlcmxhcHModCxlKXtyZXR1cm4gdD09PUsuUCYmZT09PUsuUHx8dD09PUsuQSYmZT09PUsuQT9KdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5JTlRFUklPUl0pOnQ9PT1LLkwmJmU9PT1LLkwmJigxPT09dGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0mJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuSU5URVJJT1JdW1F0LkVYVEVSSU9SXSkmJkp0LmlzVHJ1ZSh0aGlzLl9tYXRyaXhbUXQuRVhURVJJT1JdW1F0LklOVEVSSU9SXSkpfWlzRXF1YWxzKHQsZSl7cmV0dXJuIHQ9PT1lJiYoSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl09PT1LLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LkVYVEVSSU9SXT09PUsuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdPT09Sy5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LkVYVEVSSU9SXVtRdC5CT1VOREFSWV09PT1LLkZBTFNFKX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IF90KFwiMTIzNDU2Nzg5XCIpO2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0LnNldENoYXJBdCgzKmUrbixLLnRvRGltZW5zaW9uU3ltYm9sKHRoaXMuX21hdHJpeFtlXVtuXSkpO3JldHVybiB0LnRvU3RyaW5nKCl9c2V0QWxsKHQpe2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0aGlzLl9tYXRyaXhbZV1bbl09dH1nZXQodCxlKXtyZXR1cm4gdGhpcy5fbWF0cml4W3RdW2VdfXRyYW5zcG9zZSgpe2xldCB0PXRoaXMuX21hdHJpeFsxXVswXTtyZXR1cm4gdGhpcy5fbWF0cml4WzFdWzBdPXRoaXMuX21hdHJpeFswXVsxXSx0aGlzLl9tYXRyaXhbMF1bMV09dCx0PXRoaXMuX21hdHJpeFsyXVswXSx0aGlzLl9tYXRyaXhbMl1bMF09dGhpcy5fbWF0cml4WzBdWzJdLHRoaXMuX21hdHJpeFswXVsyXT10LHQ9dGhpcy5fbWF0cml4WzJdWzFdLHRoaXMuX21hdHJpeFsyXVsxXT10aGlzLl9tYXRyaXhbMV1bMl0sdGhpcy5fbWF0cml4WzFdWzJdPXQsdGhpc31tYXRjaGVzKHQpe2lmKDkhPT10Lmxlbmd0aCl0aHJvdyBuZXcgcyhcIlNob3VsZCBiZSBsZW5ndGggOTogXCIrdCk7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKWlmKCFKdC5tYXRjaGVzKHRoaXMuX21hdHJpeFtlXVtuXSx0LmNoYXJBdCgzKmUrbikpKXJldHVybiExO3JldHVybiEwfWFkZCh0KXtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdGhpcy5zZXRBdExlYXN0KGUsbix0LmdldChlLG4pKX1pc0Rpc2pvaW50KCl7cmV0dXJuIHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdPT09Sy5GQUxTRSYmdGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5CT1VOREFSWV09PT1LLkZBTFNFJiZ0aGlzLl9tYXRyaXhbUXQuQk9VTkRBUlldW1F0LklOVEVSSU9SXT09PUsuRkFMU0UmJnRoaXMuX21hdHJpeFtRdC5CT1VOREFSWV1bUXQuQk9VTkRBUlldPT09Sy5GQUxTRX1pc0Nyb3NzZXModCxlKXtyZXR1cm4gdD09PUsuUCYmZT09PUsuTHx8dD09PUsuUCYmZT09PUsuQXx8dD09PUsuTCYmZT09PUsuQT9KdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl0pJiZKdC5pc1RydWUodGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5FWFRFUklPUl0pOnQ9PT1LLkwmJmU9PT1LLlB8fHQ9PT1LLkEmJmU9PT1LLlB8fHQ9PT1LLkEmJmU9PT1LLkw/SnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5JTlRFUklPUl1bUXQuSU5URVJJT1JdKSYmSnQuaXNUcnVlKHRoaXMuX21hdHJpeFtRdC5FWFRFUklPUl1bUXQuSU5URVJJT1JdKTp0PT09Sy5MJiZlPT09Sy5MJiYwPT09dGhpcy5fbWF0cml4W1F0LklOVEVSSU9SXVtRdC5JTlRFUklPUl19Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1jbGFzcyAkdHtzdGF0aWMgdG9EZWdyZWVzKHQpe3JldHVybiAxODAqdC9NYXRoLlBJfXN0YXRpYyBub3JtYWxpemUodCl7Zm9yKDt0Pk1hdGguUEk7KXQtPSR0LlBJX1RJTUVTXzI7Zm9yKDt0PD0tTWF0aC5QSTspdCs9JHQuUElfVElNRVNfMjtyZXR1cm4gdH1zdGF0aWMgYW5nbGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYXRhbjIodC55LHQueCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxzPWUueS10Lnk7cmV0dXJuIE1hdGguYXRhbjIocyxuKX19c3RhdGljIGlzQWN1dGUodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnk7cmV0dXJuIHMqKG4ueC1lLngpK2kqKG4ueS1lLnkpPjB9c3RhdGljIGlzT2J0dXNlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55O3JldHVybiBzKihuLngtZS54KStpKihuLnktZS55KTwwfXN0YXRpYyBpbnRlcmlvckFuZ2xlKHQsZSxuKXtjb25zdCBzPSR0LmFuZ2xlKGUsdCksaT0kdC5hbmdsZShlLG4pO3JldHVybiBNYXRoLmFicyhpLXMpfXN0YXRpYyBub3JtYWxpemVQb3NpdGl2ZSh0KXtpZih0PDApe2Zvcig7dDwwOyl0Kz0kdC5QSV9USU1FU18yO3Q+PSR0LlBJX1RJTUVTXzImJih0PTApfWVsc2V7Zm9yKDt0Pj0kdC5QSV9USU1FU18yOyl0LT0kdC5QSV9USU1FU18yO3Q8MCYmKHQ9MCl9cmV0dXJuIHR9c3RhdGljIGFuZ2xlQmV0d2Vlbih0LGUsbil7Y29uc3Qgcz0kdC5hbmdsZShlLHQpLGk9JHQuYW5nbGUoZSxuKTtyZXR1cm4gJHQuZGlmZihzLGkpfXN0YXRpYyBkaWZmKHQsZSl7bGV0IG49bnVsbDtyZXR1cm4gbj10PGU/ZS10OnQtZSxuPk1hdGguUEkmJihuPTIqTWF0aC5QSS1uKSxufXN0YXRpYyB0b1JhZGlhbnModCl7cmV0dXJuIHQqTWF0aC5QSS8xODB9c3RhdGljIGdldFR1cm4odCxlKXtjb25zdCBuPU1hdGguc2luKGUtdCk7cmV0dXJuIG4+MD8kdC5DT1VOVEVSQ0xPQ0tXSVNFOm48MD8kdC5DTE9DS1dJU0U6JHQuTk9ORX1zdGF0aWMgYW5nbGVCZXR3ZWVuT3JpZW50ZWQodCxlLG4pe2NvbnN0IHM9JHQuYW5nbGUoZSx0KSxpPSR0LmFuZ2xlKGUsbiktcztyZXR1cm4gaTw9LU1hdGguUEk/aSskdC5QSV9USU1FU18yOmk+TWF0aC5QST9pLSR0LlBJX1RJTUVTXzI6aX19JHQuUElfVElNRVNfMj0yKk1hdGguUEksJHQuUElfT1ZFUl8yPU1hdGguUEkvMiwkdC5QSV9PVkVSXzQ9TWF0aC5QSS80LCR0LkNPVU5URVJDTE9DS1dJU0U9Ry5DT1VOVEVSQ0xPQ0tXSVNFLCR0LkNMT0NLV0lTRT1HLkNMT0NLV0lTRSwkdC5OT05FPUcuQ09MTElORUFSO2NsYXNzIHRlIGV4dGVuZHMgbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7bi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFwiUHJvamVjdGl2ZSBwb2ludCBub3QgcmVwcmVzZW50YWJsZSBvbiB0aGUgQ2FydGVzaWFuIHBsYW5lLlwiKX19Y2xhc3MgZWV7Y29uc3RydWN0b3IoKXtlZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLnc9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLng9MCx0aGlzLnk9MCx0aGlzLnc9MTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy53PTF9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy54PXQsdGhpcy55PWUsdGhpcy53PTF9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55KmUudy1lLnkqdC53LHRoaXMueT1lLngqdC53LXQueCplLncsdGhpcy53PXQueCplLnktZS54KnQueX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55LWUueSx0aGlzLnk9ZS54LXQueCx0aGlzLnc9dC54KmUueS1lLngqdC55fX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLnc9bn1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPXQueS1lLnkscj1lLngtdC54LG89dC54KmUueS1lLngqdC55LGw9bi55LXMueSxhPXMueC1uLngsYz1uLngqcy55LXMueCpuLnk7dGhpcy54PXIqYy1hKm8sdGhpcy55PWwqby1pKmMsdGhpcy53PWkqYS1sKnJ9fWdldFkoKXtjb25zdCB0PXRoaXMueS90aGlzLnc7aWYoci5pc05hTih0KXx8ci5pc0luZmluaXRlKHQpKXRocm93IG5ldyB0ZTtyZXR1cm4gdH1nZXRYKCl7Y29uc3QgdD10aGlzLngvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdGU7cmV0dXJuIHR9Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9bmV3IG07cmV0dXJuIHQueD10aGlzLmdldFgoKSx0Lnk9dGhpcy5nZXRZKCksdH19Y2xhc3MgbmV7Y29uc3RydWN0b3IoKXtuZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMucDI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLnAwPXQsdGhpcy5wMT1lLHRoaXMucDI9bn1zdGF0aWMgYXJlYSh0LGUsbil7cmV0dXJuIE1hdGguYWJzKCgobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzIpfXN0YXRpYyBzaWduZWRBcmVhKHQsZSxuKXtyZXR1cm4oKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yfXN0YXRpYyBkZXQodCxlLG4scyl7cmV0dXJuIHQqcy1lKm59c3RhdGljIGludGVycG9sYXRlWih0LGUsbixzKXtjb25zdCBpPWUueCxyPWUueSxvPW4ueC1pLGw9cy54LWksYT1uLnktcixjPXMueS1yLGg9bypjLWwqYSx1PXQueC1pLGc9dC55LXIsZD0oYyp1LWwqZykvaCxfPSgtYSp1K28qZykvaDtyZXR1cm4gZS5nZXRaKCkrZCoobi5nZXRaKCktZS5nZXRaKCkpK18qKHMuZ2V0WigpLWUuZ2V0WigpKX1zdGF0aWMgbG9uZ2VzdFNpZGVMZW5ndGgodCxlLG4pe2NvbnN0IHM9dC5kaXN0YW5jZShlKSxpPWUuZGlzdGFuY2Uobikscj1uLmRpc3RhbmNlKHQpO2xldCBvPXM7cmV0dXJuIGk+byYmKG89aSkscj5vJiYobz1yKSxvfXN0YXRpYyBjaXJjdW1jZW50cmVERCh0LGUsbil7Y29uc3Qgcz1ELnZhbHVlT2YodC54KS5zdWJ0cmFjdChuLngpLGk9RC52YWx1ZU9mKHQueSkuc3VidHJhY3Qobi55KSxyPUQudmFsdWVPZihlLngpLnN1YnRyYWN0KG4ueCksbz1ELnZhbHVlT2YoZS55KS5zdWJ0cmFjdChuLnkpLGw9RC5kZXRlcm1pbmFudChzLGkscixvKS5tdWx0aXBseSgyKSxhPXMuc3FyKCkuYWRkKGkuc3FyKCkpLGM9ci5zcXIoKS5hZGQoby5zcXIoKSksaD1ELmRldGVybWluYW50KGksYSxvLGMpLHU9RC5kZXRlcm1pbmFudChzLGEscixjKSxnPUQudmFsdWVPZihuLngpLnN1YnRyYWN0KGguZGl2aWRlKGwpKS5kb3VibGVWYWx1ZSgpLGQ9RC52YWx1ZU9mKG4ueSkuYWRkKHUuZGl2aWRlKGwpKS5kb3VibGVWYWx1ZSgpO3JldHVybiBuZXcgbShnLGQpfXN0YXRpYyBpc0FjdXRlKHQsZSxuKXtyZXR1cm4hISR0LmlzQWN1dGUodCxlLG4pJiYoISEkdC5pc0FjdXRlKGUsbix0KSYmISEkdC5pc0FjdXRlKG4sdCxlKSl9c3RhdGljIGNpcmN1bWNlbnRyZSh0LGUsbil7Y29uc3Qgcz1uLngsaT1uLnkscj10LngtcyxvPXQueS1pLGw9ZS54LXMsYT1lLnktaSxjPTIqbmUuZGV0KHIsbyxsLGEpLGg9bmUuZGV0KG8scipyK28qbyxhLGwqbCthKmEpLHU9bmUuZGV0KHIscipyK28qbyxsLGwqbCthKmEpO3JldHVybiBuZXcgbShzLWgvYyxpK3UvYyl9c3RhdGljIHBlcnBlbmRpY3VsYXJCaXNlY3Rvcih0LGUpe2NvbnN0IG49ZS54LXQueCxzPWUueS10LnksaT1uZXcgZWUodC54K24vMix0Lnkrcy8yLDEpLHI9bmV3IGVlKHQueC1zK24vMix0LnkrbitzLzIsMSk7cmV0dXJuIG5ldyBlZShpLHIpfXN0YXRpYyBhbmdsZUJpc2VjdG9yKHQsZSxuKXtjb25zdCBzPWUuZGlzdGFuY2UodCksaT1zLyhzK2UuZGlzdGFuY2UobikpLHI9bi54LXQueCxvPW4ueS10Lnk7cmV0dXJuIG5ldyBtKHQueCtpKnIsdC55K2kqbyl9c3RhdGljIGFyZWEzRCh0LGUsbil7Y29uc3Qgcz1lLngtdC54LGk9ZS55LXQueSxyPWUuZ2V0WigpLXQuZ2V0WigpLG89bi54LXQueCxsPW4ueS10LnksYT1uLmdldFooKS10LmdldFooKSxjPWkqYS1yKmwsaD1yKm8tcyphLHU9cypsLWkqbyxnPWMqYytoKmgrdSp1O3JldHVybiBNYXRoLnNxcnQoZykvMn1zdGF0aWMgY2VudHJvaWQodCxlLG4pe2NvbnN0IHM9KHQueCtlLngrbi54KS8zLGk9KHQueStlLnkrbi55KS8zO3JldHVybiBuZXcgbShzLGkpfXN0YXRpYyBpbkNlbnRyZSh0LGUsbil7Y29uc3Qgcz1lLmRpc3RhbmNlKG4pLGk9dC5kaXN0YW5jZShuKSxyPXQuZGlzdGFuY2UoZSksbz1zK2krcixsPShzKnQueCtpKmUueCtyKm4ueCkvbyxhPShzKnQueStpKmUueStyKm4ueSkvbztyZXR1cm4gbmV3IG0obCxhKX1hcmVhKCl7cmV0dXJuIG5lLmFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfXNpZ25lZEFyZWEoKXtyZXR1cm4gbmUuc2lnbmVkQXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aW50ZXJwb2xhdGVaKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBzKFwiU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC5cIik7cmV0dXJuIG5lLmludGVycG9sYXRlWih0LHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1sb25nZXN0U2lkZUxlbmd0aCgpe3JldHVybiBuZS5sb25nZXN0U2lkZUxlbmd0aCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aXNBY3V0ZSgpe3JldHVybiBuZS5pc0FjdXRlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1jaXJjdW1jZW50cmUoKXtyZXR1cm4gbmUuY2lyY3VtY2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1hcmVhM0QoKXtyZXR1cm4gbmUuYXJlYTNEKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1jZW50cm9pZCgpe3JldHVybiBuZS5jZW50cm9pZCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9aW5DZW50cmUoKXtyZXR1cm4gbmUuaW5DZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfX1jbGFzcyBzZSBleHRlbmRzIG57Y29uc3RydWN0b3IoKXtzdXBlcigpLHNlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW4uY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX19Y2xhc3MgaWV7Y29uc3RydWN0b3IoKXtpZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tMDA9bnVsbCx0aGlzLl9tMDE9bnVsbCx0aGlzLl9tMDI9bnVsbCx0aGlzLl9tMTA9bnVsbCx0aGlzLl9tMTE9bnVsbCx0aGlzLl9tMTI9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvSWRlbnRpdHkoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tMDA9dFswXSx0aGlzLl9tMDE9dFsxXSx0aGlzLl9tMDI9dFsyXSx0aGlzLl9tMTA9dFszXSx0aGlzLl9tMTE9dFs0XSx0aGlzLl9tMTI9dFs1XX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgaWUpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0VHJhbnNmb3JtYXRpb24odCl9fWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbNV0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbNF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbM10mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3RoaXMuc2V0VHJhbnNmb3JtYXRpb24odCxlLG4scyxpLHIpfX1zdGF0aWMgdHJhbnNsYXRpb25JbnN0YW5jZSh0LGUpe2NvbnN0IG49bmV3IGllO3JldHVybiBuLnNldFRvVHJhbnNsYXRpb24odCxlKSxufXN0YXRpYyBzaGVhckluc3RhbmNlKHQsZSl7Y29uc3Qgbj1uZXcgaWU7cmV0dXJuIG4uc2V0VG9TaGVhcih0LGUpLG59c3RhdGljIHJlZmxlY3Rpb25JbnN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1JlZmxlY3Rpb24odCxlKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBpZTtyZXR1cm4gaS5zZXRUb1JlZmxlY3Rpb24odCxlLG4scyksaX19c3RhdGljIHJvdGF0aW9uSW5zdGFuY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGllLnJvdGF0aW9uSW5zdGFuY2UoTWF0aC5zaW4odCksTWF0aC5jb3ModCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1JvdGF0aW9uKHQsZSksbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIGllLnJvdGF0aW9uSW5zdGFuY2UoTWF0aC5zaW4odCksTWF0aC5jb3ModCksZSxuKX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgaWU7cmV0dXJuIGkuc2V0VG9Sb3RhdGlvbih0LGUsbixzKSxpfX1zdGF0aWMgc2NhbGVJbnN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBpZTtyZXR1cm4gbi5zZXRUb1NjYWxlKHQsZSksbn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgaWU7cmV0dXJuIGkudHJhbnNsYXRlKC1uLC1zKSxpLnNjYWxlKHQsZSksaS50cmFuc2xhdGUobixzKSxpfX1zZXRUb1JlZmxlY3Rpb25CYXNpYyh0LGUsbixpKXtpZih0PT09biYmZT09PWkpdGhyb3cgbmV3IHMoXCJSZWZsZWN0aW9uIGxpbmUgcG9pbnRzIG11c3QgYmUgZGlzdGluY3RcIik7Y29uc3Qgcj1uLXQsbz1pLWUsbD1NYXRoLnNxcnQocipyK28qbyksYT1vL2wsYz1yL2wsaD0yKmEqYyx1PWMqYy1hKmE7cmV0dXJuIHRoaXMuX20wMD11LHRoaXMuX20wMT1oLHRoaXMuX20wMj0wLHRoaXMuX20xMD1oLHRoaXMuX20xMT0tdSx0aGlzLl9tMTI9MCx0aGlzfWdldEludmVyc2UoKXtjb25zdCB0PXRoaXMuZ2V0RGV0ZXJtaW5hbnQoKTtpZigwPT09dCl0aHJvdyBuZXcgc2UoXCJUcmFuc2Zvcm1hdGlvbiBpcyBub24taW52ZXJ0aWJsZVwiKTtjb25zdCBlPXRoaXMuX20xMS90LG49LXRoaXMuX20xMC90LHM9LXRoaXMuX20wMS90LGk9dGhpcy5fbTAwL3Qscj0odGhpcy5fbTAxKnRoaXMuX20xMi10aGlzLl9tMDIqdGhpcy5fbTExKS90LG89KC10aGlzLl9tMDAqdGhpcy5fbTEyK3RoaXMuX20xMCp0aGlzLl9tMDIpL3Q7cmV0dXJuIG5ldyBpZShlLHMscixuLGksbyl9Y29tcG9zZSh0KXtjb25zdCBlPXQuX20wMCp0aGlzLl9tMDArdC5fbTAxKnRoaXMuX20xMCxuPXQuX20wMCp0aGlzLl9tMDErdC5fbTAxKnRoaXMuX20xMSxzPXQuX20wMCp0aGlzLl9tMDIrdC5fbTAxKnRoaXMuX20xMit0Ll9tMDIsaT10Ll9tMTAqdGhpcy5fbTAwK3QuX20xMSp0aGlzLl9tMTAscj10Ll9tMTAqdGhpcy5fbTAxK3QuX20xMSp0aGlzLl9tMTEsbz10Ll9tMTAqdGhpcy5fbTAyK3QuX20xMSp0aGlzLl9tMTIrdC5fbTEyO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9bix0aGlzLl9tMDI9cyx0aGlzLl9tMTA9aSx0aGlzLl9tMTE9cix0aGlzLl9tMTI9byx0aGlzfWVxdWFscyh0KXtpZihudWxsPT09dClyZXR1cm4hMTtpZighKHQgaW5zdGFuY2VvZiBpZSkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLl9tMDA9PT1lLl9tMDAmJnRoaXMuX20wMT09PWUuX20wMSYmdGhpcy5fbTAyPT09ZS5fbTAyJiZ0aGlzLl9tMTA9PT1lLl9tMTAmJnRoaXMuX20xMT09PWUuX20xMSYmdGhpcy5fbTEyPT09ZS5fbTEyfXNldFRvU2NhbGUodCxlKXtyZXR1cm4gdGhpcy5fbTAwPXQsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTAsdGhpcy5fbTExPWUsdGhpcy5fbTEyPTAsdGhpc31pc0lkZW50aXR5KCl7cmV0dXJuIDE9PT10aGlzLl9tMDAmJjA9PT10aGlzLl9tMDEmJjA9PT10aGlzLl9tMDImJjA9PT10aGlzLl9tMTAmJjE9PT10aGlzLl9tMTEmJjA9PT10aGlzLl9tMTJ9c2NhbGUodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnNjYWxlSW5zdGFuY2UodCxlKSksdGhpc31zZXRUb0lkZW50aXR5KCl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT0wLHRoaXMuX20wMj0wLHRoaXMuX20xMD0wLHRoaXMuX20xMT0xLHRoaXMuX20xMj0wLHRoaXN9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMH1zZXRUcmFuc2Zvcm1hdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbTAwPXQuX20wMCx0aGlzLl9tMDE9dC5fbTAxLHRoaXMuX20wMj10Ll9tMDIsdGhpcy5fbTEwPXQuX20xMCx0aGlzLl9tMTE9dC5fbTExLHRoaXMuX20xMj10Ll9tMTIsdGhpc31pZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07cmV0dXJuIHRoaXMuX20wMD10LHRoaXMuX20wMT1lLHRoaXMuX20wMj1uLHRoaXMuX20xMD1zLHRoaXMuX20xMT1pLHRoaXMuX20xMj1yLHRoaXN9fXNldFRvUm90YXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2V0VG9Sb3RhdGlvbihNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSksdGhpc31pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT0tdCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9dCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9MCx0aGlzfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdGhpcy5zZXRUb1JvdGF0aW9uKE1hdGguc2luKHQpLE1hdGguY29zKHQpLGUsbiksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT0tdCx0aGlzLl9tMDI9bi1uKmUrcyp0LHRoaXMuX20xMD10LHRoaXMuX20xMT1lLHRoaXMuX20xMj1zLW4qdC1zKmUsdGhpc319Z2V0TWF0cml4RW50cmllcygpe3JldHVyblt0aGlzLl9tMDAsdGhpcy5fbTAxLHRoaXMuX20wMix0aGlzLl9tMTAsdGhpcy5fbTExLHRoaXMuX20xMl19ZmlsdGVyKHQsZSl7dGhpcy50cmFuc2Zvcm0odCxlKX1yb3RhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQpKSx0aGlzfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJvdGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc31pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQsZSxuKSksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuY29tcG9zZShpZS5yb3RhdGlvbkluc3RhbmNlKHQsZSxuLHMpKSx0aGlzfX1nZXREZXRlcm1pbmFudCgpe3JldHVybiB0aGlzLl9tMDAqdGhpcy5fbTExLXRoaXMuX20wMSp0aGlzLl9tMTB9Y29tcG9zZUJlZm9yZSh0KXtjb25zdCBlPXRoaXMuX20wMCp0Ll9tMDArdGhpcy5fbTAxKnQuX20xMCxuPXRoaXMuX20wMCp0Ll9tMDErdGhpcy5fbTAxKnQuX20xMSxzPXRoaXMuX20wMCp0Ll9tMDIrdGhpcy5fbTAxKnQuX20xMit0aGlzLl9tMDIsaT10aGlzLl9tMTAqdC5fbTAwK3RoaXMuX20xMSp0Ll9tMTAscj10aGlzLl9tMTAqdC5fbTAxK3RoaXMuX20xMSp0Ll9tMTEsbz10aGlzLl9tMTAqdC5fbTAyK3RoaXMuX20xMSp0Ll9tMTIrdGhpcy5fbTEyO3JldHVybiB0aGlzLl9tMDA9ZSx0aGlzLl9tMDE9bix0aGlzLl9tMDI9cyx0aGlzLl9tMTA9aSx0aGlzLl9tMTE9cix0aGlzLl9tMTI9byx0aGlzfXNldFRvU2hlYXIodCxlKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPXQsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPWUsdGhpcy5fbTExPTEsdGhpcy5fbTEyPTAsdGhpc31pc0RvbmUoKXtyZXR1cm4hMX1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBuKSl0aHJvdyB0O2cuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbnVsbH10cmFuc2xhdGUodCxlKXtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnRyYW5zbGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc31zZXRUb1JlZmxlY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBzKFwiUmVmbGVjdGlvbiB2ZWN0b3IgbXVzdCBiZSBub24temVyb1wiKTtpZih0PT09ZSlyZXR1cm4gdGhpcy5fbTAwPTAsdGhpcy5fbTAxPTEsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTEsdGhpcy5fbTExPTAsdGhpcy5fbTEyPTAsdGhpcztjb25zdCBuPU1hdGguc3FydCh0KnQrZSplKSxpPWUvbixyPXQvbjtyZXR1cm4gdGhpcy5yb3RhdGUoLWksciksdGhpcy5zY2FsZSgxLC0xKSx0aGlzLnJvdGF0ZShpLHIpLHRoaXN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO2lmKHQ9PT1uJiZlPT09aSl0aHJvdyBuZXcgcyhcIlJlZmxlY3Rpb24gbGluZSBwb2ludHMgbXVzdCBiZSBkaXN0aW5jdFwiKTt0aGlzLnNldFRvVHJhbnNsYXRpb24oLXQsLWUpO2NvbnN0IHI9bi10LG89aS1lLGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9by9sLGM9ci9sO3JldHVybiB0aGlzLnJvdGF0ZSgtYSxjKSx0aGlzLnNjYWxlKDEsLTEpLHRoaXMucm90YXRlKGEsYyksdGhpcy50cmFuc2xhdGUodCxlKSx0aGlzfX10b1N0cmluZygpe3JldHVyblwiQWZmaW5lVHJhbnNmb3JtYXRpb25bW1wiK3RoaXMuX20wMCtcIiwgXCIrdGhpcy5fbTAxK1wiLCBcIit0aGlzLl9tMDIrXCJdLCBbXCIrdGhpcy5fbTEwK1wiLCBcIit0aGlzLl9tMTErXCIsIFwiK3RoaXMuX20xMitcIl1dXCJ9c2V0VG9UcmFuc2xhdGlvbih0LGUpe3JldHVybiB0aGlzLl9tMDA9MSx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9dCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9MSx0aGlzLl9tMTI9ZSx0aGlzfXNoZWFyKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShpZS5zaGVhckluc3RhbmNlKHQsZSkpLHRoaXN9dHJhbnNmb3JtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmNvcHkoKTtyZXR1cm4gdC5hcHBseSh0aGlzKSx0fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9tMDAqdC54K3RoaXMuX20wMSp0LnkrdGhpcy5fbTAyLHM9dGhpcy5fbTEwKnQueCt0aGlzLl9tMTEqdC55K3RoaXMuX20xMjtyZXR1cm4gZS54PW4sZS55PXMsZX1pZihJKGFyZ3VtZW50c1swXSxGKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX20wMCp0LmdldE9yZGluYXRlKGUsMCkrdGhpcy5fbTAxKnQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLl9tMDIscz10aGlzLl9tMTAqdC5nZXRPcmRpbmF0ZShlLDApK3RoaXMuX20xMSp0LmdldE9yZGluYXRlKGUsMSkrdGhpcy5fbTEyO3Quc2V0T3JkaW5hdGUoZSwwLG4pLHQuc2V0T3JkaW5hdGUoZSwxLHMpfX19cmVmbGVjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJlZmxlY3Rpb25JbnN0YW5jZSh0LGUpKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdGhpcy5jb21wb3NlKGllLnJlZmxlY3Rpb25JbnN0YW5jZSh0LGUsbixzKSksdGhpc319Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2wsUF19fWNsYXNzIHJle3N0YXRpYyBzb2x2ZSh0LGUpe2NvbnN0IG49ZS5sZW5ndGg7aWYodC5sZW5ndGghPT1ufHx0WzBdLmxlbmd0aCE9PW4pdGhyb3cgbmV3IHMoXCJNYXRyaXggQSBpcyBpbmNvcnJlY3RseSBzaXplZFwiKTtmb3IobGV0IHM9MDtzPG47cysrKXtsZXQgaT1zO2ZvcihsZXQgZT1zKzE7ZTxuO2UrKylNYXRoLmFicyh0W2VdW3NdKT5NYXRoLmFicyh0W2ldW3NdKSYmKGk9ZSk7aWYoMD09PXRbaV1bc10pcmV0dXJuIG51bGw7cmUuc3dhcFJvd3ModCxzLGkpLHJlLnN3YXBSb3dzKGUscyxpKTtmb3IobGV0IGk9cysxO2k8bjtpKyspe2NvbnN0IHI9dFtpXVtzXS90W3NdW3NdO2ZvcihsZXQgZT1uLTE7ZT49cztlLS0pdFtpXVtlXS09dFtzXVtlXSpyO2VbaV0tPWVbc10qcn19Y29uc3QgaT1uZXcgQXJyYXkobikuZmlsbChudWxsKTtmb3IobGV0IHM9bi0xO3M+PTA7cy0tKXtsZXQgcj0wO2ZvcihsZXQgZT1zKzE7ZTxuO2UrKylyKz10W3NdW2VdKmlbZV07aVtzXT0oZVtzXS1yKS90W3NdW3NdfXJldHVybiBpfXN0YXRpYyBzd2FwUm93cygpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IobGV0IHM9MDtzPHRbMF0ubGVuZ3RoO3MrKyl7Y29uc3QgaT10W2VdW3NdO3RbZV1bc109dFtuXVtzXSx0W25dW3NdPWl9fWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKGU9PT1uKXJldHVybiBudWxsO2NvbnN0IHM9dFtlXTt0W2VdPXRbbl0sdFtuXT1zfX19Y2xhc3Mgb2V7Y29uc3RydWN0b3IoKXtvZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zcmMwPW51bGwsdGhpcy5fc3JjMT1udWxsLHRoaXMuX3NyYzI9bnVsbCx0aGlzLl9kZXN0MD1udWxsLHRoaXMuX2Rlc3QxPW51bGwsdGhpcy5fZGVzdDI9bnVsbCx0aGlzLl9tMDA9bnVsbCx0aGlzLl9tMDE9bnVsbCx0aGlzLl9tMDI9bnVsbCx0aGlzLl9tMTA9bnVsbCx0aGlzLl9tMTE9bnVsbCx0aGlzLl9tMTI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0aGlzLl9zcmMwPXQsdGhpcy5fc3JjMT1lLHRoaXMuX3NyYzI9bix0aGlzLl9kZXN0MD1zLHRoaXMuX2Rlc3QxPWksdGhpcy5fZGVzdDI9cn1zb2x2ZSh0KXtjb25zdCBlPVtbdGhpcy5fc3JjMC54LHRoaXMuX3NyYzAueSwxXSxbdGhpcy5fc3JjMS54LHRoaXMuX3NyYzEueSwxXSxbdGhpcy5fc3JjMi54LHRoaXMuX3NyYzIueSwxXV07cmV0dXJuIHJlLnNvbHZlKGUsdCl9Y29tcHV0ZSgpe2NvbnN0IHQ9W3RoaXMuX2Rlc3QwLngsdGhpcy5fZGVzdDEueCx0aGlzLl9kZXN0Mi54XSxlPXRoaXMuc29sdmUodCk7aWYobnVsbD09PWUpcmV0dXJuITE7dGhpcy5fbTAwPWVbMF0sdGhpcy5fbTAxPWVbMV0sdGhpcy5fbTAyPWVbMl07Y29uc3Qgbj1bdGhpcy5fZGVzdDAueSx0aGlzLl9kZXN0MS55LHRoaXMuX2Rlc3QyLnldLHM9dGhpcy5zb2x2ZShuKTtyZXR1cm4gbnVsbCE9PXMmJih0aGlzLl9tMTA9c1swXSx0aGlzLl9tMTE9c1sxXSx0aGlzLl9tMTI9c1syXSwhMCl9Z2V0VHJhbnNmb3JtYXRpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCk/bmV3IGllKHRoaXMuX20wMCx0aGlzLl9tMDEsdGhpcy5fbTAyLHRoaXMuX20xMCx0aGlzLl9tMTEsdGhpcy5fbTEyKTpudWxsfX1jbGFzcyBsZXtzdGF0aWMgY3JlYXRlRnJvbUJhc2VMaW5lcyh0LGUsbixzKXtjb25zdCBpPW5ldyBtKHQueCtzLngtbi54LHQueStzLnktbi55KSxyPSR0LmFuZ2xlQmV0d2Vlbk9yaWVudGVkKGUsdCxpKSxvPWUuZGlzdGFuY2UodCksbD1zLmRpc3RhbmNlKG4pO2lmKDA9PT1vKXJldHVybiBuZXcgaWU7Y29uc3QgYT1sL28sYz1pZS50cmFuc2xhdGlvbkluc3RhbmNlKC10LngsLXQueSk7cmV0dXJuIGMucm90YXRlKHIpLGMuc2NhbGUoYSxhKSxjLnRyYW5zbGF0ZShuLngsbi55KSxjfXN0YXRpYyBjcmVhdGVGcm9tQ29udHJvbFZlY3RvcnMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxzPWUueS10Lnk7cmV0dXJuIGllLnRyYW5zbGF0aW9uSW5zdGFuY2UobixzKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBzKFwiU3JjIGFuZCBEZXN0IGFycmF5cyBhcmUgbm90IHRoZSBzYW1lIGxlbmd0aFwiKTtpZih0Lmxlbmd0aDw9MCl0aHJvdyBuZXcgcyhcIlRvbyBmZXcgY29udHJvbCBwb2ludHNcIik7aWYodC5sZW5ndGg+Myl0aHJvdyBuZXcgcyhcIlRvbyBtYW55IGNvbnRyb2wgcG9pbnRzXCIpO3JldHVybiAxPT09dC5sZW5ndGg/bGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sZVswXSk6Mj09PXQubGVuZ3RoP2xlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLHRbMV0sZVswXSxlWzFdKTpsZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSx0WzFdLHRbMl0sZVswXSxlWzFdLGVbMl0pfX1lbHNle2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBtKHMueC1uLngscy55LW4ueSkscj0kdC5hbmdsZUJldHdlZW5PcmllbnRlZChlLHQsaSksbz1lLmRpc3RhbmNlKHQpLGw9cy5kaXN0YW5jZShuKTtpZigwPT09bylyZXR1cm4gbnVsbDtjb25zdCBhPWwvbyxjPWllLnRyYW5zbGF0aW9uSW5zdGFuY2UoLXQueCwtdC55KTtyZXR1cm4gYy5yb3RhdGUociksYy5zY2FsZShhLGEpLGMudHJhbnNsYXRlKG4ueCxuLnkpLGN9aWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgb2UoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0pLmdldFRyYW5zZm9ybWF0aW9uKCl9fX19Y2xhc3MgYWV7Y29uc3RydWN0b3IoKXthZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb29yZHM9dH1zdGF0aWMgZ2V0Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgTDtyZXR1cm4gdC5hcHBseShuZXcgYWUoZSkpLGV9ZmlsdGVyKHQpeyh0IGluc3RhbmNlb2YgSnx8dCBpbnN0YW5jZW9mIHR0KSYmdGhpcy5fY29vcmRzLmFkZCh0LmdldENvb3JkaW5hdGUoKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfX1jbGFzcyBjZXtjb25zdHJ1Y3Rvcigpe2NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21hcE9wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWFwT3A9dH1zdGF0aWMgbWFwKHQsZSl7cmV0dXJuIG5ldyBjZShlKS5tYXAodCl9bWFwKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dGhpcy5fbWFwT3AubWFwKHQuZ2V0R2VvbWV0cnlOKG4pKTtzLmlzRW1wdHkoKXx8ZS5hZGQocyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihDdC50b0dlb21ldHJ5QXJyYXkoZSkpfX1jbGFzcyBoZXtjb25zdHJ1Y3Rvcigpe2hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5fc2tpcEVtcHR5PSExLHRoaXMuX2lucHV0R2VvbXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdG9yeT1oZS5leHRyYWN0RmFjdG9yeSh0KSx0aGlzLl9pbnB1dEdlb21zPXR9c3RhdGljIGNvbWJpbmUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBoZShhcmd1bWVudHNbMF0pLmNvbWJpbmUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBoZShoZS5jcmVhdGVMaXN0KHQsZSkpLmNvbWJpbmUoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBoZShoZS5jcmVhdGVMaXN0KHQsZSxuKSkuY29tYmluZSgpfX1zdGF0aWMgZXh0cmFjdEZhY3RvcnkodCl7cmV0dXJuIHQuaXNFbXB0eSgpP251bGw6dC5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCl9c3RhdGljIGNyZWF0ZUxpc3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtyZXR1cm4gbi5hZGQodCksbi5hZGQoZSksbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgTDtyZXR1cm4gcy5hZGQodCkscy5hZGQoZSkscy5hZGQobiksc319ZXh0cmFjdEVsZW1lbnRzKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7dGhpcy5fc2tpcEVtcHR5JiZzLmlzRW1wdHkoKXx8ZS5hZGQocyl9fWNvbWJpbmUoKXtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT10aGlzLl9pbnB1dEdlb21zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuZXh0cmFjdEVsZW1lbnRzKG4sdCl9cmV0dXJuIDA9PT10LnNpemUoKT9udWxsIT09dGhpcy5fZ2VvbUZhY3Rvcnk/dGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6bnVsbDp0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHQpfX1jbGFzcyB1ZXtjb25zdHJ1Y3Rvcigpe3VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9pc1VzZXJEYXRhQ29waWVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9fXNldENvcHlVc2VyRGF0YSh0KXt0aGlzLl9pc1VzZXJEYXRhQ29waWVkPXR9ZWRpdCh0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5lZGl0SW50ZXJuYWwodCxlKTtyZXR1cm4gdGhpcy5faXNVc2VyRGF0YUNvcGllZCYmbi5zZXRVc2VyRGF0YSh0LmdldFVzZXJEYXRhKCkpLG59ZWRpdEludGVybmFsKHQsZSl7cmV0dXJuIG51bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdCBpbnN0YW5jZW9mIGN0P3RoaXMuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpOnQgaW5zdGFuY2VvZiBpdD90aGlzLmVkaXRQb2x5Z29uKHQsZSk6dCBpbnN0YW5jZW9mIHR0fHx0IGluc3RhbmNlb2YgSj9lLmVkaXQodCx0aGlzLl9mYWN0b3J5KTooZy5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuc3VwcG9ydGVkIEdlb21ldHJ5IHR5cGU6IFwiK3QuZ2V0R2VvbWV0cnlUeXBlKCkpLG51bGwpfWVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPWUuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpLHM9bmV3IEw7Zm9yKGxldCB0PTA7dDxuLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IGk9dGhpcy5lZGl0KG4uZ2V0R2VvbWV0cnlOKHQpLGUpO251bGw9PT1pfHxpLmlzRW1wdHkoKXx8cy5hZGQoaSl9cmV0dXJuIG4uZ2V0R2VvbWV0cnlUeXBlKCk9PT1YLlRZUEVOQU1FX01VTFRJUE9JTlQ/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KHMudG9BcnJheShbXSkpOm4uZ2V0R2VvbWV0cnlUeXBlKCk9PT1YLlRZUEVOQU1FX01VTFRJTElORVNUUklORz90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhzLnRvQXJyYXkoW10pKTpuLmdldEdlb21ldHJ5VHlwZSgpPT09WC5UWVBFTkFNRV9NVUxUSVBPTFlHT04/dGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24ocy50b0FycmF5KFtdKSk6dGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24ocy50b0FycmF5KFtdKSl9ZWRpdFBvbHlnb24odCxlKXtsZXQgbj1lLmVkaXQodCx0aGlzLl9mYWN0b3J5KTtpZihudWxsPT09biYmKG49dGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCkpLG4uaXNFbXB0eSgpKXJldHVybiBuO2NvbnN0IHM9dGhpcy5lZGl0KG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSk7aWYobnVsbD09PXN8fHMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTtjb25zdCBpPW5ldyBMO2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1JbnRlcmlvclJpbmcoKTt0Kyspe2NvbnN0IHM9dGhpcy5lZGl0KG4uZ2V0SW50ZXJpb3JSaW5nTih0KSxlKTtudWxsPT09c3x8cy5pc0VtcHR5KCl8fGkuYWRkKHMpfXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24ocyxpLnRvQXJyYXkoW10pKX19ZnVuY3Rpb24gZ2UoKXt9dWUuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb249Z2U7dWUuTm9PcEdlb21ldHJ5T3BlcmF0aW9uPWNsYXNze2VkaXQodCxlKXtyZXR1cm4gdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ2VdfX0sdWUuQ29vcmRpbmF0ZU9wZXJhdGlvbj1jbGFzc3tlZGl0KHQsZSl7Y29uc3Qgbj10aGlzLmVkaXQodC5nZXRDb29yZGluYXRlcygpLHQpO3JldHVybiB0IGluc3RhbmNlb2YgdXQ/bnVsbD09PW4/ZS5jcmVhdGVMaW5lYXJSaW5nKCk6ZS5jcmVhdGVMaW5lYXJSaW5nKG4pOnQgaW5zdGFuY2VvZiBKP251bGw9PT1uP2UuY3JlYXRlTGluZVN0cmluZygpOmUuY3JlYXRlTGluZVN0cmluZyhuKTp0IGluc3RhbmNlb2YgdHQ/bnVsbD09PW58fDA9PT1uLmxlbmd0aD9lLmNyZWF0ZVBvaW50KCk6ZS5jcmVhdGVQb2ludChuWzBdKTp0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnZV19fSx1ZS5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb249Y2xhc3N7ZWRpdCh0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgdXQ/ZS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgSj9lLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnQgaW5zdGFuY2VvZiB0dD9lLmNyZWF0ZVBvaW50KHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnZV19fTtjbGFzcyBkZXtjb25zdHJ1Y3Rvcigpe2RlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21ldHJ5VHlwZT1udWxsLHRoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbWV0cnlUeXBlPXQsdGhpcy5fY29tcHM9ZX1zdGF0aWMgaXNPZlR5cGUodCxlKXtyZXR1cm4gdC5nZXRHZW9tZXRyeVR5cGUoKT09PWV8fGU9PT1YLlRZUEVOQU1FX0xJTkVTVFJJTkcmJnQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1YLlRZUEVOQU1FX0xJTkVBUlJJTkd9c3RhdGljIGV4dHJhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGRlLmV4dHJhY3QodCxlLG5ldyBMKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1lP24uYWRkKHQpOnQgaW5zdGFuY2VvZiBjdCYmdC5hcHBseShuZXcgZGUoZSxuKSksbn19ZmlsdGVyKHQpeyhudWxsPT09dGhpcy5fZ2VvbWV0cnlUeXBlfHxkZS5pc09mVHlwZSh0LHRoaXMuX2dlb21ldHJ5VHlwZSkpJiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1FdfX1jbGFzcyBfZXtzdGF0aWMgbWFwKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYJiZJKGFyZ3VtZW50c1sxXSxwZSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEw7Zm9yKGxldCBzPTA7czx0LmdldE51bUdlb21ldHJpZXMoKTtzKyspe2NvbnN0IGk9ZS5tYXAodC5nZXRHZW9tZXRyeU4ocykpO251bGwhPT1pJiZuLmFkZChpKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShuKX1pZihJKGFyZ3VtZW50c1swXSxOKSYmSShhcmd1bWVudHNbMV0scGUpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9ZS5tYXAodCk7bnVsbCE9PWkmJm4uYWRkKGkpfXJldHVybiBufX19ZnVuY3Rpb24gcGUoKXt9X2UuTWFwT3A9cGU7Y2xhc3MgbWV7Y29uc3RydWN0b3IoKXttZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5PSEwLHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT0hMCx0aGlzLl9wcmVzZXJ2ZUNvbGxlY3Rpb25zPSExLHRoaXMuX3ByZXNlcnZlVHlwZT0hMX10cmFuc2Zvcm1Qb2ludCh0LGUpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9dHJhbnNmb3JtUG9seWdvbih0LGUpe2xldCBuPSEwO2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksdCk7bnVsbCE9PXMmJnMgaW5zdGFuY2VvZiB1dCYmIXMuaXNFbXB0eSgpfHwobj0hMSk7Y29uc3QgaT1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEludGVyaW9yUmluZ04oZSksdCk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHwocyBpbnN0YW5jZW9mIHV0fHwobj0hMSksaS5hZGQocykpfWlmKG4pcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzLGkudG9BcnJheShbXSkpO3tjb25zdCB0PW5ldyBMO3JldHVybiBudWxsIT09cyYmdC5hZGQocyksdC5hZGRBbGwoaSksdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHQpfX1jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UodCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KX1nZXRJbnB1dEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2lucHV0R2VvbX10cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcodCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LmdldEdlb21ldHJ5TihlKSx0KTtudWxsIT09cyYmKHMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe3JldHVybiB0aGlzLmNvcHkodCl9dHJhbnNmb3JtTGluZVN0cmluZyh0LGUpe3JldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX10cmFuc2Zvcm1NdWx0aVBvaW50KHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybVBvaW50KHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfWNvcHkodCl7cmV0dXJuIHQuY29weSgpfXRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49bmV3IEw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm0odC5nZXRHZW9tZXRyeU4oZSkpO251bGwhPT1zJiYodGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5JiZzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU/dGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oQ3QudG9HZW9tZXRyeUFycmF5KG4pKTp0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtKHQpe2lmKHRoaXMuX2lucHV0R2VvbT10LHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksdCBpbnN0YW5jZW9mIHR0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGh0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgdXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBKKXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2Ygd3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGl0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgZnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGN0KXJldHVybiB0aGlzLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LG51bGwpO3Rocm93IG5ldyBzKFwiVW5rbm93biBHZW9tZXRyeSBzdWJ0eXBlOiBcIit0LmdldEdlb21ldHJ5VHlwZSgpKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj10aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCk7aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhudWxsKTtjb25zdCBzPW4uc2l6ZSgpO3JldHVybiBzPjAmJnM8NCYmIXRoaXMuX3ByZXNlcnZlVHlwZT90aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobik6dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4pfX1jbGFzcyBmZXtjb25zdHJ1Y3Rvcigpe2ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NvbXBzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcHM9dH1zdGF0aWMgZ2V0R2VvbWV0cnkodCl7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoZmUuZ2V0TGluZXModCkpfXN0YXRpYyBnZXRMaW5lcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gZmUuZ2V0TGluZXModCxuZXcgTCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgSj9lLmFkZCh0KTp0IGluc3RhbmNlb2YgY3QmJnQuYXBwbHkobmV3IGZlKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIEomJnRoaXMuX2NvbXBzLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUV19fWNsYXNzIHlle2NvbnN0cnVjdG9yKCl7eWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGluZXM9bnVsbCx0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz0hMSwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZXM9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9saW5lcz10LHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPWV9fXN0YXRpYyBnZXRHZW9tZXRyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh5ZS5nZXRMaW5lcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHllLmdldExpbmVzKHQsZSkpfX1zdGF0aWMgZ2V0TGluZXMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHllLmdldExpbmVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihJKGFyZ3VtZW50c1swXSxOKSYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7eWUuZ2V0TGluZXMobix0KX1yZXR1cm4gdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBMO3JldHVybiB0LmFwcGx5KG5ldyB5ZShuLGUpKSxufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgSj9lLmFkZCh0KTp0LmFwcGx5KG5ldyB5ZShlKSksZX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJkkoYXJndW1lbnRzWzBdLE4pJiZJKGFyZ3VtZW50c1sxXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl07Zm9yKGxldCBuPWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTt5ZS5nZXRMaW5lcyhzLHQsZSl9cmV0dXJuIHR9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCYmSShhcmd1bWVudHNbMV0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdO3JldHVybiBhcmd1bWVudHNbMF0uYXBwbHkobmV3IHllKHQsZSkpLHR9fX1maWx0ZXIodCl7aWYodGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcmJnQgaW5zdGFuY2VvZiB1dCl7Y29uc3QgZT10LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0aGlzLl9saW5lcy5hZGQoZSksbnVsbH10IGluc3RhbmNlb2YgSiYmdGhpcy5fbGluZXMuYWRkKHQpfXNldEZvcmNlVG9MaW5lU3RyaW5nKHQpe3RoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfX1jb25zdCB4ZT17cmV2ZXJzZU9yZGVyOmZ1bmN0aW9uKCl7cmV0dXJue2NvbXBhcmU6KHQsZSk9PmUuY29tcGFyZVRvKHQpfX0sbWluOmZ1bmN0aW9uKHQpe3JldHVybiB4ZS5zb3J0KHQpLHQuZ2V0KDApfSxzb3J0OmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10LnRvQXJyYXkoKTtlP250LnNvcnQobixlKTpudC5zb3J0KG4pO2NvbnN0IHM9dC5pdGVyYXRvcigpO2ZvcihsZXQgdD0wLGU9bi5sZW5ndGg7dDxlO3QrKylzLm5leHQoKSxzLnNldChuW3RdKX0sc2luZ2xldG9uTGlzdDpmdW5jdGlvbih0KXtjb25zdCBlPW5ldyBMO3JldHVybiBlLmFkZCh0KSxlfX07Y2xhc3MgRWV7Y29uc3RydWN0b3IoKXtFZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dH1zdGF0aWMgZ2V0UG9pbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0IGluc3RhbmNlb2YgdHQ/eGUuc2luZ2xldG9uTGlzdCh0KTpFZS5nZXRQb2ludHModCxuZXcgTCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgdHQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIGN0JiZ0LmFwcGx5KG5ldyBFZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiB0dCYmdGhpcy5fcHRzLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUV19fWNsYXNzIElle2NvbnN0cnVjdG9yKCl7SWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wcz10fXN0YXRpYyBnZXRQb2x5Z29ucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gSWUuZ2V0UG9seWdvbnModCxuZXcgTCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgaXQ/ZS5hZGQodCk6dCBpbnN0YW5jZW9mIGN0JiZ0LmFwcGx5KG5ldyBJZShlKSksZX19ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBpdCYmdGhpcy5fY29tcHMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltRXX19Y2xhc3MgTmV7Y29uc3RydWN0b3IoKXtOZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0RvbmU9ITF9YXBwbHlUbyh0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpJiYhdGhpcy5faXNEb25lO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZihuIGluc3RhbmNlb2YgY3QpdGhpcy5hcHBseVRvKG4pO2Vsc2UgaWYodGhpcy52aXNpdChuKSx0aGlzLmlzRG9uZSgpKXJldHVybiB0aGlzLl9pc0RvbmU9ITAsbnVsbH19fWNsYXNzIFNle2NvbnN0cnVjdG9yKCl7U2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9wcmVjTW9kZWw9bnVsbCx0aGlzLl9kaW09bmV3IHdlLHRoaXMuX25QdHM9MTAwLHRoaXMuX3JvdGF0aW9uQW5nbGU9MCwwPT09YXJndW1lbnRzLmxlbmd0aClTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBDdCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Q9dCx0aGlzLl9wcmVjTW9kZWw9dC5nZXRQcmVjaXNpb25Nb2RlbCgpfX1jcmVhdGVTdXBlcmNpcmNsZSh0KXtjb25zdCBlPTEvdCxuPXRoaXMuX2RpbS5nZXRNaW5TaXplKCkvMixzPXRoaXMuX2RpbS5nZXRDZW50cmUoKSxpPU1hdGgucG93KG4sdCkscj1uLG89TWF0aC5wb3coaS8yLGUpLGw9TWF0aC50cnVuYyh0aGlzLl9uUHRzLzgpLGE9bmV3IEFycmF5KDgqbCsxKS5maWxsKG51bGwpLGM9by9sO2ZvcihsZXQgbj0wO248PWw7bisrKXtsZXQgbz0wLGg9cjtpZigwIT09bil7bz1jKm47Y29uc3Qgcz1NYXRoLnBvdyhvLHQpO2g9TWF0aC5wb3coaS1zLGUpfWFbbl09dGhpcy5jb29yZFRyYW5zKG8saCxzKSxhWzIqbC1uXT10aGlzLmNvb3JkVHJhbnMoaCxvLHMpLGFbMipsK25dPXRoaXMuY29vcmRUcmFucyhoLC1vLHMpLGFbNCpsLW5dPXRoaXMuY29vcmRUcmFucyhvLC1oLHMpLGFbNCpsK25dPXRoaXMuY29vcmRUcmFucygtbywtaCxzKSxhWzYqbC1uXT10aGlzLmNvb3JkVHJhbnMoLWgsLW8scyksYVs2Kmwrbl09dGhpcy5jb29yZFRyYW5zKC1oLG8scyksYVs4Kmwtbl09dGhpcy5jb29yZFRyYW5zKC1vLGgscyl9YVthLmxlbmd0aC0xXT1uZXcgbShhWzBdKTtjb25zdCBoPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcoYSksdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGgpO3JldHVybiB0aGlzLnJvdGF0ZSh1KX1zZXROdW1Qb2ludHModCl7dGhpcy5fblB0cz10fXNldEJhc2UodCl7dGhpcy5fZGltLnNldEJhc2UodCl9c2V0Um90YXRpb24odCl7dGhpcy5fcm90YXRpb25BbmdsZT10fXNldFdpZHRoKHQpe3RoaXMuX2RpbS5zZXRXaWR0aCh0KX1jcmVhdGVFbGxpcHNlKCl7Y29uc3QgdD10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxlPXQuZ2V0V2lkdGgoKS8yLG49dC5nZXRIZWlnaHQoKS8yLHM9dC5nZXRNaW5YKCkrZSxpPXQuZ2V0TWluWSgpK24scj1uZXcgQXJyYXkodGhpcy5fblB0cysxKS5maWxsKG51bGwpO2xldCBvPTA7Zm9yKGxldCB0PTA7dDx0aGlzLl9uUHRzO3QrKyl7Y29uc3QgbD10KigyKk1hdGguUEkvdGhpcy5fblB0cyksYT1lKk1hdGguY29zKGwpK3MsYz1uKk1hdGguc2luKGwpK2k7cltvKytdPXRoaXMuY29vcmQoYSxjKX1yW29dPW5ldyBtKHJbMF0pO2NvbnN0IGw9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhyKSxhPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24obCk7cmV0dXJuIHRoaXMucm90YXRlKGEpfWNvb3JkVHJhbnModCxlLG4pe3JldHVybiB0aGlzLmNvb3JkKHQrbi54LGUrbi55KX1jcmVhdGVTcXVpcmNsZSgpe3JldHVybiB0aGlzLmNyZWF0ZVN1cGVyY2lyY2xlKDQpfXNldEVudmVsb3BlKHQpe3RoaXMuX2RpbS5zZXRFbnZlbG9wZSh0KX1zZXRDZW50cmUodCl7dGhpcy5fZGltLnNldENlbnRyZSh0KX1jcmVhdGVBcmModCxlKXtjb25zdCBuPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLHM9bi5nZXRXaWR0aCgpLzIsaT1uLmdldEhlaWdodCgpLzIscj1uLmdldE1pblgoKStzLG89bi5nZXRNaW5ZKCkraTtsZXQgbD1lOyhsPD0wfHxsPjIqTWF0aC5QSSkmJihsPTIqTWF0aC5QSSk7Y29uc3QgYT1sLyh0aGlzLl9uUHRzLTEpLGM9bmV3IEFycmF5KHRoaXMuX25QdHMpLmZpbGwobnVsbCk7bGV0IGg9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25QdHM7ZSsrKXtjb25zdCBuPXQrZSphLGw9cypNYXRoLmNvcyhuKStyLHU9aSpNYXRoLnNpbihuKStvO2NbaCsrXT10aGlzLmNvb3JkKGwsdSl9Y29uc3QgdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lU3RyaW5nKGMpO3JldHVybiB0aGlzLnJvdGF0ZSh1KX1yb3RhdGUodCl7aWYoMCE9PXRoaXMuX3JvdGF0aW9uQW5nbGUpe2NvbnN0IGU9aWUucm90YXRpb25JbnN0YW5jZSh0aGlzLl9yb3RhdGlvbkFuZ2xlLHRoaXMuX2RpbS5nZXRDZW50cmUoKS54LHRoaXMuX2RpbS5nZXRDZW50cmUoKS55KTt0LmFwcGx5KGUpfXJldHVybiB0fWNvb3JkKHQsZSl7Y29uc3Qgbj1uZXcgbSh0LGUpO3JldHVybiB0aGlzLl9wcmVjTW9kZWwubWFrZVByZWNpc2Uobiksbn1jcmVhdGVBcmNQb2x5Z29uKHQsZSl7Y29uc3Qgbj10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxzPW4uZ2V0V2lkdGgoKS8yLGk9bi5nZXRIZWlnaHQoKS8yLHI9bi5nZXRNaW5YKCkrcyxvPW4uZ2V0TWluWSgpK2k7bGV0IGw9ZTsobDw9MHx8bD4yKk1hdGguUEkpJiYobD0yKk1hdGguUEkpO2NvbnN0IGE9bC8odGhpcy5fblB0cy0xKSxjPW5ldyBBcnJheSh0aGlzLl9uUHRzKzIpLmZpbGwobnVsbCk7bGV0IGg9MDtjW2grK109dGhpcy5jb29yZChyLG8pO2ZvcihsZXQgZT0wO2U8dGhpcy5fblB0cztlKyspe2NvbnN0IG49dCthKmUsbD1zKk1hdGguY29zKG4pK3IsdT1pKk1hdGguc2luKG4pK287Y1toKytdPXRoaXMuY29vcmQobCx1KX1jW2grK109dGhpcy5jb29yZChyLG8pO2NvbnN0IHU9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhjKSxnPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24odSk7cmV0dXJuIHRoaXMucm90YXRlKGcpfWNyZWF0ZVJlY3RhbmdsZSgpe2xldCB0PW51bGwsZT0wLG49TWF0aC50cnVuYyh0aGlzLl9uUHRzLzQpO248MSYmKG49MSk7Y29uc3Qgcz10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKS5nZXRXaWR0aCgpL24saT10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKS5nZXRIZWlnaHQoKS9uLHI9bmV3IEFycmF5KDQqbisxKS5maWxsKG51bGwpLG89dGhpcy5fZGltLmdldEVudmVsb3BlKCk7Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWluWCgpK3QqcyxpPW8uZ2V0TWluWSgpO3JbZSsrXT10aGlzLmNvb3JkKG4saSl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWF4WCgpLHM9by5nZXRNaW5ZKCkrdCppO3JbZSsrXT10aGlzLmNvb3JkKG4scyl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWF4WCgpLXQqcyxpPW8uZ2V0TWF4WSgpO3JbZSsrXT10aGlzLmNvb3JkKG4saSl9Zm9yKHQ9MDt0PG47dCsrKXtjb25zdCBuPW8uZ2V0TWluWCgpLHM9by5nZXRNYXhZKCktdCppO3JbZSsrXT10aGlzLmNvb3JkKG4scyl9cltlKytdPW5ldyBtKHJbMF0pO2NvbnN0IGw9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhyKSxhPXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24obCk7cmV0dXJuIHRoaXMucm90YXRlKGEpfWNyZWF0ZUNpcmNsZSgpe3JldHVybiB0aGlzLmNyZWF0ZUVsbGlwc2UoKX1zZXRIZWlnaHQodCl7dGhpcy5fZGltLnNldEhlaWdodCh0KX1zZXRTaXplKHQpe3RoaXMuX2RpbS5zZXRTaXplKHQpfX1jbGFzcyB3ZXtjb25zdHJ1Y3Rvcigpe3dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuYmFzZT1udWxsLHRoaXMuY2VudHJlPW51bGwsdGhpcy53aWR0aD1udWxsLHRoaXMuaGVpZ2h0PW51bGx9c2V0QmFzZSh0KXt0aGlzLmJhc2U9dH1zZXRXaWR0aCh0KXt0aGlzLndpZHRoPXR9Z2V0QmFzZSgpe3JldHVybiB0aGlzLmJhc2V9Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy53aWR0aH1zZXRFbnZlbG9wZSh0KXt0aGlzLndpZHRoPXQuZ2V0V2lkdGgoKSx0aGlzLmhlaWdodD10LmdldEhlaWdodCgpLHRoaXMuYmFzZT1uZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksdGhpcy5jZW50cmU9bmV3IG0odC5jZW50cmUoKSl9c2V0Q2VudHJlKHQpe3RoaXMuY2VudHJlPXR9Z2V0TWluU2l6ZSgpe3JldHVybiBNYXRoLm1pbih0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KX1nZXRFbnZlbG9wZSgpe3JldHVybiBudWxsIT09dGhpcy5iYXNlP25ldyBPKHRoaXMuYmFzZS54LHRoaXMuYmFzZS54K3RoaXMud2lkdGgsdGhpcy5iYXNlLnksdGhpcy5iYXNlLnkrdGhpcy5oZWlnaHQpOm51bGwhPT10aGlzLmNlbnRyZT9uZXcgTyh0aGlzLmNlbnRyZS54LXRoaXMud2lkdGgvMix0aGlzLmNlbnRyZS54K3RoaXMud2lkdGgvMix0aGlzLmNlbnRyZS55LXRoaXMuaGVpZ2h0LzIsdGhpcy5jZW50cmUueSt0aGlzLmhlaWdodC8yKTpuZXcgTygwLHRoaXMud2lkdGgsMCx0aGlzLmhlaWdodCl9Z2V0Q2VudHJlKCl7cmV0dXJuIG51bGw9PT10aGlzLmNlbnRyZSYmKHRoaXMuY2VudHJlPW5ldyBtKHRoaXMuYmFzZS54K3RoaXMud2lkdGgvMix0aGlzLmJhc2UueSt0aGlzLmhlaWdodC8yKSksdGhpcy5jZW50cmV9Z2V0SGVpZ2h0KCl7cmV0dXJuIHRoaXMuaGVpZ2h0fXNldEhlaWdodCh0KXt0aGlzLmhlaWdodD10fXNldFNpemUodCl7dGhpcy5oZWlnaHQ9dCx0aGlzLndpZHRoPXR9fVNlLkRpbWVuc2lvbnM9d2U7Y2xhc3MgQ2UgZXh0ZW5kcyBTZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQ2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbnVtQXJtcz04LHRoaXMuX2FybUxlbmd0aFJhdGlvPS41LDA9PT1hcmd1bWVudHMubGVuZ3RoKVNlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1NlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fXN0YXRpYyBjcmVhdGUodCxlLG4scyxpKXtjb25zdCByPW5ldyBDZTtyLnNldENlbnRyZSh0KSxyLnNldFNpemUoZSksci5zZXROdW1Qb2ludHMobiksci5zZXRBcm1MZW5ndGhSYXRpbyhpKSxyLnNldE51bUFybXMocyk7cmV0dXJuIHIuY3JlYXRlU2luZVN0YXIoKX1zZXROdW1Bcm1zKHQpe3RoaXMuX251bUFybXM9dH1zZXRBcm1MZW5ndGhSYXRpbyh0KXt0aGlzLl9hcm1MZW5ndGhSYXRpbz10fWNyZWF0ZVNpbmVTdGFyKCl7Y29uc3QgdD10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKSxlPXQuZ2V0V2lkdGgoKS8yO2xldCBuPXRoaXMuX2FybUxlbmd0aFJhdGlvO248MCYmKG49MCksbj4xJiYobj0xKTtjb25zdCBzPW4qZSxpPSgxLW4pKmUscj10LmdldE1pblgoKStlLG89dC5nZXRNaW5ZKCkrZSxsPW5ldyBBcnJheSh0aGlzLl9uUHRzKzEpLmZpbGwobnVsbCk7bGV0IGE9MDtmb3IobGV0IHQ9MDt0PHRoaXMuX25QdHM7dCsrKXtjb25zdCBlPXQvdGhpcy5fblB0cyp0aGlzLl9udW1Bcm1zLG49ZS1NYXRoLmZsb29yKGUpLGM9MipNYXRoLlBJKm4saD1pK3MqKChNYXRoLmNvcyhjKSsxKS8yKSx1PXQqKDIqTWF0aC5QSS90aGlzLl9uUHRzKSxnPWgqTWF0aC5jb3ModSkrcixkPWgqTWF0aC5zaW4odSkrbztsW2ErK109dGhpcy5jb29yZChnLGQpfWxbYV09bmV3IG0obFswXSk7Y29uc3QgYz10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGwpO3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKGMpfX12YXIgTGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQWZmaW5lVHJhbnNmb3JtYXRpb246aWUsQWZmaW5lVHJhbnNmb3JtYXRpb25CdWlsZGVyOm9lLEFmZmluZVRyYW5zZm9ybWF0aW9uRmFjdG9yeTpsZSxDb21wb25lbnRDb29yZGluYXRlRXh0cmFjdGVyOmFlLEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlcjpjZSxHZW9tZXRyeUNvbWJpbmVyOmhlLEdlb21ldHJ5RWRpdG9yOnVlLEdlb21ldHJ5RXh0cmFjdGVyOmRlLEdlb21ldHJ5TWFwcGVyOl9lLEdlb21ldHJ5VHJhbnNmb3JtZXI6bWUsTGluZVN0cmluZ0V4dHJhY3RlcjpmZSxMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXI6eWUsUG9pbnRFeHRyYWN0ZXI6RWUsUG9seWdvbkV4dHJhY3RlcjpJZSxTaG9ydENpcmN1aXRlZEdlb21ldHJ5VmlzaXRvcjpOZSxTaW5lU3RhckZhY3Rvcnk6Q2V9KSxUZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb29yZGluYXRlOm0sQ29vcmRpbmF0ZVhZOnksQ29vcmRpbmF0ZVhZTTp4LENvb3JkaW5hdGVYWVpNOkUsQ29vcmRpbmF0ZUxpc3Q6UixDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXI6UCxFbnZlbG9wZTpPLExpbmVTZWdtZW50Okt0LEdlb21ldHJ5RmFjdG9yeTpDdCxHZW9tZXRyeTpYLFBvaW50OnR0LExpbmVTdHJpbmc6SixMaW5lYXJSaW5nOnV0LFBvbHlnb246aXQsR2VvbWV0cnlDb2xsZWN0aW9uOmN0LE11bHRpUG9pbnQ6aHQsTXVsdGlMaW5lU3RyaW5nOnd0LE11bHRpUG9seWdvbjpmdCxEaW1lbnNpb246SyxJbnRlcnNlY3Rpb25NYXRyaXg6SnQsUHJlY2lzaW9uTW9kZWw6TnQsTG9jYXRpb246UXQsVHJpYW5nbGU6bmUsdXRpbDpMZX0pO2NsYXNzIFJle2NvbnN0cnVjdG9yKCl7UmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHQ9W25ldyBtLG5ldyBtXSx0aGlzLl9kaXN0YW5jZT1yLk5hTix0aGlzLl9pc051bGw9ITB9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRbdF19c2V0TWluaW11bSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldE1pbmltdW0odC5fcHRbMF0sdC5fcHRbMV0pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzTnVsbClyZXR1cm4gdGhpcy5pbml0aWFsaXplKHQsZSksbnVsbDtjb25zdCBuPXQuZGlzdGFuY2UoZSk7bjx0aGlzLl9kaXN0YW5jZSYmdGhpcy5pbml0aWFsaXplKHQsZSxuKX19aW5pdGlhbGl6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX2lzTnVsbD0hMDtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHQpLHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUoZSksdGhpcy5fZGlzdGFuY2U9dC5kaXN0YW5jZShlKSx0aGlzLl9pc051bGw9ITF9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZSh0KSx0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKGUpLHRoaXMuX2Rpc3RhbmNlPW4sdGhpcy5faXNOdWxsPSExfX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcodGhpcy5fcHRbMF0sdGhpcy5fcHRbMV0pfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfXNldE1heGltdW0oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRNYXhpbXVtKHQuX3B0WzBdLHQuX3B0WzFdKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLl9pc051bGwpcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZSh0LGUpLG51bGw7Y29uc3Qgbj10LmRpc3RhbmNlKGUpO24+dGhpcy5fZGlzdGFuY2UmJnRoaXMuaW5pdGlhbGl6ZSh0LGUsbil9fX1jbGFzcyBQZXtzdGF0aWMgY29tcHV0ZURpc3RhbmNlKCl7aWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBKJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IEt0LGk9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGgtMTt0Kyspe3Muc2V0Q29vcmRpbmF0ZXMoaVt0XSxpW3QrMV0pO2NvbnN0IHI9cy5jbG9zZXN0UG9pbnQoZSk7bi5zZXRNaW5pbXVtKHIsZSl9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBpdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtQZS5jb21wdXRlRGlzdGFuY2UodC5nZXRFeHRlcmlvclJpbmcoKSxlLG4pO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspUGUuY29tcHV0ZURpc3RhbmNlKHQuZ2V0SW50ZXJpb3JSaW5nTihzKSxlLG4pfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQgaW5zdGFuY2VvZiBKKVBlLmNvbXB1dGVEaXN0YW5jZSh0LGUsbik7ZWxzZSBpZih0IGluc3RhbmNlb2YgaXQpUGUuY29tcHV0ZURpc3RhbmNlKHQsZSxuKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBjdCl7Y29uc3Qgcz10O2ZvcihsZXQgdD0wO3Q8cy5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBpPXMuZ2V0R2VvbWV0cnlOKHQpO1BlLmNvbXB1dGVEaXN0YW5jZShpLGUsbil9fWVsc2Ugbi5zZXRNaW5pbXVtKHQuZ2V0Q29vcmRpbmF0ZSgpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBSZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1swXS5jbG9zZXN0UG9pbnQodCk7ZS5zZXRNaW5pbXVtKG4sdCl9fX1jbGFzcyBPZXtjb25zdHJ1Y3Rvcigpe09lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2cwPW51bGwsdGhpcy5fZzE9bnVsbCx0aGlzLl9wdERpc3Q9bmV3IFJlLHRoaXMuX2RlbnNpZnlGcmFjPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZzA9dCx0aGlzLl9nMT1lfXN0YXRpYyBkaXN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IE9lKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLmRpc3RhbmNlKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzJdLGU9bmV3IE9lKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pO3JldHVybiBlLnNldERlbnNpZnlGcmFjdGlvbih0KSxlLmRpc3RhbmNlKCl9fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0RGlzdC5nZXRDb29yZGluYXRlcygpfXNldERlbnNpZnlGcmFjdGlvbih0KXtpZih0PjF8fHQ8PTApdGhyb3cgbmV3IHMoXCJGcmFjdGlvbiBpcyBub3QgaW4gcmFuZ2UgKDAuMCAtIDEuMF1cIik7dGhpcy5fZGVuc2lmeUZyYWM9dH1jb21wdXRlKHQsZSl7dGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0LGUsdGhpcy5fcHREaXN0KSx0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKGUsdCx0aGlzLl9wdERpc3QpfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSh0aGlzLl9nMCx0aGlzLl9nMSksdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKCl9Y29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9bmV3IHZlKGUpO2lmKHQuYXBwbHkocyksbi5zZXRNYXhpbXVtKHMuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKSx0aGlzLl9kZW5zaWZ5RnJhYz4wKXtjb25zdCBzPW5ldyBNZShlLHRoaXMuX2RlbnNpZnlGcmFjKTt0LmFwcGx5KHMpLG4uc2V0TWF4aW11bShzLmdldE1heFBvaW50RGlzdGFuY2UoKSl9fW9yaWVudGVkRGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0aGlzLl9nMCx0aGlzLl9nMSx0aGlzLl9wdERpc3QpLHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpfX1jbGFzcyB2ZXtjb25zdHJ1Y3Rvcigpe3ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX21heFB0RGlzdD1uZXcgUmUsdGhpcy5fbWluUHREaXN0PW5ldyBSZSx0aGlzLl9ldWNsaWRlYW5EaXN0PW5ldyBQZSx0aGlzLl9nZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbT10fWZpbHRlcih0KXt0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpLFBlLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLHQsdGhpcy5fbWluUHREaXN0KSx0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpfWdldE1heFBvaW50RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fbWF4UHREaXN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltVXX19Y2xhc3MgTWV7Y29uc3RydWN0b3IoKXtNZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9tYXhQdERpc3Q9bmV3IFJlLHRoaXMuX21pblB0RGlzdD1uZXcgUmUsdGhpcy5fZ2VvbT1udWxsLHRoaXMuX251bVN1YlNlZ3M9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tPXQsdGhpcy5fbnVtU3ViU2Vncz1NYXRoLnRydW5jKE1hdGgucm91bmQoMS9lKSl9ZmlsdGVyKHQsZSl7aWYoMD09PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGUoZS0xKSxzPXQuZ2V0Q29vcmRpbmF0ZShlKSxpPShzLngtbi54KS90aGlzLl9udW1TdWJTZWdzLHI9KHMueS1uLnkpL3RoaXMuX251bVN1YlNlZ3M7Zm9yKGxldCB0PTA7dDx0aGlzLl9udW1TdWJTZWdzO3QrKyl7Y29uc3QgZT1uLngrdCppLHM9bi55K3QqcixvPW5ldyBtKGUscyk7dGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKSxQZS5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSxvLHRoaXMuX21pblB0RGlzdCksdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KX19aXNEb25lKCl7cmV0dXJuITF9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMX1nZXRNYXhQb2ludERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21heFB0RGlzdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUF19fU9lLk1heFBvaW50RGlzdGFuY2VGaWx0ZXI9dmUsT2UuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyPU1lO3ZhciBiZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlOk9lLERpc3RhbmNlVG9Qb2ludDpQZSxQb2ludFBhaXJEaXN0YW5jZTpSZX0pO2NsYXNzIERle3Zpc2l0SXRlbSh0KXt9fWNsYXNzIEFle2xvY2F0ZSh0KXt9fWNsYXNzIEZle2NvbnN0cnVjdG9yKCl7RmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWluPXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5fbWF4PXIuTkVHQVRJVkVfSU5GSU5JVFl9Z2V0TWluKCl7cmV0dXJuIHRoaXMuX21pbn1pbnRlcnNlY3RzKHQsZSl7cmV0dXJuISh0aGlzLl9taW4+ZXx8dGhpcy5fbWF4PHQpfWdldE1heCgpe3JldHVybiB0aGlzLl9tYXh9dG9TdHJpbmcoKXtyZXR1cm4gV3QudG9MaW5lU3RyaW5nKG5ldyBtKHRoaXMuX21pbiwwKSxuZXcgbSh0aGlzLl9tYXgsMCkpfX1GZS5Ob2RlQ29tcGFyYXRvcj1jbGFzc3tjb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZSxpPShuLl9taW4rbi5fbWF4KS8yLHI9KHMuX21pbitzLl9tYXgpLzI7cmV0dXJuIGk8cj8tMTppPnI/MTowfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19O2NsYXNzIEdlIGV4dGVuZHMgRmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLEdlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2l0ZW09bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9taW49dCx0aGlzLl9tYXg9ZSx0aGlzLl9pdGVtPW59cXVlcnkodCxlLG4pe2lmKCF0aGlzLmludGVyc2VjdHModCxlKSlyZXR1cm4gbnVsbDtuLnZpc2l0SXRlbSh0aGlzLl9pdGVtKX19Y2xhc3MgcWUgZXh0ZW5kcyBGZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkscWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZTE9bnVsbCx0aGlzLl9ub2RlMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX25vZGUxPXQsdGhpcy5fbm9kZTI9ZSx0aGlzLmJ1aWxkRXh0ZW50KHRoaXMuX25vZGUxLHRoaXMuX25vZGUyKX1idWlsZEV4dGVudCh0LGUpe3RoaXMuX21pbj1NYXRoLm1pbih0Ll9taW4sZS5fbWluKSx0aGlzLl9tYXg9TWF0aC5tYXgodC5fbWF4LGUuX21heCl9cXVlcnkodCxlLG4pe2lmKCF0aGlzLmludGVyc2VjdHModCxlKSlyZXR1cm4gbnVsbDtudWxsIT09dGhpcy5fbm9kZTEmJnRoaXMuX25vZGUxLnF1ZXJ5KHQsZSxuKSxudWxsIT09dGhpcy5fbm9kZTImJnRoaXMuX25vZGUyLnF1ZXJ5KHQsZSxuKX19Y2xhc3MgQmV7Y29uc3RydWN0b3IoKXtCZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9sZWF2ZXM9bmV3IEwsdGhpcy5fcm9vdD1udWxsLHRoaXMuX2xldmVsPTB9YnVpbGRUcmVlKCl7eGUuc29ydCh0aGlzLl9sZWF2ZXMsbmV3IEZlLk5vZGVDb21wYXJhdG9yKTtsZXQgdD10aGlzLl9sZWF2ZXMsZT1udWxsLG49bmV3IEw7Zm9yKDs7KXtpZih0aGlzLmJ1aWxkTGV2ZWwodCxuKSwxPT09bi5zaXplKCkpcmV0dXJuIG4uZ2V0KDApO2U9dCx0PW4sbj1lfX1pbnNlcnQodCxlLG4pe2lmKG51bGwhPT10aGlzLl9yb290KXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJJbmRleCBjYW5ub3QgYmUgYWRkZWQgdG8gb25jZSBpdCBoYXMgYmVlbiBxdWVyaWVkXCIpO3RoaXMuX2xlYXZlcy5hZGQobmV3IEdlKHQsZSxuKSl9cXVlcnkodCxlLG4pe2lmKHRoaXMuaW5pdCgpLG51bGw9PT10aGlzLl9yb290KXJldHVybiBudWxsO3RoaXMuX3Jvb3QucXVlcnkodCxlLG4pfWJ1aWxkUm9vdCgpe2lmKG51bGwhPT10aGlzLl9yb290KXJldHVybiBudWxsO3RoaXMuX3Jvb3Q9dGhpcy5idWlsZFRyZWUoKX1wcmludE5vZGUodCl7Qi5vdXQucHJpbnRsbihXdC50b0xpbmVTdHJpbmcobmV3IG0odC5fbWluLHRoaXMuX2xldmVsKSxuZXcgbSh0Ll9tYXgsdGhpcy5fbGV2ZWwpKSl9aW5pdCgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdHx8MD09PXRoaXMuX2xlYXZlcy5zaXplKCk/bnVsbDp2b2lkIHRoaXMuYnVpbGRSb290KCl9YnVpbGRMZXZlbCh0LGUpe3RoaXMuX2xldmVsKyssZS5jbGVhcigpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bis9Mil7Y29uc3Qgcz10LmdldChuKTtpZihudWxsPT09KG4rMTx0LnNpemUoKT90LmdldChuKTpudWxsKSllLmFkZChzKTtlbHNle2NvbnN0IHM9bmV3IHFlKHQuZ2V0KG4pLHQuZ2V0KG4rMSkpO2UuYWRkKHMpfX19fWNsYXNzIFlle2NvbnN0cnVjdG9yKCl7WWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXRlbXM9bmV3IEx9dmlzaXRJdGVtKHQpe3RoaXMuX2l0ZW1zLmFkZCh0KX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRGVdfX1jbGFzcyBWZXtjb25zdHJ1Y3Rvcigpe1ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3A9bnVsbCx0aGlzLl9jcm9zc2luZ0NvdW50PTAsdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wPXR9c3RhdGljIGxvY2F0ZVBvaW50SW5SaW5nKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZJKGFyZ3VtZW50c1sxXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1uZXcgVmUoYXJndW1lbnRzWzBdKSxuPW5ldyBtLHM9bmV3IG07Zm9yKGxldCBpPTE7aTx0LnNpemUoKTtpKyspaWYodC5nZXRDb29yZGluYXRlKGksbiksdC5nZXRDb29yZGluYXRlKGktMSxzKSxlLmNvdW50U2VnbWVudChuLHMpLGUuaXNPblNlZ21lbnQoKSlyZXR1cm4gZS5nZXRMb2NhdGlvbigpO3JldHVybiBlLmdldExvY2F0aW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPW5ldyBWZShhcmd1bWVudHNbMF0pO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKXtjb25zdCBzPXRbbl0saT10W24tMV07aWYoZS5jb3VudFNlZ21lbnQocyxpKSxlLmlzT25TZWdtZW50KCkpcmV0dXJuIGUuZ2V0TG9jYXRpb24oKX1yZXR1cm4gZS5nZXRMb2NhdGlvbigpfX1jb3VudFNlZ21lbnQodCxlKXtpZih0Lng8dGhpcy5fcC54JiZlLng8dGhpcy5fcC54KXJldHVybiBudWxsO2lmKHRoaXMuX3AueD09PWUueCYmdGhpcy5fcC55PT09ZS55KXJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwLG51bGw7aWYodC55PT09dGhpcy5fcC55JiZlLnk9PT10aGlzLl9wLnkpe2xldCBuPXQueCxzPWUueDtyZXR1cm4gbj5zJiYobj1lLngscz10LngpLHRoaXMuX3AueD49biYmdGhpcy5fcC54PD1zJiYodGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCksbnVsbH1pZih0Lnk+dGhpcy5fcC55JiZlLnk8PXRoaXMuX3AueXx8ZS55PnRoaXMuX3AueSYmdC55PD10aGlzLl9wLnkpe2xldCBuPUcuaW5kZXgodCxlLHRoaXMuX3ApO2lmKG49PT1HLkNPTExJTkVBUilyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2UueTx0LnkmJihuPS1uKSxuPT09Ry5MRUZUJiZ0aGlzLl9jcm9zc2luZ0NvdW50Kyt9fWlzUG9pbnRJblBvbHlnb24oKXtyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpIT09UXQuRVhURVJJT1J9Z2V0TG9jYXRpb24oKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD9RdC5CT1VOREFSWTp0aGlzLl9jcm9zc2luZ0NvdW50JTI9PTE/UXQuSU5URVJJT1I6UXQuRVhURVJJT1J9aXNPblNlZ21lbnQoKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudH19Y2xhc3MgemV7Y29uc3RydWN0b3IoKXt6ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW51bGwsdGhpcy5faW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTtpZighKEkodCxzdCl8fHQgaW5zdGFuY2VvZiB1dCkpdGhyb3cgbmV3IHMoXCJBcmd1bWVudCBtdXN0IGJlIFBvbHlnb25hbCBvciBMaW5lYXJSaW5nXCIpO3RoaXMuX2dlb209dH1sb2NhdGUodCl7bnVsbD09PXRoaXMuX2luZGV4JiYodGhpcy5faW5kZXg9bmV3IFhlKHRoaXMuX2dlb20pLHRoaXMuX2dlb209bnVsbCk7Y29uc3QgZT1uZXcgVmUodCksbj1uZXcga2UoZSk7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHQueSx0LnksbiksZS5nZXRMb2NhdGlvbigpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fWNsYXNzIGtle2NvbnN0cnVjdG9yKCl7a2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY291bnRlcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvdW50ZXI9dH12aXNpdEl0ZW0odCl7Y29uc3QgZT10O3RoaXMuX2NvdW50ZXIuY291bnRTZWdtZW50KGUuZ2V0Q29vcmRpbmF0ZSgwKSxlLmdldENvb3JkaW5hdGUoMSkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltEZV19fWNsYXNzIFhle2NvbnN0cnVjdG9yKCl7WGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faXNFbXB0eT0hMSx0aGlzLl9pbmRleD1uZXcgQmU7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5pc0VtcHR5KCk/dGhpcy5faXNFbXB0eT0hMDp0aGlzLmluaXQodCl9aW5pdCh0KXtmb3IobGV0IGU9eWUuZ2V0TGluZXModCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmFkZExpbmUodCl9fWFkZExpbmUodCl7Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49bmV3IEt0KHRbZS0xXSx0W2VdKSxzPU1hdGgubWluKG4ucDAueSxuLnAxLnkpLGk9TWF0aC5tYXgobi5wMC55LG4ucDEueSk7dGhpcy5faW5kZXguaW5zZXJ0KHMsaSxuKX19cXVlcnkoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNFbXB0eSlyZXR1cm4gbmV3IEw7Y29uc3Qgbj1uZXcgWWU7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHQsZSxuKSxuLmdldEl0ZW1zKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX2lzRW1wdHkpcmV0dXJuIG51bGw7dGhpcy5faW5kZXgucXVlcnkodCxlLG4pfX19emUuU2VnbWVudFZpc2l0b3I9a2UsemUuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnk9WGU7Y2xhc3MgVWV7c3RhdGljIGlzT25MaW5lKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZJKGFyZ3VtZW50c1sxXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcganQscz1uZXcgbSxpPW5ldyBtLHI9ZS5zaXplKCk7Zm9yKGxldCBvPTE7bzxyO28rKylpZihlLmdldENvb3JkaW5hdGUoby0xLHMpLGUuZ2V0Q29vcmRpbmF0ZShvLGkpLG4uY29tcHV0ZUludGVyc2VjdGlvbih0LHMsaSksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0mJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGp0O2ZvcihsZXQgcz0xO3M8ZS5sZW5ndGg7cysrKXtjb25zdCBpPWVbcy0xXSxyPWVbc107aWYobi5jb21wdXRlSW50ZXJzZWN0aW9uKHQsaSxyKSxuLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiEwfXJldHVybiExfX1zdGF0aWMgbG9jYXRlSW5SaW5nKHQsZSl7cmV0dXJuIFZlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSl9c3RhdGljIGlzSW5SaW5nKHQsZSl7cmV0dXJuIFVlLmxvY2F0ZUluUmluZyh0LGUpIT09UXQuRVhURVJJT1J9fWNsYXNzIEhle2hhc05leHQoKXt9bmV4dCgpe31yZW1vdmUoKXt9fWNsYXNzIFdle2NvbnN0cnVjdG9yKCl7V2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcGFyZW50PW51bGwsdGhpcy5fYXRTdGFydD1udWxsLHRoaXMuX21heD1udWxsLHRoaXMuX2luZGV4PW51bGwsdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50PXQsdGhpcy5fYXRTdGFydD0hMCx0aGlzLl9pbmRleD0wLHRoaXMuX21heD10LmdldE51bUdlb21ldHJpZXMoKX1zdGF0aWMgaXNBdG9taWModCl7cmV0dXJuISh0IGluc3RhbmNlb2YgY3QpfW5leHQoKXtpZih0aGlzLl9hdFN0YXJ0KXJldHVybiB0aGlzLl9hdFN0YXJ0PSExLFdlLmlzQXRvbWljKHRoaXMuX3BhcmVudCkmJnRoaXMuX2luZGV4KyssdGhpcy5fcGFyZW50O2lmKG51bGwhPT10aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCk7dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9aWYodGhpcy5faW5kZXg+PXRoaXMuX21heCl0aHJvdyBuZXcgQztjb25zdCB0PXRoaXMuX3BhcmVudC5nZXRHZW9tZXRyeU4odGhpcy5faW5kZXgrKyk7cmV0dXJuIHQgaW5zdGFuY2VvZiBjdD8odGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW5ldyBXZSh0KSx0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpKTp0fXJlbW92ZSgpe3Rocm93IG5ldyBqKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfWhhc05leHQoKXtpZih0aGlzLl9hdFN0YXJ0KXJldHVybiEwO2lmKG51bGwhPT10aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuITA7dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9cmV0dXJuISh0aGlzLl9pbmRleD49dGhpcy5fbWF4KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSGVdfX1jbGFzcyBaZXtjb25zdHJ1Y3Rvcigpe1plLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tPXR9c3RhdGljIGxvY2F0ZVBvaW50SW5Qb2x5Z29uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIFF0LkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRFeHRlcmlvclJpbmcoKSxzPVplLmxvY2F0ZVBvaW50SW5SaW5nKHQsbik7aWYocyE9PVF0LklOVEVSSU9SKXJldHVybiBzO2ZvcihsZXQgbj0wO248ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtuKyspe2NvbnN0IHM9ZS5nZXRJbnRlcmlvclJpbmdOKG4pLGk9WmUubG9jYXRlUG9pbnRJblJpbmcodCxzKTtpZihpPT09UXQuQk9VTkRBUlkpcmV0dXJuIFF0LkJPVU5EQVJZO2lmKGk9PT1RdC5JTlRFUklPUilyZXR1cm4gUXQuRVhURVJJT1J9cmV0dXJuIFF0LklOVEVSSU9SfXN0YXRpYyBsb2NhdGVQb2ludEluUmluZyh0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP1VlLmxvY2F0ZUluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6UXQuRVhURVJJT1J9c3RhdGljIGNvbnRhaW5zUG9pbnRJblBvbHlnb24odCxlKXtyZXR1cm4gUXQuRVhURVJJT1IhPT1aZS5sb2NhdGVQb2ludEluUG9seWdvbih0LGUpfXN0YXRpYyBsb2NhdGVJbkdlb21ldHJ5KHQsZSl7aWYoZSBpbnN0YW5jZW9mIGl0KXJldHVybiBaZS5sb2NhdGVQb2ludEluUG9seWdvbih0LGUpO2lmKGUgaW5zdGFuY2VvZiBjdCl7Y29uc3Qgbj1uZXcgV2UoZSk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocyE9PWUpe2NvbnN0IGU9WmUubG9jYXRlSW5HZW9tZXRyeSh0LHMpO2lmKGUhPT1RdC5FWFRFUklPUilyZXR1cm4gZX19fXJldHVybiBRdC5FWFRFUklPUn1zdGF0aWMgaXNDb250YWluZWQodCxlKXtyZXR1cm4gUXQuRVhURVJJT1IhPT1aZS5sb2NhdGUodCxlKX1zdGF0aWMgbG9jYXRlKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP1F0LkVYVEVSSU9SOmUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/WmUubG9jYXRlSW5HZW9tZXRyeSh0LGUpOlF0LkVYVEVSSU9SfWxvY2F0ZSh0KXtyZXR1cm4gWmUubG9jYXRlKHQsdGhpcy5fZ2VvbSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX19dmFyIGplPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3I6emUsUG9pbnRPbkdlb21ldHJ5TG9jYXRvcjpBZSxTaW1wbGVQb2ludEluQXJlYUxvY2F0b3I6WmV9KTtjbGFzcyBLZXttZWFzdXJlKHQsZSl7fX1jbGFzcyBRZXtzdGF0aWMgZGlhZ29uYWxTaXplKHQpe2lmKHQuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpO3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9bWVhc3VyZSh0LGUpe2NvbnN0IG49T2UuZGlzdGFuY2UodCxlLFFlLkRFTlNJRllfRlJBQ1RJT04pLHM9bmV3IE8odC5nZXRFbnZlbG9wZUludGVybmFsKCkpO3MuZXhwYW5kVG9JbmNsdWRlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gMS1uL1FlLmRpYWdvbmFsU2l6ZShzKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bS2VdfX1RZS5ERU5TSUZZX0ZSQUNUSU9OPS4yNTt2YXIgSmU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQXJlYVNpbWlsYXJpdHlNZWFzdXJlOmNsYXNze21lYXN1cmUodCxlKXtyZXR1cm4gdC5pbnRlcnNlY3Rpb24oZSkuZ2V0QXJlYSgpL3QudW5pb24oZSkuZ2V0QXJlYSgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltLZV19fSxIYXVzZG9yZmZTaW1pbGFyaXR5TWVhc3VyZTpRZSxTaW1pbGFyaXR5TWVhc3VyZTpLZSxTaW1pbGFyaXR5TWVhc3VyZUNvbWJpbmVyOmNsYXNze3N0YXRpYyBjb21iaW5lKHQsZSl7cmV0dXJuIE1hdGgubWluKHQsZSl9fX0pO2NsYXNzICRle2NvbnN0cnVjdG9yKCl7JGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fYXJlYUJhc2VQdD1udWxsLHRoaXMuX3RyaWFuZ2xlQ2VudDM9bmV3IG0sdGhpcy5fYXJlYXN1bTI9MCx0aGlzLl9jZzM9bmV3IG0sdGhpcy5fbGluZUNlbnRTdW09bmV3IG0sdGhpcy5fdG90YWxMZW5ndGg9MCx0aGlzLl9wdENvdW50PTAsdGhpcy5fcHRDZW50U3VtPW5ldyBtO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZWFCYXNlUHQ9bnVsbCx0aGlzLmFkZCh0KX1zdGF0aWMgYXJlYTIodCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKG4ueC10LngpKihlLnktdC55KX1zdGF0aWMgY2VudHJvaWQzKHQsZSxuLHMpe3JldHVybiBzLng9dC54K2UueCtuLngscy55PXQueStlLnkrbi55LG51bGx9c3RhdGljIGdldENlbnRyb2lkKHQpe3JldHVybiBuZXcgJGUodCkuZ2V0Q2VudHJvaWQoKX1zZXRBcmVhQmFzZVBvaW50KHQpe3RoaXMuX2FyZWFCYXNlUHQ9dH1hZGRQb2ludCh0KXt0aGlzLl9wdENvdW50Kz0xLHRoaXMuX3B0Q2VudFN1bS54Kz10LngsdGhpcy5fcHRDZW50U3VtLnkrPXQueX1hZGRMaW5lU2VnbWVudHModCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXtjb25zdCBzPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtpZigwPT09cyljb250aW51ZTtlKz1zO2NvbnN0IGk9KHRbbl0ueCt0W24rMV0ueCkvMjt0aGlzLl9saW5lQ2VudFN1bS54Kz1zKmk7Y29uc3Qgcj0odFtuXS55K3RbbisxXS55KS8yO3RoaXMuX2xpbmVDZW50U3VtLnkrPXMqcn10aGlzLl90b3RhbExlbmd0aCs9ZSwwPT09ZSYmdC5sZW5ndGg+MCYmdGhpcy5hZGRQb2ludCh0WzBdKX1hZGRIb2xlKHQpe2NvbnN0IGU9Ry5pc0NDVyh0KTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5fYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX1nZXRDZW50cm9pZCgpe2NvbnN0IHQ9bmV3IG07aWYoTWF0aC5hYnModGhpcy5fYXJlYXN1bTIpPjApdC54PXRoaXMuX2NnMy54LzMvdGhpcy5fYXJlYXN1bTIsdC55PXRoaXMuX2NnMy55LzMvdGhpcy5fYXJlYXN1bTI7ZWxzZSBpZih0aGlzLl90b3RhbExlbmd0aD4wKXQueD10aGlzLl9saW5lQ2VudFN1bS54L3RoaXMuX3RvdGFsTGVuZ3RoLHQueT10aGlzLl9saW5lQ2VudFN1bS55L3RoaXMuX3RvdGFsTGVuZ3RoO2Vsc2V7aWYoISh0aGlzLl9wdENvdW50PjApKXJldHVybiBudWxsO3QueD10aGlzLl9wdENlbnRTdW0ueC90aGlzLl9wdENvdW50LHQueT10aGlzLl9wdENlbnRTdW0ueS90aGlzLl9wdENvdW50fXJldHVybiB0fWFkZFNoZWxsKHQpe3QubGVuZ3RoPjAmJnRoaXMuc2V0QXJlYUJhc2VQb2ludCh0WzBdKTtjb25zdCBlPSFHLmlzQ0NXKHQpO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLl9hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfWFkZFRyaWFuZ2xlKHQsZSxuLHMpe2NvbnN0IGk9cz8xOi0xOyRlLmNlbnRyb2lkMyh0LGUsbix0aGlzLl90cmlhbmdsZUNlbnQzKTtjb25zdCByPSRlLmFyZWEyKHQsZSxuKTt0aGlzLl9jZzMueCs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueCx0aGlzLl9jZzMueSs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueSx0aGlzLl9hcmVhc3VtMis9aSpyfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgaXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkU2hlbGwodC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuYWRkSG9sZSh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiB0dCl0aGlzLmFkZFBvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBKKXRoaXMuYWRkTGluZVNlZ21lbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaXQpe2NvbnN0IGU9dDt0aGlzLmFkZChlKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBjdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKHQpKX19fX1jbGFzcyB0biBleHRlbmRzIG57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5uYW1lPU9iamVjdC5rZXlzKHtFbXB0eVN0YWNrRXhjZXB0aW9uOnRufSlbMF19fWNsYXNzIGVuIGV4dGVuZHMgd3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5hcnJheT1bXX1hZGQodCl7cmV0dXJuIHRoaXMuYXJyYXkucHVzaCh0KSwhMH1nZXQodCl7aWYodDwwfHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgUztyZXR1cm4gdGhpcy5hcnJheVt0XX1wdXNoKHQpe3JldHVybiB0aGlzLmFycmF5LnB1c2godCksdH1wb3AoKXtpZigwPT09dGhpcy5hcnJheS5sZW5ndGgpdGhyb3cgbmV3IHRuO3JldHVybiB0aGlzLmFycmF5LnBvcCgpfXBlZWsoKXtpZigwPT09dGhpcy5hcnJheS5sZW5ndGgpdGhyb3cgbmV3IHRuO3JldHVybiB0aGlzLmFycmF5W3RoaXMuYXJyYXkubGVuZ3RoLTFdfWVtcHR5KCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Lmxlbmd0aH1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuZW1wdHkoKX1zZWFyY2godCl7cmV0dXJuIHRoaXMuYXJyYXkuaW5kZXhPZih0KX1zaXplKCl7cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RofXRvQXJyYXkoKXtyZXR1cm4gdGhpcy5hcnJheS5zbGljZSgpfX1jbGFzcyBubntjb25zdHJ1Y3Rvcigpe25uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2Nvb3JkU2V0PW5ldyB4dCx0aGlzLl9saXN0PW5ldyBMfXN0YXRpYyBmaWx0ZXJDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBubjtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllLmZpbHRlcih0W25dKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlcygpfWZpbHRlcih0KXt0aGlzLl9jb29yZFNldC5hZGQodCkmJnRoaXMuX2xpc3QuYWRkKHQpfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fbGlzdC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMuX2xpc3QudG9BcnJheSh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVV19fWNsYXNzIHNue2NvbnN0cnVjdG9yKCl7c24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9pbnB1dFB0cz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHNuLmV4dHJhY3RDb29yZGluYXRlcyh0KSx0LmdldEZhY3RvcnkoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRQdHM9bm4uZmlsdGVyQ29vcmRpbmF0ZXModCksdGhpcy5fZ2VvbUZhY3Rvcnk9ZX19c3RhdGljIGV4dHJhY3RDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBubjtyZXR1cm4gdC5hcHBseShlKSxlLmdldENvb3JkaW5hdGVzKCl9cHJlU29ydCh0KXtsZXQgZT1udWxsO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKSh0W25dLnk8dFswXS55fHx0W25dLnk9PT10WzBdLnkmJnRbbl0ueDx0WzBdLngpJiYoZT10WzBdLHRbMF09dFtuXSx0W25dPWUpO3JldHVybiBudC5zb3J0KHQsMSx0Lmxlbmd0aCxuZXcgcm4odFswXSkpLHR9Y29tcHV0ZU9jdFJpbmcodCl7Y29uc3QgZT10aGlzLmNvbXB1dGVPY3RQdHModCksbj1uZXcgUjtyZXR1cm4gbi5hZGQoZSwhMSksbi5zaXplKCk8Mz9udWxsOihuLmNsb3NlUmluZygpLG4udG9Db29yZGluYXRlQXJyYXkoKSl9bGluZU9yUG9seWdvbih0KXtpZigzPT09KHQ9dGhpcy5jbGVhblJpbmcodCkpLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdFswXSx0WzFdXSk7Y29uc3QgZT10aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVQb2x5Z29uKGUpfWNsZWFuUmluZyh0KXtnLmVxdWFscyh0WzBdLHRbdC5sZW5ndGgtMV0pO2NvbnN0IGU9bmV3IEw7bGV0IG49bnVsbDtmb3IobGV0IHM9MDtzPD10Lmxlbmd0aC0yO3MrKyl7Y29uc3QgaT10W3NdLHI9dFtzKzFdO2kuZXF1YWxzKHIpfHwobnVsbCE9PW4mJnRoaXMuaXNCZXR3ZWVuKG4saSxyKXx8KGUuYWRkKGkpLG49aSkpfWUuYWRkKHRbdC5sZW5ndGgtMV0pO2NvbnN0IHM9bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiBlLnRvQXJyYXkocyl9aXNCZXR3ZWVuKHQsZSxuKXtpZigwIT09Ry5pbmRleCh0LGUsbikpcmV0dXJuITE7aWYodC54IT09bi54KXtpZih0Lng8PWUueCYmZS54PD1uLngpcmV0dXJuITA7aWYobi54PD1lLngmJmUueDw9dC54KXJldHVybiEwfWlmKHQueSE9PW4ueSl7aWYodC55PD1lLnkmJmUueTw9bi55KXJldHVybiEwO2lmKG4ueTw9ZS55JiZlLnk8PXQueSlyZXR1cm4hMH1yZXR1cm4hMX1yZWR1Y2UodCl7Y29uc3QgZT10aGlzLmNvbXB1dGVPY3RSaW5nKHQpO2lmKG51bGw9PT1lKXJldHVybiB0O2NvbnN0IG49bmV3IGx0O2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKW4uYWRkKGVbdF0pO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKVVlLmlzSW5SaW5nKHRbc10sZSl8fG4uYWRkKHRbc10pO2NvbnN0IHM9ZHQudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHMubGVuZ3RoPDM/dGhpcy5wYWRBcnJheTMocyk6c31nZXRDb252ZXhIdWxsKCl7aWYoMD09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYoMT09PXRoaXMuX2lucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy5faW5wdXRQdHNbMF0pO2lmKDI9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5faW5wdXRQdHMpO2xldCB0PXRoaXMuX2lucHV0UHRzO3RoaXMuX2lucHV0UHRzLmxlbmd0aD41MCYmKHQ9dGhpcy5yZWR1Y2UodGhpcy5faW5wdXRQdHMpKTtjb25zdCBlPXRoaXMucHJlU29ydCh0KSxuPXRoaXMuZ3JhaGFtU2NhbihlKSxzPXRoaXMudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHRoaXMubGluZU9yUG9seWdvbihzKX1wYWRBcnJheTModCl7Y29uc3QgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyluPHQubGVuZ3RoP2Vbbl09dFtuXTplW25dPXRbMF07cmV0dXJuIGV9Y29tcHV0ZU9jdFB0cyh0KXtjb25zdCBlPW5ldyBBcnJheSg4KS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dFswXTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl0W25dLng8ZVswXS54JiYoZVswXT10W25dKSx0W25dLngtdFtuXS55PGVbMV0ueC1lWzFdLnkmJihlWzFdPXRbbl0pLHRbbl0ueT5lWzJdLnkmJihlWzJdPXRbbl0pLHRbbl0ueCt0W25dLnk+ZVszXS54K2VbM10ueSYmKGVbM109dFtuXSksdFtuXS54PmVbNF0ueCYmKGVbNF09dFtuXSksdFtuXS54LXRbbl0ueT5lWzVdLngtZVs1XS55JiYoZVs1XT10W25dKSx0W25dLnk8ZVs2XS55JiYoZVs2XT10W25dKSx0W25dLngrdFtuXS55PGVbN10ueCtlWzddLnkmJihlWzddPXRbbl0pO3JldHVybiBlfXRvQ29vcmRpbmF0ZUFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXQuZ2V0KG4pO2Vbbl09c31yZXR1cm4gZX1ncmFoYW1TY2FuKHQpe2xldCBlPW51bGw7Y29uc3Qgbj1uZXcgZW47bi5wdXNoKHRbMF0pLG4ucHVzaCh0WzFdKSxuLnB1c2godFsyXSk7Zm9yKGxldCBzPTM7czx0Lmxlbmd0aDtzKyspe2ZvcihlPW4ucG9wKCk7IW4uZW1wdHkoKSYmRy5pbmRleChuLnBlZWsoKSxlLHRbc10pPjA7KWU9bi5wb3AoKTtuLnB1c2goZSksbi5wdXNoKHRbc10pfXJldHVybiBuLnB1c2godFswXSksbn19Y2xhc3Mgcm57Y29uc3RydWN0b3IoKXtybi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vcmlnaW49bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9vcmlnaW49dH1zdGF0aWMgcG9sYXJDb21wYXJlKHQsZSxuKXtjb25zdCBzPWUueC10LngsaT1lLnktdC55LHI9bi54LXQueCxvPW4ueS10LnksbD1HLmluZGV4KHQsZSxuKTtpZihsPT09Ry5DT1VOVEVSQ0xPQ0tXSVNFKXJldHVybiAxO2lmKGw9PT1HLkNMT0NLV0lTRSlyZXR1cm4tMTtjb25zdCBhPXMqcytpKmksYz1yKnIrbypvO3JldHVybiBhPGM/LTE6YT5jPzE6MH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtyZXR1cm4gcm4ucG9sYXJDb21wYXJlKHRoaXMuX29yaWdpbixuLHMpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19c24uUmFkaWFsQ29tcGFyYXRvcj1ybjtjbGFzcyBvbntjb25zdHJ1Y3Rvcigpe29uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbCx0aGlzLl9tYXhXaWR0aD0tMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnByb2Nlc3ModCl9c3RhdGljIGdldEludGVyaW9yUG9pbnQodCl7cmV0dXJuIG5ldyBvbih0KS5nZXRJbnRlcmlvclBvaW50KCl9c3RhdGljIGF2Zyh0LGUpe3JldHVybih0K2UpLzJ9Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fXByb2Nlc3ModCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIGl0KXRoaXMucHJvY2Vzc1BvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgY3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLnByb2Nlc3MoZS5nZXRHZW9tZXRyeU4odCkpfX1wcm9jZXNzUG9seWdvbih0KXtjb25zdCBlPW5ldyBsbih0KTtlLnByb2Nlc3MoKTtjb25zdCBuPWUuZ2V0V2lkdGgoKTtuPnRoaXMuX21heFdpZHRoJiYodGhpcy5fbWF4V2lkdGg9bix0aGlzLl9pbnRlcmlvclBvaW50PWUuZ2V0SW50ZXJpb3JQb2ludCgpKX19Y2xhc3MgbG57Y29uc3RydWN0b3IoKXtsbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wb2x5Z29uPW51bGwsdGhpcy5faW50ZXJpb3JQb2ludFk9bnVsbCx0aGlzLl9pbnRlcmlvclNlY3Rpb25XaWR0aD0wLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wb2x5Z29uPXQsdGhpcy5faW50ZXJpb3JQb2ludFk9Y24uZ2V0U2NhbkxpbmVZKHQpfXN0YXRpYyBpc0VkZ2VDcm9zc2luZ0NvdW50ZWQodCxlLG4pe2NvbnN0IHM9dC5nZXRZKCksaT1lLmdldFkoKTtyZXR1cm4gcyE9PWkmJighKHM9PT1uJiZpPG4pJiYhKGk9PT1uJiZzPG4pKX1zdGF0aWMgaW50ZXJzZWN0c0hvcml6b250YWxMaW5lKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEoZTx0LmdldE1pblkoKSkmJiEoZT50LmdldE1heFkoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiEodC5nZXRZKCk+biYmZS5nZXRZKCk+bikmJiEodC5nZXRZKCk8biYmZS5nZXRZKCk8bil9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4pe2NvbnN0IHM9dC5nZXRYKCksaT1lLmdldFgoKTtpZihzPT09aSlyZXR1cm4gcztjb25zdCByPWktcyxvPShlLmdldFkoKS10LmdldFkoKSkvcjtyZXR1cm4gcysobi10LmdldFkoKSkvb31maW5kQmVzdE1pZHBvaW50KHQpe2lmKDA9PT10LnNpemUoKSlyZXR1cm4gbnVsbDtnLmlzVHJ1ZSgwPT10LnNpemUoKSUyLFwiSW50ZXJpb3IgUG9pbnQgcm9idXN0bmVzcyBmYWlsdXJlOiBvZGQgbnVtYmVyIG9mIHNjYW5saW5lIGNyb3NzaW5nc1wiKSx0LnNvcnQobmV3IGFuKTtmb3IobGV0IGU9MDtlPHQuc2l6ZSgpO2UrPTIpe2NvbnN0IG49dC5nZXQoZSkscz10LmdldChlKzEpLGk9cy1uO2lmKGk+dGhpcy5faW50ZXJpb3JTZWN0aW9uV2lkdGgpe3RoaXMuX2ludGVyaW9yU2VjdGlvbldpZHRoPWk7Y29uc3QgdD1vbi5hdmcobixzKTt0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHQsdGhpcy5faW50ZXJpb3JQb2ludFkpfX19cHJvY2Vzcygpe2lmKHRoaXMuX3BvbHlnb24uaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuX2ludGVyaW9yUG9pbnQ9bmV3IG0odGhpcy5fcG9seWdvbi5nZXRDb29yZGluYXRlKCkpO2NvbnN0IHQ9bmV3IEw7dGhpcy5zY2FuUmluZyh0aGlzLl9wb2x5Z29uLmdldEV4dGVyaW9yUmluZygpLHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9seWdvbi5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspdGhpcy5zY2FuUmluZyh0aGlzLl9wb2x5Z29uLmdldEludGVyaW9yUmluZ04oZSksdCk7dGhpcy5maW5kQmVzdE1pZHBvaW50KHQpfXNjYW5SaW5nKHQsZSl7aWYoIWxuLmludGVyc2VjdHNIb3Jpem9udGFsTGluZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSx0aGlzLl9pbnRlcmlvclBvaW50WSkpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2ZvcihsZXQgdD0xO3Q8bi5zaXplKCk7dCsrKXtjb25zdCBzPW4uZ2V0Q29vcmRpbmF0ZSh0LTEpLGk9bi5nZXRDb29yZGluYXRlKHQpO3RoaXMuYWRkRWRnZUNyb3NzaW5nKHMsaSx0aGlzLl9pbnRlcmlvclBvaW50WSxlKX19Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JTZWN0aW9uV2lkdGh9Z2V0SW50ZXJpb3JQb2ludCgpe3JldHVybiB0aGlzLl9pbnRlcmlvclBvaW50fWFkZEVkZ2VDcm9zc2luZyh0LGUsbixzKXtpZighbG4uaW50ZXJzZWN0c0hvcml6b250YWxMaW5lKHQsZSxuKSlyZXR1cm4gbnVsbDtpZighbG4uaXNFZGdlQ3Jvc3NpbmdDb3VudGVkKHQsZSxuKSlyZXR1cm4gbnVsbDtjb25zdCBpPWxuLmludGVyc2VjdGlvbih0LGUsbik7cy5hZGQoaSl9fWNsYXNzIGFue2NvbXBhcmUodCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfX1sbi5Eb3VibGVDb21wYXJhdG9yPWFuO2NsYXNzIGNue2NvbnN0cnVjdG9yKCl7Y24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcG9seT1udWxsLHRoaXMuX2NlbnRyZVk9bnVsbCx0aGlzLl9oaVk9ci5NQVhfVkFMVUUsdGhpcy5fbG9ZPS1yLk1BWF9WQUxVRTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wb2x5PXQsdGhpcy5faGlZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1heFkoKSx0aGlzLl9sb1k9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWluWSgpLHRoaXMuX2NlbnRyZVk9b24uYXZnKHRoaXMuX2xvWSx0aGlzLl9oaVkpfXN0YXRpYyBnZXRTY2FuTGluZVkodCl7cmV0dXJuIG5ldyBjbih0KS5nZXRTY2FuTGluZVkoKX11cGRhdGVJbnRlcnZhbCh0KXt0PD10aGlzLl9jZW50cmVZP3Q+dGhpcy5fbG9ZJiYodGhpcy5fbG9ZPXQpOnQ+dGhpcy5fY2VudHJlWSYmdDx0aGlzLl9oaVkmJih0aGlzLl9oaVk9dCl9Z2V0U2NhbkxpbmVZKCl7dGhpcy5wcm9jZXNzKHRoaXMuX3BvbHkuZ2V0RXh0ZXJpb3JSaW5nKCkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTt0KyspdGhpcy5wcm9jZXNzKHRoaXMuX3BvbHkuZ2V0SW50ZXJpb3JSaW5nTih0KSk7cmV0dXJuIG9uLmF2Zyh0aGlzLl9oaVksdGhpcy5fbG9ZKX1wcm9jZXNzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgbj1lLmdldFkodCk7dGhpcy51cGRhdGVJbnRlcnZhbChuKX19fW9uLkludGVyaW9yUG9pbnRQb2x5Z29uPWxuLG9uLlNjYW5MaW5lWU9yZGluYXRlRmluZGVyPWNuO2NsYXNzIGhue2NvbnN0cnVjdG9yKCl7aG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY2VudHJvaWQ9bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5pc0VtcHR5KCk/dGhpcy5fY2VudHJvaWQ9bnVsbDoodGhpcy5fY2VudHJvaWQ9JGUuZ2V0Q2VudHJvaWQodCksdC5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHRoaXMuX2NlbnRyb2lkKSksdGhpcy5hZGRJbnRlcmlvcih0KSxudWxsPT09dGhpcy5faW50ZXJpb3JQb2ludCYmdGhpcy5hZGRFbmRwb2ludHModCl9c3RhdGljIGdldEludGVyaW9yUG9pbnQodCl7cmV0dXJuIG5ldyBobih0KS5nZXRJbnRlcmlvclBvaW50KCl9YWRkRW5kcG9pbnRzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgSil0aGlzLmFkZEVuZHBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGN0KXtjb25zdCBlPXQ7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0KyspdGhpcy5hZGRFbmRwb2ludHMoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHRbMF0pLHRoaXMuYWRkKHRbdC5sZW5ndGgtMV0pfX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9YWRkSW50ZXJpb3IoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBKKXRoaXMuYWRkSW50ZXJpb3IodC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBjdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkSW50ZXJpb3IoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGgtMTtlKyspdGhpcy5hZGQodFtlXSl9fWFkZCh0KXtjb25zdCBlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfX1jbGFzcyB1bntjb25zdHJ1Y3Rvcigpe3VuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2NlbnRyb2lkPW51bGwsdGhpcy5fbWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NlbnRyb2lkPSRlLmdldENlbnRyb2lkKHQpLHRoaXMuYWRkKHQpfXN0YXRpYyBnZXRJbnRlcmlvclBvaW50KHQpe3JldHVybiBuZXcgdW4odCkuZ2V0SW50ZXJpb3JQb2ludCgpfWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiB0dCl0aGlzLmFkZCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgY3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBtKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfX19Y2xhc3MgZ257aXNJbkJvdW5kYXJ5KHQpe319Y2xhc3MgZG57aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0JTI9PTF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Y2xhc3MgX257aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0PjB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Y2xhc3MgcG57aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0PjF9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2duXX19Y2xhc3MgbW57aXNJbkJvdW5kYXJ5KHQpe3JldHVybiAxPT09dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ25dfX1nbi5Nb2QyQm91bmRhcnlOb2RlUnVsZT1kbixnbi5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9X24sZ24uTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9cG4sZ24uTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1tbixnbi5NT0QyX0JPVU5EQVJZX1JVTEU9bmV3IGRuLGduLkVORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IF9uLGduLk1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IHBuLGduLk1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgbW4sZ24uT0dDX1NGU19CT1VOREFSWV9SVUxFPWduLk1PRDJfQk9VTkRBUllfUlVMRTtjbGFzcyBmbntjb25zdHJ1Y3Rvcigpe2ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2JvdW5kYXJ5UnVsZT1nbi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUsdGhpcy5faXNJbj1udWxsLHRoaXMuX251bUJvdW5kYXJpZXM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpdGhyb3cgbmV3IHMoXCJSdWxlIG11c3QgYmUgbm9uLW51bGxcIik7dGhpcy5fYm91bmRhcnlSdWxlPXR9fWxvY2F0ZUluUG9seWdvblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9VZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOlF0LkVYVEVSSU9SfWludGVyc2VjdHModCxlKXtyZXR1cm4gdGhpcy5sb2NhdGUodCxlKSE9PVF0LkVYVEVSSU9SfXVwZGF0ZUxvY2F0aW9uSW5mbyh0KXt0PT09UXQuSU5URVJJT1ImJih0aGlzLl9pc0luPSEwKSx0PT09UXQuQk9VTkRBUlkmJnRoaXMuX251bUJvdW5kYXJpZXMrK31jb21wdXRlTG9jYXRpb24odCxlKXtpZihlIGluc3RhbmNlb2YgdHQmJnRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25Qb2ludCh0LGUpKSxlIGluc3RhbmNlb2YgSil0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBpdCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUluUG9seWdvbih0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiB3dCl7Y29uc3Qgbj1lO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKGUpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQscykpfX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBmdCl7Y29uc3Qgbj1lO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKGUpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW5Qb2x5Z29uKHQscykpfX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBjdCl7Y29uc3Qgbj1uZXcgV2UoZSk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cyE9PWUmJnRoaXMuY29tcHV0ZUxvY2F0aW9uKHQscyl9fX1sb2NhdGVPblBvaW50KHQsZSl7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQpP1F0LklOVEVSSU9SOlF0LkVYVEVSSU9SfWxvY2F0ZU9uTGluZVN0cmluZyh0LGUpe2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpKXJldHVybiBRdC5FWFRFUklPUjtjb25zdCBuPWUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7cmV0dXJuIGUuaXNDbG9zZWQoKXx8IXQuZXF1YWxzKG4uZ2V0Q29vcmRpbmF0ZSgwKSkmJiF0LmVxdWFscyhuLmdldENvb3JkaW5hdGUobi5zaXplKCktMSkpP1VlLmlzT25MaW5lKHQsbik/UXQuSU5URVJJT1I6UXQuRVhURVJJT1I6UXQuQk9VTkRBUll9bG9jYXRlSW5Qb2x5Z29uKHQsZSl7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIFF0LkVYVEVSSU9SO2NvbnN0IG49ZS5nZXRFeHRlcmlvclJpbmcoKSxzPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LG4pO2lmKHM9PT1RdC5FWFRFUklPUilyZXR1cm4gUXQuRVhURVJJT1I7aWYocz09PVF0LkJPVU5EQVJZKXJldHVybiBRdC5CT1VOREFSWTtmb3IobGV0IG49MDtuPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bisrKXtjb25zdCBzPWUuZ2V0SW50ZXJpb3JSaW5nTihuKSxpPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LHMpO2lmKGk9PT1RdC5JTlRFUklPUilyZXR1cm4gUXQuRVhURVJJT1I7aWYoaT09PVF0LkJPVU5EQVJZKXJldHVybiBRdC5CT1VOREFSWX1yZXR1cm4gUXQuSU5URVJJT1J9bG9jYXRlKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP1F0LkVYVEVSSU9SOmUgaW5zdGFuY2VvZiBKP3RoaXMubG9jYXRlT25MaW5lU3RyaW5nKHQsZSk6ZSBpbnN0YW5jZW9mIGl0P3RoaXMubG9jYXRlSW5Qb2x5Z29uKHQsZSk6KHRoaXMuX2lzSW49ITEsdGhpcy5fbnVtQm91bmRhcmllcz0wLHRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsZSksdGhpcy5fYm91bmRhcnlSdWxlLmlzSW5Cb3VuZGFyeSh0aGlzLl9udW1Cb3VuZGFyaWVzKT9RdC5CT1VOREFSWTp0aGlzLl9udW1Cb3VuZGFyaWVzPjB8fHRoaXMuX2lzSW4/UXQuSU5URVJJT1I6UXQuRVhURVJJT1IpfX1jbGFzcyB5bntjb25zdHJ1Y3Rvcigpe3luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0PW51bGwsdGhpcy5fZXh0cmVtYWxQdHM9bnVsbCx0aGlzLl9jZW50cmU9bnVsbCx0aGlzLl9yYWRpdXM9MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dD10fXN0YXRpYyBmYXJ0aGVzdFBvaW50cyh0KXtjb25zdCBlPXRbMF0uZGlzdGFuY2UodFsxXSksbj10WzFdLmRpc3RhbmNlKHRbMl0pLHM9dFsyXS5kaXN0YW5jZSh0WzBdKTtyZXR1cm4gZT49biYmZT49cz9bdFswXSx0WzFdXTpuPj1lJiZuPj1zP1t0WzFdLHRbMl1dOlt0WzJdLHRbMF1dfXN0YXRpYyBwb2ludFdpdE1pbkFuZ2xlV2l0aFgodCxlKXtsZXQgbj1yLk1BWF9WQUxVRSxzPW51bGw7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IHI9dFtpXTtpZihyPT09ZSljb250aW51ZTtjb25zdCBvPXIueC1lLng7bGV0IGw9ci55LWUueTtsPDAmJihsPS1sKTtjb25zdCBhPWwvTWF0aC5zcXJ0KG8qbytsKmwpO2E8biYmKG49YSxzPXIpfXJldHVybiBzfXN0YXRpYyBsb3dlc3RQb2ludCh0KXtsZXQgZT10WzBdO2ZvcihsZXQgbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueTxlLnkmJihlPXRbbl0pO3JldHVybiBlfXN0YXRpYyBwb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50KHQsZSxuKXtsZXQgcz1yLk1BWF9WQUxVRSxpPW51bGw7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IG89dFtyXTtpZihvPT09ZSljb250aW51ZTtpZihvPT09biljb250aW51ZTtjb25zdCBsPSR0LmFuZ2xlQmV0d2VlbihlLG8sbik7bDxzJiYocz1sLGk9byl9cmV0dXJuIGl9Z2V0UmFkaXVzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX3JhZGl1c31nZXREaWFtZXRlcigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpfWNvbnN0IHQ9dGhpcy5fZXh0cmVtYWxQdHNbMF0sZT10aGlzLl9leHRyZW1hbFB0c1sxXTtyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsZV0pfWdldEV4dHJlbWFsUG9pbnRzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuX2V4dHJlbWFsUHRzfWNvbXB1dGVDaXJjbGVQb2ludHMoKXtpZih0aGlzLl9pbnB1dC5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7aWYoMT09PXRoaXMuX2lucHV0LmdldE51bVBvaW50cygpKXtjb25zdCB0PXRoaXMuX2lucHV0LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgbSh0WzBdKV0sbnVsbH1jb25zdCB0PXRoaXMuX2lucHV0LmNvbnZleEh1bGwoKS5nZXRDb29yZGluYXRlcygpO2xldCBlPXQ7aWYodFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKSYmKGU9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCksZHQuY29weURlZXAodCwwLGUsMCx0Lmxlbmd0aC0xKSksZS5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPWR0LmNvcHlEZWVwKGUpLG51bGw7bGV0IG49eW4ubG93ZXN0UG9pbnQoZSkscz15bi5wb2ludFdpdE1pbkFuZ2xlV2l0aFgoZSxuKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgdD15bi5wb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50KGUsbixzKTtpZigkdC5pc09idHVzZShuLHQscykpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVtuZXcgbShuKSxuZXcgbShzKV0sbnVsbDtpZigkdC5pc09idHVzZSh0LG4scykpbj10O2Vsc2V7aWYoISR0LmlzT2J0dXNlKHQscyxuKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBtKG4pLG5ldyBtKHMpLG5ldyBtKHQpXSxudWxsO3M9dH19Zy5zaG91bGROZXZlclJlYWNoSGVyZShcIkxvZ2ljIGZhaWx1cmUgaW4gTWluaW11bSBCb3VuZGluZyBDaXJjbGUgYWxnb3JpdGhtIVwiKX1jb21wdXRlKCl7aWYobnVsbCE9PXRoaXMuX2V4dHJlbWFsUHRzKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUNpcmNsZVBvaW50cygpLHRoaXMuY29tcHV0ZUNlbnRyZSgpLG51bGwhPT10aGlzLl9jZW50cmUmJih0aGlzLl9yYWRpdXM9dGhpcy5fY2VudHJlLmRpc3RhbmNlKHRoaXMuX2V4dHJlbWFsUHRzWzBdKSl9Z2V0Q2lyY2xlKCl7aWYodGhpcy5jb21wdXRlKCksbnVsbD09PXRoaXMuX2NlbnRyZSlyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24oKTtjb25zdCB0PXRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpO3JldHVybiAwPT09dGhpcy5fcmFkaXVzP3Q6dC5idWZmZXIodGhpcy5fcmFkaXVzKX1nZXRDZW50cmUoKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5fY2VudHJlfWdldE1heGltdW1EaWFtZXRlcigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpO2Nhc2UgMjpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMuX2V4dHJlbWFsUHRzWzBdLHRoaXMuX2V4dHJlbWFsUHRzWzFdXSk7ZGVmYXVsdDpjb25zdCB0PXluLmZhcnRoZXN0UG9pbnRzKHRoaXMuX2V4dHJlbWFsUHRzKTtyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodCl9fWNvbXB1dGVDZW50cmUoKXtzd2l0Y2godGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6dGhpcy5fY2VudHJlPW51bGw7YnJlYWs7Y2FzZSAxOnRoaXMuX2NlbnRyZT10aGlzLl9leHRyZW1hbFB0c1swXTticmVhaztjYXNlIDI6dGhpcy5fY2VudHJlPW5ldyBtKCh0aGlzLl9leHRyZW1hbFB0c1swXS54K3RoaXMuX2V4dHJlbWFsUHRzWzFdLngpLzIsKHRoaXMuX2V4dHJlbWFsUHRzWzBdLnkrdGhpcy5fZXh0cmVtYWxQdHNbMV0ueSkvMik7YnJlYWs7Y2FzZSAzOnRoaXMuX2NlbnRyZT1uZS5jaXJjdW1jZW50cmUodGhpcy5fZXh0cmVtYWxQdHNbMF0sdGhpcy5fZXh0cmVtYWxQdHNbMV0sdGhpcy5fZXh0cmVtYWxQdHNbMl0pfX19Y2xhc3MgeG57Y29uc3RydWN0b3IoKXt4bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9pc0NvbnZleD1udWxsLHRoaXMuX2NvbnZleEh1bGxQdHM9bnVsbCx0aGlzLl9taW5CYXNlU2VnPW5ldyBLdCx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluUHRJbmRleD1udWxsLHRoaXMuX21pbldpZHRoPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3huLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwhMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5faXNDb252ZXg9ZX19c3RhdGljIG5leHRJbmRleCh0LGUpe3JldHVybisrZT49dC5sZW5ndGgmJihlPTApLGV9c3RhdGljIGNvbXB1dGVDKHQsZSxuKXtyZXR1cm4gdCpuLnktZSpuLnh9c3RhdGljIGdldE1pbmltdW1EaWFtZXRlcih0KXtyZXR1cm4gbmV3IHhuKHQpLmdldERpYW1ldGVyKCl9c3RhdGljIGdldE1pbmltdW1SZWN0YW5nbGUodCl7cmV0dXJuIG5ldyB4bih0KS5nZXRNaW5pbXVtUmVjdGFuZ2xlKCl9c3RhdGljIGNvbXB1dGVTZWdtZW50Rm9yTGluZSh0LGUsbil7bGV0IHM9bnVsbCxpPW51bGw7cmV0dXJuIE1hdGguYWJzKGUpPk1hdGguYWJzKHQpPyhzPW5ldyBtKDAsbi9lKSxpPW5ldyBtKDEsbi9lLXQvZSkpOihzPW5ldyBtKG4vdCwwKSxpPW5ldyBtKG4vdC1lL3QsMSkpLG5ldyBLdChzLGkpfWdldFdpZHRoQ29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9taW5XaWR0aFB0fWdldFN1cHBvcnRpbmdTZWdtZW50KCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5fbWluQmFzZVNlZy5wMCx0aGlzLl9taW5CYXNlU2VnLnAxXSl9Z2V0RGlhbWV0ZXIoKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSxudWxsPT09dGhpcy5fbWluV2lkdGhQdClyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y29uc3QgdD10aGlzLl9taW5CYXNlU2VnLnByb2plY3QodGhpcy5fbWluV2lkdGhQdCk7cmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCx0aGlzLl9taW5XaWR0aFB0XSl9Y29tcHV0ZVdpZHRoQ29udmV4KHQpe3RoaXMuX2NvbnZleEh1bGxQdHM9dCBpbnN0YW5jZW9mIGl0P3QuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKTp0LmdldENvb3JkaW5hdGVzKCksMD09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9bnVsbCx0aGlzLl9taW5CYXNlU2VnPW51bGwpOjE9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDE9dGhpcy5fY29udmV4SHVsbFB0c1swXSk6Mj09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RofHwzPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDA9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAxPXRoaXMuX2NvbnZleEh1bGxQdHNbMV0pOnRoaXMuY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0aGlzLl9jb252ZXhIdWxsUHRzKX1jb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyKHQpe3RoaXMuX21pbldpZHRoPXIuTUFYX1ZBTFVFO2xldCBlPTE7Y29uc3Qgbj1uZXcgS3Q7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aC0xO3MrKyluLnAwPXRbc10sbi5wMT10W3MrMV0sZT10aGlzLmZpbmRNYXhQZXJwRGlzdGFuY2UodCxuLGUpfWNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKXtpZihudWxsIT09dGhpcy5fbWluV2lkdGhQdClyZXR1cm4gbnVsbDtpZih0aGlzLl9pc0NvbnZleCl0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0aGlzLl9pbnB1dEdlb20pO2Vsc2V7Y29uc3QgdD1uZXcgc24odGhpcy5faW5wdXRHZW9tKS5nZXRDb252ZXhIdWxsKCk7dGhpcy5jb21wdXRlV2lkdGhDb252ZXgodCl9fWdldExlbmd0aCgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9taW5XaWR0aH1maW5kTWF4UGVycERpc3RhbmNlKHQsZSxuKXtsZXQgcz1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W25dKSxpPXMscj1uLG89cjtmb3IoO2k+PXM7KXM9aSxyPW8sbz14bi5uZXh0SW5kZXgodCxyKSxpPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbb10pO3JldHVybiBzPHRoaXMuX21pbldpZHRoJiYodGhpcy5fbWluUHRJbmRleD1yLHRoaXMuX21pbldpZHRoPXMsdGhpcy5fbWluV2lkdGhQdD10W3RoaXMuX21pblB0SW5kZXhdLHRoaXMuX21pbkJhc2VTZWc9bmV3IEt0KGUpKSxyfWdldE1pbmltdW1SZWN0YW5nbGUoKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSwwPT09dGhpcy5fbWluV2lkdGgpcmV0dXJuIHRoaXMuX21pbkJhc2VTZWcucDAuZXF1YWxzMkQodGhpcy5fbWluQmFzZVNlZy5wMSk/dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9taW5CYXNlU2VnLnAwKTp0aGlzLl9taW5CYXNlU2VnLnRvR2VvbWV0cnkodGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKSk7Y29uc3QgdD10aGlzLl9taW5CYXNlU2VnLnAxLngtdGhpcy5fbWluQmFzZVNlZy5wMC54LGU9dGhpcy5fbWluQmFzZVNlZy5wMS55LXRoaXMuX21pbkJhc2VTZWcucDAueTtsZXQgbj1yLk1BWF9WQUxVRSxzPS1yLk1BWF9WQUxVRSxpPXIuTUFYX1ZBTFVFLG89LXIuTUFYX1ZBTFVFO2ZvcihsZXQgcj0wO3I8dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg7cisrKXtjb25zdCBsPXhuLmNvbXB1dGVDKHQsZSx0aGlzLl9jb252ZXhIdWxsUHRzW3JdKTtsPnMmJihzPWwpLGw8biYmKG49bCk7Y29uc3QgYT14bi5jb21wdXRlQygtZSx0LHRoaXMuX2NvbnZleEh1bGxQdHNbcl0pO2E+byYmKG89YSksYTxpJiYoaT1hKX1jb25zdCBsPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxvKSxhPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxpKSxjPXhuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LHMpLGg9eG4uY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQsbiksdT1jLmxpbmVJbnRlcnNlY3Rpb24obCksZz1oLmxpbmVJbnRlcnNlY3Rpb24obCksZD1oLmxpbmVJbnRlcnNlY3Rpb24oYSksXz1jLmxpbmVJbnRlcnNlY3Rpb24oYSkscD10aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoW3UsZyxkLF8sdV0pO3JldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24ocCl9fXZhciBFbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkaXN0YW5jZTpiZSxsb2NhdGU6amUsbWF0Y2g6SmUsQW5nbGU6JHQsQXJlYTpldCxDZW50cm9pZDokZSxDb252ZXhIdWxsOnNuLERpc3RhbmNlOlYsSW50ZXJpb3JQb2ludEFyZWE6b24sSW50ZXJpb3JQb2ludExpbmU6aG4sSW50ZXJpb3JQb2ludFBvaW50OnVuLExlbmd0aDpILE9yaWVudGF0aW9uOkcsUG9pbnRMb2NhdGlvbjpVZSxQb2ludExvY2F0b3I6Zm4sUm9idXN0TGluZUludGVyc2VjdG9yOmp0LE1pbmltdW1Cb3VuZGluZ0NpcmNsZTp5bixNaW5pbXVtRGlhbWV0ZXI6eG59KTtjbGFzcyBJbntjb25zdHJ1Y3Rvcigpe0luLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9c3RhdGljIGRlbnNpZnlQb2ludHModCxlLG4pe2NvbnN0IHM9bmV3IEt0LGk9bmV3IFI7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aC0xO3IrKyl7cy5wMD10W3JdLHMucDE9dFtyKzFdLGkuYWRkKHMucDAsITEpO2NvbnN0IG89cy5nZXRMZW5ndGgoKSxsPU1hdGgudHJ1bmMoby9lKSsxO2lmKGw+MSl7Y29uc3QgdD1vL2w7Zm9yKGxldCBlPTE7ZTxsO2UrKyl7Y29uc3Qgcj1lKnQvbyxsPXMucG9pbnRBbG9uZyhyKTtuLm1ha2VQcmVjaXNlKGwpLGkuYWRkKGwsITEpfX19cmV0dXJuIGkuYWRkKHRbdC5sZW5ndGgtMV0sITEpLGkudG9Db29yZGluYXRlQXJyYXkoKX1zdGF0aWMgZGVuc2lmeSh0LGUpe2NvbnN0IG49bmV3IEluKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiBuZXcgTm4odGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8PTApdGhyb3cgbmV3IHMoXCJUb2xlcmFuY2UgbXVzdCBiZSBwb3NpdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fX1jbGFzcyBObiBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxObi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fXRyYW5zZm9ybU11bHRpUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgZnQ/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPUluLmRlbnNpZnlQb2ludHMobix0aGlzLmRpc3RhbmNlVG9sZXJhbmNlLGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBKJiYxPT09cy5sZW5ndGgmJihzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0LmJ1ZmZlcigwKX19SW4uRGVuc2lmeVRyYW5zZm9ybWVyPU5uO3ZhciBTbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEZW5zaWZpZXI6SW59KTtjbGFzcyB3bntzdGF0aWMgaXNOb3J0aGVybih0KXtyZXR1cm4gdD09PXduLk5FfHx0PT09d24uTld9c3RhdGljIGlzT3Bwb3NpdGUodCxlKXtpZih0PT09ZSlyZXR1cm4hMTtyZXR1cm4gMj09PSh0LWUrNCklNH1zdGF0aWMgY29tbW9uSGFsZlBsYW5lKHQsZSl7aWYodD09PWUpcmV0dXJuIHQ7aWYoMj09PSh0LWUrNCklNClyZXR1cm4tMTtjb25zdCBuPXQ8ZT90OmU7cmV0dXJuIDA9PT1uJiYzPT09KHQ+ZT90OmUpPzM6bn1zdGF0aWMgaXNJbkhhbGZQbGFuZSh0LGUpe3JldHVybiBlPT09d24uU0U/dD09PXduLlNFfHx0PT09d24uU1c6dD09PWV8fHQ9PT1lKzF9c3RhdGljIHF1YWRyYW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBzKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtyZXR1cm4gdD49MD9lPj0wP3duLk5FOnduLlNFOmU+PTA/d24uTlc6d24uU1d9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGUueD09PXQueCYmZS55PT09dC55KXRocm93IG5ldyBzKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIit0KTtyZXR1cm4gZS54Pj10Lng/ZS55Pj10Lnk/d24uTkU6d24uU0U6ZS55Pj10Lnk/d24uTlc6d24uU1d9fX13bi5ORT0wLHduLk5XPTEsd24uU1c9Mix3bi5TRT0zO2NsYXNzIENue2NvbnN0cnVjdG9yKCl7Q24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fb3JpZz1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9vcmlnPXR9c3RhdGljIGNyZWF0ZSh0LGUpe2NvbnN0IG49bmV3IENuKHQpLHM9bmV3IENuKGUpO3JldHVybiBuLmxpbmsocyksbn1maW5kKHQpe2xldCBlPXRoaXM7ZG97aWYobnVsbD09PWUpcmV0dXJuIG51bGw7aWYoZS5kZXN0KCkuZXF1YWxzMkQodCkpcmV0dXJuIGU7ZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiBudWxsfWRlc3QoKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnfWlzRWRnZXNTb3J0ZWQoKXtjb25zdCB0PXRoaXMuZmluZExvd2VzdCgpO2xldCBlPXQ7ZG97Y29uc3Qgbj1lLm9OZXh0KCk7aWYobj09PXQpYnJlYWs7aWYoIShuLmNvbXBhcmVUbyhlKT4wKSlyZXR1cm4hMTtlPW59d2hpbGUoZSE9PXQpO3JldHVybiEwfW9OZXh0KCl7cmV0dXJuIHRoaXMuX3N5bS5fbmV4dH1kaXJlY3Rpb25ZKCl7cmV0dXJuIHRoaXMuZGlyZWN0aW9uUHQoKS5nZXRZKCktdGhpcy5fb3JpZy5nZXRZKCl9aW5zZXJ0KHQpe2lmKHRoaXMub05leHQoKT09PXRoaXMpcmV0dXJuIHRoaXMuaW5zZXJ0QWZ0ZXIodCksbnVsbDt0aGlzLmluc2VydGlvbkVkZ2UodCkuaW5zZXJ0QWZ0ZXIodCl9aW5zZXJ0QWZ0ZXIodCl7Zy5lcXVhbHModGhpcy5fb3JpZyx0Lm9yaWcoKSk7Y29uc3QgZT10aGlzLm9OZXh0KCk7dGhpcy5fc3ltLnNldE5leHQodCksdC5zeW0oKS5zZXROZXh0KGUpfWRlZ3JlZSgpe2xldCB0PTAsZT10aGlzO2Rve3QrKyxlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIHR9ZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19ZmluZExvd2VzdCgpe2xldCB0PXRoaXMsZT10aGlzLm9OZXh0KCk7ZG97ZS5jb21wYXJlVG8odCk8MCYmKHQ9ZSksZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiB0fWRpcmVjdGlvblB0KCl7cmV0dXJuIHRoaXMuZGVzdCgpfXN5bSgpe3JldHVybiB0aGlzLl9zeW19cHJldigpe3JldHVybiB0aGlzLl9zeW0ubmV4dCgpLl9zeW19Y29tcGFyZUFuZ3VsYXJEaXJlY3Rpb24odCl7Y29uc3QgZT10aGlzLmRpcmVjdGlvblgoKSxuPXRoaXMuZGlyZWN0aW9uWSgpLHM9dC5kaXJlY3Rpb25YKCksaT10LmRpcmVjdGlvblkoKTtpZihlPT09cyYmbj09PWkpcmV0dXJuIDA7Y29uc3Qgcj13bi5xdWFkcmFudChlLG4pLG89d24ucXVhZHJhbnQocyxpKTtpZihyPm8pcmV0dXJuIDE7aWYocjxvKXJldHVybi0xO2NvbnN0IGw9dGhpcy5kaXJlY3Rpb25QdCgpLGE9dC5kaXJlY3Rpb25QdCgpO3JldHVybiBHLmluZGV4KHQuX29yaWcsYSxsKX1wcmV2Tm9kZSgpe2xldCB0PXRoaXM7Zm9yKDsyPT09dC5kZWdyZWUoKTspaWYodD10LnByZXYoKSx0PT09dGhpcylyZXR1cm4gbnVsbDtyZXR1cm4gdH1kaXJlY3Rpb25YKCl7cmV0dXJuIHRoaXMuZGlyZWN0aW9uUHQoKS5nZXRYKCktdGhpcy5fb3JpZy5nZXRYKCl9aW5zZXJ0aW9uRWRnZSh0KXtsZXQgZT10aGlzO2Rve2NvbnN0IG49ZS5vTmV4dCgpO2lmKG4uY29tcGFyZVRvKGUpPjAmJnQuY29tcGFyZVRvKGUpPj0wJiZ0LmNvbXBhcmVUbyhuKTw9MClyZXR1cm4gZTtpZihuLmNvbXBhcmVUbyhlKTw9MCYmKHQuY29tcGFyZVRvKG4pPD0wfHx0LmNvbXBhcmVUbyhlKT49MCkpcmV0dXJuIGU7ZT1ufXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gZy5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlQW5ndWxhckRpcmVjdGlvbihlKX10b1N0cmluZ05vZGUoKXtjb25zdCB0PXRoaXMub3JpZygpLGU9KHRoaXMuZGVzdCgpLG5ldyBfdCk7ZS5hcHBlbmQoXCJOb2RlKCBcIitXdC5mb3JtYXQodCkrXCIgKVxcblwiKTtsZXQgbj10aGlzO2Rve2UuYXBwZW5kKFwiICAtPiBcIituKSxlLmFwcGVuZChcIlxcblwiKSxuPW4ub05leHQoKX13aGlsZShuIT09dGhpcyk7cmV0dXJuIGUudG9TdHJpbmcoKX1saW5rKHQpe3RoaXMuc2V0U3ltKHQpLHQuc2V0U3ltKHRoaXMpLHRoaXMuc2V0TmV4dCh0KSx0LnNldE5leHQodGhpcyl9bmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fXNldFN5bSh0KXt0aGlzLl9zeW09dH1vcmlnKCl7cmV0dXJuIHRoaXMuX29yaWd9dG9TdHJpbmcoKXtyZXR1cm5cIkhFKFwiK3RoaXMuX29yaWcueCtcIiBcIit0aGlzLl9vcmlnLnkrXCIsIFwiK3RoaXMuX3N5bS5fb3JpZy54K1wiIFwiK3RoaXMuX3N5bS5fb3JpZy55K1wiKVwifXRvU3RyaW5nTm9kZUVkZ2UoKXtyZXR1cm5cIiAgLT4gKFwiK1d0LmZvcm1hdCh0aGlzLmRlc3QoKSl9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9fWNsYXNzIExuIGV4dGVuZHMgQ257Y29uc3RydWN0b3IoKXtzdXBlcigpLExuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzTWFya2VkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO0NuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9c3RhdGljIHNldE1hcmtCb3RoKHQsZSl7dC5zZXRNYXJrKGUpLHQuc3ltKCkuc2V0TWFyayhlKX1zdGF0aWMgaXNNYXJrZWQodCl7cmV0dXJuIHQuaXNNYXJrZWQoKX1zdGF0aWMgc2V0TWFyayh0LGUpe3Quc2V0TWFyayhlKX1zdGF0aWMgbWFya0JvdGgodCl7dC5tYXJrKCksdC5zeW0oKS5tYXJrKCl9c3RhdGljIG1hcmsodCl7dC5tYXJrKCl9bWFyaygpe3RoaXMuX2lzTWFya2VkPSEwfXNldE1hcmsodCl7dGhpcy5faXNNYXJrZWQ9dH1pc01hcmtlZCgpe3JldHVybiB0aGlzLl9pc01hcmtlZH19Y2xhc3MgVG57Y29uc3RydWN0b3IoKXtUbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl92ZXJ0ZXhNYXA9bmV3IEl0fXN0YXRpYyBpc1ZhbGlkRWRnZSh0LGUpe3JldHVybiAwIT09ZS5jb21wYXJlVG8odCl9aW5zZXJ0KHQsZSxuKXtjb25zdCBzPXRoaXMuY3JlYXRlKHQsZSk7bnVsbCE9PW4/bi5pbnNlcnQocyk6dGhpcy5fdmVydGV4TWFwLnB1dCh0LHMpO2NvbnN0IGk9dGhpcy5fdmVydGV4TWFwLmdldChlKTtyZXR1cm4gbnVsbCE9PWk/aS5pbnNlcnQocy5zeW0oKSk6dGhpcy5fdmVydGV4TWFwLnB1dChlLHMuc3ltKCkpLHN9Y3JlYXRlKHQsZSl7Y29uc3Qgbj10aGlzLmNyZWF0ZUVkZ2UodCkscz10aGlzLmNyZWF0ZUVkZ2UoZSk7cmV0dXJuIG4ubGluayhzKSxufWNyZWF0ZUVkZ2UodCl7cmV0dXJuIG5ldyBDbih0KX1hZGRFZGdlKHQsZSl7aWYoIVRuLmlzVmFsaWRFZGdlKHQsZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLl92ZXJ0ZXhNYXAuZ2V0KHQpO2xldCBzPW51bGw7aWYobnVsbCE9PW4mJihzPW4uZmluZChlKSksbnVsbCE9PXMpcmV0dXJuIHM7cmV0dXJuIHRoaXMuaW5zZXJ0KHQsZSxuKX1nZXRWZXJ0ZXhFZGdlcygpe3JldHVybiB0aGlzLl92ZXJ0ZXhNYXAudmFsdWVzKCl9ZmluZEVkZ2UodCxlKXtjb25zdCBuPXRoaXMuX3ZlcnRleE1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1uP251bGw6bi5maW5kKGUpfX1jbGFzcyBSbiBleHRlbmRzIExue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxSbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc1N0YXJ0PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO0xuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9c2V0U3RhcnQoKXt0aGlzLl9pc1N0YXJ0PSEwfWlzU3RhcnQoKXtyZXR1cm4gdGhpcy5faXNTdGFydH19Y2xhc3MgUG4gZXh0ZW5kcyBUbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9Y3JlYXRlRWRnZSh0KXtyZXR1cm4gbmV3IFJuKHQpfX1jbGFzcyBPbntjb25zdHJ1Y3Rvcigpe09uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3Jlc3VsdD1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2xpbmVzPW5ldyBMLHRoaXMuX25vZGVFZGdlU3RhY2s9bmV3IGVuLHRoaXMuX3JpbmdTdGFydEVkZ2U9bnVsbCx0aGlzLl9ncmFwaD1uZXcgUG59c3RhdGljIGRpc3NvbHZlKHQpe2NvbnN0IGU9bmV3IE9uO3JldHVybiBlLmFkZCh0KSxlLmdldFJlc3VsdCgpfWFkZExpbmUodCl7dGhpcy5fbGluZXMuYWRkKHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LnRvQ29vcmRpbmF0ZUFycmF5KCkpKX11cGRhdGVSaW5nU3RhcnRFZGdlKHQpe3JldHVybiB0LmlzU3RhcnQoKXx8KHQ9dC5zeW0oKSkuaXNTdGFydCgpP251bGw9PT10aGlzLl9yaW5nU3RhcnRFZGdlPyh0aGlzLl9yaW5nU3RhcnRFZGdlPXQsbnVsbCk6dm9pZCh0Lm9yaWcoKS5jb21wYXJlVG8odGhpcy5fcmluZ1N0YXJ0RWRnZS5vcmlnKCkpPDAmJih0aGlzLl9yaW5nU3RhcnRFZGdlPXQpKTpudWxsfWdldFJlc3VsdCgpe3JldHVybiBudWxsPT09dGhpcy5fcmVzdWx0JiZ0aGlzLmNvbXB1dGVSZXN1bHQoKSx0aGlzLl9yZXN1bHR9cHJvY2Vzcyh0KXtsZXQgZT10LnByZXZOb2RlKCk7bnVsbD09PWUmJihlPXQpLHRoaXMuc3RhY2tFZGdlcyhlKSx0aGlzLmJ1aWxkTGluZXMoKX1idWlsZFJpbmcodCl7Y29uc3QgZT1uZXcgUjtsZXQgbj10O2ZvcihlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzPT09dClicmVhaztlLmFkZChzLm9yaWcoKS5jb3B5KCksITEpLG49c31lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuYWRkTGluZShlKX1idWlsZExpbmUodCl7Y29uc3QgZT1uZXcgUjtsZXQgbj10O2Zvcih0aGlzLl9yaW5nU3RhcnRFZGdlPW51bGwsTG4ubWFya0JvdGgobiksZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe3RoaXMudXBkYXRlUmluZ1N0YXJ0RWRnZShuKTtjb25zdCBzPW4ubmV4dCgpO2lmKHM9PT10KXJldHVybiB0aGlzLmJ1aWxkUmluZyh0aGlzLl9yaW5nU3RhcnRFZGdlKSxudWxsO2UuYWRkKHMub3JpZygpLmNvcHkoKSwhMSksbj1zLExuLm1hcmtCb3RoKG4pfWUuYWRkKG4uZGVzdCgpLmNsb25lKCksITEpLHRoaXMuc3RhY2tFZGdlcyhuLnN5bSgpKSx0aGlzLmFkZExpbmUoZSl9c3RhY2tFZGdlcyh0KXtsZXQgZT10O2Rve0xuLmlzTWFya2VkKGUpfHx0aGlzLl9ub2RlRWRnZVN0YWNrLmFkZChlKSxlPWUub05leHQoKX13aGlsZShlIT09dCl9Y29tcHV0ZVJlc3VsdCgpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXRWZXJ0ZXhFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0xuLmlzTWFya2VkKGUpfHx0aGlzLnByb2Nlc3MoZSl9dGhpcy5fcmVzdWx0PXRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyl9YnVpbGRMaW5lcygpe2Zvcig7IXRoaXMuX25vZGVFZGdlU3RhY2suZW1wdHkoKTspe2NvbnN0IHQ9dGhpcy5fbm9kZUVkZ2VTdGFjay5wb3AoKTtMbi5pc01hcmtlZCh0KXx8dGhpcy5idWlsZExpbmUodCl9fWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7YXJndW1lbnRzWzBdLmFwcGx5KG5ldyBjbGFzc3tnZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119ZmlsdGVyKHQpe3QgaW5zdGFuY2VvZiBKJiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSil7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2ZhY3RvcnkmJih0aGlzLl9mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7bGV0IG49ITE7Zm9yKGxldCB0PTE7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9dGhpcy5fZ3JhcGguYWRkRWRnZShlLmdldENvb3JkaW5hdGUodC0xKSxlLmdldENvb3JkaW5hdGUodCkpO251bGwhPT1zJiYobnx8KHMuc2V0U3RhcnQoKSxuPSEwKSl9fX19dmFyIHZuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExpbmVEaXNzb2x2ZXI6T259KTtjbGFzcyBNbntzdGF0aWMgb3Bwb3NpdGUodCl7cmV0dXJuIHQ9PT1Nbi5MRUZUP01uLlJJR0hUOnQ9PT1Nbi5SSUdIVD9Nbi5MRUZUOnR9fU1uLk9OPTAsTW4uTEVGVD0xLE1uLlJJR0hUPTI7Y2xhc3MgYm57Y29uc3RydWN0b3IoKXtibi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLm1jZT1udWxsLHRoaXMuY2hhaW5JbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubWNlPXQsdGhpcy5jaGFpbkluZGV4PWV9Y29tcHV0ZUludGVyc2VjdGlvbnModCxlKXt0aGlzLm1jZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuY2hhaW5JbmRleCx0Lm1jZSx0LmNoYWluSW5kZXgsZSl9fWNsYXNzIERue2NvbnN0cnVjdG9yKCl7RG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGFiZWw9bnVsbCx0aGlzLl94VmFsdWU9bnVsbCx0aGlzLl9ldmVudFR5cGU9bnVsbCx0aGlzLl9pbnNlcnRFdmVudD1udWxsLHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXg9bnVsbCx0aGlzLl9vYmo9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZXZlbnRUeXBlPURuLkRFTEVURSx0aGlzLl94VmFsdWU9dCx0aGlzLl9pbnNlcnRFdmVudD1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2V2ZW50VHlwZT1Ebi5JTlNFUlQsdGhpcy5fbGFiZWw9dCx0aGlzLl94VmFsdWU9ZSx0aGlzLl9vYmo9bn19aXNEZWxldGUoKXtyZXR1cm4gdGhpcy5fZXZlbnRUeXBlPT09RG4uREVMRVRFfXNldERlbGV0ZUV2ZW50SW5kZXgodCl7dGhpcy5fZGVsZXRlRXZlbnRJbmRleD10fWdldE9iamVjdCgpe3JldHVybiB0aGlzLl9vYmp9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5feFZhbHVlPGUuX3hWYWx1ZT8tMTp0aGlzLl94VmFsdWU+ZS5feFZhbHVlPzE6dGhpcy5fZXZlbnRUeXBlPGUuX2V2ZW50VHlwZT8tMTp0aGlzLl9ldmVudFR5cGU+ZS5fZXZlbnRUeXBlPzE6MH1nZXRJbnNlcnRFdmVudCgpe3JldHVybiB0aGlzLl9pbnNlcnRFdmVudH1pc0luc2VydCgpe3JldHVybiB0aGlzLl9ldmVudFR5cGU9PT1Ebi5JTlNFUlR9aXNTYW1lTGFiZWwodCl7cmV0dXJuIG51bGwhPT10aGlzLl9sYWJlbCYmdGhpcy5fbGFiZWw9PT10Ll9sYWJlbH1nZXREZWxldGVFdmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXh9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1Ebi5JTlNFUlQ9MSxEbi5ERUxFVEU9MjtjbGFzcyBBbntjb25zdHJ1Y3Rvcigpe0FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9oYXNQcm9wZXI9ITEsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX2luY2x1ZGVQcm9wZXI9bnVsbCx0aGlzLl9yZWNvcmRJc29sYXRlZD1udWxsLHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMuX251bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTAsdGhpcy5fYmR5Tm9kZXM9bnVsbCx0aGlzLl9pc0RvbmU9ITEsdGhpcy5faXNEb25lV2hlblByb3BlckludD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9saT10LHRoaXMuX2luY2x1ZGVQcm9wZXI9ZSx0aGlzLl9yZWNvcmRJc29sYXRlZD1ufXN0YXRpYyBpc0FkamFjZW50U2VnbWVudHModCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9aXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2lmKHQ9PT1uJiYxPT09dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKEFuLmlzQWRqYWNlbnRTZWdtZW50cyhlLHMpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7Y29uc3Qgbj10LmdldE51bVBvaW50cygpLTE7aWYoMD09PWUmJnM9PT1ufHwwPT09cyYmZT09PW4pcmV0dXJuITB9fXJldHVybiExfWdldFByb3BlckludGVyc2VjdGlvblBvaW50KCl7cmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50fXNldElzRG9uZUlmUHJvcGVySW50KHQpe3RoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQ9dH1oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcn1pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpLmdldENvb3JkaW5hdGUoKTtpZih0LmlzSW50ZXJzZWN0aW9uKGUpKXJldHVybiEwfXJldHVybiExfWhhc1Byb3BlckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJ9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4gdGhpcy5faXNEb25lfWlzQm91bmRhcnlQb2ludCh0LGUpe3JldHVybiBudWxsIT09ZSYmKCEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMF0pfHwhIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzFdKSl9c2V0Qm91bmRhcnlOb2Rlcyh0LGUpe3RoaXMuX2JkeU5vZGVzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2JkeU5vZGVzWzBdPXQsdGhpcy5fYmR5Tm9kZXNbMV09ZX1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLl9yZWNvcmRJc29sYXRlZCYmKHQuc2V0SXNvbGF0ZWQoITEpLG4uc2V0SXNvbGF0ZWQoITEpKSx0aGlzLl9udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsIXRoaXMuX2luY2x1ZGVQcm9wZXImJnRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKSksdGhpcy5fbGkuaXNQcm9wZXIoKSYmKHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCksdGhpcy5faGFzUHJvcGVyPSEwLHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQmJih0aGlzLl9pc0RvbmU9ITApLHRoaXMuaXNCb3VuZGFyeVBvaW50KHRoaXMuX2xpLHRoaXMuX2JkeU5vZGVzKXx8KHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSEwKSkpKX19Y2xhc3MgRm4gZXh0ZW5kcyBjbGFzc3t9e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxGbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmV2ZW50cz1uZXcgTCx0aGlzLm5PdmVybGFwcz1udWxsfXByZXBhcmVFdmVudHMoKXt4ZS5zb3J0KHRoaXMuZXZlbnRzKTtmb3IobGV0IHQ9MDt0PHRoaXMuZXZlbnRzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5ldmVudHMuZ2V0KHQpO2UuaXNEZWxldGUoKSYmZS5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgodCl9fWNvbXB1dGVJbnRlcnNlY3Rpb25zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubk92ZXJsYXBzPTAsdGhpcy5wcmVwYXJlRXZlbnRzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLmV2ZW50cy5zaXplKCk7ZSsrKXtjb25zdCBuPXRoaXMuZXZlbnRzLmdldChlKTtpZihuLmlzSW5zZXJ0KCkmJnRoaXMucHJvY2Vzc092ZXJsYXBzKGUsbi5nZXREZWxldGVFdmVudEluZGV4KCksbix0KSx0LmlzRG9uZSgpKWJyZWFrfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQW4mJkkoYXJndW1lbnRzWzBdLHcpJiZJKGFyZ3VtZW50c1sxXSx3KSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5hZGRFZGdlcyh0LHQpLHRoaXMuYWRkRWRnZXMoZSxlKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKG4pfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJkkoYXJndW1lbnRzWzBdLHcpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFuKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl0/dGhpcy5hZGRFZGdlcyh0LG51bGwpOnRoaXMuYWRkRWRnZXModCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhlKX19YWRkRWRnZSh0LGUpe2NvbnN0IG49dC5nZXRNb25vdG9uZUNoYWluRWRnZSgpLHM9bi5nZXRTdGFydEluZGV4ZXMoKTtmb3IobGV0IHQ9MDt0PHMubGVuZ3RoLTE7dCsrKXtjb25zdCBzPW5ldyBibihuLHQpLGk9bmV3IERuKGUsbi5nZXRNaW5YKHQpLHMpO3RoaXMuZXZlbnRzLmFkZChpKSx0aGlzLmV2ZW50cy5hZGQobmV3IERuKG4uZ2V0TWF4WCh0KSxpKSl9fXByb2Nlc3NPdmVybGFwcyh0LGUsbixzKXtjb25zdCBpPW4uZ2V0T2JqZWN0KCk7Zm9yKGxldCByPXQ7cjxlO3IrKyl7Y29uc3QgdD10aGlzLmV2ZW50cy5nZXQocik7aWYodC5pc0luc2VydCgpKXtjb25zdCBlPXQuZ2V0T2JqZWN0KCk7bi5pc1NhbWVMYWJlbCh0KXx8KGkuY29tcHV0ZUludGVyc2VjdGlvbnMoZSxzKSx0aGlzLm5PdmVybGFwcysrKX19fWFkZEVkZ2VzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGRFZGdlKGUsZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5hZGRFZGdlKG4sdCl9fX19Y2xhc3MgR257Y29uc3RydWN0b3IoKXtHbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLmxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0Lmxlbmd0aCl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCgxKSx0aGlzLmxvY2F0aW9uW01uLk9OXT10fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBHbil7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pbml0KHQubG9jYXRpb24ubGVuZ3RoKSxudWxsIT09dClmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuaW5pdCgzKSx0aGlzLmxvY2F0aW9uW01uLk9OXT10LHRoaXMubG9jYXRpb25bTW4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW01uLlJJR0hUXT1ufX1zZXRBbGxMb2NhdGlvbnModCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10fWlzTnVsbCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF0hPT1RdC5OT05FKXJldHVybiExO3JldHVybiEwfXNldEFsbExvY2F0aW9uc0lmTnVsbCh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPT09UXQuTk9ORSYmKHRoaXMubG9jYXRpb25bZV09dCl9aXNMaW5lKCl7cmV0dXJuIDE9PT10aGlzLmxvY2F0aW9uLmxlbmd0aH1tZXJnZSh0KXtpZih0LmxvY2F0aW9uLmxlbmd0aD50aGlzLmxvY2F0aW9uLmxlbmd0aCl7Y29uc3QgdD1uZXcgQXJyYXkoMykuZmlsbChudWxsKTt0W01uLk9OXT10aGlzLmxvY2F0aW9uW01uLk9OXSx0W01uLkxFRlRdPVF0Lk5PTkUsdFtNbi5SSUdIVF09UXQuTk9ORSx0aGlzLmxvY2F0aW9uPXR9Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PVF0Lk5PTkUmJmU8dC5sb2NhdGlvbi5sZW5ndGgmJih0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV0pfWdldExvY2F0aW9ucygpe3JldHVybiB0aGlzLmxvY2F0aW9ufWZsaXAoKXtpZih0aGlzLmxvY2F0aW9uLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMubG9jYXRpb25bTW4uTEVGVF07dGhpcy5sb2NhdGlvbltNbi5MRUZUXT10aGlzLmxvY2F0aW9uW01uLlJJR0hUXSx0aGlzLmxvY2F0aW9uW01uLlJJR0hUXT10fXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdjtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQoUXQudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW01uLkxFRlRdKSksdC5hcHBlbmQoUXQudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW01uLk9OXSkpLHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKFF0LnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltNbi5SSUdIVF0pKSx0LnRvU3RyaW5nKCl9c2V0TG9jYXRpb25zKHQsZSxuKXt0aGlzLmxvY2F0aW9uW01uLk9OXT10LHRoaXMubG9jYXRpb25bTW4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW01uLlJJR0hUXT1ufWdldCh0KXtyZXR1cm4gdDx0aGlzLmxvY2F0aW9uLmxlbmd0aD90aGlzLmxvY2F0aW9uW3RdOlF0Lk5PTkV9aXNBcmVhKCl7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjF9aXNBbnlOdWxsKCl7Zm9yKGxldCB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XT09PVF0Lk5PTkUpcmV0dXJuITA7cmV0dXJuITF9c2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRMb2NhdGlvbihNbi5PTix0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmxvY2F0aW9uW3RdPWV9fWluaXQodCl7dGhpcy5sb2NhdGlvbj1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLnNldEFsbExvY2F0aW9ucyhRdC5OT05FKX1pc0VxdWFsT25TaWRlKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRpb25bZV09PT10LmxvY2F0aW9uW2VdfWFsbFBvc2l0aW9uc0VxdWFsKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKWlmKHRoaXMubG9jYXRpb25bZV0hPT10KXJldHVybiExO3JldHVybiEwfX1jbGFzcyBxbntjb25zdHJ1Y3Rvcigpe3FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuZWx0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBHbih0KSx0aGlzLmVsdFsxXT1uZXcgR24odCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFuKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgR24odC5lbHRbMF0pLHRoaXMuZWx0WzFdPW5ldyBHbih0LmVsdFsxXSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0WzBdPW5ldyBHbihRdC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgR24oUXQuTk9ORSksdGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5lbHRbMF09bmV3IEduKHQsZSxuKSx0aGlzLmVsdFsxXT1uZXcgR24odCxlLG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuZWx0WzBdPW5ldyBHbihRdC5OT05FLFF0Lk5PTkUsUXQuTk9ORSksdGhpcy5lbHRbMV09bmV3IEduKFF0Lk5PTkUsUXQuTk9ORSxRdC5OT05FKSx0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbnMoZSxuLHMpfX1zdGF0aWMgdG9MaW5lTGFiZWwodCl7Y29uc3QgZT1uZXcgcW4oUXQuTk9ORSk7Zm9yKGxldCBuPTA7bjwyO24rKyllLnNldExvY2F0aW9uKG4sdC5nZXRMb2NhdGlvbihuKSk7cmV0dXJuIGV9Z2V0R2VvbWV0cnlDb3VudCgpe2xldCB0PTA7cmV0dXJuIHRoaXMuZWx0WzBdLmlzTnVsbCgpfHx0KyssdGhpcy5lbHRbMV0uaXNOdWxsKCl8fHQrKyx0fXNldEFsbExvY2F0aW9ucyh0LGUpe3RoaXMuZWx0W3RdLnNldEFsbExvY2F0aW9ucyhlKX1pc051bGwodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTnVsbCgpfXNldEFsbExvY2F0aW9uc0lmTnVsbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQpLHRoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zSWZOdWxsKGUpfX1pc0xpbmUodCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTGluZSgpfW1lcmdlKHQpe2ZvcihsZXQgZT0wO2U8MjtlKyspbnVsbD09PXRoaXMuZWx0W2VdJiZudWxsIT09dC5lbHRbZV0/dGhpcy5lbHRbZV09bmV3IEduKHQuZWx0W2VdKTp0aGlzLmVsdFtlXS5tZXJnZSh0LmVsdFtlXSl9ZmxpcCgpe3RoaXMuZWx0WzBdLmZsaXAoKSx0aGlzLmVsdFsxXS5mbGlwKCl9Z2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmdldChNbi5PTil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoZSl9fXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdjtyZXR1cm4gbnVsbCE9PXRoaXMuZWx0WzBdJiYodC5hcHBlbmQoXCJBOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFswXS50b1N0cmluZygpKSksbnVsbCE9PXRoaXMuZWx0WzFdJiYodC5hcHBlbmQoXCIgQjpcIiksdC5hcHBlbmQodGhpcy5lbHRbMV0udG9TdHJpbmcoKSkpLHQudG9TdHJpbmcoKX1pc0FyZWEoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5lbHRbMF0uaXNBcmVhKCl8fHRoaXMuZWx0WzFdLmlzQXJlYSgpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBcmVhKCl9fWlzQW55TnVsbCh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBbnlOdWxsKCl9c2V0TG9jYXRpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oTW4uT04sZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oZSxuKX19aXNFcXVhbE9uU2lkZSh0LGUpe3JldHVybiB0aGlzLmVsdFswXS5pc0VxdWFsT25TaWRlKHQuZWx0WzBdLGUpJiZ0aGlzLmVsdFsxXS5pc0VxdWFsT25TaWRlKHQuZWx0WzFdLGUpfWFsbFBvc2l0aW9uc0VxdWFsKHQsZSl7cmV0dXJuIHRoaXMuZWx0W3RdLmFsbFBvc2l0aW9uc0VxdWFsKGUpfXRvTGluZSh0KXt0aGlzLmVsdFt0XS5pc0FyZWEoKSYmKHRoaXMuZWx0W3RdPW5ldyBHbih0aGlzLmVsdFt0XS5sb2NhdGlvblswXSkpfX1jbGFzcyBCbntjb25zdHJ1Y3Rvcigpe0JuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuZGlzdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuY29vcmQ9bmV3IG0odCksdGhpcy5zZWdtZW50SW5kZXg9ZSx0aGlzLmRpc3Q9bn1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXh9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvb3JkfXByaW50KHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KSx0LnByaW50bG4oXCIgZGlzdCA9IFwiK3RoaXMuZGlzdCl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlKGUuc2VnbWVudEluZGV4LGUuZGlzdCl9aXNFbmRQb2ludCh0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYwPT09dGhpcy5kaXN0fHx0aGlzLnNlZ21lbnRJbmRleD09PXR9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5jb29yZCtcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4K1wiIGRpc3QgPSBcIit0aGlzLmRpc3R9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5kaXN0fWNvbXBhcmUodCxlKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8dD8tMTp0aGlzLnNlZ21lbnRJbmRleD50PzE6dGhpcy5kaXN0PGU/LTE6dGhpcy5kaXN0PmU/MTowfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgWW4gZXh0ZW5kcyB5dHt9ZnVuY3Rpb24gVm4odCl7cmV0dXJuIG51bGw9PXQ/MDp0LmNvbG9yfWZ1bmN0aW9uIHpuKHQpe3JldHVybiBudWxsPT10P251bGw6dC5wYXJlbnR9ZnVuY3Rpb24ga24odCxlKXtudWxsIT09dCYmKHQuY29sb3I9ZSl9ZnVuY3Rpb24gWG4odCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LmxlZnR9ZnVuY3Rpb24gVW4odCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnJpZ2h0fWNsYXNzIEhuIGV4dGVuZHMgWW57Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucm9vdF89bnVsbCx0aGlzLnNpemVfPTB9Z2V0KHQpe2xldCBlPXRoaXMucm9vdF87Zm9yKDtudWxsIT09ZTspe2NvbnN0IG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4gZS52YWx1ZTtlPWUucmlnaHR9fXJldHVybiBudWxsfXB1dCh0LGUpe2lmKG51bGw9PT10aGlzLnJvb3RfKXJldHVybiB0aGlzLnJvb3RfPXtrZXk6dCx2YWx1ZTplLGxlZnQ6bnVsbCxyaWdodDpudWxsLHBhcmVudDpudWxsLGNvbG9yOjAsZ2V0VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5KCl7cmV0dXJuIHRoaXMua2V5fX0sdGhpcy5zaXplXz0xLG51bGw7bGV0IG4scyxpPXRoaXMucm9vdF87ZG97aWYobj1pLHM9dC5jb21wYXJlVG8oaS5rZXkpLHM8MClpPWkubGVmdDtlbHNle2lmKCEocz4wKSl7Y29uc3QgdD1pLnZhbHVlO3JldHVybiBpLnZhbHVlPWUsdH1pPWkucmlnaHR9fXdoaWxlKG51bGwhPT1pKTtjb25zdCByPXtrZXk6dCxsZWZ0Om51bGwscmlnaHQ6bnVsbCx2YWx1ZTplLHBhcmVudDpuLGNvbG9yOjAsZ2V0VmFsdWUoKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5KCl7cmV0dXJuIHRoaXMua2V5fX07cmV0dXJuIHM8MD9uLmxlZnQ9cjpuLnJpZ2h0PXIsdGhpcy5maXhBZnRlckluc2VydGlvbihyKSx0aGlzLnNpemVfKyssbnVsbH1maXhBZnRlckluc2VydGlvbih0KXtsZXQgZTtmb3IodC5jb2xvcj0xO251bGwhPXQmJnQhPT10aGlzLnJvb3RfJiYxPT09dC5wYXJlbnQuY29sb3I7KXpuKHQpPT09WG4oem4oem4odCkpKT8oZT1Vbih6bih6bih0KSkpLDE9PT1WbihlKT8oa24oem4odCksMCksa24oZSwwKSxrbih6bih6bih0KSksMSksdD16bih6bih0KSkpOih0PT09VW4oem4odCkpJiYodD16bih0KSx0aGlzLnJvdGF0ZUxlZnQodCkpLGtuKHpuKHQpLDApLGtuKHpuKHpuKHQpKSwxKSx0aGlzLnJvdGF0ZVJpZ2h0KHpuKHpuKHQpKSkpKTooZT1Ybih6bih6bih0KSkpLDE9PT1WbihlKT8oa24oem4odCksMCksa24oZSwwKSxrbih6bih6bih0KSksMSksdD16bih6bih0KSkpOih0PT09WG4oem4odCkpJiYodD16bih0KSx0aGlzLnJvdGF0ZVJpZ2h0KHQpKSxrbih6bih0KSwwKSxrbih6bih6bih0KSksMSksdGhpcy5yb3RhdGVMZWZ0KHpuKHpuKHQpKSkpKTt0aGlzLnJvb3RfLmNvbG9yPTB9dmFsdWVzKCl7Y29uc3QgdD1uZXcgTDtsZXQgZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZS52YWx1ZSk7bnVsbCE9PShlPUhuLnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUudmFsdWUpO3JldHVybiB0fWVudHJ5U2V0KCl7Y29uc3QgdD1uZXcgeHQ7bGV0IGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUpO251bGwhPT0oZT1Ibi5zdWNjZXNzb3IoZSkpOyl0LmFkZChlKTtyZXR1cm4gdH1yb3RhdGVMZWZ0KHQpe2lmKG51bGwhPXQpe2NvbnN0IGU9dC5yaWdodDt0LnJpZ2h0PWUubGVmdCxudWxsIT1lLmxlZnQmJihlLmxlZnQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5sZWZ0PT09dD90LnBhcmVudC5sZWZ0PWU6dC5wYXJlbnQucmlnaHQ9ZSxlLmxlZnQ9dCx0LnBhcmVudD1lfX1yb3RhdGVSaWdodCh0KXtpZihudWxsIT10KXtjb25zdCBlPXQubGVmdDt0LmxlZnQ9ZS5yaWdodCxudWxsIT1lLnJpZ2h0JiYoZS5yaWdodC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LnJpZ2h0PT09dD90LnBhcmVudC5yaWdodD1lOnQucGFyZW50LmxlZnQ9ZSxlLnJpZ2h0PXQsdC5wYXJlbnQ9ZX19Z2V0Rmlyc3RFbnRyeSgpe2xldCB0PXRoaXMucm9vdF87aWYobnVsbCE9dClmb3IoO251bGwhPXQubGVmdDspdD10LmxlZnQ7cmV0dXJuIHR9c3RhdGljIHN1Y2Nlc3Nvcih0KXtsZXQgZTtpZihudWxsPT09dClyZXR1cm4gbnVsbDtpZihudWxsIT09dC5yaWdodCl7Zm9yKGU9dC5yaWdodDtudWxsIT09ZS5sZWZ0OyllPWUubGVmdDtyZXR1cm4gZX17ZT10LnBhcmVudDtsZXQgbj10O2Zvcig7bnVsbCE9PWUmJm49PT1lLnJpZ2h0OyluPWUsZT1lLnBhcmVudDtyZXR1cm4gZX19c2l6ZSgpe3JldHVybiB0aGlzLnNpemVffWNvbnRhaW5zS2V5KHQpe2xldCBlPXRoaXMucm9vdF87Zm9yKDtudWxsIT09ZTspe2NvbnN0IG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4hMDtlPWUucmlnaHR9fXJldHVybiExfX1jbGFzcyBXbntjb25zdHJ1Y3Rvcigpe1duLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVNYXA9bmV3IEhuLHRoaXMuZWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fXByaW50KHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfWFkZFNwbGl0RWRnZXModCl7dGhpcy5hZGRFbmRwb2ludHMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4scyk7dC5hZGQoaSksbj1zfX1hZGRFbmRwb2ludHMoKXtjb25zdCB0PXRoaXMuZWRnZS5wdHMubGVuZ3RoLTE7dGhpcy5hZGQodGhpcy5lZGdlLnB0c1swXSwwLDApLHRoaXMuYWRkKHRoaXMuZWRnZS5wdHNbdF0sdCwwKX1jcmVhdGVTcGxpdEVkZ2UodCxlKXtsZXQgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyO2NvbnN0IHM9dGhpcy5lZGdlLnB0c1tlLnNlZ21lbnRJbmRleF0saT1lLmRpc3Q+MHx8IWUuY29vcmQuZXF1YWxzMkQocyk7aXx8bi0tO2NvbnN0IHI9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7bGV0IG89MDtyW28rK109bmV3IG0odC5jb29yZCk7Zm9yKGxldCBuPXQuc2VnbWVudEluZGV4KzE7bjw9ZS5zZWdtZW50SW5kZXg7bisrKXJbbysrXT10aGlzLmVkZ2UucHRzW25dO3JldHVybiBpJiYocltvXT1lLmNvb3JkKSxuZXcgJG4ocixuZXcgcW4odGhpcy5lZGdlLl9sYWJlbCkpfWFkZCh0LGUsbil7Y29uc3Qgcz1uZXcgQm4odCxlLG4pLGk9dGhpcy5fbm9kZU1hcC5nZXQocyk7cmV0dXJuIG51bGwhPT1pP2k6KHRoaXMuX25vZGVNYXAucHV0KHMscykscyl9aXNJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvb3JkLmVxdWFscyh0KSlyZXR1cm4hMH1yZXR1cm4hMX19Y2xhc3MgWm57Y29uc3RydWN0b3IoKXtabi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9kYXRhPW51bGwsdGhpcy5fc2l6ZT0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKVpuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMTApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RhdGE9bmV3IEFycmF5KHQpLmZpbGwobnVsbCl9fXNpemUoKXtyZXR1cm4gdGhpcy5fc2l6ZX1hZGRBbGwodCl7cmV0dXJuIG51bGw9PT10fHwwPT09dC5sZW5ndGg/bnVsbDoodGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplK3QubGVuZ3RoKSxCLmFycmF5Y29weSh0LDAsdGhpcy5fZGF0YSx0aGlzLl9zaXplLHQubGVuZ3RoKSx2b2lkKHRoaXMuX3NpemUrPXQubGVuZ3RoKSl9ZW5zdXJlQ2FwYWNpdHkodCl7aWYodDw9dGhpcy5fZGF0YS5sZW5ndGgpcmV0dXJuIG51bGw7Y29uc3QgZT1NYXRoLm1heCh0LDIqdGhpcy5fZGF0YS5sZW5ndGgpO3RoaXMuX2RhdGE9bnQuY29weU9mKHRoaXMuX2RhdGEsZSl9dG9BcnJheSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX3NpemUpLmZpbGwobnVsbCk7cmV0dXJuIEIuYXJyYXljb3B5KHRoaXMuX2RhdGEsMCx0LDAsdGhpcy5fc2l6ZSksdH1hZGQodCl7dGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplKzEpLHRoaXMuX2RhdGFbdGhpcy5fc2l6ZV09dCwrK3RoaXMuX3NpemV9fWNsYXNzIGpue3N0YXRpYyB0b0ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX1nZXRDaGFpblN0YXJ0SW5kaWNlcyh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IFpuKE1hdGgudHJ1bmModC5sZW5ndGgvMikpO24uYWRkKGUpO2Rve2NvbnN0IHM9dGhpcy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChzKSxlPXN9d2hpbGUoZTx0Lmxlbmd0aC0xKTtyZXR1cm4gbi50b0FycmF5KCl9ZmluZENoYWluRW5kKHQsZSl7Y29uc3Qgbj13bi5xdWFkcmFudCh0W2VdLHRbZSsxXSk7bGV0IHM9ZSsxO2Zvcig7czx0Lmxlbmd0aDspe2lmKHduLnF1YWRyYW50KHRbcy0xXSx0W3NdKSE9PW4pYnJlYWs7cysrfXJldHVybiBzLTF9T0xEZ2V0Q2hhaW5TdGFydEluZGljZXModCl7bGV0IGU9MDtjb25zdCBuPW5ldyBMO24uYWRkKGUpO2Rve2NvbnN0IHM9dGhpcy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChzKSxlPXN9d2hpbGUoZTx0Lmxlbmd0aC0xKTtyZXR1cm4gam4udG9JbnRBcnJheShuKX19Y2xhc3MgS257Y29uc3RydWN0b3IoKXtLbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLmU9bnVsbCx0aGlzLnB0cz1udWxsLHRoaXMuc3RhcnRJbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZT10LHRoaXMucHRzPXQuZ2V0Q29vcmRpbmF0ZXMoKTtjb25zdCBlPW5ldyBqbjt0aGlzLnN0YXJ0SW5kZXg9ZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0aGlzLnB0cyl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9Z2V0TWF4WCh0KXtjb25zdCBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPm4/ZTpufWdldE1pblgodCl7Y29uc3QgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZTxuP2U6bn1jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLnN0YXJ0SW5kZXhbdF0sdGhpcy5zdGFydEluZGV4W3QrMV0sZSxlLnN0YXJ0SW5kZXhbbl0sZS5zdGFydEluZGV4W24rMV0scyl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07aWYoZS10PT0xJiZpLXM9PTEpcmV0dXJuIHIuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmUsdCxuLmUscyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odCxvLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHQsbyxuLGwsaSxyKSksbzxlJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG8sZSxuLGwsaSxyKSl9fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE8uaW50ZXJzZWN0cyh0aGlzLnB0c1t0XSx0aGlzLnB0c1tlXSxuLnB0c1tzXSxuLnB0c1tpXSl9Z2V0U3RhcnRJbmRleGVzKCl7cmV0dXJuIHRoaXMuc3RhcnRJbmRleH1jb21wdXRlSW50ZXJzZWN0cyh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5zdGFydEluZGV4Lmxlbmd0aC0xO24rKylmb3IobGV0IHM9MDtzPHQuc3RhcnRJbmRleC5sZW5ndGgtMTtzKyspdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG4sdCxzLGUpfX1jbGFzcyBRbntjb25zdHJ1Y3Rvcigpe1FuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2RlcHRoPUFycmF5KDIpLmZpbGwoKS5tYXAoKCgpPT5BcnJheSgzKSkpO2ZvcihsZXQgdD0wO3Q8Mjt0KyspZm9yKGxldCBlPTA7ZTwzO2UrKyl0aGlzLl9kZXB0aFt0XVtlXT1Rbi5OVUxMX1ZBTFVFfXN0YXRpYyBkZXB0aEF0TG9jYXRpb24odCl7cmV0dXJuIHQ9PT1RdC5FWFRFUklPUj8wOnQ9PT1RdC5JTlRFUklPUj8xOlFuLk5VTExfVkFMVUV9Z2V0RGVwdGgodCxlKXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV19c2V0RGVwdGgodCxlLG4pe3RoaXMuX2RlcHRoW3RdW2VdPW59aXNOdWxsKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD0wO3Q8Mjt0KyspZm9yKGxldCBlPTA7ZTwzO2UrKylpZih0aGlzLl9kZXB0aFt0XVtlXSE9PVFuLk5VTExfVkFMVUUpcmV0dXJuITE7cmV0dXJuITB9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kZXB0aFt0XVsxXT09PVFuLk5VTExfVkFMVUV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXT09PVFuLk5VTExfVkFMVUV9fW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8Mjt0KyspaWYoIXRoaXMuaXNOdWxsKHQpKXtsZXQgZT10aGlzLl9kZXB0aFt0XVsxXTt0aGlzLl9kZXB0aFt0XVsyXTxlJiYoZT10aGlzLl9kZXB0aFt0XVsyXSksZTwwJiYoZT0wKTtmb3IobGV0IG49MTtuPDM7bisrKXtsZXQgcz0wO3RoaXMuX2RlcHRoW3RdW25dPmUmJihzPTEpLHRoaXMuX2RlcHRoW3RdW25dPXN9fX1nZXREZWx0YSh0KXtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bTW4uUklHSFRdLXRoaXMuX2RlcHRoW3RdW01uLkxFRlRdfWdldExvY2F0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdPD0wP1F0LkVYVEVSSU9SOlF0LklOVEVSSU9SfXRvU3RyaW5nKCl7cmV0dXJuXCJBOiBcIit0aGlzLl9kZXB0aFswXVsxXStcIixcIit0aGlzLl9kZXB0aFswXVsyXStcIiBCOiBcIit0aGlzLl9kZXB0aFsxXVsxXStcIixcIit0aGlzLl9kZXB0aFsxXVsyXX1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTwyO2UrKylmb3IobGV0IG49MTtuPDM7bisrKXtjb25zdCBzPXQuZ2V0TG9jYXRpb24oZSxuKTtzIT09UXQuRVhURVJJT1ImJnMhPT1RdC5JTlRFUklPUnx8KHRoaXMuaXNOdWxsKGUsbik/dGhpcy5fZGVwdGhbZV1bbl09UW4uZGVwdGhBdExvY2F0aW9uKHMpOnRoaXMuX2RlcHRoW2VdW25dKz1Rbi5kZXB0aEF0TG9jYXRpb24ocykpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl09PT1RdC5JTlRFUklPUiYmdGhpcy5fZGVwdGhbdF1bZV0rK319fVFuLk5VTExfVkFMVUU9LTE7Y2xhc3MgSm57Y29uc3RydWN0b3IoKXtKbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9sYWJlbD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNDb3ZlcmVkPSExLHRoaXMuX2lzQ292ZXJlZFNldD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xhYmVsPXR9fXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWlzQ292ZXJlZCgpe3JldHVybiB0aGlzLl9pc0NvdmVyZWR9aXNDb3ZlcmVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZFNldH1zZXRMYWJlbCh0KXt0aGlzLl9sYWJlbD10fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfXNldENvdmVyZWQodCl7dGhpcy5faXNDb3ZlcmVkPXQsdGhpcy5faXNDb3ZlcmVkU2V0PSEwfXVwZGF0ZUlNKHQpe2cuaXNUcnVlKHRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKT49MixcImZvdW5kIHBhcnRpYWwgbGFiZWxcIiksdGhpcy5jb21wdXRlSU0odCl9aXNJblJlc3VsdCgpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9fWNsYXNzICRuIGV4dGVuZHMgSm57Y29uc3RydWN0b3IoKXtzdXBlcigpLCRuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMucHRzPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5laUxpc3Q9bmV3IFduKHRoaXMpLHRoaXMuX25hbWU9bnVsbCx0aGlzLl9tY2U9bnVsbCx0aGlzLl9pc0lzb2xhdGVkPSEwLHRoaXMuX2RlcHRoPW5ldyBRbix0aGlzLl9kZXB0aERlbHRhPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdOyRuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuX2xhYmVsPWV9fXN0YXRpYyB1cGRhdGVJTSgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSnQmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcW4pKXJldHVybiBzdXBlci51cGRhdGVJTS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Uuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLE1uLk9OKSx0LmdldExvY2F0aW9uKDEsTW4uT04pLDEpLHQuaXNBcmVhKCkmJihlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxNbi5MRUZUKSx0LmdldExvY2F0aW9uKDEsTW4uTEVGVCksMiksZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsTW4uUklHSFQpLHQuZ2V0TG9jYXRpb24oMSxNbi5SSUdIVCksMikpfX1nZXREZXB0aCgpe3JldHVybiB0aGlzLl9kZXB0aH1nZXRDb2xsYXBzZWRFZGdlKCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTt0WzBdPXRoaXMucHRzWzBdLHRbMV09dGhpcy5wdHNbMV07cmV0dXJuIG5ldyAkbih0LHFuLnRvTGluZUxhYmVsKHRoaXMuX2xhYmVsKSl9aXNJc29sYXRlZCgpe3JldHVybiB0aGlzLl9pc0lzb2xhdGVkfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfXNldElzb2xhdGVkKHQpe3RoaXMuX2lzSXNvbGF0ZWQ9dH1zZXROYW1lKHQpe3RoaXMuX25hbWU9dH1lcXVhbHModCl7aWYoISh0IGluc3RhbmNlb2YgJG4pKXJldHVybiExO2NvbnN0IGU9dDtpZih0aGlzLnB0cy5sZW5ndGghPT1lLnB0cy5sZW5ndGgpcmV0dXJuITE7bGV0IG49ITAscz0hMCxpPXRoaXMucHRzLmxlbmd0aDtmb3IobGV0IHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspaWYodGhpcy5wdHNbdF0uZXF1YWxzMkQoZS5wdHNbdF0pfHwobj0hMSksdGhpcy5wdHNbdF0uZXF1YWxzMkQoZS5wdHNbLS1pXSl8fChzPSExKSwhbiYmIXMpcmV0dXJuITE7cmV0dXJuITB9Z2V0Q29vcmRpbmF0ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnB0cy5sZW5ndGg+MD90aGlzLnB0c1swXTpudWxsO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5wdHNbdF19fXByaW50KHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMuX25hbWUrXCI6IFwiKSx0LnByaW50KFwiTElORVNUUklORyAoXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTt0LnByaW50KFwiKSAgXCIrdGhpcy5fbGFiZWwrXCIgXCIrdGhpcy5fZGVwdGhEZWx0YSl9Y29tcHV0ZUlNKHQpeyRuLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLHQpfWlzQ29sbGFwc2VkKCl7cmV0dXJuISF0aGlzLl9sYWJlbC5pc0FyZWEoKSYmKDM9PT10aGlzLnB0cy5sZW5ndGgmJiEhdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzWzJdKSl9aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9Z2V0TWF4aW11bVNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLnB0cy5sZW5ndGgtMX1nZXREZXB0aERlbHRhKCl7cmV0dXJuIHRoaXMuX2RlcHRoRGVsdGF9Z2V0TnVtUG9pbnRzKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH1wcmludFJldmVyc2UodCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpO2ZvcihsZXQgZT10aGlzLnB0cy5sZW5ndGgtMTtlPj0wO2UtLSl0LnByaW50KHRoaXMucHRzW2VdK1wiIFwiKTt0LnByaW50bG4oXCJcIil9Z2V0TW9ub3RvbmVDaGFpbkVkZ2UoKXtyZXR1cm4gbnVsbD09PXRoaXMuX21jZSYmKHRoaXMuX21jZT1uZXcgS24odGhpcykpLHRoaXMuX21jZX1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe3RoaXMuX2Vudj1uZXcgTztmb3IobGV0IHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy5fZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLnB0c1t0XSl9cmV0dXJuIHRoaXMuX2Vudn1hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1uZXcgbSh0LmdldEludGVyc2VjdGlvbihzKSk7bGV0IHI9ZSxvPXQuZ2V0RWRnZURpc3RhbmNlKG4scyk7Y29uc3QgbD1yKzE7aWYobDx0aGlzLnB0cy5sZW5ndGgpe2NvbnN0IHQ9dGhpcy5wdHNbbF07aS5lcXVhbHMyRCh0KSYmKHI9bCxvPTApfXRoaXMuZWlMaXN0LmFkZChpLHIsbyl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyBfdDt0LmFwcGVuZChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpLHQuYXBwZW5kKFwiTElORVNUUklORyAoXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQuYXBwZW5kKFwiLFwiKSx0LmFwcGVuZCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3JldHVybiB0LmFwcGVuZChcIikgIFwiK3RoaXMuX2xhYmVsK1wiIFwiK3RoaXMuX2RlcHRoRGVsdGEpLHQudG9TdHJpbmcoKX1pc1BvaW50d2lzZUVxdWFsKHQpe2lmKHRoaXMucHRzLmxlbmd0aCE9PXQucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspaWYoIXRoaXMucHRzW2VdLmVxdWFsczJEKHQucHRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH1zZXREZXB0aERlbHRhKHQpe3RoaXMuX2RlcHRoRGVsdGE9dH1nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpe3JldHVybiB0aGlzLmVpTGlzdH1hZGRJbnRlcnNlY3Rpb25zKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLHMpfX1jbGFzcyB0cyBleHRlbmRzIEpue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb29yZD1udWxsLHRoaXMuX2VkZ2VzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmQ9dCx0aGlzLl9lZGdlcz1lLHRoaXMuX2xhYmVsPW5ldyBxbigwLFF0Lk5PTkUpfWlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKXtmb3IobGV0IHQ9dGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2lmKHQubmV4dCgpLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpcmV0dXJuITB9cmV0dXJuITF9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fY29vcmR9cHJpbnQodCl7dC5wcmludGxuKFwibm9kZSBcIit0aGlzLl9jb29yZCtcIiBsYmw6IFwiK3RoaXMuX2xhYmVsKX1jb21wdXRlSU0odCl7fWNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpe2xldCBuPVF0Lk5PTkU7aWYobj10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKSwhdC5pc051bGwoZSkpe2NvbnN0IHM9dC5nZXRMb2NhdGlvbihlKTtuIT09UXQuQk9VTkRBUlkmJihuPXMpfXJldHVybiBufXNldExhYmVsKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSl8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpcmV0dXJuIHN1cGVyLnNldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMuX2xhYmVsP3RoaXMuX2xhYmVsPW5ldyBxbih0LGUpOnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSl9fWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfW1lcmdlTGFiZWwoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHRzKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodC5fbGFiZWwpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxbil7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTwyO2UrKyl7Y29uc3Qgbj10aGlzLmNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpO3RoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUpPT09UXQuTk9ORSYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oZSxuKX19fWFkZCh0KXt0aGlzLl9lZGdlcy5pbnNlcnQodCksdC5zZXROb2RlKHRoaXMpfXNldExhYmVsQm91bmRhcnkodCl7aWYobnVsbD09PXRoaXMuX2xhYmVsKXJldHVybiBudWxsO2xldCBlPVF0Lk5PTkU7bnVsbCE9PXRoaXMuX2xhYmVsJiYoZT10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbih0KSk7bGV0IG49bnVsbDtzd2l0Y2goZSl7Y2FzZSBRdC5CT1VOREFSWTpuPVF0LklOVEVSSU9SO2JyZWFrO2Nhc2UgUXQuSU5URVJJT1I6ZGVmYXVsdDpuPVF0LkJPVU5EQVJZfXRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsbil9fWNsYXNzIGVze2NvbnN0cnVjdG9yKCl7ZXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5ub2RlTWFwPW5ldyBIbix0aGlzLm5vZGVGYWN0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlRmFjdD10fWZpbmQodCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9YWRkTm9kZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9dGhpcy5ub2RlTWFwLmdldCh0KTtyZXR1cm4gbnVsbD09PWUmJihlPXRoaXMubm9kZUZhY3QuY3JlYXRlTm9kZSh0KSx0aGlzLm5vZGVNYXAucHV0KHQsZSkpLGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB0cyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLm5vZGVNYXAuZ2V0KHQuZ2V0Q29vcmRpbmF0ZSgpKTtyZXR1cm4gbnVsbD09PWU/KHRoaXMubm9kZU1hcC5wdXQodC5nZXRDb29yZGluYXRlKCksdCksdCk6KGUubWVyZ2VMYWJlbCh0KSxlKX19cHJpbnQodCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX12YWx1ZXMoKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfWdldEJvdW5kYXJ5Tm9kZXModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk9PT1RdC5CT1VOREFSWSYmZS5hZGQocyl9cmV0dXJuIGV9YWRkKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlKCk7dGhpcy5hZGROb2RlKGUpLmFkZCh0KX19Y2xhc3MgbnN7Y29uc3RydWN0b3IoKXtucy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9lZGdlPW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9ub2RlPW51bGwsdGhpcy5fcDA9bnVsbCx0aGlzLl9wMT1udWxsLHRoaXMuX2R4PW51bGwsdGhpcy5fZHk9bnVsbCx0aGlzLl9xdWFkcmFudD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlPXR9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixudWxsKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtucy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuaW5pdChlLG4pLHRoaXMuX2xhYmVsPXN9fWNvbXBhcmVEaXJlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2R4PT09dC5fZHgmJnRoaXMuX2R5PT09dC5fZHk/MDp0aGlzLl9xdWFkcmFudD50Ll9xdWFkcmFudD8xOnRoaXMuX3F1YWRyYW50PHQuX3F1YWRyYW50Py0xOkcuaW5kZXgodC5fcDAsdC5fcDEsdGhpcy5fcDEpfWdldER5KCl7cmV0dXJuIHRoaXMuX2R5fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDB9c2V0Tm9kZSh0KXt0aGlzLl9ub2RlPXR9cHJpbnQodCl7Y29uc3QgZT1NYXRoLmF0YW4yKHRoaXMuX2R5LHRoaXMuX2R4KSxuPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkscz1uLmxhc3RJbmRleE9mKFwiLlwiKSxpPW4uc3Vic3RyaW5nKHMrMSk7dC5wcmludChcIiAgXCIraStcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIitlK1wiICAgXCIrdGhpcy5fbGFiZWwpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX1nZXREaXJlY3RlZENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDF9Z2V0RHgoKXtyZXR1cm4gdGhpcy5fZHh9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWdldFF1YWRyYW50KCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50fWdldE5vZGUoKXtyZXR1cm4gdGhpcy5fbm9kZX10b1N0cmluZygpe2NvbnN0IHQ9TWF0aC5hdGFuMih0aGlzLl9keSx0aGlzLl9keCksZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIik7cmV0dXJuXCIgIFwiK2Uuc3Vic3RyaW5nKG4rMSkrXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrdCtcIiAgIFwiK3RoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbCh0KXt9aW5pdCh0LGUpe3RoaXMuX3AwPXQsdGhpcy5fcDE9ZSx0aGlzLl9keD1lLngtdC54LHRoaXMuX2R5PWUueS10LnksdGhpcy5fcXVhZHJhbnQ9d24ucXVhZHJhbnQodGhpcy5fZHgsdGhpcy5fZHkpLGcuaXNUcnVlKCEoMD09PXRoaXMuX2R4JiYwPT09dGhpcy5fZHkpLFwiRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmRcIil9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBzcyBleHRlbmRzIGh7Y29uc3RydWN0b3IodCxlKXtzdXBlcihlP3QrXCIgWyBcIitlK1wiIF1cIjp0KSx0aGlzLnB0PWU/bmV3IG0oZSk6dm9pZCAwLHRoaXMubmFtZT1PYmplY3Qua2V5cyh7VG9wb2xvZ3lFeGNlcHRpb246c3N9KVswXX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMucHR9fWNsYXNzIGlzIGV4dGVuZHMgbnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLGlzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRm9yd2FyZD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbCx0aGlzLl9uZXh0TWluPW51bGwsdGhpcy5fZWRnZVJpbmc9bnVsbCx0aGlzLl9taW5FZGdlUmluZz1udWxsLHRoaXMuX2RlcHRoPVswLC05OTksLTk5OV07Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYobnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KSx0aGlzLl9pc0ZvcndhcmQ9ZSxlKXRoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUoMCksdC5nZXRDb29yZGluYXRlKDEpKTtlbHNle2NvbnN0IGU9dC5nZXROdW1Qb2ludHMoKS0xO3RoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUoZSksdC5nZXRDb29yZGluYXRlKGUtMSkpfXRoaXMuY29tcHV0ZURpcmVjdGVkTGFiZWwoKX1zdGF0aWMgZGVwdGhGYWN0b3IodCxlKXtyZXR1cm4gdD09PVF0LkVYVEVSSU9SJiZlPT09UXQuSU5URVJJT1I/MTp0PT09UXQuSU5URVJJT1ImJmU9PT1RdC5FWFRFUklPUj8tMTowfWdldE5leHRNaW4oKXtyZXR1cm4gdGhpcy5fbmV4dE1pbn1nZXREZXB0aCh0KXtyZXR1cm4gdGhpcy5fZGVwdGhbdF19c2V0VmlzaXRlZCh0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH1jb21wdXRlRGlyZWN0ZWRMYWJlbCgpe3RoaXMuX2xhYmVsPW5ldyBxbih0aGlzLl9lZGdlLmdldExhYmVsKCkpLHRoaXMuX2lzRm9yd2FyZHx8dGhpcy5fbGFiZWwuZmxpcCgpfWdldE5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1zZXREZXB0aCh0LGUpe2lmKC05OTkhPT10aGlzLl9kZXB0aFt0XSYmdGhpcy5fZGVwdGhbdF0hPT1lKXRocm93IG5ldyBzcyhcImFzc2lnbmVkIGRlcHRocyBkbyBub3QgbWF0Y2hcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7dGhpcy5fZGVwdGhbdF09ZX1pc0ludGVyaW9yQXJlYUVkZ2UoKXtsZXQgdD0hMDtmb3IobGV0IGU9MDtlPDI7ZSsrKXRoaXMuX2xhYmVsLmlzQXJlYShlKSYmdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSxNbi5MRUZUKT09PVF0LklOVEVSSU9SJiZ0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlLE1uLlJJR0hUKT09PVF0LklOVEVSSU9SfHwodD0hMSk7cmV0dXJuIHR9c2V0TmV4dE1pbih0KXt0aGlzLl9uZXh0TWluPXR9cHJpbnQodCl7c3VwZXIucHJpbnQuY2FsbCh0aGlzLHQpLHQucHJpbnQoXCIgXCIrdGhpcy5fZGVwdGhbTW4uTEVGVF0rXCIvXCIrdGhpcy5fZGVwdGhbTW4uUklHSFRdKSx0LnByaW50KFwiIChcIit0aGlzLmdldERlcHRoRGVsdGEoKStcIilcIiksdGhpcy5faXNJblJlc3VsdCYmdC5wcmludChcIiBpblJlc3VsdFwiKX1zZXRNaW5FZGdlUmluZyh0KXt0aGlzLl9taW5FZGdlUmluZz10fWlzTGluZUVkZ2UoKXtjb25zdCB0PXRoaXMuX2xhYmVsLmlzTGluZSgwKXx8dGhpcy5fbGFiZWwuaXNMaW5lKDEpLGU9IXRoaXMuX2xhYmVsLmlzQXJlYSgwKXx8dGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMCxRdC5FWFRFUklPUiksbj0hdGhpcy5fbGFiZWwuaXNBcmVhKDEpfHx0aGlzLl9sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgxLFF0LkVYVEVSSU9SKTtyZXR1cm4gdCYmZSYmbn1zZXRFZGdlUmluZyh0KXt0aGlzLl9lZGdlUmluZz10fWdldE1pbkVkZ2VSaW5nKCl7cmV0dXJuIHRoaXMuX21pbkVkZ2VSaW5nfWdldERlcHRoRGVsdGEoKXtsZXQgdD10aGlzLl9lZGdlLmdldERlcHRoRGVsdGEoKTtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfHwodD0tdCksdH1zZXRJblJlc3VsdCh0KXt0aGlzLl9pc0luUmVzdWx0PXR9Z2V0U3ltKCl7cmV0dXJuIHRoaXMuX3N5bX1pc0ZvcndhcmQoKXtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fZWRnZX1wcmludEVkZ2UodCl7dGhpcy5wcmludCh0KSx0LnByaW50KFwiIFwiKSx0aGlzLl9pc0ZvcndhcmQ/dGhpcy5fZWRnZS5wcmludCh0KTp0aGlzLl9lZGdlLnByaW50UmV2ZXJzZSh0KX1zZXRTeW0odCl7dGhpcy5fc3ltPXR9c2V0VmlzaXRlZEVkZ2UodCl7dGhpcy5zZXRWaXNpdGVkKHQpLHRoaXMuX3N5bS5zZXRWaXNpdGVkKHQpfXNldEVkZ2VEZXB0aHModCxlKXtsZXQgbj10aGlzLmdldEVkZ2UoKS5nZXREZXB0aERlbHRhKCk7dGhpcy5faXNGb3J3YXJkfHwobj0tbik7bGV0IHM9MTt0PT09TW4uTEVGVCYmKHM9LTEpO2NvbnN0IGk9TW4ub3Bwb3NpdGUodCkscj1lK24qczt0aGlzLnNldERlcHRoKHQsZSksdGhpcy5zZXREZXB0aChpLHIpfWdldEVkZ2VSaW5nKCl7cmV0dXJuIHRoaXMuX2VkZ2VSaW5nfWlzSW5SZXN1bHQoKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfX1jbGFzcyByc3tjcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgdHModCxudWxsKX19Y2xhc3Mgb3N7Y29uc3RydWN0b3IoKXtvcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9lZGdlcz1uZXcgTCx0aGlzLl9ub2Rlcz1udWxsLHRoaXMuX2VkZ2VFbmRMaXN0PW5ldyBMLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX25vZGVzPW5ldyBlcyhuZXcgcnMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25vZGVzPW5ldyBlcyh0KX19c3RhdGljIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fXByaW50RWRnZXModCl7dC5wcmludGxuKFwiRWRnZXM6XCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKyl7dC5wcmludGxuKFwiZWRnZSBcIitlK1wiOlwiKTtjb25zdCBuPXRoaXMuX2VkZ2VzLmdldChlKTtuLnByaW50KHQpLG4uZWlMaXN0LnByaW50KHQpfX1maW5kKHQpe3JldHVybiB0aGlzLl9ub2Rlcy5maW5kKHQpfWFkZE5vZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHRzKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKHQpfX1nZXROb2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKX1saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX1kZWJ1Z1ByaW50bG4odCl7Qi5vdXQucHJpbnRsbih0KX1pc0JvdW5kYXJ5Tm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fbm9kZXMuZmluZChlKTtpZihudWxsPT09bilyZXR1cm4hMTtjb25zdCBzPW4uZ2V0TGFiZWwoKTtyZXR1cm4gbnVsbCE9PXMmJnMuZ2V0TG9jYXRpb24odCk9PT1RdC5CT1VOREFSWX1saW5rQWxsRGlyZWN0ZWRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rQWxsRGlyZWN0ZWRFZGdlcygpfX1tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsbixzKXtyZXR1cm4hIXQuZXF1YWxzKG4pJiYoRy5pbmRleCh0LGUscyk9PT1HLkNPTExJTkVBUiYmd24ucXVhZHJhbnQodCxlKT09PXduLnF1YWRyYW50KG4scykpfWdldEVkZ2VFbmRzKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRMaXN0fWRlYnVnUHJpbnQodCl7Qi5vdXQucHJpbnQodCl9Z2V0RWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9ZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24odCxlKXtmb3IobGV0IG49MDtuPHRoaXMuX2VkZ2VzLnNpemUoKTtuKyspe2NvbnN0IHM9dGhpcy5fZWRnZXMuZ2V0KG4pLGk9cy5nZXRDb29yZGluYXRlcygpO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLGlbMF0saVsxXSkpcmV0dXJuIHM7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsaVtpLmxlbmd0aC0xXSxpW2kubGVuZ3RoLTJdKSlyZXR1cm4gc31yZXR1cm4gbnVsbH1pbnNlcnRFZGdlKHQpe3RoaXMuX2VkZ2VzLmFkZCh0KX1maW5kRWRnZUVuZCh0KXtmb3IobGV0IGU9dGhpcy5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4uZ2V0RWRnZSgpPT09dClyZXR1cm4gbn1yZXR1cm4gbnVsbH1hZGRFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9lZGdlcy5hZGQodCk7Y29uc3Qgbj1uZXcgaXModCwhMCkscz1uZXcgaXModCwhMSk7bi5zZXRTeW0ocykscy5zZXRTeW0obiksdGhpcy5hZGQobiksdGhpcy5hZGQocyl9fWFkZCh0KXt0aGlzLl9ub2Rlcy5hZGQodCksdGhpcy5fZWRnZUVuZExpc3QuYWRkKHQpfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzLnZhbHVlcygpfWZpbmRFZGdlKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLl9lZGdlcy5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuX2VkZ2VzLmdldChuKSxpPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0LmVxdWFscyhpWzBdKSYmZS5lcXVhbHMoaVsxXSkpcmV0dXJuIHN9cmV0dXJuIG51bGx9fWNsYXNzIGxzIGV4dGVuZHMgb3N7Y29uc3RydWN0b3IoKXtzdXBlcigpLGxzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3BhcmVudEdlb209bnVsbCx0aGlzLl9saW5lRWRnZU1hcD1uZXcgSXQsdGhpcy5fYm91bmRhcnlOb2RlUnVsZT1udWxsLHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITAsdGhpcy5fYXJnSW5kZXg9bnVsbCx0aGlzLl9ib3VuZGFyeU5vZGVzPW51bGwsdGhpcy5faGFzVG9vRmV3UG9pbnRzPSExLHRoaXMuX2ludmFsaWRQb2ludD1udWxsLHRoaXMuX2FyZWFQdExvY2F0b3I9bnVsbCx0aGlzLl9wdExvY2F0b3I9bmV3IGZuLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtscy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxnbi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2FyZ0luZGV4PXQsdGhpcy5fcGFyZW50R2VvbT1lLHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGU9bixudWxsIT09ZSYmdGhpcy5hZGQoZSl9fXN0YXRpYyBkZXRlcm1pbmVCb3VuZGFyeSh0LGUpe3JldHVybiB0LmlzSW5Cb3VuZGFyeShlKT9RdC5CT1VOREFSWTpRdC5JTlRFUklPUn1pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSl7Y29uc3Qgbj10aGlzLl9ub2Rlcy5hZGROb2RlKGUpLmdldExhYmVsKCk7bGV0IHM9MSxpPVF0Lk5PTkU7aT1uLmdldExvY2F0aW9uKHQsTW4uT04pLGk9PT1RdC5CT1VOREFSWSYmcysrO2NvbnN0IHI9bHMuZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5fYm91bmRhcnlOb2RlUnVsZSxzKTtuLnNldExvY2F0aW9uKHQscil9Y29tcHV0ZVNlbGZOb2Rlcygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wdXRlU2VsZk5vZGVzKHQsZSwhMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49bmV3IEFuKGFyZ3VtZW50c1swXSwhMCwhMSk7bi5zZXRJc0RvbmVJZlByb3BlckludChlKTtjb25zdCBzPXRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCksaT10aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgdXR8fHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBpdHx8dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIGZ0LHI9dHx8IWk7cmV0dXJuIHMuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsbixyKSx0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLl9hcmdJbmRleCksbn19Y29tcHV0ZVNwbGl0RWRnZXModCl7Zm9yKGxldCBlPXRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5laUxpc3QuYWRkU3BsaXRFZGdlcyh0KX19Y29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHQsZSxuKXtjb25zdCBzPW5ldyBBbihlLG4sITApO3Muc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSx0LmdldEJvdW5kYXJ5Tm9kZXMoKSk7cmV0dXJuIHRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCkuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsdC5fZWRnZXMscyksc31nZXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9wYXJlbnRHZW9tfWdldEJvdW5kYXJ5Tm9kZVJ1bGUoKXtyZXR1cm4gdGhpcy5fYm91bmRhcnlOb2RlUnVsZX1oYXNUb29GZXdQb2ludHMoKXtyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzfWFkZFBvaW50KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB0dCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxRdC5JTlRFUklPUil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxRdC5JTlRFUklPUil9fWFkZFBvbHlnb24odCl7dGhpcy5hZGRQb2x5Z29uUmluZyh0LmdldEV4dGVyaW9yUmluZygpLFF0LkVYVEVSSU9SLFF0LklOVEVSSU9SKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBuPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTt0aGlzLmFkZFBvbHlnb25SaW5nKG4sUXQuSU5URVJJT1IsUXQuRVhURVJJT1IpfX1hZGRFZGdlKHQpe3RoaXMuaW5zZXJ0RWRnZSh0KTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LGVbMF0sUXQuQk9VTkRBUlkpLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSxRdC5CT1VOREFSWSl9YWRkTGluZVN0cmluZyh0KXtjb25zdCBlPWR0LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuX2ludmFsaWRQb2ludD1lWzBdLG51bGw7Y29uc3Qgbj1uZXcgJG4oZSxuZXcgcW4odGhpcy5fYXJnSW5kZXgsUXQuSU5URVJJT1IpKTt0aGlzLl9saW5lRWRnZU1hcC5wdXQodCxuKSx0aGlzLmluc2VydEVkZ2UobiksZy5pc1RydWUoZS5sZW5ndGg+PTIsXCJmb3VuZCBMaW5lU3RyaW5nIHdpdGggc2luZ2xlIHBvaW50XCIpLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCxlWzBdKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSl9Z2V0SW52YWxpZFBvaW50KCl7cmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludH1nZXRCb3VuZGFyeVBvaW50cygpe2NvbnN0IHQ9dGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7bGV0IG49MDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtlW24rK109dC5nZXRDb29yZGluYXRlKCkuY29weSgpfXJldHVybiBlfWdldEJvdW5kYXJ5Tm9kZXMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2JvdW5kYXJ5Tm9kZXMmJih0aGlzLl9ib3VuZGFyeU5vZGVzPXRoaXMuX25vZGVzLmdldEJvdW5kYXJ5Tm9kZXModGhpcy5fYXJnSW5kZXgpKSx0aGlzLl9ib3VuZGFyeU5vZGVzfWFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQsZSxuKXtpZih0aGlzLmlzQm91bmRhcnlOb2RlKHQsZSkpcmV0dXJuIG51bGw7bj09PVF0LkJPVU5EQVJZJiZ0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlP3RoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpOnRoaXMuaW5zZXJ0UG9pbnQodCxlLG4pfWFkZFBvbHlnb25SaW5nKHQsZSxuKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBzPWR0LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYocy5sZW5ndGg8NClyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuX2ludmFsaWRQb2ludD1zWzBdLG51bGw7bGV0IGk9ZSxyPW47Ry5pc0NDVyhzKSYmKGk9bixyPWUpO2NvbnN0IG89bmV3ICRuKHMsbmV3IHFuKHRoaXMuX2FyZ0luZGV4LFF0LkJPVU5EQVJZLGkscikpO3RoaXMuX2xpbmVFZGdlTWFwLnB1dCh0LG8pLHRoaXMuaW5zZXJ0RWRnZShvKSx0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LHNbMF0sUXQuQk9VTkRBUlkpfWluc2VydFBvaW50KHQsZSxuKXtjb25zdCBzPXRoaXMuX25vZGVzLmFkZE5vZGUoZSksaT1zLmdldExhYmVsKCk7bnVsbD09PWk/cy5fbGFiZWw9bmV3IHFuKHQsbik6aS5zZXRMb2NhdGlvbih0LG4pfWNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3Rvcigpe3JldHVybiBuZXcgRm59YWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5laUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSh0LG4uY29vcmQscyl9fX1hZGQoKXtpZighKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpKXJldHVybiBzdXBlci5hZGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgZnQmJih0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSExKSx0IGluc3RhbmNlb2YgaXQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEopdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHR0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHd0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBjdCkpdGhyb3cgbmV3IGoodC5nZXRHZW9tZXRyeVR5cGUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX19YWRkQ29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19bG9jYXRlKHQpe3JldHVybiBJKHRoaXMuX3BhcmVudEdlb20sc3QpJiZ0aGlzLl9wYXJlbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKT41MD8obnVsbD09PXRoaXMuX2FyZWFQdExvY2F0b3ImJih0aGlzLl9hcmVhUHRMb2NhdG9yPW5ldyB6ZSh0aGlzLl9wYXJlbnRHZW9tKSksdGhpcy5fYXJlYVB0TG9jYXRvci5sb2NhdGUodCkpOnRoaXMuX3B0TG9jYXRvci5sb2NhdGUodCx0aGlzLl9wYXJlbnRHZW9tKX1maW5kRWRnZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEope2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9saW5lRWRnZU1hcC5nZXQodCl9cmV0dXJuIHN1cGVyLmZpbmRFZGdlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIGFzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5R3JhcGg6bHN9KTtjbGFzcyBjc3t2aXNpdCh0KXt9fWNsYXNzIGhze2NvbnN0cnVjdG9yKCl7aHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcD1udWxsLHRoaXMuX2RhdGE9bnVsbCx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPW5ldyBtKHQpLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PTEsdGhpcy5fZGF0YT1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3A9bmV3IG0odCxlKSx0aGlzLl9sZWZ0PW51bGwsdGhpcy5fcmlnaHQ9bnVsbCx0aGlzLl9jb3VudD0xLHRoaXMuX2RhdGE9bn19aXNSZXBlYXRlZCgpe3JldHVybiB0aGlzLl9jb3VudD4xfWdldFJpZ2h0KCl7cmV0dXJuIHRoaXMuX3JpZ2h0fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcH1zZXRMZWZ0KHQpe3RoaXMuX2xlZnQ9dH1nZXRYKCl7cmV0dXJuIHRoaXMuX3AueH1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fY291bnR9Z2V0TGVmdCgpe3JldHVybiB0aGlzLl9sZWZ0fWdldFkoKXtyZXR1cm4gdGhpcy5fcC55fWluY3JlbWVudCgpe3RoaXMuX2NvdW50PXRoaXMuX2NvdW50KzF9c2V0UmlnaHQodCl7dGhpcy5fcmlnaHQ9dH19Y2xhc3MgdXN7Y29uc3RydWN0b3IoKXt1cy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9yb290PW51bGwsdGhpcy5fbnVtYmVyT2ZOb2Rlcz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXVzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fdG9sZXJhbmNlPXR9fXN0YXRpYyB0b0Nvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB1cy50b0Nvb3JkaW5hdGVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBSO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9ZT90LmdldENvdW50KCk6MTtmb3IobGV0IGU9MDtlPGk7ZSsrKW4uYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpLCEwKX1yZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfX1pbnNlcnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5zZXJ0KHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKG51bGw9PT10aGlzLl9yb290KXJldHVybiB0aGlzLl9yb290PW5ldyBocyh0LGUpLHRoaXMuX3Jvb3Q7aWYodGhpcy5fdG9sZXJhbmNlPjApe2NvbnN0IGU9dGhpcy5maW5kQmVzdE1hdGNoTm9kZSh0KTtpZihudWxsIT09ZSlyZXR1cm4gZS5pbmNyZW1lbnQoKSxlfXJldHVybiB0aGlzLmluc2VydEV4YWN0KHQsZSl9fXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEw7cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyYmSShhcmd1bWVudHNbMV0sdykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMuX3Jvb3QsdCwhMCxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NzXX12aXNpdCh0KXtlLmFkZCh0KX19KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTyYmSShhcmd1bWVudHNbMV0sY3MpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLl9yb290LHQsITAsZSl9fXF1ZXJ5Tm9kZSh0LGUsbixzKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtsZXQgaT1udWxsLHI9bnVsbCxvPW51bGw7bj8oaT1lLmdldE1pblgoKSxyPWUuZ2V0TWF4WCgpLG89dC5nZXRYKCkpOihpPWUuZ2V0TWluWSgpLHI9ZS5nZXRNYXhZKCksbz10LmdldFkoKSk7Y29uc3QgbD1vPD1yO2k8byYmdGhpcy5xdWVyeU5vZGUodC5nZXRMZWZ0KCksZSwhbixzKSxlLmNvbnRhaW5zKHQuZ2V0Q29vcmRpbmF0ZSgpKSYmcy52aXNpdCh0KSxsJiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldFJpZ2h0KCksZSwhbixzKX1maW5kQmVzdE1hdGNoTm9kZSh0KXtjb25zdCBlPW5ldyBncyh0LHRoaXMuX3RvbGVyYW5jZSk7cmV0dXJuIHRoaXMucXVlcnkoZS5xdWVyeUVudmVsb3BlKCksZSksZS5nZXROb2RlKCl9aXNFbXB0eSgpe3JldHVybiBudWxsPT09dGhpcy5fcm9vdH1pbnNlcnRFeGFjdCh0LGUpe2xldCBuPXRoaXMuX3Jvb3Qscz10aGlzLl9yb290LGk9ITAscj0hMDtmb3IoO251bGwhPT1uOyl7aWYobnVsbCE9PW4pe2lmKHQuZGlzdGFuY2Uobi5nZXRDb29yZGluYXRlKCkpPD10aGlzLl90b2xlcmFuY2UpcmV0dXJuIG4uaW5jcmVtZW50KCksbn1yPWk/dC54PG4uZ2V0WCgpOnQueTxuLmdldFkoKSxzPW4sbj1yP24uZ2V0TGVmdCgpOm4uZ2V0UmlnaHQoKSxpPSFpfXRoaXMuX251bWJlck9mTm9kZXM9dGhpcy5fbnVtYmVyT2ZOb2RlcysxO2NvbnN0IG89bmV3IGhzKHQsZSk7cmV0dXJuIHI/cy5zZXRMZWZ0KG8pOnMuc2V0UmlnaHQobyksb319Y2xhc3MgZ3N7Y29uc3RydWN0b3IoKXtncy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90b2xlcmFuY2U9bnVsbCx0aGlzLl9tYXRjaE5vZGU9bnVsbCx0aGlzLl9tYXRjaERpc3Q9MCx0aGlzLl9wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD10LHRoaXMuX3RvbGVyYW5jZT1lfXZpc2l0KHQpe2NvbnN0IGU9dGhpcy5fcC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSk7aWYoIShlPD10aGlzLl90b2xlcmFuY2UpKXJldHVybiBudWxsO2xldCBuPSExOyhudWxsPT09dGhpcy5fbWF0Y2hOb2RlfHxlPHRoaXMuX21hdGNoRGlzdHx8bnVsbCE9PXRoaXMuX21hdGNoTm9kZSYmZT09PXRoaXMuX21hdGNoRGlzdCYmdC5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuX21hdGNoTm9kZS5nZXRDb29yZGluYXRlKCkpPDEpJiYobj0hMCksbiYmKHRoaXMuX21hdGNoTm9kZT10LHRoaXMuX21hdGNoRGlzdD1lKX1xdWVyeUVudmVsb3BlKCl7Y29uc3QgdD1uZXcgTyh0aGlzLl9wKTtyZXR1cm4gdC5leHBhbmRCeSh0aGlzLl90b2xlcmFuY2UpLHR9Z2V0Tm9kZSgpe3JldHVybiB0aGlzLl9tYXRjaE5vZGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NzXX19dXMuQmVzdE1hdGNoVmlzaXRvcj1nczt2YXIgZHM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsS2RUcmVlOnVzfSk7Y2xhc3MgX3N7Y29uc3RydWN0b3IoKXtfcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pdGVtcz1uZXcgTCx0aGlzLl9zdWJub2RlPW5ldyBBcnJheSg0KS5maWxsKG51bGwpfXN0YXRpYyBnZXRTdWJub2RlSW5kZXgodCxlLG4pe2xldCBzPS0xO3JldHVybiB0LmdldE1pblgoKT49ZSYmKHQuZ2V0TWluWSgpPj1uJiYocz0zKSx0LmdldE1heFkoKTw9biYmKHM9MSkpLHQuZ2V0TWF4WCgpPD1lJiYodC5nZXRNaW5ZKCk+PW4mJihzPTIpLHQuZ2V0TWF4WSgpPD1uJiYocz0wKSksc31oYXNDaGlsZHJlbigpe2ZvcihsZXQgdD0wO3Q8NDt0KyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbdF0pcmV0dXJuITA7cmV0dXJuITF9aXNQcnVuYWJsZSgpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfWFkZEFsbEl0ZW1zKHQpe3QuYWRkQWxsKHRoaXMuX2l0ZW1zKTtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiZ0aGlzLl9zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fWdldE5vZGVDb3VudCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmKHQrPXRoaXMuX3N1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCsxfXNpemUoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJih0Kz10aGlzLl9zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5faXRlbXMuc2l6ZSgpfWFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDtlLmFkZEFsbCh0aGlzLl9pdGVtcyk7Zm9yKGxldCBuPTA7bjw0O24rKyludWxsIT09dGhpcy5fc3Vibm9kZVtuXSYmdGhpcy5fc3Vibm9kZVtuXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpfXZpc2l0SXRlbXModCxlKXtmb3IobGV0IHQ9dGhpcy5faXRlbXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspZS52aXNpdEl0ZW0odC5uZXh0KCkpfWhhc0l0ZW1zKCl7cmV0dXJuIXRoaXMuX2l0ZW1zLmlzRW1wdHkoKX1yZW1vdmUodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2xldCBuPSExO2ZvcihsZXQgcz0wO3M8NDtzKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbc10mJihuPXRoaXMuX3N1Ym5vZGVbc10ucmVtb3ZlKHQsZSksbikpe3RoaXMuX3N1Ym5vZGVbc10uaXNQcnVuYWJsZSgpJiYodGhpcy5fc3Vibm9kZVtzXT1udWxsKTticmVha31yZXR1cm4gbnx8KG49dGhpcy5faXRlbXMucmVtb3ZlKGUpLG4pfXZpc2l0KHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDt0aGlzLnZpc2l0SXRlbXModCxlKTtmb3IobGV0IG49MDtuPDQ7bisrKW51bGwhPT10aGlzLl9zdWJub2RlW25dJiZ0aGlzLl9zdWJub2RlW25dLnZpc2l0KHQsZSl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9ZGVwdGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0pe2NvbnN0IG49dGhpcy5fc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX1pc0VtcHR5KCl7bGV0IHQ9ITA7aWYodGhpcy5faXRlbXMuaXNFbXB0eSgpKXtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYhdGhpcy5fc3Vibm9kZVtlXS5pc0VtcHR5KCkpe3Q9ITE7YnJlYWt9fWVsc2UgdD0hMTtyZXR1cm4gdH1hZGQodCl7dGhpcy5faXRlbXMuYWRkKHQpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltjXX19ZnVuY3Rpb24gcHMoKXt9cHMuZXhwb25lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7bGV0IG4scyxpLHI7Y29uc3Qgbz17MzI6e2Q6MTI3LGM6MTI4LGI6MCxhOjB9LDY0OntkOjMyNzUyLGM6MCxiOjAsYTowfX0sbD17MzI6OCw2NDoxMX1bdF07cnx8KG49ZTwwfHwxL2U8MCxpc0Zpbml0ZShlKXx8KHI9b1t0XSxuJiYoci5kKz0xPDx0LzQtMSkscz1NYXRoLnBvdygyLGwpLTEsaT0wKSk7aWYoIXIpe2ZvcihzPXszMjoxMjcsNjQ6MTAyM31bdF0saT1NYXRoLmFicyhlKTtpPj0yOylzKyssaS89Mjtmb3IoO2k8MSYmcz4wOylzLS0saSo9MjtzPD0wJiYoaS89MiksMzI9PT10JiZzPjI1NCYmKHI9e2Q6bj8yNTU6MTI3LGM6MTI4LGI6MCxhOjB9LHM9TWF0aC5wb3coMixsKS0xLGk9MCl9cmV0dXJuIHN9KDY0LHQpLTEwMjN9LHBzLnBvd2VyT2YyPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQpfTtjbGFzcyBtc3tjb25zdHJ1Y3Rvcigpe21zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3B0PW5ldyBtLHRoaXMuX2xldmVsPTAsdGhpcy5fZW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfXN0YXRpYyBjb21wdXRlUXVhZExldmVsKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKSxzPWU+bj9lOm47cmV0dXJuIHBzLmV4cG9uZW50KHMpKzF9Z2V0TGV2ZWwoKXtyZXR1cm4gdGhpcy5fbGV2ZWx9Y29tcHV0ZUtleSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IodGhpcy5fbGV2ZWw9bXMuY29tcHV0ZVF1YWRMZXZlbCh0KSx0aGlzLl9lbnY9bmV3IE8sdGhpcy5jb21wdXRlS2V5KHRoaXMuX2xldmVsLHQpOyF0aGlzLl9lbnYuY29udGFpbnModCk7KXRoaXMuX2xldmVsKz0xLHRoaXMuY29tcHV0ZUtleSh0aGlzLl9sZXZlbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXBzLnBvd2VyT2YyKHQpO3RoaXMuX3B0Lng9TWF0aC5mbG9vcihlLmdldE1pblgoKS9uKSpuLHRoaXMuX3B0Lnk9TWF0aC5mbG9vcihlLmdldE1pblkoKS9uKSpuLHRoaXMuX2Vudi5pbml0KHRoaXMuX3B0LngsdGhpcy5fcHQueCtuLHRoaXMuX3B0LnksdGhpcy5fcHQueStuKX19Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5fZW52fWdldENlbnRyZSgpe3JldHVybiBuZXcgbSgodGhpcy5fZW52LmdldE1pblgoKSt0aGlzLl9lbnYuZ2V0TWF4WCgpKS8yLCh0aGlzLl9lbnYuZ2V0TWluWSgpK3RoaXMuX2Vudi5nZXRNYXhZKCkpLzIpfWdldFBvaW50KCl7cmV0dXJuIHRoaXMuX3B0fX1jbGFzcyBmcyBleHRlbmRzIF9ze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxmcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lbnY9bnVsbCx0aGlzLl9jZW50cmV4PW51bGwsdGhpcy5fY2VudHJleT1udWxsLHRoaXMuX2xldmVsPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZW52PXQsdGhpcy5fbGV2ZWw9ZSx0aGlzLl9jZW50cmV4PSh0LmdldE1pblgoKSt0LmdldE1heFgoKSkvMix0aGlzLl9jZW50cmV5PSh0LmdldE1pblkoKSt0LmdldE1heFkoKSkvMn1zdGF0aWMgY3JlYXRlTm9kZSh0KXtjb25zdCBlPW5ldyBtcyh0KTtyZXR1cm4gbmV3IGZzKGUuZ2V0RW52ZWxvcGUoKSxlLmdldExldmVsKCkpfXN0YXRpYyBjcmVhdGVFeHBhbmRlZCh0LGUpe2NvbnN0IG49bmV3IE8oZSk7bnVsbCE9PXQmJm4uZXhwYW5kVG9JbmNsdWRlKHQuX2Vudik7Y29uc3Qgcz1mcy5jcmVhdGVOb2RlKG4pO3JldHVybiBudWxsIT09dCYmcy5pbnNlcnROb2RlKHQpLHN9ZmluZCh0KXtjb25zdCBlPV9zLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdKXtyZXR1cm4gdGhpcy5fc3Vibm9kZVtlXS5maW5kKHQpfXJldHVybiB0aGlzfWlzU2VhcmNoTWF0Y2godCl7cmV0dXJuIG51bGwhPT10JiZ0aGlzLl9lbnYuaW50ZXJzZWN0cyh0KX1nZXRTdWJub2RlKHQpe3JldHVybiBudWxsPT09dGhpcy5fc3Vibm9kZVt0XSYmKHRoaXMuX3N1Ym5vZGVbdF09dGhpcy5jcmVhdGVTdWJub2RlKHQpKSx0aGlzLl9zdWJub2RlW3RdfWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuX2Vudn1nZXROb2RlKHQpe2NvbnN0IGU9X3MuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZigtMSE9PWUpe3JldHVybiB0aGlzLmdldFN1Ym5vZGUoZSkuZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc31jcmVhdGVTdWJub2RlKHQpe2xldCBlPTAsbj0wLHM9MCxpPTA7c3dpdGNoKHQpe2Nhc2UgMDplPXRoaXMuX2Vudi5nZXRNaW5YKCksbj10aGlzLl9jZW50cmV4LHM9dGhpcy5fZW52LmdldE1pblkoKSxpPXRoaXMuX2NlbnRyZXk7YnJlYWs7Y2FzZSAxOmU9dGhpcy5fY2VudHJleCxuPXRoaXMuX2Vudi5nZXRNYXhYKCkscz10aGlzLl9lbnYuZ2V0TWluWSgpLGk9dGhpcy5fY2VudHJleTticmVhaztjYXNlIDI6ZT10aGlzLl9lbnYuZ2V0TWluWCgpLG49dGhpcy5fY2VudHJleCxzPXRoaXMuX2NlbnRyZXksaT10aGlzLl9lbnYuZ2V0TWF4WSgpO2JyZWFrO2Nhc2UgMzplPXRoaXMuX2NlbnRyZXgsbj10aGlzLl9lbnYuZ2V0TWF4WCgpLHM9dGhpcy5fY2VudHJleSxpPXRoaXMuX2Vudi5nZXRNYXhZKCl9Y29uc3Qgcj1uZXcgTyhlLG4scyxpKTtyZXR1cm4gbmV3IGZzKHIsdGhpcy5fbGV2ZWwtMSl9aW5zZXJ0Tm9kZSh0KXtnLmlzVHJ1ZShudWxsPT09dGhpcy5fZW52fHx0aGlzLl9lbnYuY29udGFpbnModC5fZW52KSk7Y29uc3QgZT1fcy5nZXRTdWJub2RlSW5kZXgodC5fZW52LHRoaXMuX2NlbnRyZXgsdGhpcy5fY2VudHJleSk7aWYodC5fbGV2ZWw9PT10aGlzLl9sZXZlbC0xKXRoaXMuX3N1Ym5vZGVbZV09dDtlbHNle2NvbnN0IG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0Tm9kZSh0KSx0aGlzLl9zdWJub2RlW2VdPW59fX1jbGFzcyB5c3tzdGF0aWMgaXNaZXJvV2lkdGgodCxlKXtjb25zdCBuPWUtdDtpZigwPT09bilyZXR1cm4hMDtjb25zdCBzPW4vTWF0aC5tYXgoTWF0aC5hYnModCksTWF0aC5hYnMoZSkpO3JldHVybiBwcy5leHBvbmVudChzKTw9eXMuTUlOX0JJTkFSWV9FWFBPTkVOVH19eXMuTUlOX0JJTkFSWV9FWFBPTkVOVD0tNTA7Y2xhc3MgeHMgZXh0ZW5kcyBfc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9aW5zZXJ0KHQsZSl7Y29uc3Qgbj1fcy5nZXRTdWJub2RlSW5kZXgodCx4cy5vcmlnaW4ueCx4cy5vcmlnaW4ueSk7aWYoLTE9PT1uKXJldHVybiB0aGlzLmFkZChlKSxudWxsO2NvbnN0IHM9dGhpcy5fc3Vibm9kZVtuXTtpZihudWxsPT09c3x8IXMuZ2V0RW52ZWxvcGUoKS5jb250YWlucyh0KSl7Y29uc3QgZT1mcy5jcmVhdGVFeHBhbmRlZChzLHQpO3RoaXMuX3N1Ym5vZGVbbl09ZX10aGlzLmluc2VydENvbnRhaW5lZCh0aGlzLl9zdWJub2RlW25dLHQsZSl9aXNTZWFyY2hNYXRjaCh0KXtyZXR1cm4hMH1pbnNlcnRDb250YWluZWQodCxlLG4pe2cuaXNUcnVlKHQuZ2V0RW52ZWxvcGUoKS5jb250YWlucyhlKSk7Y29uc3Qgcz15cy5pc1plcm9XaWR0aChlLmdldE1pblgoKSxlLmdldE1heFgoKSksaT15cy5pc1plcm9XaWR0aChlLmdldE1pblkoKSxlLmdldE1heFkoKSk7bGV0IHI9bnVsbDtyPXN8fGk/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxyLmFkZChuKX19eHMub3JpZ2luPW5ldyBtKDAsMCk7Y2xhc3MgRXN7aW5zZXJ0KHQsZSl7fXJlbW92ZSh0LGUpe31xdWVyeSgpe319Y2xhc3MgSXN7Y29uc3RydWN0b3IoKXtJcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yb290PW51bGwsdGhpcy5fbWluRXh0ZW50PTEsdGhpcy5fcm9vdD1uZXcgeHN9c3RhdGljIGVuc3VyZUV4dGVudCh0LGUpe2xldCBuPXQuZ2V0TWluWCgpLHM9dC5nZXRNYXhYKCksaT10LmdldE1pblkoKSxyPXQuZ2V0TWF4WSgpO3JldHVybiBuIT09cyYmaSE9PXI/dDoobj09PXMmJihuLT1lLzIscys9ZS8yKSxpPT09ciYmKGktPWUvMixyKz1lLzIpLG5ldyBPKG4scyxpLHIpKX1zaXplKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb290P3RoaXMuX3Jvb3Quc2l6ZSgpOjB9aW5zZXJ0KHQsZSl7dGhpcy5jb2xsZWN0U3RhdHModCk7Y29uc3Qgbj1Jcy5lbnN1cmVFeHRlbnQodCx0aGlzLl9taW5FeHRlbnQpO3RoaXMuX3Jvb3QuaW5zZXJ0KG4sZSl9cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgWWU7cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlLmdldEl0ZW1zKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3Jvb3QudmlzaXQodCxlKX19cXVlcnlBbGwoKXtjb25zdCB0PW5ldyBMO3JldHVybiB0aGlzLl9yb290LmFkZEFsbEl0ZW1zKHQpLHR9cmVtb3ZlKHQsZSl7Y29uc3Qgbj1Jcy5lbnN1cmVFeHRlbnQodCx0aGlzLl9taW5FeHRlbnQpO3JldHVybiB0aGlzLl9yb290LnJlbW92ZShuLGUpfWNvbGxlY3RTdGF0cyh0KXtjb25zdCBlPXQuZ2V0V2lkdGgoKTtlPHRoaXMuX21pbkV4dGVudCYmZT4wJiYodGhpcy5fbWluRXh0ZW50PWUpO2NvbnN0IG49dC5nZXRIZWlnaHQoKTtuPHRoaXMuX21pbkV4dGVudCYmbj4wJiYodGhpcy5fbWluRXh0ZW50PW4pfWRlcHRoKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb290P3RoaXMuX3Jvb3QuZGVwdGgoKTowfWlzRW1wdHkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Jvb3R8fHRoaXMuX3Jvb3QuaXNFbXB0eSgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltFcyxjXX19dmFyIE5zPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFF1YWR0cmVlOklzfSk7Y2xhc3MgU3N7Z2V0Qm91bmRzKCl7fX1jbGFzcyB3c3tjb25zdHJ1Y3Rvcigpe3dzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2JvdW5kcz1udWxsLHRoaXMuX2l0ZW09bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ib3VuZHM9dCx0aGlzLl9pdGVtPWV9Z2V0SXRlbSgpe3JldHVybiB0aGlzLl9pdGVtfWdldEJvdW5kcygpe3JldHVybiB0aGlzLl9ib3VuZHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1NzLGNdfX1jbGFzcyBDc3tjb25zdHJ1Y3Rvcigpe0NzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpemU9bnVsbCx0aGlzLl9pdGVtcz1udWxsLHRoaXMuX3NpemU9MCx0aGlzLl9pdGVtcz1uZXcgTCx0aGlzLl9pdGVtcy5hZGQobnVsbCl9cG9sbCgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5faXRlbXMuZ2V0KDEpO3JldHVybiB0aGlzLl9pdGVtcy5zZXQoMSx0aGlzLl9pdGVtcy5nZXQodGhpcy5fc2l6ZSkpLHRoaXMuX3NpemUtPTEsdGhpcy5yZW9yZGVyKDEpLHR9c2l6ZSgpe3JldHVybiB0aGlzLl9zaXplfXJlb3JkZXIodCl7bGV0IGU9bnVsbDtjb25zdCBuPXRoaXMuX2l0ZW1zLmdldCh0KTtmb3IoOzIqdDw9dGhpcy5fc2l6ZSYmKGU9Mip0LGUhPT10aGlzLl9zaXplJiZ0aGlzLl9pdGVtcy5nZXQoZSsxKS5jb21wYXJlVG8odGhpcy5faXRlbXMuZ2V0KGUpKTwwJiZlKyssdGhpcy5faXRlbXMuZ2V0KGUpLmNvbXBhcmVUbyhuKTwwKTt0PWUpdGhpcy5faXRlbXMuc2V0KHQsdGhpcy5faXRlbXMuZ2V0KGUpKTt0aGlzLl9pdGVtcy5zZXQodCxuKX1jbGVhcigpe3RoaXMuX3NpemU9MCx0aGlzLl9pdGVtcy5jbGVhcigpfXBlZWsoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtyZXR1cm4gdGhpcy5faXRlbXMuZ2V0KDEpfWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX3NpemV9YWRkKHQpe3RoaXMuX2l0ZW1zLmFkZChudWxsKSx0aGlzLl9zaXplKz0xO2xldCBlPXRoaXMuX3NpemU7Zm9yKHRoaXMuX2l0ZW1zLnNldCgwLHQpO3QuY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTwwO2UvPTIpdGhpcy5faXRlbXMuc2V0KGUsdGhpcy5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoZS8yKSkpO3RoaXMuX2l0ZW1zLnNldChlLHQpfX1jbGFzcyBMc3tjb25zdHJ1Y3Rvcigpe0xzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2NoaWxkQm91bmRhYmxlcz1uZXcgTCx0aGlzLl9ib3VuZHM9bnVsbCx0aGlzLl9sZXZlbD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sZXZlbD10fX1nZXRMZXZlbCgpe3JldHVybiB0aGlzLl9sZXZlbH1zaXplKCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5zaXplKCl9Z2V0Q2hpbGRCb3VuZGFibGVzKCl7cmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlc31hZGRDaGlsZEJvdW5kYWJsZSh0KXtnLmlzVHJ1ZShudWxsPT09dGhpcy5fYm91bmRzKSx0aGlzLl9jaGlsZEJvdW5kYWJsZXMuYWRkKHQpfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKX1nZXRCb3VuZHMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2JvdW5kcyYmKHRoaXMuX2JvdW5kcz10aGlzLmNvbXB1dGVCb3VuZHMoKSksdGhpcy5fYm91bmRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltTcyxjXX19Y2xhc3MgVHN7c3RhdGljIG1heERpc3RhbmNlKHQsZSxuLHMsaSxyLG8sbCl7bGV0IGE9VHMuZGlzdGFuY2UodCxlLGkscik7cmV0dXJuIGE9TWF0aC5tYXgoYSxUcy5kaXN0YW5jZSh0LGUsbyxsKSksYT1NYXRoLm1heChhLFRzLmRpc3RhbmNlKG4scyxpLHIpKSxhPU1hdGgubWF4KGEsVHMuZGlzdGFuY2UobixzLG8sbCkpLGF9c3RhdGljIGRpc3RhbmNlKHQsZSxuLHMpe2NvbnN0IGk9bi10LHI9cy1lO3JldHVybiBNYXRoLnNxcnQoaSppK3Iqcil9c3RhdGljIG1heGltdW1EaXN0YW5jZSh0LGUpe2NvbnN0IG49TWF0aC5taW4odC5nZXRNaW5YKCksZS5nZXRNaW5YKCkpLHM9TWF0aC5taW4odC5nZXRNaW5ZKCksZS5nZXRNaW5ZKCkpLGk9TWF0aC5tYXgodC5nZXRNYXhYKCksZS5nZXRNYXhYKCkpLHI9TWF0aC5tYXgodC5nZXRNYXhZKCksZS5nZXRNYXhZKCkpO3JldHVybiBUcy5kaXN0YW5jZShuLHMsaSxyKX1zdGF0aWMgbWluTWF4RGlzdGFuY2UodCxlKXtjb25zdCBuPXQuZ2V0TWluWCgpLHM9dC5nZXRNaW5ZKCksaT10LmdldE1heFgoKSxyPXQuZ2V0TWF4WSgpLG89ZS5nZXRNaW5YKCksbD1lLmdldE1pblkoKSxhPWUuZ2V0TWF4WCgpLGM9ZS5nZXRNYXhZKCk7bGV0IGg9VHMubWF4RGlzdGFuY2UobixzLG4scixvLGwsbyxjKTtyZXR1cm4gaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKG4scyxuLHIsbyxsLGEsbCkpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShuLHMsbixyLGEsYyxvLGMpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UobixzLG4scixhLGMsYSxsKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKG4scyxpLHMsbyxsLG8sYykpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShuLHMsaSxzLG8sbCxhLGwpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UobixzLGkscyxhLGMsbyxjKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKG4scyxpLHMsYSxjLGEsbCkpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShpLHIsbixyLG8sbCxvLGMpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UoaSxyLG4scixvLGwsYSxsKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKGkscixuLHIsYSxjLG8sYykpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShpLHIsbixyLGEsYyxhLGwpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UoaSxyLGkscyxvLGwsbyxjKSksaD1NYXRoLm1pbihoLFRzLm1heERpc3RhbmNlKGkscixpLHMsbyxsLGEsbCkpLGg9TWF0aC5taW4oaCxUcy5tYXhEaXN0YW5jZShpLHIsaSxzLGEsYyxvLGMpKSxoPU1hdGgubWluKGgsVHMubWF4RGlzdGFuY2UoaSxyLGkscyxhLGMsYSxsKSksaH19Y2xhc3MgUnN7Y29uc3RydWN0b3IoKXtScy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ib3VuZGFibGUxPW51bGwsdGhpcy5fYm91bmRhYmxlMj1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5faXRlbURpc3RhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fYm91bmRhYmxlMT10LHRoaXMuX2JvdW5kYWJsZTI9ZSx0aGlzLl9pdGVtRGlzdGFuY2U9bix0aGlzLl9kaXN0YW5jZT10aGlzLmRpc3RhbmNlKCl9c3RhdGljIGFyZWEodCl7cmV0dXJuIHQuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpfXN0YXRpYyBpc0NvbXBvc2l0ZSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIExzfW1heGltdW1EaXN0YW5jZSgpe3JldHVybiBUcy5tYXhpbXVtRGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMS5nZXRCb3VuZHMoKSx0aGlzLl9ib3VuZGFibGUyLmdldEJvdW5kcygpKX1leHBhbmRUb1F1ZXVlKHQsZSl7Y29uc3Qgbj1Scy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKSxpPVJzLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpO2lmKG4mJmkpcmV0dXJuIFJzLmFyZWEodGhpcy5fYm91bmRhYmxlMSk+UnMuYXJlYSh0aGlzLl9ib3VuZGFibGUyKT8odGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyLCExLHQsZSksbnVsbCk6KHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsdGhpcy5fYm91bmRhYmxlMSwhMCx0LGUpLG51bGwpO2lmKG4pcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMiwhMSx0LGUpLG51bGw7aWYoaSlyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMix0aGlzLl9ib3VuZGFibGUxLCEwLHQsZSksbnVsbDt0aHJvdyBuZXcgcyhcIm5laXRoZXIgYm91bmRhYmxlIGlzIGNvbXBvc2l0ZVwiKX1pc0xlYXZlcygpe3JldHVybiEoUnMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSl8fFJzLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9kaXN0YW5jZTxlLl9kaXN0YW5jZT8tMTp0aGlzLl9kaXN0YW5jZT5lLl9kaXN0YW5jZT8xOjB9ZXhwYW5kKHQsZSxuLHMsaSl7Zm9yKGxldCByPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe2NvbnN0IHQ9ci5uZXh0KCk7bGV0IG89bnVsbDtvPW4/bmV3IFJzKGUsdCx0aGlzLl9pdGVtRGlzdGFuY2UpOm5ldyBScyh0LGUsdGhpcy5faXRlbURpc3RhbmNlKSxvLmdldERpc3RhbmNlKCk8aSYmcy5hZGQobyl9fWdldEJvdW5kYWJsZSh0KXtyZXR1cm4gMD09PXQ/dGhpcy5fYm91bmRhYmxlMTp0aGlzLl9ib3VuZGFibGUyfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuaXNMZWF2ZXMoKT90aGlzLl9pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyKTp0aGlzLl9ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgUHN7Y29uc3RydWN0b3IoKXtQcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9yb290PW51bGwsdGhpcy5fYnVpbHQ9ITEsdGhpcy5faXRlbUJvdW5kYWJsZXM9bmV3IEwsdGhpcy5fbm9kZUNhcGFjaXR5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpUHMuY29uc3RydWN0b3JfLmNhbGwodGhpcyxQcy5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2cuaXNUcnVlKHQ+MSxcIk5vZGUgY2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSx0aGlzLl9ub2RlQ2FwYWNpdHk9dH19c3RhdGljIGNvbXBhcmVEb3VibGVzKHQsZSl7cmV0dXJuIHQ+ZT8xOnQ8ZT8tMTowfXF1ZXJ5SW50ZXJuYWwoKXtpZihJKGFyZ3VtZW50c1syXSxEZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIExzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1sxXS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtmb3IobGV0IHM9MDtzPG4uc2l6ZSgpO3MrKyl7Y29uc3QgaT1uLmdldChzKTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoaS5nZXRCb3VuZHMoKSx0KSYmKGkgaW5zdGFuY2VvZiBMcz90aGlzLnF1ZXJ5SW50ZXJuYWwodCxpLGUpOmkgaW5zdGFuY2VvZiB3cz9lLnZpc2l0SXRlbShpLmdldEl0ZW0oKSk6Zy5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19ZWxzZSBpZihJKGFyZ3VtZW50c1syXSx3KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgTHMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzFdLmdldENoaWxkQm91bmRhYmxlcygpO2ZvcihsZXQgcz0wO3M8bi5zaXplKCk7cysrKXtjb25zdCBpPW4uZ2V0KHMpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhpLmdldEJvdW5kcygpLHQpJiYoaSBpbnN0YW5jZW9mIExzP3RoaXMucXVlcnlJbnRlcm5hbCh0LGksZSk6aSBpbnN0YW5jZW9mIHdzP2UuYWRkKGkuZ2V0SXRlbSgpKTpnLnNob3VsZE5ldmVyUmVhY2hIZXJlKCkpfX19Z2V0Tm9kZUNhcGFjaXR5KCl7cmV0dXJuIHRoaXMuX25vZGVDYXBhY2l0eX1sYXN0Tm9kZSh0KXtyZXR1cm4gdC5nZXQodC5zaXplKCktMSl9c2l6ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5zaXplKHRoaXMuX3Jvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9YXJndW1lbnRzWzBdLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24gaW5zdGFuY2VvZiBMcz90Kz10aGlzLnNpemUobik6biBpbnN0YW5jZW9mIHdzJiYodCs9MSl9cmV0dXJuIHR9fXJlbW92ZUl0ZW0odCxlKXtsZXQgbj1udWxsO2ZvcihsZXQgcz10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QgaW5zdGFuY2VvZiB3cyYmdC5nZXRJdGVtKCk9PT1lJiYobj10KX1yZXR1cm4gbnVsbCE9PW4mJih0LmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShuKSwhMCl9aXRlbXNUcmVlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMuYnVpbGQoKTtjb25zdCB0PXRoaXMuaXRlbXNUcmVlKHRoaXMuX3Jvb3QpO3JldHVybiBudWxsPT09dD9uZXcgTDp0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO2ZvcihsZXQgbj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQgaW5zdGFuY2VvZiBMcyl7Y29uc3Qgbj10aGlzLml0ZW1zVHJlZSh0KTtudWxsIT09biYmZS5hZGQobil9ZWxzZSB0IGluc3RhbmNlb2Ygd3M/ZS5hZGQodC5nZXRJdGVtKCkpOmcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gZS5zaXplKCk8PTA/bnVsbDplfX1pbnNlcnQodCxlKXtnLmlzVHJ1ZSghdGhpcy5fYnVpbHQsXCJDYW5ub3QgaW5zZXJ0IGl0ZW1zIGludG8gYW4gU1RSIHBhY2tlZCBSLXRyZWUgYWZ0ZXIgaXQgaGFzIGJlZW4gYnVpbHQuXCIpLHRoaXMuX2l0ZW1Cb3VuZGFibGVzLmFkZChuZXcgd3ModCxlKSl9Ym91bmRhYmxlc0F0TGV2ZWwoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtyZXR1cm4gdGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LHRoaXMuX3Jvb3QsZSksZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZy5pc1RydWUodD4tMiksZS5nZXRMZXZlbCgpPT09dClyZXR1cm4gbi5hZGQoZSksbnVsbDtmb3IobGV0IHM9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgZT1zLm5leHQoKTtlIGluc3RhbmNlb2YgTHM/dGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LGUsbik6KGcuaXNUcnVlKGUgaW5zdGFuY2VvZiB3cyksLTE9PT10JiZuLmFkZChlKSl9cmV0dXJuIG51bGx9fXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVpbGQoKTtjb25zdCBlPW5ldyBMO3JldHVybiB0aGlzLmlzRW1wdHkoKXx8dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnlJbnRlcm5hbCh0LHRoaXMuX3Jvb3QsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5idWlsZCgpLHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLHQpJiZ0aGlzLnF1ZXJ5SW50ZXJuYWwodCx0aGlzLl9yb290LGUpfX1idWlsZCgpe2lmKHRoaXMuX2J1aWx0KXJldHVybiBudWxsO3RoaXMuX3Jvb3Q9dGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpP3RoaXMuY3JlYXRlTm9kZSgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyh0aGlzLl9pdGVtQm91bmRhYmxlcywtMSksdGhpcy5faXRlbUJvdW5kYWJsZXM9bnVsbCx0aGlzLl9idWlsdD0hMH1nZXRSb290KCl7cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLl9yb290fXJlbW92ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5idWlsZCgpLCEhdGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucmVtb3ZlKHQsdGhpcy5fcm9vdCxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bGV0IHM9dGhpcy5yZW1vdmVJdGVtKGUsbik7aWYocylyZXR1cm4hMDtsZXQgaT1udWxsO2ZvcihsZXQgcj1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXtjb25zdCBlPXIubmV4dCgpO2lmKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhlLmdldEJvdW5kcygpLHQpJiYoZSBpbnN0YW5jZW9mIExzJiYocz10aGlzLnJlbW92ZSh0LGUsbikscykpKXtpPWU7YnJlYWt9fXJldHVybiBudWxsIT09aSYmaS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pc0VtcHR5KCkmJmUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKGkpLHN9fWNyZWF0ZUhpZ2hlckxldmVscyh0LGUpe2cuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj10aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKzEpO3JldHVybiAxPT09bi5zaXplKCk/bi5nZXQoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHMobixlKzEpfWRlcHRoKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLmRlcHRoKHRoaXMuX3Jvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9MDtmb3IobGV0IGU9YXJndW1lbnRzWzBdLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4gaW5zdGFuY2VvZiBMcyl7Y29uc3QgZT10aGlzLmRlcHRoKG4pO2U+dCYmKHQ9ZSl9fXJldHVybiB0KzF9fWNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKXtnLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49bmV3IEw7bi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKTtjb25zdCBzPW5ldyBMKHQpO3hlLnNvcnQocyx0aGlzLmdldENvbXBhcmF0b3IoKSk7Zm9yKGxldCB0PXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IHM9dC5uZXh0KCk7dGhpcy5sYXN0Tm9kZShuKS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5zaXplKCk9PT10aGlzLmdldE5vZGVDYXBhY2l0eSgpJiZuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpLHRoaXMubGFzdE5vZGUobikuYWRkQ2hpbGRCb3VuZGFibGUocyl9cmV0dXJuIG59aXNFbXB0eSgpe3JldHVybiB0aGlzLl9idWlsdD90aGlzLl9yb290LmlzRW1wdHkoKTp0aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2NdfX1Qcy5JbnRlcnNlY3RzT3A9ZnVuY3Rpb24oKXt9LFBzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMDtjbGFzcyBPc3tkaXN0YW5jZSh0LGUpe319Y2xhc3MgdnMgZXh0ZW5kcyBQc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx2cy5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1BzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fXN0YXRpYyBjZW50cmVYKHQpe3JldHVybiB2cy5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfXN0YXRpYyBnZXRJdGVtcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtsZXQgbj0wO2Zvcig7IXQuaXNFbXB0eSgpOyl7Y29uc3Qgcz10LnBvbGwoKTtlW25dPXMuZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSxuKyt9cmV0dXJuIGV9c3RhdGljIGNlbnRyZVkodCl7cmV0dXJuIHZzLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSl9Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyh0LGUpe2cuaXNUcnVlKHQubGVuZ3RoPjApO2NvbnN0IG49bmV3IEw7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspbi5hZGRBbGwodGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodFtzXSxlKSk7cmV0dXJuIG59bmVhcmVzdE5laWdoYm91cksoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cksodCxyLlBPU0lUSVZFX0lORklOSVRZLGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1syXTtsZXQgbj1hcmd1bWVudHNbMV07Y29uc3Qgcz1uZXcgQ3M7cy5hZGQodCk7Y29uc3QgaT1uZXcgQ3M7Zm9yKDshcy5pc0VtcHR5KCkmJm4+PTA7KXtjb25zdCB0PXMucG9sbCgpLHI9dC5nZXREaXN0YW5jZSgpO2lmKHI+PW4pYnJlYWs7aWYodC5pc0xlYXZlcygpKWlmKGkuc2l6ZSgpPGUpaS5hZGQodCk7ZWxzZXtpLnBlZWsoKS5nZXREaXN0YW5jZSgpPnImJihpLnBvbGwoKSxpLmFkZCh0KSk7bj1pLnBlZWsoKS5nZXREaXN0YW5jZSgpfWVsc2UgdC5leHBhbmRUb1F1ZXVlKHMsbil9cmV0dXJuIHZzLmdldEl0ZW1zKGkpfX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgTXModCl9c2l6ZSgpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9zdXBlci5zaXplLmNhbGwodGhpcyk6c3VwZXIuc2l6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0KCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTykpcmV0dXJuIHN1cGVyLmluc2VydC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQuaXNOdWxsKCkpcmV0dXJuIG51bGw7c3VwZXIuaW5zZXJ0LmNhbGwodGhpcyx0LGUpfX1nZXRJbnRlcnNlY3RzT3AoKXtyZXR1cm4gdnMuaW50ZXJzZWN0c09wfXZlcnRpY2FsU2xpY2VzKHQsZSl7Y29uc3Qgbj1NYXRoLnRydW5jKE1hdGguY2VpbCh0LnNpemUoKS9lKSkscz1uZXcgQXJyYXkoZSkuZmlsbChudWxsKSxpPXQuaXRlcmF0b3IoKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXtzW3RdPW5ldyBMO2xldCBlPTA7Zm9yKDtpLmhhc05leHQoKSYmZTxuOyl7Y29uc3Qgbj1pLm5leHQoKTtzW3RdLmFkZChuKSxlKyt9fXJldHVybiBzfXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBzdXBlci5xdWVyeS5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3N1cGVyLnF1ZXJ5LmNhbGwodGhpcyx0LGUpfX1nZXRDb21wYXJhdG9yKCl7cmV0dXJuIHZzLnlDb21wYXJhdG9yfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSh0LGUpe3JldHVybiBzdXBlci5jcmVhdGVQYXJlbnRCb3VuZGFibGVzLmNhbGwodGhpcyx0LGUpfXJlbW92ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gc3VwZXIucmVtb3ZlLmNhbGwodGhpcyx0LGUpfXJldHVybiBzdXBlci5yZW1vdmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWRlcHRoKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP3N1cGVyLmRlcHRoLmNhbGwodGhpcyk6c3VwZXIuZGVwdGguYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKXtnLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO2NvbnN0IG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvdGhpcy5nZXROb2RlQ2FwYWNpdHkoKSkpLHM9bmV3IEwodCk7eGUuc29ydChzLHZzLnhDb21wYXJhdG9yKTtjb25zdCBpPXRoaXMudmVydGljYWxTbGljZXMocyxNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLnNxcnQobikpKSk7cmV0dXJuIHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyhpLGUpfW5lYXJlc3ROZWlnaGJvdXIoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sT3MpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBScyh0aGlzLmdldFJvb3QoKSx0aGlzLmdldFJvb3QoKSx0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUnMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPXIuUE9TSVRJVkVfSU5GSU5JVFksbj1udWxsO2NvbnN0IHM9bmV3IENzO2ZvcihzLmFkZCh0KTshcy5pc0VtcHR5KCkmJmU+MDspe2NvbnN0IHQ9cy5wb2xsKCksaT10LmdldERpc3RhbmNlKCk7aWYoaT49ZSlicmVhazt0LmlzTGVhdmVzKCk/KGU9aSxuPXQpOnQuZXhwYW5kVG9RdWV1ZShzLGUpfXJldHVybiBudWxsPT09bj9udWxsOltuLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbi5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXX19ZWxzZXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5pc0VtcHR5KCl8fHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49bmV3IFJzKHRoaXMuZ2V0Um9vdCgpLHQuZ2V0Um9vdCgpLGUpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIobil9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzJdLGU9bmV3IHdzKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLG49bmV3IFJzKHRoaXMuZ2V0Um9vdCgpLGUsdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuKVswXX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMl0sZT1hcmd1bWVudHNbM10sbj1uZXcgd3MoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSkscz1uZXcgUnModGhpcy5nZXRSb290KCksbix0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VySyhzLGUpfX19aXNXaXRoaW5EaXN0YW5jZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1yLlBPU0lUSVZFX0lORklOSVRZO2NvbnN0IHM9bmV3IENzO2ZvcihzLmFkZCh0KTshcy5pc0VtcHR5KCk7KXtjb25zdCB0PXMucG9sbCgpLGk9dC5nZXREaXN0YW5jZSgpO2lmKGk+ZSlyZXR1cm4hMTtpZih0Lm1heGltdW1EaXN0YW5jZSgpPD1lKXJldHVybiEwO2lmKHQuaXNMZWF2ZXMoKSl7aWYobj1pLG48PWUpcmV0dXJuITB9ZWxzZSB0LmV4cGFuZFRvUXVldWUocyxuKX1yZXR1cm4hMX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgUnModGhpcy5nZXRSb290KCksdC5nZXRSb290KCksZSk7cmV0dXJuIHRoaXMuaXNXaXRoaW5EaXN0YW5jZShzLG4pfX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRXMsY119fWNsYXNzIE1zIGV4dGVuZHMgTHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLE1zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0xzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9Y29tcHV0ZUJvdW5kcygpe2xldCB0PW51bGw7Zm9yKGxldCBlPXRoaXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bnVsbD09PXQ/dD1uZXcgTyhuLmdldEJvdW5kcygpKTp0LmV4cGFuZFRvSW5jbHVkZShuLmdldEJvdW5kcygpKX1yZXR1cm4gdH19dnMuU1RSdHJlZU5vZGU9TXMsdnMueENvbXBhcmF0b3I9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX1jb21wYXJlKHQsZSl7cmV0dXJuIFBzLmNvbXBhcmVEb3VibGVzKHZzLmNlbnRyZVgodC5nZXRCb3VuZHMoKSksdnMuY2VudHJlWChlLmdldEJvdW5kcygpKSl9fSx2cy55Q29tcGFyYXRvcj1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2FdfWNvbXBhcmUodCxlKXtyZXR1cm4gUHMuY29tcGFyZURvdWJsZXModnMuY2VudHJlWSh0LmdldEJvdW5kcygpKSx2cy5jZW50cmVZKGUuZ2V0Qm91bmRzKCkpKX19LHZzLmludGVyc2VjdHNPcD1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ludGVyc2VjdHNPcF19aW50ZXJzZWN0cyh0LGUpe3JldHVybiB0LmludGVyc2VjdHMoZSl9fSx2cy5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTA7dmFyIGJzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFNUUnRyZWU6dnN9KSxEcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxrZHRyZWU6ZHMscXVhZHRyZWU6TnMsc3RydHJlZTpic30pO2NvbnN0IEFzPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtjbGFzcyBGc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgQ3R9cmVhZCh0KXtsZXQgZTtlPVwic3RyaW5nXCI9PXR5cGVvZiB0P0pTT04ucGFyc2UodCk6dDtjb25zdCBuPWUudHlwZTtpZighR3Nbbl0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK2UudHlwZSk7cmV0dXJuLTEhPT1Bcy5pbmRleE9mKG4pP0dzW25dLmNhbGwodGhpcyxlLmNvb3JkaW5hdGVzKTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09bj9Hc1tuXS5jYWxsKHRoaXMsZS5nZW9tZXRyaWVzKTpHc1tuXS5jYWxsKHRoaXMsZSl9d3JpdGUodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5VHlwZSgpO2lmKCFxc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJHZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBxc1tlXS5jYWxsKHRoaXMsdCl9fWNvbnN0IEdzPXtGZWF0dXJlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9e307Zm9yKGNvbnN0IG4gaW4gdCllW25dPXRbbl07aWYodC5nZW9tZXRyeSl7Y29uc3Qgbj10Lmdlb21ldHJ5LnR5cGU7aWYoIUdzW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIit0LnR5cGUpO2UuZ2VvbWV0cnk9dGhpcy5yZWFkKHQuZ2VvbWV0cnkpfXJldHVybiB0LmJib3gmJihlLmJib3g9R3MuYmJveC5jYWxsKHRoaXMsdC5iYm94KSksZX0sRmVhdHVyZUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT17fTtpZih0LmZlYXR1cmVzKXtlLmZlYXR1cmVzPVtdO2ZvcihsZXQgbj0wO248dC5mZWF0dXJlcy5sZW5ndGg7KytuKWUuZmVhdHVyZXMucHVzaCh0aGlzLnJlYWQodC5mZWF0dXJlc1tuXSkpfXJldHVybiB0LmJib3gmJihlLmJib3g9dGhpcy5wYXJzZS5iYm94LmNhbGwodGhpcyx0LmJib3gpKSxlfSxjb29yZGluYXRlczpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKG5ldyBtKHNbMF0sc1sxXSkpfXJldHVybiBlfSxiYm94OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgbSh0WzBdLHRbMV0pLG5ldyBtKHRbMl0sdFsxXSksbmV3IG0odFsyXSx0WzNdKSxuZXcgbSh0WzBdLHRbM10pLG5ldyBtKHRbMF0sdFsxXSldKX0sUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgbSguLi50KTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSl9LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goR3MuUG9pbnQuY2FsbCh0aGlzLHRbbl0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPUdzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyx0KTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlKX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKEdzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHRbbl0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9R3MuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLHRbMF0pLG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhlKSxzPVtdO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7KytlKXtjb25zdCBuPXRbZV0saT1Hcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsbikscj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGkpO3MucHVzaChyKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLHMpfSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaChHcy5Qb2x5Z29uLmNhbGwodGhpcyxzKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pe2NvbnN0IHM9dFtuXTtlLnB1c2godGhpcy5yZWFkKHMpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0scXM9e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7Y29uc3QgZT1bdC54LHQueV07cmV0dXJuIHQueiYmZS5wdXNoKHQueiksdC5tJiZlLnB1c2godC5tKSxlfSxQb2ludDpmdW5jdGlvbih0KXtyZXR1cm57dHlwZTpcIlBvaW50XCIsY29vcmRpbmF0ZXM6cXMuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5nZXRDb29yZGluYXRlKCkpfX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1xcy5Qb2ludC5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2ludFwiLGNvb3JkaW5hdGVzOmV9fSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W10sbj10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDsrK3Qpe2NvbnN0IHM9blt0XTtlLnB1c2gocXMuY29vcmRpbmF0ZS5jYWxsKHRoaXMscykpfXJldHVybnt0eXBlOlwiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9cXMuTGluZVN0cmluZy5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LFBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXSxuPXFzLkxpbmVTdHJpbmcuY2FsbCh0aGlzLHQuX3NoZWxsKTtlLnB1c2gobi5jb29yZGluYXRlcyk7Zm9yKGxldCBuPTA7bjx0Ll9ob2xlcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2hvbGVzW25dLGk9cXMuTGluZVN0cmluZy5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoOysrbil7Y29uc3Qgcz10Ll9nZW9tZXRyaWVzW25dLGk9cXMuUG9seWdvbi5jYWxsKHRoaXMscyk7ZS5wdXNoKGkuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1zLmdldEdlb21ldHJ5VHlwZSgpO2UucHVzaChxc1tpXS5jYWxsKHRoaXMscykpfXJldHVybnt0eXBlOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsZ2VvbWV0cmllczplfX19O2Z1bmN0aW9uIEJzKHQpe3JldHVyblt0LngsdC55XX12YXIgWXM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvSlNPTlJlYWRlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgRnModHx8bmV3IEN0KX1yZWFkKHQpe3JldHVybiB0aGlzLnBhcnNlci5yZWFkKHQpfX0sR2VvSlNPTldyaXRlcjpjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMucGFyc2VyPW5ldyBGcyh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9d3JpdGUodCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0sT0wzUGFyc2VyOmNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IEN0LHRoaXMub2w9ZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG9sJiZvbH1pbmplY3QodCxlLG4scyxpLHIsbyxsKXt0aGlzLm9sPXtnZW9tOntQb2ludDp0LExpbmVTdHJpbmc6ZSxMaW5lYXJSaW5nOm4sUG9seWdvbjpzLE11bHRpUG9pbnQ6aSxNdWx0aUxpbmVTdHJpbmc6cixNdWx0aVBvbHlnb246byxHZW9tZXRyeUNvbGxlY3Rpb246bH19fXJlYWQodCl7Y29uc3QgZT10aGlzLm9sO3JldHVybiB0IGluc3RhbmNlb2YgZS5nZW9tLlBvaW50P3RoaXMuY29udmVydEZyb21Qb2ludCh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5MaW5lYXJSaW5nP3RoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9pbnQodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aUxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uP3RoaXMuY29udmVydEZyb21Db2xsZWN0aW9uKHQpOnZvaWQgMH1jb252ZXJ0RnJvbVBvaW50KHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgbShlWzBdLGVbMV0pKX1jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBtKHRbMF0sdFsxXSl9KSkpfWNvbnZlcnRGcm9tTGluZWFyUmluZyh0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IG0odFswXSx0WzFdKX0pKSl9Y29udmVydEZyb21Qb2x5Z29uKHQpe2NvbnN0IGU9dC5nZXRMaW5lYXJSaW5ncygpO2xldCBuPW51bGw7Y29uc3Qgcz1bXTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgaT10aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyhlW3RdKTswPT09dD9uPWk6cy5wdXNoKGkpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4scyl9Y29udmVydEZyb21NdWx0aVBvaW50KHQpe2NvbnN0IGU9dC5nZXRQb2ludHMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9pbnQodCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX1jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KXtjb25zdCBlPXQuZ2V0TGluZVN0cmluZ3MoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9Y29udmVydEZyb21NdWx0aVBvbHlnb24odCl7Y29uc3QgZT10LmdldFBvbHlnb25zKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCl9KSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfWNvbnZlcnRGcm9tQ29sbGVjdGlvbih0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cmllcygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZCh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9d3JpdGUodCl7cmV0dXJuXCJQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTpcIkxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQpOlwiTGluZWFyUmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVhclJpbmcodCk6XCJQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9seWdvbih0KTpcIk11bHRpUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvaW50KHQpOlwiTXVsdGlMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlMaW5lU3RyaW5nKHQpOlwiTXVsdGlQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2x5Z29uKHQpOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvQ29sbGVjdGlvbih0KTp2b2lkIDB9Y29udmVydFRvUG9pbnQodCl7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uUG9pbnQoW3QueCx0LnldKX1jb252ZXJ0VG9MaW5lU3RyaW5nKHQpe2NvbnN0IGU9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoQnMpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLkxpbmVTdHJpbmcoZSl9Y29udmVydFRvTGluZWFyUmluZyh0KXtjb25zdCBlPXQuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKEJzKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5MaW5lYXJSaW5nKGUpfWNvbnZlcnRUb1BvbHlnb24odCl7Y29uc3QgZT1bdC5fc2hlbGwuX3BvaW50cy5fY29vcmRpbmF0ZXMubWFwKEJzKV07Zm9yKGxldCBuPTA7bjx0Ll9ob2xlcy5sZW5ndGg7bisrKWUucHVzaCh0Ll9ob2xlc1tuXS5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoQnMpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5Qb2x5Z29uKGUpfWNvbnZlcnRUb011bHRpUG9pbnQodCl7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTXVsdGlQb2ludCh0LmdldENvb3JkaW5hdGVzKCkubWFwKEJzKSl9Y29udmVydFRvTXVsdGlMaW5lU3RyaW5nKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvTGluZVN0cmluZyh0Ll9nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmcoZSl9Y29udmVydFRvTXVsdGlQb2x5Z29uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvUG9seWdvbih0Ll9nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aVBvbHlnb24oZSl9Y29udmVydFRvQ29sbGVjdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl07ZS5wdXNoKHRoaXMud3JpdGUocykpfXJldHVybiBuZXcgdGhpcy5vbC5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbihlKX19LFdLVFJlYWRlcjpjbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnBhcnNlcj1uZXcgSHQodHx8bmV3IEN0KX1yZWFkKHQpe3JldHVybiB0aGlzLnBhcnNlci5yZWFkKHQpfX0sV0tUV3JpdGVyOld0fSk7Y2xhc3MgVnN7c3RhdGljIHJlbGF0aXZlU2lnbih0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6MH1zdGF0aWMgY29tcGFyZSh0LGUsbil7aWYoZS5lcXVhbHMyRChuKSlyZXR1cm4gMDtjb25zdCBzPVZzLnJlbGF0aXZlU2lnbihlLngsbi54KSxpPVZzLnJlbGF0aXZlU2lnbihlLnksbi55KTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBWcy5jb21wYXJlVmFsdWUocyxpKTtjYXNlIDE6cmV0dXJuIFZzLmNvbXBhcmVWYWx1ZShpLHMpO2Nhc2UgMjpyZXR1cm4gVnMuY29tcGFyZVZhbHVlKGksLXMpO2Nhc2UgMzpyZXR1cm4gVnMuY29tcGFyZVZhbHVlKC1zLGkpO2Nhc2UgNDpyZXR1cm4gVnMuY29tcGFyZVZhbHVlKC1zLC1pKTtjYXNlIDU6cmV0dXJuIFZzLmNvbXBhcmVWYWx1ZSgtaSwtcyk7Y2FzZSA2OnJldHVybiBWcy5jb21wYXJlVmFsdWUoLWkscyk7Y2FzZSA3OnJldHVybiBWcy5jb21wYXJlVmFsdWUocywtaSl9cmV0dXJuIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJpbnZhbGlkIG9jdGFudCB2YWx1ZVwiKSwwfXN0YXRpYyBjb21wYXJlVmFsdWUodCxlKXtyZXR1cm4gdDwwPy0xOnQ+MD8xOmU8MD8tMTplPjA/MTowfX1jbGFzcyB6c3tjb25zdHJ1Y3Rvcigpe3pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NlZ1N0cmluZz1udWxsLHRoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuX3NlZ21lbnRPY3RhbnQ9bnVsbCx0aGlzLl9pc0ludGVyaW9yPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fc2VnU3RyaW5nPXQsdGhpcy5jb29yZD1uZXcgbShlKSx0aGlzLnNlZ21lbnRJbmRleD1uLHRoaXMuX3NlZ21lbnRPY3RhbnQ9cyx0aGlzLl9pc0ludGVyaW9yPSFlLmVxdWFsczJEKHQuZ2V0Q29vcmRpbmF0ZShuKSl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLmNvb3JkfXByaW50KHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDxlLnNlZ21lbnRJbmRleD8tMTp0aGlzLnNlZ21lbnRJbmRleD5lLnNlZ21lbnRJbmRleD8xOnRoaXMuY29vcmQuZXF1YWxzMkQoZS5jb29yZCk/MDp0aGlzLl9pc0ludGVyaW9yP2UuX2lzSW50ZXJpb3I/VnMuY29tcGFyZSh0aGlzLl9zZWdtZW50T2N0YW50LHRoaXMuY29vcmQsZS5jb29yZCk6MTotMX1pc0VuZFBvaW50KHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJiF0aGlzLl9pc0ludGVyaW9yfHx0aGlzLnNlZ21lbnRJbmRleD09PXR9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXgrXCI6XCIrdGhpcy5jb29yZC50b1N0cmluZygpfWlzSW50ZXJpb3IoKXtyZXR1cm4gdGhpcy5faXNJbnRlcmlvcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIGtze2NvbnN0cnVjdG9yKCl7a3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZU1hcD1uZXcgSG4sdGhpcy5fZWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2U9dH1nZXRTcGxpdENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgUjt0aGlzLmFkZEVuZHBvaW50cygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpO3RoaXMuYWRkRWRnZUNvb3JkaW5hdGVzKG4scyx0KSxuPXN9cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX1hZGRDb2xsYXBzZWROb2Rlcygpe2NvbnN0IHQ9bmV3IEw7dGhpcy5maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXModCksdGhpcy5maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXModCk7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCkuaW50VmFsdWUoKTt0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUodCksdCl9fWNyZWF0ZVNwbGl0RWRnZVB0cyh0LGUpe2xldCBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzI7aWYoMj09PW4pcmV0dXJuW25ldyBtKHQuY29vcmQpLG5ldyBtKGUuY29vcmQpXTtjb25zdCBzPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCksaT1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQocyk7aXx8bi0tO2NvbnN0IHI9bmV3IEFycmF5KG4pLmZpbGwobnVsbCk7bGV0IG89MDtyW28rK109bmV3IG0odC5jb29yZCk7Zm9yKGxldCBuPXQuc2VnbWVudEluZGV4KzE7bjw9ZS5zZWdtZW50SW5kZXg7bisrKXJbbysrXT10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUobik7cmV0dXJuIGkmJihyW29dPW5ldyBtKGUuY29vcmQpKSxyfXByaW50KHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19ZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZS5zaXplKCktMjtlKyspe2NvbnN0IG49dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGUpLHM9KHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKzEpLHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKzIpKTtuLmVxdWFsczJEKHMpJiZ0LmFkZChNLnZhbHVlT2YoZSsxKSl9fWFkZEVkZ2VDb29yZGluYXRlcyh0LGUsbil7Y29uc3Qgcz10aGlzLmNyZWF0ZVNwbGl0RWRnZVB0cyh0LGUpO24uYWRkKHMsITEpfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1hZGRTcGxpdEVkZ2VzKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCksdGhpcy5hZGRDb2xsYXBzZWROb2RlcygpO2NvbnN0IGU9dGhpcy5pdGVyYXRvcigpO2xldCBuPWUubmV4dCgpO2Zvcig7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpLGk9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixzKTt0LmFkZChpKSxuPXN9fWZpbmRDb2xsYXBzZUluZGV4KHQsZSxuKXtpZighdC5jb29yZC5lcXVhbHMyRChlLmNvb3JkKSlyZXR1cm4hMTtsZXQgcz1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleDtyZXR1cm4gZS5pc0ludGVyaW9yKCl8fHMtLSwxPT09cyYmKG5bMF09dC5zZWdtZW50SW5kZXgrMSwhMCl9ZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLml0ZXJhdG9yKCk7bGV0IHM9bi5uZXh0KCk7Zm9yKDtuLmhhc05leHQoKTspe2NvbnN0IGk9bi5uZXh0KCk7dGhpcy5maW5kQ29sbGFwc2VJbmRleChzLGksZSkmJnQuYWRkKE0udmFsdWVPZihlWzBdKSkscz1pfX1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9YWRkRW5kcG9pbnRzKCl7Y29uc3QgdD10aGlzLl9lZGdlLnNpemUoKS0xO3RoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwwKSx0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUodCksdCl9Y3JlYXRlU3BsaXRFZGdlKHQsZSl7Y29uc3Qgbj10aGlzLmNyZWF0ZVNwbGl0RWRnZVB0cyh0LGUpO3JldHVybiBuZXcgV3Mobix0aGlzLl9lZGdlLmdldERhdGEoKSl9YWRkKHQsZSl7Y29uc3Qgbj1uZXcgenModGhpcy5fZWRnZSx0LGUsdGhpcy5fZWRnZS5nZXRTZWdtZW50T2N0YW50KGUpKSxzPXRoaXMuX25vZGVNYXAuZ2V0KG4pO3JldHVybiBudWxsIT09cz8oZy5pc1RydWUocy5jb29yZC5lcXVhbHMyRCh0KSxcIkZvdW5kIGVxdWFsIG5vZGVzIHdpdGggZGlmZmVyZW50IGNvb3JkaW5hdGVzXCIpLHMpOih0aGlzLl9ub2RlTWFwLnB1dChuLG4pLG4pfWNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzKHQpe2NvbnN0IGU9dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlcygpLG49dC5nZXQoMCkuZ2V0Q29vcmRpbmF0ZSgwKTtpZighbi5lcXVhbHMyRChlWzBdKSl0aHJvdyBuZXcgaChcImJhZCBzcGxpdCBlZGdlIHN0YXJ0IHBvaW50IGF0IFwiK24pO2NvbnN0IHM9dC5nZXQodC5zaXplKCktMSkuZ2V0Q29vcmRpbmF0ZXMoKSxpPXNbcy5sZW5ndGgtMV07aWYoIWkuZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkpdGhyb3cgbmV3IGgoXCJiYWQgc3BsaXQgZWRnZSBlbmQgcG9pbnQgYXQgXCIraSl9fWNsYXNzIFhze3N0YXRpYyBvY3RhbnQoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IHMoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtjb25zdCBuPU1hdGguYWJzKHQpLGk9TWF0aC5hYnMoZSk7cmV0dXJuIHQ+PTA/ZT49MD9uPj1pPzA6MTpuPj1pPzc6NjplPj0wP24+PWk/MzoyOm4+PWk/NDo1fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10LngsaT1lLnktdC55O2lmKDA9PT1uJiYwPT09aSl0aHJvdyBuZXcgcyhcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK3QpO3JldHVybiBYcy5vY3RhbnQobixpKX19fWNsYXNzIFVze2dldENvb3JkaW5hdGVzKCl7fXNpemUoKXt9Z2V0Q29vcmRpbmF0ZSh0KXt9aXNDbG9zZWQoKXt9c2V0RGF0YSh0KXt9Z2V0RGF0YSgpe319Y2xhc3MgSHN7YWRkSW50ZXJzZWN0aW9uKHQsZSl7fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltVc119fWNsYXNzIFdze2NvbnN0cnVjdG9yKCl7V3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbm9kZUxpc3Q9bmV3IGtzKHRoaXMpLHRoaXMuX3B0cz1udWxsLHRoaXMuX2RhdGE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdHM9dCx0aGlzLl9kYXRhPWV9c3RhdGljIGdldE5vZGVkU3Vic3RyaW5ncygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBMO3JldHVybiBXcy5nZXROb2RlZFN1YnN0cmluZ3ModCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtmb3IobGV0IGU9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5nZXROb2RlTGlzdCgpLmFkZFNwbGl0RWRnZXModCl9fX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdHN9c2l6ZSgpe3JldHVybiB0aGlzLl9wdHMubGVuZ3RofWdldENvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMuX3B0c1t0XX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoLTFdKX1nZXRTZWdtZW50T2N0YW50KHQpe3JldHVybiB0PT09dGhpcy5fcHRzLmxlbmd0aC0xPy0xOnRoaXMuc2FmZU9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fXNhZmVPY3RhbnQodCxlKXtyZXR1cm4gdC5lcXVhbHMyRChlKT8wOlhzLm9jdGFudCh0LGUpfWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1hZGRJbnRlcnNlY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbM10sbj1uZXcgbShhcmd1bWVudHNbMF0uZ2V0SW50ZXJzZWN0aW9uKGUpKTt0aGlzLmFkZEludGVyc2VjdGlvbihuLHQpfX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcobmV3IHB0KHRoaXMuX3B0cykpfWdldE5vZGVMaXN0KCl7cmV0dXJuIHRoaXMuX25vZGVMaXN0fWFkZEludGVyc2VjdGlvbk5vZGUodCxlKXtsZXQgbj1lO2NvbnN0IHM9bisxO2lmKHM8dGhpcy5fcHRzLmxlbmd0aCl7Y29uc3QgZT10aGlzLl9wdHNbc107dC5lcXVhbHMyRChlKSYmKG49cyl9cmV0dXJuIHRoaXMuX25vZGVMaXN0LmFkZCh0LG4pfWFkZEludGVyc2VjdGlvbnModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0hzXX19Y2xhc3MgWnN7Y29uc3RydWN0b3IoKXtacy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vdmVybGFwU2VnMT1uZXcgS3QsdGhpcy5fb3ZlcmxhcFNlZzI9bmV3IEt0fW92ZXJsYXAoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM107YXJndW1lbnRzWzBdLmdldExpbmVTZWdtZW50KHQsdGhpcy5fb3ZlcmxhcFNlZzEpLGUuZ2V0TGluZVNlZ21lbnQobix0aGlzLl9vdmVybGFwU2VnMiksdGhpcy5vdmVybGFwKHRoaXMuX292ZXJsYXBTZWcxLHRoaXMuX292ZXJsYXBTZWcyKX19fWNsYXNzIGpze2NvbnN0cnVjdG9yKCl7anMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fc3RhcnQ9bnVsbCx0aGlzLl9lbmQ9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLl9jb250ZXh0PW51bGwsdGhpcy5faWQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9wdHM9dCx0aGlzLl9zdGFydD1lLHRoaXMuX2VuZD1uLHRoaXMuX2NvbnRleHQ9c31nZXRMaW5lU2VnbWVudCh0LGUpe2UucDA9dGhpcy5fcHRzW3RdLGUucDE9dGhpcy5fcHRzW3QrMV19Y29tcHV0ZVNlbGVjdCh0LGUsbixzKXtjb25zdCBpPXRoaXMuX3B0c1tlXSxyPXRoaXMuX3B0c1tuXTtpZihuLWU9PTEpcmV0dXJuIHMuc2VsZWN0KHRoaXMsZSksbnVsbDtpZighdC5pbnRlcnNlY3RzKGkscikpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKChlK24pLzIpO2U8byYmdGhpcy5jb21wdXRlU2VsZWN0KHQsZSxvLHMpLG88biYmdGhpcy5jb21wdXRlU2VsZWN0KHQsbyxuLHMpfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fZW5kLXRoaXMuX3N0YXJ0KzEpLmZpbGwobnVsbCk7bGV0IGU9MDtmb3IobGV0IG49dGhpcy5fc3RhcnQ7bjw9dGhpcy5fZW5kO24rKyl0W2UrK109dGhpcy5fcHRzW25dO3JldHVybiB0fWNvbXB1dGVPdmVybGFwcygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmNvbXB1dGVPdmVybGFwcyh0aGlzLl9zdGFydCx0aGlzLl9lbmQsdCx0Ll9zdGFydCx0Ll9lbmQsZSl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07aWYoZS10PT0xJiZpLXM9PTEpcmV0dXJuIHIub3ZlcmxhcCh0aGlzLHQsbixzKSxudWxsO2lmKCF0aGlzLm92ZXJsYXBzKHQsZSxuLHMsaSkpcmV0dXJuIG51bGw7Y29uc3Qgbz1NYXRoLnRydW5jKCh0K2UpLzIpLGw9TWF0aC50cnVuYygocytpKS8yKTt0PG8mJihzPGwmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKHQsbyxuLHMsbCxyKSxsPGkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzKHQsbyxuLGwsaSxyKSksbzxlJiYoczxsJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyhvLGUsbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyhvLGUsbixsLGkscikpfX1zZXRJZCh0KXt0aGlzLl9pZD10fXNlbGVjdCh0LGUpe3RoaXMuY29tcHV0ZVNlbGVjdCh0LHRoaXMuX3N0YXJ0LHRoaXMuX2VuZCxlKX1nZXRFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9lbnYpe2NvbnN0IHQ9dGhpcy5fcHRzW3RoaXMuX3N0YXJ0XSxlPXRoaXMuX3B0c1t0aGlzLl9lbmRdO3RoaXMuX2Vudj1uZXcgTyh0LGUpfXJldHVybiB0aGlzLl9lbnZ9b3ZlcmxhcHModCxlLG4scyxpKXtyZXR1cm4gTy5pbnRlcnNlY3RzKHRoaXMuX3B0c1t0XSx0aGlzLl9wdHNbZV0sbi5fcHRzW3NdLG4uX3B0c1tpXSl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gdGhpcy5fZW5kfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gdGhpcy5fc3RhcnR9Z2V0Q29udGV4dCgpe3JldHVybiB0aGlzLl9jb250ZXh0fWdldElkKCl7cmV0dXJuIHRoaXMuX2lkfX1jbGFzcyBLc3tzdGF0aWMgZmluZENoYWluRW5kKHQsZSl7bGV0IG49ZTtmb3IoO248dC5sZW5ndGgtMSYmdFtuXS5lcXVhbHMyRCh0W24rMV0pOyluKys7aWYobj49dC5sZW5ndGgtMSlyZXR1cm4gdC5sZW5ndGgtMTtjb25zdCBzPXduLnF1YWRyYW50KHRbbl0sdFtuKzFdKTtsZXQgaT1lKzE7Zm9yKDtpPHQubGVuZ3RoOyl7aWYoIXRbaS0xXS5lcXVhbHMyRCh0W2ldKSl7aWYod24ucXVhZHJhbnQodFtpLTFdLHRbaV0pIT09cylicmVha31pKyt9cmV0dXJuIGktMX1zdGF0aWMgZ2V0Q2hhaW5zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBLcy5nZXRDaGFpbnModCxudWxsKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgTDtsZXQgcz0wO2Rve2NvbnN0IGk9S3MuZmluZENoYWluRW5kKHQscykscj1uZXcganModCxzLGksZSk7bi5hZGQocikscz1pfXdoaWxlKHM8dC5sZW5ndGgtMSk7cmV0dXJuIG59fX1jbGFzcyBRc3tjb21wdXRlTm9kZXModCl7fWdldE5vZGVkU3Vic3RyaW5ncygpe319Y2xhc3MgSnN7Y29uc3RydWN0b3IoKXtKcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9zZWdJbnQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl9fXNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KXt0aGlzLl9zZWdJbnQ9dH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUXNdfX1jbGFzcyAkcyBleHRlbmRzIEpze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSwkcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9tb25vQ2hhaW5zPW5ldyBMLHRoaXMuX2luZGV4PW5ldyB2cyx0aGlzLl9pZENvdW50ZXI9MCx0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9bnVsbCx0aGlzLl9uT3ZlcmxhcHM9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07SnMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19Z2V0TW9ub3RvbmVDaGFpbnMoKXtyZXR1cm4gdGhpcy5fbW9ub0NoYWluc31nZXROb2RlZFN1YnN0cmluZ3MoKXtyZXR1cm4gV3MuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncyl9Z2V0SW5kZXgoKXtyZXR1cm4gdGhpcy5faW5kZXh9YWRkKHQpe2ZvcihsZXQgZT1Lcy5nZXRDaGFpbnModC5nZXRDb29yZGluYXRlcygpLHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0SWQodGhpcy5faWRDb3VudGVyKyspLHRoaXMuX2luZGV4Lmluc2VydCh0LmdldEVudmVsb3BlKCksdCksdGhpcy5fbW9ub0NoYWlucy5hZGQodCl9fWNvbXB1dGVOb2Rlcyh0KXt0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9dDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7dGhpcy5pbnRlcnNlY3RDaGFpbnMoKX1pbnRlcnNlY3RDaGFpbnMoKXtjb25zdCB0PW5ldyB0aSh0aGlzLl9zZWdJbnQpO2ZvcihsZXQgZT10aGlzLl9tb25vQ2hhaW5zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2ZvcihsZXQgZT10aGlzLl9pbmRleC5xdWVyeShuLmdldEVudmVsb3BlKCkpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpO2lmKHMuZ2V0SWQoKT5uLmdldElkKCkmJihuLmNvbXB1dGVPdmVybGFwcyhzLHQpLHRoaXMuX25PdmVybGFwcysrKSx0aGlzLl9zZWdJbnQuaXNEb25lKCkpcmV0dXJuIG51bGx9fX19Y2xhc3MgdGkgZXh0ZW5kcyBac3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc2k9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zaT10fW92ZXJsYXAoKXtpZig0IT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gc3VwZXIub3ZlcmxhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49YXJndW1lbnRzWzNdLHM9YXJndW1lbnRzWzBdLmdldENvbnRleHQoKSxpPWUuZ2V0Q29udGV4dCgpO3RoaXMuX3NpLnByb2Nlc3NJbnRlcnNlY3Rpb25zKHMsdCxpLG4pfX19JHMuU2VnbWVudE92ZXJsYXBBY3Rpb249dGk7Y2xhc3MgZWl7Y29uc3RydWN0b3IoKXtlaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fb2Zmc2V0WD1udWxsLHRoaXMuX29mZnNldFk9bnVsbCx0aGlzLl9pc1NjYWxlZD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZWkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCwwKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2Rlcj10LHRoaXMuX3NjYWxlRmFjdG9yPWUsdGhpcy5faXNTY2FsZWQ9IXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCl9fXJlc2NhbGUoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLnJlc2NhbGUoZS5nZXRDb29yZGluYXRlcygpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdLng9dFtlXS54L3RoaXMuX3NjYWxlRmFjdG9yK3RoaXMuX29mZnNldFgsdFtlXS55PXRbZV0ueS90aGlzLl9zY2FsZUZhY3Rvcit0aGlzLl9vZmZzZXRZOzI9PT10Lmxlbmd0aCYmdFswXS5lcXVhbHMyRCh0WzFdKSYmQi5vdXQucHJpbnRsbih0KX19c2NhbGUoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTCh0LnNpemUoKSk7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IFdzKHRoaXMuc2NhbGUodC5nZXRDb29yZGluYXRlcygpKSx0LmdldERhdGEoKSkpfXJldHVybiBlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWVbbl09bmV3IG0oTWF0aC5yb3VuZCgodFtuXS54LXRoaXMuX29mZnNldFgpKnRoaXMuX3NjYWxlRmFjdG9yKSxNYXRoLnJvdW5kKCh0W25dLnktdGhpcy5fb2Zmc2V0WSkqdGhpcy5fc2NhbGVGYWN0b3IpLHRbbl0uZ2V0WigpKTtyZXR1cm4gZHQucmVtb3ZlUmVwZWF0ZWRQb2ludHMoZSl9fWlzSW50ZWdlclByZWNpc2lvbigpe3JldHVybiAxPT09dGhpcy5fc2NhbGVGYWN0b3J9Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7Y29uc3QgdD10aGlzLl9ub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtyZXR1cm4gdGhpcy5faXNTY2FsZWQmJnRoaXMucmVzY2FsZSh0KSx0fWNvbXB1dGVOb2Rlcyh0KXtsZXQgZT10O3RoaXMuX2lzU2NhbGVkJiYoZT10aGlzLnNjYWxlKHQpKSx0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXMoZSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1FzXX19dmFyIG5pPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLE1DSW5kZXhOb2RlcjokcyxTY2FsZWROb2RlcjplaSxTZWdtZW50U3RyaW5nOlVzfSk7Y2xhc3Mgc2l7Y29uc3RydWN0b3IoKXtzaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9iblJ1bGU9bnVsbCx0aGlzLl9lbmRwb2ludE1hcD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZ24uTU9EMl9CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tPXQsdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCksdGhpcy5fYm5SdWxlPWV9fXN0YXRpYyBnZXRCb3VuZGFyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IHNpKGFyZ3VtZW50c1swXSkuZ2V0Qm91bmRhcnkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7cmV0dXJuIG5ldyBzaShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKS5nZXRCb3VuZGFyeSgpfX1ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0KXtpZih0aGlzLl9nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTtjb25zdCBlPXRoaXMuY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXModCk7cmV0dXJuIDE9PT1lLmxlbmd0aD90aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludChlWzBdKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhlKX1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLl9nZW9tIGluc3RhbmNlb2YgSj90aGlzLmJvdW5kYXJ5TGluZVN0cmluZyh0aGlzLl9nZW9tKTp0aGlzLl9nZW9tIGluc3RhbmNlb2Ygd3Q/dGhpcy5ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0aGlzLl9nZW9tKTp0aGlzLl9nZW9tLmdldEJvdW5kYXJ5KCl9Ym91bmRhcnlMaW5lU3RyaW5nKHQpe2lmKHRoaXMuX2dlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO2lmKHQuaXNDbG9zZWQoKSl7cmV0dXJuIHRoaXMuX2JuUnVsZS5pc0luQm91bmRhcnkoMik/dC5nZXRTdGFydFBvaW50KCk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfXJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KFt0LmdldFN0YXJ0UG9pbnQoKSx0LmdldEVuZFBvaW50KCldKX1nZXRFbXB0eU11bHRpUG9pbnQoKXtyZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfWNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEw7dGhpcy5fZW5kcG9pbnRNYXA9bmV3IEhuO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpOzAhPT1uLmdldE51bVBvaW50cygpJiYodGhpcy5hZGRFbmRwb2ludChuLmdldENvb3JkaW5hdGVOKDApKSx0aGlzLmFkZEVuZHBvaW50KG4uZ2V0Q29vcmRpbmF0ZU4obi5nZXROdW1Qb2ludHMoKS0xKSkpfWZvcihsZXQgdD10aGlzLl9lbmRwb2ludE1hcC5lbnRyeVNldCgpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRWYWx1ZSgpLmNvdW50O3RoaXMuX2JuUnVsZS5pc0luQm91bmRhcnkocykmJmUuYWRkKG4uZ2V0S2V5KCkpfXJldHVybiBkdC50b0Nvb3JkaW5hdGVBcnJheShlKX1hZGRFbmRwb2ludCh0KXtsZXQgZT10aGlzLl9lbmRwb2ludE1hcC5nZXQodCk7bnVsbD09PWUmJihlPW5ldyBpaSx0aGlzLl9lbmRwb2ludE1hcC5wdXQodCxlKSksZS5jb3VudCsrfX1jbGFzcyBpaXtjb25zdHJ1Y3Rvcigpe2lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuY291bnQ9bnVsbH19Y2xhc3Mgcml7Y29uc3RydWN0b3IoKXtyaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9ITAsdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSFlLmlzSW5Cb3VuZGFyeSgyKX19c3RhdGljIGlzU2ltcGxlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBuZXcgcmkoYXJndW1lbnRzWzBdKS5pc1NpbXBsZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IHJpKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLmlzU2ltcGxlKCl9fWlzU2ltcGxlTXVsdGlQb2ludCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtjb25zdCBlPW5ldyBsdDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKS5nZXRDb29yZGluYXRlKCk7aWYoZS5jb250YWlucyhzKSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249cywhMTtlLmFkZChzKX1yZXR1cm4hMH1pc1NpbXBsZVBvbHlnb25hbCh0KXtmb3IobGV0IGU9eWUuZ2V0TGluZXModCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYoIXRoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KSlyZXR1cm4hMX1yZXR1cm4hMH1oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbih0KXtjb25zdCBlPW5ldyBIbjtmb3IobGV0IG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkscz10LmlzQ2xvc2VkKCksaT10LmdldENvb3JkaW5hdGUoMCk7dGhpcy5hZGRFbmRwb2ludChlLGkscyk7Y29uc3Qgcj10LmdldENvb3JkaW5hdGUodC5nZXROdW1Qb2ludHMoKS0xKTt0aGlzLmFkZEVuZHBvaW50KGUscixzKX1mb3IobGV0IHQ9ZS52YWx1ZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtpZihlLmlzQ2xvc2VkJiYyIT09ZS5kZWdyZWUpcmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPWUuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfWdldE5vblNpbXBsZUxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9ufWlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Y29uc3QgZT1uZXcgbHMoMCx0KSxuPW5ldyBqdCxzPWUuY29tcHV0ZVNlbGZOb2RlcyhuLCEwKTtyZXR1cm4hcy5oYXNJbnRlcnNlY3Rpb24oKXx8KHMuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPXMuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6IXRoaXMuaGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSkmJighdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yfHwhdGhpcy5oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbihlKSkpfWhhc05vbkVuZHBvaW50SW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpO2ZvcihsZXQgZT10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYoIXQuaXNFbmRQb2ludChuKSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249dC5nZXRDb29yZGluYXRlKCksITB9fXJldHVybiExfWFkZEVuZHBvaW50KHQsZSxuKXtsZXQgcz10LmdldChlKTtudWxsPT09cyYmKHM9bmV3IG9pKGUpLHQucHV0KGUscykpLHMuYWRkRW5kcG9pbnQobil9Y29tcHV0ZVNpbXBsZSh0KXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249bnVsbCwhIXQuaXNFbXB0eSgpfHwodCBpbnN0YW5jZW9mIEp8fHQgaW5zdGFuY2VvZiB3dD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIGh0P3RoaXMuaXNTaW1wbGVNdWx0aVBvaW50KHQpOkkodCxzdCk/dGhpcy5pc1NpbXBsZVBvbHlnb25hbCh0KTohKHQgaW5zdGFuY2VvZiBjdCl8fHRoaXMuaXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCkpfWlzU2ltcGxlKCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsdGhpcy5jb21wdXRlU2ltcGxlKHRoaXMuX2lucHV0R2VvbSl9aXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuY29tcHV0ZVNpbXBsZShuKSlyZXR1cm4hMX1yZXR1cm4hMH19Y2xhc3Mgb2l7Y29uc3RydWN0b3IoKXtvaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnB0PW51bGwsdGhpcy5pc0Nsb3NlZD1udWxsLHRoaXMuZGVncmVlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wdD10LHRoaXMuaXNDbG9zZWQ9ITEsdGhpcy5kZWdyZWU9MH1hZGRFbmRwb2ludCh0KXt0aGlzLmRlZ3JlZSsrLHRoaXMuaXNDbG9zZWR8PXR9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLnB0fX1yaS5FbmRwb2ludEluZm89b2k7Y2xhc3MgbGl7Y29uc3RydWN0b3IoKXtsaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPWxpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMsdGhpcy5fZW5kQ2FwU3R5bGU9bGkuQ0FQX1JPVU5ELHRoaXMuX2pvaW5TdHlsZT1saS5KT0lOX1JPVU5ELHRoaXMuX21pdHJlTGltaXQ9bGkuREVGQVVMVF9NSVRSRV9MSU1JVCx0aGlzLl9pc1NpbmdsZVNpZGVkPSExLHRoaXMuX3NpbXBsaWZ5RmFjdG9yPWxpLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpLHRoaXMuc2V0RW5kQ2FwU3R5bGUoZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpLHRoaXMuc2V0RW5kQ2FwU3R5bGUoZSksdGhpcy5zZXRKb2luU3R5bGUobiksdGhpcy5zZXRNaXRyZUxpbWl0KHMpfX1zdGF0aWMgYnVmZmVyRGlzdGFuY2VFcnJvcih0KXtjb25zdCBlPU1hdGguUEkvMi90O3JldHVybiAxLU1hdGguY29zKGUvMil9Z2V0RW5kQ2FwU3R5bGUoKXtyZXR1cm4gdGhpcy5fZW5kQ2FwU3R5bGV9aXNTaW5nbGVTaWRlZCgpe3JldHVybiB0aGlzLl9pc1NpbmdsZVNpZGVkfXNldFF1YWRyYW50U2VnbWVudHModCl7dGhpcy5fcXVhZHJhbnRTZWdtZW50cz10LDA9PT10aGlzLl9xdWFkcmFudFNlZ21lbnRzJiYodGhpcy5fam9pblN0eWxlPWxpLkpPSU5fQkVWRUwpLHRoaXMuX3F1YWRyYW50U2VnbWVudHM8MCYmKHRoaXMuX2pvaW5TdHlsZT1saS5KT0lOX01JVFJFLHRoaXMuX21pdHJlTGltaXQ9TWF0aC5hYnModGhpcy5fcXVhZHJhbnRTZWdtZW50cykpLHQ8PTAmJih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPTEpLHRoaXMuX2pvaW5TdHlsZSE9PWxpLkpPSU5fUk9VTkQmJih0aGlzLl9xdWFkcmFudFNlZ21lbnRzPWxpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMpfWdldEpvaW5TdHlsZSgpe3JldHVybiB0aGlzLl9qb2luU3R5bGV9c2V0Sm9pblN0eWxlKHQpe3RoaXMuX2pvaW5TdHlsZT10fXNldFNpbXBsaWZ5RmFjdG9yKHQpe3RoaXMuX3NpbXBsaWZ5RmFjdG9yPXQ8MD8wOnR9Z2V0U2ltcGxpZnlGYWN0b3IoKXtyZXR1cm4gdGhpcy5fc2ltcGxpZnlGYWN0b3J9Z2V0UXVhZHJhbnRTZWdtZW50cygpe3JldHVybiB0aGlzLl9xdWFkcmFudFNlZ21lbnRzfXNldEVuZENhcFN0eWxlKHQpe3RoaXMuX2VuZENhcFN0eWxlPXR9Z2V0TWl0cmVMaW1pdCgpe3JldHVybiB0aGlzLl9taXRyZUxpbWl0fXNldE1pdHJlTGltaXQodCl7dGhpcy5fbWl0cmVMaW1pdD10fXNldFNpbmdsZVNpZGVkKHQpe3RoaXMuX2lzU2luZ2xlU2lkZWQ9dH19bGkuQ0FQX1JPVU5EPTEsbGkuQ0FQX0ZMQVQ9MixsaS5DQVBfU1FVQVJFPTMsbGkuSk9JTl9ST1VORD0xLGxpLkpPSU5fTUlUUkU9MixsaS5KT0lOX0JFVkVMPTMsbGkuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUz04LGxpLkRFRkFVTFRfTUlUUkVfTElNSVQ9NSxsaS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUj0uMDE7Y2xhc3MgYWl7Y29uc3RydWN0b3IoKXthaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9taW5JbmRleD0tMSx0aGlzLl9taW5Db29yZD1udWxsLHRoaXMuX21pbkRlPW51bGwsdGhpcy5fb3JpZW50ZWREZT1udWxsfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fbWluQ29vcmR9Z2V0UmlnaHRtb3N0U2lkZSh0LGUpe2xldCBuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUpO3JldHVybiBuPDAmJihuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUtMSkpLG48MCYmKHRoaXMuX21pbkNvb3JkPW51bGwsdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCkpLG59ZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpe2NvbnN0IHQ9dGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zy5pc1RydWUodGhpcy5fbWluSW5kZXg+MCYmdGhpcy5fbWluSW5kZXg8dC5sZW5ndGgsXCJyaWdodG1vc3QgcG9pbnQgZXhwZWN0ZWQgdG8gYmUgaW50ZXJpb3IgdmVydGV4IG9mIGVkZ2VcIik7Y29uc3QgZT10W3RoaXMuX21pbkluZGV4LTFdLG49dFt0aGlzLl9taW5JbmRleCsxXSxzPUcuaW5kZXgodGhpcy5fbWluQ29vcmQsbixlKTtsZXQgaT0hMTsoZS55PHRoaXMuX21pbkNvb3JkLnkmJm4ueTx0aGlzLl9taW5Db29yZC55JiZzPT09Ry5DT1VOVEVSQ0xPQ0tXSVNFfHxlLnk+dGhpcy5fbWluQ29vcmQueSYmbi55PnRoaXMuX21pbkNvb3JkLnkmJnM9PT1HLkNMT0NLV0lTRSkmJihpPSEwKSxpJiYodGhpcy5fbWluSW5kZXg9dGhpcy5fbWluSW5kZXgtMSl9Z2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUpe2NvbnN0IG49dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlPDB8fGUrMT49bi5sZW5ndGgpcmV0dXJuLTE7aWYobltlXS55PT09bltlKzFdLnkpcmV0dXJuLTE7bGV0IHM9TW4uTEVGVDtyZXR1cm4gbltlXS55PG5bZSsxXS55JiYocz1Nbi5SSUdIVCksc31nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX29yaWVudGVkRGV9Y2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKHQpe2NvbnN0IGU9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoLTE7bisrKShudWxsPT09dGhpcy5fbWluQ29vcmR8fGVbbl0ueD50aGlzLl9taW5Db29yZC54KSYmKHRoaXMuX21pbkRlPXQsdGhpcy5fbWluSW5kZXg9bix0aGlzLl9taW5Db29yZD1lW25dKX1maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpe2NvbnN0IHQ9dGhpcy5fbWluRGUuZ2V0Tm9kZSgpLmdldEVkZ2VzKCk7dGhpcy5fbWluRGU9dC5nZXRSaWdodG1vc3RFZGdlKCksdGhpcy5fbWluRGUuaXNGb3J3YXJkKCl8fCh0aGlzLl9taW5EZT10aGlzLl9taW5EZS5nZXRTeW0oKSx0aGlzLl9taW5JbmRleD10aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSl9ZmluZEVkZ2UodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5pc0ZvcndhcmQoKSYmdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCl9Zy5pc1RydWUoMCE9PXRoaXMuX21pbkluZGV4fHx0aGlzLl9taW5Db29yZC5lcXVhbHModGhpcy5fbWluRGUuZ2V0Q29vcmRpbmF0ZSgpKSxcImluY29uc2lzdGVuY3kgaW4gcmlnaHRtb3N0IHByb2Nlc3NpbmdcIiksMD09PXRoaXMuX21pbkluZGV4P3RoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKTp0aGlzLmZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKSx0aGlzLl9vcmllbnRlZERlPXRoaXMuX21pbkRlO3RoaXMuZ2V0UmlnaHRtb3N0U2lkZSh0aGlzLl9taW5EZSx0aGlzLl9taW5JbmRleCk9PT1Nbi5MRUZUJiYodGhpcy5fb3JpZW50ZWREZT10aGlzLl9taW5EZS5nZXRTeW0oKSl9fWNsYXNzIGNpe2NvbnN0cnVjdG9yKCl7dGhpcy5hcnJheT1bXX1hZGRMYXN0KHQpe3RoaXMuYXJyYXkucHVzaCh0KX1yZW1vdmVGaXJzdCgpe3JldHVybiB0aGlzLmFycmF5LnNoaWZ0KCl9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5hcnJheS5sZW5ndGh9fWNsYXNzIGhpe2NvbnN0cnVjdG9yKCl7aGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZmluZGVyPW51bGwsdGhpcy5fZGlyRWRnZUxpc3Q9bmV3IEwsdGhpcy5fbm9kZXM9bmV3IEwsdGhpcy5fcmlnaHRNb3N0Q29vcmQ9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLl9maW5kZXI9bmV3IGFpfWNsZWFyVmlzaXRlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRWaXNpdGVkKCExKX19Z2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZH1jb21wdXRlTm9kZURlcHRoKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzVmlzaXRlZCgpfHx0LmdldFN5bSgpLmlzVmlzaXRlZCgpKXtlPXQ7YnJlYWt9fWlmKG51bGw9PT1lKXRocm93IG5ldyBzcyhcInVuYWJsZSB0byBmaW5kIGVkZ2UgdG8gY29tcHV0ZSBkZXB0aHMgYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpO3QuZ2V0RWRnZXMoKS5jb21wdXRlRGVwdGhzKGUpO2ZvcihsZXQgZT10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLmNvcHlTeW1EZXB0aHModCl9fWNvbXB1dGVEZXB0aCh0KXt0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9maW5kZXIuZ2V0RWRnZSgpO2UuZ2V0Tm9kZSgpLGUuZ2V0TGFiZWwoKTtlLnNldEVkZ2VEZXB0aHMoTW4uUklHSFQsdCksdGhpcy5jb3B5U3ltRGVwdGhzKGUpLHRoaXMuY29tcHV0ZURlcHRocyhlKX1jcmVhdGUodCl7dGhpcy5hZGRSZWFjaGFibGUodCksdGhpcy5fZmluZGVyLmZpbmRFZGdlKHRoaXMuX2RpckVkZ2VMaXN0KSx0aGlzLl9yaWdodE1vc3RDb29yZD10aGlzLl9maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpfWZpbmRSZXN1bHRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmdldERlcHRoKE1uLlJJR0hUKT49MSYmZS5nZXREZXB0aChNbi5MRUZUKTw9MCYmIWUuaXNJbnRlcmlvckFyZWFFZGdlKCkmJmUuc2V0SW5SZXN1bHQoITApfX1jb21wdXRlRGVwdGhzKHQpe2NvbnN0IGU9bmV3IHh0LG49bmV3IGNpLHM9dC5nZXROb2RlKCk7Zm9yKG4uYWRkTGFzdChzKSxlLmFkZChzKSx0LnNldFZpc2l0ZWQoITApOyFuLmlzRW1wdHkoKTspe2NvbnN0IHQ9bi5yZW1vdmVGaXJzdCgpO2UuYWRkKHQpLHRoaXMuY29tcHV0ZU5vZGVEZXB0aCh0KTtmb3IobGV0IHM9dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLmdldFN5bSgpO2lmKHQuaXNWaXNpdGVkKCkpY29udGludWU7Y29uc3QgaT10LmdldE5vZGUoKTtlLmNvbnRhaW5zKGkpfHwobi5hZGRMYXN0KGkpLGUuYWRkKGkpKX19fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX3JpZ2h0TW9zdENvb3JkLng8ZS5fcmlnaHRNb3N0Q29vcmQueD8tMTp0aGlzLl9yaWdodE1vc3RDb29yZC54PmUuX3JpZ2h0TW9zdENvb3JkLng/MTowfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7Y29uc3QgdD1uZXcgTztmb3IobGV0IGU9dGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aC0xO2UrKyl0LmV4cGFuZFRvSW5jbHVkZShuW2VdKX10aGlzLl9lbnY9dH1yZXR1cm4gdGhpcy5fZW52fWFkZFJlYWNoYWJsZSh0KXtjb25zdCBlPW5ldyBlbjtmb3IoZS5hZGQodCk7IWUuZW1wdHkoKTspe2NvbnN0IHQ9ZS5wb3AoKTt0aGlzLmFkZCh0LGUpfX1jb3B5U3ltRGVwdGhzKHQpe2NvbnN0IGU9dC5nZXRTeW0oKTtlLnNldERlcHRoKE1uLkxFRlQsdC5nZXREZXB0aChNbi5SSUdIVCkpLGUuc2V0RGVwdGgoTW4uUklHSFQsdC5nZXREZXB0aChNbi5MRUZUKSl9YWRkKHQsZSl7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLl9ub2Rlcy5hZGQodCk7Zm9yKGxldCBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLl9kaXJFZGdlTGlzdC5hZGQodCk7Y29uc3Qgcz10LmdldFN5bSgpLmdldE5vZGUoKTtzLmlzVmlzaXRlZCgpfHxlLnB1c2gocyl9fWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWdldERpcmVjdGVkRWRnZXMoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZUxpc3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyB1aXtjb25zdHJ1Y3Rvcigpe3VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3N0YXJ0RGU9bnVsbCx0aGlzLl9tYXhOb2RlRGVncmVlPS0xLHRoaXMuX2VkZ2VzPW5ldyBMLHRoaXMuX3B0cz1uZXcgTCx0aGlzLl9sYWJlbD1uZXcgcW4oUXQuTk9ORSksdGhpcy5fcmluZz1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuX3NoZWxsPW51bGwsdGhpcy5faG9sZXM9bmV3IEwsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1lLHRoaXMuY29tcHV0ZVBvaW50cyh0KSx0aGlzLmNvbXB1dGVSaW5nKCl9fWNvbXB1dGVSaW5nKCl7aWYobnVsbCE9PXRoaXMuX3JpbmcpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fcHRzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX3B0cy5zaXplKCk7ZSsrKXRbZV09dGhpcy5fcHRzLmdldChlKTt0aGlzLl9yaW5nPXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpLHRoaXMuX2lzSG9sZT1HLmlzQ0NXKHRoaXMuX3JpbmcuZ2V0Q29vcmRpbmF0ZXMoKSl9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWNvbXB1dGVQb2ludHModCl7dGhpcy5fc3RhcnREZT10O2xldCBlPXQsbj0hMDtkb3tpZihudWxsPT09ZSl0aHJvdyBuZXcgc3MoXCJGb3VuZCBudWxsIERpcmVjdGVkRWRnZVwiKTtpZihlLmdldEVkZ2VSaW5nKCk9PT10aGlzKXRocm93IG5ldyBzcyhcIkRpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCBcIitlLmdldENvb3JkaW5hdGUoKSk7dGhpcy5fZWRnZXMuYWRkKGUpO2NvbnN0IHQ9ZS5nZXRMYWJlbCgpO2cuaXNUcnVlKHQuaXNBcmVhKCkpLHRoaXMubWVyZ2VMYWJlbCh0KSx0aGlzLmFkZFBvaW50cyhlLmdldEVkZ2UoKSxlLmlzRm9yd2FyZCgpLG4pLG49ITEsdGhpcy5zZXRFZGdlUmluZyhlLHRoaXMpLGU9dGhpcy5nZXROZXh0KGUpfXdoaWxlKGUhPT10aGlzLl9zdGFydERlKX1nZXRMaW5lYXJSaW5nKCl7cmV0dXJuIHRoaXMuX3Jpbmd9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzLmdldCh0KX1jb21wdXRlTWF4Tm9kZURlZ3JlZSgpe3RoaXMuX21heE5vZGVEZWdyZWU9MDtsZXQgdD10aGlzLl9zdGFydERlO2Rve2NvbnN0IGU9dC5nZXROb2RlKCkuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzKTtlPnRoaXMuX21heE5vZGVEZWdyZWUmJih0aGlzLl9tYXhOb2RlRGVncmVlPWUpLHQ9dGhpcy5nZXROZXh0KHQpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKTt0aGlzLl9tYXhOb2RlRGVncmVlKj0yfWFkZFBvaW50cyh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCk7aWYoZSl7bGV0IHQ9MTtuJiYodD0wKTtmb3IobGV0IGU9dDtlPHMubGVuZ3RoO2UrKyl0aGlzLl9wdHMuYWRkKHNbZV0pfWVsc2V7bGV0IHQ9cy5sZW5ndGgtMjtuJiYodD1zLmxlbmd0aC0xKTtmb3IobGV0IGU9dDtlPj0wO2UtLSl0aGlzLl9wdHMuYWRkKHNbZV0pfX1pc0hvbGUoKXtyZXR1cm4gdGhpcy5faXNIb2xlfXNldEluUmVzdWx0KCl7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3t0LmdldEVkZ2UoKS5zZXRJblJlc3VsdCghMCksdD10LmdldE5leHQoKX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSl9Y29udGFpbnNQb2ludCh0KXtjb25zdCBlPXRoaXMuZ2V0TGluZWFyUmluZygpO2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyh0KSlyZXR1cm4hMTtpZighVWUuaXNJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpKXJldHVybiExO2ZvcihsZXQgZT10aGlzLl9ob2xlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7aWYoZS5uZXh0KCkuY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMX1yZXR1cm4hMH1hZGRIb2xlKHQpe3RoaXMuX2hvbGVzLmFkZCh0KX1pc1NoZWxsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9zaGVsbH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31nZXRNYXhOb2RlRGVncmVlKCl7cmV0dXJuIHRoaXMuX21heE5vZGVEZWdyZWU8MCYmdGhpcy5jb21wdXRlTWF4Tm9kZURlZ3JlZSgpLHRoaXMuX21heE5vZGVEZWdyZWV9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5fc2hlbGx9bWVyZ2VMYWJlbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodCwwKSx0aGlzLm1lcmdlTGFiZWwodCwxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1swXS5nZXRMb2NhdGlvbih0LE1uLlJJR0hUKTtpZihlPT09UXQuTk9ORSlyZXR1cm4gbnVsbDtpZih0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbih0KT09PVF0Lk5PTkUpcmV0dXJuIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSksbnVsbH19c2V0U2hlbGwodCl7dGhpcy5fc2hlbGw9dCxudWxsIT09dCYmdC5hZGRIb2xlKHRoaXMpfXRvUG9seWdvbih0KXtjb25zdCBlPW5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9ob2xlcy5zaXplKCk7dCsrKWVbdF09dGhpcy5faG9sZXMuZ2V0KHQpLmdldExpbmVhclJpbmcoKTtyZXR1cm4gdC5jcmVhdGVQb2x5Z29uKHRoaXMuZ2V0TGluZWFyUmluZygpLGUpfX1jbGFzcyBnaSBleHRlbmRzIHVpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxnaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt1aS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9c2V0RWRnZVJpbmcodCxlKXt0LnNldE1pbkVkZ2VSaW5nKGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dE1pbigpfX1jbGFzcyBkaSBleHRlbmRzIHVpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxkaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt1aS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9YnVpbGRNaW5pbWFsUmluZ3MoKXtjb25zdCB0PW5ldyBMO2xldCBlPXRoaXMuX3N0YXJ0RGU7ZG97aWYobnVsbD09PWUuZ2V0TWluRWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgZ2koZSx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO3QuYWRkKG4pfWU9ZS5nZXROZXh0KCl9d2hpbGUoZSE9PXRoaXMuX3N0YXJ0RGUpO3JldHVybiB0fXNldEVkZ2VSaW5nKHQsZSl7dC5zZXRFZGdlUmluZyhlKX1saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKXtsZXQgdD10aGlzLl9zdGFydERlO2Rve3QuZ2V0Tm9kZSgpLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMpLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dCgpfX1jbGFzcyBfaXtjb25zdHJ1Y3Rvcigpe19pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3NoZWxsTGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9dH1zdGF0aWMgZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpe2NvbnN0IG49dC5nZXRMaW5lYXJSaW5nKCkscz1uLmdldEVudmVsb3BlSW50ZXJuYWwoKTtsZXQgaT1uLmdldENvb3JkaW5hdGVOKDApLHI9bnVsbCxvPW51bGw7Zm9yKGxldCB0PWUuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbD1lLmdldExpbmVhclJpbmcoKSxhPWwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKGEuZXF1YWxzKHMpKWNvbnRpbnVlO2lmKCFhLmNvbnRhaW5zKHMpKWNvbnRpbnVlO2k9ZHQucHROb3RJbkxpc3Qobi5nZXRDb29yZGluYXRlcygpLGwuZ2V0Q29vcmRpbmF0ZXMoKSk7bGV0IGM9ITE7VWUuaXNJblJpbmcoaSxsLmdldENvb3JkaW5hdGVzKCkpJiYoYz0hMCksYyYmKG51bGw9PT1yfHxvLmNvbnRhaW5zKGEpKSYmKHI9ZSxvPXIuZ2V0TGluZWFyUmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9cmV0dXJuIHJ9c29ydFNoZWxsc0FuZEhvbGVzKHQsZSxuKXtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzSG9sZSgpP24uYWRkKHQpOmUuYWRkKHQpfX1jb21wdXRlUG9seWdvbnModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKS50b1BvbHlnb24odGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZCh0KX1yZXR1cm4gZX1wbGFjZUZyZWVIb2xlcyh0LGUpe2ZvcihsZXQgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBlPW4ubmV4dCgpO2lmKG51bGw9PT1lLmdldFNoZWxsKCkpe2NvbnN0IG49X2kuZmluZEVkZ2VSaW5nQ29udGFpbmluZyhlLHQpO2lmKG51bGw9PT1uKXRocm93IG5ldyBzcyhcInVuYWJsZSB0byBhc3NpZ24gaG9sZSB0byBhIHNoZWxsXCIsZS5nZXRDb29yZGluYXRlKDApKTtlLnNldFNoZWxsKG4pfX19YnVpbGRNaW5pbWFsRWRnZVJpbmdzKHQsZSxuKXtjb25zdCBzPW5ldyBMO2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpO2lmKHQuZ2V0TWF4Tm9kZURlZ3JlZSgpPjIpe3QubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7Y29uc3Qgcz10LmJ1aWxkTWluaW1hbFJpbmdzKCksaT10aGlzLmZpbmRTaGVsbChzKTtudWxsIT09aT8odGhpcy5wbGFjZVBvbHlnb25Ib2xlcyhpLHMpLGUuYWRkKGkpKTpuLmFkZEFsbChzKX1lbHNlIHMuYWRkKHQpfXJldHVybiBzfWJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKHQuaXNJblJlc3VsdCgpJiZ0LmdldExhYmVsKCkuaXNBcmVhKCkmJm51bGw9PT10LmdldEVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IGRpKHQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChuKSxuLnNldEluUmVzdWx0KCl9fXJldHVybiBlfXBsYWNlUG9seWdvbkhvbGVzKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7ZS5pc0hvbGUoKSYmZS5zZXRTaGVsbCh0KX19Z2V0UG9seWdvbnMoKXtyZXR1cm4gdGhpcy5jb21wdXRlUG9seWdvbnModGhpcy5fc2hlbGxMaXN0KX1maW5kU2hlbGwodCl7bGV0IGU9MCxuPW51bGw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc0hvbGUoKXx8KG49dCxlKyspfXJldHVybiBnLmlzVHJ1ZShlPD0xLFwiZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdFwiKSxufWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LmdldEVkZ2VFbmRzKCksdC5nZXROb2RlcygpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtvcy5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhlKTtjb25zdCBuPXRoaXMuYnVpbGRNYXhpbWFsRWRnZVJpbmdzKHQpLHM9bmV3IEwsaT10aGlzLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyhuLHRoaXMuX3NoZWxsTGlzdCxzKTt0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhpLHRoaXMuX3NoZWxsTGlzdCxzKSx0aGlzLnBsYWNlRnJlZUhvbGVzKHRoaXMuX3NoZWxsTGlzdCxzKX19fWNsYXNzIHBpe2NvbnN0cnVjdG9yKCl7cGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRMaW5lPW51bGwsdGhpcy5fZGlzdGFuY2VUb2w9bnVsbCx0aGlzLl9pc0RlbGV0ZWQ9bnVsbCx0aGlzLl9hbmdsZU9yaWVudGF0aW9uPUcuQ09VTlRFUkNMT0NLV0lTRTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dExpbmU9dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtyZXR1cm4gbmV3IHBpKHQpLnNpbXBsaWZ5KGUpfWlzRGVsZXRhYmxlKHQsZSxuLHMpe2NvbnN0IGk9dGhpcy5faW5wdXRMaW5lW3RdLHI9dGhpcy5faW5wdXRMaW5lW2VdLG89dGhpcy5faW5wdXRMaW5lW25dO3JldHVybiEhdGhpcy5pc0NvbmNhdmUoaSxyLG8pJiYoISF0aGlzLmlzU2hhbGxvdyhpLHIsbyxzKSYmdGhpcy5pc1NoYWxsb3dTYW1wbGVkKGkscix0LG4scykpfWRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpe2xldCB0PTEsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKSxzPSExO2Zvcig7bjx0aGlzLl9pbnB1dExpbmUubGVuZ3RoOyl7bGV0IGk9ITE7dGhpcy5pc0RlbGV0YWJsZSh0LGUsbix0aGlzLl9kaXN0YW5jZVRvbCkmJih0aGlzLl9pc0RlbGV0ZWRbZV09cGkuREVMRVRFLGk9ITAscz0hMCksdD1pP246ZSxlPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpfXJldHVybiBzfWlzU2hhbGxvd0NvbmNhdml0eSh0LGUsbixzKXtpZighKEcuaW5kZXgodCxlLG4pPT09dGhpcy5fYW5nbGVPcmllbnRhdGlvbikpcmV0dXJuITE7cmV0dXJuIFYucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9aXNTaGFsbG93U2FtcGxlZCh0LGUsbixzLGkpe2xldCByPU1hdGgudHJ1bmMoKHMtbikvcGkuTlVNX1BUU19UT19DSEVDSyk7cjw9MCYmKHI9MSk7Zm9yKGxldCBvPW47bzxzO28rPXIpaWYoIXRoaXMuaXNTaGFsbG93KHQsZSx0aGlzLl9pbnB1dExpbmVbb10saSkpcmV0dXJuITE7cmV0dXJuITB9aXNDb25jYXZlKHQsZSxuKXtyZXR1cm4gRy5pbmRleCh0LGUsbik9PT10aGlzLl9hbmdsZU9yaWVudGF0aW9ufXNpbXBsaWZ5KHQpe3RoaXMuX2Rpc3RhbmNlVG9sPU1hdGguYWJzKHQpLHQ8MCYmKHRoaXMuX2FuZ2xlT3JpZW50YXRpb249Ry5DTE9DS1dJU0UpLHRoaXMuX2lzRGVsZXRlZD1uZXcgQXJyYXkodGhpcy5faW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTtsZXQgZT0hMTtkb3tlPXRoaXMuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCl9d2hpbGUoZSk7cmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKCl9ZmluZE5leHROb25EZWxldGVkSW5kZXgodCl7bGV0IGU9dCsxO2Zvcig7ZTx0aGlzLl9pbnB1dExpbmUubGVuZ3RoJiZ0aGlzLl9pc0RlbGV0ZWRbZV09PT1waS5ERUxFVEU7KWUrKztyZXR1cm4gZX1pc1NoYWxsb3codCxlLG4scyl7cmV0dXJuIFYucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9Y29sbGFwc2VMaW5lKCl7Y29uc3QgdD1uZXcgUjtmb3IobGV0IGU9MDtlPHRoaXMuX2lucHV0TGluZS5sZW5ndGg7ZSsrKXRoaXMuX2lzRGVsZXRlZFtlXSE9PXBpLkRFTEVURSYmdC5hZGQodGhpcy5faW5wdXRMaW5lW2VdKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfX1waS5JTklUPTAscGkuREVMRVRFPTEscGkuS0VFUD0xLHBpLk5VTV9QVFNfVE9fQ0hFQ0s9MTA7Y2xhc3MgbWl7Y29uc3RydWN0b3IoKXttaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdExpc3Q9bnVsbCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZT0wLHRoaXMuX3B0TGlzdD1uZXcgTH1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdExpc3QudG9BcnJheShtaS5DT09SRElOQVRFX0FSUkFZX1RZUEUpfXNldFByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3ByZWNpc2lvbk1vZGVsPXR9YWRkUHQodCl7Y29uc3QgZT1uZXcgbSh0KTtpZih0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShlKSx0aGlzLmlzUmVkdW5kYW50KGUpKXJldHVybiBudWxsO3RoaXMuX3B0TGlzdC5hZGQoZSl9cmV2ZXJzZSgpe31hZGRQdHModCxlKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMuYWRkUHQodFtlXSk7ZWxzZSBmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl0aGlzLmFkZFB0KHRbZV0pfWlzUmVkdW5kYW50KHQpe2lmKHRoaXMuX3B0TGlzdC5zaXplKCk8MSlyZXR1cm4hMTtjb25zdCBlPXRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKS0xKTtyZXR1cm4gdC5kaXN0YW5jZShlKTx0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2V9dG9TdHJpbmcoKXtyZXR1cm4obmV3IEN0KS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkudG9TdHJpbmcoKX1jbG9zZVJpbmcoKXtpZih0aGlzLl9wdExpc3Quc2l6ZSgpPDEpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgbSh0aGlzLl9wdExpc3QuZ2V0KDApKSxlPXRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKS0xKTtpZih0LmVxdWFscyhlKSlyZXR1cm4gbnVsbDt0aGlzLl9wdExpc3QuYWRkKHQpfXNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KXt0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2U9dH19bWkuQ09PUkRJTkFURV9BUlJBWV9UWVBFPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIGZpe2NvbnN0cnVjdG9yKCl7ZmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3I9MCx0aGlzLl9maWxsZXRBbmdsZVF1YW50dW09bnVsbCx0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPTEsdGhpcy5fc2VnTGlzdD1udWxsLHRoaXMuX2Rpc3RhbmNlPTAsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9idWZQYXJhbXM9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX3MwPW51bGwsdGhpcy5fczE9bnVsbCx0aGlzLl9zMj1udWxsLHRoaXMuX3NlZzA9bmV3IEt0LHRoaXMuX3NlZzE9bmV3IEt0LHRoaXMuX29mZnNldDA9bmV3IEt0LHRoaXMuX29mZnNldDE9bmV3IEt0LHRoaXMuX3NpZGU9MCx0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9idWZQYXJhbXM9ZSx0aGlzLl9saT1uZXcganQsdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtPU1hdGguUEkvMi9lLmdldFF1YWRyYW50U2VnbWVudHMoKSxlLmdldFF1YWRyYW50U2VnbWVudHMoKT49OCYmZS5nZXRKb2luU3R5bGUoKT09PWxpLkpPSU5fUk9VTkQmJih0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPWZpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SKSx0aGlzLmluaXQobil9YWRkTmV4dFNlZ21lbnQodCxlKXtpZih0aGlzLl9zMD10aGlzLl9zMSx0aGlzLl9zMT10aGlzLl9zMix0aGlzLl9zMj10LHRoaXMuX3NlZzAuc2V0Q29vcmRpbmF0ZXModGhpcy5fczAsdGhpcy5fczEpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMCx0aGlzLl9zaWRlLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDApLHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModGhpcy5fczEsdGhpcy5fczIpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSx0aGlzLl9zaWRlLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDEpLHRoaXMuX3MxLmVxdWFscyh0aGlzLl9zMikpcmV0dXJuIG51bGw7Y29uc3Qgbj1HLmluZGV4KHRoaXMuX3MwLHRoaXMuX3MxLHRoaXMuX3MyKSxzPW49PT1HLkNMT0NLV0lTRSYmdGhpcy5fc2lkZT09PU1uLkxFRlR8fG49PT1HLkNPVU5URVJDTE9DS1dJU0UmJnRoaXMuX3NpZGU9PT1Nbi5SSUdIVDswPT09bj90aGlzLmFkZENvbGxpbmVhcihlKTpzP3RoaXMuYWRkT3V0c2lkZVR1cm4obixlKTp0aGlzLmFkZEluc2lkZVR1cm4obixlKX1hZGRMaW5lRW5kQ2FwKHQsZSl7Y29uc3Qgbj1uZXcgS3QodCxlKSxzPW5ldyBLdDt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sTW4uTEVGVCx0aGlzLl9kaXN0YW5jZSxzKTtjb25zdCBpPW5ldyBLdDt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sTW4uUklHSFQsdGhpcy5fZGlzdGFuY2UsaSk7Y29uc3Qgcj1lLngtdC54LG89ZS55LXQueSxsPU1hdGguYXRhbjIobyxyKTtzd2l0Y2godGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgbGkuQ0FQX1JPVU5EOnRoaXMuX3NlZ0xpc3QuYWRkUHQocy5wMSksdGhpcy5hZGREaXJlY3RlZEZpbGxldChlLGwrTWF0aC5QSS8yLGwtTWF0aC5QSS8yLEcuQ0xPQ0tXSVNFLHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGkucDEpO2JyZWFrO2Nhc2UgbGkuQ0FQX0ZMQVQ6dGhpcy5fc2VnTGlzdC5hZGRQdChzLnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KGkucDEpO2JyZWFrO2Nhc2UgbGkuQ0FQX1NRVUFSRTpjb25zdCB0PW5ldyBtO3QueD1NYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkqTWF0aC5jb3MobCksdC55PU1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSpNYXRoLnNpbihsKTtjb25zdCBuPW5ldyBtKHMucDEueCt0Lngscy5wMS55K3QueSkscj1uZXcgbShpLnAxLngrdC54LGkucDEueSt0LnkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQobiksdGhpcy5fc2VnTGlzdC5hZGRQdChyKX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fc2VnTGlzdC5nZXRDb29yZGluYXRlcygpfWFkZE1pdHJlSm9pbih0LGUsbixzKXtjb25zdCBpPXEuaW50ZXJzZWN0aW9uKGUucDAsZS5wMSxuLnAwLG4ucDEpO2lmKG51bGwhPT1pKXtpZigoczw9MD8xOmkuZGlzdGFuY2UodCkvTWF0aC5hYnMocykpPD10aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKXJldHVybiB0aGlzLl9zZWdMaXN0LmFkZFB0KGkpLG51bGx9dGhpcy5hZGRMaW1pdGVkTWl0cmVKb2luKGUsbixzLHRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpfWFkZE91dHNpZGVUdXJuKHQsZSl7aWYodGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKTx0aGlzLl9kaXN0YW5jZSpmaS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUilyZXR1cm4gdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSxudWxsO3RoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWxpLkpPSU5fTUlUUkU/dGhpcy5hZGRNaXRyZUpvaW4odGhpcy5fczEsdGhpcy5fb2Zmc2V0MCx0aGlzLl9vZmZzZXQxLHRoaXMuX2Rpc3RhbmNlKTp0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1saS5KT0lOX0JFVkVMP3RoaXMuYWRkQmV2ZWxKb2luKHRoaXMuX29mZnNldDAsdGhpcy5fb2Zmc2V0MSk6KGUmJnRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSksdGhpcy5hZGRDb3JuZXJGaWxsZXQodGhpcy5fczEsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHQsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCkpfWNyZWF0ZVNxdWFyZSh0KXt0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueCt0aGlzLl9kaXN0YW5jZSx0LnkrdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueCt0aGlzLl9kaXN0YW5jZSx0LnktdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueC10aGlzLl9kaXN0YW5jZSx0LnktdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBtKHQueC10aGlzLl9kaXN0YW5jZSx0LnkrdGhpcy5fZGlzdGFuY2UpKSx0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWFkZFNlZ21lbnRzKHQsZSl7dGhpcy5fc2VnTGlzdC5hZGRQdHModCxlKX1hZGRGaXJzdFNlZ21lbnQoKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApfWFkZENvcm5lckZpbGxldCh0LGUsbixzLGkpe2NvbnN0IHI9ZS54LXQueCxvPWUueS10Lnk7bGV0IGw9TWF0aC5hdGFuMihvLHIpO2NvbnN0IGE9bi54LXQueCxjPW4ueS10LnksaD1NYXRoLmF0YW4yKGMsYSk7cz09PUcuQ0xPQ0tXSVNFP2w8PWgmJihsKz0yKk1hdGguUEkpOmw+PWgmJihsLT0yKk1hdGguUEkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGREaXJlY3RlZEZpbGxldCh0LGwsaCxzLGkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobil9YWRkTGFzdFNlZ21lbnQoKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDEpfWluaXRTaWRlU2VnbWVudHModCxlLG4pe3RoaXMuX3MxPXQsdGhpcy5fczI9ZSx0aGlzLl9zaWRlPW4sdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyh0LGUpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSxuLHRoaXMuX2Rpc3RhbmNlLHRoaXMuX29mZnNldDEpfWFkZExpbWl0ZWRNaXRyZUpvaW4odCxlLG4scyl7Y29uc3QgaT10aGlzLl9zZWcwLnAxLHI9JHQuYW5nbGUoaSx0aGlzLl9zZWcwLnAwKSxvPSR0LmFuZ2xlQmV0d2Vlbk9yaWVudGVkKHRoaXMuX3NlZzAucDAsaSx0aGlzLl9zZWcxLnAxKS8yLGw9JHQubm9ybWFsaXplKHIrbyksYT0kdC5ub3JtYWxpemUobCtNYXRoLlBJKSxjPXMqbixoPW4tYypNYXRoLmFicyhNYXRoLnNpbihvKSksdT1pLngrYypNYXRoLmNvcyhhKSxnPWkueStjKk1hdGguc2luKGEpLGQ9bmV3IG0odSxnKSxfPW5ldyBLdChpLGQpLHA9Xy5wb2ludEFsb25nT2Zmc2V0KDEsaCksZj1fLnBvaW50QWxvbmdPZmZzZXQoMSwtaCk7dGhpcy5fc2lkZT09PU1uLkxFRlQ/KHRoaXMuX3NlZ0xpc3QuYWRkUHQocCksdGhpcy5fc2VnTGlzdC5hZGRQdChmKSk6KHRoaXMuX3NlZ0xpc3QuYWRkUHQoZiksdGhpcy5fc2VnTGlzdC5hZGRQdChwKSl9YWRkRGlyZWN0ZWRGaWxsZXQodCxlLG4scyxpKXtjb25zdCByPXM9PT1HLkNMT0NLV0lTRT8tMToxLG89TWF0aC5hYnMoZS1uKSxsPU1hdGgudHJ1bmMoby90aGlzLl9maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKGw8MSlyZXR1cm4gbnVsbDtjb25zdCBhPW8vbCxjPW5ldyBtO2ZvcihsZXQgbj0wO248bDtuKyspe2NvbnN0IHM9ZStyKm4qYTtjLng9dC54K2kqTWF0aC5jb3MocyksYy55PXQueStpKk1hdGguc2luKHMpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoYyl9fWNvbXB1dGVPZmZzZXRTZWdtZW50KHQsZSxuLHMpe2NvbnN0IGk9ZT09PU1uLkxFRlQ/MTotMSxyPXQucDEueC10LnAwLngsbz10LnAxLnktdC5wMC55LGw9TWF0aC5zcXJ0KHIqcitvKm8pLGE9aSpuKnIvbCxjPWkqbipvL2w7cy5wMC54PXQucDAueC1jLHMucDAueT10LnAwLnkrYSxzLnAxLng9dC5wMS54LWMscy5wMS55PXQucDEueSthfWFkZEluc2lkZVR1cm4odCxlKXtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX29mZnNldDAucDAsdGhpcy5fb2Zmc2V0MC5wMSx0aGlzLl9vZmZzZXQxLnAwLHRoaXMuX29mZnNldDEucDEpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKXRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtlbHNlIGlmKHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMCx0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApPHRoaXMuX2Rpc3RhbmNlKmZpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpO2Vsc2V7aWYodGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPjApe2NvbnN0IHQ9bmV3IG0oKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MC5wMS54K3RoaXMuX3MxLngpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDAucDEueSt0aGlzLl9zMS55KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5fc2VnTGlzdC5hZGRQdCh0KTtjb25zdCBlPW5ldyBtKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDEucDAueCt0aGlzLl9zMS54KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQxLnAwLnkrdGhpcy5fczEueSkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQoZSl9ZWxzZSB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX3MxKTt0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApfX1jcmVhdGVDaXJjbGUodCl7Y29uc3QgZT1uZXcgbSh0LngrdGhpcy5fZGlzdGFuY2UsdC55KTt0aGlzLl9zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRGlyZWN0ZWRGaWxsZXQodCwwLDIqTWF0aC5QSSwtMSx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKX1hZGRCZXZlbEpvaW4odCxlKXt0aGlzLl9zZWdMaXN0LmFkZFB0KHQucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoZS5wMCl9aW5pdCh0KXt0aGlzLl9kaXN0YW5jZT10LHRoaXMuX21heEN1cnZlU2VnbWVudEVycm9yPXQqKDEtTWF0aC5jb3ModGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtLzIpKSx0aGlzLl9zZWdMaXN0PW5ldyBtaSx0aGlzLl9zZWdMaXN0LnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3ByZWNpc2lvbk1vZGVsKSx0aGlzLl9zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KmZpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil9YWRkQ29sbGluZWFyKHQpe3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fczAsdGhpcy5fczEsdGhpcy5fczEsdGhpcy5fczIpO3RoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpPj0yJiYodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09bGkuSk9JTl9CRVZFTHx8dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09bGkuSk9JTl9NSVRSRT8odCYmdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApKTp0aGlzLmFkZENvcm5lckZpbGxldCh0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsRy5DTE9DS1dJU0UsdGhpcy5fZGlzdGFuY2UpKX1jbG9zZVJpbmcoKXt0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWhhc05hcnJvd0NvbmNhdmVBbmdsZSgpe3JldHVybiB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGV9fWZpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SPS4wMDEsZmkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPS4wMDEsZmkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPTFlLTYsZmkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1I9ODA7Y2xhc3MgeWl7Y29uc3RydWN0b3IoKXt5aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9kaXN0YW5jZT0wLHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYnVmUGFyYW1zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9idWZQYXJhbXM9ZX1zdGF0aWMgY29weUNvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWVbbl09bmV3IG0odFtuXSk7cmV0dXJuIGV9Z2V0T2Zmc2V0Q3VydmUodCxlKXtpZih0aGlzLl9kaXN0YW5jZT1lLDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49ZTwwLHM9TWF0aC5hYnMoZSksaT10aGlzLmdldFNlZ0dlbihzKTt0Lmxlbmd0aDw9MT90aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0saSk6dGhpcy5jb21wdXRlT2Zmc2V0Q3VydmUodCxuLGkpO2NvbnN0IHI9aS5nZXRDb29yZGluYXRlcygpO3JldHVybiBuJiZkdC5yZXZlcnNlKHIpLHJ9Y29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxlLG4pe2NvbnN0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7aWYoZSl7bi5hZGRTZWdtZW50cyh0LCEwKTtjb25zdCBlPXBpLnNpbXBsaWZ5KHQsLXMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVtpXSxlW2ktMV0sTW4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9aS0yO3Q+PTA7dC0tKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9ZWxzZXtuLmFkZFNlZ21lbnRzKHQsITEpO2NvbnN0IGU9cGkuc2ltcGxpZnkodCxzKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbMF0sZVsxXSxNbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpLG4uY2xvc2VSaW5nKCl9Y29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSh0LGUsbil7bGV0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7ZT09PU1uLlJJR0hUJiYocz0tcyk7Y29uc3QgaT1waS5zaW1wbGlmeSh0LHMpLHI9aS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoaVtyLTFdLGlbMF0sZSk7Zm9yKGxldCB0PTE7dDw9cjt0Kyspe2NvbnN0IGU9MSE9PXQ7bi5hZGROZXh0U2VnbWVudChpW3RdLGUpfW4uY2xvc2VSaW5nKCl9Y29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LGUpe2NvbnN0IG49dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSkscz1waS5zaW1wbGlmeSh0LG4pLGk9cy5sZW5ndGgtMTtlLmluaXRTaWRlU2VnbWVudHMoc1swXSxzWzFdLE1uLkxFRlQpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKWUuYWRkTmV4dFNlZ21lbnQoc1t0XSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChzW2ktMV0sc1tpXSk7Y29uc3Qgcj1waS5zaW1wbGlmeSh0LC1uKSxvPXIubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKHJbb10scltvLTFdLE1uLkxFRlQpO2ZvcihsZXQgdD1vLTI7dD49MDt0LS0pZS5hZGROZXh0U2VnbWVudChyW3RdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKHJbMV0sclswXSksZS5jbG9zZVJpbmcoKX1jb21wdXRlUG9pbnRDdXJ2ZSh0LGUpe3N3aXRjaCh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBsaS5DQVBfUk9VTkQ6ZS5jcmVhdGVDaXJjbGUodCk7YnJlYWs7Y2FzZSBsaS5DQVBfU1FVQVJFOmUuY3JlYXRlU3F1YXJlKHQpfX1nZXRMaW5lQ3VydmUodCxlKXtpZih0aGlzLl9kaXN0YW5jZT1lLHRoaXMuaXNMaW5lT2Zmc2V0RW1wdHkoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj1NYXRoLmFicyhlKSxzPXRoaXMuZ2V0U2VnR2VuKG4pO2lmKHQubGVuZ3RoPD0xKXRoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxzKTtlbHNlIGlmKHRoaXMuX2J1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpe2NvbnN0IG49ZTwwO3RoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxuLHMpfWVsc2UgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQscyk7cmV0dXJuIHMuZ2V0Q29vcmRpbmF0ZXMoKX1nZXRCdWZmZXJQYXJhbWV0ZXJzKCl7cmV0dXJuIHRoaXMuX2J1ZlBhcmFtc31zaW1wbGlmeVRvbGVyYW5jZSh0KXtyZXR1cm4gdCp0aGlzLl9idWZQYXJhbXMuZ2V0U2ltcGxpZnlGYWN0b3IoKX1nZXRSaW5nQ3VydmUodCxlLG4pe2lmKHRoaXMuX2Rpc3RhbmNlPW4sdC5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuZ2V0TGluZUN1cnZlKHQsbik7aWYoMD09PW4pcmV0dXJuIHlpLmNvcHlDb29yZGluYXRlcyh0KTtjb25zdCBzPXRoaXMuZ2V0U2VnR2VuKG4pO3JldHVybiB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLHMpLHMuZ2V0Q29vcmRpbmF0ZXMoKX1jb21wdXRlT2Zmc2V0Q3VydmUodCxlLG4pe2NvbnN0IHM9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7aWYoZSl7Y29uc3QgZT1waS5zaW1wbGlmeSh0LC1zKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbaV0sZVtpLTFdLE1uLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PWktMjt0Pj0wO3QtLSluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfWVsc2V7Y29uc3QgZT1waS5zaW1wbGlmeSh0LHMpLGk9ZS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoZVswXSxlWzFdLE1uLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PTI7dDw9aTt0Kyspbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1uLmFkZExhc3RTZWdtZW50KCl9aXNMaW5lT2Zmc2V0RW1wdHkodCl7cmV0dXJuIDA9PT10fHx0PDAmJiF0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpfWdldFNlZ0dlbih0KXtyZXR1cm4gbmV3IGZpKHRoaXMuX3ByZWNpc2lvbk1vZGVsLHRoaXMuX2J1ZlBhcmFtcyx0KX19Y2xhc3MgeGl7Y29uc3RydWN0b3IoKXt4aS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zdWJncmFwaHM9bnVsbCx0aGlzLl9zZWc9bmV3IEt0O2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmdyYXBocz10fWZpbmRTdGFiYmVkU2VnbWVudHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtmb3IobGV0IG49dGhpcy5fc3ViZ3JhcGhzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5nZXRFbnZlbG9wZSgpO3QueTxpLmdldE1pblkoKXx8dC55PmkuZ2V0TWF4WSgpfHx0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCxzLmdldERpcmVjdGVkRWRnZXMoKSxlKX1yZXR1cm4gZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihJKGFyZ3VtZW50c1syXSx3KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGlzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBpPTA7aTxzLmxlbmd0aC0xO2krKyl7dGhpcy5fc2VnLnAwPXNbaV0sdGhpcy5fc2VnLnAxPXNbaSsxXSx0aGlzLl9zZWcucDAueT50aGlzLl9zZWcucDEueSYmdGhpcy5fc2VnLnJldmVyc2UoKTtpZihNYXRoLm1heCh0aGlzLl9zZWcucDAueCx0aGlzLl9zZWcucDEueCk8dC54KWNvbnRpbnVlO2lmKHRoaXMuX3NlZy5pc0hvcml6b250YWwoKSljb250aW51ZTtpZih0Lnk8dGhpcy5fc2VnLnAwLnl8fHQueT50aGlzLl9zZWcucDEueSljb250aW51ZTtpZihHLmluZGV4KHRoaXMuX3NlZy5wMCx0aGlzLl9zZWcucDEsdCk9PT1HLlJJR0hUKWNvbnRpbnVlO2xldCByPWUuZ2V0RGVwdGgoTW4uTEVGVCk7dGhpcy5fc2VnLnAwLmVxdWFscyhzW2ldKXx8KHI9ZS5nZXREZXB0aChNbi5SSUdIVCkpO2NvbnN0IG89bmV3IEVpKHRoaXMuX3NlZyxyKTtuLmFkZChvKX19ZWxzZSBpZihJKGFyZ3VtZW50c1syXSx3KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtJiZJKGFyZ3VtZW50c1sxXSx3KSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMl07Zm9yKGxldCBuPWFyZ3VtZW50c1sxXS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmlzRm9yd2FyZCgpJiZ0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCxzLGUpfX19Z2V0RGVwdGgodCl7Y29uc3QgZT10aGlzLmZpbmRTdGFiYmVkU2VnbWVudHModCk7aWYoMD09PWUuc2l6ZSgpKXJldHVybiAwO3JldHVybiB4ZS5taW4oZSkuX2xlZnREZXB0aH19Y2xhc3MgRWl7Y29uc3RydWN0b3IoKXtFaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl91cHdhcmRTZWc9bnVsbCx0aGlzLl9sZWZ0RGVwdGg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl91cHdhcmRTZWc9bmV3IEt0KHQpLHRoaXMuX2xlZnREZXB0aD1lfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7aWYodGhpcy5fdXB3YXJkU2VnLm1pblgoKT49ZS5fdXB3YXJkU2VnLm1heFgoKSlyZXR1cm4gMTtpZih0aGlzLl91cHdhcmRTZWcubWF4WCgpPD1lLl91cHdhcmRTZWcubWluWCgpKXJldHVybi0xO2xldCBuPXRoaXMuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KGUuX3Vwd2FyZFNlZyk7cmV0dXJuIDAhPT1uP246KG49LTEqZS5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy5fdXB3YXJkU2VnKSwwIT09bj9uOnRoaXMuX3Vwd2FyZFNlZy5jb21wYXJlVG8oZS5fdXB3YXJkU2VnKSl9Y29tcGFyZVgodCxlKXtjb25zdCBuPXQucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnQucDEuY29tcGFyZVRvKGUucDEpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuX3Vwd2FyZFNlZy50b1N0cmluZygpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19eGkuRGVwdGhTZWdtZW50PUVpO2NsYXNzIElpe2NvbnN0cnVjdG9yKCl7SWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bnVsbCx0aGlzLl9jdXJ2ZUxpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5fZGlzdGFuY2U9ZSx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bn1hZGRSaW5nU2lkZSh0LGUsbixzLGkpe2lmKDA9PT1lJiZ0Lmxlbmd0aDx1dC5NSU5JTVVNX1ZBTElEX1NJWkUpcmV0dXJuIG51bGw7bGV0IHI9cyxvPWk7dC5sZW5ndGg+PXV0Lk1JTklNVU1fVkFMSURfU0laRSYmRy5pc0NDVyh0KSYmKHI9aSxvPXMsbj1Nbi5vcHBvc2l0ZShuKSk7Y29uc3QgbD10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0UmluZ0N1cnZlKHQsbixlKTt0aGlzLmFkZEN1cnZlKGwscixvKX1hZGRSaW5nQm90aFNpZGVzKHQsZSl7dGhpcy5hZGRSaW5nU2lkZSh0LGUsTW4uTEVGVCxRdC5FWFRFUklPUixRdC5JTlRFUklPUiksdGhpcy5hZGRSaW5nU2lkZSh0LGUsTW4uUklHSFQsUXQuSU5URVJJT1IsUXQuRVhURVJJT1IpfWFkZFBvaW50KHQpe2lmKHRoaXMuX2Rpc3RhbmNlPD0wKXJldHVybiBudWxsO2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLG49dGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuX2Rpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpfWFkZFBvbHlnb24odCl7bGV0IGU9dGhpcy5fZGlzdGFuY2Usbj1Nbi5MRUZUO3RoaXMuX2Rpc3RhbmNlPDAmJihlPS10aGlzLl9kaXN0YW5jZSxuPU1uLlJJR0hUKTtjb25zdCBzPXQuZ2V0RXh0ZXJpb3JSaW5nKCksaT1kdC5yZW1vdmVSZXBlYXRlZFBvaW50cyhzLmdldENvb3JkaW5hdGVzKCkpO2lmKHRoaXMuX2Rpc3RhbmNlPDAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KHMsdGhpcy5fZGlzdGFuY2UpKXJldHVybiBudWxsO2lmKHRoaXMuX2Rpc3RhbmNlPD0wJiZpLmxlbmd0aDwzKXJldHVybiBudWxsO3RoaXMuYWRkUmluZ1NpZGUoaSxlLG4sUXQuRVhURVJJT1IsUXQuSU5URVJJT1IpO2ZvcihsZXQgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe2NvbnN0IGk9dC5nZXRJbnRlcmlvclJpbmdOKHMpLHI9ZHQucmVtb3ZlUmVwZWF0ZWRQb2ludHMoaS5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9kaXN0YW5jZT4wJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShpLC10aGlzLl9kaXN0YW5jZSl8fHRoaXMuYWRkUmluZ1NpZGUocixlLE1uLm9wcG9zaXRlKG4pLFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SKX19aXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkodCxlKXtjb25zdCBuPW5ldyBuZSh0WzBdLHRbMV0sdFsyXSkscz1uLmluQ2VudHJlKCk7cmV0dXJuIFYucG9pbnRUb1NlZ21lbnQocyxuLnAwLG4ucDEpPE1hdGguYWJzKGUpfWFkZExpbmVTdHJpbmcodCl7aWYodGhpcy5fY3VydmVCdWlsZGVyLmlzTGluZU9mZnNldEVtcHR5KHRoaXMuX2Rpc3RhbmNlKSlyZXR1cm4gbnVsbDtjb25zdCBlPWR0LnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZHQuaXNSaW5nKGUpJiYhdGhpcy5fY3VydmVCdWlsZGVyLmdldEJ1ZmZlclBhcmFtZXRlcnMoKS5pc1NpbmdsZVNpZGVkKCkpdGhpcy5hZGRSaW5nQm90aFNpZGVzKGUsdGhpcy5fZGlzdGFuY2UpO2Vsc2V7Y29uc3QgdD10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5fZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUodCxRdC5FWFRFUklPUixRdC5JTlRFUklPUil9fWFkZEN1cnZlKHQsZSxuKXtpZihudWxsPT09dHx8dC5sZW5ndGg8MilyZXR1cm4gbnVsbDtjb25zdCBzPW5ldyBXcyh0LG5ldyBxbigwLFF0LkJPVU5EQVJZLGUsbikpO3RoaXMuX2N1cnZlTGlzdC5hZGQocyl9Z2V0Q3VydmVzKCl7cmV0dXJuIHRoaXMuYWRkKHRoaXMuX2lucHV0R2VvbSksdGhpcy5fY3VydmVMaXN0fWFkZCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgaXQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEopdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHR0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgaHQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIHd0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBjdCkpdGhyb3cgbmV3IGoodC5nZXRHZW9tZXRyeVR5cGUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX1pc0Vyb2RlZENvbXBsZXRlbHkodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihuLmxlbmd0aDw0KXJldHVybiBlPDA7aWYoND09PW4ubGVuZ3RoKXJldHVybiB0aGlzLmlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KG4sZSk7Y29uc3Qgcz10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPU1hdGgubWluKHMuZ2V0SGVpZ2h0KCkscy5nZXRXaWR0aCgpKTtyZXR1cm4gZTwwJiYyKk1hdGguYWJzKGUpPml9YWRkQ29sbGVjdGlvbih0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19fWNsYXNzIE5pe2NvbnN0cnVjdG9yKCl7TmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZWRnZU1hcD1uZXcgSG4sdGhpcy5fZWRnZUxpc3Q9bnVsbCx0aGlzLl9wdEluQXJlYUxvY2F0aW9uPVtRdC5OT05FLFF0Lk5PTkVdfWdldE5leHRDVyh0KXt0aGlzLmdldEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5pbmRleE9mKHQpO2xldCBuPWUtMTtyZXR1cm4gMD09PWUmJihuPXRoaXMuX2VkZ2VMaXN0LnNpemUoKS0xKSx0aGlzLl9lZGdlTGlzdC5nZXQobil9cHJvcGFnYXRlU2lkZUxhYmVscyh0KXtsZXQgZT1RdC5OT05FO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLmdldExhYmVsKCk7cy5pc0FyZWEodCkmJnMuZ2V0TG9jYXRpb24odCxNbi5MRUZUKSE9PVF0Lk5PTkUmJihlPXMuZ2V0TG9jYXRpb24odCxNbi5MRUZUKSl9aWYoZT09PVF0Lk5PTkUpcmV0dXJuIG51bGw7bGV0IG49ZTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtpZihpLmdldExvY2F0aW9uKHQsTW4uT04pPT09UXQuTk9ORSYmaS5zZXRMb2NhdGlvbih0LE1uLk9OLG4pLGkuaXNBcmVhKHQpKXtjb25zdCBlPWkuZ2V0TG9jYXRpb24odCxNbi5MRUZUKSxyPWkuZ2V0TG9jYXRpb24odCxNbi5SSUdIVCk7aWYociE9PVF0Lk5PTkUpe2lmKHIhPT1uKXRocm93IG5ldyBzcyhcInNpZGUgbG9jYXRpb24gY29uZmxpY3RcIixzLmdldENvb3JkaW5hdGUoKSk7ZT09PVF0Lk5PTkUmJmcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlIChhdCBcIitzLmdldENvb3JkaW5hdGUoKStcIilcIiksbj1lfWVsc2UgZy5pc1RydWUoaS5nZXRMb2NhdGlvbih0LE1uLkxFRlQpPT09UXQuTk9ORSxcImZvdW5kIHNpbmdsZSBudWxsIHNpZGVcIiksaS5zZXRMb2NhdGlvbih0LE1uLlJJR0hULG4pLGkuc2V0TG9jYXRpb24odCxNbi5MRUZULG4pfX19Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9dGhpcy5pdGVyYXRvcigpO2lmKCF0Lmhhc05leHQoKSlyZXR1cm4gbnVsbDtyZXR1cm4gdC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZSgpfXByaW50KHQpe0Iub3V0LnByaW50bG4oXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpfX1pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHQpe3JldHVybiB0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHQuZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLmNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQoMCl9Y2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCh0KXtjb25zdCBlPXRoaXMuZ2V0RWRnZXMoKTtpZihlLnNpemUoKTw9MClyZXR1cm4hMDtjb25zdCBuPWUuc2l6ZSgpLTEscz1lLmdldChuKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQsTW4uTEVGVCk7Zy5pc1RydWUocyE9PVF0Lk5PTkUsXCJGb3VuZCB1bmxhYmVsbGVkIGFyZWEgZWRnZVwiKTtsZXQgaT1zO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldExhYmVsKCk7Zy5pc1RydWUobi5pc0FyZWEodCksXCJGb3VuZCBub24tYXJlYSBlZGdlXCIpO2NvbnN0IHM9bi5nZXRMb2NhdGlvbih0LE1uLkxFRlQpLHI9bi5nZXRMb2NhdGlvbih0LE1uLlJJR0hUKTtpZihzPT09cilyZXR1cm4hMTtpZihyIT09aSlyZXR1cm4hMTtpPXN9cmV0dXJuITB9ZmluZEluZGV4KHQpe3RoaXMuaXRlcmF0b3IoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VMaXN0LnNpemUoKTtlKyspe2lmKHRoaXMuX2VkZ2VMaXN0LmdldChlKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKCl9Z2V0RWRnZXMoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2VkZ2VMaXN0JiYodGhpcy5fZWRnZUxpc3Q9bmV3IEwodGhpcy5fZWRnZU1hcC52YWx1ZXMoKSkpLHRoaXMuX2VkZ2VMaXN0fWdldExvY2F0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XT09PVF0Lk5PTkUmJih0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdPVplLmxvY2F0ZShlLG5bdF0uZ2V0R2VvbWV0cnkoKSkpLHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF19dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB2O3QuYXBwZW5kKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpLHQuYXBwZW5kKFwiXFxuXCIpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3QuYXBwZW5kKG4pLHQuYXBwZW5kKFwiXFxuXCIpfXJldHVybiB0LnRvU3RyaW5nKCl9Y29tcHV0ZUVkZ2VFbmRMYWJlbHModCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmNvbXB1dGVMYWJlbCh0KX19Y29tcHV0ZUxhYmVsbGluZyh0KXt0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHRbMF0uZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMCksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDEpO2NvbnN0IGU9WyExLCExXTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKS5nZXRMYWJlbCgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspbi5pc0xpbmUodCkmJm4uZ2V0TG9jYXRpb24odCk9PT1RdC5CT1VOREFSWSYmKGVbdF09ITApfWZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLGk9cy5nZXRMYWJlbCgpO2ZvcihsZXQgbj0wO248MjtuKyspaWYoaS5pc0FueU51bGwobikpe2xldCByPVF0Lk5PTkU7aWYoZVtuXSlyPVF0LkVYVEVSSU9SO2Vsc2V7Y29uc3QgZT1zLmdldENvb3JkaW5hdGUoKTtyPXRoaXMuZ2V0TG9jYXRpb24obixlLHQpfWkuc2V0QWxsTG9jYXRpb25zSWZOdWxsKG4scil9fX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fZWRnZU1hcC5zaXplKCl9aW5zZXJ0RWRnZUVuZCh0LGUpe3RoaXMuX2VkZ2VNYXAucHV0KHQsZSksdGhpcy5fZWRnZUxpc3Q9bnVsbH19Y2xhc3MgU2kgZXh0ZW5kcyBOaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksU2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0PW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc9MSx0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HPTJ9bGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKXt0aGlzLmdldFJlc3VsdEFyZWFFZGdlcygpO2xldCB0PW51bGwsZT1udWxsLG49dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO2ZvcihsZXQgcz0wO3M8dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTtzKyspe2NvbnN0IGk9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChzKSxyPWkuZ2V0U3ltKCk7aWYoaS5nZXRMYWJlbCgpLmlzQXJlYSgpKXN3aXRjaChudWxsPT09dCYmaS5pc0luUmVzdWx0KCkmJih0PWkpLG4pe2Nhc2UgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKCFyLmlzSW5SZXN1bHQoKSljb250aW51ZTtlPXIsbj10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORzppZighaS5pc0luUmVzdWx0KCkpY29udGludWU7ZS5zZXROZXh0KGkpLG49dGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1pZihuPT09dGhpcy5fTElOS0lOR19UT19PVVRHT0lORyl7aWYobnVsbD09PXQpdGhyb3cgbmV3IHNzKFwibm8gb3V0Z29pbmcgZGlyRWRnZSBmb3VuZFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtnLmlzVHJ1ZSh0LmlzSW5SZXN1bHQoKSxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxlLnNldE5leHQodCl9fWluc2VydCh0KXtjb25zdCBlPXQ7dGhpcy5pbnNlcnRFZGdlRW5kKGUsZSl9Z2V0UmlnaHRtb3N0RWRnZSgpe2NvbnN0IHQ9dGhpcy5nZXRFZGdlcygpLGU9dC5zaXplKCk7aWYoZTwxKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXQoMCk7aWYoMT09PWUpcmV0dXJuIG47Y29uc3Qgcz10LmdldChlLTEpLGk9bi5nZXRRdWFkcmFudCgpLHI9cy5nZXRRdWFkcmFudCgpO3JldHVybiB3bi5pc05vcnRoZXJuKGkpJiZ3bi5pc05vcnRoZXJuKHIpP246d24uaXNOb3J0aGVybihpKXx8d24uaXNOb3J0aGVybihyKT8wIT09bi5nZXREeSgpP246MCE9PXMuZ2V0RHkoKT9zOihnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiZm91bmQgdHdvIGhvcml6b250YWwgZWRnZXMgaW5jaWRlbnQgb24gbm9kZVwiKSxudWxsKTpzfXByaW50KHQpe0Iub3V0LnByaW50bG4oXCJEaXJlY3RlZEVkZ2VTdGFyOiBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5wcmludChcIm91dCBcIiksbi5wcmludCh0KSx0LnByaW50bG4oKSx0LnByaW50KFwiaW4gXCIpLG4uZ2V0U3ltKCkucHJpbnQodCksdC5wcmludGxuKCl9fWdldFJlc3VsdEFyZWFFZGdlcygpe2lmKG51bGwhPT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QpcmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdDt0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Q9bmV3IEw7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7KGUuaXNJblJlc3VsdCgpfHxlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkmJnRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5hZGQoZSl9cmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdH11cGRhdGVMYWJlbGxpbmcodCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0TGFiZWwoKTtuLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQuZ2V0TG9jYXRpb24oMCkpLG4uc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdC5nZXRMb2NhdGlvbigxKSl9fWxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl7dGhpcy5nZXRFZGdlcygpO2xldCB0PW51bGwsZT1udWxsO2ZvcihsZXQgbj10aGlzLl9lZGdlTGlzdC5zaXplKCktMTtuPj0wO24tLSl7Y29uc3Qgcz10aGlzLl9lZGdlTGlzdC5nZXQobiksaT1zLmdldFN5bSgpO251bGw9PT1lJiYoZT1pKSxudWxsIT09dCYmaS5zZXROZXh0KHQpLHQ9c31lLnNldE5leHQodCl9Y29tcHV0ZURlcHRocygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZmluZEluZGV4KHQpLG49dC5nZXREZXB0aChNbi5MRUZUKSxzPXQuZ2V0RGVwdGgoTW4uUklHSFQpLGk9dGhpcy5jb21wdXRlRGVwdGhzKGUrMSx0aGlzLl9lZGdlTGlzdC5zaXplKCksbik7aWYodGhpcy5jb21wdXRlRGVwdGhzKDAsZSxpKSE9PXMpdGhyb3cgbmV3IHNzKFwiZGVwdGggbWlzbWF0Y2ggYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2xldCBlPWFyZ3VtZW50c1syXTtmb3IobGV0IG49YXJndW1lbnRzWzBdO248dDtuKyspe2NvbnN0IHQ9dGhpcy5fZWRnZUxpc3QuZ2V0KG4pO3Quc2V0RWRnZURlcHRocyhNbi5SSUdIVCxlKSxlPXQuZ2V0RGVwdGgoTW4uTEVGVCl9cmV0dXJuIGV9fW1lcmdlU3ltTGFiZWxzKCl7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5nZXRMYWJlbCgpLm1lcmdlKGUuZ2V0U3ltKCkuZ2V0TGFiZWwoKSl9fWxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0KXtsZXQgZT1udWxsLG49bnVsbCxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztmb3IobGV0IGk9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKS0xO2k+PTA7aS0tKXtjb25zdCByPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSksbz1yLmdldFN5bSgpO3N3aXRjaChudWxsPT09ZSYmci5nZXRFZGdlUmluZygpPT09dCYmKGU9cikscyl7Y2FzZSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoby5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuPW8scz10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORzppZihyLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO24uc2V0TmV4dE1pbihyKSxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlOR319cz09PXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcmJihnLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2VcIiksZy5pc1RydWUoZS5nZXRFZGdlUmluZygpPT09dCxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxuLnNldE5leHRNaW4oZSkpfWdldE91dGdvaW5nRGVncmVlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmlzSW5SZXN1bHQoKSYmdCsrfXJldHVybiB0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXRFZGdlUmluZygpPT09dCYmZSsrfXJldHVybiBlfX1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1maW5kQ292ZXJlZExpbmVFZGdlcygpe2xldCB0PVF0Lk5PTkU7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldFN5bSgpO2lmKCFuLmlzTGluZUVkZ2UoKSl7aWYobi5pc0luUmVzdWx0KCkpe3Q9UXQuSU5URVJJT1I7YnJlYWt9aWYocy5pc0luUmVzdWx0KCkpe3Q9UXQuRVhURVJJT1I7YnJlYWt9fX1pZih0PT09UXQuTk9ORSlyZXR1cm4gbnVsbDtsZXQgZT10O2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRTeW0oKTtuLmlzTGluZUVkZ2UoKT9uLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKGU9PT1RdC5JTlRFUklPUik6KG4uaXNJblJlc3VsdCgpJiYoZT1RdC5FWFRFUklPUikscy5pc0luUmVzdWx0KCkmJihlPVF0LklOVEVSSU9SKSl9fWNvbXB1dGVMYWJlbGxpbmcodCl7c3VwZXIuY29tcHV0ZUxhYmVsbGluZy5jYWxsKHRoaXMsdCksdGhpcy5fbGFiZWw9bmV3IHFuKFF0Lk5PTkUpO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLmdldEVkZ2UoKS5nZXRMYWJlbCgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspe2NvbnN0IG49ZS5nZXRMb2NhdGlvbih0KTtuIT09UXQuSU5URVJJT1ImJm4hPT1RdC5CT1VOREFSWXx8dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxRdC5JTlRFUklPUil9fX19Y2xhc3Mgd2kgZXh0ZW5kcyByc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IHRzKHQsbmV3IFNpKX19Y2xhc3MgQ2l7Y29uc3RydWN0b3IoKXtDaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9vcmllbnRhdGlvbj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10LHRoaXMuX29yaWVudGF0aW9uPUNpLm9yaWVudGF0aW9uKHQpfXN0YXRpYyBvcmllbnRhdGlvbih0KXtyZXR1cm4gMT09PWR0LmluY3JlYXNpbmdEaXJlY3Rpb24odCl9c3RhdGljIGNvbXBhcmVPcmllbnRlZCh0LGUsbixzKXtjb25zdCBpPWU/MTotMSxyPXM/MTotMSxvPWU/dC5sZW5ndGg6LTEsbD1zP24ubGVuZ3RoOi0xO2xldCBhPWU/MDp0Lmxlbmd0aC0xLGM9cz8wOm4ubGVuZ3RoLTE7Zm9yKDs7KXtjb25zdCBlPXRbYV0uY29tcGFyZVRvKG5bY10pO2lmKDAhPT1lKXJldHVybiBlO2ErPWksYys9cjtjb25zdCBzPWE9PT1vLGg9Yz09PWw7aWYocyYmIWgpcmV0dXJuLTE7aWYoIXMmJmgpcmV0dXJuIDE7aWYocyYmaClyZXR1cm4gMH19Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gQ2kuY29tcGFyZU9yaWVudGVkKHRoaXMuX3B0cyx0aGlzLl9vcmllbnRhdGlvbixlLl9wdHMsZS5fb3JpZW50YXRpb24pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19Y2xhc3MgTGl7Y29uc3RydWN0b3IoKXtMaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9lZGdlcz1uZXcgTCx0aGlzLl9vY2FNYXA9bmV3IEhufXByaW50KHQpe3QucHJpbnQoXCJNVUxUSUxJTkVTVFJJTkcgKCBcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlcy5zaXplKCk7ZSsrKXtjb25zdCBuPXRoaXMuX2VkZ2VzLmdldChlKTtlPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoXCIoXCIpO2NvbnN0IHM9bi5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludChzW2VdLngrXCIgXCIrc1tlXS55KTt0LnByaW50bG4oXCIpXCIpfXQucHJpbnQoXCIpICBcIil9YWRkQWxsKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKX1maW5kRWRnZUluZGV4KHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKylpZih0aGlzLl9lZGdlcy5nZXQoZSkuZXF1YWxzKHQpKXJldHVybiBlO3JldHVybi0xfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZWRnZXN9Z2V0KHQpe3JldHVybiB0aGlzLl9lZGdlcy5nZXQodCl9ZmluZEVxdWFsRWRnZSh0KXtjb25zdCBlPW5ldyBDaSh0LmdldENvb3JkaW5hdGVzKCkpO3JldHVybiB0aGlzLl9vY2FNYXAuZ2V0KGUpfWFkZCh0KXt0aGlzLl9lZGdlcy5hZGQodCk7Y29uc3QgZT1uZXcgQ2kodC5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9vY2FNYXAucHV0KGUsdCl9fWNsYXNzIFRpe3Byb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe31pc0RvbmUoKXt9fWNsYXNzIFJpe2NvbnN0cnVjdG9yKCl7UmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX2hhc1Byb3Blcj0hMSx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLl9oYXNJbnRlcmlvcj0hMSx0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dH1zdGF0aWMgaXNBZGphY2VudFNlZ21lbnRzKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfWlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXtpZih0PT09biYmMT09PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihSaS5pc0FkamFjZW50U2VnbWVudHMoZSxzKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe2NvbnN0IG49dC5zaXplKCktMTtpZigwPT09ZSYmcz09PW58fDA9PT1zJiZlPT09bilyZXR1cm4hMH19cmV0dXJuITF9Z2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKXtyZXR1cm4gdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9aGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3J9Z2V0TGluZUludGVyc2VjdG9yKCl7cmV0dXJuIHRoaXMuX2xpfWhhc1Byb3BlckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNQcm9wZXJ9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKztjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zKyssdGhpcy5faGFzSW50ZXJpb3I9ITApLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpLHRoaXMuX2xpLmlzUHJvcGVyKCkmJih0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMrKyx0aGlzLl9oYXNQcm9wZXI9ITAsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITApKSl9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hMX1oYXNJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcmlvcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVGldfX1jbGFzcyBQaXtjb25zdHJ1Y3Rvcigpe1BpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2J1ZlBhcmFtcz1udWxsLHRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX3dvcmtpbmdOb2Rlcj1udWxsLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9lZGdlTGlzdD1uZXcgTGk7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYnVmUGFyYW1zPXR9c3RhdGljIGRlcHRoRGVsdGEodCl7Y29uc3QgZT10LmdldExvY2F0aW9uKDAsTW4uTEVGVCksbj10LmdldExvY2F0aW9uKDAsTW4uUklHSFQpO3JldHVybiBlPT09UXQuSU5URVJJT1ImJm49PT1RdC5FWFRFUklPUj8xOmU9PT1RdC5FWFRFUklPUiYmbj09PVF0LklOVEVSSU9SPy0xOjB9c3RhdGljIGNvbnZlcnRTZWdTdHJpbmdzKHQpe2NvbnN0IGU9bmV3IEN0LG49bmV3IEw7Zm9yKDt0Lmhhc05leHQoKTspe2NvbnN0IHM9dC5uZXh0KCksaT1lLmNyZWF0ZUxpbmVTdHJpbmcocy5nZXRDb29yZGluYXRlcygpKTtuLmFkZChpKX1yZXR1cm4gZS5idWlsZEdlb21ldHJ5KG4pfXNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw9dH1pbnNlcnRVbmlxdWVFZGdlKHQpe2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7Y29uc3Qgbj1lLmdldExhYmVsKCk7bGV0IHM9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KHM9bmV3IHFuKHQuZ2V0TGFiZWwoKSkscy5mbGlwKCkpLG4ubWVyZ2Uocyk7Y29uc3QgaT1QaS5kZXB0aERlbHRhKHMpLHI9ZS5nZXREZXB0aERlbHRhKCkraTtlLnNldERlcHRoRGVsdGEocil9ZWxzZSB0aGlzLl9lZGdlTGlzdC5hZGQodCksdC5zZXREZXB0aERlbHRhKFBpLmRlcHRoRGVsdGEodC5nZXRMYWJlbCgpKSl9YnVpbGRTdWJncmFwaHModCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9dC5nZXRSaWdodG1vc3RDb29yZGluYXRlKCkscj1uZXcgeGkobikuZ2V0RGVwdGgoaSk7dC5jb21wdXRlRGVwdGgociksdC5maW5kUmVzdWx0RWRnZXMoKSxuLmFkZCh0KSxlLmFkZCh0LmdldERpcmVjdGVkRWRnZXMoKSx0LmdldE5vZGVzKCkpfX1jcmVhdGVTdWJncmFwaHModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5nZXROb2RlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2lmKCF0LmlzVmlzaXRlZCgpKXtjb25zdCBuPW5ldyBoaTtuLmNyZWF0ZSh0KSxlLmFkZChuKX19cmV0dXJuIHhlLnNvcnQoZSx4ZS5yZXZlcnNlT3JkZXIoKSksZX1jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oKX1nZXROb2Rlcih0KXtpZihudWxsIT09dGhpcy5fd29ya2luZ05vZGVyKXJldHVybiB0aGlzLl93b3JraW5nTm9kZXI7Y29uc3QgZT1uZXcgJHMsbj1uZXcganQ7cmV0dXJuIG4uc2V0UHJlY2lzaW9uTW9kZWwodCksZS5zZXRTZWdtZW50SW50ZXJzZWN0b3IobmV3IFJpKG4pKSxlfWJ1ZmZlcih0LGUpe2xldCBuPXRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbDtudWxsPT09biYmKG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKTtjb25zdCBzPW5ldyB5aShuLHRoaXMuX2J1ZlBhcmFtcyksaT1uZXcgSWkodCxlLHMpLmdldEN1cnZlcygpO2lmKGkuc2l6ZSgpPD0wKXJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTt0aGlzLmNvbXB1dGVOb2RlZEVkZ2VzKGksbiksdGhpcy5fZ3JhcGg9bmV3IG9zKG5ldyB3aSksdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7Y29uc3Qgcj10aGlzLmNyZWF0ZVN1YmdyYXBocyh0aGlzLl9ncmFwaCksbz1uZXcgX2kodGhpcy5fZ2VvbUZhY3QpO3RoaXMuYnVpbGRTdWJncmFwaHMocixvKTtjb25zdCBsPW8uZ2V0UG9seWdvbnMoKTtpZihsLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkobCl9Y29tcHV0ZU5vZGVkRWRnZXModCxlKXtjb25zdCBuPXRoaXMuZ2V0Tm9kZXIoZSk7bi5jb21wdXRlTm9kZXModCk7Zm9yKGxldCB0PW4uZ2V0Tm9kZWRTdWJzdHJpbmdzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCk7aWYoMj09PW4ubGVuZ3RoJiZuWzBdLmVxdWFsczJEKG5bMV0pKWNvbnRpbnVlO2NvbnN0IHM9ZS5nZXREYXRhKCksaT1uZXcgJG4oZS5nZXRDb29yZGluYXRlcygpLG5ldyBxbihzKSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKGkpfX1zZXROb2Rlcih0KXt0aGlzLl93b3JraW5nTm9kZXI9dH19Y2xhc3MgT2l7Y29uc3RydWN0b3IoKXtPaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5fc2VnU3RyaW5ncz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZ1N0cmluZ3M9dH1jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcihsZXQgdD10aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhlWzBdLHRoaXMuX3NlZ1N0cmluZ3MpLHRoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoZVtlLmxlbmd0aC0xXSx0aGlzLl9zZWdTdHJpbmdzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9YXJndW1lbnRzWzFdLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTE7ZTxuLmxlbmd0aC0xO2UrKylpZihuW2VdLmVxdWFscyh0KSl0aHJvdyBuZXcgaChcImZvdW5kIGVuZHB0L2ludGVyaW9yIHB0IGludGVyc2VjdGlvbiBhdCBpbmRleCBcIitlK1wiIDpwdCBcIit0KX19fWNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7Zm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7dGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhlLG4pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxzPWUuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGk9MDtpPG4ubGVuZ3RoLTE7aSsrKWZvcihsZXQgbj0wO248cy5sZW5ndGgtMTtuKyspdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGksZSxuKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLl9saS5pc1Byb3BlcigpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLGkscil8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksbyxsKSkpdGhyb3cgbmV3IGgoXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGF0IFwiK2krXCItXCIrcitcIiBhbmQgXCIrbytcIi1cIitsKX19Y2hlY2tWYWxpZCgpe3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0NvbGxhcHNlcygpfWNoZWNrQ29sbGFwc2VzKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5jaGVja0NvbGxhcHNlcyhlKX1lbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspdGhpcy5jaGVja0NvbGxhcHNlKHRbZV0sdFtlKzFdLHRbZSsyXSl9fWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7cysrKXtjb25zdCBpPXQuZ2V0SW50ZXJzZWN0aW9uKHMpO2lmKCFpLmVxdWFscyhlKSYmIWkuZXF1YWxzKG4pKXJldHVybiEwfXJldHVybiExfWNoZWNrQ29sbGFwc2UodCxlLG4pe2lmKHQuZXF1YWxzKG4pKXRocm93IG5ldyBoKFwiZm91bmQgbm9uLW5vZGVkIGNvbGxhcHNlIGF0IFwiK09pLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbdCxlLG5dKSl9fU9pLmZhY3Q9bmV3IEN0O2NsYXNzIHZpe2NvbnN0cnVjdG9yKCl7dmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bnVsbCx0aGlzLl9wdD1udWxsLHRoaXMuX29yaWdpbmFsUHQ9bnVsbCx0aGlzLl9wdFNjYWxlZD1udWxsLHRoaXMuX3AwU2NhbGVkPW51bGwsdGhpcy5fcDFTY2FsZWQ9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX21pbng9bnVsbCx0aGlzLl9tYXh4PW51bGwsdGhpcy5fbWlueT1udWxsLHRoaXMuX21heHk9bnVsbCx0aGlzLl9jb3JuZXI9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5fc2FmZUVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX29yaWdpbmFsUHQ9dCx0aGlzLl9wdD10LHRoaXMuX3NjYWxlRmFjdG9yPWUsdGhpcy5fbGk9bixlPD0wKXRocm93IG5ldyBzKFwiU2NhbGUgZmFjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7MSE9PWUmJih0aGlzLl9wdD1uZXcgbSh0aGlzLnNjYWxlKHQueCksdGhpcy5zY2FsZSh0LnkpKSx0aGlzLl9wMFNjYWxlZD1uZXcgbSx0aGlzLl9wMVNjYWxlZD1uZXcgbSksdGhpcy5pbml0Q29ybmVycyh0aGlzLl9wdCl9aW50ZXJzZWN0c1NjYWxlZCh0LGUpe2NvbnN0IG49TWF0aC5taW4odC54LGUueCkscz1NYXRoLm1heCh0LngsZS54KSxpPU1hdGgubWluKHQueSxlLnkpLHI9TWF0aC5tYXgodC55LGUueSksbz10aGlzLl9tYXh4PG58fHRoaXMuX21pbng+c3x8dGhpcy5fbWF4eTxpfHx0aGlzLl9taW55PnI7aWYobylyZXR1cm4hMTtjb25zdCBsPXRoaXMuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpO3JldHVybiBnLmlzVHJ1ZSghKG8mJmwpLFwiRm91bmQgYmFkIGVudmVsb3BlIHRlc3RcIiksbH1pbml0Q29ybmVycyh0KXtjb25zdCBlPS41O3RoaXMuX21pbng9dC54LWUsdGhpcy5fbWF4eD10LngrZSx0aGlzLl9taW55PXQueS1lLHRoaXMuX21heHk9dC55K2UsdGhpcy5fY29ybmVyWzBdPW5ldyBtKHRoaXMuX21heHgsdGhpcy5fbWF4eSksdGhpcy5fY29ybmVyWzFdPW5ldyBtKHRoaXMuX21pbngsdGhpcy5fbWF4eSksdGhpcy5fY29ybmVyWzJdPW5ldyBtKHRoaXMuX21pbngsdGhpcy5fbWlueSksdGhpcy5fY29ybmVyWzNdPW5ldyBtKHRoaXMuX21heHgsdGhpcy5fbWlueSl9aW50ZXJzZWN0cyh0LGUpe3JldHVybiAxPT09dGhpcy5fc2NhbGVGYWN0b3I/dGhpcy5pbnRlcnNlY3RzU2NhbGVkKHQsZSk6KHRoaXMuY29weVNjYWxlZCh0LHRoaXMuX3AwU2NhbGVkKSx0aGlzLmNvcHlTY2FsZWQoZSx0aGlzLl9wMVNjYWxlZCksdGhpcy5pbnRlcnNlY3RzU2NhbGVkKHRoaXMuX3AwU2NhbGVkLHRoaXMuX3AxU2NhbGVkKSl9c2NhbGUodCl7cmV0dXJuIE1hdGgucm91bmQodCp0aGlzLl9zY2FsZUZhY3Rvcil9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9vcmlnaW5hbFB0fWNvcHlTY2FsZWQodCxlKXtlLng9dGhpcy5zY2FsZSh0LngpLGUueT10aGlzLnNjYWxlKHQueSl9Z2V0U2FmZUVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX3NhZmVFbnYpe2NvbnN0IHQ9dmkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUi90aGlzLl9zY2FsZUZhY3Rvcjt0aGlzLl9zYWZlRW52PW5ldyBPKHRoaXMuX29yaWdpbmFsUHQueC10LHRoaXMuX29yaWdpbmFsUHQueCt0LHRoaXMuX29yaWdpbmFsUHQueS10LHRoaXMuX29yaWdpbmFsUHQueSt0KX1yZXR1cm4gdGhpcy5fc2FmZUVudn1pbnRlcnNlY3RzUGl4ZWxDbG9zdXJlKHQsZSl7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclswXSx0aGlzLl9jb3JuZXJbMV0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMV0sdGhpcy5fY29ybmVyWzJdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzJdLHRoaXMuX2Nvcm5lclszXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclszXSx0aGlzLl9jb3JuZXJbMF0pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpKSl9aW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpe2xldCBuPSExLHM9ITE7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclswXSx0aGlzLl9jb3JuZXJbMV0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsxXSx0aGlzLl9jb3JuZXJbMl0pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYobj0hMCksdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzJdLHRoaXMuX2Nvcm5lclszXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJihzPSEwKSx0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbM10sdGhpcy5fY29ybmVyWzBdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCghKCFufHwhcyl8fCghIXQuZXF1YWxzKHRoaXMuX3B0KXx8ISFlLmVxdWFscyh0aGlzLl9wdCkpKSkpKX1hZGRTbmFwcGVkTm9kZSh0LGUpe2NvbnN0IG49dC5nZXRDb29yZGluYXRlKGUpLHM9dC5nZXRDb29yZGluYXRlKGUrMSk7cmV0dXJuISF0aGlzLmludGVyc2VjdHMobixzKSYmKHQuYWRkSW50ZXJzZWN0aW9uKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpLCEwKX19dmkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUj0uNzU7Y2xhc3MgTWl7Y29uc3RydWN0b3IoKXtNaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnNlbGVjdGVkU2VnbWVudD1uZXcgS3R9c2VsZWN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1swXS5nZXRMaW5lU2VnbWVudCh0LHRoaXMuc2VsZWN0ZWRTZWdtZW50KSx0aGlzLnNlbGVjdCh0aGlzLnNlbGVjdGVkU2VnbWVudCl9fX1jbGFzcyBiaXtjb25zdHJ1Y3Rvcigpe2JpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2luZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5kZXg9dH1zbmFwKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNuYXAodCxudWxsLC0xKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmdldFNhZmVFbnZlbG9wZSgpLGk9bmV3IERpKHQsZSxuKTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkocyxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RlXX12aXNpdEl0ZW0odCl7dC5zZWxlY3QocyxpKX19KSxpLmlzTm9kZUFkZGVkKCl9fX1jbGFzcyBEaSBleHRlbmRzIE1pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxEaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ob3RQaXhlbD1udWxsLHRoaXMuX3BhcmVudEVkZ2U9bnVsbCx0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4PW51bGwsdGhpcy5faXNOb2RlQWRkZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faG90UGl4ZWw9dCx0aGlzLl9wYXJlbnRFZGdlPWUsdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleD1ufWlzTm9kZUFkZGVkKCl7cmV0dXJuIHRoaXMuX2lzTm9kZUFkZGVkfXNlbGVjdCgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBqcykpcmV0dXJuIHN1cGVyLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzBdLmdldENvbnRleHQoKTtpZih0aGlzLl9wYXJlbnRFZGdlPT09ZSYmKHQ9PT10aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4fHx0KzE9PT10aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4KSlyZXR1cm4gbnVsbDt0aGlzLl9pc05vZGVBZGRlZHw9dGhpcy5faG90UGl4ZWwuYWRkU25hcHBlZE5vZGUoZSx0KX19fWJpLkhvdFBpeGVsU25hcEFjdGlvbj1EaTtjbGFzcyBBaXtjb25zdHJ1Y3Rvcigpe0FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW51bGwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnM9bmV3IEx9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTtpZih0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7dCsrKXRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucy5hZGQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKHQpKTt0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKX19aXNEb25lKCl7cmV0dXJuITF9Z2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVGldfX1jbGFzcyBGaXtjb25zdHJ1Y3Rvcigpe0ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BtPW51bGwsdGhpcy5fbGk9bnVsbCx0aGlzLl9zY2FsZUZhY3Rvcj1udWxsLHRoaXMuX25vZGVyPW51bGwsdGhpcy5fcG9pbnRTbmFwcGVyPW51bGwsdGhpcy5fbm9kZWRTZWdTdHJpbmdzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcG09dCx0aGlzLl9saT1uZXcganQsdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwodCksdGhpcy5fc2NhbGVGYWN0b3I9dC5nZXRTY2FsZSgpfWNoZWNrQ29ycmVjdG5lc3ModCl7Y29uc3QgZT1Xcy5nZXROb2RlZFN1YnN0cmluZ3ModCkscz1uZXcgT2koZSk7dHJ5e3MuY2hlY2tWYWxpZCgpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IHQ7dC5wcmludFN0YWNrVHJhY2UoKX19Z2V0Tm9kZWRTdWJzdHJpbmdzKCl7cmV0dXJuIFdzLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpfXNuYXBSb3VuZCh0LGUpe2NvbnN0IG49dGhpcy5maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsZSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uU25hcHMobiksdGhpcy5jb21wdXRlVmVydGV4U25hcHModCl9ZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpe2NvbnN0IG49bmV3IEFpKGUpO3JldHVybiB0aGlzLl9ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobiksdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKHQpLG4uZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9Y29tcHV0ZVZlcnRleFNuYXBzKCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5jb21wdXRlVmVydGV4U25hcHMoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBXcyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2NvbnN0IHM9bmV3IHZpKGVbbl0sdGhpcy5fc2NhbGVGYWN0b3IsdGhpcy5fbGkpO3RoaXMuX3BvaW50U25hcHBlci5zbmFwKHMsdCxuKSYmdC5hZGRJbnRlcnNlY3Rpb24oZVtuXSxuKX19fWNvbXB1dGVOb2Rlcyh0KXt0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9dCx0aGlzLl9ub2Rlcj1uZXcgJHMsdGhpcy5fcG9pbnRTbmFwcGVyPW5ldyBiaSh0aGlzLl9ub2Rlci5nZXRJbmRleCgpKSx0aGlzLnNuYXBSb3VuZCh0LHRoaXMuX2xpKX1jb21wdXRlSW50ZXJzZWN0aW9uU25hcHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj1uZXcgdmkodCx0aGlzLl9zY2FsZUZhY3Rvcix0aGlzLl9saSk7dGhpcy5fcG9pbnRTbmFwcGVyLnNuYXAobil9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltRc119fWNsYXNzIEdpe2NvbnN0cnVjdG9yKCl7R2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fYXJnR2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5fYnVmUGFyYW1zPW5ldyBsaSx0aGlzLl9yZXN1bHRHZW9tZXRyeT1udWxsLHRoaXMuX3NhdmVFeGNlcHRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJnR2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2FyZ0dlb209dCx0aGlzLl9idWZQYXJhbXM9ZX19c3RhdGljIGJ1ZmZlck9wKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgR2koYXJndW1lbnRzWzBdKS5nZXRSZXN1bHRHZW9tZXRyeSh0KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdLG49bmV3IEdpKGFyZ3VtZW50c1swXSk7bi5zZXRRdWFkcmFudFNlZ21lbnRzKGUpO3JldHVybiBuLmdldFJlc3VsdEdlb21ldHJ5KHQpfWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgbGkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBHaShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzJdKS5nZXRSZXN1bHRHZW9tZXRyeSh0KX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl0sbj1hcmd1bWVudHNbM10scz1uZXcgR2koYXJndW1lbnRzWzBdKTtzLnNldFF1YWRyYW50U2VnbWVudHMoZSkscy5zZXRFbmRDYXBTdHlsZShuKTtyZXR1cm4gcy5nZXRSZXN1bHRHZW9tZXRyeSh0KX19c3RhdGljIHByZWNpc2lvblNjYWxlRmFjdG9yKHQsZSxuKXtjb25zdCBzPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9WS5tYXgoTWF0aC5hYnMocy5nZXRNYXhYKCkpLE1hdGguYWJzKHMuZ2V0TWF4WSgpKSxNYXRoLmFicyhzLmdldE1pblgoKSksTWF0aC5hYnMocy5nZXRNaW5ZKCkpKSsyKihlPjA/ZTowKSxyPW4tTWF0aC50cnVuYyhNYXRoLmxvZyhpKS9NYXRoLmxvZygxMCkrMSk7cmV0dXJuIE1hdGgucG93KDEwLHIpfWJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpe2NvbnN0IGU9bmV3IGVpKG5ldyBGaShuZXcgTnQoMSkpLHQuZ2V0U2NhbGUoKSksbj1uZXcgUGkodGhpcy5fYnVmUGFyYW1zKTtuLnNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KSxuLnNldE5vZGVyKGUpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5PW4uYnVmZmVyKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UpfWJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PUdpLk1BWF9QUkVDSVNJT05fRElHSVRTO3Q+PTA7dC0tKXt0cnl7dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHQpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIHNzKSl0aHJvdyB0O3RoaXMuX3NhdmVFeGNlcHRpb249dH1pZihudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGx9dGhyb3cgdGhpcy5fc2F2ZUV4Y2VwdGlvbn1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1HaS5wcmVjaXNpb25TY2FsZUZhY3Rvcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlLHQpLG49bmV3IE50KGUpO3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24obil9fWNvbXB1dGVHZW9tZXRyeSgpe2lmKHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKSxudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLl9hcmdHZW9tLmdldEZhY3RvcnkoKS5nZXRQcmVjaXNpb25Nb2RlbCgpO3QuZ2V0VHlwZSgpPT09TnQuRklYRUQ/dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbih0KTp0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKX1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX2J1ZlBhcmFtcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCl7dHJ5e2NvbnN0IHQ9bmV3IFBpKHRoaXMuX2J1ZlBhcmFtcyk7dGhpcy5fcmVzdWx0R2VvbWV0cnk9dC5idWZmZXIodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgaCkpdGhyb3cgdDt0aGlzLl9zYXZlRXhjZXB0aW9uPXR9fWdldFJlc3VsdEdlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9kaXN0YW5jZT10LHRoaXMuY29tcHV0ZUdlb21ldHJ5KCksdGhpcy5fcmVzdWx0R2VvbWV0cnl9c2V0RW5kQ2FwU3R5bGUodCl7dGhpcy5fYnVmUGFyYW1zLnNldEVuZENhcFN0eWxlKHQpfX1HaS5DQVBfUk9VTkQ9bGkuQ0FQX1JPVU5ELEdpLkNBUF9CVVRUPWxpLkNBUF9GTEFULEdpLkNBUF9GTEFUPWxpLkNBUF9GTEFULEdpLkNBUF9TUVVBUkU9bGkuQ0FQX1NRVUFSRSxHaS5NQVhfUFJFQ0lTSU9OX0RJR0lUUz0xMjt2YXIgcWk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQnVmZmVyT3A6R2ksQnVmZmVyUGFyYW1ldGVyczpsaX0pO2NsYXNzIEJpe2NvbnN0cnVjdG9yKCl7QmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fY29tcG9uZW50PW51bGwsdGhpcy5fc2VnSW5kZXg9bnVsbCx0aGlzLl9wdD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtCaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsQmkuSU5TSURFX0FSRUEsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29tcG9uZW50PXQsdGhpcy5fc2VnSW5kZXg9ZSx0aGlzLl9wdD1ufX1nZXRTZWdtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fc2VnSW5kZXh9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH1pc0luc2lkZUFyZWEoKXtyZXR1cm4gdGhpcy5fc2VnSW5kZXg9PT1CaS5JTlNJREVfQVJFQX10b1N0cmluZygpe3JldHVybiB0aGlzLl9jb21wb25lbnQuZ2V0R2VvbWV0cnlUeXBlKCkrXCJbXCIrdGhpcy5fc2VnSW5kZXgrXCJdLVwiK1d0LnRvUG9pbnQodGhpcy5fcHQpfWdldEdlb21ldHJ5Q29tcG9uZW50KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudH19QmkuSU5TSURFX0FSRUE9LTE7Y2xhc3MgWWl7Y29uc3RydWN0b3IoKXtZaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9sb2NhdGlvbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sb2NhdGlvbnM9dH1zdGF0aWMgZ2V0TG9jYXRpb25zKHQpe2NvbnN0IGU9bmV3IEw7cmV0dXJuIHQuYXBwbHkobmV3IFlpKGUpKSxlfWZpbHRlcih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDsodCBpbnN0YW5jZW9mIHR0fHx0IGluc3RhbmNlb2YgSnx8dCBpbnN0YW5jZW9mIGl0KSYmdGhpcy5fbG9jYXRpb25zLmFkZChuZXcgQmkodCwwLHQuZ2V0Q29vcmRpbmF0ZSgpKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1FdfX1jbGFzcyBWaXtjb25zdHJ1Y3Rvcigpe1ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2dlb209bnVsbCx0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT0wLHRoaXMuX3B0TG9jYXRvcj1uZXcgZm4sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbj1udWxsLHRoaXMuX21pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtWaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSwwKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWUsdGhpcy5fdGVybWluYXRlRGlzdGFuY2U9bn19c3RhdGljIGRpc3RhbmNlKHQsZSl7cmV0dXJuIG5ldyBWaSh0LGUpLmRpc3RhbmNlKCl9c3RhdGljIGlzV2l0aGluRGlzdGFuY2UodCxlLG4pe2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT5uKXJldHVybiExO3JldHVybiBuZXcgVmkodCxlLG4pLmRpc3RhbmNlKCk8PW59c3RhdGljIG5lYXJlc3RQb2ludHModCxlKXtyZXR1cm4gbmV3IFZpKHQsZSkubmVhcmVzdFBvaW50cygpfWNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLHQpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9nZW9tW3RdO2lmKG4uZ2V0RGltZW5zaW9uKCk8MilyZXR1cm4gbnVsbDtjb25zdCBzPTEtdCxpPUllLmdldFBvbHlnb25zKG4pO2lmKGkuc2l6ZSgpPjApe2NvbnN0IG49WWkuZ2V0TG9jYXRpb25zKHRoaXMuX2dlb21bc10pO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UobixpLGUpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbltzXT1lWzBdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bdF09ZVsxXSxudWxsfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJkkoYXJndW1lbnRzWzBdLHcpJiZJKGFyZ3VtZW50c1sxXSx3KSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0KyspaWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShpLGUuZ2V0KHQpLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEJpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGl0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKFF0LkVYVEVSSU9SIT09dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShzLGUpKXJldHVybiB0aGlzLl9taW5EaXN0YW5jZT0wLG5bMF09dCxuWzFdPW5ldyBCaShlLHMpLG51bGx9fWNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShpLHMsbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19Y29tcHV0ZUZhY2V0RGlzdGFuY2UoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGU9eWUuZ2V0TGluZXModGhpcy5fZ2VvbVswXSksbj15ZS5nZXRMaW5lcyh0aGlzLl9nZW9tWzFdKSxzPUVlLmdldFBvaW50cyh0aGlzLl9nZW9tWzBdKSxpPUVlLmdldFBvaW50cyh0aGlzLl9nZW9tWzFdKTtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhlLG4sdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKGUsaSx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMobixzLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMCksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMocyxpLHQpLHZvaWQgdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSkpKX1uZWFyZXN0TG9jYXRpb25zKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbn11cGRhdGVNaW5EaXN0YW5jZSh0LGUpe2lmKG51bGw9PT10WzBdKXJldHVybiBudWxsO2U/KHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF09dFsxXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMF0pOih0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMF0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzFdKX1uZWFyZXN0UG9pbnRzKCl7dGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKTtyZXR1cm5bdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXS5nZXRDb29yZGluYXRlKCksdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXS5nZXRDb29yZGluYXRlKCldfWNvbXB1dGVNaW5EaXN0YW5jZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihudWxsIT09dGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlRmFjZXREaXN0YW5jZSgpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBKJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHR0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGUoKTtmb3IobGV0IHI9MDtyPHMubGVuZ3RoLTE7cisrKXtjb25zdCBvPVYucG9pbnRUb1NlZ21lbnQoaSxzW3JdLHNbcisxXSk7aWYobzx0aGlzLl9taW5EaXN0YW5jZSl7dGhpcy5fbWluRGlzdGFuY2U9bztjb25zdCBsPW5ldyBLdChzW3JdLHNbcisxXSkuY2xvc2VzdFBvaW50KGkpO25bMF09bmV3IEJpKHQscixsKSxuWzFdPW5ldyBCaShlLDAsaSl9aWYodGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgSiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBKKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCByPTA7cjxzLmxlbmd0aC0xO3IrKyl7Y29uc3Qgbz1uZXcgTyhzW3JdLHNbcisxXSk7aWYoIShvLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLl9taW5EaXN0YW5jZSkpZm9yKGxldCBsPTA7bDxpLmxlbmd0aC0xO2wrKyl7Y29uc3QgYT1uZXcgTyhpW2xdLGlbbCsxXSk7aWYoby5kaXN0YW5jZShhKT50aGlzLl9taW5EaXN0YW5jZSljb250aW51ZTtjb25zdCBjPVYuc2VnbWVudFRvU2VnbWVudChzW3JdLHNbcisxXSxpW2xdLGlbbCsxXSk7aWYoYzx0aGlzLl9taW5EaXN0YW5jZSl7dGhpcy5fbWluRGlzdGFuY2U9Yztjb25zdCBvPW5ldyBLdChzW3JdLHNbcisxXSksYT1uZXcgS3QoaVtsXSxpW2wrMV0pLGg9by5jbG9zZXN0UG9pbnRzKGEpO25bMF09bmV3IEJpKHQscixoWzBdKSxuWzFdPW5ldyBCaShlLGwsaFsxXSl9aWYodGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19fWNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCkscj1pLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZShzLmdldENvb3JkaW5hdGUoKSk7aWYocjx0aGlzLl9taW5EaXN0YW5jZSYmKHRoaXMuX21pbkRpc3RhbmNlPXIsblswXT1uZXcgQmkoaSwwLGkuZ2V0Q29vcmRpbmF0ZSgpKSxuWzFdPW5ldyBCaShzLDAscy5nZXRDb29yZGluYXRlKCkpKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1kaXN0YW5jZSgpe2lmKG51bGw9PT10aGlzLl9nZW9tWzBdfHxudWxsPT09dGhpcy5fZ2VvbVsxXSl0aHJvdyBuZXcgcyhcIm51bGwgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gdGhpcy5fZ2VvbVswXS5pc0VtcHR5KCl8fHRoaXMuX2dlb21bMV0uaXNFbXB0eSgpPzA6KHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5fbWluRGlzdGFuY2UpfWNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKHQsZSxuKXtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyl7Y29uc3QgaT10LmdldChzKTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpO3QrKyl7Y29uc3Qgcz1lLmdldCh0KTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShpLHMsbiksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19fXZhciB6aT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEaXN0YW5jZU9wOlZpfSk7Y2xhc3Mga2l7Y29uc3RydWN0b3IoKXtraS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZGlyZWN0ZWRFZGdlcz1uZXcgTCx0aGlzLl9jb29yZGluYXRlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH1nZXRDb29yZGluYXRlcygpe2lmKG51bGw9PT10aGlzLl9jb29yZGluYXRlcyl7bGV0IHQ9MCxlPTA7Y29uc3Qgbj1uZXcgUjtmb3IobGV0IHM9dGhpcy5fZGlyZWN0ZWRFZGdlcy5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKTtpLmdldEVkZ2VEaXJlY3Rpb24oKT90Kys6ZSsrLG4uYWRkKGkuZ2V0RWRnZSgpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLCExLGkuZ2V0RWRnZURpcmVjdGlvbigpKX10aGlzLl9jb29yZGluYXRlcz1uLnRvQ29vcmRpbmF0ZUFycmF5KCksZT50JiZkdC5yZXZlcnNlKHRoaXMuX2Nvb3JkaW5hdGVzKX1yZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9dG9MaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpfWFkZCh0KXt0aGlzLl9kaXJlY3RlZEVkZ2VzLmFkZCh0KX19Y2xhc3MgWGl7Y29uc3RydWN0b3IoKXtYaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc01hcmtlZD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5fZGF0YT1udWxsfXN0YXRpYyBnZXRDb21wb25lbnRXaXRoVmlzaXRlZFN0YXRlKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7aWYobi5pc1Zpc2l0ZWQoKT09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9c3RhdGljIHNldFZpc2l0ZWQodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0VmlzaXRlZChlKX19c3RhdGljIHNldE1hcmtlZCh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRNYXJrZWQoZSl9fXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXNldE1hcmtlZCh0KXt0aGlzLl9pc01hcmtlZD10fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fZGF0YX1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfXNldENvbnRleHQodCl7dGhpcy5fZGF0YT10fX1jbGFzcyBVaSBleHRlbmRzIFhpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxVaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wYXJlbnRFZGdlPW51bGwsdGhpcy5fZnJvbT1udWxsLHRoaXMuX3RvPW51bGwsdGhpcy5fcDA9bnVsbCx0aGlzLl9wMT1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX2VkZ2VEaXJlY3Rpb249bnVsbCx0aGlzLl9xdWFkcmFudD1udWxsLHRoaXMuX2FuZ2xlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX2Zyb209dCx0aGlzLl90bz1lLHRoaXMuX2VkZ2VEaXJlY3Rpb249cyx0aGlzLl9wMD10LmdldENvb3JkaW5hdGUoKSx0aGlzLl9wMT1uO2NvbnN0IGk9dGhpcy5fcDEueC10aGlzLl9wMC54LHI9dGhpcy5fcDEueS10aGlzLl9wMC55O3RoaXMuX3F1YWRyYW50PXduLnF1YWRyYW50KGksciksdGhpcy5fYW5nbGU9TWF0aC5hdGFuMihyLGkpfX1zdGF0aWMgdG9FZGdlcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuYWRkKG4ubmV4dCgpLl9wYXJlbnRFZGdlKTtyZXR1cm4gZX1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3BhcmVudEVkZ2V9Y29tcGFyZURpcmVjdGlvbih0KXtyZXR1cm4gdGhpcy5fcXVhZHJhbnQ+dC5fcXVhZHJhbnQ/MTp0aGlzLl9xdWFkcmFudDx0Ll9xdWFkcmFudD8tMTpHLmluZGV4KHQuX3AwLHQuX3AxLHRoaXMuX3AxKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Zyb20uZ2V0Q29vcmRpbmF0ZSgpfXByaW50KHQpe2NvbnN0IGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpLHM9ZS5zdWJzdHJpbmcobisxKTt0LnByaW50KFwiICBcIitzK1wiOiBcIit0aGlzLl9wMCtcIiAtIFwiK3RoaXMuX3AxK1wiIFwiK3RoaXMuX3F1YWRyYW50K1wiOlwiK3RoaXMuX2FuZ2xlKX1nZXREaXJlY3Rpb25QdCgpe3JldHVybiB0aGlzLl9wMX1nZXRBbmdsZSgpe3JldHVybiB0aGlzLl9hbmdsZX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9Z2V0RnJvbU5vZGUoKXtyZXR1cm4gdGhpcy5fZnJvbX1nZXRTeW0oKXtyZXR1cm4gdGhpcy5fc3ltfXNldEVkZ2UodCl7dGhpcy5fcGFyZW50RWRnZT10fXJlbW92ZSgpe3RoaXMuX3N5bT1udWxsLHRoaXMuX3BhcmVudEVkZ2U9bnVsbH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX3BhcmVudEVkZ2V9Z2V0UXVhZHJhbnQoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnR9c2V0U3ltKHQpe3RoaXMuX3N5bT10fWdldFRvTm9kZSgpe3JldHVybiB0aGlzLl90b31nZXRFZGdlRGlyZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2VkZ2VEaXJlY3Rpb259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW29dfX1jbGFzcyBIaSBleHRlbmRzIFVpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxIaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtVaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxuLHMpfWdldE5leHQoKXtyZXR1cm4gMiE9PXRoaXMuZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCk/bnVsbDp0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCk9PT10aGlzLmdldFN5bSgpP3RoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKTooZy5pc1RydWUodGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpPT09dGhpcy5nZXRTeW0oKSksdGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApKX19Y2xhc3MgV2kgZXh0ZW5kcyBYaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksV2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZGlyRWRnZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldERpcmVjdGVkRWRnZXModCxlKX19aXNSZW1vdmVkKCl7cmV0dXJuIG51bGw9PT10aGlzLl9kaXJFZGdlfXNldERpcmVjdGVkRWRnZXModCxlKXt0aGlzLl9kaXJFZGdlPVt0LGVdLHQuc2V0RWRnZSh0aGlzKSxlLnNldEVkZ2UodGhpcyksdC5zZXRTeW0oZSksZS5zZXRTeW0odCksdC5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UodCksZS5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UoZSl9Z2V0RGlyRWRnZSgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VbdF19aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBqaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVswXTp0aGlzLl9kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMV06bnVsbH19cmVtb3ZlKCl7dGhpcy5fZGlyRWRnZT1udWxsfWdldE9wcG9zaXRlTm9kZSh0KXtyZXR1cm4gdGhpcy5fZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzBdLmdldFRvTm9kZSgpOnRoaXMuX2RpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVsxXS5nZXRUb05vZGUoKTpudWxsfX1jbGFzcyBaaXtjb25zdHJ1Y3Rvcigpe1ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX291dEVkZ2VzPW5ldyBMLHRoaXMuX3NvcnRlZD0hMX1nZXROZXh0RWRnZSh0KXtjb25zdCBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMuX291dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUrMSkpfWdldENvb3JkaW5hdGUoKXtjb25zdCB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7cmV0dXJuIHQubmV4dCgpLmdldENvb3JkaW5hdGUoKX1pdGVyYXRvcigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMuX291dEVkZ2VzLml0ZXJhdG9yKCl9c29ydEVkZ2VzKCl7dGhpcy5fc29ydGVkfHwoeGUuc29ydCh0aGlzLl9vdXRFZGdlcyksdGhpcy5fc29ydGVkPSEwKX1yZW1vdmUodCl7dGhpcy5fb3V0RWRnZXMucmVtb3ZlKHQpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5fb3V0RWRnZXN9Z2V0TmV4dENXRWRnZSh0KXtjb25zdCBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMuX291dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUtMSkpfWdldEluZGV4KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBXaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX291dEVkZ2VzLnNpemUoKTtlKyspe2lmKHRoaXMuX291dEVkZ2VzLmdldChlKS5nZXRFZGdlKCk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVWkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9vdXRFZGdlcy5zaXplKCk7ZSsrKXtpZih0aGlzLl9vdXRFZGdlcy5nZXQoZSk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7bGV0IHQ9YXJndW1lbnRzWzBdJXRoaXMuX291dEVkZ2VzLnNpemUoKTtyZXR1cm4gdDwwJiYodCs9dGhpcy5fb3V0RWRnZXMuc2l6ZSgpKSx0fX1hZGQodCl7dGhpcy5fb3V0RWRnZXMuYWRkKHQpLHRoaXMuX3NvcnRlZD0hMX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuc2l6ZSgpfX1jbGFzcyBqaSBleHRlbmRzIFhpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxqaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9wdD1udWxsLHRoaXMuX2RlU3Rhcj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtqaS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbmV3IFppKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wdD10LHRoaXMuX2RlU3Rhcj1lfX1zdGF0aWMgZ2V0RWRnZXNCZXR3ZWVuKHQsZSl7Y29uc3Qgbj1VaS50b0VkZ2VzKHQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKSxzPW5ldyB4dChuKSxpPVVpLnRvRWRnZXMoZS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpO3JldHVybiBzLnJldGFpbkFsbChpKSxzfWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fcHR9YWRkT3V0RWRnZSh0KXt0aGlzLl9kZVN0YXIuYWRkKHQpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0T3V0RWRnZXMoKXtyZXR1cm4gdGhpcy5fZGVTdGFyfXJlbW92ZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX3B0PW51bGw7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZGVTdGFyLnJlbW92ZSh0KX19Z2V0SW5kZXgodCl7cmV0dXJuIHRoaXMuX2RlU3Rhci5nZXRJbmRleCh0KX1nZXREZWdyZWUoKXtyZXR1cm4gdGhpcy5fZGVTdGFyLmdldERlZ3JlZSgpfX1jbGFzcyBLaSBleHRlbmRzIFdpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxLaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fWdldExpbmUoKXtyZXR1cm4gdGhpcy5fbGluZX19Y2xhc3MgUWl7Y29uc3RydWN0b3IoKXtRaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9ub2RlTWFwPW5ldyBIbn1maW5kKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLmdldCh0KX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9cmVtb3ZlKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLnJlbW92ZSh0KX12YWx1ZXMoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKX1hZGQodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHR9fWNsYXNzIEppe2NvbnN0cnVjdG9yKCl7SmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZWRnZXM9bmV3IHh0LHRoaXMuX2RpckVkZ2VzPW5ldyB4dCx0aGlzLl9ub2RlTWFwPW5ldyBRaX1maW5kTm9kZXNPZkRlZ3JlZSh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10aGlzLm5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtzLmdldERlZ3JlZSgpPT09dCYmZS5hZGQocyl9cmV0dXJuIGV9ZGlyRWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCl9ZWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9cmVtb3ZlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBXaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDApKSx0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMSkpLHRoaXMuX2VkZ2VzLnJlbW92ZSh0KSx0LnJlbW92ZSgpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVaSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10LmdldFN5bSgpO251bGwhPT1lJiZlLnNldFN5bShudWxsKSx0LmdldEZyb21Ob2RlKCkucmVtb3ZlKHQpLHQucmVtb3ZlKCksdGhpcy5fZGlyRWRnZXMucmVtb3ZlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBqaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRTeW0oKTtudWxsIT09biYmdGhpcy5yZW1vdmUobiksdGhpcy5fZGlyRWRnZXMucmVtb3ZlKHQpO2NvbnN0IHM9dC5nZXRFZGdlKCk7bnVsbCE9PXMmJnRoaXMuX2VkZ2VzLnJlbW92ZShzKX10aGlzLl9ub2RlTWFwLnJlbW92ZSh0LmdldENvb3JkaW5hdGUoKSksdC5yZW1vdmUoKX19ZmluZE5vZGUodCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuZmluZCh0KX1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31ub2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5pdGVyYXRvcigpfWNvbnRhaW5zKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBXaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVWkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9kaXJFZGdlcy5jb250YWlucyh0KX19YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBqaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbm9kZU1hcC5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFdpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlcy5hZGQodCksdGhpcy5hZGQodC5nZXREaXJFZGdlKDApKSx0aGlzLmFkZCh0LmdldERpckVkZ2UoMSkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBVaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZGlyRWRnZXMuYWRkKHQpfX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpfX1jbGFzcyAkaSBleHRlbmRzIEppe2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1hZGRFZGdlKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IGU9ZHQucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDtjb25zdCBuPWVbMF0scz1lW2UubGVuZ3RoLTFdLGk9dGhpcy5nZXROb2RlKG4pLHI9dGhpcy5nZXROb2RlKHMpLG89bmV3IEhpKGkscixlWzFdLCEwKSxsPW5ldyBIaShyLGksZVtlLmxlbmd0aC0yXSwhMSksYT1uZXcgS2kodCk7YS5zZXREaXJlY3RlZEVkZ2VzKG8sbCksdGhpcy5hZGQoYSl9Z2V0Tm9kZSh0KXtsZXQgZT10aGlzLmZpbmROb2RlKHQpO3JldHVybiBudWxsPT09ZSYmKGU9bmV3IGppKHQpLHRoaXMuYWRkKGUpKSxlfX1jbGFzcyB0cntjb25zdHJ1Y3Rvcigpe3RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW5ldyAkaSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9lZGdlU3RyaW5ncz1udWxsfWJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5pc01hcmtlZCgpfHwoZy5pc1RydWUoMj09PWUuZ2V0RGVncmVlKCkpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19YnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpOzIhPT1lLmdldERlZ3JlZSgpJiYodGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX1idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKX1nZXRNZXJnZWRMaW5lU3RyaW5ncygpe3JldHVybiB0aGlzLm1lcmdlKCksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3N9YnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQodCl7Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmdldEVkZ2UoKS5pc01hcmtlZCgpfHx0aGlzLl9lZGdlU3RyaW5ncy5hZGQodGhpcy5idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgodCkpfX1tZXJnZSgpe2lmKG51bGwhPT10aGlzLl9tZXJnZWRMaW5lU3RyaW5ncylyZXR1cm4gbnVsbDtYaS5zZXRNYXJrZWQodGhpcy5fZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpLFhpLnNldE1hcmtlZCh0aGlzLl9ncmFwaC5lZGdlSXRlcmF0b3IoKSwhMSksdGhpcy5fZWRnZVN0cmluZ3M9bmV3IEwsdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCksdGhpcy5fbWVyZ2VkTGluZVN0cmluZ3M9bmV3IEw7Zm9yKGxldCB0PXRoaXMuX2VkZ2VTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuX21lcmdlZExpbmVTdHJpbmdzLmFkZChlLnRvTGluZVN0cmluZygpKX19YWRkTGluZVN0cmluZyh0KXtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCl9YnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKHQpe2NvbnN0IGU9bmV3IGtpKHRoaXMuX2ZhY3RvcnkpO2xldCBuPXQ7ZG97ZS5hZGQobiksbi5nZXRFZGdlKCkuc2V0TWFya2VkKCEwKSxuPW4uZ2V0TmV4dCgpfXdoaWxlKG51bGwhPT1uJiZuIT09dCk7cmV0dXJuIGV9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtuIGluc3RhbmNlb2YgSiYmdGhpcy5hZGRMaW5lU3RyaW5nKG4pfX1lbHNlIGlmKEkoYXJndW1lbnRzWzBdLE4pKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuYWRkKHQpfX19YnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl9fWNsYXNzIGVye2NvbnN0cnVjdG9yKCl7ZXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcGFyZW50R3JhcGg9bnVsbCx0aGlzLl9lZGdlcz1uZXcgeHQsdGhpcy5fZGlyRWRnZXM9bmV3IEwsdGhpcy5fbm9kZU1hcD1uZXcgUWk7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50R3JhcGg9dH1kaXJFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKX1lZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50R3JhcGh9bm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAuaXRlcmF0b3IoKX1jb250YWlucyh0KXtyZXR1cm4gdGhpcy5fZWRnZXMuY29udGFpbnModCl9YWRkKHQpe2lmKHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpKXJldHVybiBudWxsO3RoaXMuX2VkZ2VzLmFkZCh0KSx0aGlzLl9kaXJFZGdlcy5hZGQodC5nZXREaXJFZGdlKDApKSx0aGlzLl9kaXJFZGdlcy5hZGQodC5nZXREaXJFZGdlKDEpKSx0aGlzLl9ub2RlTWFwLmFkZCh0LmdldERpckVkZ2UoMCkuZ2V0RnJvbU5vZGUoKSksdGhpcy5fbm9kZU1hcC5hZGQodC5nZXREaXJFZGdlKDEpLmdldEZyb21Ob2RlKCkpfX1jbGFzcyBucntjb25zdHJ1Y3Rvcigpe25yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ3JhcGg9dH1hZGRSZWFjaGFibGUodCxlKXtjb25zdCBuPW5ldyBlbjtmb3Iobi5hZGQodCk7IW4uZW1wdHkoKTspe2NvbnN0IHQ9bi5wb3AoKTt0aGlzLmFkZEVkZ2VzKHQsbixlKX19ZmluZFN1YmdyYXBoKHQpe2NvbnN0IGU9bmV3IGVyKHRoaXMuX2dyYXBoKTtyZXR1cm4gdGhpcy5hZGRSZWFjaGFibGUodCxlKSxlfWdldENvbm5lY3RlZFN1YmdyYXBocygpe2NvbnN0IHQ9bmV3IEw7WGkuc2V0VmlzaXRlZCh0aGlzLl9ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSk7Zm9yKGxldCBlPXRoaXMuX2dyYXBoLmVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXREaXJFZGdlKDApLmdldEZyb21Ob2RlKCk7bi5pc1Zpc2l0ZWQoKXx8dC5hZGQodGhpcy5maW5kU3ViZ3JhcGgobikpfXJldHVybiB0fWFkZEVkZ2VzKHQsZSxuKXt0LnNldFZpc2l0ZWQoITApO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7bi5hZGQodC5nZXRFZGdlKCkpO2NvbnN0IGk9dC5nZXRUb05vZGUoKTtpLmlzVmlzaXRlZCgpfHxlLnB1c2goaSl9fX1jbGFzcyBzcntjb25zdHJ1Y3Rvcigpe3NyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW5ldyAkaSx0aGlzLl9mYWN0b3J5PW5ldyBDdCx0aGlzLl9saW5lQ291bnQ9MCx0aGlzLl9pc1J1bj0hMSx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeT1udWxsLHRoaXMuX2lzU2VxdWVuY2VhYmxlPSExfXN0YXRpYyBmaW5kVW52aXNpdGVkQmVzdE9yaWVudGVkREUodCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmdldEVkZ2UoKS5pc1Zpc2l0ZWQoKXx8KG49dCx0LmdldEVkZ2VEaXJlY3Rpb24oKSYmKGU9dCkpfXJldHVybiBudWxsIT09ZT9lOm59c3RhdGljIGZpbmRMb3dlc3REZWdyZWVOb2RlKHQpe2xldCBlPU0uTUFYX1ZBTFVFLG49bnVsbDtmb3IobGV0IHM9dC5ub2RlSXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7KG51bGw9PT1ufHx0LmdldERlZ3JlZSgpPGUpJiYoZT10LmdldERlZ3JlZSgpLG49dCl9cmV0dXJuIG59c3RhdGljIGlzU2VxdWVuY2VkKHQpe2lmKCEodCBpbnN0YW5jZW9mIHd0KSlyZXR1cm4hMDtjb25zdCBlPXQsbj1uZXcgbHQ7bGV0IHM9bnVsbDtjb25zdCBpPW5ldyBMO2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCByPWUuZ2V0R2VvbWV0cnlOKHQpLG89ci5nZXRDb29yZGluYXRlTigwKSxsPXIuZ2V0Q29vcmRpbmF0ZU4oci5nZXROdW1Qb2ludHMoKS0xKTtpZihuLmNvbnRhaW5zKG8pKXJldHVybiExO2lmKG4uY29udGFpbnMobCkpcmV0dXJuITE7bnVsbCE9PXMmJihvLmVxdWFscyhzKXx8KG4uYWRkQWxsKGkpLGkuY2xlYXIoKSkpLGkuYWRkKG8pLGkuYWRkKGwpLHM9bH1yZXR1cm4hMH1zdGF0aWMgcmV2ZXJzZSh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPW5ldyBBcnJheShlLmxlbmd0aCkuZmlsbChudWxsKSxzPWUubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8czt0KyspbltzLTEtdF09bmV3IG0oZVt0XSk7cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobil9c3RhdGljIHNlcXVlbmNlKHQpe2NvbnN0IGU9bmV3IHNyO3JldHVybiBlLmFkZCh0KSxlLmdldFNlcXVlbmNlZExpbmVTdHJpbmdzKCl9YWRkTGluZSh0KXtudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHRoaXMuX2dyYXBoLmFkZEVkZ2UodCksdGhpcy5fbGluZUNvdW50Kyt9aGFzU2VxdWVuY2UodCl7bGV0IGU9MDtmb3IobGV0IG49dC5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmdldERlZ3JlZSgpJTI9PTEmJmUrK31yZXR1cm4gZTw9Mn1jb21wdXRlU2VxdWVuY2UoKXtpZih0aGlzLl9pc1J1bilyZXR1cm4gbnVsbDt0aGlzLl9pc1J1bj0hMDtjb25zdCB0PXRoaXMuZmluZFNlcXVlbmNlcygpO2lmKG51bGw9PT10KXJldHVybiBudWxsO3RoaXMuX3NlcXVlbmNlZEdlb21ldHJ5PXRoaXMuYnVpbGRTZXF1ZW5jZWRHZW9tZXRyeSh0KSx0aGlzLl9pc1NlcXVlbmNlYWJsZT0hMDtjb25zdCBlPXRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5LmdldE51bUdlb21ldHJpZXMoKTtnLmlzVHJ1ZSh0aGlzLl9saW5lQ291bnQ9PT1lLFwiTGluZXMgd2VyZSBtaXNzaW5nIGZyb20gcmVzdWx0XCIpLGcuaXNUcnVlKHRoaXMuX3NlcXVlbmNlZEdlb21ldHJ5IGluc3RhbmNlb2YgSnx8dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkgaW5zdGFuY2VvZiB3dCxcIlJlc3VsdCBpcyBub3QgbGluZWFsXCIpfWZpbmRTZXF1ZW5jZXMoKXtjb25zdCB0PW5ldyBMO2ZvcihsZXQgZT1uZXcgbnIodGhpcy5fZ3JhcGgpLmdldENvbm5lY3RlZFN1YmdyYXBocygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKCF0aGlzLmhhc1NlcXVlbmNlKG4pKXJldHVybiBudWxsO3tjb25zdCBlPXRoaXMuZmluZFNlcXVlbmNlKG4pO3QuYWRkKGUpfX1yZXR1cm4gdH1hZGRSZXZlcnNlU3VicGF0aCh0LGUsbil7Y29uc3Qgcz10LmdldFRvTm9kZSgpO2xldCBpPW51bGw7Zm9yKDs7KXtlLmFkZCh0LmdldFN5bSgpKSx0LmdldEVkZ2UoKS5zZXRWaXNpdGVkKCEwKSxpPXQuZ2V0RnJvbU5vZGUoKTtjb25zdCBuPXNyLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERShpKTtpZihudWxsPT09bilicmVhazt0PW4uZ2V0U3ltKCl9biYmZy5pc1RydWUoaT09PXMsXCJwYXRoIG5vdCBjb250aWd1b3VzXCIpfWZpbmRTZXF1ZW5jZSh0KXtYaS5zZXRWaXNpdGVkKHQuZWRnZUl0ZXJhdG9yKCksITEpO2NvbnN0IGU9c3IuZmluZExvd2VzdERlZ3JlZU5vZGUodCkuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpLm5leHQoKS5nZXRTeW0oKSxuPW5ldyBjaSxzPW4ubGlzdEl0ZXJhdG9yKCk7Zm9yKHRoaXMuYWRkUmV2ZXJzZVN1YnBhdGgoZSxzLCExKTtzLmhhc1ByZXZpb3VzKCk7KXtjb25zdCB0PXMucHJldmlvdXMoKSxlPXNyLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERSh0LmdldEZyb21Ob2RlKCkpO251bGwhPT1lJiZ0aGlzLmFkZFJldmVyc2VTdWJwYXRoKGUuZ2V0U3ltKCkscywhMCl9cmV0dXJuIHRoaXMub3JpZW50KG4pfXJldmVyc2UodCl7Y29uc3QgZT1uZXcgY2k7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGRGaXJzdCh0LmdldFN5bSgpKX1yZXR1cm4gZX1vcmllbnQodCl7Y29uc3QgZT10LmdldCgwKSxuPXQuZ2V0KHQuc2l6ZSgpLTEpLHM9ZS5nZXRGcm9tTm9kZSgpLGk9bi5nZXRUb05vZGUoKTtsZXQgcj0hMTtpZigxPT09cy5nZXREZWdyZWUoKXx8MT09PWkuZ2V0RGVncmVlKCkpe2xldCB0PSExOzE9PT1uLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpJiYhMT09PW4uZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSEwKSwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYhMD09PWUuZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSExKSx0fHwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYocj0hMCl9cmV0dXJuIHI/dGhpcy5yZXZlcnNlKHQpOnR9YnVpbGRTZXF1ZW5jZWRHZW9tZXRyeSh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtmb3IobGV0IHQ9bi5uZXh0KCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldEVkZ2UoKS5nZXRMaW5lKCk7bGV0IGk9cztuLmdldEVkZ2VEaXJlY3Rpb24oKXx8cy5pc0Nsb3NlZCgpfHwoaT1zci5yZXZlcnNlKHMpKSxlLmFkZChpKX19cmV0dXJuIDA9PT1lLnNpemUoKT90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk6dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KGUpfWdldFNlcXVlbmNlZExpbmVTdHJpbmdzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVNlcXVlbmNlKCksdGhpcy5fc2VxdWVuY2VkR2VvbWV0cnl9aXNTZXF1ZW5jZWFibGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlU2VxdWVuY2UoKSx0aGlzLl9pc1NlcXVlbmNlYWJsZX1hZGQoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2FyZ3VtZW50c1swXS5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2tdfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgSiYmdGhpcy5hZGRMaW5lKHQpfX0pfX19dmFyIGlyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLExpbmVNZXJnZXI6dHIsTGluZVNlcXVlbmNlcjpzcn0pO2NsYXNzIHJye2NvbnN0cnVjdG9yKCl7cnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc25hcFRvbGVyYW5jZT0wLHRoaXMuX3NyY1B0cz1udWxsLHRoaXMuX3NlZz1uZXcgS3QsdGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9ITEsdGhpcy5faXNDbG9zZWQ9ITEsYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBKJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZXMoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3NyY1B0cz10LHRoaXMuX2lzQ2xvc2VkPXJyLmlzQ2xvc2VkKHQpLHRoaXMuX3NuYXBUb2xlcmFuY2U9ZX19c3RhdGljIGlzQ2xvc2VkKHQpe3JldHVybiEodC5sZW5ndGg8PTEpJiZ0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfXNuYXBWZXJ0aWNlcyh0LGUpe2NvbnN0IG49dGhpcy5faXNDbG9zZWQ/dC5zaXplKCktMTp0LnNpemUoKTtmb3IobGV0IHM9MDtzPG47cysrKXtjb25zdCBuPXQuZ2V0KHMpLGk9dGhpcy5maW5kU25hcEZvclZlcnRleChuLGUpO251bGwhPT1pJiYodC5zZXQocyxuZXcgbShpKSksMD09PXMmJnRoaXMuX2lzQ2xvc2VkJiZ0LnNldCh0LnNpemUoKS0xLG5ldyBtKGkpKSl9fWZpbmRTbmFwRm9yVmVydGV4KHQsZSl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2lmKHQuZXF1YWxzMkQoZVtuXSkpcmV0dXJuIG51bGw7aWYodC5kaXN0YW5jZShlW25dKTx0aGlzLl9zbmFwVG9sZXJhbmNlKXJldHVybiBlW25dfXJldHVybiBudWxsfXNuYXBUbyh0KXtjb25zdCBlPW5ldyBSKHRoaXMuX3NyY1B0cyk7dGhpcy5zbmFwVmVydGljZXMoZSx0KSx0aGlzLnNuYXBTZWdtZW50cyhlLHQpO3JldHVybiBlLnRvQ29vcmRpbmF0ZUFycmF5KCl9c25hcFNlZ21lbnRzKHQsZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiBudWxsO2xldCBuPWUubGVuZ3RoO2VbMF0uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkmJihuPWUubGVuZ3RoLTEpO2ZvcihsZXQgcz0wO3M8bjtzKyspe2NvbnN0IG49ZVtzXSxpPXRoaXMuZmluZFNlZ21lbnRJbmRleFRvU25hcChuLHQpO2k+PTAmJnQuYWRkKGkrMSxuZXcgbShuKSwhMSl9fWZpbmRTZWdtZW50SW5kZXhUb1NuYXAodCxlKXtsZXQgbj1yLk1BWF9WQUxVRSxzPS0xO2ZvcihsZXQgaT0wO2k8ZS5zaXplKCktMTtpKyspe2lmKHRoaXMuX3NlZy5wMD1lLmdldChpKSx0aGlzLl9zZWcucDE9ZS5nZXQoaSsxKSx0aGlzLl9zZWcucDAuZXF1YWxzMkQodCl8fHRoaXMuX3NlZy5wMS5lcXVhbHMyRCh0KSl7aWYodGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpY29udGludWU7cmV0dXJuLTF9Y29uc3Qgcj10aGlzLl9zZWcuZGlzdGFuY2UodCk7cjx0aGlzLl9zbmFwVG9sZXJhbmNlJiZyPG4mJihuPXIscz1pKX1yZXR1cm4gc31zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0KXt0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz10fX1jbGFzcyBvcntjb25zdHJ1Y3Rvcigpe29yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NyY0dlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zcmNHZW9tPXR9c3RhdGljIHNuYXAodCxlLG4pe2NvbnN0IHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksaT1uZXcgb3IodCk7c1swXT1pLnNuYXBUbyhlLG4pO2NvbnN0IHI9bmV3IG9yKGUpO3JldHVybiBzWzFdPXIuc25hcFRvKHNbMF0sbiksc31zdGF0aWMgY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPW9yLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKHQpO2NvbnN0IG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpO2lmKG4uZ2V0VHlwZSgpPT09TnQuRklYRUQpe2NvbnN0IHQ9MS9uLmdldFNjYWxlKCkqMi8xLjQxNTt0PmUmJihlPXQpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gTWF0aC5taW4ob3IuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHQpLG9yLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShlKSl9fXN0YXRpYyBjb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiBNYXRoLm1pbihlLmdldEhlaWdodCgpLGUuZ2V0V2lkdGgoKSkqb3IuU05BUF9QUkVDSVNJT05fRkFDVE9SfXN0YXRpYyBzbmFwVG9TZWxmKHQsZSxuKXtyZXR1cm4gbmV3IG9yKHQpLnNuYXBUb1NlbGYoZSxuKX1zbmFwVG8odCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpO3JldHVybiBuZXcgbHIoZSxuKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSl9c25hcFRvU2VsZih0LGUpe2NvbnN0IG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5fc3JjR2VvbSkscz1uZXcgbHIodCxuLCEwKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSk7bGV0IGk9cztyZXR1cm4gZSYmSShpLHN0KSYmKGk9cy5idWZmZXIoMCkpLGl9Y29tcHV0ZVNuYXBUb2xlcmFuY2UodCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpLzEwfWV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBsdCxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyllLmFkZChuW3RdKTtyZXR1cm4gZS50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgodCl7bGV0IGU9ci5NQVhfVkFMVUU7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl7Y29uc3Qgcz10W25dLmRpc3RhbmNlKHRbbisxXSk7czxlJiYoZT1zKX1yZXR1cm4gZX19b3IuU05BUF9QUkVDSVNJT05fRkFDVE9SPTFlLTk7Y2xhc3MgbHIgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuX3NuYXBQdHM9bnVsbCx0aGlzLl9pc1NlbGZTbmFwPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9zbmFwVG9sZXJhbmNlPXQsdGhpcy5fc25hcFB0cz1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3NuYXBUb2xlcmFuY2U9dCx0aGlzLl9zbmFwUHRzPWUsdGhpcy5faXNTZWxmU25hcD1ufX1zbmFwTGluZSh0LGUpe2NvbnN0IG49bmV3IHJyKHQsdGhpcy5fc25hcFRvbGVyYW5jZSk7cmV0dXJuIG4uc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModGhpcy5faXNTZWxmU25hcCksbi5zbmFwVG8oZSl9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxzPXRoaXMuc25hcExpbmUobix0aGlzLl9zbmFwUHRzKTtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfX12YXIgYXI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlTbmFwcGVyOm9yLExpbmVTdHJpbmdTbmFwcGVyOnJyfSk7Y2xhc3MgY3J7Y29uc3RydWN0b3IoKXtjci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl9kYXRhPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fZGF0YT1lfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0c31zaXplKCl7cmV0dXJuIHRoaXMuX3B0cy5sZW5ndGh9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzW3RdfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGgtMV0pfWdldFNlZ21lbnRPY3RhbnQodCl7cmV0dXJuIHQ9PT10aGlzLl9wdHMubGVuZ3RoLTE/LTE6WHMub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXRvU3RyaW5nKCl7cmV0dXJuIFd0LnRvTGluZVN0cmluZyhuZXcgcHQodGhpcy5fcHRzKSl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1VzXX19Y2xhc3MgaHJ7Y29uc3RydWN0b3IoKXtoci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5PSExLHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zPSEwLHRoaXMuX2lzSW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seT0hMSx0aGlzLl9saT1udWxsLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPW51bGwsdGhpcy5faW50U2VnbWVudHM9bnVsbCx0aGlzLl9pbnRlcnNlY3Rpb25zPW5ldyBMLHRoaXMuX2ludGVyc2VjdGlvbkNvdW50PTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj1udWxsfXN0YXRpYyBjcmVhdGVBbGxJbnRlcnNlY3Rpb25zRmluZGVyKHQpe2NvbnN0IGU9bmV3IGhyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlfXN0YXRpYyBpc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzNdO3JldHVybighYXJndW1lbnRzWzJdfHwhbikmJiEhdC5lcXVhbHMyRChlKX1pZig4PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV0sbz1hcmd1bWVudHNbNl0sbD1hcmd1bWVudHNbN107cmV0dXJuISFoci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKHQsbixpLG8pfHwoISFoci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKHQscyxpLGwpfHwoISFoci5pc0ludGVyaW9yVmVydGV4SW50ZXJzZWN0aW9uKGUsbixyLG8pfHwhIWhyLmlzSW50ZXJpb3JWZXJ0ZXhJbnRlcnNlY3Rpb24oZSxzLHIsbCkpKX19c3RhdGljIGNyZWF0ZUludGVyaW9ySW50ZXJzZWN0aW9uQ291bnRlcih0KXtjb25zdCBlPW5ldyBocih0KTtyZXR1cm4gZS5zZXRJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5KCEwKSxlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEtlZXBJbnRlcnNlY3Rpb25zKCExKSxlfXN0YXRpYyBjcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyKHQpe2NvbnN0IGU9bmV3IGhyKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEtlZXBJbnRlcnNlY3Rpb25zKCExKSxlfXN0YXRpYyBpc0VuZFNlZ21lbnQodCxlKXtyZXR1cm4gMD09PWV8fGU+PXQuc2l6ZSgpLTJ9c3RhdGljIGNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlcih0KXtyZXR1cm4gbmV3IGhyKHQpfXN0YXRpYyBjcmVhdGVJbnRlcmlvckludGVyc2VjdGlvbnNGaW5kZXIodCl7Y29uc3QgZT1uZXcgaHIodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuc2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seSghMCksZX1zZXRDaGVja0VuZFNlZ21lbnRzT25seSh0KXt0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5PXR9Z2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKXtyZXR1cm4gdGhpcy5faW50U2VnbWVudHN9Y291bnQoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uQ291bnR9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25zfXNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9c2V0S2VlcEludGVyc2VjdGlvbnModCl7dGhpcy5fa2VlcEludGVyc2VjdGlvbnM9dH1nZXRJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7aWYoIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zJiZ0aGlzLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiBudWxsO2NvbnN0IGk9dD09PW47aWYoaSYmZT09PXMpcmV0dXJuIG51bGw7aWYodGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seSl7aWYoIShoci5pc0VuZFNlZ21lbnQodCxlKXx8aHIuaXNFbmRTZWdtZW50KG4scykpKXJldHVybiBudWxsfWNvbnN0IHI9dC5nZXRDb29yZGluYXRlKGUpLG89dC5nZXRDb29yZGluYXRlKGUrMSksbD1uLmdldENvb3JkaW5hdGUocyksYT1uLmdldENvb3JkaW5hdGUocysxKSxjPTA9PT1lLGg9ZSsyPT09dC5zaXplKCksdT0wPT09cyxnPXMrMj09PW4uc2l6ZSgpO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocixvLGwsYSk7Y29uc3QgZD10aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpO2xldCBfPSExO2lmKCF0aGlzLl9pc0ludGVyaW9ySW50ZXJzZWN0aW9uc09ubHkpe189IShpJiZNYXRoLmFicyhzLWUpPD0xKSYmaHIuaXNJbnRlcmlvclZlcnRleEludGVyc2VjdGlvbihyLG8sbCxhLGMsaCx1LGcpfShkfHxfKSYmKHRoaXMuX2ludFNlZ21lbnRzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX2ludFNlZ21lbnRzWzBdPXIsdGhpcy5faW50U2VnbWVudHNbMV09byx0aGlzLl9pbnRTZWdtZW50c1syXT1sLHRoaXMuX2ludFNlZ21lbnRzWzNdPWEsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApLHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zJiZ0aGlzLl9pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiksdGhpcy5faW50ZXJzZWN0aW9uQ291bnQrKyl9aGFzSW50ZXJzZWN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMmJm51bGwhPT10aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1zZXRJbnRlcmlvckludGVyc2VjdGlvbnNPbmx5KHQpe3RoaXMuX2lzSW50ZXJpb3JJbnRlcnNlY3Rpb25zT25seT10fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltUaV19fWNsYXNzIHVye2NvbnN0cnVjdG9yKCl7dXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGk9bmV3IGp0LHRoaXMuX3NlZ1N0cmluZ3M9bnVsbCx0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz0hMSx0aGlzLl9zZWdJbnQ9bnVsbCx0aGlzLl9pc1ZhbGlkPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZ1N0cmluZ3M9dH1zdGF0aWMgY29tcHV0ZUludGVyc2VjdGlvbnModCl7Y29uc3QgZT1uZXcgdXIodCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuaXNWYWxpZCgpLGUuZ2V0SW50ZXJzZWN0aW9ucygpfWV4ZWN1dGUoKXtpZihudWxsIT09dGhpcy5fc2VnSW50KXJldHVybiBudWxsO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKX1nZXRJbnRlcnNlY3Rpb25zKCl7cmV0dXJuIHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25zKCl9aXNWYWxpZCgpe3JldHVybiB0aGlzLmV4ZWN1dGUoKSx0aGlzLl9pc1ZhbGlkfXNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9Y2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKXt0aGlzLl9pc1ZhbGlkPSEwLHRoaXMuX3NlZ0ludD1uZXcgaHIodGhpcy5fbGkpLHRoaXMuX3NlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyk7Y29uc3QgdD1uZXcgJHM7aWYodC5zZXRTZWdtZW50SW50ZXJzZWN0b3IodGhpcy5fc2VnSW50KSx0LmNvbXB1dGVOb2Rlcyh0aGlzLl9zZWdTdHJpbmdzKSx0aGlzLl9zZWdJbnQuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIHRoaXMuX2lzVmFsaWQ9ITEsbnVsbH1jaGVja1ZhbGlkKCl7aWYodGhpcy5leGVjdXRlKCksIXRoaXMuX2lzVmFsaWQpdGhyb3cgbmV3IHNzKHRoaXMuZ2V0RXJyb3JNZXNzYWdlKCksdGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvbigpKX1nZXRFcnJvck1lc3NhZ2UoKXtpZih0aGlzLl9pc1ZhbGlkKXJldHVyblwibm8gaW50ZXJzZWN0aW9ucyBmb3VuZFwiO2NvbnN0IHQ9dGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7cmV0dXJuXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gXCIrV3QudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSkrXCIgYW5kIFwiK1d0LnRvTGluZVN0cmluZyh0WzJdLHRbM10pfX1jbGFzcyBncntjb25zdHJ1Y3Rvcigpe2dyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX252PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbnY9bmV3IHVyKGdyLnRvU2VnbWVudFN0cmluZ3ModCkpfXN0YXRpYyB0b1NlZ21lbnRTdHJpbmdzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGQobmV3IGNyKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSl9cmV0dXJuIGV9c3RhdGljIGNoZWNrVmFsaWQodCl7bmV3IGdyKHQpLmNoZWNrVmFsaWQoKX1jaGVja1ZhbGlkKCl7dGhpcy5fbnYuY2hlY2tWYWxpZCgpfX1jbGFzcyBkcntjb25zdHJ1Y3Rvcigpe2RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX29wPW51bGwsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5fcHRMb2NhdG9yPW51bGwsdGhpcy5fbGluZUVkZ2VzTGlzdD1uZXcgTCx0aGlzLl9yZXN1bHRMaW5lTGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9vcD10LHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1lLHRoaXMuX3B0TG9jYXRvcj1ufWNvbGxlY3RMaW5lcyh0KXtmb3IobGV0IGU9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuY29sbGVjdExpbmVFZGdlKG4sdCx0aGlzLl9saW5lRWRnZXNMaXN0KSx0aGlzLmNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZShuLHQsdGhpcy5fbGluZUVkZ2VzTGlzdCl9fWxhYmVsSXNvbGF0ZWRMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLl9wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX29wLmdldEFyZ0dlb21ldHJ5KGUpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX1idWlsZCh0KXtyZXR1cm4gdGhpcy5maW5kQ292ZXJlZExpbmVFZGdlcygpLHRoaXMuY29sbGVjdExpbmVzKHQpLHRoaXMuYnVpbGRMaW5lcyh0KSx0aGlzLl9yZXN1bHRMaW5lTGlzdH1jb2xsZWN0TGluZUVkZ2UodCxlLG4pe2NvbnN0IHM9dC5nZXRMYWJlbCgpLGk9dC5nZXRFZGdlKCk7dC5pc0xpbmVFZGdlKCkmJih0LmlzVmlzaXRlZCgpfHwhTnIuaXNSZXN1bHRPZk9wKHMsZSl8fGkuaXNDb3ZlcmVkKCl8fChuLmFkZChpKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpfWZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5maW5kQ292ZXJlZExpbmVFZGdlcygpfWZvcihsZXQgdD10aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldEVkZ2UoKTtpZihlLmlzTGluZUVkZ2UoKSYmIW4uaXNDb3ZlcmVkU2V0KCkpe2NvbnN0IHQ9dGhpcy5fb3AuaXNDb3ZlcmVkQnlBKGUuZ2V0Q29vcmRpbmF0ZSgpKTtuLnNldENvdmVyZWQodCl9fX1sYWJlbElzb2xhdGVkTGluZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldExhYmVsKCk7dC5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKHQsMCk6dGhpcy5sYWJlbElzb2xhdGVkTGluZSh0LDEpKX19YnVpbGRMaW5lcyh0KXtmb3IobGV0IHQ9dGhpcy5fbGluZUVkZ2VzTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fcmVzdWx0TGluZUxpc3QuYWRkKG4pLGUuc2V0SW5SZXN1bHQoITApfX1jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UodCxlLG4pe2NvbnN0IHM9dC5nZXRMYWJlbCgpO3JldHVybiB0LmlzTGluZUVkZ2UoKXx8dC5pc1Zpc2l0ZWQoKXx8dC5pc0ludGVyaW9yQXJlYUVkZ2UoKXx8dC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpP251bGw6KGcuaXNUcnVlKCEodC5pc0luUmVzdWx0KCl8fHQuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKXx8IXQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSksdm9pZChOci5pc1Jlc3VsdE9mT3AocyxlKSYmZT09PU5yLklOVEVSU0VDVElPTiYmKG4uYWRkKHQuZ2V0RWRnZSgpKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpKX19Y2xhc3MgX3J7Y29uc3RydWN0b3IoKXtfci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9vcD1udWxsLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3Jlc3VsdFBvaW50TGlzdD1uZXcgTDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9vcD10LHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1lfWZpbHRlckNvdmVyZWROb2RlVG9Qb2ludCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKCF0aGlzLl9vcC5pc0NvdmVyZWRCeUxBKGUpKXtjb25zdCB0PXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKTt0aGlzLl9yZXN1bHRQb2ludExpc3QuYWRkKHQpfX1leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYoIW4uaXNJblJlc3VsdCgpJiYoIW4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpJiYoMD09PW4uZ2V0RWRnZXMoKS5nZXREZWdyZWUoKXx8dD09PU5yLklOVEVSU0VDVElPTikpKXtjb25zdCBlPW4uZ2V0TGFiZWwoKTtOci5pc1Jlc3VsdE9mT3AoZSx0KSYmdGhpcy5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQobil9fX1idWlsZCh0KXtyZXR1cm4gdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpLHRoaXMuX3Jlc3VsdFBvaW50TGlzdH19Y2xhc3MgcHJ7Y29uc3RydWN0b3IoKXt0aGlzLl9pc0ZpcnN0PSEwLHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50PTUzLHRoaXMuX2NvbW1vbkJpdHM9bmV3IGksdGhpcy5fY29tbW9uU2lnbkV4cD1udWxsfWdldENvbW1vbigpe3JldHVybiByLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5fY29tbW9uQml0cyl9YWRkKHQpe2NvbnN0IGU9ci5kb3VibGVUb0xvbmdCaXRzKHQpO2lmKHRoaXMuX2lzRmlyc3QpcmV0dXJuIHRoaXMuX2NvbW1vbkJpdHM9ZSx0aGlzLl9jb21tb25TaWduRXhwPXByLnNpZ25FeHBCaXRzKHRoaXMuX2NvbW1vbkJpdHMpLHRoaXMuX2lzRmlyc3Q9ITEsbnVsbDtpZihwci5zaWduRXhwQml0cyhlKSE9PXRoaXMuX2NvbW1vblNpZ25FeHApcmV0dXJuIHRoaXMuX2NvbW1vbkJpdHMuaGlnaD0wLHRoaXMuX2NvbW1vbkJpdHMubG93PTAsbnVsbDt0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudD1wci5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHRoaXMuX2NvbW1vbkJpdHMsZSksdGhpcy5fY29tbW9uQml0cz1wci56ZXJvTG93ZXJCaXRzKHRoaXMuX2NvbW1vbkJpdHMsNjQtKDEyK3RoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50KSl9dG9TdHJpbmcoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1yLmxvbmdCaXRzVG9Eb3VibGUodCksbj1cIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIitpLnRvQmluYXJ5U3RyaW5nKHQpLHM9bi5zdWJzdHJpbmcobi5sZW5ndGgtNjQpO3JldHVybiBzLnN1YnN0cmluZygwLDEpK1wiICBcIitzLnN1YnN0cmluZygxLDEyKStcIihleHApIFwiK3Muc3Vic3RyaW5nKDEyKStcIiBbIFwiK2UrXCIgXVwifX1nZXRDbGFzcygpe3JldHVybiBwcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX1zdGF0aWMgZ2V0Qml0KHQsZSl7Y29uc3Qgbj0xPDxlJTMyO3JldHVybiBlPDMyPzAhPSh0LmxvdyZuKT8xOjA6MCE9KHQuaGlnaCZuKT8xOjB9c3RhdGljIHNpZ25FeHBCaXRzKHQpe3JldHVybiB0LmhpZ2g+Pj4yMH1zdGF0aWMgemVyb0xvd2VyQml0cyh0LGUpe2xldCBuPVwibG93XCI7aWYoZT4zMiYmKHQubG93PTAsZSU9MzIsbj1cImhpZ2hcIiksZT4wKXtjb25zdCBzPWU8MzI/figoMTw8ZSktMSk6MDt0W25dJj1zfXJldHVybiB0fXN0YXRpYyBudW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHQsZSl7bGV0IG49MDtmb3IobGV0IHM9NTI7cz49MDtzLS0pe2lmKHByLmdldEJpdCh0LHMpIT09cHIuZ2V0Qml0KGUscykpcmV0dXJuIG47bisrfXJldHVybiA1Mn19Y2xhc3MgbXJ7Y29uc3RydWN0b3IoKXttci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb21tb25Db29yZD1udWxsLHRoaXMuX2NjRmlsdGVyPW5ldyBmcn1hZGRDb21tb25CaXRzKHQpe2NvbnN0IGU9bmV3IHlyKHRoaXMuX2NvbW1vbkNvb3JkKTt0LmFwcGx5KGUpLHQuZ2VvbWV0cnlDaGFuZ2VkKCl9cmVtb3ZlQ29tbW9uQml0cyh0KXtpZigwPT09dGhpcy5fY29tbW9uQ29vcmQueCYmMD09PXRoaXMuX2NvbW1vbkNvb3JkLnkpcmV0dXJuIHQ7Y29uc3QgZT1uZXcgbSh0aGlzLl9jb21tb25Db29yZCk7ZS54PS1lLngsZS55PS1lLnk7Y29uc3Qgbj1uZXcgeXIoZSk7cmV0dXJuIHQuYXBwbHkobiksdC5nZW9tZXRyeUNoYW5nZWQoKSx0fWdldENvbW1vbkNvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fY29tbW9uQ29vcmR9YWRkKHQpe3QuYXBwbHkodGhpcy5fY2NGaWx0ZXIpLHRoaXMuX2NvbW1vbkNvb3JkPXRoaXMuX2NjRmlsdGVyLmdldENvbW1vbkNvb3JkaW5hdGUoKX19Y2xhc3MgZnJ7Y29uc3RydWN0b3IoKXtmci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb21tb25CaXRzWD1uZXcgcHIsdGhpcy5fY29tbW9uQml0c1k9bmV3IHByfWZpbHRlcih0KXt0aGlzLl9jb21tb25CaXRzWC5hZGQodC54KSx0aGlzLl9jb21tb25CaXRzWS5hZGQodC55KX1nZXRDb21tb25Db29yZGluYXRlKCl7cmV0dXJuIG5ldyBtKHRoaXMuX2NvbW1vbkJpdHNYLmdldENvbW1vbigpLHRoaXMuX2NvbW1vbkJpdHNZLmdldENvbW1vbigpKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVV19fWNsYXNzIHlye2NvbnN0cnVjdG9yKCl7eXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy50cmFucz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMudHJhbnM9dH1maWx0ZXIodCxlKXtjb25zdCBuPXQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLnRyYW5zLngscz10LmdldE9yZGluYXRlKGUsMSkrdGhpcy50cmFucy55O3Quc2V0T3JkaW5hdGUoZSwwLG4pLHQuc2V0T3JkaW5hdGUoZSwxLHMpfWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1BdfX1tci5Db21tb25Db29yZGluYXRlRmlsdGVyPWZyLG1yLlRyYW5zbGF0ZXI9eXI7Y2xhc3MgeHJ7Y29uc3RydWN0b3IoKXt4ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuX3NuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLl9jYnI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lLHRoaXMuY29tcHV0ZVNuYXBUb2xlcmFuY2UoKX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IHhyKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIHhyLm92ZXJsYXlPcCh0LGUsTnIuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4geHIub3ZlcmxheU9wKHQsZSxOci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7cmV0dXJuIHhyLm92ZXJsYXlPcCh0LGUsTnIuU1lNRElGRkVSRU5DRSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtyZXR1cm4geHIub3ZlcmxheU9wKHQsZSxOci5ESUZGRVJFTkNFKX1zZWxmU25hcCh0KXtyZXR1cm4gbmV3IG9yKHQpLnNuYXBUbyh0LHRoaXMuX3NuYXBUb2xlcmFuY2UpfXJlbW92ZUNvbW1vbkJpdHModCl7dGhpcy5fY2JyPW5ldyBtcix0aGlzLl9jYnIuYWRkKHRbMF0pLHRoaXMuX2Nici5hZGQodFsxXSk7Y29uc3QgZT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gZVswXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzBdLmNvcHkoKSksZVsxXT10aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzFdLmNvcHkoKSksZX1wcmVwYXJlUmVzdWx0KHQpe3JldHVybiB0aGlzLl9jYnIuYWRkQ29tbW9uQml0cyh0KSx0fWdldFJlc3VsdEdlb21ldHJ5KHQpe2NvbnN0IGU9dGhpcy5zbmFwKHRoaXMuX2dlb20pLG49TnIub3ZlcmxheU9wKGVbMF0sZVsxXSx0KTtyZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KG4pfWNoZWNrVmFsaWQodCl7dC5pc1ZhbGlkKCl8fEIub3V0LnByaW50bG4oXCJTbmFwcGVkIGdlb21ldHJ5IGlzIGludmFsaWRcIil9Y29tcHV0ZVNuYXBUb2xlcmFuY2UoKXt0aGlzLl9zbmFwVG9sZXJhbmNlPW9yLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0pfXNuYXAodCl7Y29uc3QgZT10aGlzLnJlbW92ZUNvbW1vbkJpdHModCk7cmV0dXJuIG9yLnNuYXAoZVswXSxlWzFdLHRoaXMuX3NuYXBUb2xlcmFuY2UpfX1jbGFzcyBFcntjb25zdHJ1Y3Rvcigpe0VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZX1zdGF0aWMgb3ZlcmxheU9wKHQsZSxuKXtyZXR1cm4gbmV3IEVyKHQsZSkuZ2V0UmVzdWx0R2VvbWV0cnkobil9c3RhdGljIHVuaW9uKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsTnIuVU5JT04pfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSxOci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7cmV0dXJuIEVyLm92ZXJsYXlPcCh0LGUsTnIuU1lNRElGRkVSRU5DRSl9c3RhdGljIGRpZmZlcmVuY2UodCxlKXtyZXR1cm4gRXIub3ZlcmxheU9wKHQsZSxOci5ESUZGRVJFTkNFKX1nZXRSZXN1bHRHZW9tZXRyeSh0KXtsZXQgZT1udWxsLG49ITEscz1udWxsO3RyeXtlPU5yLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLHRoaXMuX2dlb21bMV0sdCk7ITAmJihuPSEwKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBoKSl0aHJvdyB0O3M9dH1pZighbil0cnl7ZT14ci5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdLHQpfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBoP3M6dH1yZXR1cm4gZX19Y2xhc3MgSXJ7Y29uc3RydWN0b3IoKXtJci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXtpZih0aGlzLl9saT1uZXcganQsdGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9hcmc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuX2FyZz1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSx0aGlzLl9hcmdbMF09bmV3IGxzKDAsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsZ24uT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0LmdldFByZWNpc2lvbk1vZGVsKCkuY29tcGFyZVRvKGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk+PTA/dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpOnRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZS5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBscygwLHQsbiksdGhpcy5fYXJnWzFdPW5ldyBscygxLGUsbil9fWdldEFyZ0dlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9hcmdbdF0uZ2V0R2VvbWV0cnkoKX1zZXRDb21wdXRhdGlvblByZWNpc2lvbih0KXt0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbD10LHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsKX19Y2xhc3MgTnIgZXh0ZW5kcyBJcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRMb2NhdG9yPW5ldyBmbix0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX3Jlc3VsdEdlb209bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2VkZ2VMaXN0PW5ldyBMaSx0aGlzLl9yZXN1bHRQb2x5TGlzdD1uZXcgTCx0aGlzLl9yZXN1bHRMaW5lTGlzdD1uZXcgTCx0aGlzLl9yZXN1bHRQb2ludExpc3Q9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX2dyYXBoPW5ldyBvcyhuZXcgd2kpLHRoaXMuX2dlb21GYWN0PXQuZ2V0RmFjdG9yeSgpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgTnIodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gTnIuY3JlYXRlRW1wdHlSZXN1bHQoTnIuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBzKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBFci5vdmVybGF5T3AodCxlLE5yLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXJldHVybiBOci5jcmVhdGVFbXB0eVJlc3VsdChOci5JTlRFUlNFQ1RJT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe2NvbnN0IG49ZTtyZXR1cm4gY2UubWFwKHQsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltNYXBPcF19bWFwKHQpe3JldHVybiBOci5pbnRlcnNlY3Rpb24odCxuKX19KX1yZXR1cm4gRXIub3ZlcmxheU9wKHQsZSxOci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIE5yLmNyZWF0ZUVtcHR5UmVzdWx0KE5yLlNZTURJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBzKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBFci5vdmVybGF5T3AodCxlLE5yLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyByZXN1bHREaW1lbnNpb24odCxlLG4pe2NvbnN0IHM9ZS5nZXREaW1lbnNpb24oKSxpPW4uZ2V0RGltZW5zaW9uKCk7bGV0IHI9LTE7c3dpdGNoKHQpe2Nhc2UgTnIuSU5URVJTRUNUSU9OOnI9TWF0aC5taW4ocyxpKTticmVhaztjYXNlIE5yLlVOSU9OOnI9TWF0aC5tYXgocyxpKTticmVhaztjYXNlIE5yLkRJRkZFUkVOQ0U6cj1zO2JyZWFrO2Nhc2UgTnIuU1lNRElGRkVSRU5DRTpyPU1hdGgubWF4KHMsaSl9cmV0dXJuIHJ9c3RhdGljIGNyZWF0ZUVtcHR5UmVzdWx0KHQsZSxuLHMpe2NvbnN0IGk9TnIucmVzdWx0RGltZW5zaW9uKHQsZSxuKTtyZXR1cm4gcy5jcmVhdGVFbXB0eShpKX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBOci5jcmVhdGVFbXB0eVJlc3VsdChOci5ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBzKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBFci5vdmVybGF5T3AodCxlLE5yLkRJRkZFUkVOQ0UpfXN0YXRpYyBpc1Jlc3VsdE9mT3AoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldExvY2F0aW9uKDApLHM9dC5nZXRMb2NhdGlvbigxKTtyZXR1cm4gTnIuaXNSZXN1bHRPZk9wKG4scyxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3N3aXRjaCh0PT09UXQuQk9VTkRBUlkmJih0PVF0LklOVEVSSU9SKSxlPT09UXQuQk9VTkRBUlkmJihlPVF0LklOVEVSSU9SKSxuKXtjYXNlIE5yLklOVEVSU0VDVElPTjpyZXR1cm4gdD09PVF0LklOVEVSSU9SJiZlPT09UXQuSU5URVJJT1I7Y2FzZSBOci5VTklPTjpyZXR1cm4gdD09PVF0LklOVEVSSU9SfHxlPT09UXQuSU5URVJJT1I7Y2FzZSBOci5ESUZGRVJFTkNFOnJldHVybiB0PT09UXQuSU5URVJJT1ImJmUhPT1RdC5JTlRFUklPUjtjYXNlIE5yLlNZTURJRkZFUkVOQ0U6cmV0dXJuIHQ9PT1RdC5JTlRFUklPUiYmZSE9PVF0LklOVEVSSU9SfHx0IT09UXQuSU5URVJJT1ImJmU9PT1RdC5JTlRFUklPUn1yZXR1cm4hMX19aW5zZXJ0VW5pcXVlRWRnZSh0KXtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe2NvbnN0IG49ZS5nZXRMYWJlbCgpO2xldCBzPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChzPW5ldyBxbih0LmdldExhYmVsKCkpLHMuZmxpcCgpKTtjb25zdCBpPWUuZ2V0RGVwdGgoKTtpLmlzTnVsbCgpJiZpLmFkZChuKSxpLmFkZChzKSxuLm1lcmdlKHMpfWVsc2UgdGhpcy5fZWRnZUxpc3QuYWRkKHQpfWdldEdyYXBoKCl7cmV0dXJuIHRoaXMuX2dyYXBofWNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldFN5bSgpO2UuaXNJblJlc3VsdCgpJiZuLmlzSW5SZXN1bHQoKSYmKGUuc2V0SW5SZXN1bHQoITEpLG4uc2V0SW5SZXN1bHQoITEpKX19aXNDb3ZlcmVkQnlMQSh0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0TGluZUxpc3QpfHwhIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0UG9seUxpc3QpfWNvbXB1dGVHZW9tZXRyeSh0LGUsbixzKXtjb25zdCBpPW5ldyBMO3JldHVybiBpLmFkZEFsbCh0KSxpLmFkZEFsbChlKSxpLmFkZEFsbChuKSxpLmlzRW1wdHkoKT9Oci5jcmVhdGVFbXB0eVJlc3VsdChzLHRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLHRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLHRoaXMuX2dlb21GYWN0KTp0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGkpfW1lcmdlU3ltTGFiZWxzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubWVyZ2VTeW1MYWJlbHMoKX19aXNDb3ZlcmVkKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7aWYodGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LGUpIT09UXQuRVhURVJJT1IpcmV0dXJuITB9cmV0dXJuITF9cmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCl7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9dGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7bi5pc0NvbGxhcHNlZCgpJiYoZS5yZW1vdmUoKSx0LmFkZChuLmdldENvbGxhcHNlZEVkZ2UoKSkpfXRoaXMuX2VkZ2VMaXN0LmFkZEFsbCh0KX11cGRhdGVOb2RlTGFiZWxsaW5nKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtlLmdldExhYmVsKCkubWVyZ2Uobil9fWdldFJlc3VsdEdlb21ldHJ5KHQpe3JldHVybiB0aGlzLmNvbXB1dGVPdmVybGF5KHQpLHRoaXMuX3Jlc3VsdEdlb219aW5zZXJ0VW5pcXVlRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKHQpfX1jb21wdXRlT3ZlcmxheSh0KXt0aGlzLmNvcHlQb2ludHMoMCksdGhpcy5jb3B5UG9pbnRzKDEpLHRoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSksdGhpcy5fYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLl9hcmdbMV0sdGhpcy5fbGksITApO2NvbnN0IGU9bmV3IEw7dGhpcy5fYXJnWzBdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU3BsaXRFZGdlcyhlKSx0aGlzLmluc2VydFVuaXF1ZUVkZ2VzKGUpLHRoaXMuY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKSx0aGlzLnJlcGxhY2VDb2xsYXBzZWRFZGdlcygpLGdyLmNoZWNrVmFsaWQodGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5jb21wdXRlTGFiZWxsaW5nKCksdGhpcy5sYWJlbEluY29tcGxldGVOb2RlcygpLHRoaXMuZmluZFJlc3VsdEFyZWFFZGdlcyh0KSx0aGlzLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCk7Y29uc3Qgbj1uZXcgX2kodGhpcy5fZ2VvbUZhY3QpO24uYWRkKHRoaXMuX2dyYXBoKSx0aGlzLl9yZXN1bHRQb2x5TGlzdD1uLmdldFBvbHlnb25zKCk7Y29uc3Qgcz1uZXcgZHIodGhpcyx0aGlzLl9nZW9tRmFjdCx0aGlzLl9wdExvY2F0b3IpO3RoaXMuX3Jlc3VsdExpbmVMaXN0PXMuYnVpbGQodCk7Y29uc3QgaT1uZXcgX3IodGhpcyx0aGlzLl9nZW9tRmFjdCx0aGlzLl9wdExvY2F0b3IpO3RoaXMuX3Jlc3VsdFBvaW50TGlzdD1pLmJ1aWxkKHQpLHRoaXMuX3Jlc3VsdEdlb209dGhpcy5jb21wdXRlR2VvbWV0cnkodGhpcy5fcmVzdWx0UG9pbnRMaXN0LHRoaXMuX3Jlc3VsdExpbmVMaXN0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0LHQpfWxhYmVsSW5jb21wbGV0ZU5vZGUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfWNvcHlQb2ludHModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5fZ3JhcGguYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX1maW5kUmVzdWx0QXJlYUVkZ2VzKHQpe2ZvcihsZXQgZT10aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLHM9bi5nZXRMYWJlbCgpO3MuaXNBcmVhKCkmJiFuLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZOci5pc1Jlc3VsdE9mT3Aocy5nZXRMb2NhdGlvbigwLE1uLlJJR0hUKSxzLmdldExvY2F0aW9uKDEsTW4uUklHSFQpLHQpJiZuLnNldEluUmVzdWx0KCEwKX19Y29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKXtmb3IobGV0IHQ9dGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCkscz1lLmdldERlcHRoKCk7aWYoIXMuaXNOdWxsKCkpe3Mubm9ybWFsaXplKCk7Zm9yKGxldCB0PTA7dDwyO3QrKyluLmlzTnVsbCh0KXx8IW4uaXNBcmVhKCl8fHMuaXNOdWxsKHQpfHwoMD09PXMuZ2V0RGVsdGEodCk/bi50b0xpbmUodCk6KGcuaXNUcnVlKCFzLmlzTnVsbCh0LE1uLkxFRlQpLFwiZGVwdGggb2YgTEVGVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHQsTW4uTEVGVCxzLmdldExvY2F0aW9uKHQsTW4uTEVGVCkpLGcuaXNUcnVlKCFzLmlzTnVsbCh0LE1uLlJJR0hUKSxcImRlcHRoIG9mIFJJR0hUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24odCxNbi5SSUdIVCxzLmdldExvY2F0aW9uKHQsTW4uUklHSFQpKSkpfX19Y29tcHV0ZUxhYmVsbGluZygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5fYXJnKX10aGlzLm1lcmdlU3ltTGFiZWxzKCksdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCl9bGFiZWxJbmNvbXBsZXRlTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTtlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShlLDApOnRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShlLDEpKSxlLmdldEVkZ2VzKCkudXBkYXRlTGFiZWxsaW5nKG4pfX1pc0NvdmVyZWRCeUEodCl7cmV0dXJuISF0aGlzLmlzQ292ZXJlZCh0LHRoaXMuX3Jlc3VsdFBvbHlMaXN0KX19TnIuSU5URVJTRUNUSU9OPTEsTnIuVU5JT049MixOci5ESUZGRVJFTkNFPTMsTnIuU1lNRElGRkVSRU5DRT00O3ZhciBTcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxzbmFwOmFyLE92ZXJsYXlPcDpOcn0pO2NsYXNzIHdyIGV4dGVuZHMgVWl7Y29uc3RydWN0b3IoKXtzdXBlcigpLHdyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2VkZ2VSaW5nPW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2xhYmVsPS0xO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO1VpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4scyl9Z2V0TmV4dCgpe3JldHVybiB0aGlzLl9uZXh0fWlzSW5SaW5nKCl7cmV0dXJuIG51bGwhPT10aGlzLl9lZGdlUmluZ31zZXRSaW5nKHQpe3RoaXMuX2VkZ2VSaW5nPXR9c2V0TGFiZWwodCl7dGhpcy5fbGFiZWw9dH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1nZXRSaW5nKCl7cmV0dXJuIHRoaXMuX2VkZ2VSaW5nfX1jbGFzcyBDciBleHRlbmRzIFdpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxDci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fWdldExpbmUoKXtyZXR1cm4gdGhpcy5fbGluZX19Y2xhc3MgTHJ7Y29uc3RydWN0b3IoKXtMci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bmV3IEN0LHRoaXMuX2dlb21HcmFwaD1udWxsLHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fXN0YXRpYyBmaW5kRGlmZmVyZW50UG9pbnQodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZSkpcmV0dXJuIHRbbl07cmV0dXJuIG51bGx9dmlzaXRJbnRlcmlvclJpbmcodCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxzPW5bMF0saT1Mci5maW5kRGlmZmVyZW50UG9pbnQobixzKSxyPWUuZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24ocyxpKSxvPWUuZmluZEVkZ2VFbmQocik7bGV0IGw9bnVsbDtvLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxNbi5SSUdIVCk9PT1RdC5JTlRFUklPUj9sPW86by5nZXRTeW0oKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsTW4uUklHSFQpPT09UXQuSU5URVJJT1ImJihsPW8uZ2V0U3ltKCkpLGcuaXNUcnVlKG51bGwhPT1sLFwidW5hYmxlIHRvIGZpbmQgZGlyRWRnZSB3aXRoIEludGVyaW9yIG9uIFJIU1wiKSx0aGlzLnZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyhsKX12aXNpdFNoZWxsSW50ZXJpb3JzKHQsZSl7aWYodCBpbnN0YW5jZW9mIGl0KXtjb25zdCBuPXQ7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfWlmKHQgaW5zdGFuY2VvZiBmdCl7Y29uc3Qgbj10O2ZvcihsZXQgdD0wO3Q8bi5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBzPW4uZ2V0R2VvbWV0cnlOKHQpO3RoaXMudmlzaXRJbnRlcmlvclJpbmcocy5nZXRFeHRlcmlvclJpbmcoKSxlKX19fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fZGlzY29ubmVjdGVkUmluZ2Nvb3JkfXNldEludGVyaW9yRWRnZXNJblJlc3VsdCh0KXtmb3IobGV0IGU9dC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLE1uLlJJR0hUKT09PVF0LklOVEVSSU9SJiZ0LnNldEluUmVzdWx0KCEwKX19dmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzKHQpe2NvbnN0IGU9dDtsZXQgbj10O2Rve2cuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBEaXJlY3RlZCBFZGdlXCIpLG4uc2V0VmlzaXRlZCghMCksbj1uLmdldE5leHQoKX13aGlsZShuIT09ZSl9YnVpbGRFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgTDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzSW5SZXN1bHQoKSYmbnVsbD09PXQuZ2V0RWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgZGkodCx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO24ubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7Y29uc3Qgcz1uLmJ1aWxkTWluaW1hbFJpbmdzKCk7ZS5hZGRBbGwocyl9fXJldHVybiBlfWhhc1VudmlzaXRlZFNoZWxsRWRnZSh0KXtmb3IobGV0IGU9MDtlPHQuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10LmdldChlKTtpZihuLmlzSG9sZSgpKWNvbnRpbnVlO2NvbnN0IHM9bi5nZXRFZGdlcygpO2xldCBpPXMuZ2V0KDApO2lmKGkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLE1uLlJJR0hUKT09PVF0LklOVEVSSU9SKWZvcihsZXQgdD0wO3Q8cy5zaXplKCk7dCsrKWlmKGk9cy5nZXQodCksIWkuaXNWaXNpdGVkKCkpcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZD1pLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX1pc0ludGVyaW9yc0Nvbm5lY3RlZCgpe2NvbnN0IHQ9bmV3IEw7dGhpcy5fZ2VvbUdyYXBoLmNvbXB1dGVTcGxpdEVkZ2VzKHQpO2NvbnN0IGU9bmV3IG9zKG5ldyB3aSk7ZS5hZGRFZGdlcyh0KSx0aGlzLnNldEludGVyaW9yRWRnZXNJblJlc3VsdChlKSxlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7Y29uc3Qgbj10aGlzLmJ1aWxkRWRnZVJpbmdzKGUuZ2V0RWRnZUVuZHMoKSk7cmV0dXJuIHRoaXMudmlzaXRTaGVsbEludGVyaW9ycyh0aGlzLl9nZW9tR3JhcGguZ2V0R2VvbWV0cnkoKSxlKSwhdGhpcy5oYXNVbnZpc2l0ZWRTaGVsbEVkZ2Uobil9fWNsYXNzIFRye2NyZWF0ZUVkZ2VFbmRGb3JOZXh0KHQsZSxuLHMpe2NvbnN0IGk9bi5zZWdtZW50SW5kZXgrMTtpZihpPj10LmdldE51bVBvaW50cygpJiZudWxsPT09cylyZXR1cm4gbnVsbDtsZXQgcj10LmdldENvb3JkaW5hdGUoaSk7bnVsbCE9PXMmJnMuc2VnbWVudEluZGV4PT09bi5zZWdtZW50SW5kZXgmJihyPXMuY29vcmQpO2NvbnN0IG89bmV3IG5zKHQsbi5jb29yZCxyLG5ldyBxbih0LmdldExhYmVsKCkpKTtlLmFkZChvKX1jcmVhdGVFZGdlRW5kRm9yUHJldih0LGUsbixzKXtsZXQgaT1uLnNlZ21lbnRJbmRleDtpZigwPT09bi5kaXN0KXtpZigwPT09aSlyZXR1cm4gbnVsbDtpLS19bGV0IHI9dC5nZXRDb29yZGluYXRlKGkpO251bGwhPT1zJiZzLnNlZ21lbnRJbmRleD49aSYmKHI9cy5jb29yZCk7Y29uc3Qgbz1uZXcgcW4odC5nZXRMYWJlbCgpKTtvLmZsaXAoKTtjb25zdCBsPW5ldyBucyh0LG4uY29vcmQscixvKTtlLmFkZChsKX1jb21wdXRlRWRnZUVuZHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgTDtmb3IobGV0IG49dDtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5jb21wdXRlRWRnZUVuZHModCxlKX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCk7bi5hZGRFbmRwb2ludHMoKTtjb25zdCBzPW4uaXRlcmF0b3IoKTtsZXQgaT1udWxsLHI9bnVsbDtpZighcy5oYXNOZXh0KCkpcmV0dXJuIG51bGw7bGV0IG89cy5uZXh0KCk7ZG97aT1yLHI9byxvPW51bGwscy5oYXNOZXh0KCkmJihvPXMubmV4dCgpKSxudWxsIT09ciYmKHRoaXMuY3JlYXRlRWRnZUVuZEZvclByZXYodCxlLHIsaSksdGhpcy5jcmVhdGVFZGdlRW5kRm9yTmV4dCh0LGUscixvKSl9d2hpbGUobnVsbCE9PXIpfX19Y2xhc3MgUnIgZXh0ZW5kcyBuc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZWRnZUVuZHM9bmV3IEwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1JyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbnVsbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1sxXTtucy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQuZ2V0RWRnZSgpLHQuZ2V0Q29vcmRpbmF0ZSgpLHQuZ2V0RGlyZWN0ZWRDb29yZGluYXRlKCksbmV3IHFuKHQuZ2V0TGFiZWwoKSkpLHRoaXMuaW5zZXJ0KHQpfX1pbnNlcnQodCl7dGhpcy5fZWRnZUVuZHMuYWRkKHQpfXByaW50KHQpe3QucHJpbnRsbihcIkVkZ2VFbmRCdW5kbGUtLVxceDNlIExhYmVsOiBcIit0aGlzLl9sYWJlbCk7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnByaW50KHQpLHQucHJpbnRsbigpfX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlRW5kcy5pdGVyYXRvcigpfWdldEVkZ2VFbmRzKCl7cmV0dXJuIHRoaXMuX2VkZ2VFbmRzfWNvbXB1dGVMYWJlbE9uKHQsZSl7bGV0IG49MCxzPSExO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBpPWUubmV4dCgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7aT09PVF0LkJPVU5EQVJZJiZuKyssaT09PVF0LklOVEVSSU9SJiYocz0hMCl9bGV0IGk9UXQuTk9ORTtzJiYoaT1RdC5JTlRFUklPUiksbj4wJiYoaT1scy5kZXRlcm1pbmVCb3VuZGFyeShlLG4pKSx0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGkpfWNvbXB1dGVMYWJlbFNpZGUodCxlKXtmb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtpZihzLmdldExhYmVsKCkuaXNBcmVhKCkpe2NvbnN0IG49cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQsZSk7aWYobj09PVF0LklOVEVSSU9SKXJldHVybiB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUsUXQuSU5URVJJT1IpLG51bGw7bj09PVF0LkVYVEVSSU9SJiZ0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbih0LGUsUXQuRVhURVJJT1IpfX19Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Y29tcHV0ZUxhYmVsU2lkZXModCl7dGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsTW4uTEVGVCksdGhpcy5jb21wdXRlTGFiZWxTaWRlKHQsTW4uUklHSFQpfXVwZGF0ZUlNKHQpeyRuLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLHQpfWNvbXB1dGVMYWJlbCh0KXtsZXQgZT0hMTtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmKGU9ITApfXRoaXMuX2xhYmVsPWU/bmV3IHFuKFF0Lk5PTkUsUXQuTk9ORSxRdC5OT05FKTpuZXcgcW4oUXQuTk9ORSk7Zm9yKGxldCBuPTA7bjwyO24rKyl0aGlzLmNvbXB1dGVMYWJlbE9uKG4sdCksZSYmdGhpcy5jb21wdXRlTGFiZWxTaWRlcyhuKX19Y2xhc3MgUHIgZXh0ZW5kcyBOaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9dXBkYXRlSU0odCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnVwZGF0ZUlNKHQpfX1pbnNlcnQodCl7bGV0IGU9dGhpcy5fZWRnZU1hcC5nZXQodCk7bnVsbD09PWU/KGU9bmV3IFJyKHQpLHRoaXMuaW5zZXJ0RWRnZUVuZCh0LGUpKTplLmluc2VydCh0KX19Y2xhc3MgT3IgZXh0ZW5kcyB0c3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksT3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dHMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpfXVwZGF0ZUlNRnJvbUVkZ2VzKHQpe3RoaXMuX2VkZ2VzLnVwZGF0ZUlNKHQpfWNvbXB1dGVJTSh0KXt0LnNldEF0TGVhc3RJZlZhbGlkKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDApLHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDEpLDApfX1jbGFzcyB2ciBleHRlbmRzIHJze2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1jcmVhdGVOb2RlKHQpe3JldHVybiBuZXcgT3IodCxuZXcgUHIpfX1jbGFzcyBNcntjb25zdHJ1Y3Rvcigpe01yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX25vZGVzPW5ldyBlcyhuZXcgdnIpfWluc2VydEVkZ2VFbmRzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuX25vZGVzLmFkZCh0KX19Z2V0Tm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKCl9Y29weU5vZGVzQW5kTGFiZWxzKHQsZSl7Zm9yKGxldCBuPXQuZ2V0Tm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX25vZGVzLmFkZE5vZGUodC5nZXRDb29yZGluYXRlKCkpLnNldExhYmVsKGUsdC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpKX19YnVpbGQodCl7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCwwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscyh0LDApO2NvbnN0IGU9KG5ldyBUcikuY29tcHV0ZUVkZ2VFbmRzKHQuZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMoZSl9Y29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKHQsZSl7Zm9yKGxldCBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLHM9dC5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGUpO2ZvcihsZXQgbj10LmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCksaT10aGlzLl9ub2Rlcy5hZGROb2RlKHQuY29vcmQpO3M9PT1RdC5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkoZSk6aS5nZXRMYWJlbCgpLmlzTnVsbChlKSYmaS5zZXRMYWJlbChlLFF0LklOVEVSSU9SKX19fX1jbGFzcyBicntjb25zdHJ1Y3Rvcigpe2JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9nZW9tR3JhcGg9bnVsbCx0aGlzLl9ub2RlR3JhcGg9bmV3IE1yLHRoaXMuX2ludmFsaWRQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fWlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpe2ZvcihsZXQgdD10aGlzLl9ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2lmKCFlLmdldEVkZ2VzKCkuaXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0aGlzLl9nZW9tR3JhcGgpKXJldHVybiB0aGlzLl9pbnZhbGlkUG9pbnQ9ZS5nZXRDb29yZGluYXRlKCkuY29weSgpLCExfXJldHVybiEwfWdldEludmFsaWRQb2ludCgpe3JldHVybiB0aGlzLl9pbnZhbGlkUG9pbnR9aGFzRHVwbGljYXRlUmluZ3MoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Zm9yKGxldCBlPXQubmV4dCgpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodC5nZXRFZGdlRW5kcygpLnNpemUoKT4xKXJldHVybiB0aGlzLl9pbnZhbGlkUG9pbnQ9dC5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZSgwKSwhMH19cmV0dXJuITF9aXNOb2RlQ29uc2lzdGVudEFyZWEoKXtjb25zdCB0PXRoaXMuX2dlb21HcmFwaC5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCEwLCEwKTtyZXR1cm4gdC5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5faW52YWxpZFBvaW50PXQuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6KHRoaXMuX25vZGVHcmFwaC5idWlsZCh0aGlzLl9nZW9tR3JhcGgpLHRoaXMuaXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50KCkpfX1jbGFzcyBEcntjb25zdHJ1Y3Rvcigpe0RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2dyYXBoPW51bGwsdGhpcy5fcmluZ3M9bmV3IEwsdGhpcy5fdG90YWxFbnY9bmV3IE8sdGhpcy5faW5kZXg9bnVsbCx0aGlzLl9uZXN0ZWRQdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dyYXBoPXR9YnVpbGRJbmRleCgpe3RoaXMuX2luZGV4PW5ldyB2cztmb3IobGV0IHQ9MDt0PHRoaXMuX3JpbmdzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fcmluZ3MuZ2V0KHQpLG49ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7dGhpcy5faW5kZXguaW5zZXJ0KG4sZSl9fWdldE5lc3RlZFBvaW50KCl7cmV0dXJuIHRoaXMuX25lc3RlZFB0fWlzTm9uTmVzdGVkKCl7dGhpcy5idWlsZEluZGV4KCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9yaW5ncy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX3JpbmdzLmdldCh0KSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPXRoaXMuX2luZGV4LnF1ZXJ5KGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKyl7Y29uc3QgaT1zLmdldCh0KSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlPT09aSljb250aW51ZTtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpY29udGludWU7Y29uc3Qgbz1Gci5maW5kUHROb3ROb2RlKG4saSx0aGlzLl9ncmFwaCk7aWYobnVsbD09PW8pY29udGludWU7aWYoVWUuaXNJblJpbmcobyxyKSlyZXR1cm4gdGhpcy5fbmVzdGVkUHQ9bywhMX19cmV0dXJuITB9YWRkKHQpe3RoaXMuX3JpbmdzLmFkZCh0KSx0aGlzLl90b3RhbEVudi5leHBhbmRUb0luY2x1ZGUodC5nZXRFbnZlbG9wZUludGVybmFsKCkpfX1jbGFzcyBBcntjb25zdHJ1Y3Rvcigpe0FyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2Vycm9yVHlwZT1udWxsLHRoaXMuX3B0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9lcnJvclR5cGU9dCxudWxsIT09ZSYmKHRoaXMuX3B0PWUuY29weSgpKX19Z2V0RXJyb3JUeXBlKCl7cmV0dXJuIHRoaXMuX2Vycm9yVHlwZX1nZXRNZXNzYWdlKCl7cmV0dXJuIEFyLmVyck1zZ1t0aGlzLl9lcnJvclR5cGVdfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9dG9TdHJpbmcoKXtsZXQgdD1cIlwiO3JldHVybiBudWxsIT09dGhpcy5fcHQmJih0PVwiIGF0IG9yIG5lYXIgcG9pbnQgXCIrdGhpcy5fcHQpLHRoaXMuZ2V0TWVzc2FnZSgpK3R9fUFyLkVSUk9SPTAsQXIuUkVQRUFURURfUE9JTlQ9MSxBci5IT0xFX09VVFNJREVfU0hFTEw9MixBci5ORVNURURfSE9MRVM9MyxBci5ESVNDT05ORUNURURfSU5URVJJT1I9NCxBci5TRUxGX0lOVEVSU0VDVElPTj01LEFyLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT049NixBci5ORVNURURfU0hFTExTPTcsQXIuRFVQTElDQVRFX1JJTkdTPTgsQXIuVE9PX0ZFV19QT0lOVFM9OSxBci5JTlZBTElEX0NPT1JESU5BVEU9MTAsQXIuUklOR19OT1RfQ0xPU0VEPTExLEFyLmVyck1zZz1bXCJUb3BvbG9neSBWYWxpZGF0aW9uIEVycm9yXCIsXCJSZXBlYXRlZCBQb2ludFwiLFwiSG9sZSBsaWVzIG91dHNpZGUgc2hlbGxcIixcIkhvbGVzIGFyZSBuZXN0ZWRcIixcIkludGVyaW9yIGlzIGRpc2Nvbm5lY3RlZFwiLFwiU2VsZi1pbnRlcnNlY3Rpb25cIixcIlJpbmcgU2VsZi1pbnRlcnNlY3Rpb25cIixcIk5lc3RlZCBzaGVsbHNcIixcIkR1cGxpY2F0ZSBSaW5nc1wiLFwiVG9vIGZldyBkaXN0aW5jdCBwb2ludHMgaW4gZ2VvbWV0cnkgY29tcG9uZW50XCIsXCJJbnZhbGlkIENvb3JkaW5hdGVcIixcIlJpbmcgaXMgbm90IGNsb3NlZFwiXTtjbGFzcyBGcntjb25zdHJ1Y3Rvcigpe0ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3BhcmVudEdlb21ldHJ5PW51bGwsdGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD0hMSx0aGlzLl92YWxpZEVycj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BhcmVudEdlb21ldHJ5PXR9c3RhdGljIGZpbmRQdE5vdE5vZGUodCxlLG4pe2NvbnN0IHM9bi5maW5kRWRnZShlKS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPXRbZV07aWYoIXMuaXNJbnRlcnNlY3Rpb24obikpcmV0dXJuIG59cmV0dXJuIG51bGx9c3RhdGljIGlzVmFsaWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe3JldHVybiBuZXcgRnIoYXJndW1lbnRzWzBdKS5pc1ZhbGlkKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4hci5pc05hTih0LngpJiYoIXIuaXNJbmZpbml0ZSh0LngpJiYoIXIuaXNOYU4odC55KSYmIXIuaXNJbmZpbml0ZSh0LnkpKSl9fWNoZWNrSW52YWxpZENvb3JkaW5hdGVzKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIUZyLmlzVmFsaWQodFtlXSkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5JTlZBTElEX0NPT1JESU5BVEUsdFtlXSksbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgaXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWNoZWNrSG9sZXNOb3ROZXN0ZWQodCxlKXtpZih0LmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiBudWxsO2NvbnN0IG49bmV3IERyKGUpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IHM9dC5nZXRJbnRlcmlvclJpbmdOKGUpO3MuaXNFbXB0eSgpfHxuLmFkZChzKX1uLmlzTm9uTmVzdGVkKCl8fCh0aGlzLl92YWxpZEVycj1uZXcgQXIoQXIuTkVTVEVEX0hPTEVTLG4uZ2V0TmVzdGVkUG9pbnQoKSkpfWNoZWNrQ29uc2lzdGVudEFyZWEodCl7Y29uc3QgZT1uZXcgYnIodCk7aWYoIWUuaXNOb2RlQ29uc2lzdGVudEFyZWEoKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEFyKEFyLlNFTEZfSU5URVJTRUNUSU9OLGUuZ2V0SW52YWxpZFBvaW50KCkpLG51bGw7ZS5oYXNEdXBsaWNhdGVSaW5ncygpJiYodGhpcy5fdmFsaWRFcnI9bmV3IEFyKEFyLkRVUExJQ0FURV9SSU5HUyxlLmdldEludmFsaWRQb2ludCgpKSl9aXNWYWxpZCgpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5fcGFyZW50R2VvbWV0cnkpLG51bGw9PT10aGlzLl92YWxpZEVycn1jaGVja1NoZWxsSW5zaWRlSG9sZSh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGVzKCkscj1Gci5maW5kUHROb3ROb2RlKHMsZSxuKTtpZihudWxsIT09cil7aWYoIVVlLmlzSW5SaW5nKHIsaSkpcmV0dXJuIHJ9Y29uc3Qgbz1Gci5maW5kUHROb3ROb2RlKGksdCxuKTtpZihudWxsIT09byl7cmV0dXJuIFVlLmlzSW5SaW5nKG8scyk/bzpudWxsfXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwicG9pbnRzIGluIHNoZWxsIGFuZCBob2xlIGFwcGVhciB0byBiZSBlcXVhbFwiKSxudWxsfWNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3ModCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nKHQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfX1jaGVja0Nvbm5lY3RlZEludGVyaW9ycyh0KXtjb25zdCBlPW5ldyBMcih0KTtlLmlzSW50ZXJpb3JzQ29ubmVjdGVkKCl8fCh0aGlzLl92YWxpZEVycj1uZXcgQXIoQXIuRElTQ09OTkVDVEVEX0lOVEVSSU9SLGUuZ2V0Q29vcmRpbmF0ZSgpKSl9Y2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nKHQpe2NvbnN0IGU9bmV3IGx0O2xldCBuPSEwO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKG4pbj0hMTtlbHNle2lmKGUuY29udGFpbnModC5jb29yZCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5SSU5HX1NFTEZfSU5URVJTRUNUSU9OLHQuY29vcmQpLG51bGw7ZS5hZGQodC5jb29yZCl9fX1jaGVja0hvbGVzSW5TaGVsbCh0LGUpe2lmKHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk8PTApcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldEV4dGVyaW9yUmluZygpLHM9bi5pc0VtcHR5KCksaT1uZXcgemUobik7Zm9yKGxldCByPTA7cjx0LmdldE51bUludGVyaW9yUmluZygpO3IrKyl7Y29uc3Qgbz10LmdldEludGVyaW9yUmluZ04ocik7bGV0IGw9bnVsbDtpZihvLmlzRW1wdHkoKSljb250aW51ZTtpZihsPUZyLmZpbmRQdE5vdE5vZGUoby5nZXRDb29yZGluYXRlcygpLG4sZSksbnVsbD09PWwpcmV0dXJuIG51bGw7aWYoc3x8UXQuRVhURVJJT1I9PT1pLmxvY2F0ZShsKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IEFyKEFyLkhPTEVfT1VUU0lERV9TSEVMTCxsKSxudWxsfX1jaGVja1Rvb0Zld1BvaW50cyh0KXtpZih0Lmhhc1Rvb0Zld1BvaW50cygpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgQXIoQXIuVE9PX0ZFV19QT0lOVFMsdC5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbH1nZXRWYWxpZGF0aW9uRXJyb3IoKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMuX3BhcmVudEdlb21ldHJ5KSx0aGlzLl92YWxpZEVycn1jaGVja1ZhbGlkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB0dCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBodCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB1dCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgbHMoMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBqdDtlLmNvbXB1dGVTZWxmTm9kZXMobiwhMCwhMCksdGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBKKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IGxzKDAsdCk7dGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgaXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgbHMoMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Y29uc3QgZT1uZXcgbHMoMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChzLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1mb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQocyxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9aWYodGhpcy5jaGVja1NoZWxsc05vdE5lc3RlZCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYodGhpcy5jaGVja1ZhbGlkKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX3ZhbGlkRXJyPW51bGwsdC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIHR0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBodCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgdXQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEopdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGl0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBjdCkpdGhyb3cgbmV3IGoodC5nZXRHZW9tZXRyeVR5cGUoKSk7dGhpcy5jaGVja1ZhbGlkKHQpfX19c2V0U2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQodCl7dGhpcy5faXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD10fWNoZWNrU2hlbGxOb3ROZXN0ZWQodCxlLG4pe2NvbnN0IHM9dC5nZXRDb29yZGluYXRlcygpLGk9ZS5nZXRFeHRlcmlvclJpbmcoKTtpZihpLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCByPWkuZ2V0Q29vcmRpbmF0ZXMoKSxvPUZyLmZpbmRQdE5vdE5vZGUocyxpLG4pO2lmKG51bGw9PT1vKXJldHVybiBudWxsO2lmKCFVZS5pc0luUmluZyhvLHIpKXJldHVybiBudWxsO2lmKGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk8PTApcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5ORVNURURfU0hFTExTLG8pLG51bGw7bGV0IGw9bnVsbDtmb3IobGV0IHM9MDtzPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXtjb25zdCBpPWUuZ2V0SW50ZXJpb3JSaW5nTihzKTtpZihsPXRoaXMuY2hlY2tTaGVsbEluc2lkZUhvbGUodCxpLG4pLG51bGw9PT1sKXJldHVybiBudWxsfXRoaXMuX3ZhbGlkRXJyPW5ldyBBcihBci5ORVNURURfU0hFTExTLGwpfWNoZWNrQ2xvc2VkUmluZ3ModCl7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Y2hlY2tDbG9zZWRSaW5nKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKCF0LmlzQ2xvc2VkKCkpe2xldCBlPW51bGw7dC5nZXROdW1Qb2ludHMoKT49MSYmKGU9dC5nZXRDb29yZGluYXRlTigwKSksdGhpcy5fdmFsaWRFcnI9bmV3IEFyKEFyLlJJTkdfTk9UX0NMT1NFRCxlKX19Y2hlY2tTaGVsbHNOb3ROZXN0ZWQodCxlKXtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKS5nZXRFeHRlcmlvclJpbmcoKTtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7aWYobj09PWkpY29udGludWU7Y29uc3Qgcj10LmdldEdlb21ldHJ5TihpKTtpZih0aGlzLmNoZWNrU2hlbGxOb3ROZXN0ZWQocyxyLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19fX1jbGFzcyBHcntjb25zdHJ1Y3Rvcigpe0dyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9kZUxpc3Q9bmV3IEwsdGhpcy5fbG93ZXN0RWRnZT1udWxsLHRoaXMuX3Jpbmc9bnVsbCx0aGlzLl9sb2NhdG9yPW51bGwsdGhpcy5fcmluZ1B0cz1udWxsLHRoaXMuX2hvbGVzPW51bGwsdGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9pc1Byb2Nlc3NlZD0hMSx0aGlzLl9pc0luY2x1ZGVkU2V0PSExLHRoaXMuX2lzSW5jbHVkZWQ9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10fXN0YXRpYyBmaW5kRGlyRWRnZXNJblJpbmcodCl7bGV0IGU9dDtjb25zdCBuPW5ldyBMO2Rve24uYWRkKGUpLGU9ZS5nZXROZXh0KCksZy5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZy5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUoZSE9PXQpO3JldHVybiBufXN0YXRpYyBhZGRFZGdlKHQsZSxuKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKW4uYWRkKHRbZV0sITEpO2Vsc2UgZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pbi5hZGQodFtlXSwhMSl9c3RhdGljIGZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0UmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCk7bGV0IGk9bi5nZXRDb29yZGluYXRlTigwKSxyPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLGw9ZS5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKGwuZXF1YWxzKHMpKWNvbnRpbnVlO2lmKCFsLmNvbnRhaW5zKHMpKWNvbnRpbnVlO2k9ZHQucHROb3RJbkxpc3Qobi5nZXRDb29yZGluYXRlcygpLGUuZ2V0Q29vcmRpbmF0ZXMoKSk7ZS5pc0luUmluZyhpKSYmKG51bGw9PT1yfHxvLmNvbnRhaW5zKGwpKSYmKHI9ZSxvPXIuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9cmV0dXJuIHJ9aXNJbmNsdWRlZCgpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkfWdldENvb3JkaW5hdGVzKCl7aWYobnVsbD09PXRoaXMuX3JpbmdQdHMpe2NvbnN0IHQ9bmV3IFI7Zm9yKGxldCBlPXRoaXMuX2RlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0RWRnZSgpO0dyLmFkZEVkZ2Uocy5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuLmdldEVkZ2VEaXJlY3Rpb24oKSx0KX10aGlzLl9yaW5nUHRzPXQudG9Db29yZGluYXRlQXJyYXkoKX1yZXR1cm4gdGhpcy5fcmluZ1B0c31pc0luY2x1ZGVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWRTZXR9aXNWYWxpZCgpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksISh0aGlzLl9yaW5nUHRzLmxlbmd0aDw9MykmJih0aGlzLmdldFJpbmcoKSxGci5pc1ZhbGlkKHRoaXMuX3JpbmcpKX1idWlsZCh0KXtsZXQgZT10O2Rve3RoaXMuYWRkKGUpLGUuc2V0UmluZyh0aGlzKSxlPWUuZ2V0TmV4dCgpLGcuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGcuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKGUhPT10KX1pc0luUmluZyh0KXtyZXR1cm4gUXQuRVhURVJJT1IhPT10aGlzLmdldExvY2F0b3IoKS5sb2NhdGUodCl9aXNPdXRlckhvbGUoKXtyZXR1cm4hIXRoaXMuX2lzSG9sZSYmIXRoaXMuaGFzU2hlbGwoKX1nZXRQb2x5Z29uKCl7bGV0IHQ9bnVsbDtpZihudWxsIT09dGhpcy5faG9sZXMpe3Q9bmV3IEFycmF5KHRoaXMuX2hvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLnNpemUoKTtlKyspdFtlXT10aGlzLl9ob2xlcy5nZXQoZSl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbih0aGlzLl9yaW5nLHQpfWlzSG9sZSgpe3JldHVybiB0aGlzLl9pc0hvbGV9aXNQcm9jZXNzZWQoKXtyZXR1cm4gdGhpcy5faXNQcm9jZXNzZWR9YWRkSG9sZSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9ob2xlcyYmKHRoaXMuX2hvbGVzPW5ldyBMKSx0aGlzLl9ob2xlcy5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEdyKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LnNldFNoZWxsKHRoaXMpO2NvbnN0IGU9dC5nZXRSaW5nKCk7bnVsbD09PXRoaXMuX2hvbGVzJiYodGhpcy5faG9sZXM9bmV3IEwpLHRoaXMuX2hvbGVzLmFkZChlKX19c2V0SW5jbHVkZWQodCl7dGhpcy5faXNJbmNsdWRlZD10LHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITB9Z2V0T3V0ZXJIb2xlKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMuX2RlTGlzdC5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX2RlTGlzdC5nZXQodCkuZ2V0U3ltKCkuZ2V0UmluZygpO2lmKGUuaXNPdXRlckhvbGUoKSlyZXR1cm4gZX1yZXR1cm4gbnVsbH1jb21wdXRlSG9sZSgpe2NvbnN0IHQ9dGhpcy5nZXRSaW5nKCk7dGhpcy5faXNIb2xlPUcuaXNDQ1codC5nZXRDb29yZGluYXRlcygpKX1oYXNTaGVsbCgpe3JldHVybiBudWxsIT09dGhpcy5fc2hlbGx9aXNPdXRlclNoZWxsKCl7cmV0dXJuIG51bGwhPT10aGlzLmdldE91dGVySG9sZSgpfWdldExpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLl9yaW5nUHRzKX10b1N0cmluZygpe3JldHVybiBXdC50b0xpbmVTdHJpbmcobmV3IHB0KHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkpfWdldExvY2F0b3IoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2xvY2F0b3ImJih0aGlzLl9sb2NhdG9yPW5ldyB6ZSh0aGlzLmdldFJpbmcoKSkpLHRoaXMuX2xvY2F0b3J9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5pc0hvbGUoKT90aGlzLl9zaGVsbDp0aGlzfWFkZCh0KXt0aGlzLl9kZUxpc3QuYWRkKHQpfWdldFJpbmcoKXtpZihudWxsIT09dGhpcy5fcmluZylyZXR1cm4gdGhpcy5fcmluZzt0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5fcmluZ1B0cy5sZW5ndGg8MyYmQi5vdXQucHJpbnRsbih0aGlzLl9yaW5nUHRzKTt0cnl7dGhpcy5fcmluZz10aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5fcmluZ1B0cyl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgdDtCLm91dC5wcmludGxuKHRoaXMuX3JpbmdQdHMpfXJldHVybiB0aGlzLl9yaW5nfXVwZGF0ZUluY2x1ZGVkKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMuX2RlTGlzdC5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX2RlTGlzdC5nZXQodCkuZ2V0U3ltKCkuZ2V0UmluZygpLmdldFNoZWxsKCk7aWYobnVsbCE9PWUmJmUuaXNJbmNsdWRlZFNldCgpKXJldHVybiB0aGlzLnNldEluY2x1ZGVkKCFlLmlzSW5jbHVkZWQoKSksbnVsbH19c2V0U2hlbGwodCl7dGhpcy5fc2hlbGw9dH1zZXRQcm9jZXNzZWQodCl7dGhpcy5faXNQcm9jZXNzZWQ9dH19R3IuRW52ZWxvcGVDb21wYXJhdG9yPWNsYXNze2NvbXBhcmUodCxlKXtjb25zdCBuPWU7cmV0dXJuIHQuZ2V0UmluZygpLmdldEVudmVsb3BlKCkuY29tcGFyZVRvKG4uZ2V0UmluZygpLmdldEVudmVsb3BlKCkpfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19O2NsYXNzIHFyIGV4dGVuZHMgSml7Y29uc3RydWN0b3IoKXtzdXBlcigpLHFyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2ZhY3Rvcnk9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9mYWN0b3J5PXR9c3RhdGljIGZpbmRMYWJlbGVkRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IEw7bGV0IG49MTtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZih0LmlzTWFya2VkKCkpY29udGludWU7aWYodC5nZXRMYWJlbCgpPj0wKWNvbnRpbnVlO2UuYWRkKHQpO2NvbnN0IGk9R3IuZmluZERpckVkZ2VzSW5SaW5nKHQpO3FyLmxhYmVsKGksbiksbisrfXJldHVybiBlfXN0YXRpYyBnZXREZWdyZWVOb25EZWxldGVkKHQpe2xldCBlPTA7Zm9yKGxldCBuPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5pc01hcmtlZCgpfHxlKyt9cmV0dXJuIGV9c3RhdGljIGRlbGV0ZUFsbEVkZ2VzKHQpe2ZvcihsZXQgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LnNldE1hcmtlZCghMCk7Y29uc3Qgbj10LmdldFN5bSgpO251bGwhPT1uJiZuLnNldE1hcmtlZCghMCl9fXN0YXRpYyBsYWJlbCh0LGUpe2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5zZXRMYWJlbChlKX19c3RhdGljIGNvbXB1dGVOZXh0Q1dFZGdlcyh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYoIXQuaXNNYXJrZWQoKSl7aWYobnVsbD09PWUmJihlPXQpLG51bGwhPT1uKXtuLmdldFN5bSgpLnNldE5leHQodCl9bj10fX1pZihudWxsIT09bil7bi5nZXRTeW0oKS5zZXROZXh0KGUpfX1zdGF0aWMgY29tcHV0ZU5leHRDQ1dFZGdlcyh0LGUpe2xldCBuPW51bGwscz1udWxsO2NvbnN0IGk9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCk7Zm9yKGxldCB0PWkuc2l6ZSgpLTE7dD49MDt0LS0pe2NvbnN0IHI9aS5nZXQodCksbz1yLmdldFN5bSgpO2xldCBsPW51bGw7ci5nZXRMYWJlbCgpPT09ZSYmKGw9cik7bGV0IGE9bnVsbDtvLmdldExhYmVsKCk9PT1lJiYoYT1vKSxudWxsPT09bCYmbnVsbD09PWF8fChudWxsIT09YSYmKHM9YSksbnVsbCE9PWwmJihudWxsIT09cyYmKHMuc2V0TmV4dChsKSxzPW51bGwpLG51bGw9PT1uJiYobj1sKSkpfW51bGwhPT1zJiYoZy5pc1RydWUobnVsbCE9PW4pLHMuc2V0TmV4dChuKSl9c3RhdGljIGdldERlZ3JlZSh0LGUpe2xldCBuPTA7Zm9yKGxldCBzPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtzLm5leHQoKS5nZXRMYWJlbCgpPT09ZSYmbisrfXJldHVybiBufXN0YXRpYyBmaW5kSW50ZXJzZWN0aW9uTm9kZXModCxlKXtsZXQgbj10LHM9bnVsbDtkb3tjb25zdCBpPW4uZ2V0RnJvbU5vZGUoKTtxci5nZXREZWdyZWUoaSxlKT4xJiYobnVsbD09PXMmJihzPW5ldyBMKSxzLmFkZChpKSksbj1uLmdldE5leHQoKSxnLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxnLmlzVHJ1ZShuPT09dHx8IW4uaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShuIT09dCk7cmV0dXJuIHN9ZmluZEVkZ2VSaW5nKHQpe2NvbnN0IGU9bmV3IEdyKHRoaXMuX2ZhY3RvcnkpO3JldHVybiBlLmJ1aWxkKHQpLGV9Y29tcHV0ZURlcHRoUGFyaXR5KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKDs7KXJldHVybiBudWxsfWNvbXB1dGVOZXh0Q1dFZGdlcygpe2ZvcihsZXQgdD10aGlzLm5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtxci5jb21wdXRlTmV4dENXRWRnZXMoZSl9fWFkZEVkZ2UodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1kdC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIG51bGw7Y29uc3Qgbj1lWzBdLHM9ZVtlLmxlbmd0aC0xXSxpPXRoaXMuZ2V0Tm9kZShuKSxyPXRoaXMuZ2V0Tm9kZShzKSxvPW5ldyB3cihpLHIsZVsxXSwhMCksbD1uZXcgd3IocixpLGVbZS5sZW5ndGgtMl0sITEpLGE9bmV3IENyKHQpO2Euc2V0RGlyZWN0ZWRFZGdlcyhvLGwpLHRoaXMuYWRkKGEpfWRlbGV0ZUN1dEVkZ2VzKCl7dGhpcy5jb21wdXRlTmV4dENXRWRnZXMoKSxxci5maW5kTGFiZWxlZEVkZ2VSaW5ncyh0aGlzLl9kaXJFZGdlcyk7Y29uc3QgdD1uZXcgTDtmb3IobGV0IGU9dGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobi5pc01hcmtlZCgpKWNvbnRpbnVlO2NvbnN0IHM9bi5nZXRTeW0oKTtpZihuLmdldExhYmVsKCk9PT1zLmdldExhYmVsKCkpe24uc2V0TWFya2VkKCEwKSxzLnNldE1hcmtlZCghMCk7Y29uc3QgZT1uLmdldEVkZ2UoKTt0LmFkZChlLmdldExpbmUoKSl9fXJldHVybiB0fWdldEVkZ2VSaW5ncygpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCkscXIubGFiZWwodGhpcy5fZGlyRWRnZXMsLTEpO2NvbnN0IHQ9cXIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5fZGlyRWRnZXMpO3RoaXMuY29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCk7Y29uc3QgZT1uZXcgTDtmb3IobGV0IHQ9dGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7aWYobi5pc01hcmtlZCgpKWNvbnRpbnVlO2lmKG4uaXNJblJpbmcoKSljb250aW51ZTtjb25zdCBzPXRoaXMuZmluZEVkZ2VSaW5nKG4pO2UuYWRkKHMpfXJldHVybiBlfWdldE5vZGUodCl7bGV0IGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBqaSh0KSx0aGlzLmFkZChlKSksZX1jb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5ncyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TGFiZWwoKSxzPXFyLmZpbmRJbnRlcnNlY3Rpb25Ob2Rlcyh0LG4pO2lmKG51bGwhPT1zKWZvcihsZXQgdD1zLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3FyLmNvbXB1dGVOZXh0Q0NXRWRnZXMoZSxuKX19fWRlbGV0ZURhbmdsZXMoKXtjb25zdCB0PXRoaXMuZmluZE5vZGVzT2ZEZWdyZWUoMSksZT1uZXcgeHQsbj1uZXcgZW47Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspbi5wdXNoKGUubmV4dCgpKTtmb3IoOyFuLmlzRW1wdHkoKTspe2NvbnN0IHQ9bi5wb3AoKTtxci5kZWxldGVBbGxFZGdlcyh0KTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5zZXRNYXJrZWQoITApO2NvbnN0IGk9dC5nZXRTeW0oKTtudWxsIT09aSYmaS5zZXRNYXJrZWQoITApO2NvbnN0IHI9dC5nZXRFZGdlKCk7ZS5hZGQoci5nZXRMaW5lKCkpO2NvbnN0IG89dC5nZXRUb05vZGUoKTsxPT09cXIuZ2V0RGVncmVlTm9uRGVsZXRlZChvKSYmbi5wdXNoKG8pfX1yZXR1cm4gZX19Y2xhc3MgQnJ7Y29uc3RydWN0b3IoKXtCci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaGVsbHM9bnVsbCx0aGlzLl9zaGVsbEluZGV4PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2hlbGxzPXQsdGhpcy5idWlsZEluZGV4KCl9c3RhdGljIGFzc2lnbkhvbGVzVG9TaGVsbHModCxlKXtuZXcgQnIoZSkuYXNzaWduSG9sZXNUb1NoZWxscyh0KX1hc3NpZ25Ib2xlc1RvU2hlbGxzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuYXNzaWduSG9sZVRvU2hlbGwodCl9fWJ1aWxkSW5kZXgoKXt0aGlzLl9zaGVsbEluZGV4PW5ldyB2cztmb3IoY29uc3QgdCBvZiB0aGlzLl9zaGVsbHMpdGhpcy5fc2hlbGxJbmRleC5pbnNlcnQodC5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHQpfXF1ZXJ5T3ZlcmxhcHBpbmdTaGVsbHModCl7cmV0dXJuIHRoaXMuX3NoZWxsSW5kZXgucXVlcnkodCl9ZmluZFNoZWxsQ29udGFpbmluZyh0KXtjb25zdCBlPXQuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPXRoaXMucXVlcnlPdmVybGFwcGluZ1NoZWxscyhlKTtyZXR1cm4gR3IuZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LG4pfWFzc2lnbkhvbGVUb1NoZWxsKHQpe2NvbnN0IGU9dGhpcy5maW5kU2hlbGxDb250YWluaW5nKHQpO251bGwhPT1lJiZlLmFkZEhvbGUodCl9fWNsYXNzIFlye2NvbnN0cnVjdG9yKCl7WXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fbGluZVN0cmluZ0FkZGVyPW5ldyBWcih0aGlzKSx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2RhbmdsZXM9bmV3IEwsdGhpcy5fY3V0RWRnZXM9bmV3IEwsdGhpcy5faW52YWxpZFJpbmdMaW5lcz1uZXcgTCx0aGlzLl9ob2xlTGlzdD1udWxsLHRoaXMuX3NoZWxsTGlzdD1udWxsLHRoaXMuX3BvbHlMaXN0PW51bGwsdGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ9ITAsdGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw9bnVsbCx0aGlzLl9nZW9tRmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVlyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsITEpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsPXR9fXN0YXRpYyBleHRyYWN0UG9seWdvbnModCxlKXtjb25zdCBuPW5ldyBMO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpOyhlfHx0LmlzSW5jbHVkZWQoKSkmJm4uYWRkKHQuZ2V0UG9seWdvbigpKX1yZXR1cm4gbn1zdGF0aWMgZmluZE91dGVyU2hlbGxzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRPdXRlckhvbGUoKTtudWxsPT09bnx8bi5pc1Byb2Nlc3NlZCgpfHwodC5zZXRJbmNsdWRlZCghMCksbi5zZXRQcm9jZXNzZWQoITApKX19c3RhdGljIGZpbmREaXNqb2ludFNoZWxscyh0KXtZci5maW5kT3V0ZXJTaGVsbHModCk7bGV0IGU9bnVsbDtkb3tlPSExO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3QuaXNJbmNsdWRlZFNldCgpfHwodC51cGRhdGVJbmNsdWRlZCgpLHQuaXNJbmNsdWRlZFNldCgpfHwoZT0hMCkpfX13aGlsZShlKX1nZXRHZW9tZXRyeSgpe3JldHVybiBudWxsPT09dGhpcy5fZ2VvbUZhY3RvcnkmJih0aGlzLl9nZW9tRmFjdG9yeT1uZXcgQ3QpLHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2V4dHJhY3RPbmx5UG9seWdvbmFsP3RoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5fcG9seUxpc3QpOnRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihDdC50b0dlb21ldHJ5QXJyYXkodGhpcy5fcG9seUxpc3QpKX1nZXRJbnZhbGlkUmluZ0xpbmVzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2ludmFsaWRSaW5nTGluZXN9ZmluZFZhbGlkUmluZ3ModCxlLG4pe2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNWYWxpZCgpP2UuYWRkKHQpOm4uYWRkKHQuZ2V0TGluZVN0cmluZygpKX19cG9seWdvbml6ZSgpe2lmKG51bGwhPT10aGlzLl9wb2x5TGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLl9wb2x5TGlzdD1uZXcgTCxudWxsPT09dGhpcy5fZ3JhcGgpcmV0dXJuIG51bGw7dGhpcy5fZGFuZ2xlcz10aGlzLl9ncmFwaC5kZWxldGVEYW5nbGVzKCksdGhpcy5fY3V0RWRnZXM9dGhpcy5fZ3JhcGguZGVsZXRlQ3V0RWRnZXMoKTtjb25zdCB0PXRoaXMuX2dyYXBoLmdldEVkZ2VSaW5ncygpO2xldCBlPW5ldyBMO3RoaXMuX2ludmFsaWRSaW5nTGluZXM9bmV3IEwsdGhpcy5faXNDaGVja2luZ1JpbmdzVmFsaWQ/dGhpcy5maW5kVmFsaWRSaW5ncyh0LGUsdGhpcy5faW52YWxpZFJpbmdMaW5lcyk6ZT10LHRoaXMuZmluZFNoZWxsc0FuZEhvbGVzKGUpLEJyLmFzc2lnbkhvbGVzVG9TaGVsbHModGhpcy5faG9sZUxpc3QsdGhpcy5fc2hlbGxMaXN0KSx4ZS5zb3J0KHRoaXMuX3NoZWxsTGlzdCxuZXcgR3IuRW52ZWxvcGVDb21wYXJhdG9yKTtsZXQgbj0hMDt0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbCYmKFlyLmZpbmREaXNqb2ludFNoZWxscyh0aGlzLl9zaGVsbExpc3QpLG49ITEpLHRoaXMuX3BvbHlMaXN0PVlyLmV4dHJhY3RQb2x5Z29ucyh0aGlzLl9zaGVsbExpc3Qsbil9Z2V0RGFuZ2xlcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9kYW5nbGVzfWdldEN1dEVkZ2VzKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX2N1dEVkZ2VzfWdldFBvbHlnb25zKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuX3BvbHlMaXN0fWFkZCgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksbnVsbD09PXRoaXMuX2dyYXBoJiYodGhpcy5fZ3JhcGg9bmV3IHFyKHRoaXMuX2dlb21GYWN0b3J5KSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7YXJndW1lbnRzWzBdLmFwcGx5KHRoaXMuX2xpbmVTdHJpbmdBZGRlcil9fXNldENoZWNrUmluZ3NWYWxpZCh0KXt0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD10fWZpbmRTaGVsbHNBbmRIb2xlcyh0KXt0aGlzLl9ob2xlTGlzdD1uZXcgTCx0aGlzLl9zaGVsbExpc3Q9bmV3IEw7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5jb21wdXRlSG9sZSgpLHQuaXNIb2xlKCk/dGhpcy5faG9sZUxpc3QuYWRkKHQpOnRoaXMuX3NoZWxsTGlzdC5hZGQodCl9fX1jbGFzcyBWcntjb25zdHJ1Y3Rvcigpe1ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMucD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fWZpbHRlcih0KXt0IGluc3RhbmNlb2YgSiYmdGhpcy5wLmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5ba119fVlyLkxpbmVTdHJpbmdBZGRlcj1Wcjt2YXIgenI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsUG9seWdvbml6ZXI6WXJ9KTtjbGFzcyBrcntjb25zdHJ1Y3Rvcigpe2tyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9wdExvY2F0b3I9bmV3IGZuLHRoaXMuX2FyZz1udWxsLHRoaXMuX25vZGVzPW5ldyBlcyhuZXcgdnIpLHRoaXMuX2ltPW51bGwsdGhpcy5faXNvbGF0ZWRFZGdlcz1uZXcgTCx0aGlzLl9pbnZhbGlkUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmc9dH1pbnNlcnRFZGdlRW5kcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGQodCl9fWNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTSh0LGUpe2NvbnN0IG49dGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCkscz10aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxpPXQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCkscj10Lmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCk7Mj09PW4mJjI9PT1zP2kmJmUuc2V0QXRMZWFzdChcIjIxMjEwMTIxMlwiKToyPT09biYmMT09PXM/KGkmJmUuc2V0QXRMZWFzdChcIkZGRjBGRkZGMlwiKSxyJiZlLnNldEF0TGVhc3QoXCIxRkZGRkYxRkZcIikpOjE9PT1uJiYyPT09cz8oaSYmZS5zZXRBdExlYXN0KFwiRjBGRkZGRkYyXCIpLHImJmUuc2V0QXRMZWFzdChcIjFGMUZGRkZGRlwiKSk6MT09PW4mJjE9PT1zJiZyJiZlLnNldEF0TGVhc3QoXCIwRkZGRkZGRkZcIil9bGFiZWxJc29sYXRlZEVkZ2VzKHQsZSl7Zm9yKGxldCBuPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dC5pc0lzb2xhdGVkKCkmJih0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlKHQsZSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSksdGhpcy5faXNvbGF0ZWRFZGdlcy5hZGQodCkpfX1sYWJlbElzb2xhdGVkRWRnZSh0LGUsbil7aWYobi5nZXREaW1lbnNpb24oKT4wKXtjb25zdCBzPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksbik7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLHMpfWVsc2UgdC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLFF0LkVYVEVSSU9SKX1jb21wdXRlSU0oKXtjb25zdCB0PW5ldyBKdDtpZih0LnNldChRdC5FWFRFUklPUixRdC5FWFRFUklPUiwyKSwhdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4gdGhpcy5jb21wdXRlRGlzam9pbnRJTSh0KSx0O3RoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSk7Y29uc3QgZT10aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSx0aGlzLl9saSwhMSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMSksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMSksdGhpcy5sYWJlbElzb2xhdGVkTm9kZXMoKSx0aGlzLmNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTShlLHQpO2NvbnN0IG49bmV3IFRyLHM9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzBdLmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKHMpO2NvbnN0IGk9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzFdLmdldEVkZ2VJdGVyYXRvcigpKTtyZXR1cm4gdGhpcy5pbnNlcnRFZGdlRW5kcyhpKSx0aGlzLmxhYmVsTm9kZUVkZ2VzKCksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMCwxKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygxLDApLHRoaXMudXBkYXRlSU0odCksdH1sYWJlbE5vZGVFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuX2FyZyl9fWNvcHlOb2Rlc0FuZExhYmVscyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fWxhYmVsSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxpPXRoaXMuX25vZGVzLmZpbmQobi5jb29yZCk7aS5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmKHM9PT1RdC5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkodCk6aS5zZXRMYWJlbCh0LFF0LklOVEVSSU9SKSl9fX1sYWJlbElzb2xhdGVkTm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG4pfWNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLGk9dGhpcy5fbm9kZXMuYWRkTm9kZShuLmNvb3JkKTtzPT09UXQuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KHQpOmkuZ2V0TGFiZWwoKS5pc051bGwodCkmJmkuc2V0TGFiZWwodCxRdC5JTlRFUklPUil9fX1sYWJlbElzb2xhdGVkTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7Zy5pc1RydWUobi5nZXRHZW9tZXRyeUNvdW50KCk+MCxcIm5vZGUgd2l0aCBlbXB0eSBsYWJlbCBmb3VuZFwiKSxlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwwKTp0aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMSkpfX11cGRhdGVJTSh0KXtmb3IobGV0IGU9dGhpcy5faXNvbGF0ZWRFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkudXBkYXRlSU0odCl9Zm9yKGxldCBlPXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24udXBkYXRlSU0odCksbi51cGRhdGVJTUZyb21FZGdlcyh0KX19Y29tcHV0ZURpc2pvaW50SU0odCl7Y29uc3QgZT10aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKTtlLmlzRW1wdHkoKXx8KHQuc2V0KFF0LklOVEVSSU9SLFF0LkVYVEVSSU9SLGUuZ2V0RGltZW5zaW9uKCkpLHQuc2V0KFF0LkJPVU5EQVJZLFF0LkVYVEVSSU9SLGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpO2NvbnN0IG49dGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCk7bi5pc0VtcHR5KCl8fCh0LnNldChRdC5FWFRFUklPUixRdC5JTlRFUklPUixuLmdldERpbWVuc2lvbigpKSx0LnNldChRdC5FWFRFUklPUixRdC5CT1VOREFSWSxuLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKX19Y2xhc3MgWHJ7Y29uc3RydWN0b3IoKXtYci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0RW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1zdGF0aWMgY29udGFpbnModCxlKXtyZXR1cm4gbmV3IFhyKHQpLmNvbnRhaW5zKGUpfWlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KXtpZih0IGluc3RhbmNlb2YgaXQpcmV0dXJuITE7aWYodCBpbnN0YW5jZW9mIHR0KXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQgaW5zdGFuY2VvZiBKKXJldHVybiB0aGlzLmlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCk7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KG4pKXJldHVybiExfXJldHVybiEwfWlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5KHQsZSl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodC54PT09ZS54KXtpZih0Lng9PT10aGlzLl9yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5fcmVjdEVudi5nZXRNYXhYKCkpcmV0dXJuITB9ZWxzZSBpZih0Lnk9PT1lLnkmJih0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNYXhZKCkpKXJldHVybiEwO3JldHVybiExfWlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49bmV3IG0scz1uZXcgbTtmb3IobGV0IHQ9MDt0PGUuc2l6ZSgpLTE7dCsrKWlmKGUuZ2V0Q29vcmRpbmF0ZSh0LG4pLGUuZ2V0Q29vcmRpbmF0ZSh0KzEscyksIXRoaXMuaXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkobixzKSlyZXR1cm4hMTtyZXR1cm4hMH1pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQuZ2V0Q29vcmRpbmF0ZSgpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0Lng9PT10aGlzLl9yZWN0RW52LmdldE1pblgoKXx8dC54PT09dGhpcy5fcmVjdEVudi5nZXRNYXhYKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1heFkoKX19Y29udGFpbnModCl7cmV0dXJuISF0aGlzLl9yZWN0RW52LmNvbnRhaW5zKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmIXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KHQpfX1jbGFzcyBVcntjb25zdHJ1Y3Rvcigpe1VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2xpPW5ldyBqdCx0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fZGlhZ1VwMD1udWxsLHRoaXMuX2RpYWdVcDE9bnVsbCx0aGlzLl9kaWFnRG93bjA9bnVsbCx0aGlzLl9kaWFnRG93bjE9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQsdGhpcy5fZGlhZ1VwMD1uZXcgbSh0LmdldE1pblgoKSx0LmdldE1pblkoKSksdGhpcy5fZGlhZ1VwMT1uZXcgbSh0LmdldE1heFgoKSx0LmdldE1heFkoKSksdGhpcy5fZGlhZ0Rvd24wPW5ldyBtKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSx0aGlzLl9kaWFnRG93bjE9bmV3IG0odC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpfWludGVyc2VjdHModCxlKXtjb25zdCBuPW5ldyBPKHQsZSk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhuKSlyZXR1cm4hMTtpZih0aGlzLl9yZWN0RW52LmludGVyc2VjdHModCkpcmV0dXJuITA7aWYodGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiEwO2lmKHQuY29tcGFyZVRvKGUpPjApe2NvbnN0IG49dDt0PWUsZT1ufWxldCBzPSExO3JldHVybiBlLnk+dC55JiYocz0hMCkscz90aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9kaWFnRG93bjAsdGhpcy5fZGlhZ0Rvd24xKTp0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9kaWFnVXAwLHRoaXMuX2RpYWdVcDEpLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl9fWNsYXNzIEhye2NvbnN0cnVjdG9yKCl7SHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcmVjdGFuZ2xlPW51bGwsdGhpcy5fcmVjdEVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RhbmdsZT10LHRoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9c3RhdGljIGludGVyc2VjdHModCxlKXtyZXR1cm4gbmV3IEhyKHQpLmludGVyc2VjdHMoZSl9aW50ZXJzZWN0cyh0KXtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTtjb25zdCBlPW5ldyBXcih0aGlzLl9yZWN0RW52KTtpZihlLmFwcGx5VG8odCksZS5pbnRlcnNlY3RzKCkpcmV0dXJuITA7Y29uc3Qgbj1uZXcgWnIodGhpcy5fcmVjdGFuZ2xlKTtpZihuLmFwcGx5VG8odCksbi5jb250YWluc1BvaW50KCkpcmV0dXJuITA7Y29uc3Qgcz1uZXcganIodGhpcy5fcmVjdGFuZ2xlKTtyZXR1cm4gcy5hcHBseVRvKHQpLCEhcy5pbnRlcnNlY3RzKCl9fWNsYXNzIFdyIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLFdyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9pbnRlcnNlY3RzPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dH1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2ludGVyc2VjdHN9dmlzaXQodCl7Y29uc3QgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKGUpP3RoaXMuX3JlY3RFbnYuY29udGFpbnMoZSl8fGUuZ2V0TWluWCgpPj10aGlzLl9yZWN0RW52LmdldE1pblgoKSYmZS5nZXRNYXhYKCk8PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WCgpfHxlLmdldE1pblkoKT49dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCkmJmUuZ2V0TWF4WSgpPD10aGlzLl9yZWN0RW52LmdldE1heFkoKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTp2b2lkIDA6bnVsbH1pbnRlcnNlY3RzKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdHN9fWNsYXNzIFpyIGV4dGVuZHMgTmV7Y29uc3RydWN0b3IoKXtzdXBlcigpLFpyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3JlY3RTZXE9bnVsbCx0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fY29udGFpbnNQb2ludD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0U2VxPXQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdGhpcy5fcmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2NvbnRhaW5zUG9pbnR9dmlzaXQodCl7aWYoISh0IGluc3RhbmNlb2YgaXQpKXJldHVybiBudWxsO2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtjb25zdCBuPW5ldyBtO2ZvcihsZXQgcz0wO3M8NDtzKyspaWYodGhpcy5fcmVjdFNlcS5nZXRDb29yZGluYXRlKHMsbiksZS5jb250YWlucyhuKSYmWmUuY29udGFpbnNQb2ludEluUG9seWdvbihuLHQpKXJldHVybiB0aGlzLl9jb250YWluc1BvaW50PSEwLG51bGx9Y29udGFpbnNQb2ludCgpe3JldHVybiB0aGlzLl9jb250YWluc1BvaW50fX1jbGFzcyBqciBleHRlbmRzIE5le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxqci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5fcmVjdEludGVyc2VjdG9yPW51bGwsdGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX3AwPW5ldyBtLHRoaXMuX3AxPW5ldyBtO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCksdGhpcy5fcmVjdEludGVyc2VjdG9yPW5ldyBVcih0aGlzLl9yZWN0RW52KX1pbnRlcnNlY3RzKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn1pc0RvbmUoKXtyZXR1cm4hMD09PXRoaXMuX2hhc0ludGVyc2VjdGlvbn12aXNpdCh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj15ZS5nZXRMaW5lcyh0KTt0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKG4pfWNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO2lmKHRoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHModCksdGhpcy5faGFzSW50ZXJzZWN0aW9uKXJldHVybiBudWxsfX1jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTE7dDxlLnNpemUoKTt0KyspaWYoZS5nZXRDb29yZGluYXRlKHQtMSx0aGlzLl9wMCksZS5nZXRDb29yZGluYXRlKHQsdGhpcy5fcDEpLHRoaXMuX3JlY3RJbnRlcnNlY3Rvci5pbnRlcnNlY3RzKHRoaXMuX3AwLHRoaXMuX3AxKSlyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLG51bGx9fWNsYXNzIEtyIGV4dGVuZHMgSXJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLEtyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3JlbGF0ZT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtJci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fcmVsYXRlPW5ldyBrcih0aGlzLl9hcmcpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO0lyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLG4pLHRoaXMuX3JlbGF0ZT1uZXcga3IodGhpcy5fYXJnKX19c3RhdGljIGNvdmVycyh0LGUpe3JldHVybiEoMj09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MikmJighKDE9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDEmJmUuZ2V0TGVuZ3RoKCk+MCkmJighIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvdmVycyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJighIXQuaXNSZWN0YW5nbGUoKXx8bmV3IEtyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDb3ZlcnMoKSkpKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUpe2lmKCF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTtpZih0LmlzUmVjdGFuZ2xlKCkpcmV0dXJuIEhyLmludGVyc2VjdHModCxlKTtpZihlLmlzUmVjdGFuZ2xlKCkpcmV0dXJuIEhyLmludGVyc2VjdHMoZSx0KTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspZm9yKGxldCBzPTA7czxlLmdldE51bUdlb21ldHJpZXMoKTtzKyspaWYodC5nZXRHZW9tZXRyeU4obikuaW50ZXJzZWN0cyhlLmdldEdlb21ldHJ5TihzKSkpcmV0dXJuITA7cmV0dXJuITF9cmV0dXJuIG5ldyBLcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzSW50ZXJzZWN0cygpfXN0YXRpYyB0b3VjaGVzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IEtyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNUb3VjaGVzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGVxdWFsc1RvcG8odCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJktyLnJlbGF0ZSh0LGUpLmlzRXF1YWxzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIHJlbGF0ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IEtyKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLmdldEludGVyc2VjdGlvbk1hdHJpeCgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IEtyKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKX19c3RhdGljIG92ZXJsYXBzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IEtyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNPdmVybGFwcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpfXN0YXRpYyBjcm9zc2VzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IEtyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDcm9zc2VzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGNvbnRhaW5zKHQsZSl7cmV0dXJuISgyPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwyKSYmKCEoMT09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MSYmZS5nZXRMZW5ndGgoKT4wKSYmKCEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY29udGFpbnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYodC5pc1JlY3RhbmdsZSgpP1hyLmNvbnRhaW5zKHQsZSk6bmV3IEtyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDb250YWlucygpKSkpfWdldEludGVyc2VjdGlvbk1hdHJpeCgpe3JldHVybiB0aGlzLl9yZWxhdGUuY29tcHV0ZUlNKCl9fXZhciBRcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxSZWxhdGVPcDpLcn0pO2NsYXNzIEpye2NvbnN0cnVjdG9yKCl7SnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcG9pbnRHZW9tPW51bGwsdGhpcy5fb3RoZXJHZW9tPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wb2ludEdlb209dCx0aGlzLl9vdGhlckdlb209ZSx0aGlzLl9nZW9tRmFjdD1lLmdldEZhY3RvcnkoKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gbmV3IEpyKHQsZSkudW5pb24oKX11bmlvbigpe2NvbnN0IHQ9bmV3IGZuLGU9bmV3IGx0O2ZvcihsZXQgbj0wO248dGhpcy5fcG9pbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dGhpcy5fcG9pbnRHZW9tLmdldEdlb21ldHJ5TihuKS5nZXRDb29yZGluYXRlKCk7dC5sb2NhdGUocyx0aGlzLl9vdGhlckdlb20pPT09UXQuRVhURVJJT1ImJmUuYWRkKHMpfWlmKDA9PT1lLnNpemUoKSlyZXR1cm4gdGhpcy5fb3RoZXJHZW9tO2xldCBuPW51bGw7Y29uc3Qgcz1kdC50b0Nvb3JkaW5hdGVBcnJheShlKTtyZXR1cm4gbj0xPT09cy5sZW5ndGg/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoc1swXSk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMocyksaGUuY29tYmluZShuLHRoaXMuX290aGVyR2VvbSl9fWNsYXNzICRye2NvbnN0cnVjdG9yKCl7JHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9wb2x5Z29ucz1uZXcgTCx0aGlzLl9saW5lcz1uZXcgTCx0aGlzLl9wb2ludHM9bmV3IEwsdGhpcy5fZGltZW5zaW9uPUsuRkFMU0V9c3RhdGljIGV4dHJhY3QoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgJHI7cmV0dXJuIGUuYWRkKHQpLGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyAkcjtyZXR1cm4gZS5hZGQodCksZX19Z2V0RmFjdG9yeSgpe3JldHVybiB0aGlzLl9nZW9tRmFjdG9yeX1yZWNvcmREaW1lbnNpb24odCl7dD50aGlzLl9kaW1lbnNpb24mJih0aGlzLl9kaW1lbnNpb249dCl9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuX2RpbWVuc2lvbn1maWx0ZXIodCl7cmV0dXJuIHRoaXMucmVjb3JkRGltZW5zaW9uKHQuZ2V0RGltZW5zaW9uKCkpLHQgaW5zdGFuY2VvZiBjdHx8dC5pc0VtcHR5KCk/bnVsbDp0IGluc3RhbmNlb2YgaXQ/KHRoaXMuX3BvbHlnb25zLmFkZCh0KSxudWxsKTp0IGluc3RhbmNlb2YgSj8odGhpcy5fbGluZXMuYWRkKHQpLG51bGwpOnQgaW5zdGFuY2VvZiB0dD8odGhpcy5fcG9pbnRzLmFkZCh0KSxudWxsKTp2b2lkIGcuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogXCIrdC5nZXRHZW9tZXRyeVR5cGUoKSl9Z2V0RXh0cmFjdCh0KXtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB0aGlzLl9wb2ludHM7Y2FzZSAxOnJldHVybiB0aGlzLl9saW5lcztjYXNlIDI6cmV0dXJuIHRoaXMuX3BvbHlnb25zfXJldHVybiBnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiSW52YWxpZCBkaW1lbnNpb246IFwiK3QpLG51bGx9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9wb2x5Z29ucy5pc0VtcHR5KCkmJnRoaXMuX2xpbmVzLmlzRW1wdHkoKSYmdGhpcy5fcG9pbnRzLmlzRW1wdHkoKX1hZGQoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGNvbnN0IGUgb2YgdCl0aGlzLmFkZChlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2dlb21GYWN0b3J5JiYodGhpcy5fZ2VvbUZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHQuYXBwbHkodGhpcyl9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltRXX19Y2xhc3MgdG97Y29uc3RydWN0b3IoKXt0by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9nZW9tRmFjdG9yeT1udWxsLHRoaXMuX2cwPW51bGwsdGhpcy5fZzE9bnVsbCx0aGlzLl9pc1VuaW9uU2FmZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2cwPXQsdGhpcy5fZzE9ZSx0aGlzLl9nZW9tRmFjdG9yeT10LmdldEZhY3RvcnkoKX1zdGF0aWMgY29udGFpbnNQcm9wZXJseSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdC5pc051bGwoKSYmKGUuZ2V0WCgpPnQuZ2V0TWluWCgpJiZlLmdldFgoKTx0LmdldE1heFgoKSYmZS5nZXRZKCk+dC5nZXRNaW5ZKCkmJmUuZ2V0WSgpPHQuZ2V0TWF4WSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRvLmNvbnRhaW5zUHJvcGVybHkodCxlKSYmdG8uY29udGFpbnNQcm9wZXJseSh0LG4pfX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gbmV3IHRvKHQsZSkudW5pb24oKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUsbil7cmV0dXJuIHQuaW50ZXJzZWN0cyhlKXx8dC5pbnRlcnNlY3RzKG4pfXN0YXRpYyBvdmVybGFwRW52ZWxvcGUodCxlKXtjb25zdCBuPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHM9ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIG4uaW50ZXJzZWN0aW9uKHMpfXN0YXRpYyBleHRyYWN0Qm9yZGVyU2VnbWVudHModCxlLG4pe3QuYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltQXX1maWx0ZXIodCxzKXtpZihzPD0wKXJldHVybiBudWxsO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlKHMtMSkscj10LmdldENvb3JkaW5hdGUocyk7aWYodG8uaW50ZXJzZWN0cyhlLGkscikmJiF0by5jb250YWluc1Byb3Blcmx5KGUsaSxyKSl7Y29uc3QgdD1uZXcgS3QoaSxyKTtuLmFkZCh0KX19aXNEb25lKCl7cmV0dXJuITF9aXNHZW9tZXRyeUNoYW5nZWQoKXtyZXR1cm4hMX19KX1zdGF0aWMgdW5pb25CdWZmZXIodCxlKXtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFt0LGVdKS5idWZmZXIoMCl9aXNCb3JkZXJTZWdtZW50c1NhbWUodCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdEJvcmRlclNlZ21lbnRzKHRoaXMuX2cwLHRoaXMuX2cxLGUpLHM9bmV3IEw7cmV0dXJuIHRvLmV4dHJhY3RCb3JkZXJTZWdtZW50cyh0LGUscyksdGhpcy5pc0VxdWFsKG4scyl9ZXh0cmFjdEJ5RW52ZWxvcGUodCxlLG4pe2NvbnN0IHM9bmV3IEw7Zm9yKGxldCBpPTA7aTxlLmdldE51bUdlb21ldHJpZXMoKTtpKyspe2NvbnN0IHI9ZS5nZXRHZW9tZXRyeU4oaSk7aWYoci5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KSlzLmFkZChyKTtlbHNle2NvbnN0IHQ9ci5jb3B5KCk7bi5hZGQodCl9fXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHMpfWlzRXF1YWwodCxlKXtpZih0LnNpemUoKSE9PWUuc2l6ZSgpKXJldHVybiExO2NvbnN0IG49bmV3IHh0KHQpO2Zvcihjb25zdCB0IG9mIGUpaWYoIW4uY29udGFpbnModCkpcmV0dXJuITE7cmV0dXJuITB9dW5pb24oKXtjb25zdCB0PXRvLm92ZXJsYXBFbnZlbG9wZSh0aGlzLl9nMCx0aGlzLl9nMSk7aWYodC5pc051bGwoKSl7Y29uc3QgdD10aGlzLl9nMC5jb3B5KCksZT10aGlzLl9nMS5jb3B5KCk7cmV0dXJuIGhlLmNvbWJpbmUodCxlKX1jb25zdCBlPW5ldyBMLG49dGhpcy5leHRyYWN0QnlFbnZlbG9wZSh0LHRoaXMuX2cwLGUpLHM9dGhpcy5leHRyYWN0QnlFbnZlbG9wZSh0LHRoaXMuX2cxLGUpLGk9dGhpcy51bmlvbkZ1bGwobixzKTtsZXQgcj1udWxsO3JldHVybiB0aGlzLl9pc1VuaW9uU2FmZT10aGlzLmlzQm9yZGVyU2VnbWVudHNTYW1lKGksdCkscj10aGlzLl9pc1VuaW9uU2FmZT90aGlzLmNvbWJpbmUoaSxlKTp0aGlzLnVuaW9uRnVsbCh0aGlzLl9nMCx0aGlzLl9nMSkscn1jb21iaW5lKHQsZSl7aWYoZS5zaXplKCk8PTApcmV0dXJuIHQ7ZS5hZGQodCk7cmV0dXJuIGhlLmNvbWJpbmUoZSl9dW5pb25GdWxsKHQsZSl7dHJ5e3JldHVybiB0LnVuaW9uKGUpfWNhdGNoKG4pe2lmKG4gaW5zdGFuY2VvZiBzcylyZXR1cm4gdG8udW5pb25CdWZmZXIodCxlKTt0aHJvdyBufX1leHRyYWN0Qm9yZGVyU2VnbWVudHModCxlLG4pe2NvbnN0IHM9bmV3IEw7cmV0dXJuIHRvLmV4dHJhY3RCb3JkZXJTZWdtZW50cyh0LG4scyksbnVsbCE9PWUmJnRvLmV4dHJhY3RCb3JkZXJTZWdtZW50cyhlLG4scyksc31pc1VuaW9uT3B0aW1pemVkKCl7cmV0dXJuIHRoaXMuX2lzVW5pb25TYWZlfX1jbGFzcyBlb3tjb25zdHJ1Y3Rvcigpe2VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0UG9seXM9bnVsbCx0aGlzLl9nZW9tRmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0UG9seXM9dCxudWxsPT09dGhpcy5faW5wdXRQb2x5cyYmKHRoaXMuX2lucHV0UG9seXM9bmV3IEwpfXN0YXRpYyByZXN0cmljdFRvUG9seWdvbnModCl7aWYoSSh0LHN0KSlyZXR1cm4gdDtjb25zdCBlPUllLmdldFBvbHlnb25zKHQpO3JldHVybiAxPT09ZS5zaXplKCk/ZS5nZXQoMCk6dC5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKEN0LnRvUG9seWdvbkFycmF5KGUpKX1zdGF0aWMgZ2V0R2VvbWV0cnkodCxlKXtyZXR1cm4gZT49dC5zaXplKCk/bnVsbDp0LmdldChlKX1zdGF0aWMgdW5pb24odCl7cmV0dXJuIG5ldyBlbyh0KS51bmlvbigpfXJlZHVjZVRvR2VvbWV0cmllcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2xldCBzPW51bGw7SSh0LHcpP3M9dGhpcy51bmlvblRyZWUodCk6dCBpbnN0YW5jZW9mIFgmJihzPXQpLGUuYWRkKHMpfXJldHVybiBlfXVuaW9uKCl7aWYobnVsbD09PXRoaXMuX2lucHV0UG9seXMpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcInVuaW9uKCkgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2VcIik7aWYodGhpcy5faW5wdXRQb2x5cy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5fZ2VvbUZhY3Rvcnk9dGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCk7Y29uc3QgdD1uZXcgdnMoZW8uU1RSVFJFRV9OT0RFX0NBUEFDSVRZKTtmb3IobGV0IGU9dGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0Lmluc2VydChuLmdldEVudmVsb3BlSW50ZXJuYWwoKSxuKX10aGlzLl9pbnB1dFBvbHlzPW51bGw7Y29uc3QgZT10Lml0ZW1zVHJlZSgpO3JldHVybiB0aGlzLnVuaW9uVHJlZShlKX1iaW5hcnlVbmlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5iaW5hcnlVbmlvbih0LDAsdC5zaXplKCkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihuLWU8PTEpe2NvbnN0IG49ZW8uZ2V0R2VvbWV0cnkodCxlKTtyZXR1cm4gdGhpcy51bmlvblNhZmUobixudWxsKX1pZihuLWU9PTIpcmV0dXJuIHRoaXMudW5pb25TYWZlKGVvLmdldEdlb21ldHJ5KHQsZSksZW8uZ2V0R2VvbWV0cnkodCxlKzEpKTt7Y29uc3Qgcz1NYXRoLnRydW5jKChuK2UpLzIpLGk9dGhpcy5iaW5hcnlVbmlvbih0LGUscykscj10aGlzLmJpbmFyeVVuaW9uKHQscyxuKTtyZXR1cm4gdGhpcy51bmlvblNhZmUoaSxyKX19fXJlcGVhdGVkVW5pb24odCl7bGV0IGU9bnVsbDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlPW51bGw9PT1lP3QuY29weSgpOmUudW5pb24odCl9cmV0dXJuIGV9dW5pb25TYWZlKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT10P2UuY29weSgpOm51bGw9PT1lP3QuY29weSgpOnRoaXMudW5pb25BY3R1YWwodCxlKX11bmlvbkFjdHVhbCh0LGUpe2NvbnN0IG49dG8udW5pb24odCxlKTtyZXR1cm4gZW8ucmVzdHJpY3RUb1BvbHlnb25zKG4pfXVuaW9uVHJlZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlVG9HZW9tZXRyaWVzKHQpO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKGUpfWJ1ZmZlclVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldCgwKS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh0KS5idWZmZXIoMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oW3QsZV0pLmJ1ZmZlcigwKX19fWVvLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWT00O2NsYXNzIG5ve2NvbnN0cnVjdG9yKCl7bm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9leHRyYWN0ZXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tRmFjdD1lLHRoaXMuZXh0cmFjdCh0KX19c3RhdGljIHVuaW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKEkoYXJndW1lbnRzWzBdLE4pKXtyZXR1cm4gbmV3IG5vKGFyZ3VtZW50c1swXSkudW5pb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe3JldHVybiBuZXcgbm8oYXJndW1lbnRzWzBdKS51bmlvbigpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gbmV3IG5vKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLnVuaW9uKCl9fXVuaW9uTm9PcHQodCl7Y29uc3QgZT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludCgpO3JldHVybiBFci5vdmVybGF5T3AodCxlLE5yLlVOSU9OKX11bmlvbldpdGhOdWxsKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT1lP3Q6bnVsbD09PXQ/ZTp0LnVuaW9uKGUpfWV4dHJhY3QoKXtpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZXh0cmFjdGVyPSRyLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2V4dHJhY3Rlcj0kci5leHRyYWN0KHQpfX11bmlvbigpe2lmKG51bGw9PT10aGlzLl9nZW9tRmFjdCYmKHRoaXMuX2dlb21GYWN0PXRoaXMuX2V4dHJhY3Rlci5nZXRGYWN0b3J5KCkpLG51bGw9PT10aGlzLl9nZW9tRmFjdClyZXR1cm4gbnVsbDtpZih0aGlzLl9leHRyYWN0ZXIuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVFbXB0eSh0aGlzLl9leHRyYWN0ZXIuZ2V0RGltZW5zaW9uKCkpO2NvbnN0IHQ9dGhpcy5fZXh0cmFjdGVyLmdldEV4dHJhY3QoMCksZT10aGlzLl9leHRyYWN0ZXIuZ2V0RXh0cmFjdCgxKSxuPXRoaXMuX2V4dHJhY3Rlci5nZXRFeHRyYWN0KDIpO2xldCBzPW51bGw7aWYodC5zaXplKCk+MCl7Y29uc3QgZT10aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHQpO3M9dGhpcy51bmlvbk5vT3B0KGUpfWxldCBpPW51bGw7aWYoZS5zaXplKCk+MCl7Y29uc3QgdD10aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGUpO2k9dGhpcy51bmlvbk5vT3B0KHQpfWxldCByPW51bGw7bi5zaXplKCk+MCYmKHI9ZW8udW5pb24obikpO2NvbnN0IG89dGhpcy51bmlvbldpdGhOdWxsKGkscik7bGV0IGw9bnVsbDtyZXR1cm4gbD1udWxsPT09cz9vOm51bGw9PT1vP3M6SnIudW5pb24ocyxvKSxudWxsPT09bD90aGlzLl9nZW9tRmFjdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTpsfX12YXIgc289T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVW5hcnlVbmlvbk9wOm5vfSksaW89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsSXNWYWxpZE9wOkZyLENvbnNpc3RlbnRBcmVhVGVzdGVyOmJyfSkscm89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQm91bmRhcnlPcDpzaSxJc1NpbXBsZU9wOnJpLGJ1ZmZlcjpxaSxkaXN0YW5jZTp6aSxsaW5lbWVyZ2U6aXIsb3ZlcmxheTpTcixwb2x5Z29uaXplOnpyLHJlbGF0ZTpRcix1bmlvbjpzbyx2YWxpZDppb30pO2NsYXNzIG9vIGV4dGVuZHMgdWUuQ29vcmRpbmF0ZU9wZXJhdGlvbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksb28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdGFyZ2V0UE09bnVsbCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdGFyZ2V0UE09dCx0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9ZX1lZGl0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgWCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBzPW5ldyBtKHRbZV0pO3RoaXMuX3RhcmdldFBNLm1ha2VQcmVjaXNlKHMpLG5bZV09c31jb25zdCBzPW5ldyBSKG4sITEpLnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IGk9MDtlIGluc3RhbmNlb2YgSiYmKGk9MiksZSBpbnN0YW5jZW9mIHV0JiYoaT00KTtsZXQgcj1uO3JldHVybiB0aGlzLl9yZW1vdmVDb2xsYXBzZWQmJihyPW51bGwpLHMubGVuZ3RoPGk/cjpzfXJldHVybiBzdXBlci5lZGl0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19Y2xhc3MgbG97Y29uc3RydWN0b3IoKXtsby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90YXJnZXRQTT1udWxsLHRoaXMuX3JlbW92ZUNvbGxhcHNlZD0hMCx0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD0hMSx0aGlzLl9pc1BvaW50d2lzZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl90YXJnZXRQTT10fXN0YXRpYyByZWR1Y2UodCxlKXtyZXR1cm4gbmV3IGxvKGUpLnJlZHVjZSh0KX1zdGF0aWMgcmVkdWNlUG9pbnR3aXNlKHQsZSl7Y29uc3Qgbj1uZXcgbG8oZSk7cmV0dXJuIG4uc2V0UG9pbnR3aXNlKCEwKSxuLnJlZHVjZSh0KX1maXhQb2x5Z29uYWxUb3BvbG9neSh0KXtsZXQgZT10O3RoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsfHwoZT10aGlzLmNoYW5nZVBNKHQsdGhpcy5fdGFyZ2V0UE0pKTtyZXR1cm4gR2kuYnVmZmVyT3AoZSwwKX1yZWR1Y2VQb2ludHdpc2UodCl7bGV0IGU9bnVsbDtpZih0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbCl7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodC5nZXRGYWN0b3J5KCksdGhpcy5fdGFyZ2V0UE0pO2U9bmV3IHVlKG4pfWVsc2UgZT1uZXcgdWU7bGV0IG49dGhpcy5fcmVtb3ZlQ29sbGFwc2VkO3QuZ2V0RGltZW5zaW9uKCk+PTImJihuPSEwKTtyZXR1cm4gZS5lZGl0KHQsbmV3IG9vKHRoaXMuX3RhcmdldFBNLG4pKX1jaGFuZ2VQTSh0LGUpe3JldHVybiB0aGlzLmNyZWF0ZUVkaXRvcih0LmdldEZhY3RvcnkoKSxlKS5lZGl0KHQsbmV3IHVlLk5vT3BHZW9tZXRyeU9wZXJhdGlvbil9c2V0UmVtb3ZlQ29sbGFwc2VkQ29tcG9uZW50cyh0KXt0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9dH1jcmVhdGVGYWN0b3J5KHQsZSl7cmV0dXJuIG5ldyBDdChlLHQuZ2V0U1JJRCgpLHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1zZXRDaGFuZ2VQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD10fXJlZHVjZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlUG9pbnR3aXNlKHQpO3JldHVybiB0aGlzLl9pc1BvaW50d2lzZT9lOkkoZSxzdCk/RnIuaXNWYWxpZChlKT9lOnRoaXMuZml4UG9seWdvbmFsVG9wb2xvZ3koZSk6ZX1zZXRQb2ludHdpc2UodCl7dGhpcy5faXNQb2ludHdpc2U9dH1jcmVhdGVFZGl0b3IodCxlKXtpZih0LmdldFByZWNpc2lvbk1vZGVsKCk9PT1lKXJldHVybiBuZXcgdWU7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodCxlKTtyZXR1cm4gbmV3IHVlKG4pfX12YXIgYW89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlQcmVjaXNpb25SZWR1Y2VyOmxvfSk7Y2xhc3MgY297Y29uc3RydWN0b3IoKXtjby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl91c2VQdD1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5fc2VnPW5ldyBLdDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBjbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLnNpbXBsaWZ5KCl9c2ltcGxpZnlTZWN0aW9uKHQsZSl7aWYodCsxPT09ZSlyZXR1cm4gbnVsbDt0aGlzLl9zZWcucDA9dGhpcy5fcHRzW3RdLHRoaXMuX3NlZy5wMT10aGlzLl9wdHNbZV07bGV0IG49LTEscz10O2ZvcihsZXQgaT10KzE7aTxlO2krKyl7Y29uc3QgdD10aGlzLl9zZWcuZGlzdGFuY2UodGhpcy5fcHRzW2ldKTt0Pm4mJihuPXQscz1pKX1pZihuPD10aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSlmb3IobGV0IG49dCsxO248ZTtuKyspdGhpcy5fdXNlUHRbbl09ITE7ZWxzZSB0aGlzLnNpbXBsaWZ5U2VjdGlvbih0LHMpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKHMsZSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeSgpe3RoaXMuX3VzZVB0PW5ldyBBcnJheSh0aGlzLl9wdHMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fcHRzLmxlbmd0aDt0KyspdGhpcy5fdXNlUHRbdF09ITA7dGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLl9wdHMubGVuZ3RoLTEpO2NvbnN0IHQ9bmV3IFI7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wdHMubGVuZ3RoO2UrKyl0aGlzLl91c2VQdFtlXSYmdC5hZGQobmV3IG0odGhpcy5fcHRzW2VdKSk7cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX19Y2xhc3MgaG97Y29uc3RydWN0b3IoKXtoby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBobyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9c2V0RW5zdXJlVmFsaWQodCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLl9pbnB1dEdlb20uY29weSgpOm5ldyB1byh0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgcyhcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fX1jbGFzcyB1byBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx1by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITAsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1lfXRyYW5zZm9ybVBvbHlnb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBmdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1udWxsO3JldHVybiBzPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpjby5zaW1wbGlmeShuLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPWUgaW5zdGFuY2VvZiBpdCxzPXN1cGVyLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fHMgaW5zdGFuY2VvZiB1dD9zOm51bGx9fWhvLkRQVHJhbnNmb3JtZXI9dW87Y2xhc3MgZ28gZXh0ZW5kcyBLdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZ28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcGFyZW50PW51bGwsdGhpcy5faW5kZXg9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Z28uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbnVsbCwtMSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107S3QuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUpLHRoaXMuX3BhcmVudD1uLHRoaXMuX2luZGV4PXN9fWdldEluZGV4KCl7cmV0dXJuIHRoaXMuX2luZGV4fWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnR9fWNsYXNzIF9ve2NvbnN0cnVjdG9yKCl7X28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fcGFyZW50TGluZT1udWxsLHRoaXMuX3NlZ3M9bnVsbCx0aGlzLl9yZXN1bHRTZWdzPW5ldyBMLHRoaXMuX21pbmltdW1TaXplPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO19vLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wYXJlbnRMaW5lPXQsdGhpcy5fbWluaW11bVNpemU9ZSx0aGlzLmluaXQoKX19c3RhdGljIGV4dHJhY3RDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSsxKS5maWxsKG51bGwpO2xldCBuPW51bGw7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspbj10LmdldChzKSxlW3NdPW4ucDA7cmV0dXJuIGVbZS5sZW5ndGgtMV09bi5wMSxlfWFkZFRvUmVzdWx0KHQpe3RoaXMuX3Jlc3VsdFNlZ3MuYWRkKHQpfWFzTGluZVN0cmluZygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKF9vLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKSl9Z2V0UmVzdWx0U2l6ZSgpe2NvbnN0IHQ9dGhpcy5fcmVzdWx0U2Vncy5zaXplKCk7cmV0dXJuIDA9PT10PzA6dCsxfWdldFBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lfWdldFNlZ21lbnQodCl7cmV0dXJuIHRoaXMuX3NlZ3NbdF19Z2V0UGFyZW50Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpfWdldE1pbmltdW1TaXplKCl7cmV0dXJuIHRoaXMuX21pbmltdW1TaXplfWFzTGluZWFyUmluZygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKF9vLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLl9yZXN1bHRTZWdzKSl9Z2V0U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fc2Vnc31pbml0KCl7Y29uc3QgdD10aGlzLl9wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5fc2Vncz1uZXcgQXJyYXkodC5sZW5ndGgtMSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTE7ZSsrKXtjb25zdCBuPW5ldyBnbyh0W2VdLHRbZSsxXSx0aGlzLl9wYXJlbnRMaW5lLGUpO3RoaXMuX3NlZ3NbZV09bn19Z2V0UmVzdWx0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gX28uZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpfX1jbGFzcyBwb3tjb25zdHJ1Y3Rvcigpe3BvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2luZGV4PW5ldyBJc31yZW1vdmUodCl7dGhpcy5faW5kZXgucmVtb3ZlKG5ldyBPKHQucDAsdC5wMSksdCl9YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfbyl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0U2VnbWVudHMoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO3RoaXMuYWRkKG4pfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2luZGV4Lmluc2VydChuZXcgTyh0LnAwLHQucDEpLHQpfX1xdWVyeSh0KXtjb25zdCBlPW5ldyBPKHQucDAsdC5wMSksbj1uZXcgbW8odCk7dGhpcy5faW5kZXgucXVlcnkoZSxuKTtyZXR1cm4gbi5nZXRJdGVtcygpfX1jbGFzcyBtb3tjb25zdHJ1Y3Rvcigpe21vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3F1ZXJ5U2VnPW51bGwsdGhpcy5faXRlbXM9bmV3IEw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcXVlcnlTZWc9dH12aXNpdEl0ZW0odCl7Y29uc3QgZT10O08uaW50ZXJzZWN0cyhlLnAwLGUucDEsdGhpcy5fcXVlcnlTZWcucDAsdGhpcy5fcXVlcnlTZWcucDEpJiZ0aGlzLl9pdGVtcy5hZGQodCl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RlXX19Y2xhc3MgZm97Y29uc3RydWN0b3IoKXtmby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saT1uZXcganQsdGhpcy5faW5wdXRJbmRleD1uZXcgcG8sdGhpcy5fb3V0cHV0SW5kZXg9bmV3IHBvLHRoaXMuX2xpbmU9bnVsbCx0aGlzLl9saW5lUHRzPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9MDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbnB1dEluZGV4PXQsdGhpcy5fb3V0cHV0SW5kZXg9ZX1zdGF0aWMgaXNJbkxpbmVTZWN0aW9uKHQsZSxuKXtpZihuLmdldFBhcmVudCgpIT09dC5nZXRQYXJlbnQoKSlyZXR1cm4hMTtjb25zdCBzPW4uZ2V0SW5kZXgoKTtyZXR1cm4gcz49ZVswXSYmczxlWzFdfWZsYXR0ZW4odCxlKXtjb25zdCBuPXRoaXMuX2xpbmVQdHNbdF0scz10aGlzLl9saW5lUHRzW2VdLGk9bmV3IEt0KG4scyk7cmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMuX2xpbmUsdCxlKSx0aGlzLl9vdXRwdXRJbmRleC5hZGQoaSksaX1oYXNCYWRJbnRlcnNlY3Rpb24odCxlLG4pe3JldHVybiEhdGhpcy5oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24obil8fCEhdGhpcy5oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeVNlY3Rpb24odCxlLG4pe24rPTE7Y29uc3Qgcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0KzE9PT1lKXtjb25zdCBlPXRoaXMuX2xpbmUuZ2V0U2VnbWVudCh0KTtyZXR1cm4gdGhpcy5fbGluZS5hZGRUb1Jlc3VsdChlKSxudWxsfWxldCBpPSEwO2lmKHRoaXMuX2xpbmUuZ2V0UmVzdWx0U2l6ZSgpPHRoaXMuX2xpbmUuZ2V0TWluaW11bVNpemUoKSl7bisxPHRoaXMuX2xpbmUuZ2V0TWluaW11bVNpemUoKSYmKGk9ITEpfWNvbnN0IHI9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbz10aGlzLmZpbmRGdXJ0aGVzdFBvaW50KHRoaXMuX2xpbmVQdHMsdCxlLHIpO3JbMF0+dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UmJihpPSExKTtjb25zdCBsPW5ldyBLdDtpZihsLnAwPXRoaXMuX2xpbmVQdHNbdF0sbC5wMT10aGlzLl9saW5lUHRzW2VdLHNbMF09dCxzWzFdPWUsdGhpcy5oYXNCYWRJbnRlcnNlY3Rpb24odGhpcy5fbGluZSxzLGwpJiYoaT0hMSksaSl7Y29uc3Qgbj10aGlzLmZsYXR0ZW4odCxlKTtyZXR1cm4gdGhpcy5fbGluZS5hZGRUb1Jlc3VsdChuKSxudWxsfXRoaXMuc2ltcGxpZnlTZWN0aW9uKHQsbyxuKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihvLGUsbil9aGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10aGlzLl9vdXRwdXRJbmRleC5xdWVyeSh0KS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKG4sdCkpcmV0dXJuITB9cmV0dXJuITF9ZmluZEZ1cnRoZXN0UG9pbnQodCxlLG4scyl7Y29uc3QgaT1uZXcgS3Q7aS5wMD10W2VdLGkucDE9dFtuXTtsZXQgcj0tMSxvPWU7Zm9yKGxldCBzPWUrMTtzPG47cysrKXtjb25zdCBlPXRbc10sbj1pLmRpc3RhbmNlKGUpO24+ciYmKHI9bixvPXMpfXJldHVybiBzWzBdPXIsb31zaW1wbGlmeSh0KXt0aGlzLl9saW5lPXQsdGhpcy5fbGluZVB0cz10LmdldFBhcmVudENvb3JkaW5hdGVzKCksdGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLl9saW5lUHRzLmxlbmd0aC0xLDApfXJlbW92ZSh0LGUsbil7Zm9yKGxldCBzPWU7czxuO3MrKyl7Y29uc3QgZT10LmdldFNlZ21lbnQocyk7dGhpcy5faW5wdXRJbmRleC5yZW1vdmUoZSl9fWhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odC5wMCx0LnAxLGUucDAsZS5wMSksdGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpfWhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKXtmb3IobGV0IHM9dGhpcy5faW5wdXRJbmRleC5xdWVyeShuKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKGksbikpe2lmKGZvLmlzSW5MaW5lU2VjdGlvbih0LGUsaSkpY29udGludWU7cmV0dXJuITB9fXJldHVybiExfX1jbGFzcyB5b3tjb25zdHJ1Y3Rvcigpe3lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0SW5kZXg9bmV3IHBvLHRoaXMuX291dHB1dEluZGV4PW5ldyBwbyx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT0wfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9c2ltcGxpZnkodCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5faW5wdXRJbmRleC5hZGQoZS5uZXh0KCkpO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PW5ldyBmbyh0aGlzLl9pbnB1dEluZGV4LHRoaXMuX291dHB1dEluZGV4KTt0LnNldERpc3RhbmNlVG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0LnNpbXBsaWZ5KGUubmV4dCgpKX19fWNsYXNzIHhve2NvbnN0cnVjdG9yKCl7eG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fbGluZVNpbXBsaWZpZXI9bmV3IHlvLHRoaXMuX2xpbmVzdHJpbmdNYXA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyB4byh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtpZih0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLl9pbnB1dEdlb20uY29weSgpO3RoaXMuX2xpbmVzdHJpbmdNYXA9bmV3IEl0LHRoaXMuX2lucHV0R2VvbS5hcHBseShuZXcgSW8odGhpcykpLHRoaXMuX2xpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KHRoaXMuX2xpbmVzdHJpbmdNYXAudmFsdWVzKCkpO3JldHVybiBuZXcgRW8odGhpcy5fbGluZXN0cmluZ01hcCkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBzKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2xpbmVTaW1wbGlmaWVyLnNldERpc3RhbmNlVG9sZXJhbmNlKHQpfX1jbGFzcyBFbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxFby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lc3RyaW5nTWFwPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZXN0cmluZ01hcD10fXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7aWYoMD09PXQuc2l6ZSgpKXJldHVybiBudWxsO2lmKGUgaW5zdGFuY2VvZiBKKXtjb25zdCB0PXRoaXMuX2xpbmVzdHJpbmdNYXAuZ2V0KGUpO3JldHVybiB0aGlzLmNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSh0LmdldFJlc3VsdENvb3JkaW5hdGVzKCkpfXJldHVybiBzdXBlci50cmFuc2Zvcm1Db29yZGluYXRlcy5jYWxsKHRoaXMsdCxlKX19Y2xhc3MgSW97Y29uc3RydWN0b3IoKXtJby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLnRwcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMudHBzPXR9ZmlsdGVyKHQpe2lmKHQgaW5zdGFuY2VvZiBKKXtjb25zdCBlPXQ7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1lLmlzQ2xvc2VkKCk/NDoyLHM9bmV3IF9vKGUsbik7dGhpcy50cHMuX2xpbmVzdHJpbmdNYXAucHV0KGUscyl9fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltrXX19eG8uTGluZVN0cmluZ1RyYW5zZm9ybWVyPUVvLHhvLkxpbmVTdHJpbmdNYXBCdWlsZGVyRmlsdGVyPUlvO2NsYXNzIE5ve2NvbnN0cnVjdG9yKCl7Tm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHRzPXQsdGhpcy5fdG9sZXJhbmNlPWUqZX1zdGF0aWMgc2ltcGxpZnkodCxlKXtyZXR1cm4gbmV3IE5vKHQsZSkuc2ltcGxpZnkoKX1zaW1wbGlmeVZlcnRleCh0KXtsZXQgZT10LG49ZS5nZXRBcmVhKCkscz1udWxsO2Zvcig7bnVsbCE9PWU7KXtjb25zdCB0PWUuZ2V0QXJlYSgpO3Q8biYmKG49dCxzPWUpLGU9ZS5fbmV4dH1yZXR1cm4gbnVsbCE9PXMmJm48dGhpcy5fdG9sZXJhbmNlJiZzLnJlbW92ZSgpLHQuaXNMaXZlKCk/bjotMX1zaW1wbGlmeSgpe2NvbnN0IHQ9U28uYnVpbGRMaW5lKHRoaXMuX3B0cyk7bGV0IGU9dGhpcy5fdG9sZXJhbmNlO2Rve2U9dGhpcy5zaW1wbGlmeVZlcnRleCh0KX13aGlsZShlPHRoaXMuX3RvbGVyYW5jZSk7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIG4ubGVuZ3RoPDI/W25bMF0sbmV3IG0oblswXSldOm59fWNsYXNzIFNve2NvbnN0cnVjdG9yKCl7U28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fcHQ9bnVsbCx0aGlzLl9wcmV2PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2FyZWE9U28uTUFYX0FSRUEsdGhpcy5faXNMaXZlPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0PXR9c3RhdGljIGJ1aWxkTGluZSh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl7Y29uc3QgaT1uZXcgU28odFtzXSk7bnVsbD09PWUmJihlPWkpLGkuc2V0UHJldihuKSxudWxsIT09biYmKG4uc2V0TmV4dChpKSxuLnVwZGF0ZUFyZWEoKSksbj1pfXJldHVybiBlfWdldENvb3JkaW5hdGVzKCl7Y29uc3QgdD1uZXcgUjtsZXQgZT10aGlzO2Rve3QuYWRkKGUuX3B0LCExKSxlPWUuX25leHR9d2hpbGUobnVsbCE9PWUpO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9Z2V0QXJlYSgpe3JldHVybiB0aGlzLl9hcmVhfXVwZGF0ZUFyZWEoKXtpZihudWxsPT09dGhpcy5fcHJldnx8bnVsbD09PXRoaXMuX25leHQpcmV0dXJuIHRoaXMuX2FyZWE9U28uTUFYX0FSRUEsbnVsbDt0aGlzLl9hcmVhPU1hdGguYWJzKG5lLmFyZWEodGhpcy5fcHJldi5fcHQsdGhpcy5fcHQsdGhpcy5fbmV4dC5fcHQpKX1yZW1vdmUoKXtjb25zdCB0PXRoaXMuX3ByZXYsZT10aGlzLl9uZXh0O2xldCBuPW51bGw7cmV0dXJuIG51bGwhPT10aGlzLl9wcmV2JiYodGhpcy5fcHJldi5zZXROZXh0KGUpLHRoaXMuX3ByZXYudXBkYXRlQXJlYSgpLG49dGhpcy5fcHJldiksbnVsbCE9PXRoaXMuX25leHQmJih0aGlzLl9uZXh0LnNldFByZXYodCksdGhpcy5fbmV4dC51cGRhdGVBcmVhKCksbnVsbD09PW4mJihuPXRoaXMuX25leHQpKSx0aGlzLl9pc0xpdmU9ITEsbn1pc0xpdmUoKXtyZXR1cm4gdGhpcy5faXNMaXZlfXNldFByZXYodCl7dGhpcy5fcHJldj10fXNldE5leHQodCl7dGhpcy5fbmV4dD10fX1Tby5NQVhfQVJFQT1yLk1BWF9WQUxVRSxOby5WV1ZlcnRleD1TbztjbGFzcyB3b3tjb25zdHJ1Y3Rvcigpe3dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lucHV0R2VvbT1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IHdvKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1zZXRFbnN1cmVWYWxpZCh0KXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuX2lucHV0R2VvbS5jb3B5KCk6bmV3IENvKHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neSx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBzKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9fWNsYXNzIENvIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLENvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPWV9dHJhbnNmb3JtUG9seWdvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIGZ0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPW51bGw7cmV0dXJuIHM9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOk5vLnNpbXBsaWZ5KG4sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49ZSBpbnN0YW5jZW9mIGl0LHM9c3VwZXIudHJhbnNmb3JtTGluZWFyUmluZy5jYWxsKHRoaXMsdCxlKTtyZXR1cm4hbnx8cyBpbnN0YW5jZW9mIHV0P3M6bnVsbH19d28uVldUcmFuc2Zvcm1lcj1Dbzt2YXIgTG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRG91Z2xhc1BldWNrZXJTaW1wbGlmaWVyOmhvLFRvcG9sb2d5UHJlc2VydmluZ1NpbXBsaWZpZXI6eG8sVldTaW1wbGlmaWVyOndvfSk7Y2xhc3MgVG97Y29uc3RydWN0b3IoKXtUby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zZWc9bnVsbCx0aGlzLl9zZWdMZW49bnVsbCx0aGlzLl9zcGxpdFB0PW51bGwsdGhpcy5fbWluaW11bUxlbj0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NlZz10LHRoaXMuX3NlZ0xlbj10LmdldExlbmd0aCgpfXN0YXRpYyBwb2ludEFsb25nUmV2ZXJzZSh0LGUpe2NvbnN0IG49bmV3IG07cmV0dXJuIG4ueD10LnAxLngtZSoodC5wMS54LXQucDAueCksbi55PXQucDEueS1lKih0LnAxLnktdC5wMC55KSxufXNwbGl0QXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLl9taW5pbXVtTGVuL3RoaXMuX3NlZ0xlbjtpZih0LmRpc3RhbmNlKHRoaXMuX3NlZy5wMCk8dGhpcy5fbWluaW11bUxlbilyZXR1cm4gdGhpcy5fc3BsaXRQdD10aGlzLl9zZWcucG9pbnRBbG9uZyhlKSxudWxsO2lmKHQuZGlzdGFuY2UodGhpcy5fc2VnLnAxKTx0aGlzLl9taW5pbXVtTGVuKXJldHVybiB0aGlzLl9zcGxpdFB0PVRvLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuX3NlZyxlKSxudWxsO3RoaXMuX3NwbGl0UHQ9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuZ2V0Q29uc3RyYWluZWRMZW5ndGgodCkvdGhpcy5fc2VnTGVuO2UuZXF1YWxzMkQodGhpcy5fc2VnLnAwKT90aGlzLl9zcGxpdFB0PXRoaXMuX3NlZy5wb2ludEFsb25nKG4pOnRoaXMuX3NwbGl0UHQ9VG8ucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5fc2VnLG4pfX1zZXRNaW5pbXVtTGVuZ3RoKHQpe3RoaXMuX21pbmltdW1MZW49dH1nZXRDb25zdHJhaW5lZExlbmd0aCh0KXtyZXR1cm4gdDx0aGlzLl9taW5pbXVtTGVuP3RoaXMuX21pbmltdW1MZW46dH1nZXRTcGxpdFBvaW50KCl7cmV0dXJuIHRoaXMuX3NwbGl0UHR9fWNsYXNzIFJve2ZpbmRTcGxpdFBvaW50KHQsZSl7fX1jbGFzcyBQb3tzdGF0aWMgcHJvamVjdGVkU3BsaXRQb2ludCh0LGUpe3JldHVybiB0LmdldExpbmVTZWdtZW50KCkucHJvamVjdChlKX1maW5kU3BsaXRQb2ludCh0LGUpe2NvbnN0IG49dC5nZXRMaW5lU2VnbWVudCgpLHM9bi5nZXRMZW5ndGgoKS8yLGk9bmV3IFRvKG4pLHI9UG8ucHJvamVjdGVkU3BsaXRQb2ludCh0LGUpO2xldCBvPTIqci5kaXN0YW5jZShlKSouODtyZXR1cm4gbz5zJiYobz1zKSxpLnNldE1pbmltdW1MZW5ndGgobyksaS5zcGxpdEF0KHIpLGkuZ2V0U3BsaXRQb2ludCgpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltSb119fWNsYXNzIE9ve3N0YXRpYyB0cmlBcmVhKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShlLnktdC55KSoobi54LXQueCl9c3RhdGljIGlzSW5DaXJjbGVERE5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT1ELnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qocy54KSxyPUQudmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChzLnkpLG89RC52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHMueCksbD1ELnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3Qocy55KSxhPUQudmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdChzLngpLGM9RC52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHMueSksaD1pLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChvLm11bHRpcGx5KHIpKSx1PW8ubXVsdGlwbHkoYykuc2VsZlN1YnRyYWN0KGEubXVsdGlwbHkobCkpLGc9YS5tdWx0aXBseShyKS5zZWxmU3VidHJhY3QoaS5tdWx0aXBseShjKSksZD1pLm11bHRpcGx5KGkpLnNlbGZBZGQoci5tdWx0aXBseShyKSksXz1vLm11bHRpcGx5KG8pLnNlbGZBZGQobC5tdWx0aXBseShsKSkscD1hLm11bHRpcGx5KGEpLnNlbGZBZGQoYy5tdWx0aXBseShjKSk7cmV0dXJuIGQuc2VsZk11bHRpcGx5KHUpLnNlbGZBZGQoXy5zZWxmTXVsdGlwbHkoZykpLnNlbGZBZGQocC5zZWxmTXVsdGlwbHkoaCkpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgY2hlY2tSb2J1c3RJbkNpcmNsZSh0LGUsbixzKXtjb25zdCBpPU9vLmlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4scykscj1Pby5pc0luQ2lyY2xlRERTbG93KHQsZSxuLHMpLG89T28uaXNJbkNpcmNsZUNDKHQsZSxuLHMpLGw9bmUuY2lyY3VtY2VudHJlKHQsZSxuKTtCLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS10LmRpc3RhbmNlKGwpKS90LmRpc3RhbmNlKGwpKSxpPT09ciYmaT09PW98fChCLm91dC5wcmludGxuKFwiaW5DaXJjbGUgcm9idXN0bmVzcyBmYWlsdXJlIChkb3VibGUgcmVzdWx0ID0gXCIraStcIiwgREQgcmVzdWx0ID0gXCIrcitcIiwgQ0MgcmVzdWx0ID0gXCIrbytcIilcIiksQi5vdXQucHJpbnRsbihXdC50b0xpbmVTdHJpbmcobmV3IHB0KFt0LGUsbixzXSkpKSxCLm91dC5wcmludGxuKFwiQ2lyY3VtY2VudHJlID0gXCIrV3QudG9Qb2ludChsKStcIiByYWRpdXMgPSBcIit0LmRpc3RhbmNlKGwpKSxCLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS90LmRpc3RhbmNlKGwpLTEpKSxCLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBiID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9lLmRpc3RhbmNlKGwpLTEpKSxCLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBjID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9uLmRpc3RhbmNlKGwpLTEpKSxCLm91dC5wcmludGxuKCkpfXN0YXRpYyBpc0luQ2lyY2xlRERGYXN0KHQsZSxuLHMpe2NvbnN0IGk9RC5zcXIodC54KS5zZWxmQWRkKEQuc3FyKHQueSkpLnNlbGZNdWx0aXBseShPby50cmlBcmVhRERGYXN0KGUsbixzKSkscj1ELnNxcihlLngpLnNlbGZBZGQoRC5zcXIoZS55KSkuc2VsZk11bHRpcGx5KE9vLnRyaUFyZWFEREZhc3QodCxuLHMpKSxvPUQuc3FyKG4ueCkuc2VsZkFkZChELnNxcihuLnkpKS5zZWxmTXVsdGlwbHkoT28udHJpQXJlYURERmFzdCh0LGUscykpLGw9RC5zcXIocy54KS5zZWxmQWRkKEQuc3FyKHMueSkpLnNlbGZNdWx0aXBseShPby50cmlBcmVhRERGYXN0KHQsZSxuKSk7cmV0dXJuIGkuc2VsZlN1YnRyYWN0KHIpLnNlbGZBZGQobykuc2VsZlN1YnRyYWN0KGwpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZUNDKHQsZSxuLHMpe2NvbnN0IGk9bmUuY2lyY3VtY2VudHJlKHQsZSxuKSxyPXQuZGlzdGFuY2UoaSk7cmV0dXJuIHMuZGlzdGFuY2UoaSktcjw9MH1zdGF0aWMgaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT10Lngtcy54LHI9dC55LXMueSxvPWUueC1zLngsbD1lLnktcy55LGE9bi54LXMueCxjPW4ueS1zLnk7cmV0dXJuKGkqaStyKnIpKihvKmMtYSpsKSsobypvK2wqbCkqKGEqci1pKmMpKyhhKmErYypjKSooaSpsLW8qcik+MH1zdGF0aWMgaXNJbkNpcmNsZUREU2xvdyh0LGUsbixzKXtjb25zdCBpPUQudmFsdWVPZihzLngpLHI9RC52YWx1ZU9mKHMueSksbz1ELnZhbHVlT2YodC54KSxsPUQudmFsdWVPZih0LnkpLGE9RC52YWx1ZU9mKGUueCksYz1ELnZhbHVlT2YoZS55KSxoPUQudmFsdWVPZihuLngpLHU9RC52YWx1ZU9mKG4ueSksZz1vLm11bHRpcGx5KG8pLmFkZChsLm11bHRpcGx5KGwpKS5tdWx0aXBseShPby50cmlBcmVhRERTbG93KGEsYyxoLHUsaSxyKSksZD1hLm11bHRpcGx5KGEpLmFkZChjLm11bHRpcGx5KGMpKS5tdWx0aXBseShPby50cmlBcmVhRERTbG93KG8sbCxoLHUsaSxyKSksXz1oLm11bHRpcGx5KGgpLmFkZCh1Lm11bHRpcGx5KHUpKS5tdWx0aXBseShPby50cmlBcmVhRERTbG93KG8sbCxhLGMsaSxyKSkscD1pLm11bHRpcGx5KGkpLmFkZChyLm11bHRpcGx5KHIpKS5tdWx0aXBseShPby50cmlBcmVhRERTbG93KG8sbCxhLGMsaCx1KSk7cmV0dXJuIGcuc3VidHJhY3QoZCkuYWRkKF8pLnN1YnRyYWN0KHApLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixzKXtyZXR1cm4odC54KnQueCt0LnkqdC55KSpPby50cmlBcmVhKGUsbixzKS0oZS54KmUueCtlLnkqZS55KSpPby50cmlBcmVhKHQsbixzKSsobi54Km4ueCtuLnkqbi55KSpPby50cmlBcmVhKHQsZSxzKS0ocy54KnMueCtzLnkqcy55KSpPby50cmlBcmVhKHQsZSxuKT4wfXN0YXRpYyBpc0luQ2lyY2xlUm9idXN0KHQsZSxuLHMpe3JldHVybiBPby5pc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixzKX1zdGF0aWMgdHJpQXJlYUREU2xvdyh0LGUsbixzLGkscil7cmV0dXJuIG4uc3VidHJhY3QodCkubXVsdGlwbHkoci5zdWJ0cmFjdChlKSkuc3VidHJhY3Qocy5zdWJ0cmFjdChlKS5tdWx0aXBseShpLnN1YnRyYWN0KHQpKSl9c3RhdGljIHRyaUFyZWFEREZhc3QodCxlLG4pe2NvbnN0IHM9RC52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KEQudmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxpPUQudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShELnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QodC54KSk7cmV0dXJuIHMuc2VsZlN1YnRyYWN0KGkpfX1jbGFzcyB2b3tjb25zdHJ1Y3Rvcigpe3ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3A9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcD1uZXcgbSh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9wPW5ldyBtKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcD1uZXcgbSh0LGUsbil9fXN0YXRpYyBpbnRlcnBvbGF0ZVooKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmRpc3RhbmNlKG4pLGk9dC5kaXN0YW5jZShlKSxyPW4uZ2V0WigpLWUuZ2V0WigpO3JldHVybiBlLmdldFooKStyKihpL3MpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWUueCxyPWUueSxvPW4ueC1pLGw9cy54LWksYT1uLnktcixjPXMueS1yLGg9bypjLWwqYSx1PXQueC1pLGc9dC55LXIsZD0oYyp1LWwqZykvaCxfPSgtYSp1K28qZykvaDtyZXR1cm4gZS5nZXRaKCkrZCoobi5nZXRaKCktZS5nZXRaKCkpK18qKHMuZ2V0WigpLWUuZ2V0WigpKX19Y2lyY2xlQ2VudGVyKHQsZSl7Y29uc3Qgbj1uZXcgdm8odGhpcy5nZXRYKCksdGhpcy5nZXRZKCkpLHM9dGhpcy5iaXNlY3RvcihuLHQpLGk9dGhpcy5iaXNlY3Rvcih0LGUpLHI9bmV3IGVlKHMsaSk7bGV0IG89bnVsbDt0cnl7bz1uZXcgdm8oci5nZXRYKCksci5nZXRZKCkpfWNhdGNoKHMpe2lmKCEocyBpbnN0YW5jZW9mIHRlKSl0aHJvdyBzO0IuZXJyLnByaW50bG4oXCJhOiBcIituK1wiICBiOiBcIit0K1wiICBjOiBcIitlKSxCLmVyci5wcmludGxuKHMpfXJldHVybiBvfWRvdCh0KXtyZXR1cm4gdGhpcy5fcC54KnQuZ2V0WCgpK3RoaXMuX3AueSp0LmdldFkoKX1tYWduKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLl9wLngqdGhpcy5fcC54K3RoaXMuX3AueSp0aGlzLl9wLnkpfWdldFooKXtyZXR1cm4gdGhpcy5fcC5nZXRaKCl9YmlzZWN0b3IodCxlKXtjb25zdCBuPWUuZ2V0WCgpLXQuZ2V0WCgpLHM9ZS5nZXRZKCktdC5nZXRZKCksaT1uZXcgZWUodC5nZXRYKCkrbi8yLHQuZ2V0WSgpK3MvMiwxKSxyPW5ldyBlZSh0LmdldFgoKS1zK24vMix0LmdldFkoKStuK3MvMiwxKTtyZXR1cm4gbmV3IGVlKGkscil9ZXF1YWxzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9wLng9PT10LmdldFgoKSYmdGhpcy5fcC55PT09dC5nZXRZKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9wLmRpc3RhbmNlKHQuZ2V0Q29vcmRpbmF0ZSgpKTxlfX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B9aXNJbkNpcmNsZSh0LGUsbil7cmV0dXJuIE9vLmlzSW5DaXJjbGVSb2J1c3QodC5fcCxlLl9wLG4uX3AsdGhpcy5fcCl9aW50ZXJwb2xhdGVaVmFsdWUodCxlLG4pe2NvbnN0IHM9dC5nZXRYKCksaT10LmdldFkoKSxyPWUuZ2V0WCgpLXMsbz1uLmdldFgoKS1zLGw9ZS5nZXRZKCktaSxhPW4uZ2V0WSgpLWksYz1yKmEtbypsLGg9dGhpcy5nZXRYKCktcyx1PXRoaXMuZ2V0WSgpLWksZz0oYSpoLW8qdSkvYyxkPSgtbCpoK3IqdSkvYztyZXR1cm4gdC5nZXRaKCkrZyooZS5nZXRaKCktdC5nZXRaKCkpK2QqKG4uZ2V0WigpLXQuZ2V0WigpKX1taWRQb2ludCh0KXtjb25zdCBlPSh0aGlzLl9wLngrdC5nZXRYKCkpLzIsbj0odGhpcy5fcC55K3QuZ2V0WSgpKS8yLHM9KHRoaXMuX3AuZ2V0WigpK3QuZ2V0WigpKS8yO3JldHVybiBuZXcgdm8oZSxuLHMpfXJpZ2h0T2YodCl7cmV0dXJuIHRoaXMuaXNDQ1codC5kZXN0KCksdC5vcmlnKCkpfWlzQ0NXKHQsZSl7cmV0dXJuKHQuX3AueC10aGlzLl9wLngpKihlLl9wLnktdGhpcy5fcC55KS0odC5fcC55LXRoaXMuX3AueSkqKGUuX3AueC10aGlzLl9wLngpPjB9Z2V0WCgpe3JldHVybiB0aGlzLl9wLnh9Y3Jvc3NQcm9kdWN0KHQpe3JldHVybiB0aGlzLl9wLngqdC5nZXRZKCktdGhpcy5fcC55KnQuZ2V0WCgpfXNldFoodCl7dGhpcy5fcC5zZXRaKHQpfXRpbWVzKHQpe3JldHVybiBuZXcgdm8odCp0aGlzLl9wLngsdCp0aGlzLl9wLnkpfWNyb3NzKCl7cmV0dXJuIG5ldyB2byh0aGlzLl9wLnksLXRoaXMuX3AueCl9bGVmdE9mKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQub3JpZygpLHQuZGVzdCgpKX10b1N0cmluZygpe3JldHVyblwiUE9JTlQgKFwiK3RoaXMuX3AueCtcIiBcIit0aGlzLl9wLnkrXCIpXCJ9c3ViKHQpe3JldHVybiBuZXcgdm8odGhpcy5fcC54LXQuZ2V0WCgpLHRoaXMuX3AueS10LmdldFkoKSl9Z2V0WSgpe3JldHVybiB0aGlzLl9wLnl9Y2xhc3NpZnkodCxlKXtjb25zdCBuPXRoaXMscz1lLnN1Yih0KSxpPW4uc3ViKHQpLHI9cy5jcm9zc1Byb2R1Y3QoaSk7cmV0dXJuIHI+MD92by5MRUZUOnI8MD92by5SSUdIVDpzLmdldFgoKSppLmdldFgoKTwwfHxzLmdldFkoKSppLmdldFkoKTwwP3ZvLkJFSElORDpzLm1hZ24oKTxpLm1hZ24oKT92by5CRVlPTkQ6dC5lcXVhbHMobik/dm8uT1JJR0lOOmUuZXF1YWxzKG4pP3ZvLkRFU1RJTkFUSU9OOnZvLkJFVFdFRU59c3VtKHQpe3JldHVybiBuZXcgdm8odGhpcy5fcC54K3QuZ2V0WCgpLHRoaXMuX3AueSt0LmdldFkoKSl9ZGlzdGFuY2UodCxlKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGUuZ2V0WCgpLXQuZ2V0WCgpLDIpK01hdGgucG93KGUuZ2V0WSgpLXQuZ2V0WSgpLDIpKX1jaXJjdW1SYWRpdXNSYXRpbyh0LGUpe2NvbnN0IG49dGhpcy5jaXJjbGVDZW50ZXIodCxlKSxzPXRoaXMuZGlzdGFuY2Uobix0KTtsZXQgaT10aGlzLmRpc3RhbmNlKHRoaXMsdCkscj10aGlzLmRpc3RhbmNlKHQsZSk7cmV0dXJuIHI8aSYmKGk9cikscj10aGlzLmRpc3RhbmNlKGUsdGhpcykscjxpJiYoaT1yKSxzL2l9fXZvLkxFRlQ9MCx2by5SSUdIVD0xLHZvLkJFWU9ORD0yLHZvLkJFSElORD0zLHZvLkJFVFdFRU49NCx2by5PUklHSU49NSx2by5ERVNUSU5BVElPTj02O2NsYXNzIE1vIGV4dGVuZHMgdm97Y29uc3RydWN0b3IoKXtzdXBlcigpLE1vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX2lzT25Db25zdHJhaW50PW51bGwsdGhpcy5fY29uc3RyYWludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3ZvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9Z2V0Q29uc3RyYWludCgpe3JldHVybiB0aGlzLl9jb25zdHJhaW50fXNldE9uQ29uc3RyYWludCh0KXt0aGlzLl9pc09uQ29uc3RyYWludD10fW1lcmdlKHQpe3QuX2lzT25Db25zdHJhaW50JiYodGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5fY29uc3RyYWludD10Ll9jb25zdHJhaW50KX1pc09uQ29uc3RyYWludCgpe3JldHVybiB0aGlzLl9pc09uQ29uc3RyYWludH1zZXRDb25zdHJhaW50KHQpe3RoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuX2NvbnN0cmFpbnQ9dH19Y2xhc3MgYm97Y29uc3RydWN0b3IoKXtiby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9yb3Q9bnVsbCx0aGlzLl92ZXJ0ZXg9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fZGF0YT1udWxsfXN0YXRpYyBtYWtlRWRnZSh0LGUpe2NvbnN0IG49bmV3IGJvLHM9bmV3IGJvLGk9bmV3IGJvLHI9bmV3IGJvO24uX3JvdD1zLHMuX3JvdD1pLGkuX3JvdD1yLHIuX3JvdD1uLG4uc2V0TmV4dChuKSxzLnNldE5leHQociksaS5zZXROZXh0KGkpLHIuc2V0TmV4dChzKTtjb25zdCBvPW47cmV0dXJuIG8uc2V0T3JpZyh0KSxvLnNldERlc3QoZSksb31zdGF0aWMgc3dhcCh0KXtjb25zdCBlPXQub1ByZXYoKSxuPXQuc3ltKCkub1ByZXYoKTtiby5zcGxpY2UodCxlKSxiby5zcGxpY2UodC5zeW0oKSxuKSxiby5zcGxpY2UodCxlLmxOZXh0KCkpLGJvLnNwbGljZSh0LnN5bSgpLG4ubE5leHQoKSksdC5zZXRPcmlnKGUuZGVzdCgpKSx0LnNldERlc3Qobi5kZXN0KCkpfXN0YXRpYyBzcGxpY2UodCxlKXtjb25zdCBuPXQub05leHQoKS5yb3QoKSxzPWUub05leHQoKS5yb3QoKSxpPWUub05leHQoKSxyPXQub05leHQoKSxvPXMub05leHQoKSxsPW4ub05leHQoKTt0LnNldE5leHQoaSksZS5zZXROZXh0KHIpLG4uc2V0TmV4dChvKSxzLnNldE5leHQobCl9c3RhdGljIGNvbm5lY3QodCxlKXtjb25zdCBuPWJvLm1ha2VFZGdlKHQuZGVzdCgpLGUub3JpZygpKTtyZXR1cm4gYm8uc3BsaWNlKG4sdC5sTmV4dCgpKSxiby5zcGxpY2Uobi5zeW0oKSxlKSxufWVxdWFsc05vbk9yaWVudGVkKHQpe3JldHVybiEhdGhpcy5lcXVhbHNPcmllbnRlZCh0KXx8ISF0aGlzLmVxdWFsc09yaWVudGVkKHQuc3ltKCkpfXRvTGluZVNlZ21lbnQoKXtyZXR1cm4gbmV3IEt0KHRoaXMuX3ZlcnRleC5nZXRDb29yZGluYXRlKCksdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX1kZXN0KCl7cmV0dXJuIHRoaXMuc3ltKCkub3JpZygpfW9OZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9ZXF1YWxzT3JpZW50ZWQodCl7cmV0dXJuISghdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSl8fCF0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKSl9ZE5leHQoKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpLnN5bSgpfWxQcmV2KCl7cmV0dXJuIHRoaXMuX25leHQuc3ltKCl9clByZXYoKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpfXJvdCgpe3JldHVybiB0aGlzLl9yb3R9b1ByZXYoKXtyZXR1cm4gdGhpcy5fcm90Ll9uZXh0Ll9yb3R9c3ltKCl7cmV0dXJuIHRoaXMuX3JvdC5fcm90fXNldE9yaWcodCl7dGhpcy5fdmVydGV4PXR9bE5leHQoKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLnJvdCgpfWdldExlbmd0aCgpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UodGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX1pbnZSb3QoKXtyZXR1cm4gdGhpcy5fcm90LnN5bSgpfXNldERlc3QodCl7dGhpcy5zeW0oKS5zZXRPcmlnKHQpfXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1kZWxldGUoKXt0aGlzLl9yb3Q9bnVsbH1vcmlnKCl7cmV0dXJuIHRoaXMuX3ZlcnRleH1yTmV4dCgpe3JldHVybiB0aGlzLl9yb3QuX25leHQuaW52Um90KCl9dG9TdHJpbmcoKXtjb25zdCB0PXRoaXMuX3ZlcnRleC5nZXRDb29yZGluYXRlKCksZT10aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCk7cmV0dXJuIFd0LnRvTGluZVN0cmluZyh0LGUpfWlzTGl2ZSgpe3JldHVybiBudWxsIT09dGhpcy5fcm90fWdldFByaW1hcnkoKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpPD0wP3RoaXM6dGhpcy5zeW0oKX1kUHJldigpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkuaW52Um90KCl9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9fWNsYXNzIERve2NvbnN0cnVjdG9yKCl7RG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3ViZGl2PW51bGwsdGhpcy5faXNVc2luZ1RvbGVyYW5jZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJkaXY9dCx0aGlzLl9pc1VzaW5nVG9sZXJhbmNlPXQuZ2V0VG9sZXJhbmNlKCk+MH1pbnNlcnRTaXRlKHQpe2xldCBlPXRoaXMuX3N1YmRpdi5sb2NhdGUodCk7aWYodGhpcy5fc3ViZGl2LmlzVmVydGV4T2ZFZGdlKGUsdCkpcmV0dXJuIGU7dGhpcy5fc3ViZGl2LmlzT25FZGdlKGUsdC5nZXRDb29yZGluYXRlKCkpJiYoZT1lLm9QcmV2KCksdGhpcy5fc3ViZGl2LmRlbGV0ZShlLm9OZXh0KCkpKTtsZXQgbj10aGlzLl9zdWJkaXYubWFrZUVkZ2UoZS5vcmlnKCksdCk7Ym8uc3BsaWNlKG4sZSk7Y29uc3Qgcz1uO2Rve249dGhpcy5fc3ViZGl2LmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKX13aGlsZShlLmxOZXh0KCkhPT1zKTtmb3IoOzspe2NvbnN0IGk9ZS5vUHJldigpO2lmKGkuZGVzdCgpLnJpZ2h0T2YoZSkmJnQuaXNJbkNpcmNsZShlLm9yaWcoKSxpLmRlc3QoKSxlLmRlc3QoKSkpYm8uc3dhcChlKSxlPWUub1ByZXYoKTtlbHNle2lmKGUub05leHQoKT09PXMpcmV0dXJuIG47ZT1lLm9OZXh0KCkubFByZXYoKX19fWluc2VydFNpdGVzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZSh0KX19fWNsYXNzIEFve2xvY2F0ZSh0KXt9fWNsYXNzIEZve2NvbnN0cnVjdG9yKCl7Rm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fbGFzdEVkZ2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJkaXY9dCx0aGlzLmluaXQoKX1pbml0KCl7dGhpcy5fbGFzdEVkZ2U9dGhpcy5maW5kRWRnZSgpfWxvY2F0ZSh0KXt0aGlzLl9sYXN0RWRnZS5pc0xpdmUoKXx8dGhpcy5pbml0KCk7Y29uc3QgZT10aGlzLl9zdWJkaXYubG9jYXRlRnJvbUVkZ2UodCx0aGlzLl9sYXN0RWRnZSk7cmV0dXJuIHRoaXMuX2xhc3RFZGdlPWUsZX1maW5kRWRnZSgpe3JldHVybiB0aGlzLl9zdWJkaXYuZ2V0RWRnZXMoKS5pdGVyYXRvcigpLm5leHQoKX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQW9dfX1jbGFzcyBHbyBleHRlbmRzIGh7Y29uc3RydWN0b3IoKXtzdXBlcigpLEdvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3NlZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsXCJMb2NhdGUgZmFpbGVkIHRvIGNvbnZlcmdlIChhdCBlZGdlOiBcIit0K1wiKS4gIFBvc3NpYmxlIGNhdXNlcyBpbmNsdWRlIGludmFsaWQgU3ViZGl2aXNpb24gdG9wb2xvZ3kgb3IgdmVyeSBjbG9zZSBzaXRlc1wiKSx0aGlzLl9zZWc9bmV3IEt0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsR28ubXNnV2l0aFNwYXRpYWwodCxlKSksdGhpcy5fc2VnPW5ldyBLdChlKX19c3RhdGljIG1zZ1dpdGhTcGF0aWFsKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitlK1wiIF1cIjp0fWdldFNlZ21lbnQoKXtyZXR1cm4gdGhpcy5fc2VnfX1jbGFzcyBxb3t2aXNpdCh0KXt9fWNsYXNzIEJve2NvbnN0cnVjdG9yKCl7Qm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fdmlzaXRlZEtleT0wLHRoaXMuX3F1YWRFZGdlcz1uZXcgTCx0aGlzLl9zdGFydGluZ0VkZ2U9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbCx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9mcmFtZVZlcnRleD1uZXcgQXJyYXkoMykuZmlsbChudWxsKSx0aGlzLl9mcmFtZUVudj1udWxsLHRoaXMuX2xvY2F0b3I9bnVsbCx0aGlzLl9zZWc9bmV3IEt0LHRoaXMuX3RyaUVkZ2VzPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3RvbGVyYW5jZT1lLHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1lL0JvLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUix0aGlzLmNyZWF0ZUZyYW1lKHQpLHRoaXMuX3N0YXJ0aW5nRWRnZT10aGlzLmluaXRTdWJkaXYoKSx0aGlzLl9sb2NhdG9yPW5ldyBGbyh0aGlzKX1zdGF0aWMgZ2V0VHJpYW5nbGVFZGdlcyh0LGUpe2lmKGVbMF09dCxlWzFdPWVbMF0ubE5leHQoKSxlWzJdPWVbMV0ubE5leHQoKSxlWzJdLmxOZXh0KCkhPT1lWzBdKXRocm93IG5ldyBzKFwiRWRnZXMgZG8gbm90IGZvcm0gYSB0cmlhbmdsZVwiKX1nZXRUcmlhbmdsZVZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IHpvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZVZlcnRpY2VzKCl9aXNGcmFtZVZlcnRleCh0KXtyZXR1cm4hIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzBdKXx8KCEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMV0pfHwhIXQuZXF1YWxzKHRoaXMuX2ZyYW1lVmVydGV4WzJdKSl9aXNWZXJ0ZXhPZkVkZ2UodCxlKXtyZXR1cm4hKCFlLmVxdWFscyh0Lm9yaWcoKSx0aGlzLl90b2xlcmFuY2UpJiYhZS5lcXVhbHModC5kZXN0KCksdGhpcy5fdG9sZXJhbmNlKSl9Y29ubmVjdCh0LGUpe2NvbnN0IG49Ym8uY29ubmVjdCh0LGUpO3JldHVybiB0aGlzLl9xdWFkRWRnZXMuYWRkKG4pLG59Z2V0Vm9yb25vaUNlbGxQb2x5Z29uKHQsZSl7Y29uc3Qgbj1uZXcgTCxzPXQ7ZG97Y29uc3QgZT10LnJvdCgpLm9yaWcoKS5nZXRDb29yZGluYXRlKCk7bi5hZGQoZSksdD10Lm9QcmV2KCl9d2hpbGUodCE9PXMpO2NvbnN0IGk9bmV3IFI7aS5hZGRBbGwobiwhMSksaS5jbG9zZVJpbmcoKSxpLnNpemUoKTw0JiYoQi5vdXQucHJpbnRsbihpKSxpLmFkZChpLmdldChpLnNpemUoKS0xKSwhMCkpO2NvbnN0IHI9aS50b0Nvb3JkaW5hdGVBcnJheSgpLG89ZS5jcmVhdGVQb2x5Z29uKGUuY3JlYXRlTGluZWFyUmluZyhyKSksbD1zLm9yaWcoKTtyZXR1cm4gby5zZXRVc2VyRGF0YShsLmdldENvb3JkaW5hdGUoKSksb31zZXRMb2NhdG9yKHQpe3RoaXMuX2xvY2F0b3I9dH1pbml0U3ViZGl2KCl7Y29uc3QgdD10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzBdLHRoaXMuX2ZyYW1lVmVydGV4WzFdKSxlPXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMV0sdGhpcy5fZnJhbWVWZXJ0ZXhbMl0pO2JvLnNwbGljZSh0LnN5bSgpLGUpO2NvbnN0IG49dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFsyXSx0aGlzLl9mcmFtZVZlcnRleFswXSk7cmV0dXJuIGJvLnNwbGljZShlLnN5bSgpLG4pLGJvLnNwbGljZShuLnN5bSgpLHQpLHR9aXNGcmFtZUJvcmRlckVkZ2UodCl7Y29uc3QgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtCby5nZXRUcmlhbmdsZUVkZ2VzKHQsZSk7Y29uc3Qgbj1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtCby5nZXRUcmlhbmdsZUVkZ2VzKHQuc3ltKCksbik7Y29uc3Qgcz10LmxOZXh0KCkuZGVzdCgpO2lmKHRoaXMuaXNGcmFtZVZlcnRleChzKSlyZXR1cm4hMDtjb25zdCBpPXQuc3ltKCkubE5leHQoKS5kZXN0KCk7cmV0dXJuISF0aGlzLmlzRnJhbWVWZXJ0ZXgoaSl9bWFrZUVkZ2UodCxlKXtjb25zdCBuPWJvLm1ha2VFZGdlKHQsZSk7cmV0dXJuIHRoaXMuX3F1YWRFZGdlcy5hZGQobiksbn12aXNpdFRyaWFuZ2xlcyh0LGUpe3RoaXMuX3Zpc2l0ZWRLZXkrKztjb25zdCBuPW5ldyBlbjtuLnB1c2godGhpcy5fc3RhcnRpbmdFZGdlKTtjb25zdCBzPW5ldyB4dDtmb3IoOyFuLmVtcHR5KCk7KXtjb25zdCBpPW4ucG9wKCk7aWYoIXMuY29udGFpbnMoaSkpe2NvbnN0IHI9dGhpcy5mZXRjaFRyaWFuZ2xlVG9WaXNpdChpLG4sZSxzKTtudWxsIT09ciYmdC52aXNpdChyKX19fWlzRnJhbWVFZGdlKHQpe3JldHVybiEoIXRoaXMuaXNGcmFtZVZlcnRleCh0Lm9yaWcoKSkmJiF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5kZXN0KCkpKX1pc09uRWRnZSh0LGUpe3RoaXMuX3NlZy5zZXRDb29yZGluYXRlcyh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCksdC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTtyZXR1cm4gdGhpcy5fc2VnLmRpc3RhbmNlKGUpPHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZX1nZXRFbnZlbG9wZSgpe3JldHVybiBuZXcgTyh0aGlzLl9mcmFtZUVudil9Y3JlYXRlRnJhbWUodCl7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpO2xldCBzPTA7cz1lPm4/MTAqZToxMCpuLHRoaXMuX2ZyYW1lVmVydGV4WzBdPW5ldyB2bygodC5nZXRNYXhYKCkrdC5nZXRNaW5YKCkpLzIsdC5nZXRNYXhZKCkrcyksdGhpcy5fZnJhbWVWZXJ0ZXhbMV09bmV3IHZvKHQuZ2V0TWluWCgpLXMsdC5nZXRNaW5ZKCktcyksdGhpcy5fZnJhbWVWZXJ0ZXhbMl09bmV3IHZvKHQuZ2V0TWF4WCgpK3MsdC5nZXRNaW5ZKCktcyksdGhpcy5fZnJhbWVFbnY9bmV3IE8odGhpcy5fZnJhbWVWZXJ0ZXhbMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX2ZyYW1lVmVydGV4WzFdLmdldENvb3JkaW5hdGUoKSksdGhpcy5fZnJhbWVFbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2ZyYW1lVmVydGV4WzJdLmdldENvb3JkaW5hdGUoKSl9Z2V0VHJpYW5nbGVDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBrbztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVzKCl9Z2V0VmVydGljZXModCl7Y29uc3QgZT1uZXcgeHQ7Zm9yKGxldCBuPXRoaXMuX3F1YWRFZGdlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMub3JpZygpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgoaSl8fGUuYWRkKGkpO2NvbnN0IHI9cy5kZXN0KCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQocil9cmV0dXJuIGV9ZmV0Y2hUcmlhbmdsZVRvVmlzaXQodCxlLG4scyl7bGV0IGk9dCxyPTAsbz0hMTtkb3t0aGlzLl90cmlFZGdlc1tyXT1pLHRoaXMuaXNGcmFtZUVkZ2UoaSkmJihvPSEwKTtjb25zdCB0PWkuc3ltKCk7cy5jb250YWlucyh0KXx8ZS5wdXNoKHQpLHMuYWRkKGkpLHIrKyxpPWkubE5leHQoKX13aGlsZShpIT09dCk7cmV0dXJuIG8mJiFuP251bGw6dGhpcy5fdHJpRWRnZXN9Z2V0RWRnZXMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0UHJpbWFyeUVkZ2VzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZUxpbmVTdHJpbmcoW2Uub3JpZygpLmdldENvb3JkaW5hdGUoKSxlLmRlc3QoKS5nZXRDb29yZGluYXRlKCldKX1yZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9fWdldFZlcnRleFVuaXF1ZUVkZ2VzKHQpe2NvbnN0IGU9bmV3IEwsbj1uZXcgeHQ7Zm9yKGxldCBzPXRoaXMuX3F1YWRFZGdlcy5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKSxyPWkub3JpZygpO24uY29udGFpbnMocil8fChuLmFkZChyKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHIpfHxlLmFkZChpKSk7Y29uc3Qgbz1pLnN5bSgpLGw9by5vcmlnKCk7bi5jb250YWlucyhsKXx8KG4uYWRkKGwpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgobCl8fGUuYWRkKG8pKX1yZXR1cm4gZX1nZXRUcmlhbmdsZUVkZ2VzKHQpe2NvbnN0IGU9bmV3IFZvO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZUVkZ2VzKCl9Z2V0UHJpbWFyeUVkZ2VzKHQpe3RoaXMuX3Zpc2l0ZWRLZXkrKztjb25zdCBlPW5ldyBMLG49bmV3IGVuO24ucHVzaCh0aGlzLl9zdGFydGluZ0VkZ2UpO2NvbnN0IHM9bmV3IHh0O2Zvcig7IW4uZW1wdHkoKTspe2NvbnN0IGk9bi5wb3AoKTtpZighcy5jb250YWlucyhpKSl7Y29uc3Qgcj1pLmdldFByaW1hcnkoKTshdCYmdGhpcy5pc0ZyYW1lRWRnZShyKXx8ZS5hZGQociksbi5wdXNoKGkub05leHQoKSksbi5wdXNoKGkuc3ltKCkub05leHQoKSkscy5hZGQoaSkscy5hZGQoaS5zeW0oKSl9fXJldHVybiBlfWRlbGV0ZSh0KXtiby5zcGxpY2UodCx0Lm9QcmV2KCkpLGJvLnNwbGljZSh0LnN5bSgpLHQuc3ltKCkub1ByZXYoKSk7Y29uc3QgZT10LnN5bSgpLG49dC5yb3QoKSxzPXQucm90KCkuc3ltKCk7dGhpcy5fcXVhZEVkZ2VzLnJlbW92ZSh0KSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKGUpLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUobiksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShzKSx0LmRlbGV0ZSgpLGUuZGVsZXRlKCksbi5kZWxldGUoKSxzLmRlbGV0ZSgpfWxvY2F0ZUZyb21FZGdlKHQsZSl7bGV0IG49MDtjb25zdCBzPXRoaXMuX3F1YWRFZGdlcy5zaXplKCk7bGV0IGk9ZTtmb3IoOzspe2lmKG4rKyxuPnMpdGhyb3cgbmV3IEdvKGkudG9MaW5lU2VnbWVudCgpKTtpZih0LmVxdWFscyhpLm9yaWcoKSl8fHQuZXF1YWxzKGkuZGVzdCgpKSlicmVhaztpZih0LnJpZ2h0T2YoaSkpaT1pLnN5bSgpO2Vsc2UgaWYodC5yaWdodE9mKGkub05leHQoKSkpe2lmKHQucmlnaHRPZihpLmRQcmV2KCkpKWJyZWFrO2k9aS5kUHJldigpfWVsc2UgaT1pLm9OZXh0KCl9cmV0dXJuIGl9Z2V0VG9sZXJhbmNlKCl7cmV0dXJuIHRoaXMuX3RvbGVyYW5jZX1nZXRWb3Jvbm9pQ2VsbFBvbHlnb25zKHQpe3RoaXMudmlzaXRUcmlhbmdsZXMobmV3IFlvLCEwKTtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10aGlzLmdldFZlcnRleFVuaXF1ZUVkZ2VzKCExKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKTtlLmFkZCh0aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbihzLHQpKX1yZXR1cm4gZX1nZXRWb3Jvbm9pRGlhZ3JhbSh0KXtjb25zdCBlPXRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KTtyZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oQ3QudG9HZW9tZXRyeUFycmF5KGUpKX1nZXRUcmlhbmdsZXModCl7Y29uc3QgZT10aGlzLmdldFRyaWFuZ2xlQ29vcmRpbmF0ZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO2xldCBzPTA7Zm9yKGxldCBpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe2NvbnN0IGU9aS5uZXh0KCk7bltzKytdPXQuY3JlYXRlUG9seWdvbih0LmNyZWF0ZUxpbmVhclJpbmcoZSkpfXJldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX1pbnNlcnRTaXRlKHQpe2xldCBlPXRoaXMubG9jYXRlKHQpO2lmKHQuZXF1YWxzKGUub3JpZygpLHRoaXMuX3RvbGVyYW5jZSl8fHQuZXF1YWxzKGUuZGVzdCgpLHRoaXMuX3RvbGVyYW5jZSkpcmV0dXJuIGU7bGV0IG49dGhpcy5tYWtlRWRnZShlLm9yaWcoKSx0KTtiby5zcGxpY2UobixlKTtjb25zdCBzPW47ZG97bj10aGlzLmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKX13aGlsZShlLmxOZXh0KCkhPT1zKTtyZXR1cm4gc31sb2NhdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2byl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xvY2F0b3IubG9jYXRlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2xvY2F0b3IubG9jYXRlKG5ldyB2byh0KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbG9jYXRvci5sb2NhdGUobmV3IHZvKHQpKTtpZihudWxsPT09bilyZXR1cm4gbnVsbDtsZXQgcz1uO24uZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0KSYmKHM9bi5zeW0oKSk7bGV0IGk9cztkb3tpZihpLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQoZSkpcmV0dXJuIGk7aT1pLm9OZXh0KCl9d2hpbGUoaSE9PXMpO3JldHVybiBudWxsfX19Y2xhc3MgWW97dmlzaXQodCl7Y29uc3QgZT10WzBdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksbj10WzFdLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscz10WzJdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksaT1uZS5jaXJjdW1jZW50cmVERChlLG4scykscj1uZXcgdm8oaSk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl0W2VdLnJvdCgpLnNldE9yaWcocil9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3FvXX19Y2xhc3MgVm97Y29uc3RydWN0b3IoKXtWby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl90cmlMaXN0PW5ldyBMfWdldFRyaWFuZ2xlRWRnZXMoKXtyZXR1cm4gdGhpcy5fdHJpTGlzdH12aXNpdCh0KXt0aGlzLl90cmlMaXN0LmFkZCh0KX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcW9dfX1jbGFzcyB6b3tjb25zdHJ1Y3Rvcigpe3pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3RyaUxpc3Q9bmV3IEx9dmlzaXQodCl7dGhpcy5fdHJpTGlzdC5hZGQoW3RbMF0ub3JpZygpLHRbMV0ub3JpZygpLHRbMl0ub3JpZygpXSl9Z2V0VHJpYW5nbGVWZXJ0aWNlcygpe3JldHVybiB0aGlzLl90cmlMaXN0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltxb119fWNsYXNzIGtve2NvbnN0cnVjdG9yKCl7a28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fY29vcmRMaXN0PW5ldyBSLHRoaXMuX3RyaUNvb3Jkcz1uZXcgTH1jaGVja1RyaWFuZ2xlU2l6ZSh0KXtsZXQgZT1cIlwiO3QubGVuZ3RoPj0yP2U9V3QudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSk6dC5sZW5ndGg+PTEmJihlPVd0LnRvUG9pbnQodFswXSkpfXZpc2l0KHQpe3RoaXMuX2Nvb3JkTGlzdC5jbGVhcigpO2ZvcihsZXQgZT0wO2U8MztlKyspe2NvbnN0IG49dFtlXS5vcmlnKCk7dGhpcy5fY29vcmRMaXN0LmFkZChuLmdldENvb3JkaW5hdGUoKSl9aWYodGhpcy5fY29vcmRMaXN0LnNpemUoKT4wKXt0aGlzLl9jb29yZExpc3QuY2xvc2VSaW5nKCk7Y29uc3QgdD10aGlzLl9jb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtpZig0IT09dC5sZW5ndGgpcmV0dXJuIG51bGw7dGhpcy5fdHJpQ29vcmRzLmFkZCh0KX19Z2V0VHJpYW5nbGVzKCl7cmV0dXJuIHRoaXMuX3RyaUNvb3Jkc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcW9dfX1Cby5UcmlhbmdsZUNpcmN1bWNlbnRyZVZpc2l0b3I9WW8sQm8uVHJpYW5nbGVFZGdlc0xpc3RWaXNpdG9yPVZvLEJvLlRyaWFuZ2xlVmVydGV4TGlzdFZpc2l0b3I9em8sQm8uVHJpYW5nbGVDb29yZGluYXRlc1Zpc2l0b3I9a28sQm8uRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SPTFlMztjbGFzcyBYb3tjb25zdHJ1Y3Rvcigpe1hvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xzPW51bGwsdGhpcy5fZGF0YT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9scz1uZXcgS3QodCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9scz1uZXcgS3QodCxlKSx0aGlzLl9kYXRhPW59ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07WG8uY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgbSh0LGUsbiksbmV3IG0ocyxpLHIpKX1lbHNlIGlmKDc9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XSxvPWFyZ3VtZW50c1s2XTtYby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBtKHQsZSxuKSxuZXcgbShzLGksciksbyl9fWdldExpbmVTZWdtZW50KCl7cmV0dXJuIHRoaXMuX2xzfWdldEVuZFooKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKS5nZXRaKCl9Z2V0U3RhcnRaKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMCkuZ2V0WigpfWludGVyc2VjdGlvbih0KXtyZXR1cm4gdGhpcy5fbHMuaW50ZXJzZWN0aW9uKHQuZ2V0TGluZVNlZ21lbnQoKSl9Z2V0U3RhcnQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKX1nZXRFbmQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKX1nZXRFbmRZKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueX1nZXRTdGFydFgoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS54fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMuX2xzLmVxdWFsc1RvcG8odC5nZXRMaW5lU2VnbWVudCgpKX1nZXRTdGFydFkoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS55fXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1nZXRFbmRYKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueH10b1N0cmluZygpe3JldHVybiB0aGlzLl9scy50b1N0cmluZygpfX1jbGFzcyBVbyBleHRlbmRzIGh7Y29uc3RydWN0b3IoKXtzdXBlcigpLFVvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX3B0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2guY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtoLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsVW8ubXNnV2l0aENvb3JkKHQsZSkpLHRoaXMuX3B0PW5ldyBtKGUpfX1zdGF0aWMgbXNnV2l0aENvb3JkKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitXdC50b1BvaW50KGUpK1wiIF1cIjp0fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcHR9fWNsYXNzIEhve2NvbnN0cnVjdG9yKCl7SG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5faW5pdGlhbFZlcnRpY2VzPW51bGwsdGhpcy5fc2VnVmVydGljZXM9bnVsbCx0aGlzLl9zZWdtZW50cz1uZXcgTCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9pbmNEZWw9bnVsbCx0aGlzLl9jb252ZXhIdWxsPW51bGwsdGhpcy5fc3BsaXRGaW5kZXI9bmV3IFBvLHRoaXMuX2tkdD1udWxsLHRoaXMuX3ZlcnRleEZhY3Rvcnk9bnVsbCx0aGlzLl9jb21wdXRlQXJlYUVudj1udWxsLHRoaXMuX3NwbGl0UHQ9bnVsbCx0aGlzLl90b2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pbml0aWFsVmVydGljZXM9bmV3IEwodCksdGhpcy5fdG9sZXJhbmNlPWUsdGhpcy5fa2R0PW5ldyB1cyhlKX1zdGF0aWMgY29tcHV0ZVZlcnRleEVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE87Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUodC5nZXRDb29yZGluYXRlKCkpfXJldHVybiBlfWdldEluaXRpYWxWZXJ0aWNlcygpe3JldHVybiB0aGlzLl9pbml0aWFsVmVydGljZXN9Z2V0S0RUKCl7cmV0dXJuIHRoaXMuX2tkdH1lbmZvcmNlQ29uc3RyYWludHMoKXt0aGlzLmFkZENvbnN0cmFpbnRWZXJ0aWNlcygpO2xldCB0PTAsZT0wO2Rve2U9dGhpcy5lbmZvcmNlR2FicmllbCh0aGlzLl9zZWdtZW50cyksdCsrfXdoaWxlKGU+MCYmdDxIby5NQVhfU1BMSVRfSVRFUik7aWYodD09PUhvLk1BWF9TUExJVF9JVEVSKXRocm93IG5ldyBVbyhcIlRvbyBtYW55IHNwbGl0dGluZyBpdGVyYXRpb25zIHdoaWxlIGVuZm9yY2luZyBjb25zdHJhaW50cy4gIExhc3Qgc3BsaXQgcG9pbnQgd2FzIGF0OiBcIix0aGlzLl9zcGxpdFB0KX1pbnNlcnRTaXRlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUodCl9fWdldFZlcnRleEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fdmVydGV4RmFjdG9yeX1nZXRQb2ludEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5faW5pdGlhbFZlcnRpY2VzLnNpemUoKSt0aGlzLl9zZWdWZXJ0aWNlcy5zaXplKCkpLmZpbGwobnVsbCk7bGV0IGU9MDtmb3IobGV0IG49dGhpcy5faW5pdGlhbFZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3RbZSsrXT1zLmdldENvb3JkaW5hdGUoKX1mb3IobGV0IG49dGhpcy5fc2VnVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7dFtlKytdPXMuZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiB0fXNldENvbnN0cmFpbnRzKHQsZSl7dGhpcy5fc2VnbWVudHM9dCx0aGlzLl9zZWdWZXJ0aWNlcz1lfWNvbXB1dGVDb252ZXhIdWxsKCl7Y29uc3QgdD1uZXcgQ3QsZT10aGlzLmdldFBvaW50QXJyYXkoKSxuPW5ldyBzbihlLHQpO3RoaXMuX2NvbnZleEh1bGw9bi5nZXRDb252ZXhIdWxsKCl9YWRkQ29uc3RyYWludFZlcnRpY2VzKCl7dGhpcy5jb21wdXRlQ29udmV4SHVsbCgpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5fc2VnVmVydGljZXMpfWZpbmROb25HYWJyaWVsUG9pbnQodCl7Y29uc3QgZT10LmdldFN0YXJ0KCksbj10LmdldEVuZCgpLHM9bmV3IG0oKGUueCtuLngpLzIsKGUueStuLnkpLzIpLGk9ZS5kaXN0YW5jZShzKSxvPW5ldyBPKHMpO28uZXhwYW5kQnkoaSk7Y29uc3QgbD10aGlzLl9rZHQucXVlcnkobyk7bGV0IGE9bnVsbCxjPXIuTUFYX1ZBTFVFO2ZvcihsZXQgdD1sLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCByPXQubmV4dCgpLmdldENvb3JkaW5hdGUoKTtpZihyLmVxdWFsczJEKGUpfHxyLmVxdWFsczJEKG4pKWNvbnRpbnVlO2NvbnN0IG89cy5kaXN0YW5jZShyKTtpZihvPGkpe2NvbnN0IHQ9bzsobnVsbD09PWF8fHQ8YykmJihhPXIsYz10KX19cmV0dXJuIGF9Z2V0Q29uc3RyYWludFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRzfXNldFNwbGl0UG9pbnRGaW5kZXIodCl7dGhpcy5fc3BsaXRGaW5kZXI9dH1nZXRDb252ZXhIdWxsKCl7cmV0dXJuIHRoaXMuX2NvbnZleEh1bGx9Z2V0VG9sZXJhbmNlKCl7cmV0dXJuIHRoaXMuX3RvbGVyYW5jZX1lbmZvcmNlR2FicmllbCh0KXtjb25zdCBlPW5ldyBMO2xldCBuPTA7Y29uc3Qgcz1uZXcgTDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPXRoaXMuZmluZE5vbkdhYnJpZWxQb2ludCh0KTtpZihudWxsPT09ciljb250aW51ZTt0aGlzLl9zcGxpdFB0PXRoaXMuX3NwbGl0RmluZGVyLmZpbmRTcGxpdFBvaW50KHQscik7Y29uc3Qgbz10aGlzLmNyZWF0ZVZlcnRleCh0aGlzLl9zcGxpdFB0LHQpO3RoaXMuaW5zZXJ0U2l0ZShvKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodGhpcy5fc3BsaXRQdCk7Y29uc3QgbD1uZXcgWG8odC5nZXRTdGFydFgoKSx0LmdldFN0YXJ0WSgpLHQuZ2V0U3RhcnRaKCksby5nZXRYKCksby5nZXRZKCksby5nZXRaKCksdC5nZXREYXRhKCkpLGE9bmV3IFhvKG8uZ2V0WCgpLG8uZ2V0WSgpLG8uZ2V0WigpLHQuZ2V0RW5kWCgpLHQuZ2V0RW5kWSgpLHQuZ2V0RW5kWigpLHQuZ2V0RGF0YSgpKTtlLmFkZChsKSxlLmFkZChhKSxzLmFkZCh0KSxuKz0xfXJldHVybiB0LnJlbW92ZUFsbChzKSx0LmFkZEFsbChlKSxufWNyZWF0ZVZlcnRleCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLl92ZXJ0ZXhGYWN0b3J5P3RoaXMuX3ZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsbnVsbCk6bmV3IE1vKHQpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGw7cmV0dXJuIG49bnVsbCE9PXRoaXMuX3ZlcnRleEZhY3Rvcnk/dGhpcy5fdmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxlKTpuZXcgTW8odCksbi5zZXRPbkNvbnN0cmFpbnQoITApLG59fWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuX3N1YmRpdn1jb21wdXRlQm91bmRpbmdCb3goKXtjb25zdCB0PUhvLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLl9pbml0aWFsVmVydGljZXMpLGU9SG8uY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuX3NlZ1ZlcnRpY2VzKSxuPW5ldyBPKHQpO24uZXhwYW5kVG9JbmNsdWRlKGUpO2NvbnN0IHM9LjIqbi5nZXRXaWR0aCgpLGk9LjIqbi5nZXRIZWlnaHQoKSxyPU1hdGgubWF4KHMsaSk7dGhpcy5fY29tcHV0ZUFyZWFFbnY9bmV3IE8obiksdGhpcy5fY29tcHV0ZUFyZWFFbnYuZXhwYW5kQnkocil9c2V0VmVydGV4RmFjdG9yeSh0KXt0aGlzLl92ZXJ0ZXhGYWN0b3J5PXR9Zm9ybUluaXRpYWxEZWxhdW5heSgpe3RoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5fc3ViZGl2PW5ldyBCbyh0aGlzLl9jb21wdXRlQXJlYUVudix0aGlzLl90b2xlcmFuY2UpLHRoaXMuX3N1YmRpdi5zZXRMb2NhdG9yKG5ldyBGbyh0aGlzLl9zdWJkaXYpKSx0aGlzLl9pbmNEZWw9bmV3IERvKHRoaXMuX3N1YmRpdiksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLl9pbml0aWFsVmVydGljZXMpfWluc2VydFNpdGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE1vKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX2tkdC5pbnNlcnQodC5nZXRDb29yZGluYXRlKCksdCk7aWYoZS5pc1JlcGVhdGVkKCkpe2NvbnN0IG49ZS5nZXREYXRhKCk7cmV0dXJuIG4ubWVyZ2UodCksbn1yZXR1cm4gdGhpcy5faW5jRGVsLmluc2VydFNpdGUodCksdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0U2l0ZSh0aGlzLmNyZWF0ZVZlcnRleCh0KSl9fX1Iby5NQVhfU1BMSVRfSVRFUj05OTtjbGFzcyBXb3tjb25zdHJ1Y3Rvcigpe1dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbH1zdGF0aWMgZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpe2lmKG51bGw9PT10KXJldHVybiBuZXcgUjtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gV28udW5pcXVlKGUpfXN0YXRpYyBlbnZlbG9wZSh0KXtjb25zdCBlPW5ldyBPO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKHQpfXJldHVybiBlfXN0YXRpYyB1bmlxdWUodCl7Y29uc3QgZT1kdC5jb3B5RGVlcCh0KTtudC5zb3J0KGUpO3JldHVybiBuZXcgUihlLCExKX1zdGF0aWMgdG9WZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyBMO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyB2byh0KSl9cmV0dXJuIGV9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PVdvLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpLGU9V28udG9WZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9zdWJkaXY9bmV3IEJvKHQsdGhpcy5fdG9sZXJhbmNlKTtuZXcgRG8odGhpcy5fc3ViZGl2KS5pbnNlcnRTaXRlcyhlKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0U2l0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9V28uZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoSShhcmd1bWVudHNbMF0sTikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9V28udW5pcXVlKGR0LnRvQ29vcmRpbmF0ZUFycmF5KHQpKX19Z2V0RWRnZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldEVkZ2VzKHQpfWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldFRyaWFuZ2xlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfX1jbGFzcyBab3tjb25zdHJ1Y3Rvcigpe1pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl9jb25zdHJhaW50TGluZXM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwPW5ldyBIbn1zdGF0aWMgY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9eWUuZ2V0TGluZXModCksbj1uZXcgTDtmb3IobGV0IHQ9ZS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtaby5jcmVhdGVDb25zdHJhaW50U2VnbWVudHMoZSxuKX1yZXR1cm4gbn1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MTtuPGUubGVuZ3RoO24rKyl0LmFkZChuZXcgWG8oZVtuLTFdLGVbbl0pKX19Y3JlYXRlU2l0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IEw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fY29uc3RyYWludFZlcnRleE1hcC5jb250YWluc0tleSh0KXx8ZS5hZGQobmV3IE1vKHQpKX1yZXR1cm4gZX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9V28uZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3Jkcyk7bGV0IGU9bmV3IEw7bnVsbCE9PXRoaXMuX2NvbnN0cmFpbnRMaW5lcyYmKHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2NvbnN0cmFpbnRMaW5lcy5nZXRFbnZlbG9wZUludGVybmFsKCkpLHRoaXMuY3JlYXRlVmVydGljZXModGhpcy5fY29uc3RyYWludExpbmVzKSxlPVpvLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyh0aGlzLl9jb25zdHJhaW50TGluZXMpKTtjb25zdCBuPXRoaXMuY3JlYXRlU2l0ZVZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpLHM9bmV3IEhvKG4sdGhpcy5fdG9sZXJhbmNlKTtzLnNldENvbnN0cmFpbnRzKGUsbmV3IEwodGhpcy5fY29uc3RyYWludFZlcnRleE1hcC52YWx1ZXMoKSkpLHMuZm9ybUluaXRpYWxEZWxhdW5heSgpLHMuZW5mb3JjZUNvbnN0cmFpbnRzKCksdGhpcy5fc3ViZGl2PXMuZ2V0U3ViZGl2aXNpb24oKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0Q29uc3RyYWludHModCl7dGhpcy5fY29uc3RyYWludExpbmVzPXR9c2V0U2l0ZXModCl7dGhpcy5fc2l0ZUNvb3Jkcz1Xby5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9Z2V0RWRnZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldEVkZ2VzKHQpfWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldFRyaWFuZ2xlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfWNyZWF0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBuPW5ldyBNbyhlW3RdKTt0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLnB1dChlW3RdLG4pfX19Y2xhc3Mgam97Y29uc3RydWN0b3IoKXtqby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9zaXRlQ29vcmRzPW51bGwsdGhpcy5fdG9sZXJhbmNlPTAsdGhpcy5fc3ViZGl2PW51bGwsdGhpcy5fY2xpcEVudj1udWxsLHRoaXMuX2RpYWdyYW1FbnY9bnVsbH1zdGF0aWMgY2xpcEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpe2NvbnN0IG49dC5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeShlKSxzPW5ldyBMO2ZvcihsZXQgaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXtjb25zdCByPXQuZ2V0R2VvbWV0cnlOKGkpO2xldCBvPW51bGw7ZS5jb250YWlucyhyLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/bz1yOmUuaW50ZXJzZWN0cyhyLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJihvPU5yLmludGVyc2VjdGlvbihuLHIpLG8uc2V0VXNlckRhdGEoci5nZXRVc2VyRGF0YSgpKSksbnVsbD09PW98fG8uaXNFbXB0eSgpfHxzLmFkZChvKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEN0LnRvR2VvbWV0cnlBcnJheShzKSl9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PVdvLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpO2lmKHRoaXMuX2RpYWdyYW1FbnY9dGhpcy5fY2xpcEVudixudWxsPT09dGhpcy5fZGlhZ3JhbUVudil7dGhpcy5fZGlhZ3JhbUVudj10O2NvbnN0IGU9dGhpcy5fZGlhZ3JhbUVudi5nZXREaWFtZXRlcigpO3RoaXMuX2RpYWdyYW1FbnYuZXhwYW5kQnkoZSl9Y29uc3QgZT1Xby50b1ZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpO3RoaXMuX3N1YmRpdj1uZXcgQm8odCx0aGlzLl90b2xlcmFuY2UpO25ldyBEbyh0aGlzLl9zdWJkaXYpLmluc2VydFNpdGVzKGUpfWdldERpYWdyYW0odCl7dGhpcy5jcmVhdGUoKTtjb25zdCBlPXRoaXMuX3N1YmRpdi5nZXRWb3Jvbm9pRGlhZ3JhbSh0KTtyZXR1cm4gam8uY2xpcEdlb21ldHJ5Q29sbGVjdGlvbihlLHRoaXMuX2RpYWdyYW1FbnYpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRTaXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Xby5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihJKGFyZ3VtZW50c1swXSxOKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Xby51bmlxdWUoZHQudG9Db29yZGluYXRlQXJyYXkodCkpfX1zZXRDbGlwRW52ZWxvcGUodCl7dGhpcy5fY2xpcEVudj10fWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fX12YXIgS289T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVmVydGV4OnZvfSksUW89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29uZm9ybWluZ0RlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6Wm8sRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpXbyxWb3Jvbm9pRGlhZ3JhbUJ1aWxkZXI6am8scXVhZGVkZ2U6S299KTtjbGFzcyBKb3tjb25zdHJ1Y3Rvcigpe0pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuX2xpbmVhckdlb209bnVsbCx0aGlzLl9udW1MaW5lcz1udWxsLHRoaXMuX2N1cnJlbnRMaW5lPW51bGwsdGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl92ZXJ0ZXhJbmRleD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtKby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMCwwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtKby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZS5nZXRDb21wb25lbnRJbmRleCgpLEpvLnNlZ21lbnRFbmRWZXJ0ZXhJbmRleChlKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoIUkodCxXKSl0aHJvdyBuZXcgcyhcIkxpbmVhbCBnZW9tZXRyeSBpcyByZXF1aXJlZFwiKTt0aGlzLl9saW5lYXJHZW9tPXQsdGhpcy5fbnVtTGluZXM9dC5nZXROdW1HZW9tZXRyaWVzKCksdGhpcy5fY29tcG9uZW50SW5kZXg9ZSx0aGlzLl92ZXJ0ZXhJbmRleD1uLHRoaXMubG9hZEN1cnJlbnRMaW5lKCl9fXN0YXRpYyBzZWdtZW50RW5kVmVydGV4SW5kZXgodCl7cmV0dXJuIHQuZ2V0U2VnbWVudEZyYWN0aW9uKCk+MD90LmdldFNlZ21lbnRJbmRleCgpKzE6dC5nZXRTZWdtZW50SW5kZXgoKX1nZXRDb21wb25lbnRJbmRleCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleH1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lfWdldFZlcnRleEluZGV4KCl7cmV0dXJuIHRoaXMuX3ZlcnRleEluZGV4fWdldFNlZ21lbnRFbmQoKXtyZXR1cm4gdGhpcy5fdmVydGV4SW5kZXg8dGhpcy5nZXRMaW5lKCkuZ2V0TnVtUG9pbnRzKCktMT90aGlzLl9jdXJyZW50TGluZS5nZXRDb29yZGluYXRlTih0aGlzLl92ZXJ0ZXhJbmRleCsxKTpudWxsfW5leHQoKXtpZighdGhpcy5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dGhpcy5fdmVydGV4SW5kZXgrKyx0aGlzLl92ZXJ0ZXhJbmRleD49dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCkmJih0aGlzLl9jb21wb25lbnRJbmRleCsrLHRoaXMubG9hZEN1cnJlbnRMaW5lKCksdGhpcy5fdmVydGV4SW5kZXg9MCl9bG9hZEN1cnJlbnRMaW5lKCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKXJldHVybiB0aGlzLl9jdXJyZW50TGluZT1udWxsLG51bGw7dGhpcy5fY3VycmVudExpbmU9dGhpcy5fbGluZWFyR2VvbS5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpfWdldFNlZ21lbnRTdGFydCgpe3JldHVybiB0aGlzLl9jdXJyZW50TGluZS5nZXRDb29yZGluYXRlTih0aGlzLl92ZXJ0ZXhJbmRleCl9aXNFbmRPZkxpbmUoKXtyZXR1cm4hKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcykmJiEodGhpcy5fdmVydGV4SW5kZXg8dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCktMSl9aGFzTmV4dCgpe3JldHVybiEodGhpcy5fY29tcG9uZW50SW5kZXg+PXRoaXMuX251bUxpbmVzKSYmISh0aGlzLl9jb21wb25lbnRJbmRleD09PXRoaXMuX251bUxpbmVzLTEmJnRoaXMuX3ZlcnRleEluZGV4Pj10aGlzLl9jdXJyZW50TGluZS5nZXROdW1Qb2ludHMoKSl9fWNsYXNzICRve2NvbnN0cnVjdG9yKCl7JG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgaW5kZXhPZih0LGUpe3JldHVybiBuZXcgJG8odCkuaW5kZXhPZihlKX1zdGF0aWMgaW5kZXhPZkFmdGVyKHQsZSxuKXtyZXR1cm4gbmV3ICRvKHQpLmluZGV4T2ZBZnRlcihlLG4pfWluZGV4T2YodCl7cmV0dXJuIHRoaXMuaW5kZXhPZkZyb21TdGFydCh0LC0xKX1pbmRleE9mRnJvbVN0YXJ0KHQsZSl7bGV0IG49ci5NQVhfVkFMVUUscz1lLGk9MDtjb25zdCBvPW5ldyBLdCxsPW5ldyBKbyh0aGlzLl9saW5lYXJHZW9tKTtmb3IoO2wuaGFzTmV4dCgpOyl7aWYoIWwuaXNFbmRPZkxpbmUoKSl7by5wMD1sLmdldFNlZ21lbnRTdGFydCgpLG8ucDE9bC5nZXRTZWdtZW50RW5kKCk7Y29uc3Qgcj1vLmRpc3RhbmNlKHQpLGE9dGhpcy5zZWdtZW50TmVhcmVzdE1lYXN1cmUobyx0LGkpO3I8biYmYT5lJiYocz1hLG49ciksaSs9by5nZXRMZW5ndGgoKX1sLm5leHQoKX1yZXR1cm4gc31pbmRleE9mQWZ0ZXIodCxlKXtpZihlPDApcmV0dXJuIHRoaXMuaW5kZXhPZih0KTtjb25zdCBuPXRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCk7aWYobjxlKXJldHVybiBuO2NvbnN0IHM9dGhpcy5pbmRleE9mRnJvbVN0YXJ0KHQsZSk7cmV0dXJuIGcuaXNUcnVlKHM+PWUsXCJjb21wdXRlZCBpbmRleCBpcyBiZWZvcmUgc3BlY2lmaWVkIG1pbmltdW0gaW5kZXhcIiksc31zZWdtZW50TmVhcmVzdE1lYXN1cmUodCxlLG4pe2NvbnN0IHM9dC5wcm9qZWN0aW9uRmFjdG9yKGUpO3JldHVybiBzPD0wP246czw9MT9uK3MqdC5nZXRMZW5ndGgoKTpuK3QuZ2V0TGVuZ3RoKCl9fWNsYXNzIHRse2NvbnN0cnVjdG9yKCl7dGwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY29tcG9uZW50SW5kZXg9dC5fY29tcG9uZW50SW5kZXgsdGhpcy5fc2VnbWVudEluZGV4PXQuX3NlZ21lbnRJbmRleCx0aGlzLl9zZWdtZW50RnJhY3Rpb249dC5fc2VnbWVudEZyYWN0aW9ufWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RsLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCx0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQsdGhpcy5fc2VnbWVudEluZGV4PWUsdGhpcy5fc2VnbWVudEZyYWN0aW9uPW4sdGhpcy5ub3JtYWxpemUoKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9jb21wb25lbnRJbmRleD10LHRoaXMuX3NlZ21lbnRJbmRleD1lLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj1uLHMmJnRoaXMubm9ybWFsaXplKCl9fXN0YXRpYyBnZXRFbmRMb2NhdGlvbih0KXtjb25zdCBlPW5ldyB0bDtyZXR1cm4gZS5zZXRUb0VuZCh0KSxlfXN0YXRpYyBwb2ludEFsb25nU2VnbWVudEJ5RnJhY3Rpb24odCxlLG4pe2lmKG48PTApcmV0dXJuIHQ7aWYobj49MSlyZXR1cm4gZTtjb25zdCBzPShlLngtdC54KSpuK3QueCxpPShlLnktdC55KSpuK3QueSxyPShlLmdldFooKS10LmdldFooKSkqbit0LmdldFooKTtyZXR1cm4gbmV3IG0ocyxpLHIpfXN0YXRpYyBjb21wYXJlTG9jYXRpb25WYWx1ZXModCxlLG4scyxpLHIpe3JldHVybiB0PHM/LTE6dD5zPzE6ZTxpPy0xOmU+aT8xOm48cj8tMTpuPnI/MTowfXN0YXRpYyBudW1TZWdtZW50cyh0KXtjb25zdCBlPXQuZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIGU8PTE/MDplLTF9Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleH1nZXRDb21wb25lbnRJbmRleCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleH1pc0VuZHBvaW50KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49dGwubnVtU2VnbWVudHMoZSk7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleD49bnx8dGhpcy5fc2VnbWVudEluZGV4PT09bi0xJiZ0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTF9aXNWYWxpZCh0KXtpZih0aGlzLl9jb21wb25lbnRJbmRleDwwfHx0aGlzLl9jb21wb25lbnRJbmRleD49dC5nZXROdW1HZW9tZXRyaWVzKCkpcmV0dXJuITE7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7cmV0dXJuISh0aGlzLl9zZWdtZW50SW5kZXg8MHx8dGhpcy5fc2VnbWVudEluZGV4PmUuZ2V0TnVtUG9pbnRzKCkpJiYoKHRoaXMuX3NlZ21lbnRJbmRleCE9PWUuZ2V0TnVtUG9pbnRzKCl8fDA9PT10aGlzLl9zZWdtZW50RnJhY3Rpb24pJiYhKHRoaXMuX3NlZ21lbnRGcmFjdGlvbjwwfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+MSkpfW5vcm1hbGl6ZSgpe3RoaXMuX3NlZ21lbnRGcmFjdGlvbjwwJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTApLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj4xJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTEpLHRoaXMuX2NvbXBvbmVudEluZGV4PDAmJih0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSx0aGlzLl9zZWdtZW50SW5kZXg8MCYmKHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSwxPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uJiYodGhpcy5fc2VnbWVudEZyYWN0aW9uPTAsdGhpcy5fc2VnbWVudEluZGV4Kz0xKX10b0xvd2VzdCh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPXRsLm51bVNlZ21lbnRzKGUpO3JldHVybiB0aGlzLl9zZWdtZW50SW5kZXg8bj90aGlzOm5ldyB0bCh0aGlzLl9jb21wb25lbnRJbmRleCxuLTEsMSwhMSl9Z2V0Q29vcmRpbmF0ZSh0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KSxuPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KTtpZih0aGlzLl9zZWdtZW50SW5kZXg+PXRsLm51bVNlZ21lbnRzKGUpKXJldHVybiBuO2NvbnN0IHM9ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgrMSk7cmV0dXJuIHRsLnBvaW50QWxvbmdTZWdtZW50QnlGcmFjdGlvbihuLHMsdGhpcy5fc2VnbWVudEZyYWN0aW9uKX1nZXRTZWdtZW50RnJhY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9ufWdldFNlZ21lbnQodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCk7aWYodGhpcy5fc2VnbWVudEluZGV4Pj10bC5udW1TZWdtZW50cyhlKSl7Y29uc3QgdD1lLmdldENvb3JkaW5hdGVOKGUuZ2V0TnVtUG9pbnRzKCktMik7cmV0dXJuIG5ldyBLdCh0LG4pfWNvbnN0IHM9ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgrMSk7cmV0dXJuIG5ldyBLdChuLHMpfWNsYW1wKHQpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10LmdldE51bUdlb21ldHJpZXMoKSlyZXR1cm4gdGhpcy5zZXRUb0VuZCh0KSxudWxsO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49dC5nZXROdW1Qb2ludHMoKSl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7dGhpcy5fc2VnbWVudEluZGV4PXRsLm51bVNlZ21lbnRzKGUpLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xfX1zZXRUb0VuZCh0KXt0aGlzLl9jb21wb25lbnRJbmRleD10LmdldE51bUdlb21ldHJpZXMoKS0xO2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3RoaXMuX3NlZ21lbnRJbmRleD10bC5udW1TZWdtZW50cyhlKSx0aGlzLl9zZWdtZW50RnJhY3Rpb249MH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDxlLl9jb21wb25lbnRJbmRleD8tMTp0aGlzLl9jb21wb25lbnRJbmRleD5lLl9jb21wb25lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRJbmRleDxlLl9zZWdtZW50SW5kZXg/LTE6dGhpcy5fc2VnbWVudEluZGV4PmUuX3NlZ21lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxlLl9zZWdtZW50RnJhY3Rpb24/LTE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPmUuX3NlZ21lbnRGcmFjdGlvbj8xOjB9Y29weSgpe3JldHVybiBuZXcgdGwodGhpcy5fY29tcG9uZW50SW5kZXgsdGhpcy5fc2VnbWVudEluZGV4LHRoaXMuX3NlZ21lbnRGcmFjdGlvbil9dG9TdHJpbmcoKXtyZXR1cm5cIkxpbmVhckxvY1tcIit0aGlzLl9jb21wb25lbnRJbmRleCtcIiwgXCIrdGhpcy5fc2VnbWVudEluZGV4K1wiLCBcIit0aGlzLl9zZWdtZW50RnJhY3Rpb24rXCJdXCJ9aXNPblNhbWVTZWdtZW50KHQpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleD09PXQuX2NvbXBvbmVudEluZGV4JiYodGhpcy5fc2VnbWVudEluZGV4PT09dC5fc2VnbWVudEluZGV4fHwodC5fc2VnbWVudEluZGV4LXRoaXMuX3NlZ21lbnRJbmRleD09MSYmMD09PXQuX3NlZ21lbnRGcmFjdGlvbnx8dGhpcy5fc2VnbWVudEluZGV4LXQuX3NlZ21lbnRJbmRleD09MSYmMD09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbikpfXNuYXBUb1ZlcnRleCh0LGUpe2lmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbjw9MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5nZXRTZWdtZW50TGVuZ3RoKHQpLHM9dGhpcy5fc2VnbWVudEZyYWN0aW9uKm4saT1uLXM7czw9aSYmczxlP3RoaXMuX3NlZ21lbnRGcmFjdGlvbj0wOmk8PXMmJmk8ZSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKX1jb21wYXJlTG9jYXRpb25WYWx1ZXModCxlLG4pe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDx0Py0xOnRoaXMuX2NvbXBvbmVudEluZGV4PnQ/MTp0aGlzLl9zZWdtZW50SW5kZXg8ZT8tMTp0aGlzLl9zZWdtZW50SW5kZXg+ZT8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxuPy0xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbj5uPzE6MH1nZXRTZWdtZW50TGVuZ3RoKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO2xldCBuPXRoaXMuX3NlZ21lbnRJbmRleDt0aGlzLl9zZWdtZW50SW5kZXg+PXRsLm51bVNlZ21lbnRzKGUpJiYobj1lLmdldE51bVBvaW50cygpLTIpO2NvbnN0IHM9ZS5nZXRDb29yZGluYXRlTihuKSxpPWUuZ2V0Q29vcmRpbmF0ZU4obisxKTtyZXR1cm4gcy5kaXN0YW5jZShpKX1pc1ZlcnRleCgpe3JldHVybiB0aGlzLl9zZWdtZW50RnJhY3Rpb248PTB8fHRoaXMuX3NlZ21lbnRGcmFjdGlvbj49MX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fWNsYXNzIGVse2NvbnN0cnVjdG9yKCl7ZWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgaW5kZXhPZih0LGUpe3JldHVybiBuZXcgZWwodCkuaW5kZXhPZihlKX1zdGF0aWMgaW5kZXhPZkFmdGVyKHQsZSxuKXtyZXR1cm4gbmV3IGVsKHQpLmluZGV4T2ZBZnRlcihlLG4pfWluZGV4T2YodCl7cmV0dXJuIHRoaXMuaW5kZXhPZkZyb21TdGFydCh0LG51bGwpfWluZGV4T2ZGcm9tU3RhcnQodCxlKXtsZXQgbj1yLk1BWF9WQUxVRSxzPTAsaT0wLG89LTE7Y29uc3QgbD1uZXcgS3Q7Zm9yKGxldCByPW5ldyBKbyh0aGlzLl9saW5lYXJHZW9tKTtyLmhhc05leHQoKTtyLm5leHQoKSlpZighci5pc0VuZE9mTGluZSgpKXtsLnAwPXIuZ2V0U2VnbWVudFN0YXJ0KCksbC5wMT1yLmdldFNlZ21lbnRFbmQoKTtjb25zdCBhPWwuZGlzdGFuY2UodCksYz1sLnNlZ21lbnRGcmFjdGlvbih0KSxoPXIuZ2V0Q29tcG9uZW50SW5kZXgoKSx1PXIuZ2V0VmVydGV4SW5kZXgoKTthPG4mJihudWxsPT09ZXx8ZS5jb21wYXJlTG9jYXRpb25WYWx1ZXMoaCx1LGMpPDApJiYocz1oLGk9dSxvPWMsbj1hKX1pZihuPT09ci5NQVhfVkFMVUUpcmV0dXJuIG5ldyB0bChlKTtyZXR1cm4gbmV3IHRsKHMsaSxvKX1pbmRleE9mQWZ0ZXIodCxlKXtpZihudWxsPT09ZSlyZXR1cm4gdGhpcy5pbmRleE9mKHQpO2NvbnN0IG49dGwuZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSk7aWYobi5jb21wYXJlVG8oZSk8PTApcmV0dXJuIG47Y29uc3Qgcz10aGlzLmluZGV4T2ZGcm9tU3RhcnQodCxlKTtyZXR1cm4gZy5pc1RydWUocy5jb21wYXJlVG8oZSk+PTAsXCJjb21wdXRlZCBsb2NhdGlvbiBpcyBiZWZvcmUgc3BlY2lmaWVkIG1pbmltdW0gbG9jYXRpb25cIiksc319Y2xhc3Mgbmx7Y29uc3RydWN0b3IoKXtubC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fXN0YXRpYyBpbmRpY2VzT2YodCxlKXtyZXR1cm4gbmV3IG5sKHQpLmluZGljZXNPZihlKX1pbmRpY2VzT2YodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5TigwKS5nZXRDb29yZGluYXRlTigwKSxuPXQuZ2V0R2VvbWV0cnlOKHQuZ2V0TnVtR2VvbWV0cmllcygpLTEpLHM9bi5nZXRDb29yZGluYXRlTihuLmdldE51bVBvaW50cygpLTEpLGk9bmV3IGVsKHRoaXMuX2xpbmVhckdlb20pLHI9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIHJbMF09aS5pbmRleE9mKGUpLDA9PT10LmdldExlbmd0aCgpP3JbMV09clswXS5jb3B5KCk6clsxXT1pLmluZGV4T2ZBZnRlcihzLHJbMF0pLHJ9fWNsYXNzIHNse2NvbnN0cnVjdG9yKCl7c2wuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH1zdGF0aWMgZ2V0TGVuZ3RoKHQsZSl7cmV0dXJuIG5ldyBzbCh0KS5nZXRMZW5ndGgoZSl9c3RhdGljIGdldExvY2F0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgc2woYXJndW1lbnRzWzBdKS5nZXRMb2NhdGlvbih0KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBzbChhcmd1bWVudHNbMF0pLmdldExvY2F0aW9uKHQsZSl9fWdldExlbmd0aCh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IEpvKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bi5oYXNOZXh0KCk7KXtpZighbi5pc0VuZE9mTGluZSgpKXtjb25zdCBzPW4uZ2V0U2VnbWVudFN0YXJ0KCksaT1uLmdldFNlZ21lbnRFbmQoKS5kaXN0YW5jZShzKTtpZih0LmdldENvbXBvbmVudEluZGV4KCk9PT1uLmdldENvbXBvbmVudEluZGV4KCkmJnQuZ2V0U2VnbWVudEluZGV4KCk9PT1uLmdldFZlcnRleEluZGV4KCkpcmV0dXJuIGUraSp0LmdldFNlZ21lbnRGcmFjdGlvbigpO2UrPWl9bi5uZXh0KCl9cmV0dXJuIGV9cmVzb2x2ZUhpZ2hlcih0KXtpZighdC5pc0VuZHBvaW50KHRoaXMuX2xpbmVhckdlb20pKXJldHVybiB0O2xldCBlPXQuZ2V0Q29tcG9uZW50SW5kZXgoKTtpZihlPj10aGlzLl9saW5lYXJHZW9tLmdldE51bUdlb21ldHJpZXMoKS0xKXJldHVybiB0O2Rve2UrK313aGlsZShlPHRoaXMuX2xpbmVhckdlb20uZ2V0TnVtR2VvbWV0cmllcygpLTEmJjA9PT10aGlzLl9saW5lYXJHZW9tLmdldEdlb21ldHJ5TihlKS5nZXRMZW5ndGgoKSk7cmV0dXJuIG5ldyB0bChlLDAsMCl9Z2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24odCwhMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPXQ7aWYodDwwKXtuPXRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCkrdH1jb25zdCBzPXRoaXMuZ2V0TG9jYXRpb25Gb3J3YXJkKG4pO3JldHVybiBlP3M6dGhpcy5yZXNvbHZlSGlnaGVyKHMpfX1nZXRMb2NhdGlvbkZvcndhcmQodCl7aWYodDw9MClyZXR1cm4gbmV3IHRsO2xldCBlPTA7Y29uc3Qgbj1uZXcgSm8odGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtuLmhhc05leHQoKTspe2lmKG4uaXNFbmRPZkxpbmUoKSl7aWYoZT09PXQpe2NvbnN0IHQ9bi5nZXRDb21wb25lbnRJbmRleCgpLGU9bi5nZXRWZXJ0ZXhJbmRleCgpO3JldHVybiBuZXcgdGwodCxlLDApfX1lbHNle2NvbnN0IHM9bi5nZXRTZWdtZW50U3RhcnQoKSxpPW4uZ2V0U2VnbWVudEVuZCgpLmRpc3RhbmNlKHMpO2lmKGUraT50KXtjb25zdCBzPSh0LWUpL2kscj1uLmdldENvbXBvbmVudEluZGV4KCksbz1uLmdldFZlcnRleEluZGV4KCk7cmV0dXJuIG5ldyB0bChyLG8scyl9ZSs9aX1uLm5leHQoKX1yZXR1cm4gdGwuZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSl9fWNsYXNzIGlse2NvbnN0cnVjdG9yKCl7aWwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9saW5lcz1uZXcgTCx0aGlzLl9jb29yZExpc3Q9bnVsbCx0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXM9ITEsdGhpcy5fZml4SW52YWxpZExpbmVzPSExLHRoaXMuX2xhc3RQdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21GYWN0PXR9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5lbmRMaW5lKCksdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyl9Z2V0TGFzdENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fbGFzdFB0fWVuZExpbmUoKXtpZihudWxsPT09dGhpcy5fY29vcmRMaXN0KXJldHVybiBudWxsO2lmKHRoaXMuX2lnbm9yZUludmFsaWRMaW5lcyYmdGhpcy5fY29vcmRMaXN0LnNpemUoKTwyKXJldHVybiB0aGlzLl9jb29yZExpc3Q9bnVsbCxudWxsO2NvbnN0IHQ9dGhpcy5fY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IGU9dDt0aGlzLl9maXhJbnZhbGlkTGluZXMmJihlPXRoaXMudmFsaWRDb29yZGluYXRlU2VxdWVuY2UodCkpLHRoaXMuX2Nvb3JkTGlzdD1udWxsO2xldCBuPW51bGw7dHJ5e249dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZVN0cmluZyhlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBzKSl0aHJvdyB0O2lmKCF0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXMpdGhyb3cgdH1udWxsIT09biYmdGhpcy5fbGluZXMuYWRkKG4pfXNldEZpeEludmFsaWRMaW5lcyh0KXt0aGlzLl9maXhJbnZhbGlkTGluZXM9dH1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMuX2Nvb3JkTGlzdCYmKHRoaXMuX2Nvb3JkTGlzdD1uZXcgUiksdGhpcy5fY29vcmRMaXN0LmFkZCh0LGUpLHRoaXMuX2xhc3RQdD10fX1zZXRJZ25vcmVJbnZhbGlkTGluZXModCl7dGhpcy5faWdub3JlSW52YWxpZExpbmVzPXR9dmFsaWRDb29yZGluYXRlU2VxdWVuY2UodCl7aWYodC5sZW5ndGg+PTIpcmV0dXJuIHQ7cmV0dXJuW3RbMF0sdFswXV19fWNsYXNzIHJse2NvbnN0cnVjdG9yKCl7cmwuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29uc3RydWN0b3JfKCl7dGhpcy5fbGluZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmU9dH1zdGF0aWMgZXh0cmFjdCh0LGUsbil7cmV0dXJuIG5ldyBybCh0KS5leHRyYWN0KGUsbil9Y29tcHV0ZUxpbmVhcih0LGUpe2NvbnN0IG49bmV3IGlsKHRoaXMuX2xpbmUuZ2V0RmFjdG9yeSgpKTtuLnNldEZpeEludmFsaWRMaW5lcyghMCksdC5pc1ZlcnRleCgpfHxuLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2ZvcihsZXQgcz1uZXcgSm8odGhpcy5fbGluZSx0KTtzLmhhc05leHQoKSYmIShlLmNvbXBhcmVMb2NhdGlvblZhbHVlcyhzLmdldENvbXBvbmVudEluZGV4KCkscy5nZXRWZXJ0ZXhJbmRleCgpLDApPDApO3MubmV4dCgpKXtjb25zdCB0PXMuZ2V0U2VnbWVudFN0YXJ0KCk7bi5hZGQodCkscy5pc0VuZE9mTGluZSgpJiZuLmVuZExpbmUoKX1yZXR1cm4gZS5pc1ZlcnRleCgpfHxuLmFkZChlLmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpLG4uZ2V0R2VvbWV0cnkoKX1jb21wdXRlTGluZSh0LGUpe2NvbnN0IG49dGhpcy5fbGluZS5nZXRDb29yZGluYXRlcygpLHM9bmV3IFI7bGV0IGk9dC5nZXRTZWdtZW50SW5kZXgoKTt0LmdldFNlZ21lbnRGcmFjdGlvbigpPjAmJihpKz0xKTtsZXQgcj1lLmdldFNlZ21lbnRJbmRleCgpOzE9PT1lLmdldFNlZ21lbnRGcmFjdGlvbigpJiYocis9MSkscj49bi5sZW5ndGgmJihyPW4ubGVuZ3RoLTEpLHQuaXNWZXJ0ZXgoKXx8cy5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtmb3IobGV0IHQ9aTt0PD1yO3QrKylzLmFkZChuW3RdKTtlLmlzVmVydGV4KCl8fHMuYWRkKGUuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSkscy5zaXplKCk8PTAmJnMuYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7bGV0IG89cy50b0Nvb3JkaW5hdGVBcnJheSgpO3JldHVybiBvLmxlbmd0aDw9MSYmKG89W29bMF0sb1swXV0pLHRoaXMuX2xpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobyl9ZXh0cmFjdCh0LGUpe3JldHVybiBlLmNvbXBhcmVUbyh0KTwwP3RoaXMucmV2ZXJzZSh0aGlzLmNvbXB1dGVMaW5lYXIoZSx0KSk6dGhpcy5jb21wdXRlTGluZWFyKHQsZSl9cmV2ZXJzZSh0KXtyZXR1cm4gSSh0LFcpP3QucmV2ZXJzZSgpOihnLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwibm9uLWxpbmVhciBnZW9tZXRyeSBlbmNvdW50ZXJlZFwiKSxudWxsKX19Y2xhc3MgbGx7Y29uc3RydWN0b3IoKXtsbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fWNsYW1wSW5kZXgodCl7Y29uc3QgZT10aGlzLnBvc2l0aXZlSW5kZXgodCksbj10aGlzLmdldFN0YXJ0SW5kZXgoKTtpZihlPG4pcmV0dXJuIG47Y29uc3Qgcz10aGlzLmdldEVuZEluZGV4KCk7cmV0dXJuIGU+cz9zOmV9bG9jYXRpb25PZigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc2wuZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHNsLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCxlKX19cHJvamVjdCh0KXtyZXR1cm4gJG8uaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfXBvc2l0aXZlSW5kZXgodCl7cmV0dXJuIHQ+PTA/dDp0aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpK3R9ZXh0cmFjdFBvaW50KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBzbC5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQpLmdldENvb3JkaW5hdGUodGhpcy5fbGluZWFyR2VvbSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49c2wuZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KS50b0xvd2VzdCh0aGlzLl9saW5lYXJHZW9tKTtyZXR1cm4gbi5nZXRTZWdtZW50KHRoaXMuX2xpbmVhckdlb20pLnBvaW50QWxvbmdPZmZzZXQobi5nZXRTZWdtZW50RnJhY3Rpb24oKSxlKX19aXNWYWxpZEluZGV4KHQpe3JldHVybiB0Pj10aGlzLmdldFN0YXJ0SW5kZXgoKSYmdDw9dGhpcy5nZXRFbmRJbmRleCgpfWdldEVuZEluZGV4KCl7cmV0dXJuIHRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCl9Z2V0U3RhcnRJbmRleCgpe3JldHVybiAwfWluZGV4T2ZBZnRlcih0LGUpe3JldHVybiAkby5pbmRleE9mQWZ0ZXIodGhpcy5fbGluZWFyR2VvbSx0LGUpfWV4dHJhY3RMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLmNsYW1wSW5kZXgodCkscz10aGlzLmNsYW1wSW5kZXgoZSksaT1uPT09cyxyPXRoaXMubG9jYXRpb25PZihuLGkpLG89dGhpcy5sb2NhdGlvbk9mKHMpO3JldHVybiBybC5leHRyYWN0KHRoaXMuX2xpbmVhckdlb20scixvKX1pbmRleE9mKHQpe3JldHVybiAkby5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9aW5kaWNlc09mKHQpe2NvbnN0IGU9bmwuaW5kaWNlc09mKHRoaXMuX2xpbmVhckdlb20sdCk7cmV0dXJuW3NsLmdldExlbmd0aCh0aGlzLl9saW5lYXJHZW9tLGVbMF0pLHNsLmdldExlbmd0aCh0aGlzLl9saW5lYXJHZW9tLGVbMV0pXX19Y2xhc3MgYWx7Y29uc3RydWN0b3IoKXthbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10LHRoaXMuY2hlY2tHZW9tZXRyeVR5cGUoKX1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dC5jb3B5KCk7cmV0dXJuIGUuY2xhbXAodGhpcy5fbGluZWFyR2VvbSksZX1wcm9qZWN0KHQpe3JldHVybiBlbC5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9Y2hlY2tHZW9tZXRyeVR5cGUoKXtpZighKHRoaXMuX2xpbmVhckdlb20gaW5zdGFuY2VvZiBKfHx0aGlzLl9saW5lYXJHZW9tIGluc3RhbmNlb2Ygd3QpKXRocm93IG5ldyBzKFwiSW5wdXQgZ2VvbWV0cnkgbXVzdCBiZSBsaW5lYXJcIil9ZXh0cmFjdFBvaW50KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybiBhcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lYXJHZW9tKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV0sZT1hcmd1bWVudHNbMF0udG9Mb3dlc3QodGhpcy5fbGluZWFyR2VvbSk7cmV0dXJuIGUuZ2V0U2VnbWVudCh0aGlzLl9saW5lYXJHZW9tKS5wb2ludEFsb25nT2Zmc2V0KGUuZ2V0U2VnbWVudEZyYWN0aW9uKCksdCl9fWlzVmFsaWRJbmRleCh0KXtyZXR1cm4gdC5pc1ZhbGlkKHRoaXMuX2xpbmVhckdlb20pfWdldEVuZEluZGV4KCl7cmV0dXJuIHRsLmdldEVuZExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20pfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gbmV3IHRsfWluZGV4T2ZBZnRlcih0LGUpe3JldHVybiBlbC5pbmRleE9mQWZ0ZXIodGhpcy5fbGluZWFyR2VvbSx0LGUpfWV4dHJhY3RMaW5lKHQsZSl7cmV0dXJuIHJsLmV4dHJhY3QodGhpcy5fbGluZWFyR2VvbSx0LGUpfWluZGV4T2YodCl7cmV0dXJuIGVsLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1pbmRpY2VzT2YodCl7cmV0dXJuIG5sLmluZGljZXNPZih0aGlzLl9saW5lYXJHZW9tLHQpfX12YXIgY2w9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGVuZ3RoSW5kZXhlZExpbmU6bGwsTGVuZ3RoTG9jYXRpb25NYXA6c2wsTGluZWFyR2VvbWV0cnlCdWlsZGVyOmlsLExpbmVhckl0ZXJhdG9yOkpvLExpbmVhckxvY2F0aW9uOnRsLExvY2F0aW9uSW5kZXhlZExpbmU6YWx9KTtjbGFzcyBobHtzdGF0aWMgdHJhbnNmb3JtKHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyluLmFkZChlLmV4ZWN1dGUocy5uZXh0KCkpKTtyZXR1cm4gbn1zdGF0aWMgc2VsZWN0KHQsZSl7Y29uc3Qgbj1uZXcgTDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtCb29sZWFuLlRSVUUuZXF1YWxzKGUuZXhlY3V0ZSh0KSkmJm4uYWRkKHQpfXJldHVybiBufXN0YXRpYyBhcHBseSh0LGUpe2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuZXhlY3V0ZShuLm5leHQoKSl9fWhsLkZ1bmN0aW9uPWZ1bmN0aW9uKCl7fTtjbGFzcyB1bHtjb25zdHJ1Y3Rvcigpe3VsLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe3RoaXMucHRzPW51bGwsdGhpcy5uPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9bmV3IEFycmF5KHQpLmZpbGwobnVsbCl9ZmlsdGVyKHQpe3RoaXMucHRzW3RoaXMubisrXT10fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltVXX19Y2xhc3MgZ2x7Y29uc3RydWN0b3IoKXtnbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9uPTB9ZmlsdGVyKHQpe3RoaXMuX24rK31nZXRDb3VudCgpe3JldHVybiB0aGlzLl9ufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltVXX19Y2xhc3MgZGx7Y29uc3RydWN0b3IoKXtkbC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb25zdHJ1Y3Rvcl8oKXt0aGlzLl9jb3VudHM9bmV3IEl0fWNvdW50KHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtyZXR1cm4gbnVsbD09PWU/MDplLmNvdW50KCl9YWRkKHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtudWxsPT09ZT90aGlzLl9jb3VudHMucHV0KHQsbmV3IF9sKDEpKTplLmluY3JlbWVudCgpfX1jbGFzcyBfbHtjb25zdHJ1Y3Rvcigpe19sLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnN0cnVjdG9yXygpe2lmKHRoaXMuY291bnQ9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb3VudD10fX1jb3VudCgpe3JldHVybiB0aGlzLmNvdW50fWluY3JlbWVudCgpe3RoaXMuY291bnQrK319ZnVuY3Rpb24gcGwoKXt9ZnVuY3Rpb24gbWwoKXt9ZnVuY3Rpb24gZmwoKXt9ZGwuQ291bnRlcj1fbDtjbGFzcyB5bCBleHRlbmRzIG57fWZ1bmN0aW9uIHhsKCl7fWNsYXNzIEVse3N0YXRpYyBjaGFycyh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7Zm9yKGxldCBzPTA7czxlO3MrKyluW3NdPXQ7cmV0dXJuIG5ldyBTdHJpbmcobil9c3RhdGljIGdldFN0YWNrVHJhY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgZmwsbj1uZXcgcGwoZSk7cmV0dXJuIHQucHJpbnRTdGFja1RyYWNlKG4pLGUudG9TdHJpbmcoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49XCJcIjtjb25zdCBzPW5ldyB4bChuZXcgbWwoRWwuZ2V0U3RhY2tUcmFjZSh0KSkpO2ZvcihsZXQgdD0wO3Q8ZTt0KyspdHJ5e24rPXMucmVhZExpbmUoKStFbC5ORVdMSU5FfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIHlsKSl0aHJvdyB0O2cuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbn19c3RhdGljIHNwYWNlcyh0KXtyZXR1cm4gRWwuY2hhcnMoXCIgXCIsdCl9c3RhdGljIHNwbGl0KHQsZSl7Y29uc3Qgbj1lLmxlbmd0aCxzPW5ldyBMO2xldCBpPVwiXCIrdCxyPWkuaW5kZXhPZihlKTtmb3IoO3I+PTA7KXtjb25zdCB0PWkuc3Vic3RyaW5nKDAscik7cy5hZGQodCksaT1pLnN1YnN0cmluZyhyK24pLHI9aS5pbmRleE9mKGUpfWkubGVuZ3RoPjAmJnMuYWRkKGkpO2NvbnN0IG89bmV3IEFycmF5KHMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKW9bdF09cy5nZXQodCk7cmV0dXJuIG99fUVsLk5FV0xJTkU9Qi5nZXRQcm9wZXJ0eShcImxpbmUuc2VwYXJhdG9yXCIpO3ZhciBJbD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb2xsZWN0aW9uVXRpbDpobCxDb29yZGluYXRlQXJyYXlGaWx0ZXI6dWwsQ29vcmRpbmF0ZUNvdW50RmlsdGVyOmdsLEdlb21ldHJpY1NoYXBlRmFjdG9yeTpTZSxOdW1iZXJVdGlsOmUsT2JqZWN0Q291bnRlcjpkbCxQcmlvcml0eVF1ZXVlOkNzLFN0cmluZ1V0aWw6RWwsVW5pcXVlQ29vcmRpbmF0ZUFycmF5RmlsdGVyOm5ufSk7Y2xhc3MgTmx7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119Z2V0Q2xhc3MoKXtyZXR1cm4gTmx9c3RhdGljIHVuaW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIE5yLmNyZWF0ZUVtcHR5UmVzdWx0KE5yLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLEVyLm92ZXJsYXlPcCh0LGUsTnIuVU5JT04pfX1KLnByb3RvdHlwZS5nZXRCb3VuZGFyeT1mdW5jdGlvbigpe3JldHVybiBzaS5nZXRCb3VuZGFyeSh0aGlzKX0sd3QucHJvdG90eXBlLmdldEJvdW5kYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHNpLmdldEJvdW5kYXJ5KHRoaXMpfSxYLnByb3RvdHlwZS5lcXVhbHNUb3BvPWZ1bmN0aW9uKHQpe3JldHVybiBLci5lcXVhbHNUb3BvKHRoaXMsdCl9LFgucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXQmJktyLmVxdWFsc1RvcG8odGhpcyx0KX0sWC5wcm90b3R5cGUudW5pb249ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbm8udW5pb24odGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBObC51bmlvbih0aGlzLHQpfX0sWC5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiBGci5pc1ZhbGlkKHRoaXMpfSxYLnByb3RvdHlwZS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuIE5yLmludGVyc2VjdGlvbih0aGlzLHQpfSxYLnByb3RvdHlwZS5jb3ZlcnM9ZnVuY3Rpb24odCl7cmV0dXJuIEtyLmNvdmVycyh0aGlzLHQpfSxYLnByb3RvdHlwZS5jb3ZlcmVkQnk9ZnVuY3Rpb24odCl7cmV0dXJuIEtyLmNvdmVycyh0LHRoaXMpfSxYLnByb3RvdHlwZS50b3VjaGVzPWZ1bmN0aW9uKHQpe3JldHVybiBLci50b3VjaGVzKHRoaXMsdCl9LFgucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24odCl7cmV0dXJuIEtyLmludGVyc2VjdHModGhpcyx0KX0sWC5wcm90b3R5cGUud2l0aGluPWZ1bmN0aW9uKHQpe3JldHVybiBLci5jb250YWlucyh0LHRoaXMpfSxYLnByb3RvdHlwZS5vdmVybGFwcz1mdW5jdGlvbih0KXtyZXR1cm4gS3Iub3ZlcmxhcHModGhpcyx0KX0sWC5wcm90b3R5cGUuZGlzam9pbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIEtyLmRpc2pvaW50KHRoaXMsdCl9LFgucHJvdG90eXBlLmNyb3NzZXM9ZnVuY3Rpb24odCl7cmV0dXJuIEtyLmNyb3NzZXModGhpcyx0KX0sWC5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBHaS5idWZmZXJPcCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gR2kuYnVmZmVyT3AodGhpcyx0LGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gR2kuYnVmZmVyT3AodGhpcyx0LGUsbil9fSxYLnByb3RvdHlwZS5jb252ZXhIdWxsPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBzbih0aGlzKS5nZXRDb252ZXhIdWxsKCl9LFgucHJvdG90eXBlLnJlbGF0ZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gS3IucmVsYXRlKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBLci5yZWxhdGUodGhpcyx0KS5tYXRjaGVzKGUpfX0sWC5wcm90b3R5cGUuZ2V0Q2VudHJvaWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCgpO2NvbnN0IHQ9JGUuZ2V0Q2VudHJvaWQodGhpcyk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LHRoaXMpfSxYLnByb3RvdHlwZS5nZXRJbnRlcmlvclBvaW50PWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQoKTtsZXQgdD1udWxsO2NvbnN0IGU9dGhpcy5nZXREaW1lbnNpb24oKTt0PTA9PT1lP25ldyB1bih0aGlzKToxPT09ZT9uZXcgaG4odGhpcyk6bmV3IG9uKHRoaXMpO2NvbnN0IG49dC5nZXRJbnRlcmlvclBvaW50KCk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZChuLHRoaXMpfSxYLnByb3RvdHlwZS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBOci5zeW1EaWZmZXJlbmNlKHRoaXMsdCl9LFgucHJvdG90eXBlLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfSxYLnByb3RvdHlwZS50b1RleHQ9ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFd0KS53cml0ZSh0aGlzKX0sWC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt0aGlzLnRvVGV4dCgpfSxYLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtyZXR1cm4gS3IuY29udGFpbnModGhpcyx0KX0sWC5wcm90b3R5cGUuZGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gTnIuZGlmZmVyZW5jZSh0aGlzLHQpfSxYLnByb3RvdHlwZS5pc1NpbXBsZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcmkodGhpcykuaXNTaW1wbGUoKX0sWC5wcm90b3R5cGUuaXNXaXRoaW5EaXN0YW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiEodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UodC5nZXRFbnZlbG9wZUludGVybmFsKCkpPmUpJiZWaS5pc1dpdGhpbkRpc3RhbmNlKHRoaXMsdCxlKX0sWC5wcm90b3R5cGUuZGlzdGFuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIFZpLmRpc3RhbmNlKHRoaXMsdCl9O3QuYWxnb3JpdGhtPUVuLHQuZGVuc2lmeT1Tbix0LmRpc3NvbHZlPXZuLHQuZ2VvbT1UZSx0Lmdlb21ncmFwaD1hcyx0LmluZGV4PURzLHQuaW89WXMsdC5saW5lYXJyZWY9Y2wsdC5ub2Rpbmc9bmksdC5vcGVyYXRpb249cm8sdC5wcmVjaXNpb249YW8sdC5zaW1wbGlmeT1Mbyx0LnRyaWFuZ3VsYXRlPVFvLHQudXRpbD1JbCx0LnZlcnNpb249XCIyLjYuMCAoZGRhZTg2NilcIixPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzdHMubWluLmpzLm1hcCIsIiFmdW5jdGlvbih0LGkpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWkoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGkpOih0PXR8fHNlbGYpLlJCdXNoPWkoKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCxyLGUsYSxoKXshZnVuY3Rpb24gdChuLHIsZSxhLGgpe2Zvcig7YT5lOyl7aWYoYS1lPjYwMCl7dmFyIG89YS1lKzEscz1yLWUrMSxsPU1hdGgubG9nKG8pLGY9LjUqTWF0aC5leHAoMipsLzMpLHU9LjUqTWF0aC5zcXJ0KGwqZiooby1mKS9vKSoocy1vLzI8MD8tMToxKSxtPU1hdGgubWF4KGUsTWF0aC5mbG9vcihyLXMqZi9vK3UpKSxjPU1hdGgubWluKGEsTWF0aC5mbG9vcihyKyhvLXMpKmYvbyt1KSk7dChuLHIsbSxjLGgpfXZhciBwPW5bcl0sZD1lLHg9YTtmb3IoaShuLGUsciksaChuW2FdLHApPjAmJmkobixlLGEpO2Q8eDspe2ZvcihpKG4sZCx4KSxkKysseC0tO2gobltkXSxwKTwwOylkKys7Zm9yKDtoKG5beF0scCk+MDspeC0tfTA9PT1oKG5bZV0scCk/aShuLGUseCk6aShuLCsreCxhKSx4PD1yJiYoZT14KzEpLHI8PXgmJihhPXgtMSl9fSh0LHIsZXx8MCxhfHx0Lmxlbmd0aC0xLGh8fG4pfWZ1bmN0aW9uIGkodCxpLG4pe3ZhciByPXRbaV07dFtpXT10W25dLHRbbl09cn1mdW5jdGlvbiBuKHQsaSl7cmV0dXJuIHQ8aT8tMTp0Pmk/MTowfXZhciByPWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PTkpLHRoaXMuX21heEVudHJpZXM9TWF0aC5tYXgoNCx0KSx0aGlzLl9taW5FbnRyaWVzPU1hdGgubWF4KDIsTWF0aC5jZWlsKC40KnRoaXMuX21heEVudHJpZXMpKSx0aGlzLmNsZWFyKCl9O2Z1bmN0aW9uIGUodCxpLG4pe2lmKCFuKXJldHVybiBpLmluZGV4T2YodCk7Zm9yKHZhciByPTA7cjxpLmxlbmd0aDtyKyspaWYobih0LGlbcl0pKXJldHVybiByO3JldHVybi0xfWZ1bmN0aW9uIGEodCxpKXtoKHQsMCx0LmNoaWxkcmVuLmxlbmd0aCxpLHQpfWZ1bmN0aW9uIGgodCxpLG4scixlKXtlfHwoZT1wKG51bGwpKSxlLm1pblg9MS8wLGUubWluWT0xLzAsZS5tYXhYPS0xLzAsZS5tYXhZPS0xLzA7Zm9yKHZhciBhPWk7YTxuO2ErKyl7dmFyIGg9dC5jaGlsZHJlblthXTtvKGUsdC5sZWFmP3IoaCk6aCl9cmV0dXJuIGV9ZnVuY3Rpb24gbyh0LGkpe3JldHVybiB0Lm1pblg9TWF0aC5taW4odC5taW5YLGkubWluWCksdC5taW5ZPU1hdGgubWluKHQubWluWSxpLm1pblkpLHQubWF4WD1NYXRoLm1heCh0Lm1heFgsaS5tYXhYKSx0Lm1heFk9TWF0aC5tYXgodC5tYXhZLGkubWF4WSksdH1mdW5jdGlvbiBzKHQsaSl7cmV0dXJuIHQubWluWC1pLm1pblh9ZnVuY3Rpb24gbCh0LGkpe3JldHVybiB0Lm1pblktaS5taW5ZfWZ1bmN0aW9uIGYodCl7cmV0dXJuKHQubWF4WC10Lm1pblgpKih0Lm1heFktdC5taW5ZKX1mdW5jdGlvbiB1KHQpe3JldHVybiB0Lm1heFgtdC5taW5YKyh0Lm1heFktdC5taW5ZKX1mdW5jdGlvbiBtKHQsaSl7cmV0dXJuIHQubWluWDw9aS5taW5YJiZ0Lm1pblk8PWkubWluWSYmaS5tYXhYPD10Lm1heFgmJmkubWF4WTw9dC5tYXhZfWZ1bmN0aW9uIGModCxpKXtyZXR1cm4gaS5taW5YPD10Lm1heFgmJmkubWluWTw9dC5tYXhZJiZpLm1heFg+PXQubWluWCYmaS5tYXhZPj10Lm1pbll9ZnVuY3Rpb24gcCh0KXtyZXR1cm57Y2hpbGRyZW46dCxoZWlnaHQ6MSxsZWFmOiEwLG1pblg6MS8wLG1pblk6MS8wLG1heFg6LTEvMCxtYXhZOi0xLzB9fWZ1bmN0aW9uIGQoaSxuLHIsZSxhKXtmb3IodmFyIGg9W24scl07aC5sZW5ndGg7KWlmKCEoKHI9aC5wb3AoKSktKG49aC5wb3AoKSk8PWUpKXt2YXIgbz1uK01hdGguY2VpbCgoci1uKS9lLzIpKmU7dChpLG8sbixyLGEpLGgucHVzaChuLG8sbyxyKX19cmV0dXJuIHIucHJvdG90eXBlLmFsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLFtdKX0sci5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZGF0YSxuPVtdO2lmKCFjKHQsaSkpcmV0dXJuIG47Zm9yKHZhciByPXRoaXMudG9CQm94LGU9W107aTspe2Zvcih2YXIgYT0wO2E8aS5jaGlsZHJlbi5sZW5ndGg7YSsrKXt2YXIgaD1pLmNoaWxkcmVuW2FdLG89aS5sZWFmP3IoaCk6aDtjKHQsbykmJihpLmxlYWY/bi5wdXNoKGgpOm0odCxvKT90aGlzLl9hbGwoaCxuKTplLnB1c2goaCkpfWk9ZS5wb3AoKX1yZXR1cm4gbn0sci5wcm90b3R5cGUuY29sbGlkZXM9ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5kYXRhO2lmKCFjKHQsaSkpcmV0dXJuITE7Zm9yKHZhciBuPVtdO2k7KXtmb3IodmFyIHI9MDtyPGkuY2hpbGRyZW4ubGVuZ3RoO3IrKyl7dmFyIGU9aS5jaGlsZHJlbltyXSxhPWkubGVhZj90aGlzLnRvQkJveChlKTplO2lmKGModCxhKSl7aWYoaS5sZWFmfHxtKHQsYSkpcmV0dXJuITA7bi5wdXNoKGUpfX1pPW4ucG9wKCl9cmV0dXJuITF9LHIucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24odCl7aWYoIXR8fCF0Lmxlbmd0aClyZXR1cm4gdGhpcztpZih0Lmxlbmd0aDx0aGlzLl9taW5FbnRyaWVzKXtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyl0aGlzLmluc2VydCh0W2ldKTtyZXR1cm4gdGhpc312YXIgbj10aGlzLl9idWlsZCh0LnNsaWNlKCksMCx0Lmxlbmd0aC0xLDApO2lmKHRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpaWYodGhpcy5kYXRhLmhlaWdodD09PW4uaGVpZ2h0KXRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsbik7ZWxzZXtpZih0aGlzLmRhdGEuaGVpZ2h0PG4uaGVpZ2h0KXt2YXIgcj10aGlzLmRhdGE7dGhpcy5kYXRhPW4sbj1yfXRoaXMuX2luc2VydChuLHRoaXMuZGF0YS5oZWlnaHQtbi5oZWlnaHQtMSwhMCl9ZWxzZSB0aGlzLmRhdGE9bjtyZXR1cm4gdGhpc30sci5wcm90b3R5cGUuaW5zZXJ0PWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLl9pbnNlcnQodCx0aGlzLmRhdGEuaGVpZ2h0LTEpLHRoaXN9LHIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YT1wKFtdKSx0aGlzfSxyLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCxpKXtpZighdClyZXR1cm4gdGhpcztmb3IodmFyIG4scixhLGg9dGhpcy5kYXRhLG89dGhpcy50b0JCb3godCkscz1bXSxsPVtdO2h8fHMubGVuZ3RoOyl7aWYoaHx8KGg9cy5wb3AoKSxyPXNbcy5sZW5ndGgtMV0sbj1sLnBvcCgpLGE9ITApLGgubGVhZil7dmFyIGY9ZSh0LGguY2hpbGRyZW4saSk7aWYoLTEhPT1mKXJldHVybiBoLmNoaWxkcmVuLnNwbGljZShmLDEpLHMucHVzaChoKSx0aGlzLl9jb25kZW5zZShzKSx0aGlzfWF8fGgubGVhZnx8IW0oaCxvKT9yPyhuKyssaD1yLmNoaWxkcmVuW25dLGE9ITEpOmg9bnVsbDoocy5wdXNoKGgpLGwucHVzaChuKSxuPTAscj1oLGg9aC5jaGlsZHJlblswXSl9cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLnRvQkJveD1mdW5jdGlvbih0KXtyZXR1cm4gdH0sci5wcm90b3R5cGUuY29tcGFyZU1pblg9ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC5taW5YLWkubWluWH0sci5wcm90b3R5cGUuY29tcGFyZU1pblk9ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC5taW5ZLWkubWluWX0sci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sci5wcm90b3R5cGUuZnJvbUpTT049ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YT10LHRoaXN9LHIucHJvdG90eXBlLl9hbGw9ZnVuY3Rpb24odCxpKXtmb3IodmFyIG49W107dDspdC5sZWFmP2kucHVzaC5hcHBseShpLHQuY2hpbGRyZW4pOm4ucHVzaC5hcHBseShuLHQuY2hpbGRyZW4pLHQ9bi5wb3AoKTtyZXR1cm4gaX0sci5wcm90b3R5cGUuX2J1aWxkPWZ1bmN0aW9uKHQsaSxuLHIpe3ZhciBlLGg9bi1pKzEsbz10aGlzLl9tYXhFbnRyaWVzO2lmKGg8PW8pcmV0dXJuIGEoZT1wKHQuc2xpY2UoaSxuKzEpKSx0aGlzLnRvQkJveCksZTtyfHwocj1NYXRoLmNlaWwoTWF0aC5sb2coaCkvTWF0aC5sb2cobykpLG89TWF0aC5jZWlsKGgvTWF0aC5wb3cobyxyLTEpKSksKGU9cChbXSkpLmxlYWY9ITEsZS5oZWlnaHQ9cjt2YXIgcz1NYXRoLmNlaWwoaC9vKSxsPXMqTWF0aC5jZWlsKE1hdGguc3FydChvKSk7ZCh0LGksbixsLHRoaXMuY29tcGFyZU1pblgpO2Zvcih2YXIgZj1pO2Y8PW47Zis9bCl7dmFyIHU9TWF0aC5taW4oZitsLTEsbik7ZCh0LGYsdSxzLHRoaXMuY29tcGFyZU1pblkpO2Zvcih2YXIgbT1mO208PXU7bSs9cyl7dmFyIGM9TWF0aC5taW4obStzLTEsdSk7ZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKHQsbSxjLHItMSkpfX1yZXR1cm4gYShlLHRoaXMudG9CQm94KSxlfSxyLnByb3RvdHlwZS5fY2hvb3NlU3VidHJlZT1mdW5jdGlvbih0LGksbixyKXtmb3IoO3IucHVzaChpKSwhaS5sZWFmJiZyLmxlbmd0aC0xIT09bjspe2Zvcih2YXIgZT0xLzAsYT0xLzAsaD12b2lkIDAsbz0wO288aS5jaGlsZHJlbi5sZW5ndGg7bysrKXt2YXIgcz1pLmNoaWxkcmVuW29dLGw9ZihzKSx1PShtPXQsYz1zLChNYXRoLm1heChjLm1heFgsbS5tYXhYKS1NYXRoLm1pbihjLm1pblgsbS5taW5YKSkqKE1hdGgubWF4KGMubWF4WSxtLm1heFkpLU1hdGgubWluKGMubWluWSxtLm1pblkpKS1sKTt1PGE/KGE9dSxlPWw8ZT9sOmUsaD1zKTp1PT09YSYmbDxlJiYoZT1sLGg9cyl9aT1ofHxpLmNoaWxkcmVuWzBdfXZhciBtLGM7cmV0dXJuIGl9LHIucHJvdG90eXBlLl9pbnNlcnQ9ZnVuY3Rpb24odCxpLG4pe3ZhciByPW4/dDp0aGlzLnRvQkJveCh0KSxlPVtdLGE9dGhpcy5fY2hvb3NlU3VidHJlZShyLHRoaXMuZGF0YSxpLGUpO2ZvcihhLmNoaWxkcmVuLnB1c2godCksbyhhLHIpO2k+PTAmJmVbaV0uY2hpbGRyZW4ubGVuZ3RoPnRoaXMuX21heEVudHJpZXM7KXRoaXMuX3NwbGl0KGUsaSksaS0tO3RoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhyLGUsaSl9LHIucHJvdG90eXBlLl9zcGxpdD1mdW5jdGlvbih0LGkpe3ZhciBuPXRbaV0scj1uLmNoaWxkcmVuLmxlbmd0aCxlPXRoaXMuX21pbkVudHJpZXM7dGhpcy5fY2hvb3NlU3BsaXRBeGlzKG4sZSxyKTt2YXIgaD10aGlzLl9jaG9vc2VTcGxpdEluZGV4KG4sZSxyKSxvPXAobi5jaGlsZHJlbi5zcGxpY2UoaCxuLmNoaWxkcmVuLmxlbmd0aC1oKSk7by5oZWlnaHQ9bi5oZWlnaHQsby5sZWFmPW4ubGVhZixhKG4sdGhpcy50b0JCb3gpLGEobyx0aGlzLnRvQkJveCksaT90W2ktMV0uY2hpbGRyZW4ucHVzaChvKTp0aGlzLl9zcGxpdFJvb3QobixvKX0sci5wcm90b3R5cGUuX3NwbGl0Um9vdD1mdW5jdGlvbih0LGkpe3RoaXMuZGF0YT1wKFt0LGldKSx0aGlzLmRhdGEuaGVpZ2h0PXQuaGVpZ2h0KzEsdGhpcy5kYXRhLmxlYWY9ITEsYSh0aGlzLmRhdGEsdGhpcy50b0JCb3gpfSxyLnByb3RvdHlwZS5fY2hvb3NlU3BsaXRJbmRleD1mdW5jdGlvbih0LGksbil7Zm9yKHZhciByLGUsYSxvLHMsbCx1LG09MS8wLGM9MS8wLHA9aTtwPD1uLWk7cCsrKXt2YXIgZD1oKHQsMCxwLHRoaXMudG9CQm94KSx4PWgodCxwLG4sdGhpcy50b0JCb3gpLHY9KGU9ZCxhPXgsbz12b2lkIDAscz12b2lkIDAsbD12b2lkIDAsdT12b2lkIDAsbz1NYXRoLm1heChlLm1pblgsYS5taW5YKSxzPU1hdGgubWF4KGUubWluWSxhLm1pblkpLGw9TWF0aC5taW4oZS5tYXhYLGEubWF4WCksdT1NYXRoLm1pbihlLm1heFksYS5tYXhZKSxNYXRoLm1heCgwLGwtbykqTWF0aC5tYXgoMCx1LXMpKSxNPWYoZCkrZih4KTt2PG0/KG09dixyPXAsYz1NPGM/TTpjKTp2PT09bSYmTTxjJiYoYz1NLHI9cCl9cmV0dXJuIHJ8fG4taX0sci5wcm90b3R5cGUuX2Nob29zZVNwbGl0QXhpcz1mdW5jdGlvbih0LGksbil7dmFyIHI9dC5sZWFmP3RoaXMuY29tcGFyZU1pblg6cyxlPXQubGVhZj90aGlzLmNvbXBhcmVNaW5ZOmw7dGhpcy5fYWxsRGlzdE1hcmdpbih0LGksbixyKTx0aGlzLl9hbGxEaXN0TWFyZ2luKHQsaSxuLGUpJiZ0LmNoaWxkcmVuLnNvcnQocil9LHIucHJvdG90eXBlLl9hbGxEaXN0TWFyZ2luPWZ1bmN0aW9uKHQsaSxuLHIpe3QuY2hpbGRyZW4uc29ydChyKTtmb3IodmFyIGU9dGhpcy50b0JCb3gsYT1oKHQsMCxpLGUpLHM9aCh0LG4taSxuLGUpLGw9dShhKSt1KHMpLGY9aTtmPG4taTtmKyspe3ZhciBtPXQuY2hpbGRyZW5bZl07byhhLHQubGVhZj9lKG0pOm0pLGwrPXUoYSl9Zm9yKHZhciBjPW4taS0xO2M+PWk7Yy0tKXt2YXIgcD10LmNoaWxkcmVuW2NdO28ocyx0LmxlYWY/ZShwKTpwKSxsKz11KHMpfXJldHVybiBsfSxyLnByb3RvdHlwZS5fYWRqdXN0UGFyZW50QkJveGVzPWZ1bmN0aW9uKHQsaSxuKXtmb3IodmFyIHI9bjtyPj0wO3ItLSlvKGlbcl0sdCl9LHIucHJvdG90eXBlLl9jb25kZW5zZT1mdW5jdGlvbih0KXtmb3IodmFyIGk9dC5sZW5ndGgtMSxuPXZvaWQgMDtpPj0wO2ktLSkwPT09dFtpXS5jaGlsZHJlbi5sZW5ndGg/aT4wPyhuPXRbaS0xXS5jaGlsZHJlbikuc3BsaWNlKG4uaW5kZXhPZih0W2ldKSwxKTp0aGlzLmNsZWFyKCk6YSh0W2ldLHRoaXMudG9CQm94KX0scn0pO1xuIiwiLy9AdHMtY2hlY2tcblxuLyoqICovXG5leHBvcnQgY2xhc3MgQWdlbnRQb2ludCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN5IFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHN4PTAsIHN5PTApIHtcblxuICAgICAgICAvL3Bvc2l0aW9uXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHlcblxuICAgICAgICAvL3NwZWVkXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc3ggPSBzeFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zeSA9IHN5XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnMgPSB1bmRlZmluZWRcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuc2EgPSB1bmRlZmluZWRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWdlbnRQb2ludH0gYVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSB0byBhbm90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGQoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kUChhLngsIGEueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGRpc3RhbmNlIHRvIGEgcG9zaXRpb24uXG4gICAgICovXG4gICAgZFAoeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5oeXBvdCgoeCAtIHRoaXMueCksICh5IC0gdGhpcy55KSk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICogU2V0IHJhbmRvbSBzcGVlZFxuICAgICogXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZFxuICAgICovXG4gICAgc2V0UmFuZG9tU3BlZWQobWluU3BlZWQgPSAwLCBtYXhTcGVlZCA9IDAuMSkge1xuICAgICAgICB0aGlzLnMgPSBtaW5TcGVlZCArIE1hdGgucmFuZG9tKCkgKiAobWF4U3BlZWQgLSBtaW5TcGVlZCk7XG4gICAgICAgIHRoaXMuc2EgPSAyICogTWF0aC5yYW5kb20oKSAqIE1hdGguUEk7XG4gICAgICAgIHRoaXMuc3ggPSB0aGlzLnMgKiBNYXRoLmNvcyh0aGlzLnNhKVxuICAgICAgICB0aGlzLnN5ID0gdGhpcy5zICogTWF0aC5zaW4odGhpcy5zYSlcbiAgICB9XG5cbiAgICAvKiogKi9cbiAgICBjb21wdXRlU3BlZWQoKSB7XG4gICAgICAgIHRoaXMucyA9IE1hdGguaHlwb3QodGhpcy5zeCwgdGhpcy5zeSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNcbiAgICB9XG5cbiAgICAvKiogKi9cbiAgICBjb21wdXRlU3BlZWRBbmdsZSgpIHtcbiAgICAgICAgdGhpcy5zYSA9IE1hdGguYXRhbjIodGhpcy5zeSwgdGhpcy5zeCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNhXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuLyoqIEB0eXBlZGVmIHsge3hNaW46IG51bWJlciwgeE1heDogbnVtYmVyLCB5TWluOiBudW1iZXIsIHlNYXg6IG51bWJlcn0gfSBFbnZlbG9wZSAqL1xuXG5pbXBvcnQgeyB6b29tIGFzIGQzem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSBcImQzLXpvb21cIjtcbmltcG9ydCB7IHNlbGVjdCBhcyBkM3NlbGVjdCB9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuLyoqXG4gKiBBIEhUTUwgY2FudmFzIGZvciBnZW8gZGF0YSBkaXNwbGF5LCBlbmhhbmNlZCB3aXRoIHpvb20gYW5kIHBhbiBjYXBhYmlsaXRpZXMuXG4gKiBcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcbiAqL1xuZXhwb3J0IGNsYXNzIEdlb0NhbnZhcyB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2VudGVyIEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpmIFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzSWQgPSBcInZhY2FudmFzXCIsIGNlbnRlciA9IHVuZGVmaW5lZCwgemYgPSAxKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtvYmplY3R9ICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IHRoaXMuY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMudztcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oO1xuXG4gICAgICAgIC8qKkB0eXBlIHtvYmplY3R9ICovXG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIC8vIHNldCBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlclxuICAgICAgICB0aGlzLnNldENlbnRlcihjZW50ZXIgfHwgeyB4OiB0aGlzLncgKiAwLjUsIHk6IHRoaXMuaCAqIDAuNSB9KVxuXG4gICAgICAgIC8vIHNldCB6b29tIGZhY3RvcjogcGl4ZWwgc2l6ZSwgaW4gbS9waXhcbiAgICAgICAgdGhpcy5zZXRaZih6Zik7XG5cbiAgICAgICAgLy9leHRlbnRcbiAgICAgICAgLyoqIEB0eXBlIHtFbnZlbG9wZX0gKi9cbiAgICAgICAgdGhpcy5leHRHZW8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcblxuICAgICAgICAvL3JlbHkgb24gZDMgem9vbSBmb3IgcGFuL3pvb21cbiAgICAgICAgbGV0IHRQID0gem9vbUlkZW50aXR5XG4gICAgICAgIGQzc2VsZWN0KHRoaXMuY2FudmFzKS5jYWxsKFxuICAgICAgICAgICAgZDN6b29tKCkub24oXCJ6b29tXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUudHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IHRQLmsgLyB0LmtcbiAgICAgICAgICAgICAgICBpZiAoZiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcGFuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gdFAueCAtIHQueFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeSA9IHRQLnkgLSB0LnlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW4oZHggKiB0aGlzLmdldFpmKCksIC1keSAqIHRoaXMuZ2V0WmYoKSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZSA9IGUuc291cmNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZSBpbnN0YW5jZW9mIFdoZWVsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vem9vbSBhdCB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbShmLCB0aGlzLnBpeFRvR2VvWChlLnNvdXJjZUV2ZW50Lm9mZnNldFgpLCB0aGlzLnBpeFRvR2VvWShlLnNvdXJjZUV2ZW50Lm9mZnNldFkpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlIGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIHRvdWNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eCA9IDAsIHR5ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHQgb2Ygc2UudGFyZ2V0VG91Y2hlcykgeyB0eCArPSB0dC5jbGllbnRYOyB0eSArPSB0dC5jbGllbnRZIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR4IC89IHNlLnRhcmdldFRvdWNoZXMubGVuZ3RoOyB0eSAvPSBzZS50YXJnZXRUb3VjaGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy96b29tIGF0IHRoaXMgYXZlcmFnZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tKGYsIHRoaXMucGl4VG9HZW9YKHR4KSwgdGhpcy5waXhUb0dlb1kodHkpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRQID0gdFxuICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IHYgR2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXIgKi9cbiAgICBzZXRDZW50ZXIodikgeyB0aGlzLmNlbnRlciA9IHY7IH1cbiAgICAvKiogQHJldHVybnMge3t4Om51bWJlcix5Om51bWJlcn19IEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyICovXG4gICAgZ2V0Q2VudGVyKCkgeyByZXR1cm4gdGhpcy5jZW50ZXI7IH1cblxuICAgIC8qKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgem9vbSBmYWN0b3IgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKSAqL1xuICAgIHNldFpmKHYpIHsgdGhpcy56ZiA9IHY7IH1cbiAgICAvKiogQHJldHVybnMge251bWJlcn0gVGhlIHpvb20gZmFjdG9yIChwaXhlbCBzaXplLCBpbiBncm91bmQgbSkgKi9cbiAgICBnZXRaZigpIHsgcmV0dXJuIHRoaXMuemY7IH1cblxuXG5cblxuICAgIC8qKiBJbml0aWFsaXNlIGNhbnZhcyB0cmFuc2Zvcm0gd2l0aCBpZGVudGl0eSB0cmFuc2Zvcm1hdGlvbi4gKi9cbiAgICBpbml0Q2FudmFzVHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqIEluaXRpYWxpc2UgY2FudmFzIHRyYW5zZm9ybSB3aXRoIGdlbyB0byBzY3JlZW4gdHJhbnNmb3JtYXRpb24sIHNvIHRoYXQgZ2VvIG9iamVjdHMgY2FuIGJlIGRyYXduIGRpcmVjdGx5IGluIGdlbyBjb29yZGluYXRlcy4gKi9cbiAgICBzZXRDYW52YXNUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIC8gdGhpcy5nZXRaZigpO1xuICAgICAgICBjb25zdCB0eCA9IC10aGlzLmNlbnRlci54IC8gdGhpcy5nZXRaZigpICsgdGhpcy53ICogMC41O1xuICAgICAgICBjb25zdCB0eSA9IHRoaXMuY2VudGVyLnkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLmggKiAwLjU7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShrLCAwLCAwLCAtaywgdHgsIHR5KTtcbiAgICB9XG5cblxuICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyBob3cgdG8gZHJhdyB0aGUgbWFwLiAqL1xuICAgIHJlZHJhdygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgcmVkcmF3IG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgYXBwIHNjcmVlbi4gVG8gYmUgdXNlZCBiZWZvcmUgYSByZWRyYXcgZm9yIGV4YW1wbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIFxuICAgICAqL1xuICAgIGNsZWFyKGNvbG9yID0gXCJ3aGl0ZVwiKSB7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG4gICAgfVxuXG4gICAgLy9jb252ZXJzaW9uIGZ1bmN0aW9uc1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4R2VvIEdlbyB4IGNvb3JkaW5hdGUsIGluIG0uXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2NyZWVuIHggY29vcmRpbmF0ZSwgaW4gcGl4LlxuICAgICovXG4gICAgZ2VvVG9QaXhYKHhHZW8pIHsgcmV0dXJuICh4R2VvIC0gdGhpcy5jZW50ZXIueCkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLncgKiAwLjU7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUdlbyBHZW8geSBjb29yZGluYXRlLCBpbiBtLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNjcmVlbiB5IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAqL1xuICAgIGdlb1RvUGl4WSh5R2VvKSB7IHJldHVybiAtKHlHZW8gLSB0aGlzLmNlbnRlci55KSAvIHRoaXMuZ2V0WmYoKSArIHRoaXMuaCAqIDAuNTsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjcmVlbiB4IGNvb3JkaW5hdGUsIGluIHBpeC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBHZW8geCBjb29yZGluYXRlLCBpbiBtLlxuICAgICovXG4gICAgcGl4VG9HZW9YKHgpIHsgcmV0dXJuICh4IC0gdGhpcy53ICogMC41KSAqIHRoaXMuZ2V0WmYoKSArIHRoaXMuY2VudGVyLng7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBTY3JlZW4geSBjb29yZGluYXRlLCBpbiBwaXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHkgY29vcmRpbmF0ZSwgaW4gbS5cbiAgICAqL1xuICAgIHBpeFRvR2VvWSh5KSB7IHJldHVybiAtKHkgLSB0aGlzLmggKiAwLjUpICogdGhpcy5nZXRaZigpICsgdGhpcy5jZW50ZXIueTsgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4R2VvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5R2VvXG4gICAgICovXG4gICAgcGFuKGR4R2VvLCBkeUdlbykge1xuICAgICAgICAvL1RPRE8gZm9yY2UgZXh0ZW5kIHRvIHJlbWFpblxuICAgICAgICB0aGlzLmNlbnRlci54ICs9IGR4R2VvO1xuICAgICAgICB0aGlzLmNlbnRlci55ICs9IGR5R2VvO1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWm9vbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiBUaGUgem9vbSBmYWN0b3IsIHdpdGhpbiBdMCwgSW5maW5pdHldLiAxIGlzIGZvciBubyBjaGFuZ2UuIDwxIHRvIHpvb20taW4sID4xIHRvIHpvb20tb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4R2VvIFRoZSB4IGdlbyBwb3NpdGlvbiBmaXhlZCBpbiB0aGUgc2NyZWVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5R2VvIFRoZSB5IGdlbyBwb3NpdGlvbiBmaXhlZCBpbiB0aGUgc2NyZWVuLlxuICAgICAqL1xuICAgIHpvb20oZiA9IDEsIHhHZW8gPSB0aGlzLmNlbnRlci54LCB5R2VvID0gdGhpcy5jZW50ZXIueSkge1xuICAgICAgICAvL1RPRE8gZm9yY2UgZXh0ZW5kIHRvIHJlbWFpblxuICAgICAgICB0aGlzLnNldFpmKGYgKiB0aGlzLmdldFpmKCkpO1xuICAgICAgICB0aGlzLmNlbnRlci54ICs9ICh4R2VvIC0gdGhpcy5jZW50ZXIueCkgKiAoMSAtIGYpXG4gICAgICAgIHRoaXMuY2VudGVyLnkgKz0gKHlHZW8gLSB0aGlzLmNlbnRlci55KSAqICgxIC0gZilcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRHZW8oKVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5QeCBcbiAgICAgKiBAcmV0dXJucyB7RW52ZWxvcGV9IFRoZSBlbnZlbG9wZSBvZiB0aGUgdmlldywgaW4gZ2VvIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIHVwZGF0ZUV4dGVudEdlbyhtYXJnaW5QeCA9IDIwKSB7XG4gICAgICAgIHRoaXMuZXh0R2VvID0ge1xuICAgICAgICAgICAgeE1pbjogdGhpcy5waXhUb0dlb1goLW1hcmdpblB4KSxcbiAgICAgICAgICAgIHhNYXg6IHRoaXMucGl4VG9HZW9YKHRoaXMudyArIG1hcmdpblB4KSxcbiAgICAgICAgICAgIHlNaW46IHRoaXMucGl4VG9HZW9ZKHRoaXMuaCArIG1hcmdpblB4KSxcbiAgICAgICAgICAgIHlNYXg6IHRoaXMucGl4VG9HZW9ZKC1tYXJnaW5QeClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHRHZW87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIG9iamVjdCBoYXMgdG8gYmUgZHJhd25cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IG9iaiBcbiAgICAgKi9cbiAgICB0b0RyYXcob2JqKSB7XG4gICAgICAgIGlmIChvYmoueCA8IHRoaXMuZXh0R2VvLnhNaW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9iai54ID4gdGhpcy5leHRHZW8ueE1heCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob2JqLnkgPCB0aGlzLmV4dEdlby55TWluKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvYmoueSA+IHRoaXMuZXh0R2VvLnlNYXgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5cbi8vc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoXG5pbXBvcnQgUkJ1c2ggZnJvbSAncmJ1c2gnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGF0aWFsSW5kZXgge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNsYXNzIE15UkJ1c2ggZXh0ZW5kcyBSQnVzaCB7XG4gICAgICAgICAgICAvKiogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBvYmogICovXG4gICAgICAgICAgICB0b0JCb3gob2JqKSB7IHJldHVybiB7IG1pblg6IG9iai54LCBtaW5ZOiBvYmoueSwgbWF4WDogb2JqLngsIG1heFk6IG9iai55IH07IH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBhIFxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBiIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb21wYXJlTWluWChhLCBiKSB7IHJldHVybiBhLnggLSBiLng7IH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBhIFxuICAgICAgICAgICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBiIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb21wYXJlTWluWShhLCBiKSB7IHJldHVybiBhLnkgLSBiLnk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7TXlSQnVzaH0gKi9cbiAgICAgICAgdGhpcy50cmVlID0gbmV3IE15UkJ1c2goKTtcbiAgICB9XG5cbiAgICAvL1RPRE8gYnVsayByZW1vdmUgP1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geW1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4bWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHltYXhcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48VD59XG4gICAgICovXG4gICAgZ2V0KHhtaW4sIHltaW4sIHhtYXgsIHltYXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5zZWFyY2goe1xuICAgICAgICAgICAgbWluWDogeG1pbixcbiAgICAgICAgICAgIG1pblk6IHltaW4sXG4gICAgICAgICAgICBtYXhYOiB4bWF4LFxuICAgICAgICAgICAgbWF4WTogeW1heFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R9IG9ialxuICAgICAqL1xuICAgIGluc2VydChvYmopIHtcbiAgICAgICAgdGhpcy50cmVlLmluc2VydChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1bGsgaW5zZXJ0XG4gICAgICogXG4gICAgICogQHBhcmFtIHtBcnJheS48VD59IG9ianNcbiAgICAgKi9cbiAgICBsb2FkKG9ianMpIHtcbiAgICAgICAgdGhpcy50cmVlLmxvYWQob2Jqcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUfSBvYmpcbiAgICAgKi9cbiAgICByZW1vdmUob2JqKSB7XG4gICAgICAgIHRoaXMudHJlZS5yZW1vdmUob2JqKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnRyZWUuY2xlYXIoKVxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7T2JqZWN0Ljw/LCBUPn0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXkuPFQ+fVxuICovXG5leHBvcnQgY29uc3Qgb2JqVG9BcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgb3V0LnB1c2gob2JqW2tleV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyXG4gKiBAcGFyYW0ge1R9IG9ialxuICogQHBhcmFtIHtib29sZWFufSBtc2cgXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBvYmosIG1zZyA9IHRydWUpIHtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihvYmopO1xuICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBlbHNlXG4gICAgICAgIGlmIChtc2cpIGNvbnNvbGUubG9nKFwiSW1wb3NzaWJsZSB0byByZW1vdmUgZWxlbWVudCBub3QgcHJlc2VudCBpbiBhcnJheS5cIik7XG59O1xuXG4vKipcbiAqIFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnJcbiAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBvYmpzIFxuICogQHBhcmFtIHtib29sZWFufSBtc2cgXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVGcm9tQXJyYXlTID0gZnVuY3Rpb24gKGFyciwgb2JqcywgbXNnID0gdHJ1ZSkge1xuICAgIGZvciAobGV0IG9iaiBvZiBvYmpzKVxuICAgICAgICByZW1vdmVGcm9tQXJyYXkoYXJyLCBvYmosIG1zZylcbn07XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU2VhIH0gZnJvbSBcIi4vU2VhXCJcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gXCIuLi9iYXNlL0dlb0NhbnZhc1wiXG5pbXBvcnQgeyBBZ2VudFBvaW50IH0gZnJvbSBcIi4uL2Jhc2UvQWdlbnRQb2ludFwiO1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuXG4vKiogKi9cbmV4cG9ydCBjbGFzcyBTYXJkaW4gZXh0ZW5kcyBBZ2VudFBvaW50IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2VhfSBzZWEgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZWEsIHggPSBzZWEudyAqIE1hdGgucmFuZG9tKCksIHkgPSBzZWEuaCAqIE1hdGgucmFuZG9tKCksIHN4ID0gdW5kZWZpbmVkLCBzeSA9IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIC8vXG4gICAgICAgIHN1cGVyKHgsIHksIHN4LCBzeSlcblxuICAgICAgICAvKiogQHR5cGUge1NlYX0gKi9cbiAgICAgICAgdGhpcy5zZWEgPSBzZWE7XG5cbiAgICAgICAgLy9wb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geCA8IDAgPyAwIDogeCA+IHNlYS53ID8gc2VhLncgOiB4XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnkgPSB5IDwgMCA/IDAgOiB5ID4gc2VhLmggPyBzZWEuaCA6IHlcblxuICAgICAgICAvL3NwZWVkXG4gICAgICAgIGlmICghc3ggJiYgIXN5KSB7XG4gICAgICAgICAgICB0aGlzLnNldFJhbmRvbVNwZWVkKDAsIHRoaXMuc2VhLlZfTUFYKVxuXG4gICAgICAgICAgICAvL2FjY2VsZXJhdGlvblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICB0aGlzLmF4ID0gMFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICB0aGlzLmF5ID0gMFxuXG4gICAgICAgICAgICAvL2xpc3Qgb2Ygc2FyZGlucyBpbiB2aXNpb24gZmllbGRcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgICAgICB0aGlzLm9icyA9IFtdXG4gICAgICAgICAgICAvL2xpc3Qgb2Ygc2FyZGlucyBpbiBjb2xsaXNpb24gZmllbGRcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgICAgICB0aGlzLmNvbCA9IFtdXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3BhdGlhbEluZGV4LjxTYXJkaW4+fSBzaW5kZXggXG4gICAgICovXG4gICAgb2JzZXJ2ZShzaW5kZXgpIHtcblxuICAgICAgICAvKiogQHR5cGUge1NlYX0gKi9cbiAgICAgICAgY29uc3QgcyA9IHRoaXMuc2VhXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBjb25zdCBkTyA9IHMuRF9PQlNcblxuICAgICAgICAvL2luaXRpYWxpc2UgbGlzdHNcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5vYnMgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5jb2wgPSBbXTtcblxuICAgICAgICAvL2dldCBzYXJkaW5zIGFyb3VuZCB1c2luZyBzcGF0aWFsIGluZGV4XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFNhcmRpbj59ICovXG4gICAgICAgIGNvbnN0IHNzID0gc2luZGV4LmdldCh0aGlzLnggLSBkTywgdGhpcy55IC0gZE8sIHRoaXMueCArIGRPLCB0aGlzLnkgKyBkTyk7XG5cbiAgICAgICAgLy9nZXQgc2FyZGlucyBpbiBvYnNlcnZhdGlvbiBhbmQgY29sbGlzaW9uIGZpZWxkc1xuICAgICAgICBmb3IgKGxldCBmIG9mIHNzKSB7XG4gICAgICAgICAgICBpZiAoZiA9PSB0aGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmQoZikgPD0gcy5EX0NPTClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbC5wdXNoKGYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZChmKSA8PSBkTykge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgYW5nbGVcbiAgICAgICAgICAgICAgICBsZXQgZGEgPSBNYXRoLmF0YW4yKGYueSAtIHRoaXMueSwgZi54IC0gdGhpcy54KSAtIHRoaXMuc2E7XG4gICAgICAgICAgICAgICAgaWYgKGRhID4gTWF0aC5QSSkgZGEgLT0gMiAqIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGEgPD0gLU1hdGguUEkpIGRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIGRhID0gTWF0aC5hYnMoZGEpO1xuICAgICAgICAgICAgICAgIGlmIChkYSA+IHMuQV9PQlMgKiAwLjUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRoaXMub2JzLnB1c2goZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2luaXRpYWxpc2UgYWNjZWxlcmF0aW9uXG4gICAgICAgIHRoaXMuYXggPSAwOyB0aGlzLmF5ID0gMDtcblxuICAgICAgICAvL2NvbGxpc2lvbjogcmVwdWxzaW9uXG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5jb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmQoZik7XG4gICAgICAgICAgICBjb25zdCBhID0gMS4wICogKDEgLyAoZCAqIGQpIC0gMSAvIChzLkRfQ09MICogcy5EX0NPTCkpO1xuICAgICAgICAgICAgdGhpcy5heCArPSBhICogKHRoaXMueCAtIGYueCkgLyBkO1xuICAgICAgICAgICAgdGhpcy5heSArPSBhICogKHRoaXMueSAtIGYueSkgLyBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG93YXJkIHRhcmdldCBzcGVlZFxuICAgICAgICBjb25zdCBkdiA9IChzLlZfVEFSR0VUIC0gdGhpcy5zKSAqIDAuMDE7XG4gICAgICAgIHRoaXMuYXggKz0gZHYgKiB0aGlzLnN4IC8gdGhpcy5zO1xuICAgICAgICB0aGlzLmF5ICs9IGR2ICogdGhpcy5zeSAvIHRoaXMucztcblxuICAgICAgICAvL3Rvd2FyZCB0aGUgb2JzZXJ2ZWQgbWVhbiBwb3NpdGlvblxuICAgICAgICAvKmlmKG9icy5zaXplKCk+MSl7XG4gICAgICAgICAgICBkb3VibGUgeG49MCx5bj0wO1xuICAgICAgICAgICAgZm9yKFNhcmRpbiBzOm9icyl7XG4gICAgICAgICAgICAgICAgeG4rPXMueDtcbiAgICAgICAgICAgICAgICB5bis9cy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeG49eG4vb2JzLnNpemUoKTtcbiAgICAgICAgICAgIHluPXluL29icy5zaXplKCk7XG4gICAgICAgICAgICBkb3VibGUgZD1NYXRoLmh5cG90KHhuLXgseW4teSk7XG4gICAgICAgICAgICBheCs9LTAuMSooeC14bikvZDtcbiAgICAgICAgICAgIGF5Kz0tMC4xKih5LXluKS9kO1xuICAgICAgICB9Ki9cblxuICAgICAgICAvL3Rvd2FyZCB0aGUgb2JzZXJ2ZWQgc3BlZWRcbiAgICAgICAgY29uc3QgdCA9IDAuOTtcbiAgICAgICAgaWYgKHRoaXMub2JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBkc3ggPSAwLCBkc3kgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLm9icykge1xuICAgICAgICAgICAgICAgIGRzeCArPSBzLnN4O1xuICAgICAgICAgICAgICAgIGRzeSArPSBzLnN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHN4ID0gKHQgLSAxKSAqIHRoaXMuc3ggKyAoMSAtIHQpICogZHN4IC8gdGhpcy5vYnMubGVuZ3RoO1xuICAgICAgICAgICAgZHN5ID0gKHQgLSAxKSAqIHRoaXMuc3kgKyAoMSAtIHQpICogZHN5IC8gdGhpcy5vYnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBjb25zdCBhID0gMC4xO1xuICAgICAgICAgICAgdGhpcy5heCArPSBhICogZHN4O1xuICAgICAgICAgICAgdGhpcy5heSArPSBhICogZHN5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hdm9pZCBzaGFya1xuICAgICAgICBjb25zdCBzaCA9IHMuc2hhcms7XG4gICAgICAgIGlmIChzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gTWF0aC5oeXBvdCgoc2gueCAtIHRoaXMueCksIChzaC55IC0gdGhpcy55KSk7XG4gICAgICAgICAgICBpZiAoZCA8PSBzLkRfT0JTKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IDUuMCAqICgxIC8gKGQgKiBkKSAtIDEgLyAoZE8gKiBkTykpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXggKz0gYSAqICh0aGlzLnggLSBzaC54KSAvIGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5heSArPSBhICogKHRoaXMueSAtIHNoLnkpIC8gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBtb3ZlKHRpbWVTdGVwTXMgPSAxMCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBuZXcgc3BlZWRcbiAgICAgICAgdGhpcy5zeCArPSB0aGlzLmF4ICogdGltZVN0ZXBNcyArICgxIC0gMiAqIE1hdGgucmFuZG9tKCkpICogMC4wMjtcbiAgICAgICAgdGhpcy5zeSArPSB0aGlzLmF5ICogdGltZVN0ZXBNcyArICgxIC0gMiAqIE1hdGgucmFuZG9tKCkpICogMC4wMjtcbiAgICAgICAgdGhpcy5zID0gdGhpcy5jb21wdXRlU3BlZWQoKVxuICAgICAgICBpZiAodGhpcy5zID4gdGhpcy5zZWEuVl9NQVgpIHtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMuc2VhLlZfTUFYO1xuICAgICAgICAgICAgdGhpcy5zeCA9IHRoaXMuc2VhLlZfTUFYICogTWF0aC5jb3ModGhpcy5zYSk7XG4gICAgICAgICAgICB0aGlzLnN5ID0gdGhpcy5zZWEuVl9NQVggKiBNYXRoLnNpbih0aGlzLnNhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBuZXcgcG9zaXRpb25cbiAgICAgICAgdGhpcy54ICs9IHRoaXMuc3ggKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy5zeSAqIHRpbWVTdGVwTXM7XG5cbiAgICAgICAgLy9saW1pdFxuICAgICAgICBpZiAodGhpcy54IDwgMCkgdGhpcy54ID0gdGhpcy5zZWEudztcbiAgICAgICAgaWYgKHRoaXMueSA8IDApIHRoaXMueSA9IHRoaXMuc2VhLmg7XG4gICAgICAgIGlmICh0aGlzLnggPiB0aGlzLnNlYS53KSB0aGlzLnggPSAwO1xuICAgICAgICBpZiAodGhpcy55ID4gdGhpcy5zZWEuaCkgdGhpcy55ID0gMDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgYSBzYXJkaW4gYm9keVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjb25zdCBjID0gTWF0aC5mbG9vcigyNTUgKiBNYXRoLmFicyh0aGlzLnNhKSAvIE1hdGguUEkpO1xuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwicmdiKDI1NSwgMjU1LCBcIiArIGMgKyBcIilcIlxuICAgICAgICBjb25zdCBhID0gbGVuZ3RoIC8gdGhpcy5zO1xuICAgICAgICBjb25zdCBkeCA9IGEgKiB0aGlzLnN4ICogMC41O1xuICAgICAgICBjb25zdCBkeSA9IGEgKiB0aGlzLnN5ICogMC41O1xuXG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5tb3ZlVG8odGhpcy54IC0gZHgsIHRoaXMueSAtIGR5KTtcbiAgICAgICAgYzIubGluZVRvKHRoaXMueCArIGR4LCB0aGlzLnkgKyBkeSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5zdHJva2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHNhcmRpbiB2aXNpb24gZmllbGRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGxTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqL1xuICAgIGRpc3BsYXlWaXNpb25GaWVsZChjcCwgZmlsbFN0eWxlLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLm1vdmVUbyh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGMyLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5zZWEuRF9PQlMgLyBjcC5nZXRaZigpLFxuICAgICAgICAgICAgdGhpcy5zYSAtIHRoaXMuc2VhLkFfT0JTICogMC41LFxuICAgICAgICAgICAgdGhpcy5zYSArIHRoaXMuc2VhLkFfT0JTICogMC41XG4gICAgICAgICk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5maWxsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBzYXJkaW4gdmlzaW9uIGxpbmtzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqL1xuICAgIGRpc3BsYXlWaXNpb25MaW5rcyhjcCwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGZvciAobGV0IHNhMiBvZiB0aGlzLm9icykge1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5tb3ZlVG8odGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgYzIubGluZVRvKHNhMi54LCBzYTIueSk7XG4gICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBzYXJkaW4gY29sbGlzaW9uIGZpZWxkXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqL1xuICAgIGRpc3BsYXlDb2xsaXNpb25GaWVsZChjcCwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuc2VhLkRfQ09MICogMC41IC8gY3AuZ2V0WmYoKSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU2FyZGluIH0gZnJvbSAnLi9TYXJkaW4nO1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgcmVtb3ZlRnJvbUFycmF5IH0gZnJvbSAnLi4vYmFzZS9saWInO1xuXG4vKiogKi9cbmV4cG9ydCBjbGFzcyBTZWEge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggXG4gICAgICovICAgICAgICAvL2dldCAxMCByYW5kb20gbG9jYXRpb25zXG5cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG5cbiAgICAgICAgLy9UT0RPIHNob3VsZCBiZWNvbWUgc3RhdGljIGF0dHJpYnV0ZXMgb2YgU2FyZGluIGNsYXNzXG5cbiAgICAgICAgLy9vYnNlcnZhdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5EX09CUyA9IDUwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkFfT0JTID0gMjAwICogTWF0aC5QSSAvIDE4MFxuXG4gICAgICAgIC8vY29sbGlzaW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkRfQ09MID0gMTBcblxuICAgICAgICAvL3NwZWVkXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLlZfVEFSR0VUID0gMC4zXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLlZfTUFYID0gMC42XG5cbiAgICAgICAgLy9zaGFya1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5EX1NIQVJLX0VBVCA9IDEyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLkVBVEVOX1NBUkRJTl9OQiA9IDBcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICB0aGlzLmZpc2ggPSBbXVxuXG4gICAgICAgIC8vVE9ET1xuICAgICAgICB0aGlzLnNoYXJrID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxTYXJkaW4+fSAqL1xuICAgICAgICB0aGlzLmtpbGxlZCA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqL1xuICAgIHN0ZXAodGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9pbmlcbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmZpc2gpIHtcbiAgICAgICAgICAgIGYuY29tcHV0ZVNwZWVkKClcbiAgICAgICAgICAgIGYuY29tcHV0ZVNwZWVkQW5nbGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9tYWtlIHNwYXRpYWwgaW5kZXhcbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPFNhcmRpbj59ICovXG4gICAgICAgIGNvbnN0IHNpbmRleCA9IG5ldyBTcGF0aWFsSW5kZXgoKTtcbiAgICAgICAgc2luZGV4LmxvYWQodGhpcy5maXNoKVxuXG4gICAgICAgIC8vb2JzZXJ2ZVxuICAgICAgICBmb3IgKGxldCBmIG9mIHRoaXMuZmlzaClcbiAgICAgICAgICAgIGYub2JzZXJ2ZShzaW5kZXgpO1xuXG4gICAgICAgIC8vc2hhcmsgZWF0IGZpc2hcbiAgICAgICAgdGhpcy5zaGFya0VhdChzaW5kZXgpO1xuXG4gICAgICAgIC8vZGlzcG9zZSBzcGF0aWFsIGluZGV4XG4gICAgICAgIC8vc2luZGV4LmNsZWFyKClcblxuICAgICAgICAvL21vdmVcbiAgICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLmZpc2gpXG4gICAgICAgICAgICBmLm1vdmUodGltZVN0ZXBNcyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48U2FyZGluPn0gc2luZGV4IFxuICAgICAqL1xuICAgIHNoYXJrRWF0KHNpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zaGFyayA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48U2FyZGluPn0gKi9cbiAgICAgICAgdGhpcy5raWxsZWQgPSBbXTtcblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5zaGFyay54LCB5ID0gdGhpcy5zaGFyay55O1xuICAgICAgICBjb25zdCBzcyA9IHNpbmRleC5nZXQoeCAtIHRoaXMuRF9TSEFSS19FQVQsIHkgLSB0aGlzLkRfU0hBUktfRUFULCB4ICsgdGhpcy5EX1NIQVJLX0VBVCwgeSArIHRoaXMuRF9TSEFSS19FQVQpO1xuICAgICAgICBmb3IgKGxldCBzIG9mIHNzKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gTWF0aC5oeXBvdCgoeCAtIHMueCksICh5IC0gcy55KSk7XG4gICAgICAgICAgICBpZiAoZCA+IHRoaXMuRF9TSEFSS19FQVQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5raWxsZWQucHVzaChzKTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLmZpc2gsIHMpXG4gICAgICAgICAgICAvL3NpbmRleC5yZW1vdmUocyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5FQVRFTl9TQVJESU5fTkIgKz0gdGhpcy5raWxsZWQubGVuZ3RoO1xuICAgICAgICAvL2VhdGVuRmlzaE5iLnNldFRleHQoXCJFYXRlbiBmaXNoOiBcIiArIEVBVEVOX1NBUkRJTl9OQik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBmaXNoXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGFkZEZpc2gobmIgPSAxKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKylcbiAgICAgICAgICAgIHRoaXMuZmlzaC5wdXNoKG5ldyBTYXJkaW4odGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCByYW5kb20gc3BlZWQgZm9yIGFsbCBmaXNoXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0UmFuZG9tU3BlZWQoKSB7XG4gICAgICAgIGZvciAobGV0IGYgb2YgdGhpcy5maXNoKVxuICAgICAgICAgICAgZi5zZXRSYW5kb21TcGVlZCgpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU2VhIH0gZnJvbSAnLi9TZWEnO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi4vYmFzZS9HZW9DYW52YXMnO1xuXG5jbGFzcyBGaXNoU2ltdWxhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvL1RPRE9cbiAgICAgICAgLy9hZGQgZWF0ZW4gZmlzaCBuYiBsYWJlbFxuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd0Zpc2hWaXNpb25GaWVsZCA9IGZhbHNlXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5zaG93RmlzaFZpc2lvbkxpbmtzID0gZmFsc2VcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLnNob3dGaXNoQ29sbGlzaW9uRmllbGQgPSBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHRoID0gdGhpcztcbiAgICAgICAgdGhpcy5jcGx1cy5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuY3R4XG4gICAgICAgICAgICBjb25zdCBzID0gdGguc2VhXG5cbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXG5cbiAgICAgICAgICAgIC8vY2xlYXJcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmdiYSgxMjAsMTIwLDI1NSwwLjYpXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcblxuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL3Nob3cgdmlzaW9uIGZpZWxkXG4gICAgICAgICAgICBpZiAodGguc2hvd0Zpc2hWaXNpb25GaWVsZClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzYS5kaXNwbGF5VmlzaW9uRmllbGQodGhpcywgXCJyZ2JhKDIwMCwyMDAsMjAwLDAuMTUpXCIsIDEpXG4gICAgICAgICAgICAvL3Nob3cgdmlzaW9uIGxpbmtzXG4gICAgICAgICAgICBpZiAodGguc2hvd0Zpc2hWaXNpb25MaW5rcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhzYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzYS5kaXNwbGF5VmlzaW9uTGlua3ModGhpcywgXCJyZ2JhKDI1NSwxMDAsMTAwLDAuMylcIiwgMSlcbiAgICAgICAgICAgIC8vc2hvdyBjb2xsaXNpb24gZmllbGRcbiAgICAgICAgICAgIGlmICh0aC5zaG93RmlzaENvbGxpc2lvbkZpZWxkKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNhIG9mIHMuZmlzaClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KHNhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhLmRpc3BsYXlDb2xsaXNpb25GaWVsZCh0aGlzLCBcInB1cnBsZVwiLCAxKVxuXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBzYXJkaW5zXG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAyXG4gICAgICAgICAgICBjb25zdCBzYXJkaW5MZW5ndGggPSA3XG4gICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmZpc2gpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9EcmF3KHNhKSlcbiAgICAgICAgICAgICAgICAgICAgc2EuZGlzcGxheSh0aGlzLCBzYXJkaW5MZW5ndGgpXG5cblxuICAgICAgICAgICAgLy9kaXNwbGF5IHNoYXJrXG4gICAgICAgICAgICBpZiAocy5zaGFyayAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICBjMi5saW5lV2lkdGggPSA0XG4gICAgICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCJcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJrTGVuZ3RoID0gMTJcbiAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHNoYXJrTGVuZ3RoICogTWF0aC5jb3Mocy5zaGFyay5hbmdsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHkgPSBzaGFya0xlbmd0aCAqIE1hdGguc2luKHMuc2hhcmsuYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgYzIubW92ZVRvKHMuc2hhcmsueCwgcy5zaGFyay55KTtcbiAgICAgICAgICAgICAgICBjMi5saW5lVG8ocy5zaGFyay54IC0gZHgsIHMuc2hhcmsueSArIGR5KTtcbiAgICAgICAgICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjMi5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kaXNwbGF5IGJsb29kIHNwb3RcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxXG4gICAgICAgICAgICBmb3IgKGxldCBzYSBvZiBzLmtpbGxlZCkge1xuICAgICAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLm1vdmVUbyhzYS54LCBzYS55KTtcbiAgICAgICAgICAgICAgICBjMi5hcmMoc2EueCwgc2EueSwgNCwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLmZpbGwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNwbHVzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGUgPT4ge1xuICAgICAgICAgICAgdGguc2VhLnNoYXJrID0geyB4OiB0aC5jcGx1cy5waXhUb0dlb1goZS5vZmZzZXRYKSwgeTogdGguY3BsdXMucGl4VG9HZW9ZKGUub2Zmc2V0WSksIGFuZ2xlOiAwIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3BsdXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB4RyA9IHRoLmNwbHVzLnBpeFRvR2VvWChlLm9mZnNldFgpO1xuICAgICAgICAgICAgY29uc3QgeUcgPSB0aC5jcGx1cy5waXhUb0dlb1koZS5vZmZzZXRZKTtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMigteUcgKyB0aC5zZWEuc2hhcmsueSwgeEcgLSB0aC5zZWEuc2hhcmsueCk7XG4gICAgICAgICAgICB0aC5zZWEuc2hhcmsgPSB7IHg6IHhHLCB5OiB5RywgYW5nbGU6IGFuZ2xlIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3BsdXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoLnNlYS5zaGFyayA9IG51bGw7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtTZWF9ICovXG4gICAgICAgIHRoaXMuc2VhID0gbmV3IFNlYSh0aGlzLncsIHRoaXMuaClcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHkgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdFJhbmRvbShkZW5zaXR5ID0gMC4wMDEpIHtcbiAgICAgICAgdGhpcy5zZWEuYWRkRmlzaChkZW5zaXR5ICogdGhpcy5zZWEudyAqIHRoaXMuc2VhLmgpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYkl0ZXJhdGlvbnMgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc3RhcnQodGltZVN0ZXBNcyA9IDEwLCBuYkl0ZXJhdGlvbnMgPSAtMSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0LnNlYS5zdGVwKHRpbWVTdGVwTXMpO1xuICAgICAgICAgICAgdC5jcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYkl0ZXJhdGlvbnMgPiAwICYmIGkrKyA+IG5iSXRlcmF0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGVuZ2luZSgpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICovXG5leHBvcnQgY29uc3QgZmlzaCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBGaXNoU2ltdWxhdGlvbihvcHRzKVxufVxuIiwiLy9AdHMtY2hlY2tcblxuLyoqXG4gKiBcbiAqL1xuZXhwb3J0IGNsYXNzIENlbGwge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIG5iPTApIHtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubmIgPSBuYlxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IG9ialRvQXJyYXkgfSBmcm9tICcuLi9iYXNlL2xpYic7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5pbXBvcnQgeyBDZWxsIH0gZnJvbSAnLi9DZWxsJztcblxuLyoqXG4gKiBcbiAqL1xuZXhwb3J0IGNsYXNzIFVuaXZlcnNlIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBoO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPENlbGw+fSAqL1xuICAgICAgICB0aGlzLnBvcHVsYXRpb24gPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxDZWxsPn0gKi9cbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uSSA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Q2VsbHxudWxsfVxuICAgICAqL1xuICAgIGFkZCh4LCB5KSB7XG5cbiAgICAgICAgLy9maW5kIGNlbGwgYXQgbG9jYXRpb25cbiAgICAgICAgLyoqQHR5cGUge3N0cmluZ30qL1xuICAgICAgICBjb25zdCBpZCA9IHggKyBcIl9cIiArIHk7XG4gICAgICAgIGlmICh0aGlzLnBvcHVsYXRpb25JW2lkXSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy9jcmVhdGUgbmV3IGNlbGxcbiAgICAgICAgLyoqQHR5cGUge0NlbGx9ICovXG4gICAgICAgIGNvbnN0IGNlbGwgPSBuZXcgQ2VsbCh4LCB5LCAwKVxuICAgICAgICB0aGlzLnBvcHVsYXRpb24ucHVzaChjZWxsKVxuICAgICAgICB0aGlzLnBvcHVsYXRpb25JW2lkXSA9IGNlbGxcbiAgICAgICAgcmV0dXJuIGNlbGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGVwKCkge1xuXG4gICAgICAgIC8vVE9ETyBkb3VibGUgaW5kZXhpbmc/IGJ5IHJhdyBhbmQgdGhlbiBjb2x1bW4gP1xuICAgICAgICAvL3BvcHVsYXRlIGNlbGwgc3Vycm91bmRpbmdzXG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENlbGw+fVxuICAgICAgICAgKiBAZGljdCAqL1xuICAgICAgICBjb25zdCBzdXJJID0ge307XG4gICAgICAgIC8vZ28gdGhyb3VnaCBsaXN0IG9mIGNlbGxzXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgdGhpcy5wb3B1bGF0aW9uKSB7XG4gICAgICAgICAgICAvLyArMSBzdXJyb3VuZGluZyBjZWxsc1xuICAgICAgICAgICAgY29uc3Qgc3JzID0gVW5pdmVyc2UuZ2V0Q2VsbFN1cnJvdW5kaW5nKGNlbGwsIHRoaXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgc3VyIG9mIHNycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHN1ci54ICsgXCJfXCIgKyBzdXIueTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdXJfID0gc3VySVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChzdXJfKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cl8ubmIrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdXIubmIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBzdXJJW2tleV0gPSBzdXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9CMy9TMjNcbiAgICAgICAgLy9raWxsIGNlbGxzXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPENlbGw+fSAqL1xuICAgICAgICBjb25zdCBjZWxsc1RvS2VlcCA9IFtdO1xuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBDZWxsPn1cbiAgICAgICAgICogQGRpY3QgKi9cbiAgICAgICAgY29uc3QgY2VsbHNUb0tlZXBJID0ge307XG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgdGhpcy5wb3B1bGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjZWxsLnggKyBcIl9cIiArIGNlbGwueTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxfID0gc3VySVtrZXldO1xuICAgICAgICAgICAgaWYgKCFjZWxsXykgY29udGludWU7XG4gICAgICAgICAgICAvL2lmIChuYjwyIG9yIG5iPjMpIC0+IGtpbGxcbiAgICAgICAgICAgIGlmIChjZWxsXy5uYiA8IDIgfHwgY2VsbF8ubmIgPiAzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNlbGxzVG9LZWVwLnB1c2goY2VsbCk7XG4gICAgICAgICAgICBjZWxsc1RvS2VlcElba2V5XSA9IGNlbGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3B1bGF0aW9uID0gY2VsbHNUb0tlZXA7XG4gICAgICAgIHRoaXMucG9wdWxhdGlvbkkgPSBjZWxsc1RvS2VlcEk7XG5cbiAgICAgICAgLy9jcmVhdGUgbmV3IGNlbGxzXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPENlbGw+fSAqL1xuICAgICAgICBjb25zdCBzdXJzID0gb2JqVG9BcnJheShzdXJJKTtcbiAgICAgICAgZm9yIChsZXQgc3VyIG9mIHN1cnMpIHtcblxuICAgICAgICAgICAgaWYgKHN1ci5uYiAhPT0gMykgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vY2hlY2sgaWYgYWxyZWFkeSBhbGl2ZVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gc3VyLnggKyBcIl9cIiArIHN1ci55O1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnBvcHVsYXRpb25JW2tleV07XG4gICAgICAgICAgICBpZiAoY2VsbCkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vY3JlYXRlIG5ldyBjZWxsXG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRpb24ucHVzaChzdXIpO1xuICAgICAgICAgICAgdGhpcy5wb3B1bGF0aW9uSVtrZXldID0gc3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNU1xuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcGx1c1xuICAgICAqIEByZXR1cm4ge1VuaXZlcnNlfVxuICAgICAqL1xuICAgIHN0YXJ0KG5iLCB0aW1lb3V0TVMsIGNwbHVzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdW5pID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhpKTtcbiAgICAgICAgICAgIHVuaS5zdGVwKCk7XG4gICAgICAgICAgICBjcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYiA+IDAgJiYgaSsrID4gbmIpIHJldHVybjtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW5naW5lLCB0aW1lb3V0TVMpO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDZWxsfSBjZWxsXG4gICAgICogQHBhcmFtIHtVbml2ZXJzZX0gdW5pXG4gICAgICogQHJldHVybiB7QXJyYXkuPENlbGw+fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDZWxsU3Vycm91bmRpbmcoY2VsbCwgdW5pKSB7XG4gICAgICAgIGNvbnN0IHgxID0gY2VsbC54ID09PSAwID8gdW5pLncgLSAxIDogY2VsbC54IC0gMTtcbiAgICAgICAgY29uc3QgeDIgPSBjZWxsLnggPT09IHVuaS53IC0gMSA/IDAgOiBjZWxsLnggKyAxO1xuICAgICAgICBjb25zdCB5MSA9IGNlbGwueSA9PT0gMCA/IHVuaS5oIC0gMSA6IGNlbGwueSAtIDE7XG4gICAgICAgIGNvbnN0IHkyID0gY2VsbC55ID09PSB1bmkuaCAtIDEgPyAwIDogY2VsbC55ICsgMTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBDZWxsKHgxLCB5MSksXG4gICAgICAgICAgICBuZXcgQ2VsbCh4MSwgY2VsbC55KSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgxLCB5MiksXG4gICAgICAgICAgICBuZXcgQ2VsbChjZWxsLngsIHkxKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKGNlbGwueCwgeTIpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDIsIHkxKSxcbiAgICAgICAgICAgIG5ldyBDZWxsKHgyLCBjZWxsLnkpLFxuICAgICAgICAgICAgbmV3IENlbGwoeDIsIHkyKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5pbXBvcnQgeyBVbml2ZXJzZSB9IGZyb20gJy4vVW5pdmVyc2UnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbCc7XG5cbi8vVE9ETyB6b29tL3Bhbiwgd2l0aCBjYW52YXMgdHJhbnNmb3JtOiBiZXR0ZXIgdW5pdmVyc2UgbGltaXRzXG4vL1RPRE8gYnV0dG9ucyAocGxheSwgc3RvcCwgc3BlZWQsIGRyYXcsIHBhbilcbi8vVE9ETyBjaGVjayBjYW52YXMgYW5pbWF0aW9uXG5cblxuY2xhc3MgR29MU2ltdWxhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICAvL2NsZWFyXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIC8vZHJhdyBjZWxsc1xuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJibHVlXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHRoLnVuaS5wb3B1bGF0aW9uKVxuICAgICAgICAgICAgICAgIGMyLmZpbGxSZWN0KChjZWxsLngpLCAoY2VsbC55KSwgMSwgMSk7XG5cbiAgICAgICAgICAgIC8vZnJhbWVcbiAgICAgICAgICAgIGMyLnN0cm9rZVN0eWxlID0gXCJkYXJrZ3JheVwiO1xuICAgICAgICAgICAgYzIubGluZVdpZHRoID0gMSAqIHRoLmNwbHVzLmdldFpmKCk7XG4gICAgICAgICAgICBjMi5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGMyLnJlY3QoMCwgMCwgdGgudywgdGguaCk7XG4gICAgICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVuaSA9IG5ldyBVbml2ZXJzZSh0aGlzLncsIHRoaXMuaCk7XG4gICAgfVxuXG5cbiAgICAvL1xuICAgIGluaXRSYW5kb20oZGVuc2l0eSA9IDAuMDUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgY29uc3QgbmIgPSB0aGlzLnVuaS53ICogdGhpcy51bmkuaCAqIGRlbnNpdHk7XG4gICAgICAgIHdoaWxlIChpIDwgbmIpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHRoaXMudW5pLncgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHRoaXMudW5pLmggKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7Q2VsbH0gKi9cbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLnVuaS5hZGQoeCwgeSk7XG4gICAgICAgICAgICBpZiAoY2VsbCkgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLy9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy51bmkuc3RhcnQoLTEsIDAsIHRoaXMuY3BsdXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cblxuXG5leHBvcnQgY29uc3QgZ2FtZU9mTGlmZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBHb0xTaW11bGF0aW9uKG9wdHMpXG59XG4iLCIvL0B0cy1jaGVja1xuXG5leHBvcnQgKiBmcm9tIFwiLi9wbGFuZXRzL2luZGV4XCJcbmV4cG9ydCAqIGZyb20gXCIuL2dvbC9pbmRleFwiXG5leHBvcnQgKiBmcm9tIFwiLi9maXNoL2luZGV4XCJcbmV4cG9ydCAqIGZyb20gXCIuL3BwL2luZGV4XCJcbmV4cG9ydCAqIGZyb20gXCIuL3VyYmFuL2luZGV4XCJcbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBVbml2ZXJzZSB9IGZyb20gXCIuL1VuaXZlcnNlXCI7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgQWdlbnRQb2ludCB9IGZyb20gXCIuLi9iYXNlL0FnZW50UG9pbnRcIjtcblxuZXhwb3J0IGNsYXNzIFBsYW5ldCBleHRlbmRzIEFnZW50UG9pbnQge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtVbml2ZXJzZX0gdSBUaGUgdW5pdmVyc2UgdGhlIHBsYW5ldCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSBtYXNzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBUaGUgc3BlZWQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSBUaGUgc3BlZWQgeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHUsIG0sIHgsIHksIHN4ID0gMCwgc3kgPSAwKSB7XG5cbiAgICAgICAgLy9cbiAgICAgICAgc3VwZXIoeCwgeSwgc3gsIHN5KVxuXG4gICAgICAgIC8qKiBAdHlwZSB7VW5pdmVyc2V9ICovXG4gICAgICAgIHRoaXMudSA9IHU7XG4gICAgICAgIHUucHMucHVzaCh0aGlzKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm0gPSBtO1xuXG4gICAgICAgIC8vY29tcHV0ZSByYWRpdXNcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLnIoKTtcblxuICAgICAgICAvL3NldCBwb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geCA8IHIgPyByIDogeCA+IHUudyAtIHIgPyB1LncgLSByIDogeDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMueSA9IHkgPCByID8gciA6IHkgPiB1LmggLSByID8gdS5oIC0gciA6IHk7XG5cbiAgICAgICAgLy9hY2NlbGVyYXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXggPSAwO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5heSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBmb3JjZSwgYmFzZWQgb24gdGhlIGdyYXZpdHkgb2Ygb3RoZXIgcGxhbmV0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAgICAgKi9cbiAgICBvYnNlcnZlKGV4cG9uZW50KSB7XG5cbiAgICAgICAgLy9jb21wdXRlIGdyYXZpdHkgZmllbGQgYXQgcGxhbmV0IGxvY2F0aW9uXG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLnUuZ2V0R3Jhdml0eUZpZWxkKHRoaXMueCwgdGhpcy55LCB0aGlzLCBleHBvbmVudCk7XG5cbiAgICAgICAgLy9zZXQgYWNjZWxlcmF0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmF4ID0gZy5neDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuYXkgPSBnLmd5O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBwbGFuZXQsIGRlcGVuZGluZyBvbiBpdHMgbWFzcy5cbiAgICAgKi9cbiAgICByKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3codGhpcy5tIC8gTWF0aC5QSSwgMC41KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm91bmNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKi9cbiAgICBjaGFuZ2UoYm91bmNlID0gZmFsc2UsIG1heFNwZWVkID0gMC44LCB0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL2NvbXB1dGUgbmV3IHNwZWVkXG4gICAgICAgIHRoaXMuc3ggKz0gdGhpcy5heCAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMuc3kgKz0gdGhpcy5heSAqIHRpbWVTdGVwTXM7XG5cbiAgICAgICAgLy9jaGVjayB2bWF4XG4gICAgICAgIGlmIChtYXhTcGVlZCA+IDApIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICAgICAgY29uc3QgdiA9IE1hdGguc3FydCh0aGlzLnN4ICogdGhpcy5zeCArIHRoaXMuc3kgKiB0aGlzLnN5KTtcbiAgICAgICAgICAgIGlmICh2ID4gbWF4U3BlZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN4ID0gbWF4U3BlZWQgKiB0aGlzLnN4IC8gdjtcbiAgICAgICAgICAgICAgICB0aGlzLnN5ID0gbWF4U3BlZWQgKiB0aGlzLnN5IC8gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29tcHV0ZSBuZXcgcG9zaXRpb25cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBueCA9IHRoaXMueCArIHRoaXMuc3ggKiB0aW1lU3RlcE1zO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgbGV0IG55ID0gdGhpcy55ICsgdGhpcy5zeSAqIHRpbWVTdGVwTXM7XG5cbiAgICAgICAgLy9oYW5kbGUgcG9zaXRpb24gbGltaXRcbiAgICAgICAgaWYgKGJvdW5jZSkge1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMucigpO1xuICAgICAgICAgICAgY29uc3QgZSA9IDE7XG4gICAgICAgICAgICBpZiAobnggPCByKSB7IG54ID0gcjsgdGhpcy5zeCA9IC10aGlzLnN4ICogZTsgfVxuICAgICAgICAgICAgaWYgKG55IDwgcikgeyBueSA9IHI7IHRoaXMuc3kgPSAtdGhpcy5zeSAqIGU7IH1cbiAgICAgICAgICAgIGlmIChueCA+IHRoaXMudS53IC0gcikgeyBueCA9IHRoaXMudS53IC0gcjsgdGhpcy5zeCA9IC10aGlzLnN4ICogZTsgfVxuICAgICAgICAgICAgaWYgKG55ID4gdGhpcy51LmggLSByKSB7IG55ID0gdGhpcy51LmggLSByOyB0aGlzLnN5ID0gLXRoaXMuc3kgKiBlOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobnggPCAwKSB7IG54ID0gdGhpcy51Lnc7IH1cbiAgICAgICAgICAgIGlmIChueSA8IDApIHsgbnkgPSB0aGlzLnUuaDsgfVxuICAgICAgICAgICAgaWYgKG54ID4gdGhpcy51LncpIHsgbnggPSAwOyB9XG4gICAgICAgICAgICBpZiAobnkgPiB0aGlzLnUuaCkgeyBueSA9IDA7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbW92ZVxuICAgICAgICB0aGlzLnggPSBueDtcbiAgICAgICAgdGhpcy55ID0gbnk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHBsYW5ldFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsbFN0eWxlIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGZpbGxTdHlsZSkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucigpIC8gY3AuZ2V0WmYoKSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuZmlsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgcGxhbmV0IGFjY2VsZXJhdGlvblxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3Ryb2tlU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIFxuICAgICAqL1xuICAgIGRpc3BsYXlBY2NlbGVyYXRpb24oY3AsIHN0cm9rZVN0eWxlID0gXCJjeWFuXCIsIGxpbmVXaWR0aCA9IDEsIGZhY3RvciA9IDUwMDApIHtcbiAgICAgICAgY29uc3QgYzIgPSBjcC5jdHhcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgYzIubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXG4gICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICBjMi5tb3ZlVG8odGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjMi5saW5lVG8odGhpcy54ICsgZmFjdG9yICogdGhpcy5heCwgdGhpcy55ICsgZmFjdG9yICogdGhpcy5heSk7XG4gICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICBjMi5zdHJva2UoKTtcbiAgICB9XG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyByZW1vdmVGcm9tQXJyYXkgfSBmcm9tICcuLi9iYXNlL2xpYic7XG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tICcuLi9iYXNlL1NwYXRpYWxJbmRleCc7XG5pbXBvcnQgeyBQbGFuZXQgfSBmcm9tICcuL1BsYW5ldCc7XG5cbmV4cG9ydCBjbGFzcyBVbml2ZXJzZSB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICB0aGlzLnBzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbWFzcyBvZiB0aGUgdW5pdmVyc2UsIGFzIHRoZSBzdW0gb2YgdGhlIG1hc3Mgb2YgaXRzIHBsYW5ldHMuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBtKCkge1xuICAgICAgICBsZXQgbSA9IDA7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIG0gKz0gcC5tO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqIEBwYXJhbSB7UGxhbmV0fSBwSWdub3JlIEEgcGxhbmV0IHRvIGlnbm9yZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICAgICAqIEByZXR1cm5zIHt7Z3g6bnVtYmVyLGd5Om51bWJlcn19XG4gICAgICovXG4gICAgZ2V0R3Jhdml0eUZpZWxkKHgsIHksIHBJZ25vcmUgPSB1bmRlZmluZWQsIGV4cG9uZW50ID0gMikge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgZ3ggPSAwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgZ3kgPSAwXG5cbiAgICAgICAgLy9nb3Rocm91Z2ggYWxsIHBsYW5ldHMgaW4gdGhlIHVuaXZlcnNlXG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcykge1xuXG4gICAgICAgICAgICAvL2lnbm9yZSBwbGFuZXRcbiAgICAgICAgICAgIGlmIChwSWdub3JlICYmIHAgPT0gcElnbm9yZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy9jb21wdXRlIGRpc3RhbmNlXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgIGxldCBkID0gcC5kUCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChkID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL2NvbXB1dGUgYW5kIGFkZCBjb250cmlidXRpb25cbiAgICAgICAgICAgIGQgPSBkICogTWF0aC5wb3coZCwgZXhwb25lbnQpO1xuICAgICAgICAgICAgZ3ggKz0gMC4wMSAqIChwLnggLSB4KSAqIHAubSAvIGQ7XG4gICAgICAgICAgICBneSArPSAwLjAxICogKHAueSAtIHkpICogcC5tIC8gZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBneDogZ3gsIGd5OiBneSB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGUgdHdvIHBsYW5ldHNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcDFcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcDJcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48UGxhbmV0Pn0gc2luZGV4XG4gICAgICogQHJldHVybnMge1BsYW5ldH1cbiAgICAgKi9cbiAgICBhZ2dyZWdhdGUocDEsIHAyLCBzaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbSA9IHAxLm0gKyBwMi5tO1xuICAgICAgICBjb25zdCBwID0gbmV3IFBsYW5ldChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgKHAxLnggKiBwMS5tICsgcDIueCAqIHAyLm0pIC8gbSxcbiAgICAgICAgICAgIChwMS55ICogcDEubSArIHAyLnkgKiBwMi5tKSAvIG0sXG4gICAgICAgICAgICAocDEuc3ggKiBwMS5tICsgcDIuc3ggKiBwMi5tKSAvIG0sXG4gICAgICAgICAgICAocDEuc3kgKiBwMS5tICsgcDIuc3kgKiBwMi5tKSAvIG1cbiAgICAgICAgKTtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMucHMsIHAxKTtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMucHMsIHAyKTtcblxuICAgICAgICBpZiAoc2luZGV4KSB7XG4gICAgICAgICAgICBzaW5kZXgucmVtb3ZlKHAxKVxuICAgICAgICAgICAgc2luZGV4LnJlbW92ZShwMilcbiAgICAgICAgICAgIHNpbmRleC5pbnNlcnQocClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48UGxhbmV0Pn0gc2luZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpc2lvbkZhY3RvclxuICAgICAqIEByZXR1cm5zIHtBcnJheS48UGxhbmV0Pn1cbiAgICAgKi9cbiAgICBmaW5kQ29sbGlzaW9uKHNpbmRleCwgY29sbGlzaW9uRmFjdG9yID0gMSkge1xuICAgICAgICBmb3IgKGxldCBwaSBvZiB0aGlzLnBzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHcgPSAyICogcGkucigpO1xuICAgICAgICAgICAgY29uc3QgY2FuZCA9IHNpbmRleC5nZXQocGkueCAtIHcsIHBpLnkgLSB3LCBwaS54ICsgdywgcGkueSArIHcpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBwaiBvZiBjYW5kKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocGkgPT0gcGopIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgICAgICAgICAgY29uc3QgZDEgPSBwaS5kKHBqKTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICAgICAgICBjb25zdCBkMiA9IChwaS5yKCkgKyBwai5yKCkpICogY29sbGlzaW9uRmFjdG9yO1xuICAgICAgICAgICAgICAgIGlmIChkMSA+IGQyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BpLCBwal07XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBwbGFuZXRzIHdpdGggcmFuZG9tIHNwZWVkXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3BlZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBhZGRQbGFuZXRzKG5iID0gMSwgbWkgPSAwLjUsIG1pblNwZWVkID0gMCwgbWF4U3BlZWQgPSAwLjEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFBsYW5ldCh0aGlzLCBtaSwgdGhpcy53ICogTWF0aC5yYW5kb20oKSwgdGhpcy5oICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICBwLnNldFJhbmRvbVNwZWVkKG1pblNwZWVkLCBtYXhTcGVlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm91bmNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2bWF4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sbGlzaW9uRmFjdG9yIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lU3RlcE1zIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0ZXAoYm91bmNlID0gZmFsc2UsIHZtYXggPSAwLjgsIGV4cG9uZW50ID0gMiwgY29sbGlzaW9uRmFjdG9yID0gMSwgdGltZVN0ZXBNcyA9IDEwKSB7XG5cbiAgICAgICAgLy9vYnNlcnZhdGlvblxuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBwLm9ic2VydmUoZXhwb25lbnQpO1xuXG4gICAgICAgIC8vYWN0aW9uXG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIHAuY2hhbmdlKGJvdW5jZSwgdm1heCwgdGltZVN0ZXBNcyk7XG5cblxuICAgICAgICAvL2NvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgdGhpcy5kZXRlY3RDb2xsaXNpb25zKGNvbGxpc2lvbkZhY3RvcilcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sbGlzaW9uRmFjdG9yIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIGRldGVjdENvbGxpc2lvbnMoY29sbGlzaW9uRmFjdG9yID0gMSkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U3BhdGlhbEluZGV4LjxQbGFuZXQ+fSAqL1xuICAgICAgICBjb25zdCBzaW5kZXggPSBuZXcgU3BhdGlhbEluZGV4KCk7XG4gICAgICAgIHNpbmRleC5sb2FkKHRoaXMucHMpXG5cbiAgICAgICAgLy9maW5kIGZpcnN0IGNvbGxpc2lvblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxQbGFuZXQ+fSAqL1xuICAgICAgICBsZXQgcGFpciA9IHRoaXMuZmluZENvbGxpc2lvbihzaW5kZXgsIGNvbGxpc2lvbkZhY3Rvcik7XG4gICAgICAgIHdoaWxlIChwYWlyICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vYWdncmVnYXRlXG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5hZ2dyZWdhdGUocGFpclswXSwgcGFpclsxXSwgc2luZGV4KVxuXG4gICAgICAgICAgICAvL2ZpbmQgbmV4dCBjb2xsaXNpb25cbiAgICAgICAgICAgIHBhaXIgPSB0aGlzLmZpbmRDb2xsaXNpb24oc2luZGV4LCBjb2xsaXNpb25GYWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gcmFuZG9tIHNwZWVkIHRvIGFsbCBwbGFuZXRzXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRSYW5kb21TcGVlZChtaW5TcGVlZCA9IDAsIG1heFNwZWVkID0gMC4xKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wcylcbiAgICAgICAgICAgIHAuc2V0UmFuZG9tU3BlZWQobWluU3BlZWQsIG1heFNwZWVkKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQbGFuZXR9IFRoZSBsYXJnZXN0IHBsYW5ldCBvZiB0aGUgdW5pdmVyc2UsIHVzdWFsbHkgdGhlIHN0YXIuXG4gICAgICovXG4gICAgZ2V0TGFyZ2VzdFBsYW5ldCgpIHtcbiAgICAgICAgbGV0IHBNID0gbnVsbCwgbU0gPSAwO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucHMpXG4gICAgICAgICAgICBpZiAocC5tID4gbU0pIHsgcE0gPSBwOyBtTSA9IHAubSB9XG4gICAgICAgIHJldHVybiBwTVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBsYXJnZXN0IHBsYW5ldCBhbmQgZXhwbG9kZSBpdC5cbiAgICAgKi9cbiAgICBleHBsb2RlTGFyZ2VzdFBsYW5ldCgpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuZ2V0TGFyZ2VzdFBsYW5ldCgpXG4gICAgICAgIHRoaXMuZXhwbG9kZShwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGxvZGUgYSBwbGFuZXQgaW50byBwaWVjZXNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1BsYW5ldH0gcCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNwZWVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIFxuICAgICAqL1xuICAgIGV4cGxvZGUocCwgbmIgPSAtMSwgbWluU3BlZWQgPSAwLjgsIG1heFNwZWVkID0gMS41LCByYWQgPSAtMSkge1xuICAgICAgICBpZiAobmIgPD0gMCkgbmIgPSBNYXRoLmZsb29yKHAubSk7XG4gICAgICAgIGlmIChuYiA8PSAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGFuZ2xlU3RlcCA9IDIgKiBNYXRoLlBJIC8gbmI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgLy9jcmVhdGUgcGxhbmV0XG5cbiAgICAgICAgICAgIC8vcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChyYWQgPCAwKSByYWQgPSAyICogcC5yKClcbiAgICAgICAgICAgIGNvbnN0IGQgPSByYWQgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgY29uc3QgYSA9IGkgKiBhbmdsZVN0ZXA7XG4gICAgICAgICAgICBjb25zdCB4ID0gZCAqIE1hdGguY29zKGEpLCB5ID0gZCAqIE1hdGguc2luKGEpO1xuXG4gICAgICAgICAgICAvL3NwZWVkXG4gICAgICAgICAgICBjb25zdCBzcGVlZCA9IG1pblNwZWVkICsgTWF0aC5yYW5kb20oKSAqIChtYXhTcGVlZCAtIG1pblNwZWVkKTtcbiAgICAgICAgICAgIGNvbnN0IGFTID0gYSArIDIgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyICogTWF0aC5QSSAvIDM7XG4gICAgICAgICAgICBjb25zdCBzeCA9IHNwZWVkICogTWF0aC5jb3MoYVMpLCBzeSA9IHNwZWVkICogTWF0aC5zaW4oYVMpO1xuXG4gICAgICAgICAgICBuZXcgUGxhbmV0KHRoaXMsIHAubSAvIG5iLCBwLnggKyB4LCBwLnkgKyB5LCBwLnN4ICsgc3gsIHAuc3kgKyBzeSlcbiAgICAgICAgfVxuICAgICAgICAvL3JlbW92ZSBwIGZyb20gdW5pdmVyc2VcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMucHMsIHApO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFVuaXZlcnNlIH0gZnJvbSAnLi9Vbml2ZXJzZSc7XG5pbXBvcnQgeyBQbGFuZXQgfSBmcm9tICcuL1BsYW5ldCc7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5cbi8qKiAgKi9cbmNsYXNzIFBsYW5ldFNpbXVsYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBvcHRzLmNhbnZhc0lkID0gb3B0cy5jYW52YXNJZCB8fCBcInZhY2FudmFzXCI7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdHMuY2FudmFzSWQpO1xuICAgICAgICBpZiAoY2FudmFzID09IG51bGwpIHRocm93IFwiTm8gY2FudmFzIFwiICsgb3B0cy5jYW52YXNJZDtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53ID0gb3B0cy53IHx8IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLm1heFNwZWVkID0gb3B0cy5tYXhTcGVlZCB8fCAwLjg7XG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5ib3VuY2UgPSBvcHRzLmJvdW5jZSB8fCBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5leHBvbmVudCA9IG9wdHMuZXhwb25lbnQgfHwgMjtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuY29sbGlzaW9uRmFjdG9yID0gb3B0cy5jb2xsaXNpb25GYWN0b3IgfHwgMTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuc2hvd1BsYW5ldEFjY2VsZXJhdGlvbiA9IGZhbHNlXG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgICB0aGlzLnNob3dGaWVsZCA9IHVuZGVmaW5lZFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5maWVsZFJlcyA9IDIwXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmZpZWxkRmFjdG9yID0gMTAwMFxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5maWVsZFN0cm9rZVN0eWxlID0gXCIjOTliYmZmXCI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudGFpbGluZ3MgPSBvcHRzLnRhaWxpbmdzIHx8IDAuMTtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgLy9jbGVhciwgd2l0aCB0cmFuc3BhcmVuY3lcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmdiYSgwLDAsMCxcIiArIHRoLnRhaWxpbmdzICsgXCIpXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIC8vYzIuZmlsbFJlY3QoLTFlMjAsIC0xZTIwLCAyZTIwLCAyZTIwKTsgLy90b2RvXG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBncmF2aXR5IGZpZWxkXG4gICAgICAgICAgICBpZiAodGguc2hvd0ZpZWxkID09PSBcImZcIilcbiAgICAgICAgICAgICAgICB0aC5kaXNwbGF5R3Jhdml0eUZpZWxkKHRoaXMsIHRydWUpXG4gICAgICAgICAgICBlbHNlIGlmICh0aC5zaG93RmllbGQgPT09IFwiaVwiKVxuICAgICAgICAgICAgICAgIHRoLmRpc3BsYXlHcmF2aXR5RmllbGQodGhpcywgZmFsc2UpXG5cblxuICAgICAgICAgICAgdGhpcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgcGxhbmV0c1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aC51bmkucHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudG9EcmF3KHApKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwLm0gLyB0aC51bmkubSgpO1xuICAgICAgICAgICAgICAgIHAuZGlzcGxheSh0aGlzLCBcInJnYigyNTUsMjU1LFwiICsgTWF0aC5mbG9vcigyNTUgKiAoMSAtIHQpKSArIFwiKVwiKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Rpc3BsYXkgcGxhbmV0cyBhY2NlbGVyYXRpb25cbiAgICAgICAgICAgIGlmICh0aC5zaG93UGxhbmV0QWNjZWxlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aC51bmkucHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhwKSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgcC5kaXNwbGF5QWNjZWxlcmF0aW9uKHRoaXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7VW5pdmVyc2V9ICovXG4gICAgICAgIHRoaXMudW5pID0gbmV3IFVuaXZlcnNlKHRoaXMudywgdGhpcy5oKVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmllbGQgXG4gICAgICovXG4gICAgZGlzcGxheUdyYXZpdHlGaWVsZChjcCwgZmllbGQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGMyID0gY3AuY3R4XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZmllbGRSZXNcbiAgICAgICAgY29uc3QgZiA9IHRoaXMuZmllbGRGYWN0b3JcbiAgICAgICAgY29uc3QgZl8gPSBmaWVsZCA/IDAuMyAqIHJlcyA6IDAuNiAqIHJlcztcbiAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSB0aGlzLmZpZWxkU3Ryb2tlU3R5bGVcbiAgICAgICAgZm9yIChsZXQgeCA9IHJlcyAqIDAuNTsgeCA8IHRoaXMudzsgeCArPSByZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHhHID0gY3AucGl4VG9HZW9YKHgpO1xuICAgICAgICAgICAgaWYgKHhHID4gdGhpcy51bmkudyB8fCB4RyA8IDApIGNvbnRpbnVlXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gcmVzIC8gMjsgeSA8IHRoaXMuaDsgeSArPSByZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5RyA9IGNwLnBpeFRvR2VvWSh5KTtcbiAgICAgICAgICAgICAgICBpZiAoeUcgPiB0aGlzLnVuaS5oIHx8IHlHIDwgMCkgY29udGludWVcbiAgICAgICAgICAgICAgICAvL2dldCBncmF2aXR5IGZpZWxkXG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pLmdldEdyYXZpdHlGaWVsZCh4RywgeUcsIHVuZGVmaW5lZCwgdGhpcy5leHBvbmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ18gPSBNYXRoLmh5cG90KGcuZ3gsIGcuZ3kpXG5cbiAgICAgICAgICAgICAgICBjMi5saW5lV2lkdGggPSBNYXRoLm1pbihmICogZ18sIDAuMyAqIHJlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHggPSBmXyAqIGcuZ3ggLyBnXywgZHkgPSBmXyAqIGcuZ3kgLyBnX1xuXG4gICAgICAgICAgICAgICAgLy9kcmF3XG4gICAgICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZ3Jhdml0eSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBjMi5tb3ZlVG8oeCAtIGR4LCB5ICsgZHkpO1xuICAgICAgICAgICAgICAgICAgICBjMi5saW5lVG8oeCArIGR4LCB5IC0gZHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaXNvcG90ZW50aWFsIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgIGMyLm1vdmVUbyh4ICsgZHksIHkgKyBkeCk7XG4gICAgICAgICAgICAgICAgICAgIGMyLmxpbmVUbyh4IC0gZHksIHkgLSBkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMyLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHdpdGggcmFuZG9tIHBsYW5ldHNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgaW5pdFJhbmRvbShuYiA9IDEwMDAsIG1pID0gMC41LCBtaW5TcGVlZCA9IDAsIG1heFNwZWVkID0gMC4xKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFBsYW5ldD59ICovXG4gICAgICAgIHRoaXMudW5pLnBzID0gW107XG4gICAgICAgIHRoaXMudW5pLmFkZFBsYW5ldHMobmIsIG1pLCBtaW5TcGVlZCwgbWF4U3BlZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHdpdGggYmlnIGJhbmcgc2V0dXBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmIgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcGVlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3BlZWQgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBpbml0QmlnQmFuZyhuYiA9IDEwMDAsIG1pID0gMSwgbWluU3BlZWQgPSAwLjM1LCBtYXhTcGVlZCA9IDAuNywgcmFkID0gMTAwKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFBsYW5ldD59ICovXG4gICAgICAgIHRoaXMudW5pLnBzID0gW107XG4gICAgICAgIC8vY3JlYXRlIGJpZyBwbGFuZXQgaW4gdGhlIG1pZGRsZVxuICAgICAgICBjb25zdCBjeCA9IHRoaXMudyAqIDAuNSwgY3kgPSB0aGlzLmggKiAwLjU7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUGxhbmV0KHRoaXMudW5pLCBuYiAqIG1pLCBjeCwgY3ksIDAsIDApO1xuICAgICAgICAvL2V4cGxvZGUgaXRcbiAgICAgICAgdGhpcy51bmkuZXhwbG9kZShwLCBuYiwgbWluU3BlZWQsIG1heFNwZWVkLCByYWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHNpbXVsYXRpb25cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVN0ZXBNcyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmJJdGVyYXRpb25zIFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHN0YXJ0KHRpbWVTdGVwTXMgPSAxMCwgbmJJdGVyYXRpb25zID0gLTEpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCB0ID0gdGhpcztcbiAgICAgICAgY29uc3QgZW5naW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdC51bmkuc3RlcCh0LmJvdW5jZSwgdC5tYXhTcGVlZCwgdC5leHBvbmVudCwgdC5jb2xsaXNpb25GYWN0b3IsIHRpbWVTdGVwTXMpO1xuICAgICAgICAgICAgdC5jcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYkl0ZXJhdGlvbnMgPiAwICYmIGkrKyA+IG5iSXRlcmF0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGVuZ2luZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvL3N0b3BcbiAgICBzdG9wKCkge1xuICAgICAgICAvL1RPRE9cbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYW5ldHMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIHJldHVybiBuZXcgUGxhbmV0U2ltdWxhdGlvbihvcHRzKVxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IExhbmQgfSBmcm9tIFwiLi9MYW5kXCJcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gXCIuLi9iYXNlL0dlb0NhbnZhc1wiXG5pbXBvcnQgeyBBZ2VudFBvaW50IH0gZnJvbSBcIi4uL2Jhc2UvQWdlbnRQb2ludFwiXG5cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hbCBleHRlbmRzIEFnZW50UG9pbnQge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgXG4gICAgICogQHBhcmFtIHtMYW5kfSBsIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGwsIHggPSAwLCB5ID0gMCkge1xuXG4gICAgICAgIHN1cGVyKHgsIHkpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKiBAdHlwZSB7TGFuZH0gKi9cbiAgICAgICAgdGhpcy5sID0gbDtcblxuICAgICAgICAvL3Bvc2l0aW9uXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnggPSB4IDwgMCA/IDAgOiB4ID4gbC53ID8gbC53IDogeFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geSA8IDAgPyAwIDogeSA+IGwuaCA/IGwuaCA6IHlcblxuICAgICAgICAvL3RoZSBvdGhlciBhbmltYWxzIGFyb3VuZFxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLnByZWRhdG9ycyA9IFtdXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMucHJleXMgPSBbXVxuXG4gICAgICAgIC8vYWRkIHRvIHRoZSBzcGF0aWFsIGluZGV4XG4gICAgICAgIGwuZ3JpZC5pbnNlcnQodGhpcyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgbW92ZSh0aW1lU3RlcE1zID0gMTApIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMubFxuICAgICAgICBsLmdyaWQucmVtb3ZlKHRoaXMpO1xuXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCByID0gMC4wMSAqIE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgdGhpcy5zeCArPSByICogTWF0aC5jb3MoYW5nbGUpICogdGltZVN0ZXBNcztcbiAgICAgICAgdGhpcy5zeCA9IHRoaXMuc3ggPiBsLlZfTUFYID8gbC5WX01BWCA6IHRoaXMuc3ggPCAtbC5WX01BWCA/IC1sLlZfTUFYIDogdGhpcy5zeFxuXG4gICAgICAgIHRoaXMuc3kgKz0gciAqIE1hdGguc2luKGFuZ2xlKSAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMuc3kgPSB0aGlzLnN5ID4gbC5WX01BWCA/IGwuVl9NQVggOiB0aGlzLnN5IDwgLWwuVl9NQVggPyAtbC5WX01BWCA6IHRoaXMuc3lcblxuICAgICAgICB0aGlzLnggKz0gdGhpcy5zeCAqIHRpbWVTdGVwTXM7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueCA8IDAgPyBsLncgOiB0aGlzLnggPiBsLncgPyAwIDogdGhpcy54XG5cbiAgICAgICAgdGhpcy55ICs9IHRoaXMuc3kgKiB0aW1lU3RlcE1zO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnkgPCAwID8gbC5oIDogdGhpcy55ID4gbC5oID8gMCA6IHRoaXMueVxuXG4gICAgICAgIGwuZ3JpZC5pbnNlcnQodGhpcyk7XG4gICAgfVxuXG5cbiAgICAvKiogT2JzZXJ2ZSAqL1xuICAgIG9ic2VydmUoKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxcblxuICAgICAgICAvL2dldCBhbmltYWxzIGFyb3VuZFxuICAgICAgICBjb25zdCBhcyA9IGwuZ3JpZC5nZXQodGhpcy54IC0gbC5kLCB0aGlzLnkgLSBsLmQsIHRoaXMueCArIGwuZCwgdGhpcy55ICsgbC5kKTtcblxuICAgICAgICB0aGlzLnByZXlzID0gW107XG4gICAgICAgIHRoaXMucHJlZGF0b3JzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgYSBvZiBhcykge1xuICAgICAgICAgICAgaWYgKGEgPT0gdGhpcykgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5kKGEpID4gbC5kKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChhLnR5cGUgPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXlzLnB1c2goYSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVkYXRvcnMucHVzaChhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcmV0dXJucyB7QW5pbWFsfSAqL1xuICAgIG1ha2VDaGlsZCgpIHtcbiAgICAgICAgLy9kbyBiZXR0ZXI6IG1ha2UgY2hpbGQgYXJvdW5kXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWFsKHRoaXMudHlwZSwgdGhpcy5sLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgYW5pbWFsXG4gICAgICogXG4gICAgICogQHBhcmFtIHtHZW9DYW52YXN9IGNwIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsU3R5bGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgXG4gICAgICovXG4gICAgZGlzcGxheShjcCwgZmlsbFN0eWxlID0gXCJibHVlXCIsIHNpemUgPSAyKSB7XG4gICAgICAgIGNwLmN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGNwLmN0eC5maWxsUmVjdCh0aGlzLngsIHRoaXMueSwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgIC8qYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLmFyYyhhLngsIGEueSwgMC41LCAwLCAyKk1hdGguUEkpO1xuICAgICAgICBjMi5jbG9zZVBhdGgoKTtcbiAgICAgICAgYzIuZmlsbCgpOyovXG4gICAgfVxuXG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSAnLi4vYmFzZS9TcGF0aWFsSW5kZXgnO1xuaW1wb3J0IHsgcmVtb3ZlRnJvbUFycmF5UyB9IGZyb20gJy4uL2Jhc2UvbGliJztcbmltcG9ydCB7QW5pbWFsfSBmcm9tIFwiLi9BbmltYWxcIlxuXG5leHBvcnQgY2xhc3MgTGFuZCB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3LCBoKSB7XG5cbiAgICAgICAgLy90aGUgbWF4IHNwZWVkXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLlZfTUFYID0gMC4xXG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMucCA9IDAuMDIgLy9wcmVkYXRvciBkZWF0aCBwcm9iYWJpbGl0eVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5xID0gMC4xIC8vcHJleSByZXByb2R1Y3Rpb24gcHJvYmFiaWxpdHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMuciA9IDAuNSAvL2VhdGVuIHByZXkgdHJhbnNmb3JtYXRpb24gcHJvYmFiaWxpdHlcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMubmIgPSAzIC8vbmVpZ2hib3JzIG51bWJlclxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBoXG5cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QW5pbWFsPn0gKi9cbiAgICAgICAgdGhpcy5wcmVkYXRvcnMgPSBbXVxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxBbmltYWw+fSAqL1xuICAgICAgICB0aGlzLnByZXlzID0gW11cblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5kID0gMTBcbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPEFuaW1hbD59ICovXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBTcGF0aWFsSW5kZXgoKTtcblxuICAgICAgICAvKmludFtdW10gaGlzdG87XG4gICAgICAgIGludCBpbmRleD0wO1xuICAgICAgICB0aGlzLmMyQ2hhcnQ9YzJDaGFydDtcbiAgICAgICAgdGhpcy5oQ2hhcnQ9aENoYXJ0O1xuICAgICAgICB0aGlzLmhpc3RvPW5ldyBpbnRbd0NoYXJ0XVtdO1xuICAgICAgICBmb3IoaW50IGk9MDtpPHdDaGFydDtpKyspXG4gICAgICAgICAgICBoaXN0b1tpXT1uZXcgaW50W117MCwwfTsqL1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICovXG4gICAgc3RlcCh0aW1lU3RlcE1zID0gMTApIHtcblxuICAgICAgICAvL29ic2VydmVcbiAgICAgICAgZm9yIChsZXQgYSBvZiB0aGlzLnByZXlzKSBhLm9ic2VydmUoKTtcbiAgICAgICAgZm9yIChsZXQgYSBvZiB0aGlzLnByZWRhdG9ycykgYS5vYnNlcnZlKCk7XG5cbiAgICAgICAgY29uc3QgcHJleXNUb0Jvcm4gPSBbXVxuICAgICAgICBjb25zdCBwcmV5c1RvRGllID0gW11cbiAgICAgICAgY29uc3QgcHJlZHNUb0Jvcm4gPSBbXVxuICAgICAgICBjb25zdCBwcmVkc1RvRGllID0gW11cblxuICAgICAgICAvL3ByZXlcbiAgICAgICAgZm9yIChsZXQgcHJleSBvZiB0aGlzLnByZXlzKSB7XG4gICAgICAgICAgICAvL3JlcHJvZHVjdGlvbiBpZiBubyBwcmVkYXRvciBhcm91bmRcbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gdGhpcy5xKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwcmV5LnByZWRhdG9ycy5sZW5ndGggIT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocHJleS5wcmV5cy5sZW5ndGggPj0gdGhpcy5uYikgY29udGludWU7XG4gICAgICAgICAgICBwcmV5c1RvQm9ybi5wdXNoKHByZXkubWFrZUNoaWxkKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9wcmVkYXRvclxuICAgICAgICBmb3IgKGxldCBwcmVkIG9mIHRoaXMucHJlZGF0b3JzKSB7XG4gICAgICAgICAgICAvL25vIHByZXkgYXJvdW5kOiBwcmVkYXRvciBkaWVzIHdpdGggcHJvYmFiaWxpdHkgcFxuICAgICAgICAgICAgaWYgKHByZWQucHJleXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHRoaXMucCkgcHJlZHNUb0RpZS5wdXNoKHByZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9wcmV5IGFyb3VuZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9lYXQgcHJleVxuICAgICAgICAgICAgICAgIC8vY2hvb3NlIHJhbmRvbWx5XG4gICAgICAgICAgICAgICAgY29uc3QgcHJleVRvRWF0ID0gcHJlZC5wcmV5c1tNYXRoLmZsb29yKHByZWQucHJleXMubGVuZ3RoICogTWF0aC5yYW5kb20oKSldO1xuICAgICAgICAgICAgICAgIHByZXlzVG9EaWUucHVzaChwcmV5VG9FYXQpO1xuXG4gICAgICAgICAgICAgICAgLy9wcmVkYXRvciByZXByb2R1Y3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IHRoaXMucikgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHByZWQucHJlZGF0b3JzLmxlbmd0aCA+PSB0aGlzLm5iKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBwcmVkc1RvQm9ybi5wdXNoKHByZWQubWFrZUNoaWxkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV5cy5wdXNoKC4uLnByZXlzVG9Cb3JuKTtcbiAgICAgICAgdGhpcy5wcmVkYXRvcnMucHVzaCguLi5wcmVkc1RvQm9ybik7XG5cbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5Uyh0aGlzLnByZXlzLCBwcmV5c1RvRGllLCBmYWxzZSlcbiAgICAgICAgZm9yIChsZXQgYSBvZiBwcmV5c1RvRGllKSB0aGlzLmdyaWQucmVtb3ZlKGEpO1xuICAgICAgICByZW1vdmVGcm9tQXJyYXlTKHRoaXMucHJlZGF0b3JzLCBwcmVkc1RvRGllLCBmYWxzZSlcbiAgICAgICAgZm9yIChsZXQgYSBvZiBwcmVkc1RvRGllKSB0aGlzLmdyaWQucmVtb3ZlKGEpO1xuXG4gICAgICAgIC8vbW92ZVxuICAgICAgICBmb3IgKGxldCBhIG9mIHRoaXMucHJleXMpXG4gICAgICAgICAgICBhLm1vdmUodGltZVN0ZXBNcyk7XG4gICAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5wcmVkYXRvcnMpXG4gICAgICAgICAgICBhLm1vdmUodGltZVN0ZXBNcyk7XG5cbiAgICAgICAgLyovaGlzdG9cbiAgICAgICAgaGlzdG9baW5kZXhdID0gbmV3IGludFtdeyBwcmV5cy5zaXplKCksIHByZWRhdG9ycy5zaXplKCkgfTtcbiAgICAgICAgaWYgKGluZGV4ID09IGhpc3RvLmxlbmd0aCAtIDEpIGluZGV4ID0gMDtcbiAgICAgICAgZWxzZSBpbmRleCsrOyovXG5cbiAgICB9XG59XG4iLCIvL0B0cy1jaGVja1xuaW1wb3J0IHsgTGFuZCB9IGZyb20gJy4vTGFuZCc7XG5pbXBvcnQgeyBBbmltYWwgfSBmcm9tICcuL0FuaW1hbCc7XG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5cbi8qKiAqL1xuY2xhc3MgUHJleVByZWRhdG9yU2ltdWxhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIG9wdHMuY2FudmFzSWQgPSBvcHRzLmNhbnZhc0lkIHx8IFwidmFjYW52YXNcIjtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0cy5jYW52YXNJZCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvKiogQHR5cGUge0dlb0NhbnZhc30gKi9cbiAgICAgICAgdGhpcy5jcGx1cyA9IG5ldyBHZW9DYW52YXMoKTtcbiAgICAgICAgdGhpcy5jcGx1cy5jdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaCk7XG5cblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICAvL3RyYW5zcGFyZW5jeVxuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGMyLmZpbGxTdHlsZSA9IFwicmdiYSgyNTUsMjU1LDI1NSwwLjUpXCI7XG4gICAgICAgICAgICBjMi5maWxsUmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcblxuICAgICAgICAgICAgLy9kaXNwbGF5IGFuaW1hbHNcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcbiAgICAgICAgICAgIGZvciAobGV0IGEgb2YgdGgubGFuZC5wcmV5cylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b0RyYXcoYSkpXG4gICAgICAgICAgICAgICAgICAgIGEuZGlzcGxheSh0aGlzLCBcImJsdWVcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBhIG9mIHRoLmxhbmQucHJlZGF0b3JzKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvRHJhdyhhKSlcbiAgICAgICAgICAgICAgICAgICAgYS5kaXNwbGF5KHRoaXMsIFwicmVkXCIpO1xuXG4gICAgICAgICAgICAvKi9sYWJlbFxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJsaWdodGdyYXlcIjtcbiAgICAgICAgICAgIGMyLmZpbGxSZWN0KDAsIDAsIDY1LCAxMyk7XG4gICAgICAgICAgICBjMi5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICBjMi5maWxsVGV4dChwcmV5cy5sZW5ndGggKyBcIi9cIiArIHByZWRhdG9ycy5sZW5ndGgsIDIsIDEwKTsqL1xuXG4gICAgICAgICAgICAvL2NoYXJ0XG4gICAgICAgICAgICAvL2MyQ2hhcnQuc2V0RmlsbFN0eWxlKGJhY2tDb2xvcjIpO1xuICAgICAgICAgICAgLy9jMkNoYXJ0LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICAgICAgICAvL2RvdWJsZSBtYXggPSBnZXRNYXhIaXN0bygpO1xuICAgICAgICAgICAgLypwdWJsaWMgaW50IGdldE1heEhpc3RvKCkge1xuICAgICAgICAgICAgICAgIGludCBtYXg9MDtcbiAgICAgICAgICAgICAgICBmb3IoaW50IGk9MDtpPGhpc3RvLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgICAgICAgICBpZihoaXN0b1tpXVswXT5tYXgpIG1heD1oaXN0b1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGlzdG9baV1bMV0+bWF4KSBtYXg9aGlzdG9baV1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VibGUgaDEsIGgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaGlzdG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDEgPSBoQ2hhcnQgKiBoaXN0b1tpXVswXSAvIG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSBoQ2hhcnQgKiBoaXN0b1tpXVsxXSAvIG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5zZXRGaWxsU3R5bGUocHJleUNvbG9yMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyQ2hhcnQuZmlsbFJlY3QoaSwgaENoYXJ0IC0gaDEsIDEsIGgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5zZXRGaWxsU3R5bGUocHJlZGF0b3JDb2xvcjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LmZpbGxSZWN0KGksIGhDaGFydCAtIGgyLCAxLCBoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYzJDaGFydC5zZXRGaWxsU3R5bGUoQ3NzQ29sb3IubWFrZSgyNTUsIDI1NSwgMjU1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMkNoYXJ0LmZpbGxSZWN0KGluZGV4LCAwLCAxLCBoQ2hhcnQpO1xuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy9mcmFtZVxuICAgICAgICAgICAgYzIuc3Ryb2tlU3R5bGUgPSBcImRhcmtncmF5XCI7XG4gICAgICAgICAgICBjMi5saW5lV2lkdGggPSAxICogdGguY3BsdXMuZ2V0WmYoKTtcbiAgICAgICAgICAgIGMyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYzIucmVjdCgwLCAwLCB0aC53LCB0aC5oKTtcbiAgICAgICAgICAgIGMyLnN0cm9rZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqIEB0eXBlIHtMYW5kfSAqL1xuICAgICAgICB0aGlzLmxhbmQgPSBuZXcgTGFuZCh0aGlzLncsIHRoaXMuaClcblxuICAgIH1cblxuXG5cbiAgICAvL1RPRE8gdGVzdCBpbml0IGluIGEgYnViYmxlID9cbiAgICAvL1RPRE8gdXNlIGRlbnNpdHkgYXMgaW5wdXQgcGFyYW1ldGVycyBpbnN0ZWFkIG9mIG5iXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJleURlbnNpdHkgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByZWRhdG9yRGVuc2l0eSBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBpbml0UmFuZG9tKHByZXlEZW5zaXR5ID0gMC4wMDMsIHByZWRhdG9yRGVuc2l0eSA9IDAuMDAzKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxhbmRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV5RGVuc2l0eSAqIGwudyAqIGwuaDsgaSsrKVxuICAgICAgICAgICAgbC5wcmV5cy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBBbmltYWwoMCwgbCwgbC53ICogTWF0aC5yYW5kb20oKSwgbC5oICogTWF0aC5yYW5kb20oKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZGF0b3JEZW5zaXR5ICogbC53ICogbC5oOyBpKyspXG4gICAgICAgICAgICBsLnByZWRhdG9ycy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBBbmltYWwoMSwgbCwgbC53ICogTWF0aC5yYW5kb20oKSwgbC5oICogTWF0aC5yYW5kb20oKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubGFuZC5zdGVwKHRpbWVTdGVwTXMpO1xuICAgICAgICAgICAgdC5jcGx1cy5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmIChuYkl0ZXJhdGlvbnMgPiAwICYmIGkrKyA+IG5iSXRlcmF0aW9ucylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVuZ2luZSwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGVuZ2luZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICovXG5leHBvcnQgY29uc3QgcHJleVByZWRhdG9yID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByZXlQcmVkYXRvclNpbXVsYXRpb24ob3B0cylcbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tIFwiLi4vYmFzZS9HZW9DYW52YXNcIlxuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSBcIi4uL2Jhc2UvU3BhdGlhbEluZGV4XCJcblxuZXhwb3J0IGNsYXNzIEJ1aWxkaW5nIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYSBUaGUgYXJlYVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIGFyZWEpIHtcblxuICAgICAgICAvL3NldCBwb3NpdGlvblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy54ID0geFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy55ID0geVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5hcmVhID0gYXJlYVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHsgbnVtYmVyIH1cbiAgICAgKi9cbiAgICByKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuYXJlYSAvIE1hdGguUEkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCdWlsZGluZ30gYiBcbiAgICAgKi9cbiAgICBvdmVybGFwKGIpIHtcbiAgICAgICAgY29uc3QgZDEgPSBiLnIoKSArIHRoaXMucigpXG4gICAgICAgIGNvbnN0IGQyID0gTWF0aC5oeXBvdCgoYi54IC0gdGhpcy54KSwgKGIueSAtIHRoaXMueSkpO1xuICAgICAgICByZXR1cm4gZDIgPCBkMVxuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NwYXRpYWxJbmRleC48QnVpbGRpbmc+fSBzaW5kZXggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNEaXN0YW5jZSBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjaGVja0NvbGxpc2lvbihzaW5kZXgsIHNEaXN0YW5jZSkge1xuXG4gICAgICAgIC8vZ2V0IGJ1aWxkaW5ncyBhcm91bmQgdXNpbmcgc3BhdGlhbCBpbmRleFxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxCdWlsZGluZz59ICovXG4gICAgICAgIGNvbnN0IHNzID0gc2luZGV4LmdldCh0aGlzLnggLSBzRGlzdGFuY2UsIHRoaXMueSAtIHNEaXN0YW5jZSwgdGhpcy54ICsgc0Rpc3RhbmNlLCB0aGlzLnkgKyBzRGlzdGFuY2UpO1xuXG4gICAgICAgIGZvciAobGV0IGIgb2Ygc3MpIHtcbiAgICAgICAgICAgIGlmIChiID09IHRoaXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxhcChiKSkgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7R2VvQ2FudmFzfSBjcCBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsbFN0eWxlIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJva2VTdHlsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFxuICAgICAqL1xuICAgIGRpc3BsYXkoY3AsIGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIGMyLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGMyLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMyLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yKCksIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgYzIuY2xvc2VQYXRoKCk7XG4gICAgICAgIGMyLmZpbGwoKTtcbiAgICAgICAgYzIuc3Ryb2tlKCk7XG4gICAgfVxuXG5cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBTcGF0aWFsSW5kZXggfSBmcm9tICcuLi9iYXNlL1NwYXRpYWxJbmRleCc7XG5pbXBvcnQgeyBCdWlsZGluZyB9IGZyb20gJy4vQnVpbGRpbmcnO1xuaW1wb3J0IHsgUm9hZE5ldHdvcmsgfSBmcm9tICcuL1JvYWROZXR3b3JrJztcblxuZXhwb3J0IGNsYXNzIE1hcCB7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodywgaCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxCdWlsZGluZz59ICovXG4gICAgICAgIHRoaXMuYnMgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtTcGF0aWFsSW5kZXguPEJ1aWxkaW5nPn0gKi9cbiAgICAgICAgdGhpcy5idUluZGV4ID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Um9hZE5ldHdvcmt9ICovXG4gICAgICAgIHRoaXMucm4gPSBuZXcgUm9hZE5ldHdvcmsodGhpcyk7XG5cbiAgICB9XG5cbiAgICAvKiogKi9cbiAgICBhZGRCdWlsZGluZygpIHtcblxuICAgICAgICAvL2NvbXB1dGUgY2FuZGlkYXRlIGxvY2F0aW9uLCBzaXplIGFuZCB0eXBlIGZvciBuZXh0IGJ1aWxkaW5nXG4gICAgICAgIC8vVE9ETyBsb3cgbG9jYWwgY29uZ2VzdGlvbiBBTkQgZ28gdG8gaGlnaCBkZW5zaXR5ICh3aXRoIGdvb2QgYWNjZXNzIHRvIG90aGVyIHN0dWZmKVxuXG4gICAgICAgIC8vbWFrZSByYW5kb20gYnVpbGRpbmdcbiAgICAgICAgY29uc3QgbWFrZVJhbmRvbUJ1aWxkaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMudyAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5oICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSA0MCArIDIwMCAqIE1hdGgucmFuZG9tKClcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVpbGRpbmcoeCwgeSwgYXJlYSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETyBzaG91bGQgbm90IG92ZXJsYXAgd2l0aCBvdGhlciBlbnRpdGllcyAocm9hZHMsIGJ1aWxkaW5nKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBjb25zdCBzRGlzdGFuY2UgPSAxMDA7XG4gICAgICAgIC8qKiBAdHlwZSB7QnVpbGRpbmd9ICovXG4gICAgICAgIGxldCBidSA9IG1ha2VSYW5kb21CdWlsZGluZygpO1xuICAgICAgICB3aGlsZSAoYnUuY2hlY2tDb2xsaXNpb24odGhpcy5idUluZGV4LCBzRGlzdGFuY2UpKSB7XG4gICAgICAgICAgICBidSA9IG1ha2VSYW5kb21CdWlsZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hZGQgYnVpbGRpbmdcbiAgICAgICAgdGhpcy5icy5wdXNoKGJ1KTtcbiAgICAgICAgdGhpcy5idUluZGV4LmxvYWQoW2J1XSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGVwKCkge1xuXG4gICAgICAgIC8vY29tcHV0ZSBidWlsZGluZyBuZWVkXG4gICAgICAgIGNvbnN0IGJ1TmVlZCA9IDEwO1xuXG4gICAgICAgIC8vdXJiYW5pc2VcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidU5lZWQ7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRCdWlsZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9leHRlbmQgcm9hZCBuZXR3b3JrXG4gICAgICAgIC8vVE9ET1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gXCIuLi9iYXNlL0dlb0NhbnZhc1wiO1xuXG5leHBvcnQgY2xhc3MgUm9hZCB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ2VvbSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2VvbSwgd2lkdGgpIHtcblxuICAgICAgICAvKiogQHR5cGUge2pzdHMuZ2VvbS5HZW9tZXRyeX0gKi9cbiAgICAgICAgdGhpcy5nZW9tID0gZ2VvbVxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoXG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cm9rZVN0eWxlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggXG4gICAgICovXG4gICAgZGlzcGxheShjcCwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCkge1xuICAgICAgICBjb25zdCBjcyA9IHRoaXMuZ2VvbS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBpZiAoY3MubGVuZ3RoID09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdCBjMiA9IGNwLmN0eFxuICAgICAgICBjMi5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICBjMi5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgLy9tb3ZlIHRvIGZpcnN0IHBvaW50XG4gICAgICAgIGxldCBjID0gY3NbMF1cbiAgICAgICAgYzIubW92ZVRvKGMueCwgYy55KTtcblxuICAgICAgICAvL3RyYWNlIGxpbmVcbiAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBjc1tpXVxuICAgICAgICAgICAgYzIubGluZVRvKGMueCwgYy55KTtcbiAgICAgICAgfVxuICAgICAgICBjMi5zdHJva2UoKTtcblxuICAgIH1cblxufVxuIiwiLy9AdHMtY2hlY2tcbmltcG9ydCB7IFJvYWQgfSBmcm9tIFwiLi9Sb2FkXCJcbmltcG9ydCB7IE1hcCB9IGZyb20gXCIuL01hcFwiXG5pbXBvcnQganN0cyBmcm9tIFwianN0c1wiO1xuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSBcIi4uL2Jhc2UvR2VvQ2FudmFzXCI7XG5cbmV4cG9ydCBjbGFzcyBSb2FkTmV0d29yayB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7TWFwfSAqL1xuICAgICAgICB0aGlzLm1hcCA9IG1hcFxuXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPFJvYWQ+fSAqL1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gW11cblxuXG4gICAgICAgIC8vYWRkIHRlc3Qgcm9hZFxuICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbiAgICAgICAgLy9odHRwOi8vYmpvcm5oYXJydGVsbC5naXRodWIuaW8vanN0cy9cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLldLVFJlYWRlcigpXG4gICAgICAgIHZhciBnID0gcmVhZGVyLnJlYWQoJ0xJTkVTVFJJTkcgKDMwIDEwLCAxMCAzMDAsIDQwMCA0MDApJylcbiAgICAgICAgdGhpcy5zZWN0aW9ucy5wdXNoKG5ldyBSb2FkKGcsIDcpKTtcbiAgICB9XG5cbiAgICBidWlsZFJhbmRvbSgpIHtcblxuICAgICAgICBjb25zdCB3ID0gdGhpcy5tYXAud1xuICAgICAgICBjb25zdCBoID0gdGhpcy5tYXAuaFxuXG4gICAgICAgIC8vY29uc3QgciA9IDIgKiB3ICsgMiAqIGggKiBNYXRoLnJhbmRvbSgpO1xuXG5cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXlcbiAgICAgKiBAcGFyYW0ge0dlb0NhbnZhc30gY3AgXG4gICAgICovXG4gICAgZGlzcGxheShjcCkge1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMuc2VjdGlvbnMpXG4gICAgICAgICAgICByLmRpc3BsYXkoY3AsIFwiYmxhY2tcIiwgci53aWR0aCk7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5zZWN0aW9ucylcbiAgICAgICAgICAgIHIuZGlzcGxheShjcCwgXCJ5ZWxsb3dcIiwgci53aWR0aCAtIDMpO1xuICAgIH1cbn1cbiIsIi8vQHRzLWNoZWNrXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuLi9iYXNlL0dlb0NhbnZhcyc7XG5pbXBvcnQgeyBNYXAgfSBmcm9tIFwiLi9NYXBcIjtcblxuLyoqICAqL1xuY2xhc3MgVXJiYW5TaW11bGF0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgb3B0cy5jYW52YXNJZCA9IG9wdHMuY2FudmFzSWQgfHwgXCJ2YWNhbnZhc1wiO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRzLmNhbnZhc0lkKTtcbiAgICAgICAgaWYgKGNhbnZhcyA9PSBudWxsKSB0aHJvdyBcIk5vIGNhbnZhcyBcIiArIG9wdHMuY2FudmFzSWQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgY2FudmFzLm9mZnNldEhlaWdodDtcblxuXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvQ2FudmFzfSAqL1xuICAgICAgICB0aGlzLmNwbHVzID0gbmV3IEdlb0NhbnZhcygpO1xuICAgICAgICB0aGlzLmNwbHVzLmN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgIHRoaXMuY3BsdXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcblxuICAgICAgICBjb25zdCB0aCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3BsdXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLmN0eFxuXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgLy9jbGVhclxuICAgICAgICAgICAgYzIuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgYzIuZmlsbFJlY3QoMCwgMCwgdGgudywgdGguaCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcblxuICAgICAgICAgICAgLy9kaXNwbGF5IHJvYWQgbmV0d29ya1xuICAgICAgICAgICAgdGgubWFwLnJuLmRpc3BsYXkodGhpcyk7XG5cbiAgICAgICAgICAgIC8vZGlzcGxheSBidWlsZGluZ3NcbiAgICAgICAgICAgIGZvciAobGV0IGIgb2YgdGgubWFwLmJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRvRHJhdyhiKSkgY29udGludWVcbiAgICAgICAgICAgICAgICBiLmRpc3BsYXkodGhpcywgXCJsaWdodGdyYXlcIiwgXCJibGFja1wiLCAyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2ZyYW1lXG4gICAgICAgICAgICBjMi5zdHJva2VTdHlsZSA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgIGMyLmxpbmVXaWR0aCA9IDEgKiB0aC5jcGx1cy5nZXRaZigpO1xuICAgICAgICAgICAgYzIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjMi5yZWN0KDAsIDAsIHRoLncsIHRoLmgpO1xuICAgICAgICAgICAgYzIuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7TWFwfSAqL1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAodGhpcy53LCB0aGlzLmgpXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBzaW11bGF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTdGVwTXMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5iSXRlcmF0aW9ucyBcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdGFydCh0aW1lU3RlcE1zID0gMTAsIG5iSXRlcmF0aW9ucyA9IC0xKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubWFwLnN0ZXAoKTtcbiAgICAgICAgICAgIHQuY3BsdXMucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAobmJJdGVyYXRpb25zID4gMCAmJiBpKysgPiBuYkl0ZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VGltZW91dChlbmdpbmUsIDApO1xuICAgICAgICB9O1xuICAgICAgICBlbmdpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9zdG9wXG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy9UT0RPXG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXG4gKi9cbmV4cG9ydCBjb25zdCB1cmJhbiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBVcmJhblNpbXVsYXRpb24ob3B0cylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=